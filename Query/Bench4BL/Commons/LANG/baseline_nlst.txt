367	FastDateFormat thread safety  FastDateFormat has several static HashMaps  These are currently not final  so there is no guarantee that they will be visible to all threads  Patch to follow  Also  as far as I can make out  the class shares SimpleDateFormat instances between threads  It does not document why this is OK  I&amp apos m guessing that it assumes that instances of the SimpleDateFormat class are thread safe provided that they have the same attributes  but this is not documented  If this is the case  it s not clear that it is a valid assumption
459	Issue in HashCodeBuilder which only shows up under high load multi threaded usage  We found we were having problems with HashCodeBuilder under multi threaded high load  I narrowed this down to the following attached test case  When I dug into the code  I found the problem was solved by commenting out the isRegistered method  though this would break the infinite loop problem     I did a lot of other digging that I wont bore you with   So instead I replaced the HashSet with an ArrayList and just added the object  rather than the toIdentityHashCodeInteger object   This results in about 5 lines of change  My suspicion is that System identityHashCode does not return unique values  it is after all a hashcode method   The code assumes it will return a unique value and this causes the problem at high loads  The downside is a List vs  a Set  but I believe this is necessary  I d like to submit this fix and have it verified  and perhaps improved   I am convinced it is a necessary fix which we have seen show up under high loads  Kindest regards  Andrew
481	Possible race conditions in hashCode of the range classesThe hashCode   methods of the range classes look very suspicious to me  The value is lazily initialized  but the calculation is done _on the cached value  With some unlucky timing a caller may get an incomplete hash  An unlucky sequence of Code could be something like T1         if  hashCode    0     true T1             hashCode   17  T2          if  hashCode    0     now false because hashCode was already set to 17 T2          return hashCode     return 17 T1             hashCode   37   hashCode            where T1 and T2 are different threads accessing the method in parallel and T2 gets the wrong hash  17   Affected classes are org apache commons lang math DoubleRange org apache commons lang math FloatRange org apache commons lang math IntRange org apache commons lang math LongRange org apache commons lang math NumberRange org apache commons lang math Range Possible fix  calculate the hash on a temporary variable and finally assign it to the member
584	ExceptionUtils uses mutable lock targetExceptionUtils uses a mutable lock target  both the methods removeCauseMethodName   and addCauseMethodName   take out a lock on CAUSE_METHOD_NAMES but then modify it  That doesn t work   locks need to be immutable
1230	Remove unnecessary synchronization from registry lookup in EqualsBuilder and HashCodeBuilder  We re running into contention issues in registry lookup in EqualsBuilder and HashCodeBuilder  We believe the synchronization for the registry lookup is unnecessary  ThreadLocals are thread safe  each thread gets own value  Therefore no other thread can read or change the value of the current thread  As a consequence access to ThreadLocals does not need to be synchronized  Since IDKey uses object identity and the identity hashCode it does use neither EqualsBuilder nor HashCodeBuilder  This means that recursive calls to register and unregister are not possible even if the registered objects use EqualsBuilder or HashCodeBuilder  This also makes re reading redundant  The issue was likely introduced in 2 5 by LANG 586 but 2 6 is the oldest version we can select
1251	SerializationUtils ClassLoaderAwareObjectInputStream should use static initializer to initialize primitiveTypes map  SerializationUtils ClassLoaderAwareObjectInputStream should use static initializer to initialize primitiveTypes map because initializing the map in the constructor of ClassLoaderAwareObjectInputStream would break thread safety  java util HashMap is not thread safe