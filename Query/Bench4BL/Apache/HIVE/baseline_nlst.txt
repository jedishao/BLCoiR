545	Use ArrayList instead of Vector in single threaded  Hive codeMost of the Hive code is single threaded  but sometimes we are using Vector instead of the more efficient ArrayList  See http   java sun com j2se 1 5 0 docs api java util ArrayList html  This class  ArrayList  is roughly equivalent to Vector  except that it is unsynchronized
3057	metastore HiveMetaStore HMSHandler should set the thread local raw store to null in shutdown    The shutdown   function of metastore HiveMetaStore HMSHandler does not set the thread local RawStore variable  in threadLocalMS  to null  Subsequent getMS   calls may get the wrong RawStore object
3408	A race condition is caused within QueryPlan classHive s threads are stopped at HashMap getEntry     that is used within QueryPlan extractCounters   and QueryPlan updateCountersInQueryPlan    It seems that a race condition problem of a HashSet object is caused when extractCounters   and updateCountersInQueryPlan   are concurrently executed  I hit the problem with Hive 0 7 1 but  I think that it also is caused with 0 8 1  The problem is reported by several persons on mailing list  http   mail archives apache org mod_mbox hive dev 201201 mbox  3CCAKTRiE 3x31FDy 3F0c jZSXQrhxBgT4DOyfZddm7sdX cu Zg mail gmail com 3E http   mail archives apache org mod_mbox hive user 201202 mbox  3CFC28CCD9 9C75 4F8D B272 3D50F663A634 gmail com 3E The following is a part of my thread dump    Thread 1091  prio 10 tid 0x00007fd17112b000 nid 0x1100 runnable  0x00007fd175f60000  java lang Thread State  RUNNABLE at java util HashMap getEntry HashMap java 347  at java util HashMap containsKey HashMap java 335  at java util HashSet contains HashSet java 184  at org apache hadoop hive ql QueryPlan extractCounters QueryPlan java 342  at org apache hadoop hive ql QueryPlan getQueryPlan QueryPlan java 419  at org apache hadoop hive ql QueryPlan toString QueryPlan java 592  at org apache hadoop hive ql history HiveHistory logPlanProgress HiveHistory java 493  at org apache hadoop hive ql exec ExecDriver progress ExecDriver java 395  at org apache hadoop hive ql exec ExecDriver execute ExecDriver java 686  at org apache hadoop hive ql exec MapRedTask execute MapRedTask java 123  at org apache hadoop hive ql exec Task executeTask Task java 130  at org apache hadoop hive ql exec TaskRunner runSequential TaskRunner java 57  at org apache hadoop hive ql exec TaskRunner run TaskRunner java 47   Thread 1090  prio 10 tid 0x00007fd17012f000 nid 0x10ff runnable  0x00007fd175152000  java lang Thread State  RUNNABLE at java util HashMap getEntry HashMap java 347  at java util HashMap containsKey HashMap java 335  at java util HashSet contains HashSet java 184  at org apache hadoop hive ql QueryPlan updateCountersInQueryPlan QueryPlan java 297  at org apache hadoop hive ql QueryPlan getQueryPlan QueryPlan java 420  at org apache hadoop hive ql QueryPlan toString QueryPlan java 592  at org apache hadoop hive ql history HiveHistory logPlanProgress HiveHistory java 493  at org apache hadoop hive ql exec ExecDriver progress ExecDriver java 395  at org apache hadoop hive ql exec ExecDriver execute ExecDriver java 686  at org apache hadoop hive ql exec MapRedTask execute MapRedTask java 123  at org apache hadoop hive ql exec Task executeTask Task java 130  at org apache hadoop hive ql exec TaskRunner runSequential TaskRunner java 57  at org apache hadoop hive ql exec TaskRunner run TaskRunner java 47
4000	Hive client goes into infinite loop at 100  cpu  The Hive client starts multiple threads to track the progress of the MapReduce jobs  Unfortunately those threads access several static HashMaps that are not protected by locks  When the HashMaps are modified  they sometimes cause race conditions that lead to the client threads getting stuck in infinite loops
7011	HiveInputFormat s split generation isn t thread safe  Tez will do split generation in parallel  Need to protect the inputformat cache against concurrent access
7341	Support for Table replication across HCatalog instances  The HCatClient currently doesn t provide very much support for replicating HCatTable definitions between 2 HCatalog Server  i e  Hive metastore  instances  Systems similar to Apache Falcon might find the need to replicate partition data between 2 clusters  and keep the HCatalog metadata in sync between the two  This poses a couple of problems   The definition of the source table might change  in column schema  I O formats  record formats  serde parameters  etc    The system will need a way to diff 2 tables and update the target metastore with the changes  E g   targetTable resolve  sourceTable  targetTable diff sourceTable      hcatClient updateTableSchema dbName  tableName  targetTable    The current HCatClient addPartitions   API requires that the partition s schema be derived from the table s schema  thereby requiring that the table schema be resolved before partitions with the new schema are added to the table  This is problematic  because it introduces race conditions when 2 partitions with differing column schemas  e g  right after a schema change  are copied in parallel  This can be avoided if each HCatAddPartitionDesc kept track of the partition s schema  in flight  The source and target metastores might be running different incompatible versions of Hive   The impending patch attempts to address these concerns  with some caveats    HCatTable now has  a diff   method  to compare against another HCatTable instance  a resolve diff  method to copy over specified table attributes from another HCatTable  a serialize deserialize mechanism  via HCatClient serializeTable   and HCatClient deserializeTable     so that HCatTable instances constructed in other class loaders may be used for comparison    HCatPartition now provides finer grained control over a Partition s column schema  StorageDescriptor settings  etc  This allows partitions to be copied completely from source  with the ability to override specific properties if required  e g  location   HCatClient updateTableSchema   can now update the entire table definition  not just the column schema  I ve cleaned up and removed most of the redundancy between the HCatTable  HCatCreateTableDesc and HCatCreateTableDesc Builder  The prior API failed to separate the table attributes from the add table operation s attributes  By providing fluent interfaces in HCatTable  and composing an HCatTable instance in HCatCreateTableDesc  the interfaces are cleaner ish   The old setters are deprecated  in favour of those in HCatTable  Likewise  HCatPartition and HCatAddPartitionDesc   I ll post a patch for trunk shortly
8440	Hiveserver block query  In our environment Hiveserver handle approximately 15000 jobs per day  Sometimes we found a large number of  ETL tasks wait in our ETL schedule  queue to runIn this situation only few Hadoop Job running in Hadoop cluster many maps and reduces slots free  We view Hiveserver heap found Hiveserver block a large number of query   pool 1 thread 17903  prio 10 tid 0x00007f89589c8000 nid 0x13865 waiting for monitor entry  0x00007f893413b000  java lang Thread State  BLOCKED  on object monitor  at org apache hadoop hive ql Driver runInternal Driver java 977   waiting to lock &lt 0x00000006000ac458&gt   a java lang Object  at org apache hadoop hive ql Driver run Driver java 888  at org apache hadoop hive service HiveServer HiveServerHandler execute HiveServer java 198  at org apache hadoop hive service ThriftHive Processor execute getResult ThriftHive java 644  at org apache hadoop hive service ThriftHive Processor execute getResult ThriftHive java 628  at org apache thrift ProcessFunction process ProcessFunction java 39  at org apache thrift TBaseProcessor process TBaseProcessor java 39  at org apache thrift server TThreadPoolServer WorkerProcess run TThreadPoolServer java 206  at java util concurrent ThreadPoolExecutor Worker runTask ThreadPoolExecutor java 886  at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 908  at java lang Thread run Thread java 662   It is a problem of HiveServer cannot handle concurrent requests from more than one client  Why HiveServer cannot handle concurrent requests  https   github com apache hive blob branch 0 12 ql src java org apache hadoop hive ql Driver java L975 Under code in org apache hadoop hive ql cause Hiveserver cannot handle concurrent requests  int ret  synchronized  compileMonitor     ret   compile command
9199	Excessive exclusive lock used in some DDLs with DummyTxnManager  In DummyTxnManager  the lockMode for a WriteEntity  e g  database  table  is determined by  complete  instead of its writeType  But since DDL output WriteEntity is usually complete  some DDL operations might be given exclusive locks which are actually not needed  which causes unnecessary locking contention  For example  in createTable  DummyTxnManager suggests an exclusive lock to table database writeentity since it is complete
9598	java lang IllegalMonitorStateException java util concurrent locks ReentrantLock Sync tryRelease  if ResultSet closed called after Statement close calledhttp   docs oracle com javase 7 docs api java sql ResultSet html close   http   docs oracle com javase 7 docs api java sql Statement html close   Statement stmt  try   stmt   dbConnection createStatement    stmt executeQuery  select  from t    ResultSet rs   stmt getResultSet    stmt close    if  rs !  null    System out println  IS NOT NULL       Hive does not implement isClosed     				if  !rs isClosed         					System out println  IS NOT CLOSED       				  rs close        catch  SQLException e        TODO Auto generated catch block  e printStackTrace        Exception in thread  main  java lang IllegalMonitorStateException at java util concurrent locks ReentrantLock Sync tryRelease ReentrantLock java 166  at java util concurrent locks AbstractQueuedSynchronizer release AbstractQueuedSynchronizer java 1271  at java util concurrent locks ReentrantLock unlock ReentrantLock java 471  at org apache hive jdbc HiveStatement closeClientOperation HiveStatement java 175  at org apache hive jdbc HiveQueryResultSet close HiveQueryResultSet java 293   D  JDBC Hortonworks_Hive13 commons configuration 1 6 jar  D  JDBC Hortonworks_Hive13 commons logging 1 1 3 jar  D  JDBC Hortonworks_Hive13 hadoop common 2 4 0 2 1 1 0 385 jar  D  JDBC Hortonworks_Hive13 hive exec 0 13 0 2 1 1 0 385 jar  D  JDBC Hortonworks_Hive13 hive jdbc 0 13 0 2 1 1 0 385 jar  D  JDBC Hortonworks_Hive13 hive service 0 13 0 2 1 1 0 385 jar  D  JDBC Hortonworks_Hive13 httpclient 4 2 5 jar  D  JDBC Hortonworks_Hive13 httpcore 4 2 5 jar  D  JDBC Hortonworks_Hive13 libfb303 0 9 0 jar  D  JDBC Hortonworks_Hive13 libthrift 0 9 0 jar  D  JDBC Hortonworks_Hive13 log4j 1 2 16 jar  D  JDBC Hortonworks_Hive13 slf4j api 1 7 5 jar  D  JDBC Hortonworks_Hive13 slf4j log4j12 1 7 5 jar
10483	insert overwrite partition deadlocks on itself with DbTxnManagerinsert overwrite ta partition part xxxx  select xxx from tb join ta where part xxxx  It seems like the Shared conflicts with the Exclusive lock for Insert Overwrite even though both are part of the same txn  More precisely insert overwrite requires X lock on partition and the read side needs an S lock on the query  A simpler case is insert overwrite ta partition part xxxx  select   from ta
11036	Race condition in DataNucleus makes Metastore to hangUnder moderate to high concurrent query workload Metastore gets deadlocked in DataNucleus
11616	DelegationTokenSecretManager reuses the same objectstore  which has concurrency issues  sometime in metastore log  will get below exception   after analysis  we found that   when hivemetastore start  the DelegationTokenSecretManager will maintain the same objectstore  see here  saslServer startDelegationTokenSecretManager conf   baseHandler getMS     ServerMode METASTORE    this lead to the cocurrent issue   2015 08 18 20 59 10 520   ERROR   pool 6 thread 200   Error occurred during processing of message    org apache thrift server TThreadPoolServer WorkerProcess run TThreadPoolServer java 296   org apache hadoop hive thrift DelegationTokenStore TokenStoreException  org datanucleus transaction NucleusTransactionException  Invalid state  Transaction has already started  at org apache hadoop hive thrift DBTokenStore invokeOnRawStore DBTokenStore java 154   at org apache hadoop hive thrift DBTokenStore getToken DBTokenStore java 88   at org apache hadoop hive thrift TokenStoreDelegationTokenSecretManager retrievePassword TokenStoreDelegationTokenSecretManager java 112   at org apache hadoop hive thrift TokenStoreDelegationTokenSecretManager retrievePassword TokenStoreDelegationTokenSecretManager java 56   at org apache hadoop hive thrift HadoopThriftAuthBridge Server SaslDigestCallbackHandler getPassword HadoopThriftAuthBridge java 565   at org apache hadoop hive thrift HadoopThriftAuthBridge Server SaslDigestCallbackHandler handle HadoopThriftAuthBridge java 596   at com sun security sasl digest DigestMD5Server validateClientResponse DigestMD5Server java 589   at com sun security sasl digest DigestMD5Server evaluateResponse DigestMD5Server java 244   at org apache thrift transport TSaslTransport SaslParticipant evaluateChallengeOrResponse TSaslTransport java 539   at org apache thrift transport TSaslTransport open TSaslTransport java 283   at org apache thrift transport HiveTSaslServerTransport open HiveTSaslServerTransport java 133   at org apache thrift transport HiveTSaslServerTransport Factory getTransport HiveTSaslServerTransport java 261   at org apache hadoop hive thrift HadoopThriftAuthBridge Server TUGIAssumingTransportFactory 1 run HadoopThriftAuthBridge java 739   at org apache hadoop hive thrift HadoopThriftAuthBridge Server TUGIAssumingTransportFactory 1 run HadoopThriftAuthBridge java 736   at java security AccessController doPrivileged Native Method   at javax security auth Subject doAs Subject java 360   at org apache hadoop security UserGroupInformation doAs UserGroupInformation java 1652   at org apache hadoop hive thrift HadoopThriftAuthBridge Server TUGIAssumingTransportFactory getTransport HadoopThriftAuthBridge java 736   at org apache thrift server TThreadPoolServer WorkerProcess run TThreadPoolServer java 268   at java util concurrent ThreadPoolExecutor runWorker ThreadPoolExecutor java 1142   at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 617   at java lang Thread run Thread java 745   Caused by  org datanucleus transaction NucleusTransactionException  Invalid state  Transaction has already started  at org datanucleus transaction TransactionManager begin TransactionManager java 47   at org datanucleus TransactionImpl begin TransactionImpl java 131   at org datanucleus api jdo JDOTransaction internalBegin JDOTransaction java 88   at org datanucleus api jdo JDOTransaction begin JDOTransaction java 80   at org apache hadoop hive metastore ObjectStore openTransaction ObjectStore java 420   at org apache hadoop hive metastore ObjectStore getToken ObjectStore java 6455   at sun reflect GeneratedMethodAccessor8 invoke Unknown Source   at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43   at java lang reflect Method invoke Method java 497   at org apache hadoop hive metastore RawStoreProxy invoke RawStoreProxy java 98   at com sun proxy  Proxy4 getToken Unknown Source   at sun reflect GeneratedMethodAccessor7 invoke Unknown Source   at sun reflect DelegatingMethodAccessorImpl invoke DelegatingMethodAccessorImpl java 43   at java lang reflect Method invoke Method java 497   at org apache hadoop hive thrift DBTokenStore invokeOnRawStore DBTokenStore java 146       21 more
12238	Vectorization  Thread safety errors in VectorUDFDate   Caused by  java lang NumberFormatException  For input string      at java lang NumberFormatException forInputString NumberFormatException java 65   at java lang Long parseLong Long java 601   at java lang Long parseLong Long java 631   at java text DigitList getLong DigitList java 195   at java text DecimalFormat parse DecimalFormat java 2051   at java text SimpleDateFormat subParse SimpleDateFormat java 1869   at java text SimpleDateFormat parse SimpleDateFormat java 1514         at java text DateFormat parse DateFormat java 364   at org apache hadoop hive ql exec vector expressions VectorUDFDateString 1 evaluate VectorUDFDateString java 48   at org apache hadoop hive ql exec vector expressions StringUnaryUDF evaluate StringUnaryUDF java 90         at org apache hadoop hive ql exec vector expressions VectorExpression evaluateChildren VectorExpression java 121   at org apache hadoop hive ql exec vector expressions StringGroupColConcatStringScalar evaluate StringGroupColConcatStringScalar java 50   at org apache hadoop hive ql exec vector expressions VectorExpression evaluateChildren VectorExpression java 121   at org apache hadoop hive ql exec vector udf VectorUDFAdaptor evaluate VectorUDFAdaptor java 112   at org apache hadoop hive ql exec vector expressions VectorExpression evaluateChildren VectorExpression java 121   at org apache hadoop hive ql exec vector expressions VectorUDFTimestampFieldLong evaluate VectorUDFTimestampFieldLong java 93   at org apache hadoop hive ql exec vector VectorSelectOperator process VectorSelectOperator java 123       22 more
12248	The rawStore used in DBTokenStore should be thread safe  A non thread safe implementation of RawStore  particularly ObjectStore  set in DBTokenStore is being shared by multi threads  which causes the race condition in DataNuclues to access the backend DB  The DN PersistenceManager PM  in ObjectStore is not thread safe  so DBTokenStore should use a ThreadLocal ObjectStore  Following errors might be root caused by the race condition in DN PM   Object of type  org apache hadoop hive metastore model MDelegationToken  is detached  Detached objects cannot be used with this operation   org datanucleus exceptions ObjectDetachedException  Object of type  org apache hadoop hive metastore model MDelegationToken  is detached  Detached objects cannot be used with this operation   at org datanucleus ExecutionContextImpl assertNotDetached ExecutionContextImpl java 5728   at org datanucleus ExecutionContextImpl retrieveObject ExecutionContextImpl java 1859   at org datanucleus ExecutionContextThreadedImpl retrieveObject ExecutionContextThreadedImpl java 203   at org datanucleus api jdo JDOPersistenceManager jdoRetrieve JDOPersistenceManager java 605   at org datanucleus api jdo JDOPersistenceManager retrieveAll JDOPersistenceManager java 693   at org datanucleus api jdo JDOPersistenceManager retrieveAll JDOPersistenceManager java 713   at org apache hadoop hive metastore ObjectStore getAllTokenIdentifiers ObjectStore java 6517
12266	When client exists abnormally  it doesn t release ACID locks if you start Hive CLI  locking enabled  and run some command that acquires locks and C the shell before command completes the locks for the command remain until they timeout  I believe Beeline has the same issue  Need to add proper hooks to release locks when command dies   As much as possible
12409	make sure SessionState initTxnMgr   is thread safe  make this method synchronized since HS2 may run multiple threads in a Session   see HIVE 11402
12529	HiveTxnManager acquireLocks   should not block foreverCurrently  in DbTxnManager this method will block until all competing locks have gone away  This is not appropriate for all clients   There should be a way to specify a max wait time  It will throw an exception on timeout  given how current method signature is written
12620	Misc improvement to Acid module  DbLockManger unlock     if this fails  due to no such lock in turn due to timeout  the lock is not removed from DbLockManger internal tracking  Add logic to DBLockManager to detect if there is attempt to interleave transactions or locks from different statements for read only auto commit mode  TxnHandler checkLock   can use 1 connection instead of 2  TxnHandler timeOutLocks     refactor so that it can log which locks were expired  simplifies debugging   TxnHandler getTxnIdFromLockId     include lock id if it s not found  TxnHandler checkRetryable     log exception it saw  TxnHandler lock     throw new MetaException  Couldn&amp apos t find a lock we just created!      include lockid
12768	Thread safety  binary sortable serde decimal deserialization  We see thread safety issues due to static decimal buffer in binary sortable serde
12797	Synchronization issues with tez llap session pool in hs2  The changes introduced as part of HIVE 12674 causes issues while shutting down hs2 when session pools are used     java util ConcurrentModificationException  at java util LinkedList ListItr checkForComodification LinkedList java 966  ~   1 8 0_45   at java util LinkedList ListItr remove LinkedList java 921  ~   1 8 0_45   at org apache hadoop hive ql exec tez TezSessionPoolManager stop TezSessionPoolManager java 288  ~ hive exec 2 0 0 2 3 5 0 79 jar 2 0 0 2 3 5 0 79   at org apache hive service server HiveServer2 stop HiveServer2 java 479   hive jdbc 2 0 0 2 3 5 0 79 standalone jar 2 0 0 2 3 5 0 79   at org apache hive service server HiveServer2 2 run HiveServer2 java 183   hive jdbc 2 0 0 2 3 5 0 79 standalone jar 2 0 0 2 3 5 0 79
12904	LLAP  deadlock in task scheduling  Thread 34107   state   BLOCKED     org apache hadoop hive llap daemon impl TaskExecutorService TaskWrapper isInWaitQueue    bci 0  line 690  Compiled frame     org apache hadoop hive llap daemon impl TaskExecutorService finishableStateUpdated org apache hadoop hive llap daemon impl TaskExecutorService TaskWrapper  boolean   bci 8  line 485  Compiled frame     org apache hadoop hive llap daemon impl TaskExecutorService access 1500 org apache hadoop hive llap daemon impl TaskExecutorService  org apache hadoop hive llap daemon impl TaskExecutorService TaskWrapper  boolean   bci 3  line 78  Compiled frame     org apache hadoop hive llap daemon impl TaskExecutorService TaskWrapper finishableStateUpdated boolean   bci 27  line 733  Compiled frame     org apache hadoop hive llap daemon impl QueryInfo FinishableStateTracker sourceStateUpdated java lang String   bci 76  line 210  Compiled frame     org apache hadoop hive llap daemon impl QueryInfo sourceStateUpdated java lang String   bci 5  line 164  Compiled frame     org apache hadoop hive llap daemon impl QueryTracker registerSourceStateChange java lang String  java lang String  org apache hadoop hive llap daemon rpc LlapDaemonProtocolProtos SourceStateProto   bci 34  line 228  Compiled frame     org apache hadoop hive llap daemon impl ContainerRunnerImpl sourceStateUpdated org apache hadoop hive llap daemon rpc LlapDaemonProtocolProtos SourceStateUpdatedRequestProto   bci 47  line 255  Compiled frame     org apache hadoop hive llap daemon impl LlapDaemon sourceStateUpdated org apache hadoop hive llap daemon rpc LlapDaemonProtocolProtos SourceStateUpdatedRequestProto   bci 5  line 328  Compiled frame     org apache hadoop hive llap daemon impl LlapDaemonProtocolServerImpl sourceStateUpdated com google protobuf RpcController  org apache hadoop hive llap daemon rpc LlapDaemonProtocolProtos SourceStateUpdatedRequestProto   bci 5  line 105  Compiled frame     org apache hadoop hive llap daemon rpc LlapDaemonProtocolProtos LlapDaemonProtocol 2 callBlockingMethod com google protobuf Descriptors MethodDescriptor  com google protobuf RpcController  com google protobuf Message   bci 80  line 13067  Compiled frame     org apache hadoop ipc ProtobufRpcEngine Server ProtoBufRpcInvoker call org apache hadoop ipc RPC Server  java lang String  org apache hadoop io Writable  long   bci 246  line 616  Compiled frame     org apache hadoop ipc RPC Server call org apache hadoop ipc RPC RpcKind  java lang String  org apache hadoop io Writable  long   bci 9  line 969  Compiled frame     org apache hadoop ipc Server Handler 1 run    bci 38  line 2151  Compiled frame     org apache hadoop ipc Server Handler 1 run    bci 1  line 2147  Compiled frame     java security AccessController doPrivileged java security PrivilegedExceptionAction  java security AccessControlContext   bci 0  Compiled frame     javax security auth Subject doAs javax security auth Subject  java security PrivilegedExceptionAction   bci 42  line 422  Compiled frame     org apache hadoop security UserGroupInformation doAs java security PrivilegedExceptionAction   bci 14  line 1657  Compiled frame     org apache hadoop ipc Server Handler run    bci 315  line 2145  Interpreted frame       and      Thread 34500   state   BLOCKED     org apache hadoop hive llap daemon impl QueryInfo FinishableStateTracker unregisterForUpdates org apache hadoop hive llap daemon FinishableStateUpdateHandler   bci 0  line 195  Compiled frame     org apache hadoop hive llap daemon impl QueryInfo unregisterFinishableStateUpdate org apache hadoop hive llap daemon FinishableStateUpdateHandler   bci 5  line 160  Compiled frame     org apache hadoop hive llap daemon impl QueryFragmentInfo unregisterForFinishableStateUpdates org apache hadoop hive llap daemon FinishableStateUpdateHandler   bci 5  line 143  Compiled frame     org apache hadoop hive llap daemon impl TaskExecutorService TaskWrapper maybeUnregisterForFinishedStateNotifications    bci 20  line 681  Compiled frame     org apache hadoop hive llap daemon impl TaskExecutorService InternalCompletionListener onSuccess org apache tez runtime task TaskRunner2Result   bci 32  line 548  Compiled frame     org apache hadoop hive llap daemon impl TaskExecutorService InternalCompletionListener onSuccess java lang Object   bci 5  line 535  Compiled frame     com google common util concurrent Futures 4 run    bci 55  line 1149  Compiled frame     java util concurrent ThreadPoolExecutor runWorker java util concurrent ThreadPoolExecutor Worker   bci 95  line 1142  Compiled frame     java util concurrent ThreadPoolExecutor Worker run    bci 5  line 617  Interpreted frame     java lang Thread run    bci 11  line 745  Interpreted frame      IPC Server handler 0 on 15001    waiting to lock Monitor 0x00007f5d322ecb08  Object 0x00007f67032cd2c0  a org apache hadoop hive llap daemon impl TaskExecutorService TaskWrapper    which is held by  ExecutionCompletionThread  0    ExecutionCompletionThread  0    waiting to lock Monitor 0x00007f6066b9e8c8  Object 0x00007f66b6570200  a org apache hadoop hive llap daemon impl QueryInfo FinishableStateTracker    which is held by  IPC Server handler 0 on 15001     Found a total of 1 deadlock       Looks like it&amp apos s caused by synchronized blocks   TaskWrapper   public synchronized void maybeUnregisterForFinishedStateNotifications    Eventually calls  FinishableStateTracker  synchronized void unregisterForUpdates FinishableStateUpdateHandler handler       and  FST  synchronized void sourceStateUpdated String sourceName       eventually calls  public synchronized boolean isInWaitQueue        The latter returns the boolean  so it definitely doesn t need synchronized  however I don t know if there are other similar issues and what is necessary inside sync blocks  perhaps there s a better fix  Overall I d say synch methods on objects that call any other non trivial objects should not be used  Perhaps for now it would be good to replace all sync methods by sync blocks that cover entire method  as well as remove the unnecessary ones like the isWait    one  Then the scope of the blocks can be adjusted based on logic in future
12926	Another synchronization issue with tez llap session pool in hs2  The changes introduced as part of HIVE 12674 causes issues while shutting down hs2 when session pools are used    java util ConcurrentModificationException  at java util LinkedList ListItr checkForComodification LinkedList java 966  ~   1 8 0_45   at java util LinkedList ListItr remove LinkedList java 921  ~   1 8 0_45   at org apache hadoop hive ql exec tez TezSessionPoolManager stop TezSessionPoolManager java 288  ~ hive exec 2 0 0 2 3 5 0 79 jar 2 0 0 2 3 5 0 79   at org apache hive service server HiveServer2 stop HiveServer2 java 479   hive jdbc 2 0 0 2 3 5 0 79 standalone jar 2 0 0 2 3 5 0 79   at org apache hive service server HiveServer2 2 run HiveServer2 java 183   hive jdbc 2 0 0 2 3 5 0 79 standalone jar 2 0 0 2 3 5 0 79
12927	HBase metastore  sequences should be one per row  not all in one row  long getNextSequence byte   sequence  throws IOException     Is not safe in presence of any concurrency  It should use HBase increment API
12996	Temp tables shouldn t be locked  Internally  INSERT INTO     VALUES statements use temp table to accomplish its functionality  But temp tables shouldn t be stored in the metastore tables for ACID  because they are by definition only visible inside the session that created them  and we don t allow multiple threads inside a session  If a temp table is used in a query  it should be ignored by lock manager     mysql&gt  select   from COMPLETED_TXN_COMPONENTS                                                                              CTC_TXNID   CTC_DATABASE   CTC_TABLE               CTC_PARTITION                                                                                          1   acid           t1                      NULL                          1   acid           values__tmp__table__1   NULL                          2   acid           t1                      NULL                          2   acid           values__tmp__table__2   NULL                          3   acid           values__tmp__table__3   NULL                          3   acid           t1                      NULL                          4   acid           values__tmp__table__1   NULL                          4   acid           t2p                     ds today                      5   acid           values__tmp__table__1   NULL                          5   acid           t3p                     ds today hour 12
13013	Further Improve concurrency in TxnHandler  There are still a few operations in TxnHandler that run at Serializable isolation  Most or all of them can be dropped to READ_COMMITTED now that we have SELECT     FOR UPDATE support  This will reduce number of deadlocks in the DBs
13213	make DbLockManger work for non acid resources  for example  insert into T values      If T is an ACID table we acquire Read lock  but for non acid table it should acquire Exclusive lock
13395	Lost Update problem in ACIDACID users can run into Lost Update problem  In Hive 1 2  Driver recordValidTxns    which records the snapshot to use for the query  is called in Driver compile    Now suppose to concurrent  update T set x   x   1  are executed    for simplicity assume there is exactly 1 row in T  What can happen is that both compile at the same time  more precisely before acquireLocksAndOpenTxn   in runInternal   is called  and thus will lock in the same snapshot  say the value of x   7 in this snapshot  Now 1 will get the lock on the row  the second will block  Now 1  makes x   8 and commits  Now 2 proceeds and makes x   8 again since in it s snapshot x is still 7  This specific issue is solved in Hive 1 3 2 0  HIVE 11077 which is a large patch that deals with multi statement txns  by moving recordValidTxns   after locks are acquired which reduces the likelihood of this but doesn t eliminate the problem   Even in 1 3 version of the code  you could have the same issue   Assume the same 2 queries  Both start a txn  say txnid 9 and 10   Say 10 gets the lock first  9 blocks  10 updates the row  so x   8  and thus ReaderKey currentTransactionId 10  10 commits  Now 9 can proceed and it will get a snapshot that includes 10  i e  it will see x   8 and it will write x   9  but it will set ReaderKey currentTransactionId   9   Thus when merge logic runs  it will see x   8 is the later version of this row  i e  lost update  The problem is that locks alone are insufficient for MVCC architecture   At lower level Row ID has  originalTransactionId  rowid  bucket id  currentTransactionId  and since on update delete we do a table scan  we could check that we are about to write a row with currentTransactionId &lt   currentTransactionId of row we ve read  and fail the query   Currently  currentTransactionId is not surfaced at higher level where this check can be made  This would not work  efficiently  longer term where we want to support fast update on user defined PK vis streaming ingest  Also  this would not work with multi statement txns since in that case we d lock in the snapshot at the start of the txn  but then 2nd  3rd etc queries would use the same snapshot and the locks for these queries would be acquired after the snapshot is locked in so this would be the same situation as pre HIVE 11077   A more robust solution  commonly used with MVCC  is to keep track of start and commit time  logical counter  or each transaction to detect if two txns overlap   The 2nd part is to keep track of write set  i e  which data  rows  partitions  whatever appropriate level of granularity is  were modified by any txn and if 2 txns overlap in time and wrote the same element  abort later one   This is called first committer wins rule   This requires a MS DB schema change It would be most convenient to use the same sequence for txnId  start and commit time  in which case txnid start time    In this case we d need to add 1 filed to TXNS table   The complication here is that we ll be using elements of the sequence faster and they are used as part of file name of delta and base dir and currently limited to 7 digits which can be exceeded   So this would require some thought to handling upgrade migration  Also  write set tracking requires either additional metastore table or keeping info in HIVE_LOCKS around longer with new state   In the short term  on SQL side of things we could  in auto commit mode only  acquire the locks first and then open the txn AND update these locks with txn id  This implies another Thrift change to pass in lockId to openTxn  The same would not work for Streaming API since it opens several txns at once and then acquires locks for each   Not sure if that s is an issue or not since Streaming only does Insert   Either way this feels hacky   Here is one simple example why we need Write Set tracking for multi statement txns Consider transactions T 1 and T 2  T 1  r 1 x   &gt  w 1 y   &gt  c 1 T 2  w 2 x   &gt  w 2 y   &gt  c 2 Suppose the order of operations is r 1 x  w 2 x      then a conventional R W lock manager w o MVCSS will block the write from T 2 With MVCC we don t want readers to interfere with writers and so the following schedule is possible  because Hive s semi shared  write  don t conflict with shared  read  locks  in Hive s current implementation  r 1 x  w 2 x  w 2 y  c 2 w 1 y  c 1 By the time w 1 y  happens  T 2 has committed and released it s locks   But this is a lost update if c 1 is allowed to commit   That s where write set tracking comes in
13458	Heartbeater doesn&apos t fail query when heartbeat fails  When a heartbeat fails to locate a lock  it should fail the current query  That doesn t happen  which is a bug  Another thing is  we need to make sure stopHeartbeat really stops the heartbeat  i e  no additional heartbeat will be sent  since that will break the assumption and cause the query to fail
13512	Make initializing dag ids in TezWork thread safe for parallel compilationWhen parallel query compilation is enabled  it is possible for concurrent running threads to create TezWork objects that have the same dag id  This is because the counter used to obtain the next dag id is not thread safe  The counter should be an AtomicInteger rather than an int   private static int counter        public TezWork String queryId  Configuration conf     this dagId   queryId            counter
13599	LLAP  Incorrect handling of the preemption queue on finishable state updates  When running some tests with pre emption enabled  got the following exception  Looks like a race condition when removing items from pre emption queue     16 04 23 23 32 00  Wait Queue Scheduler 0    ERROR impl TaskExecutorService   Wait queue scheduler worker exited with failure!  java util NoSuchElementException  at java util AbstractQueue remove AbstractQueue java 117  ~   1 7 0_55   at org apache hadoop hive llap daemon impl TaskExecutorService removeAndGetFromPreemptionQueue TaskExecutorService java 568  ~ hive llap server 2 1 0 SNAPSHOT jar 2 1 0 SNAPSHOT   at org apache hadoop hive llap daemon impl TaskExecutorService handleScheduleAttemptedRejection TaskExecutorService java 493  ~ hive llap server 2 1 0 SNAPSHOT jar 2 1 0 SNAPSHOT   at org apache hadoop hive llap daemon impl TaskExecutorService access 1100 TaskExecutorService java 81  ~ hive llap server 2 1 0 SNAPSHOT jar 2 1 0 SNAPSHOT   at org apache hadoop hive llap daemon impl TaskExecutorService WaitQueueWorker run TaskExecutorService java 285  ~ hive llap server 2 1 0 SNAPSHOT jar 2 1 0 SNAPSHOT   at java util concurrent Executors RunnableAdapter call Executors java 471  ~   1 7 0_55   at java util concurrent FutureTask run FutureTask java 262     1 7 0_55   at java util concurrent ThreadPoolExecutor runWorker ThreadPoolExecutor java 1145     1 7 0_55   at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 615     1 7 0_55   at java lang Thread run Thread java 745     1 7 0_55   16 04 23 23 32 00  Wait Queue Scheduler 0    INFO impl LlapDaemon   UncaughtExceptionHandler invoked  16 04 23 23 32 00  Wait Queue Scheduler 0    ERROR impl LlapDaemon   Thread Thread Wait Queue Scheduler 0 5 main  threw an Exception  Shutting down now     java util NoSuchElementException  at java util AbstractQueue remove AbstractQueue java 117  ~   1 7 0_55   at org apache hadoop hive llap daemon impl TaskExecutorService removeAndGetFromPreemptionQueue TaskExecutorService java 568  ~ hive llap server 2 1 0 SNAPSHOT jar 2 1 0 SNAPSHOT   at org apache hadoop hive llap daemon impl TaskExecutorService handleScheduleAttemptedRejection TaskExecutorService java 493  ~ hive llap server 2 1 0 SNAPSHOT jar 2 1 0 SNAPSHOT   at org apache hadoop hive llap daemon impl TaskExecutorService access 1100 TaskExecutorService java 81  ~ hive llap server 2 1 0 SNAPSHOT jar 2 1 0 SNAPSHOT   at org apache hadoop hive llap daemon impl TaskExecutorService WaitQueueWorker run TaskExecutorService java 285  ~ hive llap server 2 1 0 SNAPSHOT jar 2 1 0 SNAPSHOT   at java util concurrent Executors RunnableAdapter call Executors java 471  ~   1 7 0_55   at java util concurrent FutureTask run FutureTask java 262     1 7 0_55   at java util concurrent ThreadPoolExecutor runWorker ThreadPoolExecutor java 1145     1 7 0_55   at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 615     1 7 0_55   at java lang Thread run Thread java 745     1 7 0_55
13699	Make JavaDataModel get thread safe for parallel compilation  The class JavaDataModel has a static method   get  that is not thread safe  This may be an issue when parallel query compilation is enabled because two threads may attempt to call JavaDataModel get at the same time  etc
13725	ACID  Streaming API should synchronize calls when multiple threads use the same endpointCurrently  the streaming endpoint creates a metastore client which gets used for RPC  The client itself is not internally thread safe  Therefore  the API methods should provide the relevant synchronization so that the methods can be called from different threads  A sample use case is as follows  1  Thread 1 creates a streaming endpoint and opens a txn batch  2  Thread 2 heartbeats the txn batch  With the current impl  this can result in an  out of sequence response   since the response of the calls in thread1 might end up going to thread2 and vice versa
13753	Make metastore client thread safe in DbTxnManager  The fact that multiple threads sharing the same metastore client which is used for RPC to Thrift is not thread safe  Race condition can happen when one sees  out of sequence response  error message from Thrift server  That means the response from the Thrift server is for a different request  by a different thread   Solution will be to synchronize methods from the client side
13833	Add an initial delay when starting the heartbeat  Since the scheduling of heartbeat happens immediately after lock acquisition  it s unnecessary to send heartbeat at the time when locks is acquired  Add an initial delay to skip this
13858	LLAP  A preempted task can end up waiting on completeInitialization  if some part of the executing code suppressed the interruptAn interrupt along with a HiveProcessor abort call is made when attempting to preempt a task  In this specific case  the task was in the middle of HDFS IO   which  handled  the interrupt by retrying  As a result the interrupt status on the thread was reset   so instead of skipping the future get in completeInitialization   the task ended up blocking there  End result   a single executor slot permanently blocked in LLAP  Depending on what else is running   this can cause a cluster level deadlock
14357	TestDbTxnManager2 testLocksInSubquery failing in branch 2 1  checkCmdOnDriver driver compileAndRespond  insert into R select   from S where a in  select a from T where b   1       txnMgr openTxn  three     txnMgr acquireLocks driver getPlan    ctx   three     locks   getLocks     Assert assertEquals  Unexpected lock count   3  locks size      checkLock LockType SHARED_READ  LockState ACQUIRED   default    T   null  locks get 0     checkLock LockType SHARED_READ  LockState ACQUIRED   default    S   null  locks get 1     checkLock LockType SHARED_READ  LockState ACQUIRED   default    R   null  locks get 2       This test case is failing  The expected order of locks is supposed to be T  S  R  But upon closer inspection  it seems to be R S T  I m not much familiar with what these locks are and why the order is important  Raising this jira so while I try to understand it all  Meanwhile  if somebody can explain here  would be helpful
14400	Handle concurrent insert with dynamic partition  With multiple users concurrently issuing insert statements on the same partition has a side effect that some queries may not see a partition at the time when they&amp apos re issued  but will realize the partition is actually there when it is trying to add such partition to the metastore and thus get AlreadyExistsException  because some earlier query just created it  race condition   For example  imagine such a table is created     create table T  name char 50   partitioned by  ds string      and the following two queries are launched at the same time  from different sessions     insert into table T partition  ds  values  &amp apos Bob&amp apos   &amp apos today&amp apos       creates the partition &amp apos today&amp apos   insert into table T partition  ds  values  &amp apos Joe&amp apos   &amp apos today&amp apos       will fail with AlreadyExistsException
14463	hcatalog server extensions test cases getting stuck  The module is getting stuck in tests and not coming out for as long as 2 days  Specifically  TestMsgBusConnection is the test case which has this problem  I ran the tests on local environment and took a thread dump after it got stuck   Full thread dump Java HotSpot TM  64 Bit Server VM  24 80 b11 mixed mode     InactivityMonitor Async Task  java util concurrent ThreadPoolExecutor Worker 2c040428 State    1  empty queue   daemon prio 5 tid 0x00007fe90d89e000 nid 0x8827 waiting on condition  0x0000000117b74000   java lang Thread State  TIMED_WAITING  parking   at sun misc Unsafe park Native Method     parking to wait for  &lt 0x000000078166f0b8&gt   a java util concurrent SynchronousQueue TransferStack   at java util concurrent locks LockSupport parkNanos LockSupport java 226   at java util concurrent SynchronousQueue TransferStack awaitFulfill SynchronousQueue java 460   at java util concurrent SynchronousQueue TransferStack transfer SynchronousQueue java 359   at java util concurrent SynchronousQueue poll SynchronousQueue java 942   at java util concurrent ThreadPoolExecutor getTask ThreadPoolExecutor java 1068   at java util concurrent ThreadPoolExecutor runWorker ThreadPoolExecutor java 1130   at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 615   at java lang Thread run Thread java 745    InactivityMonitor Async Task  java util concurrent ThreadPoolExecutor Worker 182a483f State    1  empty queue   daemon prio 5 tid 0x00007fe90d801000 nid 0x585f waiting on condition  0x000000011786b000   java lang Thread State  TIMED_WAITING  parking   at sun misc Unsafe park Native Method     parking to wait for  &lt 0x000000078166f0b8&gt   a java util concurrent SynchronousQueue TransferStack   at java util concurrent locks LockSupport parkNanos LockSupport java 226   at java util concurrent SynchronousQueue TransferStack awaitFulfill SynchronousQueue java 460   at java util concurrent SynchronousQueue TransferStack transfer SynchronousQueue java 359   at java util concurrent SynchronousQueue poll SynchronousQueue java 942   at java util concurrent ThreadPoolExecutor getTask ThreadPoolExecutor java 1068   at java util concurrent ThreadPoolExecutor runWorker ThreadPoolExecutor java 1130   at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 615   at java lang Thread run Thread java 745    ActiveMQ Transport  tcp    127 0 0 1 56883  daemon prio 5 tid 0x00007fe90c83e800 nid 0x8403 runnable  0x00000001196ab000   java lang Thread State  RUNNABLE  at java net SocketInputStream socketRead0 Native Method   at java net SocketInputStream read SocketInputStream java 152   at java net SocketInputStream read SocketInputStream java 122   at org apache activemq transport tcp TcpBufferedInputStream fill TcpBufferedInputStream java 50   at org apache activemq transport tcp TcpTransport 2 fill TcpTransport java 576   at org apache activemq transport tcp TcpBufferedInputStream read TcpBufferedInputStream java 58   at org apache activemq transport tcp TcpTransport 2 read TcpTransport java 561   at java io DataInputStream readInt DataInputStream java 387   at org apache activemq openwire OpenWireFormat unmarshal OpenWireFormat java 269   at org apache activemq transport tcp TcpTransport readCommand TcpTransport java 227   at org apache activemq transport tcp TcpTransport doRun TcpTransport java 219   at org apache activemq transport tcp TcpTransport run TcpTransport java 202   at java lang Thread run Thread java 745    ActiveMQ Transport  tcp   localhost 127 0 0 1 61616  prio 5 tid 0x00007fe90b81e800 nid 0x8003 runnable  0x00000001194a5000   java lang Thread State  RUNNABLE  at java net SocketInputStream socketRead0 Native Method   at java net SocketInputStream read SocketInputStream java 152   a
14739	Replace runnables directly added to runtime shutdown hooks to avoid deadlock  Deepesh Khandelwal reported that a deadlock can occur when running queries through hive cli  Chris Nauroth analyzed it and reported that hive adds shutdown hooks directly to java Runtime which may execute in non deterministic order causing deadlocks with hadoop s shutdown hooks  In one case  hadoop shutdown locked FileSystem Cache and FileSystem close whereas hive shutdown hook locked FileSystem close and FileSystem Cache order causing a deadlock  Hive and Hadoop has ShutdownHookManager that runs the shutdown hooks in deterministic order based on priority  We should use that to avoid deadlock throughout the code
14778	document threading model of Streaming APIThe model is not obvious and needs to be documented properly  A StreamingConnection internally maintains 2 MetaStoreClient objects  each has 1 Thrift client for actual RPC   Let s call them  primary  and  heartbeat   Each TransactionBatch created from a given StreamingConnection  gets a reference to both of these MetaStoreClients  So the model is that there is at most 1 outstanding  not closed  TransactionBatch for any given StreamingConnection and for any given TransactionBatch there can be at most 2 threads accessing it concurrently  1 thread calling TransactionBatch heartbeat    and nothing else  and the other calling all other methods
14924	MSCK REPAIR table with single threaded is throwing null pointer exception  MSCK REPAIR TABLE is throwing Null Pointer Exception while running on single threaded mode  hive mv files thread 0   Error  2016 10 10T22 27 13 564 ERROR  e9ce04a8 2a84 426d 8e79 a2d15b8cee09 main       exec DDLTask  DDLTask java failed 581     java lang NullPointerException at org apache hadoop hive ql metadata HiveMetaStoreChecker checkPartitionDirs HiveMetaStoreChecker java 423  at org apache hadoop hive ql metadata HiveMetaStoreChecker findUnknownPartitions HiveMetaStoreChecker java 315  at org apache hadoop hive ql metadata HiveMetaStoreChecker checkTable HiveMetaStoreChecker java 291  at org apache hadoop hive ql metadata HiveMetaStoreChecker checkTable HiveMetaStoreChecker java 236  at org apache hadoop hive ql metadata HiveMetaStoreChecker checkMetastore HiveMetaStoreChecker java 113  at org apache hadoop hive ql exec DDLTask msck DDLTask java 1834  In order to reproduce  set hive mv files thread 0 and run MSCK REPAIR TABLE command
15090	Temporary DB failure can stop ExpiredTokenRemover thread  In HIVE 13090 we decided that we should not close the metastore if there is an unexpected exception during the expired token removal process  but that fix leaves a running metastore without ExpiredTokenRemover thread  To fix this I will move the catch inside the running loop  and hope the thread could recover from the exception