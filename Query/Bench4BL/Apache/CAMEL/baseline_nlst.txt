140	XsltBuilder instance not threadsafe and can t be used more then once  XsltBuilder uses a ResultHandler instance variable to hold the result of the transformation  That makes it thread unsafe and at the same time  as it‘s never cleared reset  it can’t be used more then once
510	Intermittent test failure in MultiCastAggregatorTestThere is a race condition in the test that both in out aggregators are aggregating the output  It looks like the InAggregator should to make a copy of the exchange  The attached patch also gets rid of a unused method
574	Multicast default excecutor do not create the enough thread for parallel processing  When I added the loan broker example CAMEL 556  I found there is no performance improvement when using the parallelly mulitcast  After digging into to code  I found we should create the enough thread for the parallel processing
715	ConcurrentModificationException in ThreadProcessorWhen defining very simple routing with ThreadProcessor  I get ConcurrentModificationException on multicore systems  Example  from  direct a   thread 10  process new Processor      Override public void process Exchange ex  throws Exception     sth       Stack trace  Exception in thread  Thread Processor  java util ConcurrentModificationException at java util HashMap HashIterator nextEntry HashMap java 793  at java util HashMap EntryIterator next HashMap java 834  at java util HashMap EntryIterator next HashMap java 832  at java util HashMap putAll HashMap java 523  at org apache camel processor Pipeline createNextExchange Pipeline java 146   at org apache camel processor Pipeline 1 done Pipeline java 123  at org apache camel processor ThreadProcessor ProcessCall run ThreadProcess or j ava 66  at java util concurrent ThreadPoolExecutor Worker runTask ThreadPoolExecuto r ja va 885  at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor ja va 9 07  at java lang Thread run Thread java 619
803	ValidatingProcessor not thread safe  The method org apache camel processor validation ValidatingProcessor process   is executed concurrently but error information is stored in a shared errorHandler  Because each thread calls errorHandler reset   it may clean errors written by another thread  The easiest way to fix this issue would be a synchronized block  ValidatingProcessor java     synchronized  errorHandler    errorHandler reset    validator setErrorHandler errorHandler    DOMResult result   new DOMResult    validator validate source  result    errorHandler handleErrors exchange  schema  result           The disadvantage of this solution is that is serializes threads  A locally created error handler would be preferrable
1199	Throttler appears to  throttle  per thread instead of throttling across multiple threads
1270	Starting Camel using Main from camel run or Main class   countdown latch is hanging  The countdown latch in MainSupport is not completed when Main is stopping  Then we have a hanging thread  Can bee seen using ctrl
1401	JaxbDataFormat is not thread safe  JaxbDataFormat reuses the Marshaller Unmarshaller instances  However  according to the https   jaxb dev java net faq index html threadSafety  Marshaller Unmarshaller instances are NOT thread safe  so you can t use them from separate threads at the same time  Due to this we are getting exceptions from the JAXB implementation  like ClassCastException or  org xml sax SAXException  FWK005 parse may not be called while parsing     Everything works nice with our custom JaxbDataFormat that creates new Unmarshaller Marshaller instance on every request  Also  lazy creating instances  like JAXBContext  in getter methods is not thread safe as well  because explicit synchronization is required
1510	BatchProcessor interrupt has side effects  I have noticed that the BatchProcessor class uses the Thread class interrupt method to wake the run loop from sleeping within the enqueueExchange method  The unfortunate side effect of this is that if the run loop is in the middle of processing exchanges  and the processing involves something slow like establishing a JMS connection over SSL or queuing to an asynchronous processor  then the processing can become interrupted  The consequence of this side effect is that the batch sender thread rarely gets the opportunity to complete properly and exceptions regarding the interrupt are thrown  This all became apparent during some performance testing that resulted in continuously adding exchanges to the aggregator  the threshold becoming reached  and then trying to enqueue the aggregated result to a JMS queue  If my analysis of the BatchProcessor is correct then I would recommend finer grained concurrency controls being used instead of relying upon interrupting a thread  Perhaps something like the following  untested  re write of the sender   private class BatchSender extends Thread   private Queue&lt Exchange&gt  queue  private boolean exchangeQueued   false  private Lock queueMutex   new ReentrantLock    private Condition queueCondition   queueMutex newCondition     public BatchSender     super  Batch Sender    this queue   new LinkedList&lt Exchange&gt        public void cancel     interrupt       private void drainQueueTo Collection&lt Exchange&gt  collection  int batchSize    for  int i   0  i &lt  batchSize    i    Exchange e   queue poll    if  e !  null    collection add e     else   break         public void enqueueExchange Exchange exchange    queueMutex lock    try   queue add exchange   exchangeQueued   true  queueCondition signal      finally   queueMutex unlock          Override public void run     queueMutex lock    try   do   try   if  !exchangeQueued    queueCondition await batchTimeout  TimeUnit MILLISECONDS   if  !exchangeQueued    drainQueueTo collection  batchSize        if  exchangeQueued    exchangeQueued   false  queueMutex unlock    try   while  isInBatchCompleted queue size       queueMutex lock    try   drainQueueTo collection  batchSize     finally   queueMutex unlock         if  !isOutBatchCompleted      continue      finally   queueMutex lock          queueMutex unlock    try   try   sendExchanges      catch  Exception e    getExceptionHandler   handleException e       finally   queueMutex lock        catch  InterruptedException e    break      while  true     finally   queueMutex unlock         private void sendExchanges   throws Exception   Iterator&lt Exchange&gt  iter   collection iterator    while  iter hasNext      Exchange exchange   iter next    iter remove    processExchange exchange           I have replaced the concurrent queue with a regular linked list and mutexed its access  In addition any queuing of exchanges is noted  This should result in less locking  The main change though is that queuing an exchange does not interrupt the batch sender s current activity  I hope that this sample is useful
1565	Make camel validation thread safe  When a flow which contains a camel validation endpoint is started  the XSD schemas are not loaded until the first request comes in and the camel validation endpoint is first hit  If two requests come in simultaneously  the initialization will be performed twice  at the same time  It seems that SchemaFactory is not thread safe  so this results in the following exception  10 38 20 860   ERROR   org apache camel processor DeadLetterChannel   org apache camel processor Logger   Failed delivery for exchangeId  ID ATOS B624 E47AF0 3211 1240562892751 0 11  On delivery attempt  0 caught  org xml sax SAXException  FWK005 parse may not be called while parsing  org xml sax SAXException  FWK005 parse may not be called while parsing  at com sun org apache xerces internal jaxp validation Util toSAXException Util java 62  at com sun org apache xerces internal jaxp validation XMLSchemaFactory newSchema XMLSchemaFactory java 214  at javax xml validation SchemaFactory newSchema SchemaFactory java 594  at org apache camel processor validation ValidatingProcessor createSchema ValidatingProcessor java 204  at org apache camel processor validation ValidatingProcessor getSchema ValidatingProcessor java 118  at org apache camel processor validation ValidatingProcessor process ValidatingProcessor java 54  at org apache camel impl ProcessorEndpoint onExchange ProcessorEndpoint java 92  at org apache camel impl ProcessorEndpoint 1 process ProcessorEndpoint java 66  at org apache camel impl converter AsyncProcessorTypeConverter ProcessorToAsyncProcessorBridge process AsyncProcessorTypeConverter java 43        For more info  http   www nabble com Concurrency Issue with camel validation td23213294 html Is it possible to backport the fix to 1 4
1583	ldap component is not thread safe  JNDI context objects are not thread safe  The LDAP component shares a directory context across all threads that use the component  This is not safe  In addition the LDAP component will attempt to establish a connection on instantiation of the component  and not when the component is required to process requests  If the LDAP server is not ready e g  temporarily unavailable then the entire Camel application will stop  JNDI directory contexts should be established when a consuming thread needs it and should be released when the thread is finished with the component i e    ctx   new InitialDirContext env   try         finally   ctx close        The above will release the connection with the LDAP server as soon as possible  The existing component relies on JNDI to release the socket in its own time  several seconds later
1604	UnitOfWork synchronization callbacks   add DSL for easy registering custom processor  See nabble  http   www nabble com  DISCUSS   Camel 2 0   Synchronization  28UnitOfWork callbacks 29 and  needed syntax DSL sugar td23498213s22882 html
1641	camel ftp is not thread safe  See nabble for discussion  http   www nabble com Threadsafety of Camel FTP td23615932 html Basically FTPClient should be created as a new instance for each created producer or consumer  like http component does
1650	Race condition in IdempotentConsumer  A possible possible race condition exists in the IdempotentConsumer implementation  The code first checks in the MessageIdRepository if the message was already processed  If not then it processes the message and afterwards adds the id to the repository   See also http   issues apache org activemq browse CAMEL 1451   There is no locking between the check with  contains  and the insert with  add   So if multiple threads instances try this in parallel for the same id  then it might happen that more than one finds the id not yet contained in the repository and the same message is processed multiple times  I enclose an extended version of IdempotentConsumerTest which illustrates the problem  It is important to note that even if the test demonstrates the issue with an MemoryIdempotentRepository a solution should also address the case of a database based respository in a clustered environment  So this might imply that some locking mechanism on the database is required
1670	thread   and File Components  I just experimented with adding calls to thread 10  to my route to make it multithreaded  This definitely speeds up by route  but it keeps throwing java nio channels OverlappingFileLockException  errors and leaving lock files behind it   The start of my route looks like from  file startDirectory move endDirectory    threads 10   bean  myBean    myMethod   Afterwards  my route ran successfully but an OverlappingFileLockException was thrown for every file that was read and all the lock files were left in my source directory
1795	camel jms   wrong defaults causes message listener to use new thread when receiving a messageJmsConfiguratiuon have a bad default  maxMessagesPerTask 1 It should be  1 as we do not want to strict the DefaultMessageListenerContainer to only handle 1 message per thread
1930	Synchronized access to XPathExpression resulting in contention for multiple consumers  Hi  I m using Camel to do some JMS message routing  Messages are XML so xpath is a natural choice  However when using a choice with an xpath expression  the XPathBuilder creates one XPathExpression object  According to the specification  these objects are not thread safe so synchronizing looks natural  But then  using multiple jms consumers is totally useless since no concurrent evaluations can be made  XPathExpression objects would rather need to be stored in a ThreadLocal to avoid synchronization and contention  Cheers  Fabrice
1966	CamelNamespaceHandler is not thread safe  Here is the mail thread 1  which discusses about it   1  http   www nabble com Occasional CamelNamespaceHandler exception when running with Spring DM 1 2 td25195171 html
2049	Improper configuration of MINA connector and acceptor instances  Better producerA sample scenario where both MINA producer s  and consumer s  are used in the same route  e g  some kind of dispatching or proxying   from  mina tcp   localhost 8888 lazySessionCreation true&amp sync true    to  mina tcp   localhost 7777 lazySessionCreation true&amp sync true    from  mina tcp   localhost 7777 lazySessionCreation true&amp sync true    process  prepare answer    Due to improper configuration of MINA acceptor and connector instances in MinaComponent createSocketEndpoint    no more than 15 incoming threads can be served at port 8888 the producer becomes unable to open an outgoing session  This is actually an issue of MINA  not of Camel a test application written using  raw  MINA shows the same behaviour  A solution is to apply configuration rules described  e g   at http   mina apache org configuring thread model html  as done in the attached patch  Moreover  the standard Camel MINA producer is not thread safe actually a well known point  A second attached file contains a thread pool based reentrant version  which can be efficiently used for TCP endpoints with both parameters lazySessionCreation and sync set to true
2175	Initialization code of camel cxf is not thread safe  getCxfBinding is not thread safe in case multiple threads hit a CXF webserive at once and it hasnt been initialized before  Code like this  public CxfBinding getCxfBinding     if  cxfBinding    null    cxfBinding   new DefaultCxfBinding    if  LOG isDebugEnabled      LOG debug  Create default CXF Binding     cxfBinding        if  !cxfBindingInitialized getAndSet true  &amp &amp  cxfBinding instanceof HeaderFilterStrategyAware      HeaderFilterStrategyAware cxfBinding   setHeaderFilterStrategy getHeaderFilterStrategy       return cxfBinding      Is a false sense as the getAndSet will let other threads pass it with a cxfBinding that still may not have been initialized
2496	StreamCache Splitter race condition  Attached patch introduces a test that shows the following symptom  org apache camel RuntimeCamelException  java io FileNotFoundException   var folders vC vCA487MkHEeSaIu9LmlkrU   TI Tmp camel tmp 627613 cos3755307044377901165 tmp  No such file or directory  org apache camel RuntimeCamelException  java io FileNotFoundException   var folders vC vCA487MkHEeSaIu9LmlkrU   TI Tmp camel tmp 627613 cos3755307044377901165 tmp  No such file or directory  at org apache camel converter stream FileInputStreamCache reset FileInputStreamCache java 52  at org apache camel converter stream StreamCacheConverter StreamSourceCache reset StreamCacheConverter java 126  at org apache camel util MessageHelper resetStreamCache MessageHelper java 105  at org apache camel builder xml XPathBuilder getDocument XPathBuilder java 548  at org apache camel builder xml XPathBuilder evaluateAs XPathBuilder java 428  at org apache camel builder xml XPathBuilder evaluate XPathBuilder java 118  at org apache camel processor Splitter createProcessorExchangePairs Splitter java 72  at org apache camel processor MulticastProcessor process MulticastProcessor java 155  at org apache camel management InstrumentationProcessor process InstrumentationProcessor java 80  at org apache camel processor DeadLetterChannel process DeadLetterChannel java 189  at org apache camel processor DeadLetterChannel process DeadLetterChannel java 133  at org apache camel management InstrumentationProcessor process InstrumentationProcessor java 68  at org apache camel processor interceptor StreamCachingInterceptor proceed StreamCachingInterceptor java 87  at org apache camel processor interceptor StreamCachingInterceptor process StreamCachingInterceptor java 82  at org apache camel processor UnitOfWorkProcessor process UnitOfWorkProcessor java 52  at org apache camel component seda SedaConsumer run SedaConsumer java 72  at java util concurrent ThreadPoolExecutor Worker runTask ThreadPoolExecutor java 886  at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 908  at java lang Thread run Thread java 637  I believe it must be a race condition when several threads are passing through the splitter  in the above case I m using a seda queue with 5 threads  Am logging this now as I m not sure what time I ll have to investigate further this week
2824	Deadlock in org apache camel util DefaultTimeoutMapAfter running a camel route with a camel Aggregator for a while  I get a deadlock in org apache camel util DefaultTimeoutMap  A full processdump is attached to this bug  I have also tried to recreate this as failing testcase  but without any luck so far
2935	Broken failure reporting via DefaultProucerTemplate asyncCallback and Synchronization  onFailureThe recent change in ProducerCache send  ProducerCache java public void send Endpoint endpoint  Exchange exchange    try   sendExchange endpoint  null  null  exchange      RECENT CHANGE HERE     ensure that CamelExecutionException is always thrown if  exchange getException   !  null    exchange setException wrapCamelExecutionException exchange  exchange getException          catch  Exception e    throw wrapCamelExecutionException exchange  e         that throws a CamelExecutionException if exchange getException is not null  makes it impossible for DefaultProducerTemplate asyncCallback to report failures  other than fault messages  asynchronously via Synchronization onFailure  DefaultProducerTemplate java public Future&lt Exchange&gt  asyncCallback final Endpoint endpoint  final Exchange exchange  final Synchronization onCompletion    Callable&lt Exchange&gt  task   new Callable&lt Exchange&gt      public Exchange call   throws Exception       FIXME  exception is thrown in Camel 2 4 where a normal return with answer getException !  null was done in Camel 2 3 Exchange answer   send endpoint  exchange    if  answer isFailed      onCompletion onFailure answer     else            return answer                  This was working in Camel 2 3  but unfortunately there wasn t any test case for it   I attached a patch for DefaultProducerTemplateAsyncTest that demonstrates the problem  I didn t commit a fix yet because I m unsure at the moment about the best way to fix that  Of course I tried a naive fix in the DefaultProducerTemplate asyncCallback methods which causes the test  in the patch  to pass but I d like to hear other opinions before I continue
2986	IllegalStateException in CamelContinuationServlet under heavy loadReason is a race between continuation suspend   and continuation resume    It can occur that continuation resume   is executed before continuation suspend   leading to an IllegalStateException thrown by Jetty   java lang IllegalStateException  DISPATCHED initial at org eclipse jetty server AsyncContinuation dispatch AsyncContinuation java 364  at org eclipse jetty server AsyncContinuation resume AsyncContinuation java 769  at org apache camel component jetty CamelContinuationServlet 1 done CamelContinuationServlet java 85  at org apache camel management InstrumentationProcessor 1 done InstrumentationProcessor java 78  at org apache camel processor UnitOfWorkProcessor 1 done UnitOfWorkProcessor java 104  at org apache camel processor DefaultChannel 1 done DefaultChannel java 262  at org apache camel processor RedeliveryErrorHandler 1 done RedeliveryErrorHandler java 302  at org apache camel management InstrumentationProcessor 1 done InstrumentationProcessor java 78  at org apache camel management InstrumentationProcessor 1 done InstrumentationProcessor java 78    This is the case when an async completion callback is faster than the thread that is concurrently executing the if  continuation isInitial    block  I ll commit a fix soon that also follows the recommendations in http   wiki eclipse org Jetty Feature Continuations to always call continuation suspend   before registering the continuation with a callback handler
2994	camel cxf   CxfClientCallback is invoked twice when only one was expectedRun the test CXFWsdlOnlyTest  Because CXF invokes the CxfClientCallback 2 times there is a race condition with 2 threads wanting to complete routing the Exchange  You can then end up with errors such as 2010 07 26 13 22 13 305  default workqueue 1                  INFO  Logger                           Exchange Message   Body is instance of java io InputStream   Exception in thread  default workqueue 1  java util NoSuchElementException at java util AbstractList Itr next AbstractList java 350  at org apache camel processor Pipeline 1 done Pipeline java 153  at org apache camel processor DefaultChannel 1 done DefaultChannel java 262  at org apache camel processor RedeliveryErrorHandler 1 done RedeliveryErrorHandler java 302  at org apache camel management InstrumentationProcessor 1 done InstrumentationProcessor java 78  at org apache camel management InstrumentationProcessor 1 done InstrumentationProcessor java 78  at org apache camel component cxf CxfClientCallback handleException CxfClientCallback java 77  at org apache cxf interceptor ClientOutFaultObserver onMessage ClientOutFaultObserver java 55  at org apache cxf transport http HTTPConduit WrappedOutputStream 1 run HTTPConduit java 2144  at org apache cxf workqueue AutomaticWorkQueueImpl 2 run AutomaticWorkQueueImpl java 253  at java util concurrent ThreadPoolExecutor Worker runTask ThreadPoolExecutor java 886  at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 908  at java lang Thread run Thread java 637  2010 07 26 13 22 13 305  default workqueue 2                  INFO  Logger                           Exchange Message   Body is instance of java io InputStream   Exception in thread  default workqueue 2  java util NoSuchElementException at java util AbstractList Itr next AbstractList java 350  at org apache camel processor Pipeline 1 done Pipeline java 153  at org apache camel processor DefaultChannel 1 done DefaultChannel java 262  at org apache camel processor RedeliveryErrorHandler 1 done RedeliveryErrorHandler java 302  at org apache camel management InstrumentationProcessor 1 done InstrumentationProcessor java 78  at org apache camel management InstrumentationProcessor 1 done InstrumentationProcessor java 78  at org apache camel component cxf CxfClientCallback handleException CxfClientCallback java 77  at org apache cxf interceptor ClientOutFaultObserver onMessage ClientOutFaultObserver java 55  at org apache cxf transport http HTTPConduit WrappedOutputStream 1 run HTTPConduit java 2144  at org apache cxf workqueue AutomaticWorkQueueImpl 2 run AutomaticWorkQueueImpl java 253  at java util concurrent ThreadPoolExecutor Worker runTask ThreadPoolExecutor java 886  at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 908  at java lang Thread run Thread java 637    CXF should only invoke the org apache cxf endpoint ClientCallback one time as we have only registered this once
3216	ScheduledPollConsumer should avoid runnable thread to die to ensure its kept being scheduledscheduled consumers such as file ftp uses ScheduledPollConsumer to poll  If a throwable is thrown then the thread may die due it throws that to the JDK  We should avoid this and ensure to catch all exceptions  otherwise the thread may die  and the JDK will not re schedule a new thread  This cause it to stop polling  See http   fusesource com forums thread jspa threadID 2320&amp tstart 0
3277	Threading issue which lets converter loading abortThe type converter loading is not threadsafe and fails sometimes  That will end up with around 17 type converters loaded only which will probably let your camel routes fail with conversion errors like   07 04 31 112   ERROR   qtp25205731 2783   DefaultErrorHandler   rg apache camel processor Logger 248   68   org apache camel camel core   2 4 0 fuse 00 00   Failed delivery for exchangeId  53e23457 5551 4487 9fc4 87dd33687f0b  Exhausted after delivery attempt  1 caught  java lang ClassCastException  org apache camel converter stream InputStreamCache cannot be cast to org w3c dom Node java lang ClassCastException  org apache camel converter stream InputStreamCache cannot be cast to org w3c dom Node at com sun org apache xpath internal jaxp XPathExpressionImpl eval XPathExpressionImpl java 116   1 6 0_17  at com sun org apache xpath internal jaxp XPathExpressionImpl eval XPathExpressionImpl java 98   1 6 0_17  at com sun org apache xpath internal jaxp XPathExpressionImpl evaluate XPathExpressionImpl java 180   1 6 0_17  at org apache camel builder xml XPathBuilder doInEvaluateAs XPathBuilder java 598  68 org apache camel camel core 2 4 0 fuse 00 00  at org apache camel builder xml XPathBuilder evaluateAs XPathBuilder java 570  68 org apache camel camel core 2 4 0 fuse 00 00  at org apache camel builder xml XPathBuilder matches XPathBuilder java 122  68 org apache camel camel core 2 4 0 fuse 00 00    Tracking the issue down showed that several type converter loaders share the same registry object and fail to load all converters every once a while  That can be fixed by making the load method synchronized   see attached patch
3349	Race condition found in CxfRsEndpoint while getting the endpoint binding under load and performing sync and async invocation  The CxfRsEndpoint&amp apos s getBinding method is not thread safe  At a customer site  I ran into an issue at startup if 2 threads raced to perform sync and async invocation  the code for getBinding  given below  would react in the following way   Thread 1 would proceed to create a binding object  Thread 2 would mean while still find the binding to be null and proceed to create a new binding Meanwhile thread one would have its binding and set the Atomic boolean for binding initialized and proceed to set the HeaderStrategy  Thread 2 meanwhile would overwrite the original binding object and find that Atomic boolean already set and would have no way to associate a HeaderFilterStrategy object since the flag is up  In the absence of a HeaderFilterStrategy  copying of ProtocolHeaders etc will throw exceptions on every following request invocation                                                      public CxfRsBinding getBinding     if  binding    null    binding   new DefaultCxfRsBinding    if  LOG isDebugEnabled      LOG debug  Create default CXF Binding     binding       if  !bindingInitialized getAndSet true  &amp &amp  binding instanceof HeaderFilterStrategyAware      HeaderFilterStrategyAware binding  setHeaderFilterStrategy getHeaderFilterStrategy        return binding
3493	ConcurrentModificationException in DefaultCamelContext removeRouteDefinitions    I get the following exception in DefaultCamelContext removeRouteDefinitions    We are removing route definitions from multiple threads  I see synchronization in various other methods  but not this one  Caused by  java util ConcurrentModificationException at java util AbstractList Itr checkForComodification AbstractList java 372  at java util AbstractList Itr next AbstractList java 343  at java util AbstractCollection removeAll AbstractCollection java 336  at org apache camel impl DefaultCamelContext removeRouteDefinitions DefaultCamelContext java 588
3528	HybridSourceDataBinding not thread safe  The HybridSourceDataBinding in camel cxf is not thread safe   The readers writers in CXF hold state  like schemas and properties  and  must be created when needed
7116	JettyHttpProducer doStop does not stop client thread poolCase  CamelContext with one route  from  direct a    routingSlip generateHttpUrl    Where generateHttpUrl   returns  for example   jetty http   someurl com 666 some httpClientMinThreads 128&amp   When CamelContext is closing  JettyHttpProducer doStop is not called  Result   When JettyHttpProducer client is closing  its thread pool is not closed and the threads are non deamon threads  subject to another JIRA    so application cannot be shutdown
7161	camel dozer   Can cause dead lock in init when using springWhen using spring with dozer  and we call init in the ctr  then spring can cause a deadlock when it does its getBean stuff   java lang Thread State  BLOCKED  on object monitor   at org springframework beans factory support DefaultSingletonBeanRegistry getSingleton DefaultSingletonBeanRegistry java 182     waiting to lock &lt 0x00000007d7c4ca38&gt   a java util concurrent ConcurrentHashMap   at org springframework beans factory support AbstractBeanFactory isTypeMatch AbstractBeanFactory java 468   at org springframework beans factory support DefaultListableBeanFactory doGetBeanNamesForType DefaultListableBeanFactory java 356   at org springframework beans factory support DefaultListableBeanFactory getBeanNamesForType DefaultListableBeanFactory java 334   at org springframework beans factory support DefaultListableBeanFactory getBeansOfType DefaultListableBeanFactory java 434   at org springframework beans factory support DefaultListableBeanFactory getBeansOfType DefaultListableBeanFactory java 428   at org springframework context support AbstractApplicationContext getBeansOfType AbstractApplicationContext java 1182   at org springframework beans factory BeanFactoryUtils beansOfTypeIncludingAncestors BeanFactoryUtils java 228   at org apache camel spring spi ApplicationContextRegistry findByTypeWithName ApplicationContextRegistry java 85   at org apache camel impl PropertyPlaceholderDelegateRegistry findByTypeWithName PropertyPlaceholderDelegateRegistry java 70   at org apache camel converter dozer DozerTypeConverterLoader lookupDozerBeanMapperConfigurations DozerTypeConverterLoader java 228   at org apache camel converter dozer DozerTypeConverterLoader init DozerTypeConverterLoader java 155     We should defer init to a bit later  and turn the loader into a service so init is done like the others with start stop methods
7239	Address the SchemaFactory thread safe issue  SchemaFactory is not thread safe  we need to do addition work in ValidatorProcessor to avoid the threads issue
7318	Concurrency on HDFS Consumer not working efficiently  If we have two HDFS consumers the files are being processed twice  once by each consumer  waiting one after the other   so the consumers are not working in parallel  If we add this the consumers will work as a team and the transfer will go faster  This happens because there is no exception thrown the rename method just returns true or false and everything carries on as nothing would have happened  In order to fix this we could add in the HdfsInputStream  49 boolean tf   info getFileSystem   rename new Path ret actualPath   new Path ret suffixedPath    if  !tf     throw new IOException  This exception is thrown because the rename did not succeded         And also in the HdfsConsumer  150 try    this rwlock writeLock   lock     this istream   HdfsInputStream createInputStream fileStatuses i  getPath   toString    this config      catch  IOException ioe     log info ioe getMessage  	    If the rename fails we move on to the next file      continue
7321	JcrConsumer freezes in some environments  In January Willem Jiang reported that the JUnit test JcrConsumerTest fails in his environment  This could not be reproduced in other environments at that time  Willem Jiang applied the following fix to the pom xml in order make the test pass  camel jcr pom xml         &lt build&gt   &lt plugins&gt   &lt plugin&gt   &lt groupId&gt org apache maven plugins&lt  groupId&gt   &lt artifactId&gt maven surefire plugin&lt  artifactId&gt   &lt configuration&gt   &lt forkMode&gt pertest&lt  forkMode&gt   &lt  configuration&gt   &lt  plugin&gt   &lt  plugins&gt   &lt  build&gt            This made all tests run in separate processes  but was also an indicator for potential multi threading issues in JcrConsumer  I was recently able to reproduce the problem by running Maven within Eclipse  The problem is indeed a synchronization issue and should be addressed with this ticket
7364	JpaMessageIdRepository uses EntityManager non thread safe  In our product we have found strange behavior of JpaMessageIdRepository when change version 2 9 2 to 2 12 3  The reason for this was that EntityManager assigned in the constructor org apache camel processor idempotent jpa JpaMessageIdRepository  but EntityManager not required to be thread safe  http   download oracle com otn pub jcp persistence 2 0 fr oth JSpec persistence 2_0 final spec pdf page 286  I think need assign the EntityManager in each method separately
7556	camel rabbitmq  Multiple concurrent consumer threads  Allow multiple concurrent threads listening to a single queue  like the JMS endpoint
7715	SjmsConsumer and SjmsProducer do not remove thread pool when stopSjmsConsumer and SjmsProducer always register a new ThreadPool on Camel context ExecutorServiceManager every time a new instance is created for an endpoint  If consumer or producer is stopped or removed or even component is removed  thread pool still exists
7795	Regression  MDC may lose values after when Async Routing Engine is used  CAMEL 6377 introduced some optimisations in the MDC Logging mechanism which make it lose MDC values when the async routing engine is used  If we are using an async component such as CXF  the response or done   callback will be issued from a thread NOT managed by Camel  Therefore  we need the MDCCallback to reset ALL MDC values  not just the routeId  as was intended by the commits that caused the regression   The situation may be salvaged by the fact that underlying MDC implementations use an InheritableThreadLocal  so the first requests after system initialisation may see correct behaviour  because the MDC values from the requesting thread is propagated to the newly initialised threads in the underlying stack s ThreadPool  as the coreThreads are being initialised within the context of the original threads which act like parent threads  But after those first attempts  odd behaviour is seen and all responses from the async endpoint come back without an MDC
7968	Container has undefined concurrency behaviour  The implementation of Container Instance is not ThreadSafe  It is also not defined what happens when multiple Containers race on the singleton  Instead of using a Container singleton approach  It might be better to have a singleton ContainerRegistry that can handle concurrent multiple Containers
7973	CircuitBreakerLoadBalancer fails on async processors  The CircuitBreakerLoadBalancer works fine on direct synchronous processor  but it seems to not behave as expected in case of async processor  To reproduce the error  it s enough to add a threads 1  before the mock processor in the CircuitBreakerLoadBalancerTest routeBuilder configuration  This misbehaviour seems to be related to the use of the AsyncProcessorConverterHelper to force any processor to behave like asynchronous  I m going to propose a patch with the failing test and a proposal of solution  EDIT  the patch contains the fix also to other unexpected behaviour of the CircuitBreaker  The second problem addressed is that  after the opening of the circuit  the RejectedExecutionException raised by the circuit breaker is set in the Exchange  but it doesn t return  This cause the processor will receive the Exchange even if the circuit is open  In this case also  if the CircuitBreaker is instructed to react only to specific Exception  it will close the circuit after the following request  because the raised exception would be a RejectedExecutionException instead of the one specified in the configuration
7988	file consumer   Should call abort in case read lock cannot be acquired if exception was thrown  See nabble  http   camel 465427 n5 nabble com Possible issue with FileLockExclusiveReadLockStrategy leaves orphaned camelLock file tp5758142 html This could cause a camelLock or phaned file to be there causing the file to not be eligible for consuming on next poll
8088	FTP can wait indefinitely when connection timeout occurs during connect  In our production system we have seen cases where the FTP thread is waiting for a response indefinitely despite having set soTimeout on the connection  On investigation this is due to a condition that can occur where a socket is able to connect yet a firewall or the ilk then blocks further traffic  This can be over come by setting the property ftpClient defaultTimeout to a non zero value  It should be the case where if upon initial socket connection no response occurs that the socket should be deemed dead  however this is not the case  When the following exception is thrown during initial connect to an FTP server  after the socket has connected but whilst awaiting the inital reply it can leave the RemoteFileProducer in a state where it is connected but not logged in and no attempt reconnect is attempted  if the soTimeout as set by ftpClient defaultTimeout is set to zero then it can cause a subsequent command will wait for a reply indefinitely   Caused by  java io IOException  Timed out waiting for initial connect reply  at org apache commons net ftp FTP _connectAction_ FTP java 389  ~ commons net 3 1 jar 3 1   at org apache commons net ftp FTPClient _connectAction_ FTPClient java 796  ~ commons net 3 1 jar 3 1   at org apache commons net SocketClient connect SocketClient java 172  ~ commons net 3 1 jar 3 1   at org apache commons net SocketClient connect SocketClient java 192  ~ commons net 3 1 jar 3 1   at org apache camel component file remote FtpOperations connect FtpOperations java 95  ~ camel ftp 2 13 1 jar 2 13 1     The RemoteFileProducer will enter this block as the loggedIn state has not yet been reached  however the existing broken socket is reused        recover by re creating operations which should most likely be able to recover  if  !loggedIn     log debug  Trying to recover connection to     with a fresh client    getEndpoint      setOperations getEndpoint   createRemoteFileOperations      connectIfNecessary          Yet the connectIfNecessary   method will return immediately since the check condition is based on socket connection and takes no account of whether login was achieved so the dead s socket is reused    protected void connectIfNecessary   throws GenericFileOperationFailedException       This will be skipped when loggedIn   false and the socket is connected  if  !getOperations   isConnected       log debug  Not already connected logged in  Connecting to       getEndpoint      RemoteFileConfiguration config   getEndpoint   getConfiguration     loggedIn   getOperations   connect config    if  !loggedIn     return      log info  Connected and logged in to      getEndpoint              A dirty test that blocks of this blocking condition     package ftp     import org apache camel builder RouteBuilder   import org apache camel impl JndiRegistry   import org apache camel test junit4 CamelTestSupport   import org apache commons net ftp FTPClient   import org junit After   import org junit Before   import org junit Test   import org mockftpserver fake FakeFtpServer   import org mockito Mockito   import org mockito invocation InvocationOnMock   import org mockito stubbing Answer     import java io IOException   import java io InputStream   import java net Socket   import java net SocketException   import java net SocketTimeoutException   import java util concurrent atomic AtomicBoolean     import javax net SocketFactory     import static org mockito Matchers anyInt   import static org mockito Mockito doAnswer   import static org mockito Mockito mock   import static org mockito Mockito when     public class FtpInitialConnectTimeoutTest extends CamelTestSupport      private static final int CONNECT_TIMEOUT   11223            Create the answer for the socket factory that causes a SocketTimeoutException to occur in connect       private static class SocketAnswer implements Answer&lt Socket&gt      Override  public Socket answer InvocationOnMock invocation  throws Throwable    final Socket socket   Mockito spy new Socket      final AtomicBoolean timeout   new AtomicBoolean       try    doAnswer new Answer&lt InputStream&gt        Override  public InputStream answer InvocationOnMock invocation  throws Throwable    final InputStream stream    InputStream  invocation callRealMethod       InputStream inputStream   new InputStream       Override  public int read   throws IOException    if  timeout get          emulate a timeout occuring in _getReply    throw new SocketTimeoutException        return stream read              return inputStream         when socket  getInputStream       catch  IOException ignored          try    doAnswer new Answer       Override  public Object answer InvocationOnMock invocation  throws Throwable    if   Integer  invocation getArguments   0     CONNECT_TIMEOUT        setting of connect timeout  timeout set true      else       non connect timeout  timeout set false       return invocation callRealMethod           when socket  setSoTimeout anyInt        catch  SocketException e     throw new RuntimeException e       return socket           private FakeFtpServer fakeFtpServer      Override   Before  public void setUp   throws Exception    fakeFtpServer   new FakeFtpServer     fakeFtpServer setServerControlPort 0    fakeFtpServer start       super setUp           Override   After  public void tearDown   throws Exception    super tearDown     if  fakeFtpServer !  null     fakeFtpServer stop              Test  public void testName   throws Exception    sendBody  direct start    test          private FTPClient mockedClient   throws IOException    FTPClient client   new FTPClient     client setSocketFactory createSocketFactory      return client        private SocketFactory createSocketFactory   throws IOException    SocketFactory socketFactory   mock SocketFactory class    when socketFactory createSocket    thenAnswer new SocketAnswer      return socketFactory         Override  protected JndiRegistry createRegistry   throws Exception    JndiRegistry registry   super createRegistry     registry bind  mocked   mockedClient      return registry         Override  protected RouteBuilder createRouteBuilder   throws Exception    return new RouteBuilder       Override  public void configure   throws Exception    from  direct start     to  ftp   localhost     fakeFtpServer getServerControlPort        ftpClient  mocked      &amp soTimeout 1234&amp       connectTimeout     CONNECT_TIMEOUT
8134	We should not add synchronisation if the CachedOutputStream closedOnCompletion option is falseCachedOutputStream  adds synchronization into exchange even the closedOnCompletion option is false  it could cause OOM error with the HttpProducer endpoint does  unlimited limited  redelivery  Here is the discussion about this issue
8146	Starting and stopping routes leak threadsSeems to be identical consequence as with previous issue CAMEL 5677  but perhaps due to a different cause  Having a file or SFTP based route  trying something like     for  int i   0  i &lt  50  i       camelContext startRoute routeId    camelContext stopRoute routeId         results in 50 orphan threads of this type      Camel  camel  thread  231   sftp   user host path   10170 daemon prio 5 os_prio 0 tid 0x00007fa4b46a5800 nid 0x10fc waiting on condition  0x00007fa452934000   java lang Thread State  TIMED_WAITING  parking   at sun misc Unsafe park Native Method     parking to wait for  &lt 0x00000000b83dc900&gt   a java util concurrent locks AbstractQueuedSynchronizer ConditionObject   at java util concurrent locks LockSupport parkNanos LockSupport java 215   at java util concurrent locks AbstractQueuedSynchronizer ConditionObject awaitNanos AbstractQueuedSynchronizer java 2078   at java util concurrent ScheduledThreadPoolExecutor DelayedWorkQueue take ScheduledThreadPoolExecutor java 1093   at java util concurrent ScheduledThreadPoolExecutor DelayedWorkQueue take ScheduledThreadPoolExecutor java 809   at java util concurrent ThreadPoolExecutor getTask ThreadPoolExecutor java 1067   at java util concurrent ThreadPoolExecutor runWorker ThreadPoolExecutor java 1127   at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 617   at java lang Thread run Thread java 745     Switching to suspend resume solves the problem  however I guess the start stop issue should be addressed
8200	Race condition in JmsProducer for request response messaging causing nondeterministic setting body to null  In my team we have noticed that there is a race condition problem in JmsProducer class for request response messaging  It causes that sometimes  nondeterministically  body of a response message is changed to null  It can happen when JMS response is received very fast  we use in memory ActiveMQ with VM transport and no persistence  under heavy load  It looks that there is a problem in JmsProducer class in processInOut exchange  callback  method     protected boolean processInOut final Exchange exchange  final AsyncCallback callback       doSend true  destinationName  destination  messageCreator  messageSentCallback       after sending then set the OUT message id to the JMSMessageID so its identical  setMessageId exchange       continue routing asynchronously  reply will be processed async when its received   return false             protected void setMessageId Exchange exchange     if  exchange hasOut       JmsMessage out   exchange getOut JmsMessage class    try    if  out !  null &amp &amp  out getJmsMessage   !  null     out setMessageId out getJmsMessage   getJMSMessageID           catch  JMSException e     LOG warn  Unable to retrieve JMSMessageID from outgoing JMS Message and set it into Camel&amp apos s MessageId   e               The problem is caused by invoking setMessageId      method after doSend       Method doSend      is sending JMS request message and causes that another thread is used to handle JMS reply message  This leads to a situation that 2 different threads can operate on the same exchange  which is not synchronized at all  at the same time  1  original thread in which processInOut      method was called  2  separate thread from JMS component for handling JMS response  In our case there it was happening sometimes that setMessageId      was invoked at the same time as PipelineHelper createNextMessage exchange  method     public static Exchange createNextExchange Exchange previousExchange     Exchange answer   previousExchange      now lets set the input of the next exchange to the output of the     previous message if it is not null  if  answer hasOut       answer setIn answer getOut      answer setOut null       return answer        It caused that body of response message was lost  set to null   It looks for me that calling setMessageId      at the end of processInOut      method is redundant and this logic should be executed when JMS reply message is handled  I ve attached a patch where invokation of setMessageId      is removed  I ve checked that it doesn t break any test for camel jms component
8241	Exec command failures using Java 8 on Unix  I’m attaching a test case that shows an issue  I‘ve been running into with the exec command since updating my environment to Java 8  It appears that I’m running into a race condition where a stream is sometimes closed prematurely before DefaultExecutor has a chance to close it  causing DefaultExecCommandExecutor to throw and exit  even though the command did execute properly   I‘ve tested this against the updated version of commons exec as well just to make sure this hasn’t somehow been fixed in that library  Please note that the attached test doesn‘t always fail  you may need to run it a few times before the error will show up
8268	camel hbase   The scan method is not thread safe when using a filter listThe scan method is not thread safe when using a filter list  A concurrent call on the endpoint will produce wrong values because the same FilterList is used between threads  Cloning the passed filter list solve the problem
8353	FileLockExclusiveReadLockStrategy   Should defer closing channel till release lock  See nabble  http   camel 465427 n5 nabble com FileLockExclusiveReadLockStrategy doesn t hold lock and error on commit tp5762668 html The acquire lock method closes the channel if it acquired the lock  but that would make the lock invalid  Instead the channel should remain open and only closed when the lock is released
8673	ConcurrentModificationException when creating dynamic routesThis ticket refers to CAMEL 7836  The fix seems to be slightly wrong   We still geht the ConcurrentModificationException  The cause seems to be in removeRouteCollection and addRouteCollection  See here     void removeRouteCollection Collection&lt Route&gt  routes     synchronized  routes     this routes removeAll routes            Here the code synchronizes on the routes parameter  but should be on this routes  as it getRoutes   does   The same in addRouteCollection
8713	ParallelAggregate option when using parallel mode does not run in parallel  See CAMEL 7521 When using parallel processing then the boss thread aggregate on the fly is a single threaded boss thread that controls the aggregation  So even if setting parallel aggregate   true  then its still only 1 boss thread  We should have a thread pool  or allow to use the existing pool for parallel processing  for worker threads to do the aggregate work in parallel
8885	ConsumeLockEntity without ConsumeDeleteI think that condition at the beginning of the lock function is wrong     protected boolean lockEntity Object entity  EntityManager entityManager     if  !getEndpoint   isConsumeDelete      !getEndpoint   isConsumeLockEntity       return true             If I wanna just select and then update entity I should set consumeDelete false  but If so entity will newer be locked
8954	Lock information is not handovered together with Exchange on completion synchronizations  This applies to the file components when using common read lock strategies   markerFile   org apache camel component file strategy MarkerFileExclusiveReadLockStrategy fileLock   org apache camel component file strategy FileLockExclusiveReadLockStrategy  This strategies stores lock information in the Exchange properties   Exchange FILE_LOCK_FILE_ACQUIRED     CamelFileLockFileAcquired  Exchange FILE_LOCK_FILE_NAME     CamelFileLockFileName  Exchange FILE_LOCK_EXCLUSIVE_LOCK     CamelFileLockExclusiveLock  Exchange FILE_LOCK_RANDOM_ACCESS_FILE     CamelFileLockRandomAccessFile   Lock information is stored as scalar values and can hold information about only one single lock  When there are two Exchanges participates in the route  share UoW  and synchronizations are handovered from one Exchange to another  information about both locks can t be stored in the Exchange properties and lost  Consequently when on completion synchronizations are performed  read lock strategies can t access information about all the locks and they are not released  For example  after completing this route lock for file1 dat is not released     from  file data input a fileName file1 dat&amp readLock markerFile     pollEnrich  file data input b fileName file2 dat&amp readLock markerFile     to  mock result
9199	RabbitMQ Consumer threads crash when sending partially serializable objects  The RabbitMQ consumer thread crashes when sending an object that implements Serializable but contains non Serializable objects  I will have PR very soon to fix this and add tests
9311	Concurrency issue with the dynamic router  We have a service with two HTTP contexts  http   0 0 0 0 9000 endpoin1 dynamic  http   0 0 0 0 9000 endpoin2 dynamic  Both endpoints can be called using a HTTP GET method and a dynamic router routes the message differently  Each HTTP endpoint  has its own instance of the dynamic router bean  The dynamic router bean does not use any shared state  When the HTTP endpoints are called sequentially the calls are handled as expected  When the HTTP endpoints are called concurrently then sometimes the the dynamic router of the 9000 endpoin1 dynamic endpoint is re routing calls originating from 9000 endpoin2 dynamic and vice versa  Please take a look at attached unit test case for more detail
9319	SshClient resource leak when used from ProducerTemplate  When using ProducerTemplate for execution of an ssh command  i e  producerTemplate requestBody  ssh         String class    11 threads are being created  that are never killed  Any subsequent calls create new threads  eventually this exhausts memory and thread resources on the machine  These threads are not being killed even when explicitly stopping the ProducerTemplate  Here is a more detailed discussion  together with profiler results and code to reproduce the issue  http   stackoverflow com questions 33671567 spring boot camel producertemplate thousands of threads http   camel 465427 n5 nabble com Spring Boot Camel producerTemplate ssh spawning thousands of threads td5773741 html
9331	Thread leak in Http4Endpoint  doStop   does not close   the httpClientThread leak in Http4Endpoint  doStop   does not close   the httpClient  Also when using a shared client connection manager the builder must be told of this so it does not close   a shared connection manager when the http client is closed
9738	Thread leak for camel mina2 consumers  The camel mina2 consumer  org apache camel component mina2 Mina2Consumer doStart    internally start a Mina2 IoAcceptor  org apache mina core service IoAcceptor   but the org apache camel component mina2 Mina2Consumer doStop   do not invoke acceptor dispose true   to release the threadpool started by Mina2  Current behavior  While stopping the web application  the threadpool started by Mina2 IoAcceptor will not be stopped  so we have several thread which do not properly shutdown  Current workaround  I create custom CamelShutdownStrategy and collect all Mina2Consumer and invoke Mina2consumer getAcceptor dispose true   OR as an alternative create a dedicated consumer and overwrite the stop method of the Mina2 consumer as seen here  https   github com oehf ipf commit 12fdde8df7ebbbb7cd9966aadeab3ea3bed8fe75 Suggested bugfix  In org apache camel component mina2 Mina2Consumer doShutdown   call the IoAcceptor dispose true  method after unbind from the address
9951	Setup default values for thread connected properties in WebSocket component  If you do not set properties minThreads or maxThreads or method getThreadPool   returns null the you will get RuntimeCamelException and websocket cosumer will not be created  These attributes were not required in previous versions of camel  Websocket component now uses Jetty 9  If these properties are really required why do not use some default values   minThreads   1  maxThreads   Runtime getRuntime   availableProcessors    https   github com apache camel blob master components camel websocket src main java org apache camel component websocket WebsocketComponent java L341
9970	CamelFileLength header is wrong for long write fileGiven a long write file slowfile dat  Camel polls the file and stores its parameters  length  lastModified      Camel tries to get exclusive read lock and fails as file is writing by someone  next time Camel gets lock  But file was changed and its parameters are wrong  The solution is pretty simple   check the file length and lastModified when exclusive read lock is granted and update them  Here is a patch  http   pastebin com 2vyF8BTU
10024	Race condition in Mina2Producer Mina2Consumer when closing connections with disconnect true  There is a race condition in the Mina2Producer when trying to close connections after use by setting disconnect true or setting CamelMina2CloseSessionWhenComplete true  Connections will not be fully closed in the method maybeDisconnectOnDone  The call to session close true  returns a CloseFuture   one must await this to ensure the session is really closed  In the current implementation  there is no await on the CloseFuture  This means that the producer will be returned to the pool before the session is closed  If the next call comes right after  it is very likely that it will get the same producer and that the session will suddenly be closed while in use  leading to errors like ExchangeTimedOutException  The OUT message was not received within 30000 ms or java lang IllegalStateException  handler cannot be set while the service is active  The fix is trivial   just change line 221 in Mina2Producer java  from session close true   to long timeout   getEndpoint   getConfiguration   getTimeout     CloseFuture closeFuture   session close true    closeFuture awaitUninterruptibly timeout  TimeUnit MILLISECONDS      But the unit testing might be more complex  There might be a similar issue in Mina2Consumer   but I could not provoke it as easily  Here is a small program demonstrating the problem   on my system it will fail within the first 50 iterations  When looking at the debug log  it is clear that the connections are closed too late   after the next iteration has started      import org apache camel     import org apache camel builder RouteBuilder   import org apache camel impl DefaultCamelContext   import org slf4j              Demonstrating race condition      public class Main    public static void main String   args  throws Exception      System setProperty  org slf4j simpleLogger log org apache camel component mina2 Mina2Producer    trace     System setProperty  org slf4j simpleLogger log org apache mina filter logging LoggingFilter    trace       Logger logger   LoggerFactory getLogger Main class    CamelContext context   new DefaultCamelContext     context addRoutes new RouteBuilder       Override  public void configure   throws Exception    from  mina2 tcp   localhost 20000 sync true   setBody simple  Hello   in body                 ProducerTemplate producerTemplate   context createProducerTemplate     context start     try    for  int i   0  i &lt  10000  i       logger info       Call       i    String result    String  producerTemplate requestBody  mina2 tcp   localhost 20000 disconnect true&amp timeout 1000&amp sync true&amp minaLogger true    world     i    logger info       End call       i          result         finally    context stop
10215	EventDrivenPollingConsumer is not thread safe when used with ConsumerCache For static endpoints  if DefaultConsumerTemplate receive   is used   ConsumerCache will return the cached instance of PollingConsumer for every thread part of parallel processing of split aggregate  Now  if EventDrivenPollingConsumer is used  returning same cache instance causes race condition in receive and receive long  as the methods are not thread safe  The ordering of beforePoll  poll and afterPoll needs to be synchronized  otherwise the consumer might end up being suspended in afterPoll and the client whose beforePoll couldn t wake up the suspended thread will get no data
10229	camel rabbitmq   Race condition when stopping context with autoack false  Run the following code and hit enter while one message is in unacked state  see RabbitMQ console    public static void main String   args  throws Exception    CamelContext context   new DefaultCamelContext       context addRoutes new RouteBuilder       Override  public void configure      from  rabbitmq   localhost  queue sourceQueue&amp skipExchangeDeclare true&amp skipQueueDeclare true&amp autoAck false&amp prefetchEnabled true&amp prefetchCount 1     delayer 5000    setHeader  rabbitmq ROUTING_KEY   constant  destinationQueue      to  rabbitmq   localhost  skipExchangeDeclare true&amp skipQueueDeclare true&amp autoAck false     routeId  myRoute             context start     new BufferedReader new InputStreamReader System in   readLine     context stop          you get the following exception   com rabbitmq client impl DefaultExceptionHandler  Consumer org apache camel component rabbitmq RabbitConsumer 4c57777e  amq ctag dWpQw46flmamv0dM_Fa_Qg  method handleDelivery for channel AMQChannel amqp   rabbit_user 127 0 0 1 5672  1  threw an exception for channel AMQChannel amqp   rabbit_user 127 0 0 1 5672  1    com rabbitmq client AlreadyClosedException  channel is already closed due to clean channel shutdown  protocol method   method&lt channel close&gt  reply code 200  reply text OK  class id 0  method id 0   at com rabbitmq client impl AMQChannel ensureIsOpen AMQChannel java 195   at com rabbitmq client impl AMQChannel transmit AMQChannel java 309   at com rabbitmq client impl AMQChannel transmit AMQChannel java 303   at com rabbitmq client impl ChannelN basicAck ChannelN java 1043   at org apache camel component rabbitmq RabbitConsumer handleDelivery RabbitConsumer java 108   at com rabbitmq client impl ConsumerDispatcher 5 run ConsumerDispatcher java 144   at com rabbitmq client impl ConsumerWorkService WorkPoolRunnable run ConsumerWorkService java 99   at java util concurrent ThreadPoolExecutor runWorker ThreadPoolExecutor java 1142   at java util concurrent ThreadPoolExecutor Worker run ThreadPoolExecutor java 617   at java lang Thread run Thread java 745     I think that this is caused by a race condition between the main thread that runs channel close   immediately after channel basicCancel tag   see org apache camel component rabbitmq RabbitConsumer  without waiting the channel basicAck deliveryTag  false  in handleDelivery    Another bad side effect is that you ll find a duplicate of a message on the destinationQueue  For example if you have 10 initial messages in sourceQueue and you hit enter while it s processing the third one  you ll get 7 messages in sourceQueue and 4 messages in destinationQueue  The correct behaviour should be the following  1  Stop consumer  channel basicCancel tag  2  Wait if there is a running consumer 3  The consumer acks the previous message 4  Close the channel
10273	Jetty  missing jmx object if custom thread pool is used  If a custom configuration for the ThreadPool is passed  the correspondent JMX object is not published  The issue here is that enableJmx    https   github com apache camel blob camel 2 17 3 components camel jetty common src main java org apache camel component jetty JettyHttpComponent java L314 that adds the mbeans listeners is called only after setThread https   github com apache camel blob camel 2 17 3 components camel jetty common src main java org apache camel component jetty JettyHttpComponent java L1177 method  so this explains how come the threadpool is not exposed on JMX  I ve put a simple PR that just adds a check for enableJmx flag at component level  but I wonder if I should make it smarter to take in account possible settings only at Endpoint level or instead if we should remove it the flag per Endpoint altogether