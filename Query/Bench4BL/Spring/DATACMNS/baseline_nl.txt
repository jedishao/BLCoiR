65	BasicPersistentEntity potentially suffers from ConcurrentModificationException  BasicPersistentEntity exposes an addPersistentEntity      method to allow adding properties and essentially makes it mutable  This potentially opens it up to a concurrency problem given the following scenario  1  We concurrently use MongoTemplate for inserting objects of a type not already known to the MappingContext  2  Thread A enters getPersistentEntity      which discovers the entity not mapped already and thus calls addPersistentEntity       The algorithm in there eagerly adds the PersistentEntity object to the map of PersistentEntities to allow type self references be detected  No or some properties might have been discovered already  3  Thread B enters getPersistentEntity      which now discovers the semi parsed PersistentEntity and thus returns it  This thread continues and at some point doWithProperties      gets invoked  iterating over the PersistentProperties already registered  4  Meanwhile Thread A wants to add additional PersistentProperties and thus causes a ConcurrentModificationException in thread B
362	Potential concurrency issues in RepositoriesgetRepoInfoFor   is iterating over the key set of the repositories already cached to eagerly return RepositoryInformation instances found upfront  A second thread might have already passed that block of the code and triggered lookupRepositoryFactoryInformationFor   which writes into the repositories instance variable  This will cause a ConcurrentModificationException as reported in this issue
390	ConcurrentModificationException in MappingContextTypeInformationMapper resolveTypeFrom  I am using Spring Data and found the following Stacktrace in the logs  Caused by  java util ConcurrentModificationException I think that there might be a data race in the implementation of org springframework data mapping context AbstractMappingContext getPersistentEntities   public Collection&lt E&gt  getPersistentEntities     try   read lock    return persistentEntities values      finally   read unlock        Although the code acquires a read lock when returning the values of the HashMap  persistentEntities  it immediately releases the lock  This opens up the possibility that a thread modifies the values of  persistentEntities  while another thread is iterating over the values  The JavaDoc of java util HashMap values   says  If the map is modified while an iteration over the collection is in progress  except through the iterator s own &lt tt&gt remove&lt  tt&gt  operation   the results of the iteration are undefined   In my case I get a ConcurrentModificationException  It would be nice  if you could take a look at this issue
831	AbstractMappingContext getPersistentEntity sometimes returns an empty entity when called by multiple threads  If you call the getPersistentEntity   method in the AbstractMappingContext class with the same type from multiple threads concurrently  you will sometimes get an empty entity back  i e  an entity without any properties  This is caused by a race condition at the beginning of the addPersistentEntity   method  If one thread calls the method while another one is already executing inside the write lock in the method  the first thread will return an empty entity from the persistentEntities map even though the second thread is still populating it with properties  To fix this  the addPersistentEntity   method should acquire the read lock before accessing the persistentEntities map