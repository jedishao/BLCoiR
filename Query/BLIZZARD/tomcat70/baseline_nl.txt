39769	Wrong class loader when the myServlet destroy   called if myServlet is in the T5 shared directory  Hi all  My web app needs to have Thread currentThread   getContextClassLoader   always right  When the application is unload it seem not be the case  My classes are under the T5 s shared directory  so all my servlet getClass   getClassLoader      the shared classloader i e   StandardCalssLoader  My understanding is that when executing the code in my web app  Thread currentThread   getContextClassLoader   should always give the WebappLoader used in the StandardContext  The problem occurs in StandardWrapper unload   before calling the servlet destroy   method      ClassLoader oldCtxClassLoader   Thread currentThread   getContextClassLoader    ClassLoader classLoader   instance getClass   getClassLoader    PrintStream out   System out  if  swallowOutput    SystemLogHandler startCapture         Call the servlet destroy   method try   instanceSupport fireInstanceEvent  InstanceEvent BEFORE_DESTROY_EVENT  instance   Thread currentThread   setContextClassLoader classLoader   if  System getSecurityManager     null    SecurityUtil doAsPrivilege  destroy   instance   SecurityUtil remove instance     else   instance destroy           In the code  the INSTANCE variable is my servlet and it have been loaded by the SHARED classloader  So the classloader set in the thread is not the right one  It Should be the classloader related to StandardContext getLoader   This problem occurs when I try to close my T5 dos windows and I suppose will occurs when I will uninstall any webApp from my T5  I notice the problem in T5 5 5 16 but I verified and it s the same code in 5 5 17  So probably the problem is still there Best Regards  David Gagnon
40380	Potential syncro problem in StandardSession expire boolean   public void expire boolean notify       Mark this session as  being expired  if needed if  expiring  return     No man s land here synchronized  this    if  manager    null  return  expiring   true
42530	ManagerBase backgroundProcess throws NullPointerException  ManagerBase backgroundProcess throws NullPointerException  java lang NullPointerException Environment  Tomcat6 0 13 JDK1 5 11 TestServletF protected void doGet HttpServletRequest request  HttpServletResponse response  throws ServletException  IOException   HttpSession session   request getSession    session invalidate      Test  ab  c 3000  n 300000 http   localhost 8080 contextName TestServlet It is as follows in org apache catalina session ManagerBase  findSessions   that is called by processExpires     public Session   findSessions     Session results     null  synchronized  sessions    results   new Session sessions size             A  results    Session    sessions values   toArray results          B    return  results     In Tomcat6  sessions of ManagerBase has been changed from HashMap to ConcurrentHashMap  At the same time  synchronized operations of sessions have been removed from the methods such as findSession String is   add Session session   and remove Session session   However  if the lock of sessions is not acquired by add Session session  and remove Session session   Servlets can execute session invalidate   between  A  and  B    see above   As a result  NullpointerException is thrown by processing the 682 line of ManagerBase processExpires    if  sessions i  isValid      I think add Session session  and remove Session session  should manipulate sessions in synchronized manner like Tomcat5 5
45453	JDBCRealm getRoles bad synchronization causes hangs w  DIGEST authentication  JDBCRealm getRoles bad synchronization causes hangs w  DIGEST authentication  JDBCRealm caches PreparedStatement preparedRoles  That  and missing synchronization in JDBCRealm and or DigestAuthenticator allow two threads to call getRoles simultaneously so that T1 will do stmt executeQuery   while T2 does stmt setString 1  userName  plus another  executeQuery   on the same PreparedStatement object  In the worst case  the JDBC driver gets confused by this  and blocks forever waiting for server response  causing all other threads that try to access DB hang   This was observed with PostgreSQL 8 3 603 jdbc4 JDBC driver
47158	I think AccessLogValve has race condition problem   Double Checked Locking  pattern is heavily used in this class  but the usage of it in AccessLogValve has some issues of race condition judging by this article  http   www cs umd edu ~pugh java memoryModel DoubleCheckedLocking html  Based by this article  I think these variables in this class should be declared as volatile to get rid of race condition  private volatile long currentMillis  private volatile  Date currentDate
47524	McastServiceImpl executor is not dispatching events  Created attachment 23977  details  Fix proposal The class McastServiceImpl does not dispatch events  because the the executor is not creating threads  The class ReceiverBase has its own queue to address this issue  I have refactored the code a little to reuse the class   attaching the diff file  I m not sure if filing a bug in Bugzilla is the right procedure for Trunk branch  If not  could you please tell me how should I proceed  Regards  Ariel
48172	JspRuntimeContext synch  problems  JspRuntimeContext jspReloadCount is synchronised when updated  but not when read by getJspReloadCount    If the instance is accessed from multiple threads  then the returned value may not be the current value  it could be arbitrarily stale  If this is acceptable  then the Javadoc should say so  otherwise the getter needs to be synch   or the field needs to be volatile  Or just use AtomicInteger  Various other fields are neither final nor synchronized  e g  classpath codeSource etc  As far as I can tell  these could easily be made final as they are only written by the constructor
48234	org apache catalina core ContainerBase getLogger   not thread safe  org apache catalina core ContainerBase getLogger   is not synchronised  yet all the other methods which access org apache catalina core ContainerBase logger are synch  This seems wrong  org apache catalina core ContainerBase logger should probably be private to prevent unsynch  access by subclasses  Similar considerations apply to logName and logName    The Javadoc for getLogger   states that it can return null   that does not appear to be possible   Not sure if the method ever returns the parent logger either
48248	tribes group interceptors MessageDispatchInterceptor run should be volatile  org apache catalina tribes group interceptors MessageDispatchInterceptor run should be volatile  as it is used to communicate between running threads
48249	org apache tomcat util net NioBlockingSelector BlockPoller run    volatile  org apache tomcat util net NioBlockingSelector BlockPoller run should be volatile  as it is used to communicate between running threads
48399	Lock fields should be final  Created attachment 24715  details  Patch lock field that should be final  A field that is used as a lock should be final  org apache catalina ha session DeltaSession diffLock is protected and mutable
48790	Race condition in org apache catalina session ManagerBase maxActive  We are running tomcat 6 0 18 with a race detector  http   www alphaworks ibm com tech msdk   and find one race condition in class org apache catalina session ManagerBase field maxActive  Data Race 1   org apache catalina session ManagerBase   maxActive Thread  http 8080 3    Tid 34   WRITE Lock Set        org apache catalina session ManagerBase   add Lorg apache catalina Session  V      741   org apache catalina session StandardSession   setId Ljava lang String  V      368   org apache catalina session ManagerBase   createSession Ljava lang String  Lorg apache catalina Session       827   org apache catalina session StandardManager   createSession Ljava lang String  Lorg apache catalina Session       291   org apache catalina connector Request   doGetSession Z Lorg apache catalina Session       2324   org apache catalina connector Request   getSession Z Ljavax servlet http HttpSession       2074   org apache catalina connector RequestFacade   getSession Z Ljavax servlet http HttpSession       833   org apache catalina connector RequestFacade   getSession  Ljavax servlet http HttpSession       844   com ecyrd jspwiki auth AuthenticationManager   login Ljavax servlet http HttpServletRequest  Z      270           Thread  http 8080 1    Tid 32   READ Lock Set        org apache catalina session ManagerBase   add Lorg apache catalina Session  V      740   org apache catalina session StandardSession   setId Ljava lang String  V      368   org apache catalina session ManagerBase   createSession Ljava lang String  Lorg apache catalina Session       827   org apache catalina session StandardManager   createSession Ljava lang String  Lorg apache catalina Session       291           Here is the code snip of ManagerBase java public void add Session session    sessions put session getIdInternal    session   int size   sessions size    1        if  size   maxActive     2           maxActive   size      Statement 1 and statement 2 should executed in an atomic manner  One fix to this problem is to move statement 1 and statement 2 into a synchronized block
48843	Tomcat Acceptor Thread goes into wait   and it will never come back  Hi  I believe I ve found a race condition in Tomcat that causes the http port to be non responsive  It exists in 6 0 and also in 5 5  although the code has been refactored   I could not find any reference to it in the Bug database or the mailing list archives  Consider a tomcat instance with maxThreads set to 2  i e  you have 2 tomcat threads to service incoming requests  The sequence of events is as follows  1  Thread 1 and Thread 2 are both servicing a request each  2  A third request comes in  3  In class JIOEndpoint java  the acceptor thread calls methods processSocket   which then calls getWorkerThread   which then calls createWorkerThread    4  createWorkerThread   returns null since both threads are busy processing the two requests  5  Here is the race condition in method getWorkerThread   in the code shown below protected Worker getWorkerThread        Worker workerThread   createWorkerThread    while  workerThread    null    try   synchronized  workers    workers wait              The acceptor thread executes the  while workerThread    null   statement and is then switched out by the CPU  The two threads executing the two requests complete and go into Worker await   waiting for the next job after executing method recycleWorkerThread    The acceptor thread is switched back into CPU and executes the synchronized block and goes into the wait    At this point  there aren t any Worker threads out there processing requestsand therefore there isn t any thread to wake up the acceptor thread  The application is non responsive after this  A simple solution would be to check if curThreadsBusy   0 in the synchronized block before going into wait   in method getWorkerThread   OR increase the scope of the critical section to include the while loop  Thanks  Harshad Stack Traces below   bda19102143  id 1578 in WAITING on lock org apache tomcat util net jioendpoint wor    13aa4ee3 m at java lang Object wait Native Method  M at java lang Object wait Object java 485  M at org apache tomcat util net JIoEndpoint Worker await JIoEndpoint java 416  M at org apache tomcat util net JIoEndpoint Worker run JIoEndpoint java 442  M at java lang Thread run Thread java 619  M  http 8091 Acceptor 0  id 43 in WAITING on lock org apache tomcat util net jioendpoint workerst    13bd7b6a m at java lang Object wait Native Method  M at java lang Object wait Object java 485  M at org apache tomcat util net JIoEndpoint getWorkerThread JIoEndpoint java 700  M at org apache tomcat util net JIoEndpoint processSocket JIoEndpoint java 731  M at org apache tomcat util net JIoEndpoint Acceptor run JIoEndpoint java 313  M at java lang Thread run Thread java 619  M
48895	WebAppClassLoader clearThreadLocalMap   concurrency issues  I think that the memory leak protection of WebAppClassLoader clearReferencesThreadLocals   which detects and clears ThreadLocals that would prevent GC the WebAppClassLoader instance has issues regarding concurrency     It enumerates Threads and looks into internal structures of the Thread class  but there are no  memory barrier  that would ensure a consistent state of the ThreadLocalMap being examined  So  it is theoretically possible that a ThreadLocal in Thread A was properly cleaned up by the application  but the current thread B  that is undeploying the application  does not see the up to date state because there s no synchronization between those threads    Much more severe   after detecting such a leak  it invokes java lang ThreadLocal ThreadLocalMap remove ThreadLocal  on Thread A s ThreadLocalMap instance but the invocation is done by Thread B  the thread that undeploys the app   The remove   method is not thread safe at all  and nor is the expungeStaleEntries   method which may also be invoked in clearThreadLocalMap    So  if a webapp is being undeployed while other applications continue to receive a heavy load of requests  this could corrupt the internal structures of the ThreadLocalMap instance  I propose to keep the detection of leaks as it is  but to make the actual clearing optional  and disabled by default  to avoid encountering big problems in production  Idea to improve the clearing in a safe way   if the thread that is  provoking  the leak is one of tomcat s worker threads  we could mark it as  dirty   and then have a background task that would end such threads  renew those threads in the pool
49129	DigestAuthenticator md5Helper   possible incorrect lazy initialisation  Findbugs says   This method contains an unsynchronized lazy initialization of a non volatile static field  Because the compiler or processor may reorder instructions  threads are not guaranteed to see a completely initialized object  if the method can be called by multiple threads  You can make the field volatile to correct the problem
49144	Incorrect lazy initialization and update of static fields  Incorrect lazy initialization and update of static fields  org apache catalina startup Bootstrap daemon org apache catalina startup ContextConfig contextDigester Findbugs says  This method contains an unsynchronized lazy initialization of a static field  After the field is set  the object stored into that location is further updated or accessed  The setting of the field is visible to other threads as soon as it is set  If the futher accesses in the method that set the field serve to initialize the object  then you have a very serious multithreading bug  unless something else prevents any other thread from accessing the stored object until it is fully initialized  Even if you feel confident that the method is never called by multiple threads  it might be better to not set the static field until the value you are setting it to is fully populated initialized
49567	when starting a new thread from a startAsync Runnable  an infinite amount of doPosts is generated  Created attachment 25728  details  testcase demonstrating the bug when starting a new thread from a startAsync Runnable  an infinite amount of doPosts is generated  Also  the GET status is  500 Internal Server Error  however  there is no exception thrown by tomcat  The attached code demonstrates this  by printing  Start async    an infinite amount of times
49730	Race condition in StandardThreadExecutor   requests are sometimes enqueued instead of creating new threads  In tomcat 6  I often configure an Executor with minSpareThreads 0 to work around memory leak issues upon redeployment  Sometimes  especially in development   when I refresh a page of my webapp with Safari  Chrome or Firefox  some resources of the page take several seconds   10s  to be served though they are static resources and should come in less than 50ms  For instance  over 15 requests for a page  1 for html  the others for resources like js  css  images      I sometimes have 1 or 2 that take  10s  After analysis  I found that in org apache catalina core StandardThreadExecutor TaskQueue offer Runnable  the statement if  parent getActiveCount    parent getPoolSize     is sometimes true unexpectedly  Here is the scenario     ThreadPoolExecutor is empty   the user refreshes the page  or accesses it with an empty cache  in his web browser for a page that uses a more than 10 15 resources   the browser establishes one TCP connection and a new Thread is created   after the browser receives the response  it decides to load as many resources as possible in parallel  For this it establishes up to 6 TCP connections  in my tests    The Acceptor thread calls StandardThreadExecutor execute to process each incoming connection    For each call  StandardThreadExecutor TaskQueue offer Runnable  is being called   if you study the sources of Java 6 ThreadPoolExecutor  you can see that there s a small delay between the time a new Thread is created  thus increasing poolSize  and the time it starts working on its first task  increasing the activeCount    Since in my case connections are established in a rapid burst  the calls to TaskQueue offer   are sometimes faster than this small delay  so that we do have parent getActiveCount   parent getPoolSize   and thus the task is enqueued instead of forcing the creation of a thread to serve it    Since Keep Alive is enabled and tomcat 6 threads take care of only one TCP connection at a time  the requests in the queue must wait for the keep alive timeout so that a Thread is returned to the pool to serve pending tasks    With 25s keepAliveTimeOut  it means that some requests take more than 25s to be served eventhough the pool was never full and the server quite idle Other facts about this issue     Although my test case starts with an empty pool  it can occur even on a loaded server  The thing that triggers the issue is the burst of new TCP connections    The problem is less severe with a lower keepAliveTimeout  or if keepalive is disabled  In any case  it also depends on the time taken to serve current requests    The issue also affects tomcat 7 but is less severe because tc7 threads are returned to the pool after each http request  even if the TCP connection is kept alive  The impact would the same as with tc6 with keepAlive disabled
49905	In cluster  when using DeltaManager memory leak can occur  Created attachment 26008  details  Patch to remove context classloader from threads in ThreadPoolExecutor in tribes  Tested on apache tomcat 6 0 29 running under jdk 1 6 0_18  When DeltaManager is instantiated and assigned in StandardContext start    is it done AFTER StandardContext bindThreads    DeltaManager  in turn  during initalization  asks for sessions in other nodes  and this may result in creating threads in ThreadPoolExecutor in tribes  These threads created with contextClassLoader set to current webapplication WebAppClassLoader  This results in memory leak and error message during redeployment in tomcat log  09 09 2010 14 46 19 S     WebappClassLoader clearReferencesThreads  The web application   creditdev  appears to have started a thread named  pool 1 thread 1  but has failed to stop it  This is very likely to create a memory leak  Stacktrace  at java util concurrent ThreadPoolExecutor addIfUnderCorePoolSize Unknown Source  Proposed solution   implement java util concurrent ThreadFactory in MessageDispatch15Interceptor and pass instance on ThreadPoolExecutor executor creation  This instance must call setContextClassLoader null  in newThread   overriden method
49985	Lazy initialization without any synchronization   data race in AstInteger  AstFloatingPoint  AstString  r998053 http   svn apache org repos asf tomcat tc6 0 x trunk java org apache el parser AstInteger java http   svn apache org repos asf tomcat tc6 0 x trunk java org apache el parser AstFloatingPoint java http   svn apache org repos asf tomcat tc6 0 x trunk java org apache el parser AstString java Use lazy init without any synchronization in methods getInteger    getFloatingPoint    getString    respectively  Consider AstInteger  private Number number  protected Number getInteger     if  this number    null    try   this number   new Long this image     catch  ArithmeticException e1    this number   new BigInteger this image       return number    Data races on variable number  37 in method getInteger    39 concurrent read on line 40 concurrent write on lines 42  44
49987	Data race in ApplicationContext  r998053 http   svn apache org repos asf tomcat tc6 0 x trunk java org apache catalina core ApplicationContext java Data race on variable  private Map parameters In method private void mergeParameters     if  parameters   null      concurrent read   881 return  Map results   new ConcurrentHashMap        parameters   results     concurrent write   897
50138	Lack of synchronization in org apache catalina security SecurityUtil  Symptom  all processor threads spin madly in                  tomcat processor 20  daemon prio 10 tid 0x09210800 nid 0x51fb runnable  0x61b76000  java lang Thread State  RUNNABLE                    Cause  org apache catalina security SecurityUtil objectCache is a HashMap  but access to it is not synchronized  The javadoc for HashMap says                Note that this implementation is not synchronized  If multiple threads access a hash map concurrently  and at least one of the threads modifies the map structurally  it must be synchronized externally                Proposed solution  change objectCache to ConcurrentHashMap
50293	javax el CompositeELResolver synchronization issue  Created attachment 26310  details  Synchronize change in CompositeELResolver add  The javax el CompositeELResolver add method needs to synchronize around the update to the resolvers  If two threads call add  then it is possible for both threads get past the size check  then one thread updates the size  and when the next thread tries to update the size  it fails with an ArrayIndexOutOfBoundsException  Also  it makes sense to increase the default size of the ELResolver array since even the jasper EL adds 5 ELResolvers  I propose a default of 8
50352	AsyncListener onComplete is not called after AsyncContext complete   is called  Using servlet 3 async features  when asyncContext complete    is called from an async thread  the AsyncListener onComplete   method is not called though it should be  Example Servlet   package test  import java io IOException  import javax servlet AsyncContext  import javax servlet AsyncEvent  import javax servlet AsyncListener  import javax servlet ServletException  import javax servlet annotation WebServlet  import javax servlet http HttpServlet  import javax servlet http HttpServletRequest  import javax servlet http HttpServletResponse        Servlet implementation class MyServlet     WebServlet value     MyServlet   asyncSupported   true  public class MyServlet extends HttpServlet implements AsyncListener   private static final long serialVersionUID   1L  protected void doGet HttpServletRequest request  HttpServletResponse response  throws ServletException  IOException   final AsyncContext asyncContext   request startAsync request  response   asyncContext addListener this   asyncContext start new Runnable      Override public void run     try   Thread sleep 5   1000   asyncContext getResponse   getWriter   write  Hello world    asyncContext complete      catch  Exception e    e printStackTrace               Override public void onComplete AsyncEvent arg0  throws IOException   System out println  onComplete     arg0      Override public void onError AsyncEvent arg0  throws IOException   System out println  onError     arg0      Override public void onStartAsync AsyncEvent arg0  throws IOException   System out println  onStartAsync     arg0      Override public void onTimeout AsyncEvent arg0  throws IOException   System out println  onTimeout     arg0
50353	Calling asyncContext getResponse   returns null after async timeout  If the async thread calls asyncContext getResponse   after the async timeout  it gets a null reference  In the following example  it leads to a NPE  The servlet spec is not very clear on the behavior to adopt after a timeout  but I don t think null should be returned  Maybe an IllegalStateException instead  It seems to be the case if complete   is called after the timeout  package test  import java io IOException  import java io PrintWriter  import javax servlet AsyncContext  import javax servlet AsyncEvent  import javax servlet AsyncListener  import javax servlet ServletException  import javax servlet ServletResponse  import javax servlet annotation WebServlet  import javax servlet http HttpServlet  import javax servlet http HttpServletRequest  import javax servlet http HttpServletResponse        Servlet implementation class MyServlet     WebServlet value     MyServlet   asyncSupported   true  public class MyServlet extends HttpServlet implements AsyncListener   private static final long serialVersionUID   1L  protected void doGet HttpServletRequest request  HttpServletResponse response  throws ServletException  IOException   final AsyncContext asyncContext   request startAsync request  response   asyncContext addListener this   asyncContext setTimeout 10 1000   asyncContext start new Runnable      Override public void run     System out println  Entering async thread    try   Thread sleep 20   1000   System out println   Asyncthread  about to write response    ServletResponse response2   asyncContext getResponse    PrintWriter writer   response2 getWriter    writer write  Hello world    System out println   Asyncthread  about to complete    asyncContext complete      catch  Exception e    e printStackTrace               Override public void onComplete AsyncEvent evt  throws IOException   System out println  onComplete     evt      Override public void onError AsyncEvent evt  throws IOException   System out println  onError     evt      Override public void onStartAsync AsyncEvent evt  throws IOException   System out println  onStartAsync     evt      Override public void onTimeout AsyncEvent evt  throws IOException   System out println  onTimeout     evt   evt getAsyncContext   getResponse   getWriter   write  Timed out    evt getAsyncContext   complete
50459	StandardContext bindThread   and unbindThread   are not symmetrical and not limited to current thread  As a side effect of my commit  I think I found a bug in StandardContext bindThread   and unbindThread   methods in both tomcat 6 and 7     the methods should be symmetrical   unbindThread should restore the Thread CCL after calling DirContextURLStreamHandler unbind   and ContextBindings unbindThread     StandardContext bindThread   should call DirContextURLStreamHandler bindThread   instead of DirContextURLStreamHandler bind     StandardContext unbindThread   should call DirContextURLStreamHandler unbindThread   instead of DirContextURLStreamHandler unbind
50547	The CHANGE_SESSION_ID message that received during cluster session synchronization is dropped  Neither CHANGE_SESSION_ID message nor SESSION_EXPIRED message set timestamp  If these messages are received during cluster sessions synchronization in DeltaManager startup  because the timestamp is not set  they are dropped  I made a patch that add timestamp for CHANGE_SESSION_ID and SESSION_EXPIRED message  Best Regards
50554	Bad use of getClass   could potentially lead to concurrency bugs in future  The method org apache naming java javaURLContextFactory getInitialContext Hashtable       has a synchronized block on getClass    Using getClass   as lock is a bug pattern because if some class subclasses javaURLContextFactory and getInitialContext gets called on an instance of such a subclass  getClass   will return a different Class object for that instance  Locking different objects for different classes is usually not the expected behavior  Therefore  I suggest to remove this bug pattern by simply replacing getClass   by javaURLContextFactory class  See https   www securecoding cert org confluence display java LCK02 J  Do not synchronize on the class object returned by getClass 28 29 for more information about this bug pattern  Keshmesh  https   github com reprogrammer keshmesh   is an Eclipse plugin that analyzes the source code of Java programs to detect concurrency bug patterns such the one I reported
50629	Make the bindThread unbindThread method protected  In the latest Tomcat codes  I saw that a new thread is created for listener start  filter start and loadOnStartup  But the two methods bindThread and unbindThread is marked as private  how about making those methods protected  So that other containers could use those two methods for their own initialization works  Thanks
51185	Performance  DataSourceProxy createPool should use more fine grained synchronisation Hello  I don t know if this is the right component  My Enhancement concerns new Tomcat JDBC POOL  Looking at code I think that DataSourceProxy createPool should not be synchronized but use another private method that is synchronized and used only when creation is needed  something like that        Sets up the connection pool  by creating a pooling driver     return Driver    throws SQLException    public ConnectionPool createPool   throws SQLException   if  pool   null    return pool    else   return pCreatePool                 return    throws SQLException    private synchronized ConnectionPool pCreatePool   throws SQLException   if  pool   null    return pool    else   pool   new ConnectionPool poolProperties   return pool      Currently since createPool   is called for lots of getters we get this synchro IMPACT without really needing it  Regards Philippe http   www ubik ingenierie com
51197	sendError sendRedirect don t work with AsyncContext  For some reason  response sendRedirect and response sendError are not producing expected behavior when using an AsyncContext  On the server side  the async request completes normally  and everything looks hunky dory  but the client never gets ANY response from the server  It appears that Tomcat simply times out after the default 10 seconds and closes the connection  No headers are returned  no content  nothing  I ve confirmed with thread dumps that the server isn t stuck  Yet   if you use response setStatus and response setHeader instead  it works absolutely fine  The client gets the response every time  I put together a very simple test that isolates the issue reliably  https   github com dcheckoway async test See the README in there for details  NOTE  the behavior for sendError changed slightly from 7 0 12 to 7 0 14  As of 7 0 14  sendError seems to close the connection immediately  but the client still never gets any response of any kind
51212	QueryStats has synchornisation issues  Created attachment 27017  details  Patch with Atomic approach Hello  I don t know if it is volontary but I think QueryStats fields should be Atomic because they are accessed by multiple threads at same time  I made a Load test with heavy load and collected results of SlowQueryReport and I get Sql queries with 0 as number of executions which is wrong as they have been executed at least once  By the way I don t know which approach will perform better    synchronize add failure   Use Atomic Maybe you did this for performance reasons  Regards Philippe Mouawad http   www ubik ingenierie com
51467	usage of method run instead of start to start a thread  In StandardContext method Thread run is used  This is most probably a mistake  since a few lines below Thread join is called to wait for the completion of the thread  So we could either remove the join and get rid of the thread by using just a runnable  or start the thread
51545	make threadname available in ExtendedAccessLogValve  Created attachment 27309  details  Threadname usable in ExtendedAccessLogValve  As discussed on the tomcat users mailinglist  http   old nabble com thread name in extended access log valve tt32101677 html make the threadname of the thread  that served the request  available to the ExtendedAccessLogValve
51688	JreMemoryLeakPreventionListener should protect against AWT thread creation  Any webapp that calls java awt Toolkit getDefaultToolkit will launch a new thread  AWT Windows  AWT XAWT  etc   which will capture the ContextClassLoader  pinning the webapp in memory after an undeploy redeploy  A simple addition to JreMemoryLeakPreventionListener can alleviate this condition
52055	ChunkedInputFilter is not recycled for servlet 3 0 asynchronous request  I m using the standard servlet 3 0 async APIs with tomcat 7 0 22  The server side code is something like the following  final AsyncContext asyncContext   request startAsync           in a processing thread asyncContext getRequest   getInputStream        read the input stream asyncContext complete    The InputStream returns 0 bytes for the HTTP post with chunking  After debugging  I found that the ChunkedInputFilter is reused by org apache coyote http11 AbstractInputBuffer  But it has never been recycled  nextRequest     before the reuse for another request  As a result  the endChunk flag is always true after the first request  And it always return immediately without reading more from the buffer
52091	TagHandlerPool is slow when high concurrently  TagHandlerPool is slow when I ran stress test my web application using tomcat7  It occured in 7 0 19  Profiler said that it causes are followings  1  Lock of log instance at org apache jasper runtime TagHandlerPool  2  Lock of parameters field at org apache catalina core StandardWrapper getInitParameter  An attached patch resolve this issue in my environment  It makes following changes  1  Makes log field to static  2  At StandardWrapper  changes lock policy from synchronized block to ReentrantReadWriteLock
52213	Field  org apache catalina tribes transport bio util FastQueue enabled  should be volatile  The boolean flag  org apache catalina tribes transport bio util FastQueue enabled  may be read written by multiple threads concurrently  See  http   svn apache org repos asf svn bc 1203897 tomcat trunk java org apache catalina tribes group interceptors MessageDispatchInterceptor java    Therefore  accesses to it should be properly synchronized  It is sufficient to make this boolean flag volatile to protect access to it  See  https   www securecoding cert org confluence display java VNA00 J  Ensure visibility when accessing shared primitive variables  for more information about this bug pattern  Keshmesh  https   keshmesh cs illinois edu   is an Eclipse plugin that analyzes the source code of Java programs for common concurrency bug patterns  We used Keshmesh to detect this concurrency bug pattern
52259	synchonization issues and dead lock if no realm is presented in configuration  Problem  Tomcat 7 0 23 startup freezes at  INFO  Deploying web application directory      Nuances    no errors are displayed in logs   tomcat process can t be shutted down with shutdown sh script   http request on 80 port wait forever   it s a multi host configuration   the same setup works well on all previous build  including 7 0 22   when lib   jar files of tomcat 7 0 23 are replaced with lib   jar files of tomcat 7 0 23   everything works just fine fix it asap thank you fill free to contact for details  a19596 mail ru
52356	Prevent potential data races on  org apache catalina tribes transport bio util FastQueue size   Even though accesses to  org apache catalina tribes transport bio util FastQueue size  are synchronized inside  org apache catalina tribes transport bio util FastQueue add ChannelMessage  Member    InterceptorPayload   and  org apache catalina tribes transport bio util FastQueue remove     the read access in  org apache catalina tribes transport bio util FastQueue getSize    is not properly synchronized and thus can lead to a race condition  However   org apache catalina tribes transport bio util FastQueue getSize    is not used  so this bug never manifests  Nevertheless  we suggest that Tomcat developers either remove  org apache catalina tribes transport bio util FastQueue getSize    or make it access the shared field safely  Field  org apache catalina tribes transport bio util FastQueue size  is declared at  http   svn apache org repos asf svn bc 1220560 tomcat trunk java org apache catalina tribes transport bio util FastQueue java
52777	Automatically shut down old versions in parallel deployment  Under parallel deployment  when an older version in an application has zero sessions  shut it down automatically to release tomcat and JVM resources  Christopher Schultz suggested these approaches might be possible  on the Tomcat user list   1  Modify the parallel deployment code to register an MBean  NotificationListener that filters for useful events  such as expiring session notifications on the outgoing webapp   2  When the listener receives a notification  check the current state  e g  session count 0  or  I suppose you could make this a part of your filter in step  1   If session count   0  start a new thread that stops the outgoing webapp and de registers the listener  Or  1  Install a SessionEventListener that counts down the sessions  you ll have to get the count from JMX  I suppose  until they equal 0  then starts a new thread that     etc  Or  1  Install a Timer thread that polls at intervals  1 minute   to see if all the sessions are dead and then starts a thread     etc  The first idea seems the cleanest  though Tomcat might not actually fire MBean events for things like session count changing
52999	Performance issue with locking in ContainerBase fireContainerEvent    This was reported on dev list  1     2  org apache catalina core ContainerBase fireContainerEvent    That method contains critical section     synchronized  listeners             list   listeners toArray list           Is is called pretty often with every put operation into request or   session map  That code in tomcat looks like a candidate for   CopyOnWriteArrayList   I confirm that I see fireContainerEvent   calls in many places in StandardSession  Moreover those are two nested loops   a loop in StandardSession over array of context getApplicationEventListeners    x copying the list of container listeners inside into array in context fireContainerEvent    I cannot confirm reported problem with request attributes   I do not see anything in the code that would send events from that access  Is it possible to solve it with a ReadWriteLock  Or it would be better to have a helper class that avoids copying the array over on every access  the said copy on write one   I classify this as an enhancement request   1  Thread  Two performance problems  found during myfaces testing   on dev list  starting on 2012 03 08    http   tomcat markmail org thread 7bbvzmkvyvryvn44   http   marc info  t 133124021200002&r 1&w 2
53173	maxConnections feature hangs the system  Created attachment 28704  details  fix missing count down for maxConnections latch We ve run into a scenario where the JIO Acceptor thread hangs as connections are not counted down properly   Executor name  tomcatThreadPool  namePrefix  tomcat 8080   minSpareThreads  50  maxThreads  300     Connector port  8080  redirectPort    bio https port   protocol  org apache coyote http11 Http11Protocol  maxKeepAliveRequests  15  executor  tomcatThreadPool  connectionTimeout  20000  acceptCount  100    Thread dump yields  http bio 8080 Acceptor 0  daemon prio 3 tid 0xXXXXXXXX nid 0xXX waiting on condition  0xXXXXXXXX  0xXXXXXXXX  java lang Thread State  WAITING  parking    parking to wait for   0xXXXXXXXX   a org apache tomcat util threads LimitLatch Sync  This  as you may imagine  is a fairly hard use case to reproduce into a simple test case  The easiest way to reproduce it is to create the following configuration  Executor name  tomcatThreadPool  namePrefix  catalina exec   maxThreads  5  minSpareThreads  0  maxQueueSize  15     Connector port  8080  protocol  HTTP 1 1  executor  tomcatThreadPool  connectionTimeout  10000  redirectPort  8443  maxConnections  30    This reproduces one test case  where the state machine is not taking into account that connections may be rejected by the queue  but it doesn t count down the latch  I m attaching a patch to fix this specific use case  but it may not be a complete fix  As a workaround  the patch also introduces the maxConnections   1  configuration that disables the usage of maxConnections  The  1 setting is important to give administrator a workaround while the other edge cases are tracked down  I have not been able to reproduce this error with NIO connector  There is one more place in the JioEndpoint that requires handling of RejectedExecutionException in the public boolean processSocketAsync SocketWrapper Socket  socket SocketStatus status  This is currently unhandled
53450	Deployment of an application with  ROOT  context hangs forever  Hi  The scenario is the following    I have running Tomcat 7 0 28   I deploy an application with  ROOT  context   The deployment hangs forever  When taking a tread dump  the following is suspicious   localhost startStop 2  daemon prio 6 tid 0x0000000006607800 nid 0x2560 waiting on condition  0x0000000009ebf000  java lang Thread State  WAITING  parking    parking to wait for   0x00000007d80f0108   a java util concurrent locks ReentrantReadWriteLock NonfairSync  As you can see   Then every listener is invoked to process the container event   Unfortunately in the ReentrantReadWriteLock it is stated that upgrade from read to write lock is not possible  Reentrancy also allows downgrading from the write lock to a read lock  by acquiring the write lock  then the read lock and then releasing the write lock  However  upgrading from a read lock to the write lock is not possible   Regards Violeta Georgieva
53498	Atomicity violation bugs because of misusing concurrent collections  Created attachment 29021  details  The patch that may fix the atomicity violation bugs  My name is Yu Lin  I m a Ph D  student in the CS department at UIUC  I m currently doing research on mining Java concurrent library misusages  I found some misusages of ConcurrentHashMap in Tomcat 7 0 28  which may result in potential atomicity violation bugs or harm the performance  The code below is a snapshot of the code in file java org apache catalina core ApplicationContext java from line 761 to 767 and line 1262 to 1266 L761        found   attributes containsKey name   L762        if  found    L763            value   attributes get name   L764            attributes remove name   L765          else   L766            return  L767              L1262       if  parameters containsKey name     L1263           return false  L1264         L1265 L1266       parameters put name  value   In the code above  an atomicity violation may occur between lines 762 and 763  Suppose thread T1 executes line 761 and finds that the concurrent hashmap  attributes  contains the key  name   Before thread T1 executes line 763  another thread T2 removes the  name  key from  attributes   Now thread T1 resumes execution at line 763 and will get a null value for  name   Then the next line will throw a NullPointerException when invoking the method on  name   Second  the snapshot above has another atomicity violation  Let s look at lines 1262 and 1266  Suppose a thread T1 executes line 1262 and finds out the concurrent hashmap dose not contain the key  name   Before it gets to execute line 1266  another thread T2 puts a pair  name  v  in the concurrent hashmap  parameters   Now thread T1 resumes execution and it will overwrite the value written by thread T2  Thus  the code no longer preserves the  put if absent  semantics  I found some similar misusages in other files  In java org apache catalina ha context ReplicatedContext java  similar atomicity violation may occur when another thread T2 remove the key  name  from concurrent hashmap  tomcatAttributes  before thread T1 executes line 172  In java org apache catalina startup HostConfig java  suppose thread T1 executes line 1480 and finds out the concurrent hashmap dose not contain the key  contextName   Before it executes line 1509  another thread T2 puts a pair  contextName  v  in the concurrent hashmap  deployed   Now thread T1 resumes execution and it will overwrite the value written by thread T2  Indeed  the putIfAbsent method shoule be used rather than put method at line 1509
53624	sendRedirect doesn t work after a dispatch through the AsyncContext  A call to sendRedirect after AsyncContext dispatch doesn t redirect and returns with a 200 status code instead  A project demonstrating the issue  https   github com rstoyanchev dispatch test Build and deploy the source in the  tomcat issue repro   From the home page of the deployed application  select the  Redirect  scenario  The scenario involves Servlet  RedirectA  that creates a thread and dispatches to Servlet  RedirectB   which in turn redirects to Servlet  RedirectC  and that forwards to a simple JSP page  Instead of the JSP page rendering  you should see a blank page and the log output will show that processing ended at ServletC  For details on the setup see WebAppInitializer setupRedirectScenario ServletContext       FWIW if a forward is used instead of a dispatch from the async thread  the scenario works  To do that  modify the line that creates servlet  RedirectA  to be ForwardingAsyncServlet instead of DispatchingAsyncServlet      This issue is very similar to 51197  which was marked resolved in 7 0 25  The current issue was tested against 7 0 29
53843	isAsyncStarted may return false in thread that started async processing  After async processing starts in some container thread A  subsequent calls to request isAsyncStarted   return true as expected  However as soon as an application thread B calls asyncContext dispatch    isAsyncStarted   begins to return false even if the actual dispatch has not yet occurred  For this case the spec says   the dispatch operation will be delayed until after the container initiated dispatch has returned to the container   For the brief period after dispatch   is called but before the actual dispatch begins  and DispatcherType becomes ASYNC   isAsyncStarted should return true  Without that  the return value of isAsyncStarted   may suddenly change while thread A is still exiting causing it to not recognize that async processing started and that it needs to exit as quickly as possible
54045	ReplicatedMap don t like TcpFailureDetector in static configuration  Tribes stack using    TcpPingInterceptor   TcpFailureDetector   MessageDispatchInterceptor   StaticMembershipInterceptor Do not work well in static cluster  First side  ie one thread     call to TcpFailureDetector heartbeat     call to checkMembers false    call to performBasicCheck   in synchronized membership    in performBasicCheck  for a missing static node      add  missing  member to membership with membership memberAlive m          HERE THE SECOND THREAD HAVE SOME TIME TO WORK     check it with memberAlive m      remove it since if it doesn t exist Second side  ie another thread     some call to channel getMembers   like what the done by AbstractReplicatedMap   this call will call the TcpFailureDetector getMembers     this one could return a wrong value since it can contains unavailable nodes Note    synchronize on membership isn t use by TcpFailureDetector in getMember    getMembers    hasMembers    neither in Membership equivalent method  maybe because it s too heavy to lock every thread while the TcpFailureDetector check if node are alive   It must not be an issue for AbstractReplicatedMap since with or without TcpFailureDetector a node could disapear while replicated map try to use it  But ReplicatedMap use always Channel SEND_OPTIONS_DEFAULT where the value is Channel SEND_OPTIONS_USE_ACK  So a message sent to a missing node will fail with an exception  Personnaly I override TcpFailureDetector heartbeat   to avoid performBasicCheck   if I use a static configuration  TcpPingInterceptor call performForcedCheck     But this doesn t fix ReplicatedMap issue  Better fix could avoid adding missing member to membership list    Add a method like memberAlive MemberImpl  to Membership without side effect  add the member    in TcpFailureDetector performBasicCheck    check this new method before adding the node This doesn t fix the AbstractReplicatedMap issue which work always with acknoledge from other nodes  Same code for Tomcat 6  best regards F Arnoud
54086	ConcurrentModificationException in NioReceiver on shutdown  Solaris 10 x86  jdk 1 7  We use tomcat clustering for session replication with 4 nodes and sometimes 8 nodes  We get a ConcurrentModificationException occasionally on shutdown  I have been unable to reliably reproduce the exception  In the log  I see  Unable to close cluster receiver selector   with the exception below  java util ConcurrentModificationException org â€‹apache â€‹catalina â€‹tribes â€‹transport â€‹nio â€‹NioReceiver â€‹closeSelector â€‹NioReceiver â€‹java 382  org â€‹apache â€‹catalina â€‹tribes â€‹transport â€‹nio â€‹NioReceiver â€‹stopListening â€‹NioReceiver â€‹java 365  org â€‹apache â€‹catalina â€‹tribes â€‹group â€‹ChannelCoordinator â€‹stop â€‹ChannelCoordinator â€‹java 115  org â€‹apache â€‹catalina â€‹ha â€‹tcp â€‹SimpleTcpCluster â€‹stopInternal â€‹SimpleTcpCluster â€‹java â€‹744  sun â€‹reflect â€‹DelegatingMethodAccessorImpl â€‹invoke â€‹DelegatingMethodAccessorImpl â€‹java 43  I looked at the code briefly and noticed the use of a SelectionKey Iterator  I have not dug deep enough to find any issue in the NioReceiver code  but I did find this potentially relevant text in the Selector javadocs  http   docs oracle com javase 7 docs api java nio channels Selector html    A selector s key and selected key sets are not  in general  safe for use by multiple concurrent threads  If such a thread might modify one of these sets directly then access should be controlled by synchronizing on the set itself  The iterators returned by these sets  iterator methods are fail fast  If the set is modified after the iterator is created  in any way except by invoking the iterator s own remove method  then a ConcurrentModificationException will be thrown
54521	DigestAuthenticator  nonceCountValid   fails in case of simultaneous asynchronous requests of the same client  Concerned components  org apache catalina authenticator DigestAuthenticator org apache catalina authenticator DigestAuthenticator NonceInfo Scenario  A multithreaded client sends two requests within one millisecond  The DigestAuthenticator creates for each request a nonce as well as a NonceInfo instance  The two nonces are equal  as they were created within the same millisecond  When writing data into the cache  method generateNonce     the second NonceInfo instance overwrites the first one  same key   Problem  The two client threads then send a second request with a digest authentication header  In both requests  â€œncâ€   nonce count  is equal â€œ1â€   as the nonce has been newly created  In the NonceInfo of the first request  array â€œseenâ€  is set to â€œtrueâ€  for index   nonceCount   offset    seen length   In the second request the same NonceInfo instance is used  as the instance is retrieved from map â€œnoncesâ€  using â€œnonceâ€  as a key  that is  in both requests the same key is used  Consequently  method â€œnonceCountValid  â€œ returns â€žfalseâ€œ  as  seen  nonceCount   offset    seen length   has already been set to â€žtrueâ€œ  Therefore the authentication fails  although the client has sent a valid digest authentication header  Conclusion  Working with multi threaded clients with many requests  digest authentication does not function reliably
55267	NIO thread locked  Did some load test and thread got stuck  see dump  Basically I just simulate 100 users that connect and disconnect
55309	Concurrent issue of TagPluginManager  Created attachment 30629  details  Patch on TagPluginManager  TagPluginManager is shared within ServletContext  But it contains a variable  PageInfo pageInfo   PageInfo should be aligned with specified page  PageInfo is used for holding page information  such as  Import   So when there are two pages are compiled in parallel  It encounters concurrent issue  One of the page can t be compiled unless the server is restarted
55521	Race Condition in HttpSession invalidate     HttpServletRequest getSession boolean   Created attachment 30798  details  code flow that exhibits the race condition For session fixation protection  we have to discard a user s session and create a new one whenever the user s login state changes  For this we rely on Spring Security s SessionFixationProtectionStrategy that  at its core  uses the following commands  session invalidate    session   request getSession true   Yesterday  we had a message in the log that indicates the latter command returned the same session that was invalidated in the line before   Your servlet container did not change the session ID when a new session was created  You will not be adequately protected against session fixation attacks  catalina exec 339  org springframework security web authentication session SessionFixationProtectionStrategy  SessionFixationProtectionStrategy java 102   When I investigated this issue  I found there is in fact a race condition if two threads  associated with requests from the same client  enter the session fixation protection code in parallel  I attached a TXT file that illustrates the code flow that leads to the race condition  When thread B calls session invalidate    the call returns immediately becuase the session is already in the  expiring  state  Since the session is not invalid yet  the call to request getSession true  won t create a new session  though  So in effect  thread B cannot obtain a new session  The documentation at http   tomcat apache org tomcat 7 0 doc servletapi  has no indication that a session may not yet be invalid when session invalidate   returns  The session interface neither provides a way to detect  expiring  session  The error message appears only once in the production log files that go some weeks back  so it seems to be an infrequent event  Nevertheless  it should be possible to implement session fixation without a race condition  Regards Christoph
55524	Deadlock produced during Websocket write operation  org apache catalina websocket WsOutbound   Created attachment 30800  details  thread dump of the deadlock  I use Tomcat with an application that uses Websockets  The websockets are handled by the Atmosphere framework  https   github com Atmosphere atmosphere A deadlock occurs during write operations to the websocket  I have attached a thread dump of the deadlock  This issue is also duscussed here  https   github com Atmosphere atmosphere issues 1264 Here are the deadlocked threads  Found one Java level deadlock                                 Atmosphere Shared AsyncOp 267   waiting to lock monitor 0x00007efebc0015f8  object 0x00000005ef4c6988  a org apache catalina websocket WsOutbound   which is held by  Atmosphere Scheduler 2   Atmosphere Scheduler 2   waiting to lock monitor 0x00007efe8c290ac0  object 0x00000005ef4b77f8  a org atmosphere cpr AtmosphereResourceImpl   which is held by  Atmosphere Shared AsyncOp 267  Java stack information for the threads listed above                                                       Atmosphere Shared AsyncOp 267     waiting to lock  0x00000005ef4c6988   a org apache catalina websocket WsOutbound    locked  0x00000005ef4b77f8   a org atmosphere cpr AtmosphereResourceImpl   Atmosphere Scheduler 2     waiting to lock  0x00000005ef4b77f8   a org atmosphere cpr AtmosphereResourceImpl    locked  0x00000005ef4c6988   a org apache catalina websocket WsOutbound
55582	Concurrent issue of TagFileProcessor  Created attachment 30871  details  Unsynchronized getting wrapper from RuntimeContext  The following code has concurrent issue  JspRuntimeContext rctxt   ctxt getRuntimeContext    JspServletWrapper wrapper   rctxt getWrapper wrapperUri   synchronized  rctxt    if  wrapper    null         It creates duplicated JspServletWrapper in this scenario  A jsp     C tag B jsp     C tag A jsp and B jsp are both compiling and come to the given lines  Two threads all get null from JspRuntimeContext JspServletWrapper    null   So two instances of JspServletWrapper was created
55684	WebappClassLoader getThread want an access to root ThreadGroup  Tomcat may not have all permissions granted  The method WebappClassLoader getThread try to access the root ThreadGroup in order to list all threads  You should either manage SecurityException or avoid to access the parent ThreadGroup of the thread which start Tomcat
55799	Stability issues when concurrently sending large messages  Created attachment 31055  details  Test case  modifications to the Chat example  Hi  a thread on the Users List  1  described that problems can occur when sending large messages over a WebSocket connection using getBasicRemote   sendText String   The ChatAnnotation class does not synchronize when using this method  which means that multiple threads could call RemoteEndpoint Basic sendText   concurrently  The JavaDoc of RemoteEndpoint Basic says   If the websocket connection underlying this RemoteEndpoint is busy sending a message when a call is made to send another one  for example if two threads attempt to call a send method concurrently  or if a developer attempts to send a new message while in the middle of sending an existing one  the send method called while the connection is already busy may throw an IllegalStateException    I thought I had read earlier that the implementation should synchronize calls to methods of RemoteEndpoint Basic instead of throwing an ISE  but maybe that has changed   When sending large Messages over Websocket using RemoteEndpoint Basic from different threads without or with synchronization  some problems happen like  a  The WebSocket connection is suddenly closed  I guess the browser actually aborts the connections due to data corruption or Timeout errors  but I have not examined the raw data sent over TCP  b  Various Exceptions occur  see below  c  Sometimes when I open the chat xhtml example in my browser  it shows what seems to be a raw WebSocket response instead of the  xhtml file  see added screenshots  These issues also happen after synchronizing calls to RemoteEndpoint Basic sendText    but are then harder to reproduce  To reproduce  1  Checkout Tomcat 8 trunk  r1543467  and apply the attached patch  It applies some modifications to the Chat Websocket Example  so that the Javascript sends messages in a regular interval  50 ms   and the ChatAnnotation modifies the message to be 256 times as large as the original message  and sends it back using session getBasicRemote   sendText msg   1  Build Tomcat and run it on a Windows machine  I used Windows 8 1 x64  Java 1 7 0_45 x64   using the NIO HTTP connector  default configuration   2  Open Firefox and IE 11  With both browsers  open the Chat example  http   localhost 8080 examples websocket chat xhtml   1  Repeat the following actions in a regular interval  a  Wait several seconds  it might be that Tomcat already closes one of the two WebSocket connections in that time   b  On one of the browsers  e g  IE   press F5 several times  1  After some time  you can see that in one of the browsers  the WebSocket connection is suddenly closed  Tomcat will show one or more of the following exceptions  I think the IOException and ClosedChannelException are expected if the browser aborts the connection   19 Nov 2013 23 18 39 809 SEVERE  http nio 8080 ClientPoller 0  org apache tomcat util net NioEndpoint processSocket Error allocating socket processor java lang NullPointerException 19 Nov 2013 23 32 16 601 SEVERE  http nio 8080 exec 3  websocket chat ChatAnnotation onError Chat Error  java nio channels ClosedChannelException java nio channels ClosedChannelException 19 Nov 2013 23 32 19 658 SEVERE  http nio 8080 exec 2  websocket chat ChatAnnotation onError Chat Error  java lang IllegalArgumentException  java lang reflect InvocationTargetException java lang IllegalArgumentException  java lang reflect InvocationTargetException Caused by  java lang reflect InvocationTargetException     15 more Caused by  java nio charset CoderMalfunctionError  java nio BufferOverflowException     19 more Caused by  java nio BufferOverflowException     25 more 19 Nov 2013 23 32 23 353 SEVERE  http nio 8080 exec 10  websocket chat ChatAnnotation onError Chat Error  java io IOException  Eine vorhandene Verbindung wurde vom Remotehost geschlossen java io IOException  Eine vorhandene Verbindung wurde vom Remotehost geschlossen If you try to press F5  then it might be that the Websocket connection is closed as soon as it was opened  or that the browser doesn t get a response for the request to chat xhtml  Now  add synchronization by modifying ChatAnnotation s broadcast   method  private static void broadcast String msg    for  ChatAnnotation client   connections    synchronized  client    try   client session getBasicRemote   sendText msg     catch  Exception e            and repeat the above steps  Now  if you open chat xhtml with both IE and Firefox and do nothing  the WebSocket connection will not be closed  Even if you start to repeatedly press F5  most of the time everything will appear normal  besides getting IOExceptions and ClosedChannelExceptions   However  after I tried this several minutes  I still got the problems that the WebSocket connections are closed just after opening it  or after some time   or that the browser didn t get a response to its HTTP request  or that the browser got a raw WebSocket reply instead of the XHTML page reply  see added screenshots   I also got these exceptions  20 Nov 2013 00 18 20 037 SEVERE  http nio 8080 exec 9  websocket chat ChatAnnotation onError Chat Error  java io IOException  java util concurrent ExecutionException  java io IOException  Key must be cancelled java io IOException  java util concurrent ExecutionException  java io IOException  Key must be cancelled Caused by  java util concurrent ExecutionException  java io IOException  Key must be cancelled     14 more Caused by  java io IOException  Key must be cancelled     14 more 20 Nov 2013 00 32 53 483 SEVERE  http nio 8080 exec 3  org apache tomcat util net NioEndpoint SocketProcessor doRun java lang NullPointerException 20 Nov 2013 00 35 19 333 SEVERE  http nio 8080 exec 15  org apache tomcat websocket server WsHttpUpgradeHandler destroy Failed to close WebConnection while destroying the WebSocket HttpUpgradeHandler java lang NullPointerException 20 Nov 2013 00 35 19 327 SEVERE  http nio 8080 exec 15  org apache coyote http11 AbstractHttp11Processor process Error processing request java lang IllegalArgumentException  1  http   markmail org message ee3jch4zj2orltzs
55996	Async context does not timeout with HTTP NIO connector  Created attachment 31200  details  Servlet with Async processing and Java Based client I created a ProblemServlet which receives request via a Java based client  The Servlet starts an Async processing for each request  Within the Async processing run   method there is a while loop which cyclically sends String messages to the client  The implementation of run method is shown  public void run     try   String msg       ServletOutputStream outputStream   publisherAsyncCtx getResponse   getOutputStream    boolean continu   true  while  continu    msg       msg               new Date    System out println  publishing message        msg   outputStream println msg   publisherAsyncCtx getResponse   flushBuffer    try   Thread sleep 1000     catch  InterruptedException e    System out println  sleep InterruptedException      e getMessage     e printStackTrace          When a Java based console application client hits this servlet and reads its output stream  for around 10 sec the messages arrive  But after 10 seconds the connection is closed by the server  Logs on the Server side  Starting the Async Context  publishing message      Mon Jan 13 11 28 30 IST 2014 publishing message      Mon Jan 13 11 28 31 IST 2014 publishing message      Mon Jan 13 11 28 32 IST 2014 publishing message      Mon Jan 13 11 28 33 IST 2014 publishing message      Mon Jan 13 11 28 34 IST 2014 publishing message      Mon Jan 13 11 28 35 IST 2014 publishing message      Mon Jan 13 11 28 36 IST 2014 publishing message      Mon Jan 13 11 28 37 IST 2014 publishing message      Mon Jan 13 11 28 38 IST 2014 publishing message      Mon Jan 13 11 28 39 IST 2014 publishing message      Mon Jan 13 11 28 40 IST 2014 publishing message      Mon Jan 13 11 28 41 IST 2014 Exception in thread  http bio 8080 exec 6  java lang IllegalStateException  The request associated with the AsyncContext has already completed processing  Issue is seen with  apache tomcat 7 0 50    apache tomcat 7 0 47   Not tested with other release 7 variants  The same codebase when run on  apache tomcat 8 0 0 RC10  there are no issues
56042	java lang IllegalStateException  Calling  asyncComplete    is not valid for a request with Async state  MUST_DISPATCH   The issue appears if the response has been set before startAsync  response setStatus HttpServletResponse SC_BAD_REQUEST   AsyncContext asyncContext   request startAsync request  response   asyncContext dispatch    You might wonder why would anyone do that  The actual scenario is a bit more complex  It involves a separate thread that completes very fast  even before startAsync is called  The resulting stack trace  java lang IllegalStateException  Calling  asyncComplete    is not valid for a request with Async state  MUST_DISPATCH  The Servlet spec says   It is illegal to call startAsync if      or if the response has been committed and closed        If that is indeed the reason  a clear error should be raised  and startAsync not be allowed to proceed  Or perhaps it is an issue that can be fixed  For what it s worth it actually works in Jetty even though the spec says it is illegal
56082	ConcurrentModificationException with org apache juli ClassLoaderLogManager  Created attachment 31267  details  Source to reproduce In Tomcat  java util logging LogManager getLogManager   is in general an instance of org apache juli ClassLoaderLogManager  In a webapp  when iterating over the result of LogManager getLogManager   getLoggerNames    a ConcurrentModification can sometimes occur  To reproduce     download attached test 1 0 zip   run  mvn clean package  using Maven   copy  target test 1 0 war  into tomcat webapps   start Tomcat   see a lot of  Issue reproduced  java util ConcurrentModificationException  in the System output This webapp uses simple Logger getLogger String  and LogManager getLoggerNames   in threads  I my case  this is reproduced using Tomcat 7 0 42 and JDK 1 7  I suppose that a copy of the result could be made in org apache juli ClassLoaderLogManager getLoggerNames
56518	NIO async servlet limit latch leak  Created attachment 31613  details  the sample webapp to reproduce the bug we have encouter this bug in a real product webapp  I have tested this in linux x86  oracle jdk jdk1 7 0_55  tomcat 7 0 53 and tomcat 8 0 5  CONFIG  we change HTTP Connector to NIO in  server xml   e g  protocol  org apache coyote http11 Http11NioProtocol  WEBAPP LOGIC  the simplified situation  1  call  req startAsync    to start async serlvet  then execute the async logic in our user thread  2  sometimes the user thread be interrupted  by some timeout logic of our code   3  some user code call  resp flushBuffer    to send response to client PROBLEM  in the situation descibed above  the  LimitLatch countDown    is not called  when the connections limit latch count up to max   default  10000     tomcat DO not accept any connection  all incoming client hangs  REPRODUCER  in a clean tomcat 7 0 53 installation  1  change the default  server xml  Connector config   1  change protocol  org apache coyote http11 Http11NioProtocol   2  Optional  add maxConnections  100  to reproduce the bug faster  2  copy the sample webapp in the attachment to  webapps ROOT war  3  start tomcat  4  make plenty request to   async html   for    i   0  i   15000    i      do echo  i  curl localhost 8080 async html  done each request is likely cause a limit latch leak  when the requests reaches maxConnections  100 as we set above  or some more  the client   curl   hangs  TECHNIC DETAILS  after some debug  wo found these  1  when the thread was interrupted  when the user code call  resp flushBuffer     the NioChannel was Closed by jdk NIO code  and a ClosedByInterruptException is thrown  2  when the channel closed  the SelectionKey was removed by Poller thread  stack trace  Daemon Thread  http nio 8080 ClientPoller 0   Suspended  owns  Object   id 3346  owns  HashSet E    id 3354  owns  EPollSelectorImpl   id 82  owns  Collections UnmodifiableSet E    id 3355  owns  Util 2   id 3356  SocketChannelImpl AbstractSelectableChannel  removeKey SelectionKey  line  114 EPollSelectorImpl AbstractSelector  deregister AbstractSelectionKey  line  168 EPollSelectorImpl implDereg SelectionKeyImpl  line  162 EPollSelectorImpl SelectorImpl  processDeregisterQueue   line  131 EPollSelectorImpl doSelect long  line  69 EPollSelectorImpl SelectorImpl  lockAndDoSelect long  line  69 EPollSelectorImpl SelectorImpl  select long  line  80 NioEndpoint Poller run   line  1163 Thread run   line  662 3  when we call  ctx complete     it run to  org apache tomcat util net NioEndpoint processSocket NioChannel  SocketStatus  boolean    code is below  public boolean processSocket NioChannel socket  SocketStatus status  boolean dispatch    try   KeyAttachment attachment    KeyAttachment socket getAttachment false   if  attachment    null    return false    since the SelectionKey was removed  the  attachment  returns null  the logic is break   AbstractEndpoint countDownConnection    is not called  a limit latch leak happens  WORK AROUND  some work around  1  switch to the stable BIO connector  2  avoid call  resp flushBuffer    in the user thread
56577	Inappropriate executor in WsServerContainer  The executor service to process SendHandler for sendAsync calls is initialized in WsServerContainer  which is using an unbounded queue  Thus  no more than corePoolSize threads will ever be created   And the value of the maximumPoolSize therefore doesn t have any effect     1  The corePoolSize has a default value to be 1  though it could be changed by context parameter  it s still hard to find an optimized value  This will create an issue if using the SendHandler to close the session after sending the last message  An example stack trace is like the following   WebSocketServer  spring websocket test 1  daemon prio 10 tid 0x00007f9f040ec000 nid 0x7499 waiting on condition  0x00007f9f73af8000  java lang Thread State  TIMED_WAITING  parking    parking to wait for   0x000000075d52f018   a java util concurrent CountDownLatch Sync    locked  0x000000075d7dc388   a java lang Object  If all the threads are in this state  there will be no available threads to clear any SendHandler and all Remote send methods would throw TimeoutException though actually the clients could receive the messages   1  http   docs oracle com javase 7 docs api java util concurrent ThreadPoolExecutor html
56653	Concurrency issue with Mapper ContextList when stopping Contexts  I noticed this issue while reviewing the code of Mapper removeContextVersion   of the current trunk   1604217   The same code exists in Tomcat 7 and 6  In Mapper removeContextVersion    Mapper removeContext   in Tomcat 6  it does the following      host contextList contexts   newContexts     Recalculate nesting host contextList nesting   0  for  int i   0  i   newContexts length  i      int slashCount   slashCount newContexts i  name   if  slashCount   host contextList nesting    host contextList nesting   slashCount          The problem is there is a delay between when the list of contexts is updated  contextList contexts  and the contextList nesting field is updated  The  nesting  field is used when mapping contexts  For example  1  If there are the following contexts  ROOT foo foo bar 2  Context foo bar is being stopped  3  A request for  foo  comes in  e g  http   localhost foo index html Expected behaviour  Map the context to foo application  Actual behaviour  It may be that the request will be erroneously mapped to the ROOT webapp instead of  foo   I have a test case
56724	Restart Container background thread if it died unexpectedly  To address the issue that has been raised several times on the mailing lists  e g  http   tomcat markmail org thread xooxcq56ehki63dh  ContainerBackgroundProcessor and compounding OOMEs  http   tomcat markmail org thread f6b6vicg7kusckra  Background thread died  no errors in log  invoking backgroundProcess via JMX has no effect  I think it is OK to start a new background thread after some delay  If the start succeeds  it will be a new thread with its own  clean  stack  It may help for StackOverflowError  It might partially help with OutOfMemoryError thread death if nothing else is available  but a better strategy for an admin to handle an OutOfMemoryError is to start JVM with  XX OnOutOfMemoryError flag with a script that shuts down  and restarts  Tomcat
56746	Webssocket secure client thread cannot access webapp resources  The new SecureIOThreadFactory method in org apache tomcat websocket AsyncChannelWrapperSecure sets the context class loader of the secure websocket client threads to it s own standard class loader   thus preventing the them from accessing webapp resources  Removing this line restores access  as the new threads then have the classloader of the calling  webapp  thread
56857	Thread safety issue in ApplicationContextFacade invokeMethod  Multiple subsequent Thread dumps were exhibiting lots of threads hanging in HashMap get   while in RUNNABLE status  and consuming high CPU   a typical indicator of a thread safety issue with these non threadsafe Maps  Thread stacks all as below  ApplicationContextFacade implements ServletContext  these objects are singletons per webapp  and get passed around among multiple threads  Their private member  objectCache  is a HashMap  i e  not thread safe  but gets accessed AND modified without any synchronization in invokeMethod    Suggested remedy  change to a ConcurrentHashMap  which is thread safe  and performs much better than synchronizing on every access   connector 93  userId _101_1  sessionId C9EC1C59DD2244557BC6231A5476000E  daemon prio 10 tid 0x00007fb1e40cf800 nid 0x7b90 runnable  0x00007fb1e82c3000  java lang Thread State  RUNNABLE
56907	Threads leak  Hello  While using WebSocket implementation of versions 7 0 55 and 8 0 11 leaking threads were noticed  Use method WsWebSocketContainer connection  endpoint  clientEndpointConfiguration  path  to reproduce this issue  The URL to specify a non existent page  As a result  the connection will return an error  404 Not Found   but the threads that have been created in the class AsyncChannelWrapperSecure will stay alive for a long time  source of threads creation  private final ExecutorService executor   Executors newFixedThreadPool  2  new SecureIOThreadFactory        Count of threads are increasing with every reconnect attempt to non existent URL  Those will live for a very long time  until you disable the application that calls the connection WsWebSocketContainer connection        Leakage threads can be observed using the jvisualvm program  Please  make it possible to deal with such kind of situations and destroy unused threads
57265	Tomcat 8 hiden behind NGINX fails to send file when using NIO connector  We have moved Tomcat 8 server behind the nginx balancing server and have started  experiencing this problem  org apache tomcat util net NioEndpoint NioBufferHandler 2001a157 26 Nov 2014 11 37 04 476 SEVERE  http nio 8443 ClientPoller 0  org apache tomcat util net NioEndpoint Poller processSendfile java lang IllegalArgumentException  You can only read using the application read buffer provided by the handler  Problem occurres irregularly when loading lots of scripts refencenced by homepage  It seems to be ok with useSendfile false  I have tried to add some slow logging  with flushing output  to code and it lowers occurrence rate  so it looks like some race condition problem
57338	SingleSignOnEntry cache of ClusterSingleSignOn valve is not synchronized on Tomcat startup  When using the ClusterSingleSignOn valve  it looks like the single sign on session state is not synchronized to cluster nodes when they start  The state is instead only replicated at the moment that an action is performed  so any nodes that come online after that action are out of sync  See mailing list discussion here  http   www mail archive com users tomcat apache org msg115472 html
57340	NioConnector caches get corrupted on concurrent comet close  Configuration  Tomcat 7 0 47 NioConnector  nginx 1 6 2  atmosphere 2 2 3  It happens when nginx and atmosphere close the same comet connection concurrently  In NioEndpoint Poller thread A  the SocketChannel becomes ready for read when nginx closes it  Poller unregisters the channel for read and forks another thread B  to handle close event   see NioEndpoint 1239  Then atmosphere calls close on the connection in thread C  and Tomcat receives internal action with code ActionCode COMET_CLOSE and adds the channel to the Poller  which registers it for read again   see Http11NioProcessor java 462   The SocketChannel is still readable in case thread B  hasn t invalidated the SelectionKey yet  so Poller in thread A  initiates the closing process again and forks thread D   Thread B  completes the closing process and puts NioChannel and AttachmentKey into the corresponding caches  Then Thread D  tries to close the channel again and realizes that it has already been closed  see AbstractProtocol java 564  and puts the same NioChannel and AttachmentKey into caches  Caches become corrupted because they contain 2 references to the same object  Then any 2 subsequent requests may get the same NioChannel and AttachmentKey and some crazy stuff may happen  mixed up responses  etc
57420	Wrong class names generated since URL_ENCODER in DirContextURLConnection is not thread safe  We ve been debugging this for a long time  Sometimes when tomcat starts up  it will fail to deploy a webapp since it cannot find a certain class  That class name is always complete garbage  The error stack trace always is  SEVERE  Unable to process resource element  jndi  localhost testapp WEB INF classes ch blabli dNlewrP lculgiansDisalog 3 class  for annotations java io FileNotFoundException  jndi  localhost testapp WEB INF classes ch blabli dNlewrP lculgiansDisalog 3 class From time to time we see  that the referenced class name is actually a mix of the real class name and one or more other classes that exist in the vicinity of that class  Finally I was able to catch this exception with the debugger  What I see is that the problem stems from rg apache catalina startup ContextConfig processAnnotationsJndi ContextConfig java 1986     dcUrlConn  DirContextURLConnection  contains the correct entries of the WAR file   Enumeration String  dirs   dcUrlConn list    however does not  Calling list   again from the debugger yields the correct results  Here s the contents of that dirs variable   lCsosn  oCrAopnpfliigcEadtiitoonr AEpdpiltiocraMtoidoen  c2l acslsass    tCioonnfi gu4r aticolnaLsosad  liconaftgiuroatni o5n LocadlLaisstsen  cCaotnifiognur a6 clastsi  lCaonsfsig  s  cluaiss  CwoindgfetisegtEditorApplication 9 class  ConfigEditorApplication ApplicationConfigLoadListener class  ConfigEditorApplication ConfigEditorToParameterHandlerIntegration class  ConfigEditorApplication EditorMode 1 class  ConfigEditorApplication EditorMode 2 class  ConfigEditorApplication EditorMode class  ConfigEditorApplication class  ConfigLoader 1 class  ConfigLoader class  ConfigurationLoadListener ConfigType class  ConfigurationLoadListener ConfigurationLoadedEvent class  ConfigurationLoadListener FailedToLoadConfigurationEvent class  ConfigurationLoadListener class  command  data  field  rendering  session  ui  util  widgetset  walking into the list   command leads to collection list      which in turn is encoded using an URL_ENCODER  class UEncoder   This URL_ENCODER is  not  thread safe and can result in exactly such garbage if used concurrently  It is interesting to note that every single failure we had at this step was always caused by classes in the WEB INF classes directory  never in JAR files in WEB INF lib  To me it appears that there are two different DirContextURLConnections with rare concurrency issues when both use the same URL_ENCODER  Here s the full stacktrace when the error occurs  Jan 06  2015 3 43 44 PM org apache catalina startup ContextConfig processAnnotationsJndi SEVERE  Unable to process resource element  jndi  localhost medusa config editor 5 48 0 WEB INF classes ch ergon medusa configeditor ui dialog TeerstRelgeaxsDialog class  for annotations java io FileNotFoundException  jndi  localhost medusa config editor 5 48 0 WEB INF classes ch ergon medusa configeditor ui dialog TeerstRelgeaxsDialog class Jan 06  2015 3 43 44 PM org apache catalina startup ContextConfig processAnnotationsJndi SEVERE  Unable to process resource element  jndi  localhost medusa config editor 5 48 0 WEB INF classes ch ergon medusa configeditor ui dialog aTsesxtAreaDialog 2 class  for annotations java io FileNotFoundException  jndi  localhost medusa config editor 5 48 0 WEB INF classes ch ergon medusa configeditor ui dialog aTsesxtAreaDialog 2 class
57681	Allow parallel class loading in web application class loader by synchronizing on class specific object  Created attachment 32553  details  Parallel classloading port from Tc8 0 into Tc7 0 Related to fix in Tomcat8 0  Fix https   issues apache org bugzilla show_bug cgi id 56530 Add a web application class loader implementation that supports the parallel loading of web application classes  Source file to patch  https   svn apache org viewvc tomcat tc7 0 x trunk java org apache catalina loader WebappClassLoader java revision 1661811&view markup
57683	Crash of stockticket async example caused by an aborted client request  I mentioned this issue in  Time for 7 0 60  thread on dev   It is a bug with error handling in example webapp  It is not a regression from recent changes  It is reproducible with 7 0 59  Steps to reproduce  Using Tomcat 7 0 59  JDK 6u45  1  Start Tomcat 2  Visit stockicker example  http   localhost 8080 examples async stockticker 3  Abort the request while the page is being loaded  Press  Esc  key on keyboard  4  Re visit the example http   localhost 8080 examples async stockticker Expected  Working stockicker example  Actual  1  Browser waits for a response  After several seconds the progress indicator stops  A blank page is displayed  1  Access log shows response status 200  but byte counter is zero        127 0 0 1      10 Mar 2015 17 45 31  0300   GET  examples async stockticker HTTP 1 1  200   1  Looking into catalina 2015 03 10 log  there is the following exception      10 03 2015 17 36 58 org apache coyote AbstractProcessor setErrorState INFO  An error occurred in processing while on a non container thread  The connection will be closed immediately java net SocketException  Software caused connection abort  socket write error     1  Looking at console  There is the same exception as in  3    followed by the following exception      java lang IllegalStateException  The request associated with the AsyncContext has already completed processing      Essentially  the async Stockticker thread crashed due to a non handled ISE  This explains the behaviour  1  The exception in  4   is logged to the console only  It is not logged into Tomcat log files
57779	Deadlock if using separate thread to write to ServletOutputStream  If using a separate  non container  thread to write to a ServletOutputStream  a deadlock can occur  if an io error occurs during write  For example  if the client drops the connection  This is caused by a synchronized operation on the the underlying socket object  The servlet handling thread is blocked  while waiting for the end of output from the separate thread  and holds a lock on the socket object   http bio 25030 exec 10  daemon prio 10 tid 0x0000000001804800 nid 0x3fd0 waiting on condition  0x00007f767aeeb000  java lang Thread State  WAITING  parking    parking to wait for   0x00000000c3b273b8   a java util concurrent locks AbstractQueuedSynchronizer ConditionObject        locked  0x00000000c38ef6d8   a org apache tomcat util net SocketWrapper  The separate thread trys to write  but an io error occurs   Thread 13  daemon prio 10 tid 0x00007f767c5c8000 nid 0x3fda waiting for monitor entry  0x00007f767a4e2000  java lang Thread State  BLOCKED  on object monitor    waiting to lock  0x00000000c38ef6d8   a org apache tomcat util net SocketWrapper  Now it trys to get a lock on the socket object and both threads are blocked forever  In the former tomcat version we used  7 0 53  this was not an issue  I had a look in the source code and saw that the failing code was invented later
57943	NioEndpoint  one poller thread died  when i restart tomcat the tomcat can not process request soon find an error log  Exception in thread  http nio 7001 ClientPoller 1  java util ConcurrentModificationException tomcat poller thread is not catch this exception so this thread is died  connection is accept but has no poller thread to process
57959	Deadlock in FileHandler java when log is rotated  Tomcat 7 will deadlock when a log file is rotated  This issue has been fixed in latest tomcat 6 and tomcat 8 but not in tomcat 7  The issue is in following code  apache tomcat 7 0 62 src java org apache juli FileHandler java 188    finally   writerLock writeLock   unlock       Down grade to read lock  This ensures the writer remains valid    until the log message is written writerLock readLock   lock        Despite the comment the order is wrong  you have to acquire a read lock then release write lock to make sure the race condition does not occur  The correct way to do it is    finally   writerLock readLock   lock    writerLock writeLock   unlock        In tomcat 6  apache tomcat 6 0 44 src java org apache juli FileHandler java 187  and tomcat 8  apache tomcat 8 0 22 src java org apache juli FileHandler java 186  the order is correct
57977	The original class loader isn t re bound to the thread in PersistentValve invoke    Created attachment 32769  details  patch against trunk In PersistentValve invoke Request  Response  method  The Webapp class loader has been bound to the current thread  However  the original class loader that had been used before bind isn t restored to the thread  The original class loader should be re bound to the thread
58179	Atomicity violation  My name is Bai Guangdong  a research fellow from National University of Singapore  I find an atomicity violation similar to bug 53498  The problem occurs in the same file java org apache catalina core ApplicationContext java  Look at the code snippet below  L791         oldValue   attributes get name   L792         if  oldValue   null  L793             replaced   true  L794         attributes put name  value           L801         if  replaced  L802             event   L803                 new ServletContextAttributeEvent context getServletContext    L804                                                  name  oldValue   L805         else L806             event   L807                 new ServletContextAttributeEvent context getServletContext    L808                                                  name  value           L816                 if  replaced    L817                     context fireContainerEvent L818                           beforeContextAttributeReplaced   listener   L819                     listener attributeReplaced event   L820                     context fireContainerEvent  afterContextAttributeReplaced   L821                                                listener   L822                   else   L823                     context fireContainerEvent  beforeContextAttributeAdded   L824                                                listener   L825                     listener attributeAdded event   L826                     context fireContainerEvent  afterContextAttributeAdded   L827                                                listener   Suppose two threads T1 and T2 executes this code snippet with the same key   name    Initially   attributes  is empty  T1 executes line 791 and  oldValue  in T1 becomes null  Before T1 executes line 794  T2 executes 791 and  oldValue  in T2 becomes null as well  Then T1 executes line 794  and later T2 replaces T1 s  value  at line 794  Afterwards  both T1 and T2 fire the  beforeContextAttributeAdded  event at line 823  However  in the above situation   replaced  in T2 should be true and  beforeContextAttributeReplaced  should be fired at line 817
58522	concurrency problem corrupts WARDirContext Entry children  We discovered a problem where calling ServletContext getResourcePaths from a jsp may corrupt WARDirContext Entry children  The WARDirContext list Entry  method performs an Arrays sort children  call which is not thread safe  Calling this from multiple request threads may result in the children array losing some entries and duplicating others  When entries representing directories in the war are lost  Tomcat cannot load resources from there  Static resource requests result in http error code 404 and jsp compliation can throw JasperException when included files are not found  We have seen this on CentOS 6 5  and newer versions  with Tomcat 7 0 52 and Java 1 7 0_51  The following are attached in the zip    Test case project which demonstrates this corruption  It usually requires multiple runs    A stack trace illustrating the problematic flow    A patch file for WARDirContext java
58946	ApplicationHttpRequest should enforce immutability of ParameterMap  JavaDoc for ServletRequest getParameterMap    both ours and the one at Oracle site  1  says   Returns  an immutable java util Map containing        The problem is that this immutability is not enforced by org apache catalina core ApplicationHttpRequest class that is used to implement included or forwarded requests  Note that org apache catalina util ParameterMap class used for usual  not forwarded  requests does enforce immutability  An example of message from that class is shown below  Reproducible with current Tomcat 8 0 dev  Steps to reproduce                      1  Put the following two JSPs into ROOT web application  test jsp        page contentType  text plain charset UTF 8  import  java util         RequestDispatcher rd   request getRequestDispatcher  test2 jsp    rd forward request  response          test2 jsp        page contentType  text plain charset UTF 8  import  java util         Map map   request getParameterMap    map put  foo    bar           map        2  Call http   localhost 8080 test jsp z a Actual           The following response is observed       foo bar  z  Ljava lang String  3877a5      Expected            If I call the test2 jsp application directly  the behaviour is as expected  http   localhost 8080 test2 jsp z a HTTP Status 500   An exception occurred processing JSP page  test2 jsp at line 4 root cause java lang IllegalStateException  No modifications are allowed to a locked ParameterMap                          I noticed this issue while performing code review  inspired by a thread started 2016 01 19 on users mailing list  2    1  http   docs oracle com javaee 7 api javax servlet ServletRequest html getParameterMap    2  http   tomcat markmail org thread 3hq4fghtoxcj44i5
59138	checkThreadLocalMapForLeaks has false positives  ThreadLocal ThreadLocalMap weakly references keys but strongly references values  However  it appears the checkThreadLocalMapForLeaks checking reports false positives if the key is a ThreadLocal subclass  e g   anonymous class  but the value does not strongly reference the class loader  e g   Integer  int   List SimpleDateFormatter   etc    Example output  07 Mar 2016 11 27 08 258 SEVERE  localhost startStop 2  org apache catalina loader WebappClassLoaderBase checkThreadLocalMapForLeaks The web application  servlettest 0 1  created a ThreadLocal with key of type  servlettest TestServlet 1   value  servlettest TestServlet 1 40d92399   and a value of type  java lang Integer   value  1   but failed to remove it when the web application was stopped  Threads are going to be renewed over time to try and avoid a probable memory leak  For large web applications with many such false positives  this output makes tracking down  or even noticing new  real issues more difficult  Third party libraries refuse to adjust their use of ThreadLocal because they believe  IMO rightly  their code is not causing leaks  I have read bug 50175 comment 6  but given that the current heuristic has false positives  can some compromise be reached   Perhaps some configuration for stifling the warning on a per key class name basis could be added   It would even be acceptable for us if that configuration hid the per instance message but issued a single overall  suppressing N ThreadLocal warnings based on config  info warning message