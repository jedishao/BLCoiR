RedissonFairLock timeout drift
We've discovered additional conditions that produce timeout drift as originally described in #1104.
To summarize the issue, we see that the timeouts in the redisson_lock_timeout sorted set created by RedissonFairLock can gradually increase over time to be hours or days in the future despite the queue only containing less than 10 threads; this condition continues until the fair wait queue empties, or one of the threads dies and the rest of the threads are forced to wait for the far in the future timeout on the dead thread to lapse (this creates a dead lock-like situation).
I'll provide a PR to follow shortly with test cases and proposed changes to fix the issue.
We greatly appreciate feed back on any misunderstanding of the issue described here and will do the same for feedback on the PR.
Expected behavior
The expected behavior is that which is documented in the second paragraph of 8.2 Fair Lock:

All waiting threads are queued and if some thread has died then Redisson waits its return for 5 seconds.
For example, if 5 threads are died for some reason then delay will be 25 seconds.

As an example that replicates this documentation, given we have 7 threads trying to take one lock, we expect the redis data structures to contain roughly the following after a 7 threads try to acquire the lock once using RLock.tryLock(threadId) in order with short delays between:
> HGETALL example_fair_lock
1) lock name of the 1st thread
2) "1"

> LRANGE redisson_lock_queue:{example_fair_lock} 0 -1
1) lock name of the 2nd thread
2) lock name of the 3rd thread
3) lock name of the 4th thread
4) lock name of the 5th thread
5) lock name of the 6th thread
6) lock name of the 7th thread

> ZRANGE redisson_lock_timeout:{example_fair_lock} 0 -1 WITHSCORES
1) lock name of the 2nd thread
2) lock timeout + 5s
3) lock name of the 3rd thread
4) lock timeout + 10s
5) lock name of the 4th thread
6) lock timeout + 15s
7) lock name of the 5th thread
8) lock timeout + 20s
9) lock name of the 6th thread
10) lock timeout + 25s
11) lock name of the 7th thread
12) lock timeout + 30s

In the above we see that the 7th thread will need to wait 25s after the lock expiration (based on the lease time) until it can acquire the lock if the 1st to 6th threads die.
Additionally, we expect that when a thread leaves the queue voluntarily either by wait timeout or by acquiring the lock, that timeouts adjust regardless of where the thread was in the queue.
For example, if the 3rd thread in the above example left the queue via a RedissonFairLock.acquireFailedAsync call due to wait timeout, the sorted set would then be expected to be:
1) lock name of the 2nd thread
2) lock timeout + 5s
5) lock name of the 4th thread
6) lock timeout + 10s
7) lock name of the 5th thread
8) lock timeout + 15s
9) lock name of the 6th thread
10) lock timeout + 20s
11) lock name of the 7th thread
12) lock timeout + 25s

And the 7th thread would then only need to wait 20s after the lock expiration to acquire the lock if the other threads died.
Actual behavior
In one of our usages of redisson we use the fair lock using 3-6 servers using each a single instance of Redisson running roughly the following code in one thread per server:

We observe that since the work done within the locked portion of the code can take only ~100ms that the 6 server threads running this code quickly churn through the lock queue without issue, though a queue is always present since there is little time between when each thread unlocks and locks again. If we take periodic snapshots of the redisson_lock_timeout sorted set, we tend to see that the timeouts increase in increments of 5s over time until the timeouts are hours or days in the future. If one of the servers is killed, then we observe that the other servers stop doing work and are timing out trying to get the lock due to the dead server's lock holding the first position in redisson_lock_queue with a timeout in redisson_lock_timeout that may be hours or days in the future. We expect that under the case that we lose one server of 6, that the timeout values will be in the range of 10 to 35s in the future at any one time (5s lease time + 5s thread wait time * position in queue). It may be said that the above lock usage itself may be foolish, but its mostly working except for the chance of deadlock.
Steps to reproduce or test case
I'll provide a PR for this issue to follow with additional test cases added to RedissonFairLockTest. However, what we started with was a modification of the testTimeoutDrift where we changed the wait time from 500ms to 3s and changed the lock holding time from 30s to 100ms (see Thread.sleep(30000)); with this test case, instead of the tryLock failing due to wait timeout, the threads are able to lock and unlock the lock quickly. The new version of the test, the test fails with a timeout drift into the futre, in a similar way that the test failed in #1104.
The PR will contain other test cases with the hope that we cover all code changes and produce the expected behavior described above.

We run a single redis server for use exclusively by redisson
