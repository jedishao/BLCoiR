Stability issues when concurrently sending large messages.
Test case (modifications to the Chat example)
Hi, a thread on the Users List [1] described that problems can occur when sending large messages over a WebSocket connection using getBasicRemote().sendText(String).
The ChatAnnotation class does not synchronize when using this method, which means that multiple threads could call RemoteEndpoint.Basic#sendText() concurrently.
The JavaDoc of RemoteEndpoint.Basic says:
"If the websocket connection underlying this RemoteEndpoint is busy sending a message when a call is made to send another one, for example if two threads attempt to call a send method concurrently, or if a developer attempts to send a new message while in the middle of sending an existing one, the send method called while the connection is already busy may throw an IllegalStateException."
(I thought I had read earlier that the implementation should synchronize calls to methods of RemoteEndpoint.Basic instead of throwing an ISE, but maybe that has changed).
When sending large Messages over Websocket using RemoteEndpoint.Basic from different threads without or with synchronization, some problems happen like:
a) The WebSocket connection is suddenly closed (I guess the browser actually aborts the connections due to data corruption or Timeout errors, but I have not examined the raw data sent over TCP)
b) Various Exceptions occur (see below)
c) Sometimes when I open the chat.xhtml example in my browser, it shows what seems to be a raw WebSocket response instead of the .xhtml file (see added screenshots)
These issues also happen after synchronizing calls to RemoteEndpoint.Basic#sendText(), but are then harder to reproduce.
To reproduce:
1) Checkout Tomcat 8 trunk (r1543467) and apply the attached patch.
It applies some modifications to the Chat Websocket Example, so that the Javascript sends messages in a regular interval (50 ms), and the ChatAnnotation modifies the message to be 256 times as large as the original message, and sends it back using session.getBasicRemote()#sendText(msg).
1) Build Tomcat and run it on a Windows machine (I used Windows 8.1 x64, Java 1.7.0_45 x64), using the NIO HTTP connector (default configuration).
2) Open Firefox and IE 11.
With both browsers, open the Chat example (http://localhost:8080/examples/websocket/chat.xhtml).
1) Repeat the following actions in a regular interval:
a) Wait several seconds (it might be that Tomcat already closes one of the two WebSocket connections in that time).
b) On one of the browsers (e.g. IE), press F5 several times.
1) After some time, you can see that in one of the browsers, the WebSocket connection is suddenly closed.
Tomcat will show one or more of the following exceptions (I think the IOException and ClosedChannelException are expected if the browser aborts the connection):
If you try to press F5, then it might be that the Websocket connection is closed as soon as it was opened, or that the browser doesn't get a response for the request to chat.xhtml.
Now, add synchronization by modifying ChatAnnotation's broadcast() method:

and repeat the above steps.
Now, if you open chat.xhtml with both IE and Firefox and do nothing, the WebSocket connection will not be closed.
Even if you start to repeatedly press F5, most of the time everything will appear normal (besides getting IOExceptions and ClosedChannelExceptions).
However, after I tried this several minutes, I still got the problems that the WebSocket connections are closed just after opening it (or after some time), or that the browser didn't get a response to its HTTP request, or that the browser got a raw WebSocket reply instead of the XHTML page reply (see added screenshots).
I also got these exceptions: