Race condition found in CxfRsEndpoint while getting the endpoint binding under load and performing sync and async invocation.
The CxfRsEndpoint's getBinding method is not thread safe.
At a customer site, I ran into an issue at startup if 2 threads raced to perform sync and async invocation, the code for getBinding (given below) would react in the following way.

Thread 1 would proceed to create a binding object.
Thread 2 would meanwhile still find the binding to be null and proceed to create a new binding
Meanwhile thread one would have its binding and set the Atomic boolean for binding initialized and proceed to set the HeaderStrategy.
Thread 2 meanwhile would overwrite the original binding object and find that Atomic boolean already set and would have no way to associate a HeaderFilterStrategy object since the flag is up.
In the absence of a HeaderFilterStrategy, copying of ProtocolHeaders etc will throw exceptions on every following request/invocation.