camel-rabbitmq - Race condition when stopping context with autoack=false.
Run the following code and hit enter while one message is in unacked state (see RabbitMQ console):
you get the following exception:
I think that this is caused by a race condition between the main thread that runs channel.close() immediately after channel.basicCancel(tag) (see org.apache.camel.component.rabbitmq.RabbitConsumer) without waiting the channel.basicAck(deliveryTag, false) in handleDelivery().
Another bad side effect is that you'll find a duplicate of a message on the destinationQueue.
For example if you have 10 initial messages in sourceQueue, and you hit enter while it's processing the third one, you'll get 7 messages in sourceQueue and 4 messages in destinationQueue.
The correct behaviour should be the following:
1) Stop consumer: channel.basicCancel(tag)
2) Wait if there is a running consumer
3) The consumer acks the previous message
4) Close the channel