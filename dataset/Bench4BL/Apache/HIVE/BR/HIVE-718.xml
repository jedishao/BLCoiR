<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat Dec 03 01:08:47 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HIVE-718/HIVE-718.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HIVE-718] Load data inpath into a new partition without overwrite does not move the file</title>
                <link>https://issues.apache.org/jira/browse/HIVE-718</link>
                <project id="12310843" key="HIVE">Hive</project>
                    <description>&lt;p&gt;The bug can be reproduced as following. Note that it only happens for partitioned tables. The select after the first load returns nothing, while the second returns the data correctly.&lt;/p&gt;

&lt;p&gt;insert.txt in the current local directory contains 3 lines: &quot;a&quot;, &quot;b&quot; and &quot;c&quot;.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&amp;gt; create table tmp_insert_test (value string) stored as textfile;
&amp;gt; load data local inpath &apos;insert.txt&apos; into table tmp_insert_test;
&amp;gt; select * from tmp_insert_test;
a
b
c
&amp;gt; create table tmp_insert_test_p ( value string) partitioned by (ds string) stored as textfile;
&amp;gt; load data local inpath &apos;insert.txt&apos; into table tmp_insert_test_p partition (ds = &apos;2009-08-01&apos;);
&amp;gt; select * from tmp_insert_test_p where ds= &apos;2009-08-01&apos;;
&amp;gt; load data local inpath &apos;insert.txt&apos; into table tmp_insert_test_p partition (ds = &apos;2009-08-01&apos;);
&amp;gt; select * from tmp_insert_test_p where ds= &apos;2009-08-01&apos;;
a       2009-08-01
b       2009-08-01
d       2009-08-01
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
                <environment></environment>
        <key id="12432077">HIVE-718</key>
            <summary>Load data inpath into a new partition without overwrite does not move the file</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="namit">Namit Jain</assignee>
                                    <reporter username="zshao">Zheng Shao</reporter>
                        <labels>
                    </labels>
                <created>Mon, 3 Aug 2009 19:07:23 +0000</created>
                <updated>Sat, 17 Dec 2011 00:05:37 +0000</updated>
                            <resolved>Tue, 15 Sep 2009 19:15:26 +0000</resolved>
                                    <version>0.4.0</version>
                                    <fixVersion>0.4.0</fixVersion>
                    <fixVersion>0.5.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                <comments>
                            <comment id="12738782" author="he yongqiang" created="Tue, 4 Aug 2009 03:15:52 +0000"  >&lt;p&gt;patch.  &lt;br/&gt;
I will check and test it late tonight.&lt;/p&gt;</comment>
                            <comment id="12738931" author="he yongqiang" created="Tue, 4 Aug 2009 11:44:06 +0000"  >&lt;p&gt;the patch that passed tests in my local.&lt;br/&gt;
Added the code to undo the copy operation when error occures (this might not help in most situations, but we should try out best).&lt;/p&gt;</comment>
                            <comment id="12739075" author="tlipcon" created="Tue, 4 Aug 2009 18:21:11 +0000"  >&lt;p&gt;I can confirm this bug on trunk - it&apos;s a regression since 0.3.0.&lt;/p&gt;

&lt;p&gt;However, I&quot;m not sure about the patch - if one of the later rename fails, we should undo the previous ones, but in this patch it looks like it&apos;s actually deleting the previous ones. Why not attempt to move it back to its original location?&lt;/p&gt;

&lt;p&gt;Also, it seems worth it to add some LOG.error() statements in these cases.&lt;/p&gt;</comment>
                            <comment id="12739084" author="tlipcon" created="Tue, 4 Aug 2009 18:38:58 +0000"  >&lt;p&gt;Here&apos;s a new revision of the patch which addresses my concerns above.&lt;/p&gt;

&lt;p&gt;Is there a way to write a unit test for this? We should have a test to prevent another regression.&lt;/p&gt;</comment>
                            <comment id="12739096" author="prasadc" created="Tue, 4 Aug 2009 19:02:18 +0000"  >&lt;p&gt;can&apos;t this be done the same way replaceFiles() does? that is use a tmpdir as a staging directory and do a rename() which is atomic.&lt;/p&gt;</comment>
                            <comment id="12739100" author="tlipcon" created="Tue, 4 Aug 2009 19:06:49 +0000"  >&lt;p&gt;What if the partition already exists? In that case we couldn&apos;t rename the staging directory since the destination name would already exist, right? Or can we just make another subdirectory of the partition with some unique name?&lt;/p&gt;</comment>
                            <comment id="12739107" author="prasadc" created="Tue, 4 Aug 2009 19:14:16 +0000"  >&lt;p&gt;another subdir should work fine. there is no rule that there can only be files in a partition dir&lt;/p&gt;</comment>
                            <comment id="12739109" author="tlipcon" created="Tue, 4 Aug 2009 19:18:39 +0000"  >&lt;p&gt;OK. How do we come up with a unique name? Just use timestamp?&lt;/p&gt;

&lt;p&gt;Does the metastore need to know this name somehow? Or is the change just localized to that method? (Also, should we rename that method? It&apos;s called copyFiles, but does nothing of the sort)&lt;/p&gt;</comment>
                            <comment id="12739110" author="prasadc" created="Tue, 4 Aug 2009 19:24:10 +0000"  >&lt;p&gt;metastore doesn&apos;t need to know the subdir name. any random enough name should be fine. feel free to rename it.&lt;/p&gt;</comment>
                            <comment id="12739146" author="tlipcon" created="Tue, 4 Aug 2009 20:37:53 +0000"  >&lt;p&gt;In looking through this code, I&apos;ve found a few more issues:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;In isolation, it looks like copyFiles/replaceFiles are supposed to be able to handle a srcf like &quot;/foo/*&quot; with a directory layout like:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;/foo/subdir1/part-00000&lt;br/&gt;
/foo/subdir2/part-00000&lt;/p&gt;

&lt;p&gt;I&apos;m assuming this because it first does fs.globStatus on srcf, and then for each of the results of the glob, it calls fs.listStatus (implying that they are directories).&lt;/p&gt;

&lt;p&gt;However, given the example above, this would actually fail, since both files are named part-00000 and the could would attempt to rename both to tmpdir/part-00000.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;In fact, using the tmpdir like this is consistent from the view of an outside observer, but not atomic. If the renamer crashes in the middle of the operation, the files will have been moved out of the original location and into the tmpdir, but the tmpdir has not been renamed into the destination. Is this OK? I feel like the solution would be to make dstdir/&lt;em&gt;staging&lt;/em&gt;&amp;lt;timestamp&amp;gt;, move the files one-by-one into there, and then rename &lt;em&gt;staging&lt;/em&gt;&amp;lt;timestamp&amp;gt; to the destination. This way if there is a failure in the middle, the client can at least determine where their files went without looking through a temporary directory.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12739164" author="zshao" created="Tue, 4 Aug 2009 21:02:02 +0000"  >&lt;p&gt;I think it&apos;s not acceptable for a failed &quot;insert&quot; to corrupt the original data of the table.&lt;/p&gt;

&lt;p&gt;We never have a table with sub directories (instead of files) inside. We will need some testing to make sure it actually works.&lt;br/&gt;
For unique name, maybe we can just prepend the job id.&lt;/p&gt;</comment>
                            <comment id="12739170" author="tlipcon" created="Tue, 4 Aug 2009 21:16:20 +0000"  >&lt;blockquote&gt;&lt;p&gt;I think it&apos;s not acceptable for a failed &quot;insert&quot; to corrupt the original data of the table. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;then we definitely have to move an entire directory of files in at once - otherwise we can have an insert partially succeed&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;We never have a table with sub directories (instead of files) inside. We will need some testing to make sure it actually works.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is going to be a necessity to do non-overwrite loads into a table/partition, right?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;For unique name, maybe we can just prepend the job id.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This isn&apos;t always available (eg running LOAD DATA from the cli). I think we&apos;re stuck with java.util.UUID, as ugly as it may be.&lt;/p&gt;

&lt;p&gt;I&apos;ve spent the last hour or so trying to figure out any other way of generating a unique name inside a subdirectory. Because of the semantics of FileSystem.mkdirs and FileSystem.rename, I don&apos;t believe there&apos;s any way of doing this. mkdirs doesn&apos;t return false in the case that the directory already exists, and if you rename(src, dst), and dst already exists as a directory, it will move src &lt;b&gt;inside&lt;/b&gt; of dst.&lt;/p&gt;</comment>
                            <comment id="12739187" author="prasadc" created="Tue, 4 Aug 2009 21:39:08 +0000"  >&lt;blockquote&gt;&lt;p&gt;We never have a table with sub directories (instead of files) inside. We will need some testing to make sure it actually works.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Zheng, aren&apos;t buckets are separate subdirs? they work so sub-dirs should be fine.&lt;/p&gt;</comment>
                            <comment id="12739197" author="zshao" created="Tue, 4 Aug 2009 21:53:57 +0000"  >&lt;blockquote&gt;&lt;p&gt;Zheng, aren&apos;t buckets are separate subdirs? they work so sub-dirs should be fine.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I tried to add a directory into a table, and then run this. Apparently hadoop file format does not like the sub directory:&lt;br/&gt;
Buckets are files not directories.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&amp;gt; select * from zshao_tt;
OK
Failed with exception java.io.IOException:Not a file: hdfs:&lt;span class=&quot;code-comment&quot;&gt;//dfs1.data.facebook.com:9000/user/facebook/warehouse/zshao_tt/a
&lt;/span&gt;09/08/04 14:49:38 ERROR exec.FetchTask: Failed with exception java.io.IOException:Not a file: hdfs:&lt;span class=&quot;code-comment&quot;&gt;//dfs1.data.facebook.com:9000/user/facebook/warehouse/zshao_tt/a
&lt;/span&gt;java.io.IOException: Not a file: hdfs:&lt;span class=&quot;code-comment&quot;&gt;//dfs1.data.facebook.com:9000/user/facebook/warehouse/zshao_tt/a
&lt;/span&gt;        at org.apache.hadoop.mapred.FileInputFormat.getSplits(FileInputFormat.java:231)
        at org.apache.hadoop.hive.ql.exec.FetchTask.getRecordReader(FetchTask.java:236)
        at org.apache.hadoop.hive.ql.exec.FetchTask.fetch(FetchTask.java:291)
        at org.apache.hadoop.hive.ql.Driver.getResults(Driver.java:368)
        at org.apache.hadoop.hive.cli.CliDriver.processCmd(CliDriver.java:183)
        at org.apache.hadoop.hive.cli.CliDriver.processLine(CliDriver.java:216)
        at org.apache.hadoop.hive.cli.CliDriver.main(CliDriver.java:306)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.apache.hadoop.util.RunJar.main(RunJar.java:166)
        at org.apache.hadoop.mapred.JobShell.run(JobShell.java:194)
        at org.apache.hadoop.util.ToolRunner.run(ToolRunner.java:65)
        at org.apache.hadoop.util.ToolRunner.run(ToolRunner.java:79)
        at org.apache.hadoop.mapred.JobShell.main(JobShell.java:220)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I discussed with Ashish offline on this. I think we still want the atomic property of insert - as a result, we may need to manually expand the input directory into a bunch of files, and feed the files into the map/reduce jobs (instead of the directories).  That code is in ExecDriver.java and MapRedTask.java when we set the JobConf.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;</comment>
                            <comment id="12739352" author="he yongqiang" created="Wed, 5 Aug 2009 06:33:06 +0000"  >&lt;p&gt;Todd&apos;s patch looks good (at least better than mine).  so +1.&lt;br/&gt;
I assumed the srcfs is a tmp dir, and did not recover them when error occurs. &lt;/p&gt;</comment>
                            <comment id="12741454" author="tlipcon" created="Mon, 10 Aug 2009 18:07:43 +0000"  >&lt;p&gt;I think we should go ahead with my patch for now and then open another JIRA for fixing the atomicity issue.&lt;/p&gt;</comment>
                            <comment id="12743911" author="he yongqiang" created="Sun, 16 Aug 2009 21:43:07 +0000"  >&lt;p&gt;I think this should be merged into 0.4 release.&lt;/p&gt;</comment>
                            <comment id="12744138" author="prasadc" created="Mon, 17 Aug 2009 17:24:32 +0000"  >&lt;p&gt;lacking atomicity can lead to silent bugs which are unacceptable in production systems.&lt;/p&gt;</comment>
                            <comment id="12744143" author="tlipcon" created="Mon, 17 Aug 2009 17:44:12 +0000"  >&lt;p&gt;Prasad: this is true, but the atomicity issue was already there - we just discovered it while looking at this section of the code. My guess is that there are similar bugs elsewhere in Hive - there&apos;s no safe way to have multiple threads compete for a directory name, so really any movement of files has to be coordinated by the metastore to be safe. The hadoop-side issues are:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;mkdirs on an existing directory will return the exact same thing as mkdirs on one that didn&apos;t previously exist&lt;/li&gt;
	&lt;li&gt;rename of one directory to a new name will not give an error if the new name exists - rather, it will move your directory inside that one&lt;/li&gt;
	&lt;li&gt;checking if (not exists) 
{ do something to a location }
&lt;p&gt; is obviously racy&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12745275" author="zshao" created="Thu, 20 Aug 2009 01:50:50 +0000"  >&lt;p&gt;Let&apos;s get a consensus on this issue soon.&lt;/p&gt;

&lt;p&gt;Atomicity is definitely wanted (either now or some time in the future). It&apos;s not just the move of all files need to be atomic - if the files are moved, the job should always return successful - otherwise most probably the client will try again and end up insert the data twice. It seems it&apos;s impossible to me with what we have.&lt;/p&gt;

&lt;p&gt;Maybe we should not support &quot;append&quot; - user can always load into a new partition every time. Thoughts?&lt;/p&gt;</comment>
                            <comment id="12745548" author="prasadc" created="Thu, 20 Aug 2009 18:30:59 +0000"  >&lt;p&gt;&apos;overwrite&apos; path has less of an issue in the sense that only one of two competing statements will win out. the resulting directory will not contain some files from first statement and some from the second statement. (this assuming probability of two statements creating same random tmp directory is very less)&lt;/p&gt;

&lt;p&gt;my concern in this case is that, it is possible to corrupt the existing partition with only a part of new files and overwrite some of the old files and user has no way of knowing that such a thing has happened and it may not possible to recover the data.&lt;/p&gt;

&lt;p&gt;but if you guys think the current patch is no worse than the existing solution, i  do not have a problem.&lt;/p&gt;</comment>
                            <comment id="12745554" author="tlipcon" created="Thu, 20 Aug 2009 18:36:29 +0000"  >&lt;blockquote&gt;&lt;p&gt;my concern in this case is that, it is possible to corrupt the existing partition with only a part of new files and overwrite some of the old files and user has no way of knowing that such a thing has happened and it may not possible to recover the data.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Can you explain the order of events that causes this? I think even with the current patch the operation will not fail silently and should not cause unrecoverable loss.&lt;/p&gt;</comment>
                            <comment id="12745569" author="prasadc" created="Thu, 20 Aug 2009 18:52:29 +0000"  >&lt;p&gt;Two statements issue load into same partition around the same time. For one, dirExisted will be true and false for the other. Suppose the &apos;false&apos; stmt copies a file named &apos;a1&apos; first and then &apos;true&apos; stmt will fail if it copies the same file. so it will try to undo the previous copies and then delete the dir. But the &apos;false&apos; stmt keeps copying the files blissfully and succeed but the files &apos;a1&apos; and others that were copied before the &apos;true&apos; stmt deleted the directory will not be there but there won&apos;t be an error for the &apos;false&apos; stmt.&lt;/p&gt;

&lt;p&gt;hoping my writing is understandable enough &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12745572" author="tlipcon" created="Thu, 20 Aug 2009 18:57:21 +0000"  >&lt;p&gt;Thanks for the explanation. I&apos;ll try to block out an hour to look through the code again this afternoon or evening to see if I can fix this issue somehow or another.&lt;/p&gt;

&lt;p&gt;There is one ugly solution whereby you can use a file (not a directory) as a lock. That is to say, open a file &quot;foo_load_lock&quot;. If it&apos;s already being created by another writer, the NN will throw an IOException to the second guy, and we can enforce exclusive access. The problem here is what to do with the failure scenario which might leave a lock hanging around for perpetuity &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12745672" author="prasadc" created="Thu, 20 Aug 2009 21:32:08 +0000"  >&lt;p&gt;continuing the ugly part, you can do some sort of leases instead of locks using files. create a file uniquely named with the current hour so lease will be held for an hour atmost. there might be lot of files hanging around but they can be created in /tmp which will get cleaned.&lt;/p&gt;

&lt;p&gt;another option is, ashish is implementing session level temporary tables in metastore. you can use them as locks without worrying them existing after the session.&lt;/p&gt;</comment>
                            <comment id="12747107" author="tlipcon" created="Mon, 24 Aug 2009 22:22:03 +0000"  >&lt;p&gt;Here&apos;s a proposal: How would you guys feel about an addition to the metastore API that is as simple as:&lt;/p&gt;

&lt;p&gt;string get_unique_id()&lt;/p&gt;

&lt;p&gt;The metastore would simply keep an autoincrement field to hand these out. We can then use these safely to allocate race-free names to clients. Should be straightforward and a lot more simple than any kind of lock/lease based mechanism.&lt;/p&gt;</comment>
                            <comment id="12747580" author="rsm" created="Tue, 25 Aug 2009 19:06:21 +0000"  >&lt;p&gt;Can the unique name problem be solved at the file system level via a mktemp like method? Then you wouldnt have to depend on the metastore to reliably maintain unique ids (for example, what happens when the metastore uses an in-memory db and is restarted).&lt;/p&gt;</comment>
                            <comment id="12747602" author="tlipcon" created="Tue, 25 Aug 2009 19:47:31 +0000"  >&lt;p&gt;I hadn&apos;t considered the case of an in-memory metastore. A mktemp-like method would be great, but o.a.h.FileSystem gives you nothing of the sort &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12747658" author="rsm" created="Tue, 25 Aug 2009 21:30:20 +0000"  >&lt;blockquote&gt;&lt;p&gt;A mktemp-like method would be great, but o.a.h.FileSystem gives you nothing of the sort&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s fine. We could just implement such a method in hive. The logic could be the same as unix mktemp. See &lt;a href=&quot;http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/lib/libast/common/path/pathtemp.c&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/lib/libast/common/path/pathtemp.c&lt;/a&gt; . Specifically, the for loop starting 245.&lt;/p&gt;</comment>
                            <comment id="12747668" author="tlipcon" created="Tue, 25 Aug 2009 21:42:45 +0000"  >&lt;p&gt;Not sure how that actually helps - if we use an algorithm like:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; each file to be moved:
  &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; not successful:
    come up with a random name
    &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; to move src file to the random name
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; it fails due to dst already existing, &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; again with a &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; random name
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then we&apos;d lose the atomicity/isolation - readers would see a partial load during the middle of the operation.&lt;/p&gt;

&lt;p&gt;We can&apos;t use that algorithm with atomic directory renames, since Hadoop has the wacky behavior that move(&quot;srcdir&quot;, &quot;dstdir&quot;) will create &quot;dstdir/srcdir&quot; if dstdir already exists&lt;/p&gt;</comment>
                            <comment id="12748104" author="prasadc" created="Wed, 26 Aug 2009 19:42:23 +0000"  >&lt;p&gt;@todd&lt;br/&gt;
dhruba said he would be willing to provide a &apos;mkdir&apos; method that would mimic the POSIX mkdir() fn. But in the meantime i think the algorithm with atomic directory renames would be sufficient. we can try to generate a pseudo random number and check for that directory to exist before creating it. Since we are generating pseudo random numbers, the probability that two different loads into same directory will be generating same random number and checking for existence at the same time is pretty low. &lt;/p&gt;</comment>
                            <comment id="12754058" author="athusoo" created="Fri, 11 Sep 2009 09:04:53 +0000"  >&lt;p&gt;Apologies on following this earlier. It caught my attention as Todd brought up whether we should get this into 0.4.0 release as this is a regression when compared to 0.3.0. I checked the code on 0.3.0 and it seems to be the same as that in 0.4.0. So I am not sure if this is a regression. If this is not a regression then potentially we can go out with 0.4.0 without this and document this?&lt;/p&gt;

&lt;p&gt;As is evident by this discussion LOAD INTO and its cousin INSERT INTO (when we have it) are very tricky. Almost all our code has been written with the overwrite semantics. Appending new data to an existing partition would need more work to get right and I feel we should punt it and document that insert into is not reliable - I think it has never been reliable.&lt;/p&gt;

&lt;p&gt;In order to safely implement the INSERT INTO and LOAD INTO semantics one approach is to introduce a notion of versions on the DML commands which is encoded in the directory structure i.e.&lt;/p&gt;

&lt;p&gt;instead of storing things as &lt;/p&gt;

&lt;p&gt;xyz/part-0000&lt;/p&gt;

&lt;p&gt;we store the files as&lt;/p&gt;

&lt;p&gt;xyz/v1/part-0000&lt;/p&gt;

&lt;p&gt;and so on so forth. We store the latest created version in the metastore entry for that table. When a reader comes in it first looks at this entry and then finds a version corresponding to that in the table. The versions themselves could be garbage collected by deleting version directories that are older than say some configurable duration old and this could either be done lazily by the writer on the table or by an active garbage collector in the background. These are of course somewhat involved changes and would solve the isolation and atomicity problems. The later becase v1 is a directory so moving data to that directory would be a rename and hence atomic. Thoughts?&lt;/p&gt;</comment>
                            <comment id="12754266" author="tlipcon" created="Fri, 11 Sep 2009 18:20:18 +0000"  >&lt;p&gt;Not sure if people are already following the discussion on &lt;a href=&quot;https://issues.apache.org/jira/browse/HADOOP-6240&quot; title=&quot;Rename operation is not consistent between different implementations of FileSystem&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HADOOP-6240&quot;&gt;&lt;del&gt;HADOOP-6240&lt;/del&gt;&lt;/a&gt;, but it&apos;s worth checking out &amp;#8211; discussions regarding rename() semantics on HDFS.&lt;/p&gt;</comment>
                            <comment id="12754285" author="namit" created="Fri, 11 Sep 2009 19:14:03 +0000"  >&lt;p&gt;INSERT INTO is not supported - it will get a parse error.&lt;/p&gt;

&lt;p&gt;LOAD INTO is the only scenario we have to worry about&lt;/p&gt;</comment>
                            <comment id="12754347" author="prasadc" created="Fri, 11 Sep 2009 21:03:54 +0000"  >&lt;p&gt;from &lt;a href=&quot;https://issues.apache.org/jira/browse/HADOOP-6240&quot; title=&quot;Rename operation is not consistent between different implementations of FileSystem&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HADOOP-6240&quot;&gt;&lt;del&gt;HADOOP-6240&lt;/del&gt;&lt;/a&gt;, it appears that atomic rename() might not be supported on all FileSystems. Given this, I think we may need to avoid depending on HDFS for atomicity or locking.&lt;/p&gt;

&lt;p&gt;There was another discussion on hive-users@ about providing some kind of locking so that two different jobs can do conflicting things to a directory (if there is one writer and a reader). So if we go down that route, this problem can be solved by acquiring write locks (or leases). Ofcourse, this won&apos;t work if one of the processes is a non-Hive process. Even ashish&apos;s solution will not work since the external process needs to handle the version numbers correctly.&lt;/p&gt;</comment>
                            <comment id="12754384" author="namit" created="Fri, 11 Sep 2009 22:25:05 +0000"  >&lt;p&gt;@Todd, I dont think it is a regression, and there is no easy fix for this.&lt;/p&gt;

&lt;p&gt;Do you think we should hold the release for this ?&lt;/p&gt;</comment>
                            <comment id="12754397" author="athusoo" created="Fri, 11 Sep 2009 22:47:06 +0000"  >&lt;p&gt;@prasad, can you explain your comment about the external process stuff?&lt;/p&gt;</comment>
                            <comment id="12754402" author="prasadc" created="Fri, 11 Sep 2009 22:55:22 +0000"  >&lt;p&gt;It is possible for users now to add new files to the table/partition directory without going through Hive to load files. Hive will pick it up these for the future queries. Currently the directory structure is easily inferred and so external processes can write and read data independent of Hive. if we start having versions then they have to read the correct version from Hive to interact with the data. Doesn&apos;t this goes against the philosophy of openness? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="12754408" author="tlipcon" created="Fri, 11 Sep 2009 23:06:26 +0000"  >&lt;p&gt;Namit: here&apos;s a trace from a session on hive 0.3.0:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;todd@todd-laptop:~$ cat /tmp/insert.txt 
a
b
c
d
todd@todd-laptop:~$ cat /tmp/insert2.txt 
e
f
g
h
todd@todd-laptop:~$ hive
Hive history file=/tmp/todd/hive_job_log_todd_200909111603_978288634.txt
hive&amp;gt; create table tmp_insert_test_p (value string) partitioned by (ds string);
OK
Time taken: 3.865 seconds
hive&amp;gt; load data local inpath &apos;/tmp/insert.txt&apos; into table tmp_insert_test_p partition (ds = &apos;2009-08-01&apos;);
Copying data from file:/tmp/insert.txt
Loading data to table tmp_insert_test_p partition {ds=2009-08-01}
OK
Time taken: 0.672 seconds
hive&amp;gt; select * from tmp_insert_test_p where ds = &apos;2009-08-01&apos;;
OK
a       2009-08-01
b       2009-08-01
c       2009-08-01
d       2009-08-01
Time taken: 0.374 seconds
hive&amp;gt; load data local inpath &apos;/tmp/insert2.txt&apos; into table tmp_insert_test_p partition (ds = &apos;2009-08-01&apos;);
Copying data from file:/tmp/insert2.txt
Loading data to table tmp_insert_test_p partition {ds=2009-08-01}
OK
Time taken: 0.261 seconds
hive&amp;gt; select * from tmp_insert_test_p where ds = &apos;2009-08-01&apos;;
OK
a       2009-08-01
b       2009-08-01
c       2009-08-01
d       2009-08-01
e       2009-08-01
f       2009-08-01
g       2009-08-01
h       2009-08-01
Time taken: 0.14 seconds
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The same session fails on the 0.4 branch:&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;hive&amp;gt; create table tmp_insert_test_p (value string) partitioned by (ds string);
OK
Time taken: 0.068 seconds
hive&amp;gt; load data local inpath &apos;/tmp/insert.txt&apos; into table tmp_insert_test_p partition (ds = &apos;2009-08-01&apos;);
Copying data from file:/tmp/insert.txt
Loading data to table tmp_insert_test_p partition {ds=2009-08-01}
OK
Time taken: 0.315 seconds
hive&amp;gt; select * from tmp_insert_test_p where ds = &apos;2009-08-01&apos;;
OK
Time taken: 0.523 seconds
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="12754458" author="athusoo" created="Sat, 12 Sep 2009 01:27:26 +0000"  >&lt;p&gt;hmm.... that is strange. Given this we should definitely figure out the regression and get it fixed.&lt;/p&gt;</comment>
                            <comment id="12754459" author="namit" created="Sat, 12 Sep 2009 01:38:36 +0000"  >&lt;p&gt;After discussing with Ashish offline, we think it is due to fact that Prasad changed the order of directory move and metastore.&lt;/p&gt;

&lt;p&gt;Unfortunately, users can wait on both hdfs partition creation and partition creation, and we need to do perform 2 in some order while doing a load into.&lt;/p&gt;

&lt;p&gt;Prasad might have some ideas on this&lt;/p&gt;</comment>
                            <comment id="12754461" author="prasadc" created="Sat, 12 Sep 2009 01:59:13 +0000"  >&lt;p&gt;the only change i made was not to create the partition/table until Hive.copyFiles() returns. i,e the partition/table directory was created (if it did not exist) before copyFiles() was called in 0.3. It could be the reason for the discrepancy between 0.3 and 0.4 but I am not sure.&lt;/p&gt;

&lt;p&gt;We can&apos;t do the create the directory if we want to support correct semantics (i.e. the partition directory does not exist until the data has been copied completely). This  is needed for both COPY or REPLACE without which down stream data get corrupted/incomplete data.&lt;/p&gt;

&lt;p&gt;But if you want to keep 0.3 semantics (which we might want to since COPY otherwise is quite unusable), we just need to create destf directory in Hive.copyFiles(). &lt;/p&gt;</comment>
                            <comment id="12754632" author="tlipcon" created="Sat, 12 Sep 2009 22:56:19 +0000"  >&lt;p&gt;Even in the case of LOAD...OVERWRITE, we currently lack atomicity. The old directory is deleted prior to the new directory being moved in. There&apos;s a small window of time in which neither old nor new data is present. Sure, this is probably on the order of a half second, but it is still not correct. There&apos;s also the general case of a query which has already computed input splits being affected by a concurrent LOAD DATA OVERWRITE. The versioning solution I think gets us partly there, but will be very tricky to implement correctly while maintaining performance since there&apos;s no way to do a copy-on-write directory snapshot built in to HDFS. So, I think a significant amount of work will have to be done in the metastore and we&apos;ll definitely have to drop the &quot;external process load&quot; ability that currently exists.&lt;/p&gt;

&lt;p&gt;Should we open a new JIRA for the general concurrency control/locking issues we&apos;re discussing here? It seems like this ticket should be used for the 0.3-&amp;gt;0.4 regression, even if it&apos;s just a temporary fix. We can then put a more general correct solution on the roadmap for 0.5 or later, since it&apos;s looking like it will be a complicated project.&lt;/p&gt;</comment>
                            <comment id="12754651" author="prasadc" created="Sun, 13 Sep 2009 02:22:59 +0000"  >&lt;p&gt;+1 to todd&apos;s suggestion. let&apos;s fix the regression by just creating the directory in copyFiles() and let&apos;s open a separate JIRA for concurrency and atomicity issues.&lt;/p&gt;
</comment>
                            <comment id="12755176" author="namit" created="Mon, 14 Sep 2009 20:17:00 +0000"  >&lt;p&gt;In 0.3, if we insert the same file twice, we get a error &lt;/p&gt;

&lt;p&gt;2009-09-14 13:15:16,422 ERROR exec.MoveTask (SessionState.java:printError(279)) - Failed with exception checkPaths: /data/users/njain/hive6/hive6/build/ql/test/data/warehouse/tmp_insert_test_p/ds=2009-08-01/kv1.txt already exists&lt;br/&gt;
org.apache.hadoop.hive.ql.metadata.HiveException: checkPaths: /data/users/njain/hive6/hive6/build/ql/test/data/warehouse/tmp_insert_test_p/ds=2009-08-01/kv1.txt already exists&lt;br/&gt;
	at org.apache.hadoop.hive.ql.metadata.Hive.checkPaths(Hive.java:703)&lt;br/&gt;
	at org.apache.hadoop.hive.ql.metadata.Hive.copyFiles(Hive.java:726)&lt;br/&gt;
	at org.apache.hadoop.hive.ql.metadata.Hive.loadPartition(Hive.java:522)&lt;br/&gt;
	at org.apache.hadoop.hive.ql.exec.MoveTask.execute(MoveTask.java:145)&lt;br/&gt;
	at org.apache.hadoop.hive.ql.Driver.run(Driver.java:245)&lt;br/&gt;
	at org.apache.hadoop.hive.cli.CliDriver.processCmd(CliDriver.java:176)&lt;br/&gt;
	at org.apache.hadoop.hive.cli.CliDriver.processLine(CliDriver.java:211)&lt;br/&gt;
	at org.apache.hadoop.hive.ql.QTestUtil.executeClient(QTestUtil.java:411)&lt;br/&gt;
	at org.apache.hadoop.hive.cli.TestCliDriver.testCliDriver_input40(TestCliDriver.java:57)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)&lt;br/&gt;
	at java.lang.reflect.Method.invoke(Method.java:597)&lt;br/&gt;
	at junit.framework.TestCase.runTest(TestCase.java:154)&lt;br/&gt;
	at junit.framework.TestCase.runBare(TestCase.java:127)&lt;br/&gt;
	at junit.framework.TestResult$1.protect(TestResult.java:106)&lt;br/&gt;
	at junit.framework.TestResult.runProtected(TestResult.java:124)&lt;br/&gt;
	at junit.framework.TestResult.run(TestResult.java:109)&lt;br/&gt;
	at junit.framework.TestCase.run(TestCase.java:118)&lt;br/&gt;
	at junit.framework.TestSuite.runTest(TestSuite.java:208)&lt;br/&gt;
	at junit.framework.TestSuite.run(TestSuite.java:203)&lt;br/&gt;
	at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:297)&lt;br/&gt;
	at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.launch(JUnitTestRunner.java:672)&lt;br/&gt;
	at org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.main(JUnitTestRunner.java:567)&lt;/p&gt;


&lt;p&gt;I will stick with the above error for now for 0.4 also.&lt;/p&gt;</comment>
                            <comment id="12755177" author="tlipcon" created="Mon, 14 Sep 2009 20:18:51 +0000"  >&lt;p&gt;Namit: that error is tracked by &lt;a href=&quot;https://issues.apache.org/jira/browse/HIVE-307&quot; title=&quot;&amp;quot;LOAD DATA LOCAL INPATH&amp;quot; fails when the table already contains a file of the same name&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HIVE-307&quot;&gt;&lt;del&gt;HIVE-307&lt;/del&gt;&lt;/a&gt; marked linked above. I think it&apos;s OK behavior for 0.4 - we should verify, though, that the file that fails to load remains safely in place.&lt;/p&gt;</comment>
                            <comment id="12755216" author="namit" created="Mon, 14 Sep 2009 21:47:14 +0000"  >&lt;p&gt;@Todd, @Prasad, @Raghu - the current patch is very simple - creates the directory if it does not exist - does not account for concurrency etc.&lt;br/&gt;
It should be compatible with 0.3. &lt;/p&gt;

&lt;p&gt;Please review, if it is OK, please merge and I will cut a new release candidate&lt;/p&gt;</comment>
                            <comment id="12755275" author="zshao" created="Tue, 15 Sep 2009 00:49:26 +0000"  >&lt;p&gt;+1 from my side. We don&apos;t want to delay 0.4 release because of this.&lt;/p&gt;</comment>
                            <comment id="12755292" author="athusoo" created="Tue, 15 Sep 2009 01:24:23 +0000"  >&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;Looks good to me.&lt;/p&gt;</comment>
                            <comment id="12755611" author="namit" created="Tue, 15 Sep 2009 18:01:26 +0000"  >&lt;p&gt;@Todd, I am assuming you are OK with this - If yes, we will try to commit it in a hour or so, so that we can get another release candidate &lt;/p&gt;</comment>
                            <comment id="12755644" author="tlipcon" created="Tue, 15 Sep 2009 19:07:26 +0000"  >&lt;p&gt;+1 lgtm. Thanks for getting this in, guys!&lt;/p&gt;</comment>
                            <comment id="12755649" author="zshao" created="Tue, 15 Sep 2009 19:15:26 +0000"  >&lt;p&gt;Committed. Thanks Namit!&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                            <outwardlinks description="blocks">
                                        <issuelink>
            <issuekey id="12435644">HIVE-829</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12415618">HIVE-307</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                            <outwardlinks description="depends upon">
                                        <issuelink>
            <issuekey id="12433886">HIVE-789</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12415442" name="HIVE-718.1.patch" size="966" author="he yongqiang" created="Tue, 4 Aug 2009 03:15:51 +0000"/>
                            <attachment id="12415481" name="HIVE-718.2.patch" size="1513" author="he yongqiang" created="Tue, 4 Aug 2009 11:44:06 +0000"/>
                            <attachment id="12415509" name="hive-718.txt" size="2550" author="tlipcon" created="Tue, 4 Aug 2009 18:38:58 +0000"/>
                            <attachment id="12419569" name="hive.718.1.patch" size="45721" author="namit" created="Mon, 14 Sep 2009 21:42:03 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 4 Aug 2009 03:15:52 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>73344</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 12 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0lbdj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>122493</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310192" key="com.atlassian.jira.plugin.system.customfieldtypes:textarea">
                        <customfieldname>Release Note</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>&lt;a href=&quot;https://issues.apache.org/jira/browse/HIVE-718&quot; title=&quot;Load data inpath into a new partition without overwrite does not move the file&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HIVE-718&quot;&gt;&lt;strike&gt;HIVE-718&lt;/strike&gt;&lt;/a&gt;. Fix Loading data inpath into a new partition. (Namit Jain via zshao)</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>