<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat Dec 03 01:01:57 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HIVE-65/HIVE-65.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HIVE-65] Implict conversion from integer to long broken for Dynamic Serde tables</title>
                <link>https://issues.apache.org/jira/browse/HIVE-65</link>
                <project id="12310843" key="HIVE">Hive</project>
                    <description>&lt;p&gt;For a dynamic serde table that has a bigint column, implict conversion from int to bigint seems to be broken. I have not verified this for other tables.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12408665">HIVE-65</key>
            <summary>Implict conversion from integer to long broken for Dynamic Serde tables</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.png">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="athusoo">Ashish Thusoo</assignee>
                                    <reporter username="athusoo">Ashish Thusoo</reporter>
                        <labels>
                    </labels>
                <created>Mon, 17 Nov 2008 18:28:21 +0000</created>
                <updated>Sat, 17 Dec 2011 00:08:37 +0000</updated>
                            <resolved>Wed, 22 Jul 2009 23:59:28 +0000</resolved>
                                                    <fixVersion>0.3.0</fixVersion>
                                    <component>Query Processor</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12648230" author="athusoo" created="Mon, 17 Nov 2008 18:29:23 +0000"  >&lt;p&gt;Test case is as follows:&lt;/p&gt;

&lt;p&gt;CREATE TABLE implicit_test1(a BIGINT, b STRING) ROW FORMAT SERDE &apos;org.apache.hadoop.hive.serde2.dynamic_type.DynamicSerDe&apos; WITH SERDEPROPERTIES(&apos;serialization.format&apos;= &apos;org.apache.hadoop.hive.serde2.thrift.TCTLSeparatedProtocol&apos;) STORED AS TEXTFILE;&lt;/p&gt;


&lt;p&gt;SELECT implicit_test1.*&lt;br/&gt;
FROM implicit_test1&lt;br/&gt;
WHERE implicit_test1.a &amp;lt;&amp;gt; 0;&lt;/p&gt;


&lt;p&gt;Fails to do implicit conversion in the predicate implicit_test1.a &amp;lt;&amp;gt; 0 &lt;/p&gt;</comment>
                            <comment id="12652111" author="athusoo" created="Mon, 1 Dec 2008 19:32:33 +0000"  >&lt;p&gt;Zheng, I was actually fixing this. I have a partial fix ready for this. One major problem with this is the fact that the implict conversion stuff is broken because of circular dependencies in the implict conversion graph (this should be a tree) when string to number types are involved..&lt;/p&gt;</comment>
                            <comment id="12652133" author="zshao" created="Mon, 1 Dec 2008 19:59:13 +0000"  >&lt;p&gt;Yep. The problem with this test case is an ambiguous call: evaluate(String, Number), evaluate(Number, String), and evaluate(Long, Long) all fit with one implicit conversion.&lt;/p&gt;

&lt;p&gt;I think we have to disallow the circular conversion.&lt;/p&gt;

&lt;p&gt;This is what we discussed on the mailing list long time ago (This disallows number -&amp;gt; string implicit conversion)&lt;br/&gt;
String -&amp;gt; byte -&amp;gt; int -&amp;gt; long -&amp;gt; double&lt;br/&gt;
int -&amp;gt; float -&amp;gt; double&lt;/p&gt;

&lt;p&gt;Is this your plan for the fix?&lt;/p&gt;</comment>
                            <comment id="12652141" author="athusoo" created="Mon, 1 Dec 2008 20:26:16 +0000"  >&lt;p&gt;yes.&lt;/p&gt;

&lt;p&gt;basically what I have done is move string to be at the bottom of the hierarchy and disallow the implicit conversion from number to string and some of the tests fail because of that as we need to change them to do explicit conversion now.&lt;/p&gt;

&lt;p&gt;On looking at some of the test cases that fail, I think it would make sense to convert from various types to strings as well, though I had thought otherwise in the discussion that we had originally on the email thread. We have actually some queries in our tests that do that .e.g&lt;/p&gt;

&lt;p&gt;concat(&apos;My total: &apos;, sum(t.c))&lt;/p&gt;

&lt;p&gt;A user could do that very easily to generate reporting strings with that kind of a sql. Without implict conversion, they would have to write a cast operator.&lt;/p&gt;

&lt;p&gt;In light of that, I think we should revisit the decisions that we made.&lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;</comment>
                            <comment id="12652182" author="jsensarma" created="Mon, 1 Dec 2008 22:12:53 +0000"  >&lt;p&gt;if u can go both ways (string -&amp;gt; number and number -&amp;gt; string) - which way would u go? any rules we would come up with (perhaps based on context etc.) would become complicated. mysql does something even simpler than we proposed and people seem ok with that ..&lt;/p&gt;

&lt;p&gt;regarding the concat example - can&apos;t we make the function polymorphic? concat can take responsibilty for converting everything to string. &lt;/p&gt;</comment>
                            <comment id="12652192" author="athusoo" created="Mon, 1 Dec 2008 22:55:42 +0000"  >&lt;p&gt;Actually mysql supports implicit conversions in both directions and that is what got me thinking that perhaps we should also be supporting both.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/type-conversion.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://dev.mysql.com/doc/refman/5.0/en/type-conversion.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If we go the polymorphism route we would have to be very careful while adding UDFs. The UDF writers will have to really understand how for implicit conversion they have to implement functions with different signatures and that would just make it that much harder for them to write UDFs that can take advantage of implicit conversion. In fact polymorphism in the comparison function is the reason why we are hitting this problem in the&lt;br/&gt;
first place. &lt;/p&gt;


&lt;p&gt;The problem with going both ways is truly the one that caused us a lot of pain initially. However, that does not get solved by restricting the conversion possibilities. If for example we have a udf that takes two forms:&lt;/p&gt;

&lt;p&gt;a) evaluate(string, string, int)&lt;br/&gt;
b) evaluate(int, string, string)&lt;/p&gt;

&lt;p&gt;then even if we only allow string to be converted to int and not vice versa we have an ambiguous match for&lt;/p&gt;

&lt;p&gt;evaluate(1, &apos;abc&apos;, 2)&lt;/p&gt;

&lt;p&gt;and we would not know which one to pick. This is what I mean by polymorphism causing these issues. The comparison functions are&lt;br/&gt;
polymorphic and they are the ones that lead to the problem of ambiguity.&lt;/p&gt;</comment>
                            <comment id="12652332" author="zshao" created="Tue, 2 Dec 2008 10:31:49 +0000"  >&lt;p&gt;&amp;gt; a) evaluate(string, string, int)&lt;br/&gt;
&amp;gt; b) evaluate(int, string, string)&lt;/p&gt;

&lt;p&gt;This problem even happens for strict-typed languages (replace string with double). So I don&apos;t think this is something we need to fix.&lt;/p&gt;


&lt;p&gt;If we agree in most cases people convert string &lt;del&gt;&amp;gt; numeric, then all numeric&lt;/del&gt;&amp;gt;string can be done by udf itself through polymorphism.&lt;br/&gt;
I think this is much cleaner than circular conversion.&lt;/p&gt;

&lt;p&gt;I am +1 to stick to the original solution (and leave the author of concat to implement Number-&amp;gt;String conversion).&lt;/p&gt;</comment>
                            <comment id="12652341" author="athusoo" created="Tue, 2 Dec 2008 11:42:27 +0000"  >&lt;p&gt;I am not sure what you mean by saying that the problem also happens with strict-typed languages. Can you elaborate?&lt;/p&gt;</comment>
                            <comment id="12652342" author="zshao" created="Tue, 2 Dec 2008 11:44:47 +0000"  >&lt;p&gt;I mean, strict-typed languages will have ambiguity if the user calls evaluate(int, double, int), while there are 2 overloaded implementations: evaluate(double, double, int) and evaluate(int, double, double).&lt;/p&gt;</comment>
                            <comment id="12652681" author="zshao" created="Wed, 3 Dec 2008 04:53:09 +0000"  >&lt;p&gt;Namit&apos;s experiment with Oracle shows Oracle outputs ambiguity if UDF has both evaluate(double, double) and evaluate(string,string), and users calls udf(double, string).&lt;/p&gt;

&lt;p&gt;Let&apos;s stick with the following implicit conversion hierarchy and special-case comparison operators (they will prefer evaluate(double, double) to evaluate(string,string)):&lt;br/&gt;
byte -&amp;gt; short -&amp;gt; int -&amp;gt; long -&amp;gt; float -&amp;gt; double -&amp;gt; string, string -&amp;gt; double&lt;/p&gt;

&lt;p&gt;In order to allow the special case, we can add a tag to the methods. If there are multiple methods with the same number of implicit conversions, then we choose the one with the maximum tag (if there are still many then we say ambiguity).&lt;/p&gt;

&lt;p&gt;The reason that I think long -&amp;gt; float should be allowed is &lt;a href=&quot;http://java.sun.com/docs/books/jls/third_edition/html/conversions.html#25214&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://java.sun.com/docs/books/jls/third_edition/html/conversions.html#25214&lt;/a&gt; This of course also simplify the code since it&apos;s a single line instead of a DAG.&lt;/p&gt;</comment>
                            <comment id="12652683" author="zshao" created="Wed, 3 Dec 2008 04:57:10 +0000"  >&lt;p&gt;By using tag, we can get rid of the current hack (the evaluate(String, Number) and evaluate(Number, String) methods in the parent class) which caused the problem in this issue.&lt;/p&gt;</comment>
                            <comment id="12652988" author="athusoo" created="Wed, 3 Dec 2008 21:46:53 +0000"  >&lt;p&gt;I guess the following outlines how conversions are done for comparison operators for mysql&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.0/en/type-conversion.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://dev.mysql.com/doc/refman/5.0/en/type-conversion.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I think we should just follow that for comparisons.&lt;/p&gt;</comment>
                            <comment id="12653005" author="jsensarma" created="Wed, 3 Dec 2008 22:22:39 +0000"  >&lt;p&gt;@Zheng - i don&apos;t follow. i thought we discussed a while back that double-&amp;gt;string conversion is non-intuitive in a comparison between double and string. it&apos;s almost always the case that the user in such a case would like the string to be treated as a double and hence we had talked about putting string at the base of the partial order. mysql type conversion agrees with this approach.&lt;/p&gt;

&lt;p&gt;i am ok with using mysql type conversion semantics as well - but i think what we had agreed was better (in terms of partial order and finding least common super-type to convert to). this actually has space consequences - for example in mysql string + int will produce double. which consumes double the space of int (which is the least common super-type).&lt;/p&gt;

&lt;p&gt;i still don&apos;t see the problem with this approach (and letting udf polymorphism take care of ambiguities)&lt;/p&gt;</comment>
                            <comment id="12653090" author="zshao" created="Thu, 4 Dec 2008 00:52:21 +0000"  >&lt;p&gt;@joydeep: There are 2 drawbacks:&lt;/p&gt;

&lt;p&gt;1. Authors of udf need to be aware of that.  In oracle, the system does take care of double -&amp;gt; string in udf so authors don&apos;t have to do it.&lt;br/&gt;
2. string -&amp;gt; int is lossy. The result of &apos;1.1&apos; = 1 will be true under our agreed conversion partial order (string -&amp;gt; byte -&amp;gt; short -&amp;gt; int -&amp;gt; ... -&amp;gt; double). But both mysql and oracle output that as FALSE.&lt;/p&gt;
</comment>
                            <comment id="12653151" author="athusoo" created="Thu, 4 Dec 2008 03:56:19 +0000"  >&lt;p&gt;Description of implicit conversions in PL/SQL&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www-camden.rutgers.edu/HELP/Documentation/Oracle/server.815/a67842/02_funds.htm#3435&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www-camden.rutgers.edu/HELP/Documentation/Oracle/server.815/a67842/02_funds.htm#3435&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Description of implicit conversion in Postgres&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.postgresql.org/docs/7.3/static/typeconv.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.postgresql.org/docs/7.3/static/typeconv.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In light of this and the mysql implicit conversion for comparison types&lt;/p&gt;

&lt;p&gt;I think fundamentally the model is as follows:&lt;/p&gt;

&lt;p&gt;1. For overloaded comparison operators (&amp;gt;,&amp;lt;, &amp;gt;=, &amp;lt;=, &amp;lt;&amp;gt;, =):&lt;br/&gt;
      If both the operands have the same type, then we have an exact match&lt;br/&gt;
      otherwise, If one of the operands is a date and the other is not, then convert the other to a date.&lt;br/&gt;
      otherwise, If the two arguments are not of the same type, convert them both to double and do the comparison.&lt;br/&gt;
      Note that we do not do this for LIKE, RLIKE and REGEXP as those operators are not overloaded and every type is convertible to string&lt;/p&gt;

&lt;p&gt;2. For overloaded arithmetic operators (+, -, *, /, %, &amp;amp;, |, ^):&lt;br/&gt;
      If both the operands have the same types then we have an exact match&lt;br/&gt;
      otherwise we convert everything to double&lt;br/&gt;
      In this case the logical operators will just work as is as they are not overloaded in the sense that they do not have multiple evaluate functions.&lt;/p&gt;

&lt;p&gt;We allow seemless conversions within numbers, from string to numbers and vice versa as well as from date to string and vice versa. We may allow seemless conversion between date and int at some point (once we support date more formally)&lt;/p&gt;

&lt;p&gt;When looking for a match in a generic overloaded function (which is user defined and not one of the cases enumerated above as we have already addressed those), we use the current mechanism of picking up an evaluate function that needs&lt;br/&gt;
least number of conversions, otherwise we throw an ambiguity.&lt;/p&gt;

&lt;p&gt;So instead of encoding hierarchies, in the UDFTo... classes we will encode the conversion rules and then use the above to figure out the matches.&lt;/p&gt;

&lt;p&gt;I think this will give us the same results as mysql and other DBs as well.&lt;/p&gt;

&lt;p&gt;One thing that is still not very clean in this is the bit operators...&lt;/p&gt;

&lt;p&gt;I think this somewhat addresses all the concerns except the storage one which Joy raised, but even Oracle there warns about the same issue and asks the user to casting properly. These set of rules are also hopefully much simpler to code and to explain to the users.&lt;/p&gt;

&lt;p&gt;Thoughts? &lt;/p&gt;</comment>
                            <comment id="12657650" author="athusoo" created="Thu, 18 Dec 2008 02:03:34 +0000"  >&lt;p&gt;The expression node generation code needs changes to fix this bug and that in turn depends on the unified graph traversal and rules framework.&lt;/p&gt;</comment>
                            <comment id="12664266" author="athusoo" created="Thu, 15 Jan 2009 21:11:31 +0000"  >&lt;p&gt;Uploading the patch for refactoing typechecking and fixing implict conversion problems. This is a rather big patch with a number of changes relating to:&lt;br/&gt;
1. How we resolve udf and udaf evaluation functions or evaluators given the argument types.&lt;br/&gt;
2. Changes to how we implement UDAFs to support overloaded UDAFs.&lt;br/&gt;
3. Tree walker, dispatcher and processor code to make it more amenable to expression creation.&lt;br/&gt;
etc...&lt;/p&gt;

&lt;p&gt;Will update with a more detailed description of the changes after lunch.&lt;/p&gt;</comment>
                            <comment id="12664297" author="athusoo" created="Thu, 15 Jan 2009 22:33:25 +0000"  >&lt;p&gt;The patch contains the following changes: &lt;/p&gt;

&lt;p&gt;1. Interfaces to be able to plugin your own resolvers for UDFs and UDAFs. These are: &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;UDFMethodResolver for udfs -&amp;gt; Given the types of the arguments, this interface allows the compiler to retrieve which evaluate function to use.&lt;/li&gt;
	&lt;li&gt;UDAFEvaluatorResolver for udafs -&amp;gt; Given the types of the arguments, this interface allows the compiler to retrieve which UDAFEvaluator to use.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;What was UDAF previously in now the UDAFEvaluator interface. The function names have been changed somewhat. These are: &lt;br/&gt;
1. init which was also init in the UDAF abstract class - for initializaing the state &lt;br/&gt;
2. iterate which was aggregate in the UDAF abstract class - for updating the state for each passed in value of the arguments &lt;br/&gt;
3. terminatePartial which was evaluatePartial in the UDAF abstract class - for returning the state after the partial aggregation has been done &lt;br/&gt;
4. merge which was aggregatePartial in the UDAF abstract class - for merging the results of the terminatePartial while doing the final aggregation &lt;br/&gt;
5. terminate which was evaluate in the UDAF abstract class - for retruning the final result of the aggregation. &lt;/p&gt;

&lt;p&gt;The UDF and UDAF classes now encapsulate a resolver which is used for resolution for that particular class. &lt;br/&gt;
The different types of resolver implementation for UDFMethodResolver are: &lt;br/&gt;
1. DefaultUDFMethodResolver - This is the default resolver and it uses the old rule of finding the evaluate function in the UDF that needs least number of &lt;br/&gt;
    argument conversions. &lt;br/&gt;
2. NumericOpMethodResolver - This is the resolver used by overloaded numeric operators (+, -, %, /, *). This implements the following resolution logic: &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;If any of the arguments is Void (null) or String, then the evaluate(Double, Double) method is used.&lt;/li&gt;
	&lt;li&gt;otherwise, if both the arguments are of the same type, then the evaluate(&amp;lt;arg Type&amp;gt;, &amp;lt;arg Type&amp;gt;) method is used.&lt;/li&gt;
	&lt;li&gt;otherwise, evaluate(Double, Double) method is used.&lt;br/&gt;
3. ComparisonOpMethodResolver - This is the resolver used by oveloaded comparison operators (&amp;gt;, &amp;lt;. &amp;gt;=. &amp;lt;=. =. &amp;lt;&amp;gt;). This implements the following resolution logic: &lt;/li&gt;
	&lt;li&gt;If any of the arguments in Void (null), then the evaluate(Double, Double) method is used.&lt;/li&gt;
	&lt;li&gt;otherwise, if both the arguments are of the same type, then the evaluate(&amp;lt;arg Type&amp;gt;, &amp;lt;arg Type&amp;gt;) method is used.&lt;/li&gt;
	&lt;li&gt;otherwise, if one of the arguments is a Date, then evaluate(Date, Date) method is used.&lt;/li&gt;
	&lt;li&gt;otherwise, evaluate(Double, Double) method is used.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Abstract base classes for UDFs that use each of these resolvers are provided. These are: &lt;br/&gt;
1. UDF has been modified to use DefaultUDFMethodResolver. &lt;br/&gt;
2. UDFNumericOp is a new class which uses NumericOpMethodResolver. &lt;br/&gt;
3. UDFBaseCompare has been modified to use ComparisonOpMethodResolver. &lt;/p&gt;

&lt;p&gt;Similar to the UDFMethodResolvers decribed above, there are 2 implementation available for the UDAFEvaluatorResolvers. These are: &lt;br/&gt;
1. DefaultUDAFEvaluatorResolver - on similar lines as DefaultUDFMethodResolver. &lt;br/&gt;
2. NumericUDAFEvaluatorResolver - on similar lines as NumericOpMethodResolver. &lt;/p&gt;

&lt;p&gt;The UDAF resolution logic is in getUDAF where as the UDF resolution logic is in getExprNodeDesc. This logic is the same as previously, though &lt;br/&gt;
I think we should change this to allow conversions from any thing to any thing. I have change the UDF conversion operators to reflect that. In both &lt;br/&gt;
these locations, conversion operators are appropriately added for the arguments that need conversion. &lt;/p&gt;

&lt;p&gt;I have also moved the code to create exprNodeDesc to start using the tree walker infrastructure. Note the code in SemanticAnalyzer still remains &lt;br/&gt;
because PartitionPruner depends on it and we can get rid of that only after we have refactored partition pruning which iteself depends on predicate &lt;br/&gt;
push down - I will file a separate JIRA for this work. &lt;br/&gt;
In the Tree Walker framework, I have added the ability for the processor to return objects and I have also added the ability for the walker to pass &lt;br/&gt;
what was returned for objects walked so far to the processor. This is usefull while creating expression node descriptors for a node from the &lt;br/&gt;
expression node descriptors of the children that have been visited preorder. Also I have removed the NodeProcessorCtx (this was Joy&apos;s comment &lt;br/&gt;
in the previous review), it was anyway an empty abstract class and having that around was making it more involved to write the type checker &lt;br/&gt;
because of Java&apos;s lack of support for multiple class inheritance. &lt;br/&gt;
Accordingly, the type check processor and factory are implemented in: &lt;br/&gt;
1. TypeCheckProcFactory &lt;br/&gt;
2. TypeCheckCtx &lt;/p&gt;

&lt;p&gt;I have so far added 1 test relating to this JIRA. I am also going to add more tests for this. &lt;/p&gt;

&lt;p&gt;As a result of the UDAFEvaluator framework, we are now able to support overloaded aggregate functions like max and min for strings as well. &lt;br/&gt;
One of the existing tests which was returning null previously (a wrong result!!) now outputs the correct result.&lt;/p&gt;</comment>
                            <comment id="12665506" author="prasadc" created="Tue, 20 Jan 2009 19:11:24 +0000"  >&lt;p&gt;haven&apos;t finished looking at all of them&lt;br/&gt;
ql/src/java/org/apache/hadoop/hive/ql/exec/UDAFEvaluator.java:21	nit: that encapsulates?&lt;br/&gt;
ql/src/java/org/apache/hadoop/hive/ql/parse/TypeCheckProcFactory.java:128	can you put a comment explaining what is going on here&lt;br/&gt;
ql/src/java/org/apache/hadoop/hive/ql/parse/TypeCheckProcFactory.java:255	does this work for complex columns? i think this should use getColAlias or some such function&lt;br/&gt;
ql/src/java/org/apache/hadoop/hive/ql/parse/TypeCheckProcFactory.java:393	how do UDFs read struct object? how does it know the class?&lt;br/&gt;
ql/src/java/org/apache/hadoop/hive/ql/lib/NodeProcessorCtx.java:23	why is this removed? wouldn&apos;t it be useful so that arbitrary context objects are not passed around. or is that a requirement?&lt;/p&gt;</comment>
                            <comment id="12665680" author="athusoo" created="Wed, 21 Jan 2009 01:53:15 +0000"  >&lt;p&gt;I did not get the first comment. Can you elaborate on UDAFEvaluator.java:21?&lt;/p&gt;

&lt;p&gt;I removed NodeProcessorCtx.java because this was initially an abstract class with nothing inside it, so it was not serving any purpose as such (Joy had pointed that out in the previous JIRA code review)...&lt;/p&gt;

&lt;p&gt;Looking at other comments...&lt;/p&gt;</comment>
                            <comment id="12666485" author="athusoo" created="Fri, 23 Jan 2009 11:23:15 +0000"  >&lt;p&gt;For TypeCheckProcFactory.java:255 - This is the same code as the one that appears in genExprNodeDescFromColRef today. Don;t completely understand how getColAlias helps here?&lt;/p&gt;

&lt;p&gt;For 393: structs are just read to be of type Object. The only UDAF that I know of that does this is count.&lt;/p&gt;</comment>
                            <comment id="12666490" author="athusoo" created="Fri, 23 Jan 2009 11:33:25 +0000"  >&lt;p&gt;Resolved conflicts with latest changes from Prasad&apos;s checkin and cleaned out more stuff from SemanticAnalyzer&lt;/p&gt;

&lt;p&gt;There was one comment in the code review of converting the MethodResolver into a static variable in the UDF class. Can someone refresh my memory as to what was needed there. I tried doing that but it seems that there is not much benefit there.&lt;/p&gt;

&lt;p&gt;Another comment during the code review was with respect to the date type in the NumericOpMethodResolver. That code was actually in CompareOpMethodResolver and not in NumericOpMethodResolver as I had originally stated in the code review. So I did not have to change anything there..&lt;/p&gt;
</comment>
                            <comment id="12666817" author="athusoo" created="Sat, 24 Jan 2009 01:07:13 +0000"  >&lt;p&gt;Added NodeProcessorCtx back due to popular demand &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Also addressed other review comments from Prasad and Zheng..&lt;/p&gt;</comment>
                            <comment id="12666818" author="zshao" created="Sat, 24 Jan 2009 01:10:33 +0000"  >&lt;p&gt;+1&lt;/p&gt;</comment>
                            <comment id="12734394" author="zshao" created="Wed, 22 Jul 2009 23:59:28 +0000"  >&lt;p&gt;Fixed long time ago. Thanks Ashish!&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10032">
                    <name>Blocker</name>
                                                                <inwardlinks description="is blocked by">
                                        <issuelink>
            <issuekey id="12410943">HIVE-186</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12398012" name="patch-65.txt" size="592587" author="athusoo" created="Thu, 15 Jan 2009 21:11:30 +0000"/>
                            <attachment id="12398546" name="patch-65_2.txt" size="614274" author="athusoo" created="Fri, 23 Jan 2009 11:33:25 +0000"/>
                            <attachment id="12398622" name="patch-65_3.txt" size="625731" author="athusoo" created="Sat, 24 Jan 2009 01:07:13 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 1 Dec 2008 19:59:13 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>73808</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310191" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Hadoop Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10343"><![CDATA[Reviewed]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 20 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0l7mv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>121887</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310192" key="com.atlassian.jira.plugin.system.customfieldtypes:textarea">
                        <customfieldname>Release Note</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>&lt;a href=&quot;https://issues.apache.org/jira/browse/HIVE-65&quot; title=&quot;Implict conversion from integer to long broken for Dynamic Serde tables&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HIVE-65&quot;&gt;&lt;strike&gt;HIVE-65&lt;/strike&gt;&lt;/a&gt;. Rewrite typechecking to use the walker interface and add Resolvers to UDF and UDAF to support proper implicit casting in a manner similar to other RDBMSs. (athusoo)</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>