<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat Dec 03 02:28:20 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/CAMEL-1510/CAMEL-1510.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[CAMEL-1510] BatchProcessor interrupt has side effects</title>
                <link>https://issues.apache.org/jira/browse/CAMEL-1510</link>
                <project id="12311211" key="CAMEL">Camel</project>
                    <description>&lt;p&gt;I have noticed that the BatchProcessor class uses the Thread class interrupt method to wake the run loop from sleeping within the enqueueExchange method.&lt;/p&gt;

&lt;p&gt;The unfortunate side effect of this is that if the run loop is in the middle of processing exchanges, and the processing involves something slow like establishing a JMS connection over SSL or queuing to an asynchronous processor, then the processing can become interrupted. The consequence of this side effect is that the batch sender thread rarely gets the opportunity to complete properly and exceptions regarding the interrupt are thrown.&lt;/p&gt;

&lt;p&gt;This all became apparent during some performance testing that resulted in continuously adding exchanges to the aggregator, the threshold becoming reached, and then trying to enqueue the aggregated result to a JMS queue.&lt;/p&gt;

&lt;p&gt;If my analysis of the BatchProcessor is correct then I would recommend finer grained concurrency controls being used instead of relying upon interrupting a thread. Perhaps something like the following (untested) re-write of the sender:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; class BatchSender &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt; {
        &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; Queue&amp;lt;Exchange&amp;gt; queue;
        &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; exchangeQueued = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
        &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; Lock queueMutex = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ReentrantLock();
        &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; Condition queueCondition = queueMutex.newCondition();

        &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; BatchSender() {
            &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;(&lt;span class=&quot;code-quote&quot;&gt;&quot;Batch Sender&quot;&lt;/span&gt;);
            &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.queue = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;Exchange&amp;gt;();
        }

        &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void cancel() {
            interrupt();
        }

        &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void drainQueueTo(Collection&amp;lt;Exchange&amp;gt; collection, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; batchSize) {
            &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; batchSize; ++i) {
                Exchange e = queue.poll();
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (e != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
                    collection.add(e);
                } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
                    &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
                }
            }
        }

        &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void enqueueExchange(Exchange exchange) {
            queueMutex.lock();
            &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                queue.add(exchange);
                exchangeQueued = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
                queueCondition.signal();
            } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
                queueMutex.unlock();
            }
        }

        @Override
        &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void run() {
            queueMutex.lock();
            &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; {
                    &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!exchangeQueued) {
                            queueCondition.await(batchTimeout,
                                    TimeUnit.MILLISECONDS);
                            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!exchangeQueued) {
                                drainQueueTo(collection, batchSize);
                            }
                        }

                        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (exchangeQueued) {
                            exchangeQueued = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
                            queueMutex.unlock();
                            &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                                &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (isInBatchCompleted(queue.size())) {
                                    queueMutex.lock();
                                    &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                                        drainQueueTo(collection, batchSize);
                                    } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
                                        queueMutex.unlock();
                                    }
                                }

                                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!isOutBatchCompleted()) {
                                    &lt;span class=&quot;code-keyword&quot;&gt;continue&lt;/span&gt;;
                                }
                            } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
                                queueMutex.lock();
                            }

                        }

                        queueMutex.unlock();
                        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                            &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                                sendExchanges();
                            } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
                                getExceptionHandler().handleException(e);
                            }
                        } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
                            queueMutex.lock();
                        }
                    } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
                        &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
                    }
                } &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;);
            } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
                queueMutex.unlock();
            }
        }

        &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void sendExchanges() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {
            Iterator&amp;lt;Exchange&amp;gt; iter = collection.iterator();
            &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (iter.hasNext()) {
                Exchange exchange = iter.next();
                iter.remove();
                processExchange(exchange);
            }
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I have replaced the concurrent queue with a regular linked list and mutexed its access. In addition any queuing of exchanges is noted. This should result in less locking.&lt;/p&gt;

&lt;p&gt;The main change though is that queuing an exchange does not interrupt the batch sender&apos;s current activity.&lt;/p&gt;

&lt;p&gt;I hope that this sample is useful.&lt;/p&gt;</description>
                <environment>&lt;p&gt;Mac OS X&lt;/p&gt;</environment>
        <key id="12485271">CAMEL-1510</key>
            <summary>BatchProcessor interrupt has side effects</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.png">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="wtam">William Tam</assignee>
                                    <reporter username="huntc@internode.on.net">Christopher Hunt</reporter>
                        <labels>
                    </labels>
                <created>Thu, 2 Apr 2009 01:05:12 +0000</created>
                <updated>Sat, 21 Nov 2009 11:57:57 +0000</updated>
                            <resolved>Thu, 16 Apr 2009 20:31:33 +0000</resolved>
                                    <version>1.6.0</version>
                    <version>2.0-M1</version>
                                    <fixVersion>1.6.1</fixVersion>
                    <fixVersion>2.0-M2</fixVersion>
                                    <component>camel-core</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12951566" author="huntc@internode.on.net" created="Thu, 2 Apr 2009 01:07:15 +0000"  >&lt;p&gt;Formatted code&lt;/p&gt;</comment>
                            <comment id="12951565" author="huntc@internode.on.net" created="Thu, 2 Apr 2009 01:30:26 +0000"  >&lt;p&gt;The collection.clear() statement was incorrect. Removed.&lt;/p&gt;</comment>
                            <comment id="12951564" author="huntc@internode.on.net" created="Thu, 2 Apr 2009 01:36:55 +0000"  >&lt;p&gt;Just wondering... the batch processor&apos;s collection should always be a thread-safe type of collection. Is this the case in practice? If the collection is not thread safe then the batch sender run method will contend with the processor&apos;s isOutBatchCompleted(), doStop() and getCollection() methods.&lt;/p&gt;</comment>
                            <comment id="12951702" author="huntc@internode.on.net" created="Sat, 11 Apr 2009 22:11:06 +0000"  >&lt;p&gt;Upon inspecting the 2.0 trunk I see that this problem will be carried through.&lt;/p&gt;

&lt;p&gt;Is there any interest in fixing this problem?&lt;/p&gt;</comment>
                            <comment id="12951701" author="mrt1nz" created="Sun, 12 Apr 2009 09:11:24 +0000"  >&lt;p&gt;Christopher, sorry for reacting so late - didn&apos;t see the JIRA notification earlier. I wonder if it&apos;s sufficient to make the methods &lt;tt&gt;enqueueExchange()&lt;/tt&gt; and &lt;tt&gt;sendExchanges&lt;/tt&gt; synchronized to solve that problem. What do you think?&lt;/p&gt;</comment>
                            <comment id="12951709" author="huntc@internode.on.net" created="Sun, 12 Apr 2009 11:58:45 +0000"  >&lt;p&gt;Hi Martin,&lt;/p&gt;

&lt;p&gt;Thank you for replying.&lt;/p&gt;

&lt;p&gt;I presume by synchronised you mean that the enqueueExchange and sendExchanges lock on some shared mutex.&lt;/p&gt;

&lt;p&gt;I wonder with your suggestion if you might also have to try synchronising with other things that can then be overloaded e.g. isInBatchCompleted and isOutBatchCompleted. Who would know what these methods could eventually be doing?&lt;/p&gt;

&lt;p&gt;Personally I prefer to see the batch sender awake from known conditions i.e. timeout or exchange enqueued. For some reason I also feel that Interrupts are a little brutal and should be used sparingly.&lt;/p&gt;

&lt;p&gt;In addition I think that what I have proposed (albeit untested) would be more efficient as there is only one lock in play. The present solution has the lock associated within the blocking queue. You would of course being adding another lock with the potential for a deadlock.&lt;/p&gt;

&lt;p&gt;Thanks for the continued dialogue.&lt;/p&gt;

&lt;p&gt;Kind regards,&lt;br/&gt;
Christopher&lt;/p&gt;</comment>
                            <comment id="12951715" author="mrt1nz" created="Sun, 12 Apr 2009 18:21:26 +0000"  >&lt;p&gt;Hi Christopher,&lt;/p&gt;

&lt;p&gt;agreed that it&apos;s a bit more elegant to use the locking mechanism from &lt;tt&gt;java.util.concurrent.locks&lt;/tt&gt; when using Java 5 or higher &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; I just tried to solve the problem using &lt;tt&gt;ReentrantLock&lt;/tt&gt; and &lt;tt&gt;Condition&lt;/tt&gt; too but instead of using an &lt;tt&gt;exchangeQueued&lt;/tt&gt; variable I let the &lt;tt&gt;enqueueExchange()&lt;/tt&gt; and the &lt;tt&gt;cancel()&lt;/tt&gt; methods to &lt;em&gt;signal&lt;/em&gt; the batch sender to resume processing. I tested the following code with the &lt;tt&gt;AggregatorTest&lt;/tt&gt; unit tests.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; class BatchSender &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt; {
        
        &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; cancelRequested;

        &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; Queue&amp;lt;Exchange&amp;gt; queue;
        
        &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; Lock queueMutex = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ReentrantLock();
        
        &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; Condition queueCondition = queueMutex.newCondition();

        &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; BatchSender() {
            &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;(&lt;span class=&quot;code-quote&quot;&gt;&quot;Batch Sender&quot;&lt;/span&gt;);
            &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.queue = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;Exchange&amp;gt;();
        }

        @Override
        &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void run() {
            &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;) {
                queueMutex.lock();
                &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                    &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; signalled = queueCondition.await(batchTimeout, TimeUnit.MILLISECONDS);
                    processEnqueuedExchanges(signalled);
                } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
                    &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
                } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
                    &lt;span class=&quot;code-comment&quot;&gt;// TODO: handle exception ...
&lt;/span&gt;                    e.printStackTrace();
                } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
                    queueMutex.unlock();
                }
                
            }
        }
        
        &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void cancel() {
            cancelRequested = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
            queueMutex.lock();
            &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                queueCondition.signal();
            } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
                queueMutex.unlock();
            }
        }
     
        &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void enqueueExchange(Exchange exchange) {
            queue.add(exchange);
            queueMutex.lock();
            &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (isInBatchCompleted(queue.size())) {
                    queueCondition.signal();
                }
            } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
                queueMutex.unlock();
            }
        }
        
        &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void processEnqueuedExchanges(&lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; signalled) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {

            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!signalled) { 
                drainQueueTo(collection, batchSize); 
            } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (cancelRequested) {
                    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
                }
                &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (isInBatchCompleted(queue.size())) {
                    drainQueueTo(collection, batchSize);  
                }
                
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!isOutBatchCompleted()) {
                    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
                }
            }
            
            
            &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                sendExchanges();
            } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
                getExceptionHandler().handleException(e);
            }
            
        }
        
        &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void sendExchanges() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {
           ...
        }
        
        &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void drainQueueTo(Collection&amp;lt;Exchange&amp;gt; collection, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; batchSize) {
           ...
        }

    }    
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Does this make sense to you?&lt;/p&gt;

&lt;p&gt;BTW similar changes should also be applied to the stream resequencer. Let&apos;s close this issue only when both the &lt;tt&gt;BatchProcessor&lt;/tt&gt; and &lt;tt&gt;StreamResequencer&lt;/tt&gt; are fixed.&lt;/p&gt;</comment>
                            <comment id="12951713" author="huntc@internode.on.net" created="Sun, 12 Apr 2009 23:00:14 +0000"  >&lt;p&gt;Hi Martin,&lt;/p&gt;

&lt;p&gt;I&apos;m still leaning to the patch that I provided... I think that it closely resembles the code that is already there which is essentially flawed only in the sense that it interrupts when adding an exchange. &lt;/p&gt;

&lt;p&gt;A couple of observations with your changes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;cancel still needs to interrupt - you really want to interrupt with cancellations.&lt;/li&gt;
	&lt;li&gt;cancelRequested is not being protected within the cancel method.&lt;/li&gt;
	&lt;li&gt;cancelRequested wouldn&apos;t be required if cancel interrupts.&lt;/li&gt;
	&lt;li&gt;drainQueueTo will need to protect the queue also.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;... my code did do all of the above.&lt;/p&gt;

&lt;p&gt;Kind regards,&lt;br/&gt;
Christopher&lt;/p&gt;</comment>
                            <comment id="12951711" author="mrt1nz" created="Mon, 13 Apr 2009 08:13:17 +0000"  >&lt;p&gt;Christopher, my intention was to provide an implementation that signals the batch sender to stop waiting when the batch size has been reached and to continue processing. I think we should keep that. This is especially useful when the batch timeout is set to a high value. It prevents the batch sender from unecessarily waiting when the batch size has already been reached. From what I&apos;ve seen in your proposal this is not the case i.e. the batch sender continues to wait even if the in-batch size has been reached before the timeout. Changing cancellation to use &lt;tt&gt;interrupt()&lt;/tt&gt; makes sense to me.&lt;/p&gt;

&lt;p&gt;Maybe we should also consider to have a shared implementation for the wait/signal/cancel mechanisms for the &lt;tt&gt;BatchProcessor&lt;/tt&gt; and the &lt;tt&gt;StreamResequencer&lt;/tt&gt;, otherwise, we&apos;d need to implement similar things in two different places. Do you want to provide a patch file plus some tests or should we wait for comments from one of the commiters how to proceed?&lt;/p&gt;</comment>
                            <comment id="12951719" author="huntc@internode.on.net" created="Mon, 13 Apr 2009 08:48:00 +0000"  >&lt;p&gt;&quot;my intention was to provide an implementation that signals the batch sender to stop waiting when the batch size has been reached and to continue processing. I think we should keep that. &quot;&lt;/p&gt;

&lt;p&gt;I see the problem here - I forgot to include a signal of the condition variable. I will update my original comment to reflect this. My sincere apologies for the confusion. Would you mind re-reviewing my code?&lt;/p&gt;

&lt;p&gt;&quot;Maybe we should also consider to have a shared implementation for the wait/signal/cancel mechanisms for the BatchProcessor and the StreamResequencer, otherwise, we&apos;d need to implement similar things in two different places. &quot;&lt;/p&gt;

&lt;p&gt;I agree, a shared batch sender style of class should be useful.&lt;/p&gt;

&lt;p&gt;&quot;Do you want to provide a patch file plus some tests or should we wait for comments from one of the commiters how to proceed?&quot;&lt;/p&gt;

&lt;p&gt;I&apos;m happy to provide a patch file, though I did have difficulty building the camel distro. I could try again.&lt;/p&gt;

&lt;p&gt;I think that it would be great to receive some more feedback on this incident.&lt;/p&gt;

&lt;p&gt;Thanks again for the dialogue.&lt;/p&gt;</comment>
                            <comment id="12951720" author="huntc@internode.on.net" created="Mon, 13 Apr 2009 08:50:54 +0000"  >&lt;p&gt;Now signals the queue condition signal - forgot to include it in my original code suggestion.&lt;/p&gt;</comment>
                            <comment id="12951727" author="wtam" created="Tue, 14 Apr 2009 03:38:28 +0000"  >&lt;p&gt;Thanks for the great discussion and proposal.   I personally think Martin&apos;s version of BatchSender is a bit easier to read.  If they both solve the performance issue, I&apos;d give it a +1.  I think we agree to call intercept() in cancel().  Regarding the last bullet, it looks like drainQueueTo() is called with queueMutex already held, right?&lt;/p&gt;</comment>
                            <comment id="12951726" author="huntc@internode.on.net" created="Tue, 14 Apr 2009 04:23:50 +0000"  >&lt;p&gt;My feedback on Martin&apos;s proposal:&lt;/p&gt;

&lt;p&gt;1. cancelRequested is not required.&lt;br/&gt;
2. Line 19: move the lock before the while statement so that the block becomes (also using do instead of while) - less locking i.e.:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    queueMutex.lock();
    &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
      &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; {
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
          &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; signalled = queueCondition.await(batchTimeout,
              TimeUnit.MILLISECONDS);
          processEnqueuedExchanges(signalled);
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
          &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
          &lt;span class=&quot;code-comment&quot;&gt;// TODO: handle exception ...
&lt;/span&gt;          e.printStackTrace();
        }

      } &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;);
    } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
      queueMutex.unlock();
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3. Preserve the existing code for the cancel method i.e. it should continue performing an interrupt i.e.:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void cancel() {
      interrupt();
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4. enqueueExchange needs to add to the queue while the queue is locked i.e.:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void enqueueExchange(Exchange exchange) {
    queueMutex.lock();
    &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
      queue.add(exchange);
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (isInBatchCompleted(queue.size())) {
        queueCondition.signal();
      }
    } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
      queueMutex.unlock();
    }
  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;NOTE: isInBatchCompleted is called while the queue is locked - my example did not do this. My focus was on keeping the locks locked minimally given the goal of performance and throughput.&lt;/p&gt;

&lt;p&gt;5. processEnqueuedExchanges does not need to check if the batch is cancelled as the interrupt would have previously called an exception i.e.:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void processEnqueuedExchanges(&lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; signalled) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {

    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!signalled) {
      drainQueueTo(collection, batchSize);
    } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
      &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (isInBatchCompleted(queue.size())) {
        drainQueueTo(collection, batchSize);
      }

      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!isOutBatchCompleted()) {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
      }
    }

    &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
      sendExchanges();
    } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
      getExceptionHandler().handleException(e);
    }

  }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;NOTE: isInBatchCompleted is now being called a second time - once inside enqueueExchange and now here.&lt;/p&gt;

&lt;p&gt;NOTE: sendExchanges is being called while the queue is locked. If there is some slow IO occurring (as was indeed the case with my determining this issue originally) then nothing can be added to the queue during sendExchanges.&lt;/p&gt;

&lt;p&gt;My focus with the original code submission was on minimising lock contentions while retaining a structure that built on proven code.&lt;/p&gt;</comment>
                            <comment id="12951723" author="mrt1nz" created="Tue, 14 Apr 2009 05:59:59 +0000"  >&lt;p&gt;My feedback on Christopher&apos;s comments:&lt;/p&gt;

&lt;p&gt;1) ok&lt;br/&gt;
2) ok&lt;br/&gt;
3) ok&lt;br/&gt;
4) I added &lt;tt&gt;isInBatchCompleted()&lt;/tt&gt; here because otherwise we&apos;d always stop the batch sender from waiting &lt;tt&gt;batchTimeout&lt;/tt&gt; ms. I think that&apos;s also an issue in the original code (i.e. in the codebase, not Christopher&apos;s proposal): the batch sender has always been interrupted whenever a message was enequeued. From a user&apos;s perspective there&apos;s no noticable batch timeout, for example, when the &lt;tt&gt;batchTimout&lt;/tt&gt; is set to 1000 ms and every 300 ms there is a message coming in (assuming the batch size is 100). Normally, the batch processor should send 3 messages after the timout occurs but using the original code it would send more (I&apos;d expect 100 messages) The unit test testing the batch timout only works because it only sends a single message (BTW the original patch from &lt;a href=&quot;https://issues.apache.org/jira/browse/CAMEL-1037&quot; title=&quot;Messages in Resequencer between 2 JMS queues get stuck&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CAMEL-1037&quot;&gt;&lt;del&gt;CAMEL-1037&lt;/del&gt;&lt;/a&gt; honored the batch timeout). I didn&apos;t verify these statements in a unit test - just derived that from looking at the code. We should consider that when fixing this issue (maybe Christopher&apos;s initial proposal is not &apos;built on a proven code&apos;). Regarding all other comments for this point: ok (it makes sense to do a more fine-grained locking).&lt;br/&gt;
5) Actually, I don&apos;t fully understand why a &lt;tt&gt;while (isInBatchCompleted(queue.size()))&lt;/tt&gt; is used here anyway. Any thoughts? Regarding lock granularity: a more fine-grained locking woud make sense here too.&lt;/p&gt;

&lt;p&gt;Furthermore, I agree with William that Christopher&apos;s original proposal is a bit difficult to read. Some refactorings would help. &lt;/p&gt;</comment>
                            <comment id="12951728" author="huntc@internode.on.net" created="Tue, 14 Apr 2009 06:23:01 +0000"  >&lt;p&gt;Hi guys,&lt;/p&gt;

&lt;p&gt;Thanks for this great dialogue.&lt;/p&gt;

&lt;p&gt;With regards to:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;I think that&apos;s also an issue in the original code (i.e. in the codebase, not Christopher&apos;s proposal): the batch sender has always been interrupted whenever a message was enequeued. From a user&apos;s perspective there&apos;s no noticable batch timeout, for example, when the batchTimout is set to 1000 ms and every 300 ms there is a message coming in (assuming the batch size is 100). Normally, the batch processor should send 3 messages after the timout occurs but using the original code it would send more (I&apos;d expect 100 messages)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I do not believe that is the case with the original code or my proposal. The queue is only drained into the collection if the batch times out. Using my code to illustrate:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!exchangeQueued) {
  drainQueueTo(collection, batchSize);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Furthermore sendExchanges would not even be called unless the batch is complete given the following block:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (exchangeQueued) {
       exchangeQueued = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
       queueMutex.unlock();
       &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
           &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (isInBatchCompleted(queue.size())) {
               queueMutex.lock();
               &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                   drainQueueTo(collection, batchSize);
               } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
                   queueMutex.unlock();
               }
           }

           &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!isOutBatchCompleted()) {
               &lt;span class=&quot;code-keyword&quot;&gt;continue&lt;/span&gt;;
           }
       } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
           queueMutex.lock();
       }

   }

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;... if the batch is not completed then the loop will continue.&lt;/p&gt;

&lt;p&gt;On the re-factoring, please bear in mind that in essence, all that I have done is moved blocks of existing code around and used a condition to signal when adding to the queue.&lt;/p&gt;</comment>
                            <comment id="12951752" author="wtam" created="Wed, 15 Apr 2009 04:11:03 +0000"  >&lt;p&gt;@Martin&lt;br/&gt;
Let me try to answer your question regarding InBatchCompleted(),  the original patch from &lt;a href=&quot;https://issues.apache.org/jira/browse/CAMEL-1037&quot; title=&quot;Messages in Resequencer between 2 JMS queues get stuck&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CAMEL-1037&quot;&gt;&lt;del&gt;CAMEL-1037&lt;/del&gt;&lt;/a&gt; has an issue.  (I thought it had anyway.)   Suppose the batch size is a very small number (say 2).  Someone can send a large number (say 1000) of messages to the BatchProcessor in a short period of time.  It can cause the queue size to become much greater than the batch size. The reason is that the enqueueExchange only interrupts the Sender thread if it is sleeping.  If the Sender thread is not sleeping it only drain 2 messages from the queue.  The queue can back up pretty easily.   When that happens, (hundreds of) messages are stuck on the queue until batchTimeout expires.  However, it only drains 2 messages (batchSize) for each batchTimeout.  Most of messages in the queue really should have been sent.   It should have at most 1 message left in the queue in this example.&lt;/p&gt;

&lt;p&gt;The &quot;while (isInBatchCompleted(queue.size()&quot; is to address the issue.  We actually introduced new parameters InBatchSize and OutBatchSize.  InBatchSize is how big the queue can grow before draining the messages to the collection.  OutBatchSize is how big the collection can grow before messages are sent.  &lt;/p&gt;

&lt;p&gt;BTW, setting the OutBatchSize would give you the behavior in the original patch.&lt;/p&gt;
</comment>
                            <comment id="12951751" author="wtam" created="Wed, 15 Apr 2009 05:15:49 +0000"  >&lt;p&gt;@Christopher&lt;br/&gt;
You are pretty close to have a patch, right?  Would you mind to create one?   &lt;/p&gt;</comment>
                            <comment id="12951769" author="huntc@internode.on.net" created="Wed, 15 Apr 2009 05:48:42 +0000"  >&lt;p&gt;Sure thing. I should be able to do this tomorrow - shall I work off the 2.0 trunk?&lt;/p&gt;</comment>
                            <comment id="12951758" author="mrt1nz" created="Wed, 15 Apr 2009 06:12:46 +0000"  >&lt;p&gt;Thank you guys for this great discussion. It would be great to have a patch for the 2.x trunk and the 1.x branch. If I can help you doing that please let me know.&lt;/p&gt;</comment>
                            <comment id="12951776" author="huntc@internode.on.net" created="Thu, 16 Apr 2009 04:23:30 +0000"  >&lt;p&gt;Batch file attached for the trunk (v2) build.&lt;/p&gt;

&lt;p&gt;I have tested this by running AggregatorTest - do you think that is sufficient?&lt;/p&gt;

&lt;p&gt;I have not had the time yet to update the v.1.x branch.&lt;/p&gt;</comment>
                            <comment id="12951775" author="wtam" created="Thu, 16 Apr 2009 04:45:30 +0000"  >&lt;p&gt;Hi Christopher,&lt;br/&gt;
Thanks for working on the issue.  I&apos;d say at least running all tests in camel-core. &lt;/p&gt;</comment>
                            <comment id="12951774" author="huntc@internode.on.net" created="Thu, 16 Apr 2009 05:15:10 +0000"  >&lt;p&gt;I have now ran all of the camel-core tests and things appear fine:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
cd Development/Eclipse/camel-workspace/camel-trunk/
cd camel-core/
mvn test
[INFO] Scanning &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; projects...
[INFO] ------------------------------------------------------------------------
[INFO] Building Camel :: Core
[INFO]    task-segment: [test]
[INFO] ------------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using &lt;span class=&quot;code-keyword&quot;&gt;default&lt;/span&gt; encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Compiling 1 source file to /Volumes/Users HD/Users/huntc/Development/Eclipse/camel-workspace/camel-trunk/camel-core/target/classes
[INFO] [resources:testResources]
[INFO] Using &lt;span class=&quot;code-keyword&quot;&gt;default&lt;/span&gt; encoding to copy filtered resources.
[INFO] [compiler:testCompile]
[INFO] Nothing to compile - all classes are up to date
[INFO] [surefire:test]
[INFO] Surefire report directory: /Volumes/Users HD/Users/huntc/Development/Eclipse/camel-workspace/camel-trunk/camel-core/target/surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running org.apache.camel.management.JmxInstrumentationWithConnectorTest
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 7.151 sec
Running org.apache.camel.issues.InterceptorLogTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.821 sec
Running org.apache.camel.processor.RemoveHeaderTest
...
Running org.apache.camel.converter.ConverterTest
Tests run: 15, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.703 sec &amp;lt;&amp;lt;&amp;lt; FAILURE!
...
Running org.apache.camel.util.jndi.JndiTest
Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.175 sec
Running org.apache.camel.component.bean.CustomParameterMappingStrategyTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.799 sec

Results :

Failed tests: 

Tests run: 941, Failures: 1, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[ERROR] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ConverterTest fails because I am running on Mac OS X and have a path that includes a space:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
ConverterTest
org.apache.camel.converter.ConverterTest
testFileToString(org.apache.camel.converter.ConverterTest)
junit.framework.AssertionFailedError: Should have returned a &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;!
	at junit.framework.Assert.fail(Assert.java:47)
	at junit.framework.Assert.assertTrue(Assert.java:20)
	at junit.framework.Assert.assertNotNull(Assert.java:217)
	at org.apache.camel.converter.ConverterTest.testFileToString(ConverterTest.java:166)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:164)
	at junit.framework.TestCase.runBare(TestCase.java:130)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:120)
	at junit.framework.TestSuite.runTest(TestSuite.java:230)
	at junit.framework.TestSuite.run(TestSuite.java:225)
	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:81)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:45)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(that&apos;s an unlreated problem)&lt;/p&gt;

&lt;p&gt;Please note that I have not attempted to apply my changes to StreamResequencer. Martin highlighted that StreamResequencer has a similar structure to BatchProcessor.&lt;/p&gt;</comment>
                            <comment id="12951773" author="mrt1nz" created="Thu, 16 Apr 2009 05:18:40 +0000"  >&lt;p&gt;I&apos;ll provide a patch for the StreamResequencer within the next days.&lt;/p&gt;</comment>
                            <comment id="12951784" author="wtam" created="Thu, 16 Apr 2009 15:40:30 +0000"  >&lt;p&gt;Thanks guys.  Christopher, your patch looks good.  I slightly modified it. &lt;/p&gt;

&lt;p&gt;1. I got it to pass style check.  FYI, you enable style checker by &quot;mvn -Psourcecheck&quot;.&lt;/p&gt;

&lt;p&gt;2. I made sure queue.size() is called with queueLock held.&lt;/p&gt;

&lt;p&gt;(Regarding &quot;while loop around (isInBatchCompleted(queue.size)&quot;, your patch and the original code stand correct.  It is still needed but only for the timeout case.)&lt;/p&gt;


</comment>
                            <comment id="12951790" author="wtam" created="Thu, 16 Apr 2009 17:17:06 +0000"  >&lt;p&gt;Christopher&apos;s patch has been submitted to trunk (r765686) and 1.x (r765689).   &lt;br/&gt;
Martin, I will submit your fix to StreamResequencer whenever you are ready. &lt;/p&gt;

&lt;p&gt;Thanks!&lt;/p&gt;</comment>
                            <comment id="12951794" author="wtam" created="Thu, 16 Apr 2009 18:59:29 +0000"  >&lt;p&gt;To answer Christopher&apos;s question:&lt;br/&gt;
&quot;Just wondering... the batch processor&apos;s collection should always be a thread-safe type of collection. Is this the case in practice? If the collection is not thread safe then the batch sender run method will contend with the processor&apos;s isOutBatchCompleted(), doStop() and getCollection() methods.&quot;&lt;/p&gt;

&lt;p&gt;The batch processor&apos;s collection is exclusively accessed by the BatchSender thread (with the exception accessed by the doStop() method), so the collection does not need to be a thread-safe type.  The doStop() method is called during shutdown and it interrupts the BatchSender thread before clear() on the collection, so it should be fine.  The getCollection() is a protected method and it never gets called.  We probably should get rid of getCollection() and make In/OutBatchCompleted() method private.  Thoughts?&lt;/p&gt;</comment>
                            <comment id="12951793" author="mrt1nz" created="Thu, 16 Apr 2009 19:10:08 +0000"  >&lt;p&gt;Attached are the StreamResequencer patches for 2.x trunk and 1.x branch:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;camel-core-2.x.patch&lt;/li&gt;
	&lt;li&gt;camel-core-1.x.patch&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12951792" author="wtam" created="Thu, 16 Apr 2009 19:58:06 +0000"  >&lt;p&gt;Submitted Martin&apos;s patch to trunk (r765729) and 1.x (r765731);&lt;/p&gt;</comment>
                            <comment id="12951791" author="wtam" created="Thu, 16 Apr 2009 20:31:33 +0000"  >&lt;p&gt;Also, submitted changes to reduce the scope of methods that access collection object to trunk (r765743) and 1.x (r765748).  Big thanks to Christopher Hunt and Martin Krasser for working on this issue!&lt;/p&gt;</comment>
                            <comment id="12951798" author="huntc@internode.on.net" created="Fri, 17 Apr 2009 00:01:52 +0000"  >&lt;p&gt;Hi William,&lt;/p&gt;

&lt;p&gt;Thanks for submitting my patch to BatchProcessor. Thank you also for reviewing the code and noticing that queue.size() wasn&apos;t protected. I obtained your version of BatchProcessor from the trunk and further noticed that the call to isOutBatchCompleted can be safely performed while retaining the queue lock. I was under the original impression (through not looking) that isInBatchCompleted and isOutBatchCompleted were overload-able. Since they are private then this can not be the case and thus can be invoked while retaining the queue lock. The code is nicely simplified by removing the locking around these calls.&lt;/p&gt;

&lt;p&gt;I have attached a minor patch reflecting the above after having performed the camel-core test cases successfully again. The patch is for the 2.0 source.&lt;/p&gt;

&lt;p&gt;Kind regards,&lt;br/&gt;
Christopher&lt;/p&gt;</comment>
                            <comment id="12951799" author="huntc@internode.on.net" created="Fri, 17 Apr 2009 00:02:21 +0000"  >&lt;p&gt;Reduced locking further:&lt;/p&gt;

&lt;p&gt;BatchProcessor-lockmin.java.20.diff&lt;/p&gt;</comment>
                            <comment id="12951800" author="wtam" created="Fri, 17 Apr 2009 01:18:39 +0000"  >&lt;p&gt;Submitted Christopher&apos;s second patch (rr765824 and r765825).  Thanks!&lt;/p&gt;</comment>
                            <comment id="12951827" author="huntc@internode.on.net" created="Sun, 19 Apr 2009 02:46:35 +0000"  >&lt;p&gt;Hi Martin,&lt;/p&gt;

&lt;p&gt;I just had a look at your changes to StreamResequencer and wonder if you need to signal that a request has been delivered using a boolean as well as relying on the condition variable. Perhaps you do not need to discriminate between a timeout and whether a request is made, but I thought you should know that a condition variable can wake up spuriously on some platforms i.e. non-timeout and non-signal.&lt;/p&gt;

&lt;p&gt;From the Java 5 javadoc:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;When waiting upon a Condition, a &quot;spurious wakeup&quot; is permitted to occur, in general, as a concession to the underlying platform semantics. This has little practical impact on most application programs as a Condition should always be waited upon in a loop, testing the state predicate that is being waited for. An implementation is free to remove the possibility of spurious wakeups but it is recommended that applications programmers always assume that they can occur and so always wait in a loop.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&apos;hope that this is useful to you.&lt;/p&gt;

&lt;p&gt;Kind regards,&lt;br/&gt;
Christopher&lt;/p&gt;</comment>
                            <comment id="12951795" author="mrt1nz" created="Sun, 19 Apr 2009 16:25:08 +0000"  >&lt;p&gt;Hi Christopher,&lt;/p&gt;

&lt;p&gt;Spurious wakeups are ok for the stream resequencer. If they occur the ResequencerEngine takes care that only elements are delivered if they really timed-out (the ResequencerEngine tracks timeouts for each element separately). We can leave the code as is.&lt;/p&gt;</comment>
                            <comment id="12953607" author="davsclaus" created="Sat, 21 Nov 2009 11:57:57 +0000"  >&lt;p&gt;Closing all 2.0M2 tickets&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12462918" name="BatchProcessor-lockmin.java.20.diff" size="1571" author="huntc@internode.on.net" created="Fri, 17 Apr 2009 00:02:21 +0000"/>
                            <attachment id="12462917" name="BatchProcessor.java.20.diff" size="6926" author="huntc@internode.on.net" created="Thu, 16 Apr 2009 04:23:29 +0000"/>
                            <attachment id="12462919" name="camel-core-1.x.patch" size="4571" author="mrt1nz" created="Thu, 16 Apr 2009 19:10:08 +0000"/>
                            <attachment id="12462920" name="camel-core-2.x.patch" size="4534" author="mrt1nz" created="Thu, 16 Apr 2009 19:10:08 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 12 Apr 2009 09:11:24 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>76827</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 2 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12310041" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Patch Info</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10042"><![CDATA[Patch Available]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i01iuv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6824</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>