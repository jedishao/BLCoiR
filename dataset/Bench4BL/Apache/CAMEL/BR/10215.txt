EventDrivenPollingConsumer is not thread safe when used with ConsumerCache For static endpoints, if DefaultConsumerTemplate#receive() is used,  ConsumerCache will return the cached instance of PollingConsumer for every thread part of parallel processing of split/aggregate.
Now, if EventDrivenPollingConsumer is used, returning same cache instance causes race condition in receive and receive(long) as the methods are not thread safe. The ordering of beforePoll, poll and afterPoll needs to be synchronized, otherwise the consumer might end up being suspended in afterPoll and the client whose beforePoll couldn't wake up the suspended thread will get no data.
