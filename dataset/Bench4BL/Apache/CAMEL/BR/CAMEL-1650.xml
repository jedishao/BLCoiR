<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat Dec 03 03:10:25 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/CAMEL-1650/CAMEL-1650.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[CAMEL-1650] Race condition in IdempotentConsumer</title>
                <link>https://issues.apache.org/jira/browse/CAMEL-1650</link>
                <project id="12311211" key="CAMEL">Camel</project>
                    <description>&lt;p&gt;A possible possible race condition exists in the IdempotentConsumer implementation:&lt;br/&gt;
The code first checks in the MessageIdRepository if the message was already processed. If not then it processes the message and&lt;br/&gt;
afterwards adds the id to the repository. (See also &lt;a href=&quot;http://issues.apache.org/activemq/browse/CAMEL-1451&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/activemq/browse/CAMEL-1451&lt;/a&gt;). There is no locking&lt;br/&gt;
between the check with &quot;contains&quot; and the insert with &quot;add&quot;. So if multiple threads/instances try this in parallel for the same id, then&lt;br/&gt;
it might happen that more than one finds the id not yet contained in the repository and the same message is processed multiple&lt;br/&gt;
times.&lt;/p&gt;

&lt;p&gt;I enclose an extended version of IdempotentConsumerTest which illustrates the problem.&lt;br/&gt;
It is important to note that even if the test demonstrates the issue with an MemoryIdempotentRepository a solution should also&lt;br/&gt;
address the case of a database based respository in a clustered environment. So this might imply that some locking mechanism on the&lt;br/&gt;
database is required.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12486450">CAMEL-1650</key>
            <summary>Race condition in IdempotentConsumer</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="davsclaus">Claus Ibsen</assignee>
                                    <reporter username="ohecker">Oliver Hecker</reporter>
                        <labels>
                    </labels>
                <created>Wed, 27 May 2009 12:38:36 +0000</created>
                <updated>Sat, 21 Nov 2009 11:58:02 +0000</updated>
                            <resolved>Sun, 7 Jun 2009 11:23:29 +0000</resolved>
                                    <version>2.0-M1</version>
                                    <fixVersion>2.0-M2</fixVersion>
                                    <component>camel-core</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="12952334" author="ohecker" created="Wed, 27 May 2009 12:40:22 +0000"  >&lt;p&gt;Extended version of the unit test which shows the problem.&lt;/p&gt;</comment>
                            <comment id="12952332" author="davsclaus" created="Wed, 27 May 2009 13:23:50 +0000"  >&lt;p&gt;Thanks for the unit test.&lt;/p&gt;

&lt;p&gt;The problem is a bit chicken and egg. Should you add the id before you start process the message or afterwards?&lt;br/&gt;
If you do it before then you have the issue what if the processing failed? Should the id be removed or should it stay?&lt;/p&gt;

&lt;p&gt;Maybe we should expose options so end user can configure&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;before&lt;/li&gt;
	&lt;li&gt;after&lt;/li&gt;
	&lt;li&gt;and if id should be removed in case of failure&lt;/li&gt;
&lt;/ul&gt;

</comment>
                            <comment id="12952331" author="ohecker" created="Wed, 27 May 2009 14:56:44 +0000"  >&lt;p&gt;Yes, I see the problem. The way how it is implemented at the moment assures an &quot;at least once&quot; quality of service.&lt;br/&gt;
Assuming that race conditions will not occur quite often this seems to be OK for most cases.&lt;br/&gt;
I was testing this because I am looking for a way to manage scheduled jobs (via Camel Quartz) in a clustered szenario&lt;br/&gt;
running the same camel config on multiple host in parallel. I am looking for a way to assure that even if the job is triggered&lt;br/&gt;
on every host only one of them gets actually processed. Due to the timers running more or less synchronous on all hosts&lt;br/&gt;
I am expecting that race conditions might occur quite often. (I actually also investigated in using the cluster features of Quartz&lt;br/&gt;
itself but found it not working within Camel Quartz)&lt;/p&gt;

&lt;p&gt;Removing the id in case of a failure will not work if there there is some (technical) problem which prevents from deleting the entry&lt;br/&gt;
in the database. So if we crash after inserting in the database but before we could deliver to the destination then the message then&lt;br/&gt;
even when retrying later the filter will filter out the message.&lt;/p&gt;

&lt;p&gt;I was thinking of some intermediate state to be stored in the repository to serve as a lock for the time between &quot;contains&quot; and &quot;add&quot;.&lt;br/&gt;
But this requires quite some effort concerning coordination and detecting failed instances in the cluster.&lt;/p&gt;

&lt;p&gt;So the Interface of IdempotentRepository might be something like&lt;/p&gt;

&lt;p&gt;isProcessedAndLockIfNot (the former &quot;contains&quot;): &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Returns true if the id is contained in state &quot;processed&quot;&lt;/li&gt;
	&lt;li&gt;Returns false if id is not contained. Will insert id in state &quot;locked&quot;&lt;/li&gt;
	&lt;li&gt;if id is contained in state &quot;locked&quot; then the call will be blocked until&lt;/li&gt;
	&lt;li&gt;the id is either removed or goes to state processed, then proceed as above   or&lt;/li&gt;
	&lt;li&gt;a timeout is reached which indicates that the process which set the lock possibly crashed; in this case the lock will be stolen and false will be returned&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;setProcessed (the former &quot;add&quot;):&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;set state of ID to &quot;processed&quot;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;unlock (new):&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;delete id from the repository;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;It might even be necessary to keep track of who aquired a lock to avoid messing up if the locker tries to release a lock after the timeout occurred.&lt;/p&gt;

&lt;p&gt;In any case this requires quite some interface and coding changes (and some more thoughts about how to do it).&lt;/p&gt;</comment>
                            <comment id="12952444" author="davsclaus" created="Fri, 5 Jun 2009 14:46:54 +0000"  >&lt;p&gt;We could add a 1st cache that is a JVM only memory pool for the in flight exchanges.&lt;br/&gt;
So if there is a duplicate sent while another is currently being processed it can be found in the memory pool and be rejected.&lt;/p&gt;
</comment>
                            <comment id="12957612" author="a_abes@yahoo.com" created="Fri, 5 Jun 2009 18:27:03 +0000"  >&lt;p&gt;Sounds that what you&apos;re looking for is a bit like transaction management - you want to make sure that the Quartz event gets processed exactly once.&lt;br/&gt;
If the UnitOfWork provided a means to register  &quot;start&quot; synchronization objects, with access to the Exchange then you could potentially do something like:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;sync.start() - extract the message ID and perform duplication check against DB (or memory) and implement your decision algorithm, potentially delaying until timeout. Potentially polling for completion against the DB. In a memory based approach, you could get notified when the lock on the process is signaled.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; -sync.onFailure / onComplete would update the database (memory) with the status and continue.&lt;/p&gt;

&lt;p&gt;this basically would provide a means to have an &quot;exclusive&quot; unit of work...&lt;/p&gt;</comment>
                            <comment id="12952462" author="ohecker" created="Fri, 5 Jun 2009 19:43:17 +0000"  >&lt;p&gt;Andi summarized quite exaclty what I am looking for. I think this is how interaction with the IdempotentRepository should look like to make shure it works in a parallel processing scenario.&lt;br/&gt;
The old implementation (pre &lt;a href=&quot;https://issues.apache.org/jira/browse/CAMEL-1451&quot; title=&quot;IdempotentConsumer - should only add to repository after processing, so we know the processing was a success&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CAMEL-1451&quot;&gt;&lt;del&gt;CAMEL-1451&lt;/del&gt;&lt;/a&gt;) had the issue that the message gets lost when the route fails after checking the repository.&lt;br/&gt;
The current implentation has the issue that there might be duplicates because identical messages are not detected unless the first one gets processed completely. &lt;/p&gt;

&lt;p&gt;The solution with the in memory cache might improve the situation but will have no effect in my main use case (Quartz trigger duplicates) because here the duplicate messages occur on always on different machines. So in this scenario a synchronization via database is required to make it work. &lt;/p&gt;</comment>
                            <comment id="12952472" author="davsclaus" created="Sun, 7 Jun 2009 09:49:31 +0000"  >&lt;p&gt;Oliver, thanks for the unit test.&lt;/p&gt;

&lt;p&gt;I have reproduced the problem, and working with &lt;a href=&quot;https://issues.apache.org/jira/browse/CAMEL-1679&quot; title=&quot;InProgress repository&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CAMEL-1679&quot;&gt;&lt;del&gt;CAMEL-1679&lt;/del&gt;&lt;/a&gt; on a solution.&lt;/p&gt;</comment>
                            <comment id="12952471" author="davsclaus" created="Sun, 7 Jun 2009 10:02:29 +0000"  >&lt;p&gt;I added the &lt;b&gt;remove&lt;/b&gt; operation to the idempotent interface so you can implement your DB based solution.&lt;/p&gt;

&lt;p&gt;And changed the behavior to add the key before processing. And in case of a failure it will invoke the remove operation so you can process the failed message at a later stage.&lt;/p&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; IdempotentRepository&amp;lt;E&amp;gt; {

    /**
     * Adds the key to the repository.
     *
     * @param key the key of the message &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; duplicate test
     * @&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &amp;lt;tt&amp;gt;&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&amp;lt;/tt&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; repository did &amp;lt;b&amp;gt;not&amp;lt;/b&amp;gt; already contain the specified element
     */
    &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; add(E key);

    /**
     * Returns &amp;lt;tt&amp;gt;&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&amp;lt;/tt&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; repository contains the specified element.
     *
     * @param key the key of the message
     * @&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &amp;lt;tt&amp;gt;&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&amp;lt;/tt&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; repository contains the specified element
     */
    &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; contains(E key);

    /**
     * Removes the key from the repository.
     *
     * @param key the key of the message &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; duplicate test
     * @&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &amp;lt;tt&amp;gt;&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&amp;lt;/tt&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the key was removed
     */
    &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; remove(E key);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

</comment>
                            <comment id="12952484" author="ohecker" created="Sun, 7 Jun 2009 11:01:03 +0000"  >&lt;p&gt;Thanks Claus.&lt;br/&gt;
I was in the meantime locally working on a solution as I had drafted it above. It would be a major change in the IdempotentRepository interface. Also the interface&lt;br/&gt;
would no longer be as easy as the &quot;Set-alike&quot; interface of the current IdempotentRepository.&lt;/p&gt;

&lt;p&gt;The main idea is that the key might be first &quot;reserved&quot; in the repository which also includes a timeout and might lateron either be &quot;confirmed&quot; or &quot;released&quot;.&lt;/p&gt;

&lt;p&gt;I already got a changed MemoryIdempotentRepository working and an IdempotentConsumer implementation. For the&lt;br/&gt;
FileConsumer it is not that straightforward as the lockHandle Object needs to be attached to the Exchange due to the asynchronous processor.&lt;/p&gt;

&lt;p&gt;Probably &lt;a href=&quot;https://issues.apache.org/jira/browse/CAMEL-1679&quot; title=&quot;InProgress repository&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CAMEL-1679&quot;&gt;&lt;del&gt;CAMEL-1679&lt;/del&gt;&lt;/a&gt; provides a more generic solution for this and similar requirements.&lt;/p&gt;

&lt;p&gt;I just want to note that your approach with the &lt;tt&gt;remove&lt;/tt&gt; method might result in loss of the message if processing the message fails after executing &lt;tt&gt;add&lt;/tt&gt; &lt;br/&gt;
and removing the key from the repository with &lt;tt&gt;remove&lt;/tt&gt; also fails. Especially when using a DB based Repository this might happen when loosing the network&lt;br/&gt;
connection when processing the message.&lt;/p&gt;

&lt;p&gt;For completeness here is the IdempotentRepository Interface as I was experimenting with:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; IdempotentRepository&amp;lt;E&amp;gt; {
    /**
     * Reserves a given key in the repository.
     * &amp;lt;ul&amp;gt;
     * &amp;lt;li&amp;gt;If the key is neither reserved nor confirmed then the key will be reserved and an &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; will be returned which serves as handle &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; either confirming or
     * releasing the key lateron.&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;If the key is already confirmed then &amp;lt;code&amp;gt;&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;&amp;lt;/code&amp;gt; will be returned immediately.&amp;lt;/li&amp;gt;
     * &amp;lt;li&amp;gt;If the key is reserved then the method will block until
     *   &amp;lt;ul&amp;gt;
     *     &amp;lt;li&amp;gt;the key is confirmed by the actor which reserved the key&amp;lt;/li&amp;gt;
     *     &amp;lt;li&amp;gt;the key is released by the actor which reserved the key&amp;lt;/li&amp;gt;
     *     &amp;lt;li&amp;gt;the reservation of the original actor timed out&amp;lt;/li&amp;gt;
     *   &amp;lt;/ul&amp;gt;
     *   In all cases the method will then &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; to reserve the key and react as indicated above.&amp;lt;/li&amp;gt;
     * &amp;lt;/ul&amp;gt;
     * On completion of the method it is guaranteed that
     * &amp;lt;ul&amp;gt;
     *   &amp;lt;li&amp;gt;the key was successfully reserved, indicated by a returned lock handle object, or&amp;lt;/li&amp;gt;
     *   &amp;lt;li&amp;gt;the key was already confirmed, indicated by returning &amp;lt;code&amp;gt;&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;&amp;lt;/code&amp;gt;&amp;lt;/li&amp;gt;
     * &amp;lt;/ul&amp;gt;     
     * 
     * @param key The key which should be reserved in the repository.
     * @param timeOut Indicates how &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; the key is locked before the lock might be broken by another actor requesting to reserve the same key. This is
     * a minimum time and the lock might still be valid even after the timeout.
     * @&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; a lock handle object in &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; of successful reservation; &amp;lt;code&amp;gt;&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;&amp;lt;/code&amp;gt; is the key was already confirmed beforehand
     */
    Serializable reserveKey(E key, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; timeOut);

    
    /**
     * Releases the key in the repository which is represented by the given lock handle object.
     * The key is then available again &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; reservation by &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; or another actor.
     * If the lock handle object is unknown (which might also be caused by a timed out lock or the lock already being released or confirmed)
     * no action is taken.
     * @param lockHandle the lock handle object which was returned when reserving the key via the {@link #reserveKey(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;,&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;)} method.
     */
    void releaseKey(Serializable lockHandle);

    /**
     * Confirms the key in the repository which is represented by the given lock handle object.
     * @param lockHandle the lock handle object which was returned when reserving the key via the {@link #reserveKey(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;,&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt;)} method.
     * @&lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; CamelException  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the lock handle object is unknown (which might also be caused by a timed out lock or the lock already
     * being released or confirmed) 
     */
    void confirmKey(Serializable lockHandle) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; CamelException;
    
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If I don&apos;t get any other message from you I will stop working on this for now.&lt;/p&gt;</comment>
                            <comment id="12952480" author="davsclaus" created="Sun, 7 Jun 2009 11:23:29 +0000"  >&lt;p&gt;trunk: 782371.&lt;/p&gt;

&lt;p&gt;Oliver we now eagerly adds to repository to be able to detect duplications of in progress exchanges.&lt;/p&gt;

&lt;p&gt;Camel also provides a jpa based repository you can use. Check out camel-jpa and some of the unit tests there.&lt;/p&gt;
</comment>
                            <comment id="12952479" author="davsclaus" created="Sun, 7 Jun 2009 18:38:41 +0000"  >&lt;p&gt;Oliver&lt;/p&gt;

&lt;p&gt;Sorry I did not see you comments before I marked this as fixed. I had prepared by pressing fixed, and was running one last final test and waiting for the SVN rev. no.&lt;/p&gt;

&lt;p&gt;You have a good idea about the confirm key. So I have created a ticket for this issue. See the sub ticket.&lt;br/&gt;
I do think that adding the confirm to the SPI interface you will be able to implement your timeout feature.&lt;/p&gt;

&lt;p&gt;But lets take that discussion at the sub ticket.&lt;/p&gt;</comment>
                            <comment id="12952487" author="davsclaus" created="Mon, 8 Jun 2009 05:51:19 +0000"  >&lt;p&gt;I add the confirm key to the repo interface. This allows you to be able to impl. your timeout version.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
MyRepo repo = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MyRepo();
repo.setTimeout(20000);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And then use MyRepo with the idempotent consumer EIP.&lt;/p&gt;

&lt;p&gt;Camel will eagerly add and then when the exchange is done call the confirm.&lt;br/&gt;
In case of failure it will call the remove instead.&lt;/p&gt;

&lt;p&gt;I also added an &lt;tt&gt;eager&lt;/tt&gt; option so you can turn it on/off. Its enabled by default.&lt;br/&gt;
If disabled then Camel will add when the exchange is complete.&lt;/p&gt;

&lt;p&gt;trunk: 782534.&lt;/p&gt;</comment>
                            <comment id="12953737" author="davsclaus" created="Sat, 21 Nov 2009 11:58:02 +0000"  >&lt;p&gt;Closing all 2.0M2 tickets&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                                                <inwardlinks description="is depended upon by">
                                        <issuelink>
            <issuekey id="12484684">CAMEL-1679</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12486453">CAMEL-1680</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12462965" name="IdempotentConsumerTest.java" size="6260" author="ohecker" created="Wed, 27 May 2009 12:40:22 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 27 May 2009 13:23:50 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>76783</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 2 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i01jpz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6964</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>