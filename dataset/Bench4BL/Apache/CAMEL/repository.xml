<?xml version = "1.0" encoding = "UTF-8" ?>
<bugrepository name="CAMEL">
	<bug id="72" opendate="2007-07-08 10:33:06" fixdate="2007-07-09 09:00:19" resolution="Fixed">
		<buginformation>
			<summary>FileConfigureTest can&amp;apos;t pass in Windows box</summary>
			<description>Because of the File.separator is different between the unix and windows system. 
So the test can&amp;amp;apos;t pass in windows box.
I just attached a patch for it.  
Please have a look at it, I tested it in windows box.</description>
			<version>1.1.0</version>
			<fixedVersion>1.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileConfigureTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="81" opendate="2007-07-27 14:31:38" fixdate="2007-07-30 16:49:10" resolution="Fixed">
		<buginformation>
			<summary>Stop logic a bit off in ServiceSupport.java</summary>
			<description>With the current logic, during stop the service is both started and stopped.</description>
			<version>1.1.0</version>
			<fixedVersion>1.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.ServiceSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="85" opendate="2007-08-03 04:26:19" fixdate="2007-08-03 20:18:56" resolution="Fixed">
		<buginformation>
			<summary>VM Component should extend Seda not Queue</summary>
			<description>It appears that the deprecation of the Queue component means the VM component incorrectly complains that it is deprecated.</description>
			<version>1.1.0</version>
			<fixedVersion>1.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.vm.VmComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="105" opendate="2007-08-14 21:27:14" fixdate="2007-08-14 21:43:05" resolution="Fixed">
		<buginformation>
			<summary>FileProducer truncates message bodies &gt; 256KB</summary>
			<description>Thanks to NIO&amp;amp;apos;s awesomely intuitive behavior, the FileProducer is only writing out the first &amp;amp; last buffers it reads.  Apparently ByteBuffer needs to be cleared after each FileChannel write?</description>
			<version>1.1.0</version>
			<fixedVersion>1.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileProducer.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="depends upon">95</link>
		</links>
	</bug>
	<bug id="103" opendate="2007-08-14 18:22:55" fixdate="2007-08-17 04:42:11" resolution="Fixed">
		<buginformation>
			<summary>ClassCastException when using GenericApplicationContext</summary>
			<description>
Caused by: java.lang.ClassCastException:
org.springframework.context.support.GenericApplicationContext
           at
org.apache.camel.spring.SpringCamelContext.createInjector(SpringCamelCon
text.java:147)
           at
org.apache.camel.impl.DefaultCamelContext.getInjector(DefaultCamelContex
t.java:322)
           at
org.apache.camel.impl.DefaultCamelContext.forceLazyInitialization(Defaul
tCamelContext.java:407)
           at
org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.ja
va:373)
           at
org.apache.camel.spring.SpringCamelContext.doStart(SpringCamelContext.ja
va:139)
           at
org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:38)
           at
org.apache.camel.spring.CamelContextFactoryBean.onApplicationEvent(Camel
ContextFactoryBean.java:103)
           ... 20 more
</description>
			<version>1.1.0</version>
			<fixedVersion>1.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBeanTest.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.spring.spi.SpringInjector.java</file>
			<file type="M">org.apache.camel.spring.SpringCamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="112" opendate="2007-08-17 16:05:54" fixdate="2007-08-17 16:13:12" resolution="Fixed">
		<buginformation>
			<summary>JMSXGroupID is not copied across ActiveMQ endpoints</summary>
			<description>See thread: http://www.nabble.com/MethodName-in-header-is-ignored-by-beanRef%28%29-tf4285009s22882.html#a12198390</description>
			<version>1.1.0</version>
			<fixedVersion>1.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsMessage.java</file>
			<file type="M">org.apache.camel.component.activemq.ActiveMQReplyToHeaderUsingConverterTest.java</file>
			<file type="M">org.apache.camel.component.jms.EndpointMessageListener.java</file>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="154" opendate="2007-09-24 14:31:44" fixdate="2007-09-25 15:52:50" resolution="Fixed">
		<buginformation>
			<summary>Improper wiring of camel context using Spring</summary>
			<description>When using spring to wire camel components, the whole magic is driven by org.springframework.context.support.AbstractApplicationContext.refresh().
At about line 327 the xml file is read and at some point AbstractApplicationContext.doParse is called.  What is notable is that we use parseUsingJaxb (line 135) instead of the spring way of doing things, and then we still use 
BeanDefinitionParser(s) to build the BeanDefinition(s).
On a sample context definition like the one in the unit tests:
  &amp;lt;camelContext id="camel" xmlns="http://activemq.apache.org/camel/schema/spring"&amp;gt;
    &amp;lt;beanPostProcessor/&amp;gt;
    &amp;lt;endpoint id="endpoint1" uri="direct:start"/&amp;gt;
    &amp;lt;endpoint id="endpoint2" uri="mock:end"/&amp;gt;
    &amp;lt;route&amp;gt;
      &amp;lt;from ref="endpoint1"/&amp;gt;
      &amp;lt;to ref="endpoint2"/&amp;gt;
    &amp;lt;/route&amp;gt;
  &amp;lt;/camelContext&amp;gt;
The jaxb parser instantiates the BeanPostProcessor, endpoints, the RouteType, From/ToTypes properly, but the BeanPostProcessor is not injected with the camelContext and applicationContext, obviously.
Later on in AbstractApplicationContext.refresh() during the registerBeanPostProcessors() call (line 337) spring figures out that it needs to instantiate the BeanPostProcessor first and use it before it initializes the other beans.  So far so good, but in doing so there are 2 major problems.
1. It uses the BeanDefinition instead of the instance already created during jaxb parsing.
2. There is a chicken and egg situation; while it initializes "camel:beanPostProcessor", it looks for a "camel" bean which isn&amp;amp;apos;t registered yet.  The model for it does exist though, so a new instance of the CamelContextFactoryBean gets instantiated (and the id now is null instead of "camel" as in the spring xml).
I wrestled with this and couldn&amp;amp;apos;t figure out a solution.</description>
			<version>1.2.0</version>
			<fixedVersion>1.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.CamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.management.InstrumentationLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.spring.managment.JmxInstrumentationWithConnectorTest.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.management.JmxInstrumentationUsingDefaultsTest.java</file>
			<file type="M">org.apache.camel.component.stringtemplate.StringTemplateTest.java</file>
			<file type="M">org.apache.camel.management.CamelNamingStrategy.java</file>
			<file type="M">org.apache.camel.management.ManagedService.java</file>
			<file type="M">org.apache.camel.spring.handler.CamelNamespaceHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="158" opendate="2007-09-26 17:06:45" fixdate="2007-09-26 17:07:54" resolution="Fixed">
		<buginformation>
			<summary>jetty endpoint consumer does not send exchange output as the HTTP response</summary>
			<description></description>
			<version>1.1.0</version>
			<fixedVersion>1.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.jetty.CamelContinuationServlet.java</file>
			<file type="M">org.apache.camel.component.jetty.HttpRouteTest.java</file>
			<file type="M">org.apache.camel.component.http.HttpBinding.java</file>
			<file type="M">org.apache.camel.component.http.CamelServlet.java</file>
		</fixedFiles>
	</bug>
	<bug id="161" opendate="2007-09-28 04:04:46" fixdate="2007-10-01 15:17:52" resolution="Fixed">
		<buginformation>
			<summary>URL link broken in org.apache.camel.Processor API doc</summary>
			<description>"Message Transformer" link is broken.</description>
			<version>1.1.0</version>
			<fixedVersion>1.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.Processor.java</file>
		</fixedFiles>
	</bug>
	<bug id="140" opendate="2007-09-10 14:17:19" fixdate="2007-10-01 16:15:11" resolution="Fixed">
		<buginformation>
			<summary>XsltBuilder instance not threadsafe and can&amp;apos;t be used more then once.</summary>
			<description>XsltBuilder uses a ResultHandler instance variable to hold the result of the transformation. That makes it thread unsafe and at the same time, as it&amp;amp;apos;s never cleared/reset, it can&amp;amp;apos;t be used more then once.</description>
			<version>1.1.0</version>
			<fixedVersion>1.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.xml.XsltBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="166" opendate="2007-10-09 05:24:42" fixdate="2007-10-10 17:40:18" resolution="Fixed">
		<buginformation>
			<summary>org.apache.camel.processor.UnitOfWorkWithAsyncFlowTest failure</summary>
			<description>Running org.apache.camel.processor.UnitOfWorkWithAsyncFlowTest
Tests run: 3, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 20.345 sec &amp;lt;&amp;lt;&amp;lt; FAILURE!
This prevents developer from building camel under Linux platform. Thanks!</description>
			<version>1.1.0</version>
			<fixedVersion>1.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.UnitOfWorkTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="191" opendate="2007-10-25 19:26:22" fixdate="2007-10-26 11:53:42" resolution="Fixed">
		<buginformation>
			<summary>Catch clause with pipeline does not proceed</summary>
			<description>Catch clause with pipeline does not proceed. This is because the pipeline is designed to reject exceptions. The catch processor should give the exchange a fresh start
This started from thread http://www.nabble.com/Camel-1.2---CatchProcessor-not-working--t4690438s22882.html</description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.TryProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="197" opendate="2007-10-31 14:50:18" fixdate="2007-11-05 15:02:26" resolution="Fixed">
		<buginformation>
			<summary>Processor invocation order</summary>
			<description>Please see attached patch to reproduce.
I made a small change to an existing unit test and created a route like this:
from("direct:a").intercept(interceptor1).process(orderProcessor).intercept(interceptor2).to("direct:d"); 
I think one would expect to have one route and the invocation order to be interceptor1 -&amp;gt; orderProcessor -&amp;gt; interceptor2 -&amp;gt; direct:d.
Instead we have:
1. two routes
1. interceptor1 and interceptor2 are invoked twice
2. orderProcessor is never invoked
3. direct:d is invoked twice, i think.
</description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ToType.java</file>
			<file type="M">org.apache.camel.model.InterceptType.java</file>
			<file type="M">org.apache.camel.model.ResequencerType.java</file>
			<file type="M">org.apache.camel.model.ChoiceType.java</file>
			<file type="M">org.apache.camel.model.RoutesType.java</file>
			<file type="M">org.apache.camel.model.OutputType.java</file>
			<file type="M">org.apache.camel.model.ThreadType.java</file>
			<file type="M">org.apache.camel.model.ExceptionType.java</file>
			<file type="M">org.apache.camel.model.ThrottlerType.java</file>
			<file type="M">org.apache.camel.impl.RouteContext.java</file>
			<file type="M">org.apache.camel.builder.InterceptorBuilderTest.java</file>
			<file type="M">org.apache.camel.model.CatchType.java</file>
			<file type="M">org.apache.camel.model.XmlParseTest.java</file>
			<file type="M">org.apache.camel.model.InterceptorType.java</file>
			<file type="M">org.apache.camel.model.ExpressionNode.java</file>
			<file type="M">org.apache.camel.model.RouteType.java</file>
			<file type="M">org.apache.camel.spring.xml.SpringXmlRouteBuilderTest.java</file>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
			<file type="M">org.apache.camel.model.ProceedType.java</file>
			<file type="M">org.apache.camel.model.InterceptorRef.java</file>
		</fixedFiles>
	</bug>
	<bug id="210" opendate="2007-11-06 11:46:53" fixdate="2007-11-14 12:16:01" resolution="Fixed">
		<buginformation>
			<summary>exception clause doesn&amp;apos;t proceed with pipeline</summary>
			<description>Problem is very similar to CAMEL-191 but this time with exception clause.
As exceptions are not cleared pipeline doesn&amp;amp;apos;t proceed.</description>
			<version>1.3.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.issues.ExceptionTest.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannel.java</file>
		</fixedFiles>
	</bug>
	<bug id="211" opendate="2007-11-08 12:37:45" fixdate="2007-11-14 12:19:12" resolution="Fixed">
		<buginformation>
			<summary>httpClientConfigurer component settings doesn&amp;apos;t work</summary>
			<description>httpClientConfigurer property is not propagated to the endpoint on endpoint creation.</description>
			<version>1.3.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.HttpEndpoint.java</file>
			<file type="M">org.apache.camel.component.http.HttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="194" opendate="2007-10-30 15:33:01" fixdate="2007-11-14 12:53:02" resolution="Fixed">
		<buginformation>
			<summary>Converters are not found properly</summary>
			<description>There is default converter from dom.Document -&amp;gt; xml.transform.DOMSource
Unfortunately when you try to send DOM document (implementation) and convert it to Source there is no converter found, because Document cannot be assigned to implementation without a cast.</description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.converter.DefaultTypeConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="189" opendate="2007-10-19 22:38:20" fixdate="2007-11-14 13:14:43" resolution="Fixed">
		<buginformation>
			<summary>System.out in source code - FtpProducer</summary>
			<description>I was browsing the source for the FTP component to see how the inner works.
I discovered a System.out statement in the class FtpProducer:
            System.out.println(sb.toString() + " = " + success);</description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="203" opendate="2007-11-05 11:32:17" fixdate="2007-11-16 17:55:07" resolution="Fixed">
		<buginformation>
			<summary>FileComponent sometimes creates file instead of directory</summary>
			<description>When using the FileComponent ("file://") to publish to a non-existent directory tree, the last part of the path is created as file instead of directory. It only happens when setting the filename in the header (FileComponent.HEADER_FILE_NAME).
This is because the method that determines the file name (which checks whether a directory exists), is called before the directory tree is built.
See also http://www.nabble.com/Problem-with-concurrent-dir-file-access--tf4724448s22882.html</description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="224" opendate="2007-11-16 08:33:43" fixdate="2007-11-16 18:01:12" resolution="Fixed">
		<buginformation>
			<summary>Headers lost after XSLT processing</summary>
			<description>After xslt processing the message headers are lost. See attached unit test, this test fails since revision 590680.
http://svn.apache.org/viewvc?view=rev&amp;amp;revision=590680</description>
			<version>1.3.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.xml.XsltBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="232" opendate="2007-11-18 15:42:14" fixdate="2007-11-19 11:43:27" resolution="Fixed">
		<buginformation>
			<summary>Fix performance counters</summary>
			<description></description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.management.InstrumentationLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.model.FromType.java</file>
			<file type="M">org.apache.camel.model.ResequencerType.java</file>
			<file type="M">org.apache.camel.model.RoutesType.java</file>
			<file type="M">org.apache.camel.spi.LifecycleStrategy.java</file>
			<file type="M">org.apache.camel.Route.java</file>
			<file type="M">org.apache.camel.management.JmxInstrumentationUsingDefaultsTest.java</file>
			<file type="M">org.apache.camel.impl.RouteContext.java</file>
			<file type="M">org.apache.camel.management.ManagedRoute.java</file>
			<file type="M">org.apache.camel.management.CamelNamingStrategy.java</file>
			<file type="M">org.apache.camel.impl.DefaultLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.model.RouteType.java</file>
			<file type="M">org.apache.camel.management.ManagedEndpoint.java</file>
			<file type="M">org.apache.camel.osgi.OsgiComponentResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="247" opendate="2007-11-29 09:09:11" fixdate="2007-11-29 17:38:33" resolution="Fixed">
		<buginformation>
			<summary>some issues with camel-cxf component</summary>
			<description>1. input params List shouldn&amp;amp;apos;t be null, at lease it should be a empty List,
so use
List&amp;lt;Object&amp;gt; params = new ArrayList&amp;lt;Object&amp;gt;();
instead of 
List&amp;lt;Object&amp;gt; params = null;
in CamelInvoker.java
to avoid input params is null
2. Cxf Producer should only copy back exchange when ExchangePattern is not InOnly
so  use
if (exchange.getPattern() != ExchangePattern.InOnly) {
        	exchange.copyFrom(cxfExchange);
}
instead of 
    exchange.copyFrom(cxfExchange);</description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.HelloServiceImpl.java</file>
			<file type="M">org.apache.camel.component.cxf.HelloService.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfRouterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducer.java</file>
			<file type="M">org.apache.camel.component.cxf.CamelInvoker.java</file>
			<file type="M">org.apache.camel.component.cxf.CXFGreeterRouterTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="261" opendate="2007-12-14 05:52:32" fixdate="2007-12-18 04:26:29" resolution="Fixed">
		<buginformation>
			<summary>patch to fix some issue about camel-cxf component</summary>
			<description>this patch 
1.
@override
    protected boolean useIntrospectionOnEndpoint() 
{
        return false;
    }
to let parameter start with "soap." passed in soap endpoint
2. use
WSDLServiceFactory factory = new WSDLServiceFactory(getBus(), getWsdlURL(), getServiceQName());
instead of
WSDLServiceFactory factory = new WSDLServiceFactory(getBus(), getWsdlURL(), null);
so that can pass in servicename to WSDLServiceFactory, in case that more than one service in the wsdl, we can specify the one we want
3. add wait response into CxfProducer, so that if the MEP is not oneway, we can waiting for the response in certain period
4. add more type convert for CxfSoapBinding and CxfBinding, so that we can handle message body more than InputStream .</description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.util.WSDLSoapServiceFactoryBean.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSoapBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfExchange.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducer.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSoapComponent.java</file>
			<file type="M">org.apache.camel.component.cxf.invoker.CxfClient.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSoapProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="271" opendate="2007-12-19 18:36:15" fixdate="2007-12-21 19:06:24" resolution="Fixed">
		<buginformation>
			<summary>CxfEndpointBeanDefinitionParser throws a ClassCastException when definining inner list elements in spring configuration</summary>
			<description>In the CxfEndpointBeanDefinitionParser, the list elements being read are cast to com.sun.xml.bind.v2.schemagen.xmlschema.List class which is never true...
Why don&amp;amp;apos;t we just leave it as a object or atleast cast it to a java.util.List?
For getting the error just add the following configuration to a cxf endpoint:
  &amp;lt;cxf:cxfEndpoint id="toEndpoint1" 
                   address="http://localhost:9091/GreeterContext/GreeterPort" 
                   serviceClass="demo.router.Greeter"&amp;gt;
      &amp;lt;cxf:features&amp;gt;
          &amp;lt;cxfcore:logging/&amp;gt;
      &amp;lt;/cxf:features&amp;gt;
  &amp;lt;/cxf:cxfEndpoint&amp;gt;
cxfcore points to the "http://cxf.apache.org/core" namespace.
I have attached a patch for this problem &amp;amp; would appreciate if someone applied it.
Thanks
Balaji
</description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="304" opendate="2008-01-22 00:39:44" fixdate="2008-01-22 00:48:16" resolution="Fixed">
		<buginformation>
			<summary>Multithreaded HTTP invocations doesn&amp;apos;t work</summary>
			<description>Description of the bug:
http://www.nabble.com/Multithreaded-http-endpoint-to13646722s22882.html#a13646722</description>
			<version>1.3.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyHttpEndpoint.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.http.HttpEndpoint.java</file>
			<file type="M">org.apache.camel.component.http.HttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="297" opendate="2008-01-18 13:25:04" fixdate="2008-01-24 11:34:45" resolution="Fixed">
		<buginformation>
			<summary>tryCatch() doesn&amp;apos;t propagate results from handle() section</summary>
			<description>in following flow

from("direct:a")
.setBody(constant("body"))
.tryBlock()
.process(new ExceptionThrower())
.handle(Exception.class)
.setBody(constant("exception"));


the result of such invocation is "body" instead of "exception".</description>
			<version>1.3.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.TryProcessor.java</file>
			<file type="M">org.apache.camel.processor.ValidationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="320" opendate="2008-02-05 13:10:17" fixdate="2008-02-06 20:56:00" resolution="Fixed">
		<buginformation>
			<summary>DefaultParameterMappingStrategy doesn&amp;apos;t load its defaults</summary>
			<description>This is preventing BeanProcessor from using bean methods with a Message parameter, or bean methods not named "process" that have an Exchange as their parameter.  For example, to map to a Message the it tries using the ParameterExpression bodyAs(Message.class) instead of inmessageExpression().</description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.DefaultParameterMappingStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="329" opendate="2008-02-12 13:34:31" fixdate="2008-02-26 02:17:59" resolution="Fixed">
		<buginformation>
			<summary>Throwing the  IllegalArgumentException if there are already another type bean which name is same with the URI schema</summary>
			<description>
Please see the discussion below
http://www.nabble.com/%22cxf%22-name-conflict-in-the-spring-context-td15427019s22882.html</description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CamelInvoker.java</file>
			<file type="M">org.apache.camel.impl.DefaultComponentResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="324" opendate="2008-02-10 10:30:07" fixdate="2008-02-28 03:52:42" resolution="Fixed">
		<buginformation>
			<summary>bad content length header value in http response</summary>
			<description>By default HttpBinding class copies all request header attributes from the request to the response including &amp;amp;apos;Content-Length&amp;amp;apos;. So the consequence is that the response is declaring the same size as the request which can lead to serious truncation problems! 
the workaround is simply to add the line:
out.removeHeader("Content-Length"); 
in the writeResponse method of the httpbinding class allowing jetty to set the right value.  </description>
			<version>1.3.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.ErrorHandlerTest.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpProducer.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.http.HttpBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="340" opendate="2008-02-17 16:54:37" fixdate="2008-02-28 08:49:43" resolution="Fixed">
		<buginformation>
			<summary>Mina TCP does not support InOut pattern</summary>
			<description>See this thread:
http://www.nabble.com/camel-mina-TCP-InOut-exchange-td15530602s22882.html
This builder does not support InOut when a client send a textline to localhost:8888.
The client never receives a response.
url = "mina:tcp://localhost:8888?textline=true";
from(uri).process(new Processor() {
                    public void process(Exchange e) 
{
                        String in = e.getIn().getBody(String.class);
                        // append newline at end to denote end of data for textline codec
                        e.getOut().setBody("Hello " + in + "\n");
                    }
                });
Attached is a patch that fixes this by introducing a new parameter to the URL for fluent builder sync=true (ie is there a better name?)
Using this url instead and the patch then Camel will send a response back to the client:
mina:tcp://localhost:8888?textline=true&amp;amp;sync=true
</description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina.MinaConsumer.java</file>
			<file type="M">org.apache.camel.component.mina.MinaComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="352" opendate="2008-03-03 14:13:07" fixdate="2008-03-03 14:36:07" resolution="Fixed">
		<buginformation>
			<summary>Aggregrator Batch Processor can sometimes ignore batchExpiry timeout that result in a hang/delay in processing, with jms</summary>
			<description>The Batch processor behind the Aggregrator has a batch expiry timeout that governs the delivery of messages.  If the timeout expires during aggregration the resulting timeout value passed to PollingConsumer.receive will be negative. In the jms consumer case with the spring templates, a negative timeout != -1 is considered infinite/blocking.</description>
			<version>1.3.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.AggregatorTest.java</file>
			<file type="M">org.apache.camel.processor.BatchProcessor.java</file>
			<file type="M">org.apache.camel.processor.aggregate.AggregationCollection.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="is depended upon by">341</link>
		</links>
	</bug>
	<bug id="370" opendate="2008-03-06 23:09:39" fixdate="2008-03-07 02:30:31" resolution="Fixed">
		<buginformation>
			<summary>SftpConsumer is not connecting and retrieving remote files</summary>
			<description>SftpConsumer does not connect to server due to patch for CAMEL-251.  The SftpConsumer also checks remote file modification timestamp against last poll timestamp but incorrectly converts seconds to milliseconds using integer math so the resulting conversion is always negative and will never retrieve file.  I will attach the fixes to this issue.</description>
			<version>1.3.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.SftpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpProducer.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="373" opendate="2008-03-07 15:09:32" fixdate="2008-03-07 20:50:18" resolution="Fixed">
		<buginformation>
			<summary>xquery does not work from xml if query contains functions</summary>
			<description>Give something like this:
[                          main] DeadLetterChannel              ERROR Failed delivery for exchangeId: ID-xxxxx/63907-1204902526306/0-1. On delivery attempt: 0 caught: org.apache.camel.RuntimeExpressionException: net.sf.saxon.trans.DynamicError: org.w3c.dom.DOMException: HIERARCHY_REQUEST_ERR: An attempt was made to insert a node where it is not permitted. 
org.apache.camel.RuntimeExpressionException: net.sf.saxon.trans.DynamicError: org.w3c.dom.DOMException: HIERARCHY_REQUEST_ERR: An attempt was made to insert a node where it is not permitted. 
	at org.apache.camel.component.xquery.XQueryBuilder.evaluate(XQueryBuilder.java:124)
</description>
			<version>1.3.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.language.XQueryExpression.java</file>
		</fixedFiles>
	</bug>
	<bug id="257" opendate="2007-12-05 02:28:31" fixdate="2008-03-09 10:20:26" resolution="Fixed">
		<buginformation>
			<summary>Build error from org.apache.camel.component.mina.MinaUdpTest</summary>
			<description>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running org.apache.camel.component.mina.MinaUdpTest
1578 [AnonymousIoService-1] WARN org.apache.camel.component.mina.MinaConsumer$1 - [/127.0.0.1:32858] EXCEPTION, please implement org.apache.camel.component.mina.MinaConsumer$1.exceptionCaught() for proper handling:
java.lang.IllegalStateException: Already released buffer.  You released the buffer too many times.
        at org.apache.mina.common.PooledByteBufferAllocator$PooledByteBuffer.release(PooledByteBufferAllocator.java:310)
        at org.apache.mina.util.ByteBufferUtil.releaseIfPossible(ByteBufferUtil.java:39)
        at org.apache.mina.common.support.AbstractIoFilterChain$TailFilter.messageReceived(AbstractIoFilterChain.java:572)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:299)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1100(AbstractIoFilterChain.java:53)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:648)
        at org.apache.mina.filter.codec.support.SimpleProtocolDecoderOutput.flush(SimpleProtocolDecoderOutput.java:58)
        at org.apache.mina.filter.codec.ProtocolCodecFilter.messageReceived(ProtocolCodecFilter.java:173)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:299)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1100(AbstractIoFilterChain.java:53)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:648)
        at org.apache.mina.filter.executor.ExecutorFilter.processEvent(ExecutorFilter.java:220)
        at org.apache.mina.filter.executor.ExecutorFilter$ProcessEventsRunnable.run(ExecutorFilter.java:264)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675)
        at org.apache.mina.util.NamePreservingRunnable.run(NamePreservingRunnable.java:51)
        at java.lang.Thread.run(Thread.java:595)
2143 [AnonymousIoService-2] WARN org.apache.camel.component.mina.MinaConsumer$1 - [/127.0.0.1:32858] EXCEPTION, please implement org.apache.camel.component.mina.MinaConsumer$1.exceptionCaught() for proper handling:
java.lang.IllegalStateException: Already released buffer.  You released the buffer too many times.
        at org.apache.mina.common.PooledByteBufferAllocator$PooledByteBuffer.release(PooledByteBufferAllocator.java:310)
        at org.apache.mina.util.ByteBufferUtil.releaseIfPossible(ByteBufferUtil.java:39)
        at org.apache.mina.common.support.AbstractIoFilterChain$TailFilter.messageReceived(AbstractIoFilterChain.java:572)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:299)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1100(AbstractIoFilterChain.java:53)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:648)
        at org.apache.mina.filter.codec.support.SimpleProtocolDecoderOutput.flush(SimpleProtocolDecoderOutput.java:58)
        at org.apache.mina.filter.codec.ProtocolCodecFilter.messageReceived(ProtocolCodecFilter.java:173)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:299)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1100(AbstractIoFilterChain.java:53)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:648)
        at org.apache.mina.filter.executor.ExecutorFilter.processEvent(ExecutorFilter.java:220)
        at org.apache.mina.filter.executor.ExecutorFilter$ProcessEventsRunnable.run(ExecutorFilter.java:264)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675)
        at org.apache.mina.util.NamePreservingRunnable.run(NamePreservingRunnable.java:51)
        at java.lang.Thread.run(Thread.java:595)
3151 [AnonymousIoService-3] WARN org.apache.camel.component.mina.MinaConsumer$1 - [/127.0.0.1:32858] EXCEPTION, please implement org.apache.camel.component.mina.MinaConsumer$1.exceptionCaught() for proper handling:
java.lang.IllegalStateException: Already released buffer.  You released the buffer too many times.
        at org.apache.mina.common.PooledByteBufferAllocator$PooledByteBuffer.release(PooledByteBufferAllocator.java:310)
        at org.apache.mina.util.ByteBufferUtil.releaseIfPossible(ByteBufferUtil.java:39)
        at org.apache.mina.common.support.AbstractIoFilterChain$TailFilter.messageReceived(AbstractIoFilterChain.java:572)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:299)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1100(AbstractIoFilterChain.java:53)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:648)
        at org.apache.mina.filter.codec.support.SimpleProtocolDecoderOutput.flush(SimpleProtocolDecoderOutput.java:58)
        at org.apache.mina.filter.codec.ProtocolCodecFilter.messageReceived(ProtocolCodecFilter.java:173)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:299)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1100(AbstractIoFilterChain.java:53)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:648)
        at org.apache.mina.filter.executor.ExecutorFilter.processEvent(ExecutorFilter.java:220)
        at org.apache.mina.filter.executor.ExecutorFilter$ProcessEventsRunnable.run(ExecutorFilter.java:264)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675)
        at org.apache.mina.util.NamePreservingRunnable.run(NamePreservingRunnable.java:51)
        at java.lang.Thread.run(Thread.java:595)
Sent 3 messages
Dec 5, 2007 10:28:57 AM org.apache.camel.component.mock.MockEndpoint assertIsSatisfied
INFO: Asserting: Endpoint[mock:result] is satisfied
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 4.442 sec
Running org.apache.camel.component.mina.MinaFileUdpTest
Dec 5, 2007 10:28:58 AM org.apache.camel.component.mock.MockEndpoint assertIsSatisfied
INFO: Asserting: Endpoint[mock:results] is satisfied
1600 [AnonymousIoService-3] WARN org.apache.camel.component.mina.MinaConsumer$1 - [/127.0.0.1:32858] EXCEPTION, please implement org.apache.camel.component.mina.MinaConsumer$1.exceptionCaught() for proper handling:
java.lang.IllegalStateException: Already released buffer.  You released the buffer too many times.
        at org.apache.mina.common.PooledByteBufferAllocator$PooledByteBuffer.release(PooledByteBufferAllocator.java:310)
        at org.apache.mina.util.ByteBufferUtil.releaseIfPossible(ByteBufferUtil.java:39)
        at org.apache.mina.common.support.AbstractIoFilterChain$TailFilter.messageReceived(AbstractIoFilterChain.java:572)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:299)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1100(AbstractIoFilterChain.java:53)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:648)
        at org.apache.mina.filter.codec.support.SimpleProtocolDecoderOutput.flush(SimpleProtocolDecoderOutput.java:58)
        at org.apache.mina.filter.codec.ProtocolCodecFilter.messageReceived(ProtocolCodecFilter.java:173)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:299)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1100(AbstractIoFilterChain.java:53)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:648)
        at org.apache.mina.filter.executor.ExecutorFilter.processEvent(ExecutorFilter.java:220)
        at org.apache.mina.filter.executor.ExecutorFilter$ProcessEventsRunnable.run(ExecutorFilter.java:264)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675)
        at org.apache.mina.util.NamePreservingRunnable.run(NamePreservingRunnable.java:51)
        at java.lang.Thread.run(Thread.java:595)
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.842 sec
Running org.apache.camel.component.mina.MinaUdpUsingTemplateTest
495 [AnonymousIoService-4] WARN org.apache.camel.component.mina.MinaConsumer$1 - [/127.0.0.1:32858] EXCEPTION, please implement org.apache.camel.component.mina.MinaConsumer$1.exceptionCaught() for proper handling:
java.lang.IllegalStateException: Already released buffer.  You released the buffer too many times.
        at org.apache.mina.common.PooledByteBufferAllocator$PooledByteBuffer.release(PooledByteBufferAllocator.java:310)
        at org.apache.mina.util.ByteBufferUtil.releaseIfPossible(ByteBufferUtil.java:39)
        at org.apache.mina.common.support.AbstractIoFilterChain$TailFilter.messageReceived(AbstractIoFilterChain.java:572)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:299)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1100(AbstractIoFilterChain.java:53)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:648)
        at org.apache.mina.filter.codec.support.SimpleProtocolDecoderOutput.flush(SimpleProtocolDecoderOutput.java:58)
        at org.apache.mina.filter.codec.ProtocolCodecFilter.messageReceived(ProtocolCodecFilter.java:173)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:299)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1100(AbstractIoFilterChain.java:53)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:648)
        at org.apache.mina.filter.executor.ExecutorFilter.processEvent(ExecutorFilter.java:220)
        at org.apache.mina.filter.executor.ExecutorFilter$ProcessEventsRunnable.run(ExecutorFilter.java:264)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675)
        at org.apache.mina.util.NamePreservingRunnable.run(NamePreservingRunnable.java:51)
        at java.lang.Thread.run(Thread.java:595)
497 [AnonymousIoService-4] WARN org.apache.camel.component.mina.MinaConsumer$1 - [/127.0.0.1:32858] EXCEPTION, please implement org.apache.camel.component.mina.MinaConsumer$1.exceptionCaught() for proper handling:
java.lang.IllegalStateException: Already released buffer.  You released the buffer too many times.
        at org.apache.mina.common.PooledByteBufferAllocator$PooledByteBuffer.release(PooledByteBufferAllocator.java:310)
        at org.apache.mina.util.ByteBufferUtil.releaseIfPossible(ByteBufferUtil.java:39)
        at org.apache.mina.common.support.AbstractIoFilterChain$TailFilter.messageReceived(AbstractIoFilterChain.java:572)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:299)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1100(AbstractIoFilterChain.java:53)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:648)
        at org.apache.mina.filter.codec.support.SimpleProtocolDecoderOutput.flush(SimpleProtocolDecoderOutput.java:58)
        at org.apache.mina.filter.codec.ProtocolCodecFilter.messageReceived(ProtocolCodecFilter.java:173)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:299)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1100(AbstractIoFilterChain.java:53)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:648)
        at org.apache.mina.filter.executor.ExecutorFilter.processEvent(ExecutorFilter.java:220)
        at org.apache.mina.filter.executor.ExecutorFilter$ProcessEventsRunnable.run(ExecutorFilter.java:264)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675)
        at org.apache.mina.util.NamePreservingRunnable.run(NamePreservingRunnable.java:51)
        at java.lang.Thread.run(Thread.java:595)
498 [AnonymousIoService-4] WARN org.apache.camel.component.mina.MinaConsumer$1 - [/127.0.0.1:32858] EXCEPTION, please implement org.apache.camel.component.mina.MinaConsumer$1.exceptionCaught() for proper handling:
java.lang.IllegalStateException: Already released buffer.  You released the buffer too many times.
        at org.apache.mina.common.PooledByteBufferAllocator$PooledByteBuffer.release(PooledByteBufferAllocator.java:310)
        at org.apache.mina.util.ByteBufferUtil.releaseIfPossible(ByteBufferUtil.java:39)
        at org.apache.mina.common.support.AbstractIoFilterChain$TailFilter.messageReceived(AbstractIoFilterChain.java:572)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:299)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1100(AbstractIoFilterChain.java:53)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:648)
        at org.apache.mina.filter.codec.support.SimpleProtocolDecoderOutput.flush(SimpleProtocolDecoderOutput.java:58)
        at org.apache.mina.filter.codec.ProtocolCodecFilter.messageReceived(ProtocolCodecFilter.java:173)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:299)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1100(AbstractIoFilterChain.java:53)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:648)
        at org.apache.mina.filter.executor.ExecutorFilter.processEvent(ExecutorFilter.java:220)
        at org.apache.mina.filter.executor.ExecutorFilter$ProcessEventsRunnable.run(ExecutorFilter.java:264)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675)
        at org.apache.mina.util.NamePreservingRunnable.run(NamePreservingRunnable.java:51)
        at java.lang.Thread.run(Thread.java:595)
Dec 5, 2007 10:29:00 AM org.apache.camel.component.mock.MockEndpoint assertIsSatisfied
INFO: Asserting: Endpoint[mock:result] is satisfied</description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina.MinaProducer.java</file>
			<file type="M">org.apache.camel.component.mina.MinaEndpoint.java</file>
			<file type="M">org.apache.camel.component.mina.MinaComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="380" opendate="2008-03-09 12:43:12" fixdate="2008-03-10 02:28:38" resolution="Fixed">
		<buginformation>
			<summary>camel-mina UDP protocol fails when sending bytes</summary>
			<description>Using a CamelProducer to send bytes to a mina UDP listener fails.
This unit tests below fails
Using: "Hello from bytes" as a plain string works fine.

    public void testSendingByteMessages() throws Exception {
        MockEndpoint endpoint = getMockEndpoint("mock:result");
        endpoint.expectedMessageCount(1);

        template.sendBody("mina:udp://127.0.0.1:4445", "Hello from bytes".getBytes());
        // sleeping for while to let the mock endpoint get all the message
        Thread.sleep(1000);

        assertMockEndpointsSatisifed();
        List&amp;lt;Exchange&amp;gt; list = endpoint.getReceivedExchanges();
        assertEquals("Hello from bytes", list.get(0).getIn().getBody(String.class));
    }

</description>
			<version>1.3.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina.MinaUdpUsingTemplateTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaConverterTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaConverter.java</file>
			<file type="M">org.apache.camel.component.mina.MinaUdpTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="363" opendate="2008-03-05 18:10:04" fixdate="2008-03-11 14:34:02" resolution="Fixed">
		<buginformation>
			<summary>camel-cxf component can&amp;apos;t deal with the exception message in MESSAGE dataFormat</summary>
			<description>From: Willem Jiang
To: camel-user@activemq.apache.org
Subject: Re: camel-cxf throwing a fault
Date: Wed, 05 Mar 2008 16:26:41 +0800
Reply-To: camel-user@activemq.apache.org
Hi Marc,
It looks like camel-cxf component&amp;amp;apos;s issue which can&amp;amp;apos;t deal with the 
exception message in MESSAGE dataFormat.
Could you fill a JIRA for it ? I will fix it later this week.
As usual ,you just need throw the exception from the processor , CXF 
will try to marshal it into a soap fault.
Regards,
Willem
Marc Giger wrote:
&amp;gt; Hi,
&amp;gt;
&amp;gt; I&amp;amp;apos;m trying to get the following camel route working where the
&amp;gt; dataformat is MESSAGE.
&amp;gt;
&amp;gt; &amp;lt;from uri="cxf:bean:routerEndpoint?dataFormat=MESSAGE"/&amp;gt;            
&amp;gt; &amp;lt;process ref="decryptProcessor"/&amp;gt;  
&amp;gt; &amp;lt;choice&amp;gt;
&amp;gt;     &amp;lt;when&amp;gt;  
&amp;gt;     	&amp;lt;methodCall bean="endpointSelector" method="matches"/&amp;gt;
&amp;gt; 	    &amp;lt;to uri="cxf:bean:serviceEndpoint?dataFormat=MESSAGE"/&amp;gt;  
&amp;gt;     &amp;lt;/when&amp;gt;
&amp;gt;     &amp;lt;otherwise&amp;gt;  
&amp;gt;     	&amp;lt;to uri="cxf:bean:localEndpoint?dataFormat=MESSAGE"/&amp;gt;   
&amp;gt;     &amp;lt;/otherwise&amp;gt;
&amp;gt; &amp;lt;/choice&amp;gt;  
&amp;gt;
&amp;gt; if the endpointSelector bean returns true the request is redirected to
&amp;gt; a remote webservice.
&amp;gt; otherwise the request is forwarded to a local cxf service (with
&amp;gt; local-transport)
&amp;gt;
&amp;gt; Now, if I invoke the routerEndpoint and somewhere in the pipeline
&amp;gt; happens an exception (in my case in the decryptProcessor), I get the
&amp;gt; following Exception in the outFault chain:
&amp;gt;
&amp;gt; Mar 4, 2008 10:48:35 PM org.apache.cxf.phase.PhaseInterceptorChain
&amp;gt; doIntercept INFO: Interceptor has thrown exception, unwinding now
&amp;gt; org.apache.cxf.interceptor.Fault
&amp;gt;         at
&amp;gt; org.apache.camel.component.cxf.interceptors.RawMessageContentRedirectInterceptor.handleMessage(RawMessageContentRedirectInterceptor.java:43)
&amp;gt; at
&amp;gt; org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:208)
&amp;gt; at
&amp;gt; org.apache.cxf.interceptor.OutgoingChainInterceptor.handleMessage(OutgoingChainInterceptor.java:74)
&amp;gt; at
&amp;gt; org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:208)
&amp;gt; at
&amp;gt; org.apache.cxf.transport.ChainInitiationObserver.onMessage(ChainInitiationObserver.java:77)
&amp;gt; at
&amp;gt; org.apache.cxf.transport.servlet.ServletDestination.doMessage(ServletDestination.java:79)
&amp;gt; at
&amp;gt; org.apache.cxf.transport.servlet.ServletController.invokeDestination(ServletController.java:264)
&amp;gt; at
&amp;gt; org.apache.cxf.transport.servlet.ServletController.invoke(ServletController.java:160)
&amp;gt; at
&amp;gt; org.apache.cxf.transport.servlet.AbstractCXFServlet.invoke(AbstractCXFServlet.java:170)
&amp;gt; at
&amp;gt; org.apache.cxf.transport.servlet.AbstractCXFServlet.doPost(AbstractCXFServlet.java:148)
&amp;gt; at javax.servlet.http.HttpServlet.service(HttpServlet.java:727) at
&amp;gt; javax.servlet.http.HttpServlet.service(HttpServlet.java:820) at
&amp;gt; org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:487)
&amp;gt; at
&amp;gt; org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:362)
&amp;gt; at
&amp;gt; org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)
&amp;gt; at
&amp;gt; org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:181)
&amp;gt; at
&amp;gt; org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:712)
&amp;gt; at
&amp;gt; org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:405)
&amp;gt; at
&amp;gt; org.mortbay.jetty.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:211)
&amp;gt; at
&amp;gt; org.mortbay.jetty.handler.HandlerCollection.handle(HandlerCollection.java:114)
&amp;gt; at
&amp;gt; org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:139)
&amp;gt; at org.mortbay.jetty.Server.handle(Server.java:313) at
&amp;gt; org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:506)
&amp;gt; at
&amp;gt; org.mortbay.jetty.HttpConnection$RequestHandler.content(HttpConnection.java:844)
&amp;gt; at org.mortbay.jetty.HttpParser.parseNext(HttpParser.java:644) at
&amp;gt; org.mortbay.jetty.HttpParser.parseAvailable(HttpParser.java:211) at
&amp;gt; org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:381) at
&amp;gt; org.mortbay.io.nio.SelectChannelEndPoint.run(SelectChannelEndPoint.java:396)
&amp;gt; at
&amp;gt; org.mortbay.thread.BoundedThreadPool$PoolThread.run(BoundedThreadPool.java:442)
&amp;gt; Caused by: java.lang.NullPointerException at
&amp;gt; org.apache.commons.io.IOUtils.copyLarge(IOUtils.java:1025) at
&amp;gt; org.apache.commons.io.IOUtils.copy(IOUtils.java:999) at
&amp;gt; org.apache.camel.component.cxf.interceptors.RawMessageContentRedirectInterceptor.handleMessage(RawMessageContentRedirectInterceptor.java:39) ...
&amp;gt; 28 more
&amp;gt;
&amp;gt; This is because the InputStream is null in
&amp;gt; RawMessageContentRedirectInterceptor:
&amp;gt;
&amp;gt; public void handleMessage(Message message) throws Fault {
&amp;gt;
&amp;gt;         InputStream is = message.getContent(InputStream.class);
&amp;gt;         OutputStream os = message.getContent(OutputStream.class);
&amp;gt;         
&amp;gt;         try 
{            
&amp;gt;             IOUtils.copy(is, os);
&amp;gt;             is.close();
&amp;gt;             os.flush();
&amp;gt;         }
 catch (Exception e) 
{
&amp;gt;             throw new Fault(e);
&amp;gt;         }
&amp;gt;     }
&amp;gt;
&amp;gt; How can I return a custom soap-fault in a processor/filter?
&amp;gt;
&amp;gt; Thanks,
&amp;gt;
&amp;gt; Marc
&amp;gt;
&amp;gt;</description>
			<version>1.3.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.interceptors.FaultOutInterceptor.java</file>
			<file type="M">org.apache.camel.component.cxf.feature.MessageDataFormatFeature.java</file>
			<file type="M">org.apache.camel.component.cxf.interceptors.RawMessageContentRedirectInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="384" opendate="2008-03-12 18:48:11" fixdate="2008-03-14 02:21:07" resolution="Fixed">
		<buginformation>
			<summary>Support for a full customized soap-fault incl. fault-code and detail</summary>
			<description>Don&amp;amp;apos;t wrap a Fault in a Fault.</description>
			<version>1.3.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CamelInvoker.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfPayLoadCustomizedExceptionTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfCustmerizedExceptionTest.java</file>
			<file type="M">org.apache.camel.component.cxf.interceptors.RawMessageContentRedirectInterceptor.java</file>
			<file type="M">org.apache.camel.component.cxf.interceptors.PayloadContentRedirectInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="388" opendate="2008-03-14 11:46:24" fixdate="2008-03-20 04:16:55" resolution="Fixed">
		<buginformation>
			<summary>Requestor doesn&amp;apos;t honor JmsConfiguration.useVersion102</summary>
			<description>Requestor doesn&amp;amp;apos;t honor JmsConfiguration.useVersion102
Within createListenerContainer() it creates instance of SimpleMessageListenerContainer, however for 1.0.2 it have to create instance of SimpleMessageListenerContainer102 instead.</description>
			<version>1.3.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.requestor.Requestor.java</file>
		</fixedFiles>
	</bug>
	<bug id="374" opendate="2008-03-07 21:31:47" fixdate="2008-03-24 03:51:02" resolution="Fixed">
		<buginformation>
			<summary>HttpBinding.writeResponse doesn&amp;apos;t set the response status code (i.e. it&amp;apos;s always 200)</summary>
			<description>When writing out an Http response, the HttpBinding should check for the existing of the header HttpProducer.HTTP_RESPONSE_CODE and set it in the response if it&amp;amp;apos;s there.  This allows requests made via the http component to be output with the correct status code info.  If also allows processors in the flow to control the status code by setting the header themselves.</description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.HttpBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="383" opendate="2008-03-12 16:18:36" fixdate="2008-03-24 11:47:55" resolution="Fixed">
		<buginformation>
			<summary>Exchange.getOut() not returning (blocking till timeout) when ExchangePattern.InOut used as well as message headers and exchange properties not passed when a Camel Mina used.</summary>
			<description>Exchange.getOut() not returning (blocking till timeout) when ExchangePattern.InOut used. Additionally, message properties and exchange headers does not seem to be passed when using MINA TCP communication. In direct pojo or bean, everything seems working.
I have attached the classes needed to resolve the issue. No modifications are made to interfaces (method signatures). Classes affected are:
org/apache/camel/component/mina/MinaEndpoint.java
org/apache/camel/component/mina/MinaProducer.java
org/apache/camel/component/mina/MinaConsumer.java
new class introduced:
org/apache/camel/component/mina/MinaTransportObject.java
Junit test attached:
org\apache\camel\component\mina\MinaTcpExchangeTest.java</description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina.MinaProducer.java</file>
			<file type="M">org.apache.camel.component.mina.MinaEndpoint.java</file>
			<file type="M">org.apache.camel.component.mina.MinaConverterTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaComponentTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaEncodingTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaTcpWithIoOutProcessorExceptionTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaConsumer.java</file>
			<file type="M">org.apache.camel.component.mina.MinaUdpWithInOutUsingPlainSocketTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaComponent.java</file>
			<file type="M">org.apache.camel.component.mina.MinaExchangeTimeOutTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaExchangeTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="171" opendate="2007-10-11 03:05:14" fixdate="2008-03-28 07:08:37" resolution="Fixed">
		<buginformation>
			<summary>org.apache.camel.component.file.remote.FromFileToFtpTest failure</summary>
			<description>Running org.apache.camel.component.file.remote.FromFileToFtpTest
Server ready :: Apache FTP Server
Oct 11, 2007 10:57:43 AM org.apache.camel.component.mock.MockEndpoint assertIsSatisfied
INFO: Asserting: Endpoint[mock:result] is satisfied
/ = true
//tmp2 = true
//tmp2/camel = true
Oct 11, 2007 10:57:44 AM org.apache.camel.processor.Logger log
SEVERE: On delivery attempt: 0 caught: org.apache.camel.RuntimeCamelException: error sending file
org.apache.camel.RuntimeCamelException: error sending file
        at org.apache.camel.component.file.remote.FtpProducer.process(FtpProducer.java:51)
        at org.apache.camel.component.file.remote.FtpProducer.process(FtpProducer.java:37)
        at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsynProcessorBridge.process(AsyncProcessorTypeConverter.java:44)
        at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:73)
        at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:136)
        at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:86)
        at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:40)
        at org.apache.camel.component.file.FileConsumer.pollFile(FileConsumer.java:131)
        at org.apache.camel.component.file.FileConsumer.pollFileOrDirectory(FileConsumer.java:68)
        at org.apache.camel.component.file.File
The build still said "successful" at the end</description>
			<version>1.1.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpProducer.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpRouteTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="173" opendate="2007-10-11 08:13:31" fixdate="2008-03-28 11:27:06" resolution="Fixed">
		<buginformation>
			<summary>BAM example failure</summary>
			<description>the example throws following error:
[pache.camel.spring.Main.main()] Main                           INFO  Apache Camel 1.2.0 starting
[pache.camel.spring.Main.main()] Main                           INFO  Generating DOT file for routes: /opt/dev/apache-camel-1.2.0/examples/camel-example-bam/target/site/cameldoc for: org.apache.camel.spring.SpringCamelContext@352d87
[nent.file.FileComponent@db248c] JDBCExceptionReporter          WARN  SQL Error: 0, SQLState: null
[nent.file.FileComponent@db248c] JDBCExceptionReporter          ERROR failed batch
Failed to load preferences.  Proceeding with defaults:
[nent.file.FileComponent@db248c] AbstractFlushingEventListener  ERROR Could not synchronize database state with session
org.hibernate.exception.GenericJDBCException: Could not execute JDBC batch update
        at org.hibernate.exception.SQLStateConverter.handledNonSpecificException(SQLStateConverter.java:103)
        at org.hibernate.exception.SQLStateConverter.convert(SQLStateConverter.java:91)
        at org.hibernate.exception.JDBCExceptionHelper.convert(JDBCExceptionHelper.java:43)
        at org.hibernate.jdbc.AbstractBatcher.executeBatch(AbstractBatcher.java:249)
        at org.hibernate.engine.ActionQueue.executeActions(ActionQueue.java:235)
        at org.hibernate.engine.ActionQueue.executeActions(ActionQueue.java:139)
        at org.hibernate.event.def.AbstractFlushingEventListener.performExecutions(AbstractFlushingEventListener.java:298)
        at org.hibernate.event.def.DefaultFlushEventListener.onFlush(DefaultFlushEventListener.java:27)
        at org.hibernate.impl.SessionImpl.flush(SessionImpl.java:1000)
        at org.hibernate.ejb.AbstractEntityManagerImpl.flush(AbstractEntityManagerImpl.java:296)
        at org.springframework.orm.jpa.JpaTemplate$8.doInJpa(JpaTemplate.java:289)
        at org.springframework.orm.jpa.JpaTemplate.execute(JpaTemplate.java:191)
        at org.springframework.orm.jpa.JpaTemplate.flush(JpaTemplate.java:287)
        at org.apache.camel.bam.processor.JpaBamProcessorSupport.loadEntity(JpaBamProcessorSupport.java:118)
        at org.apache.camel.bam.processor.BamProcessorSupport$1.doInTransaction(BamProcessorSupport.java:96)
        at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:127)
        at org.apache.camel.bam.processor.BamProcessorSupport.process(BamProcessorSupport.java:91)
        at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsynProcessorBridge.process(AsyncProcessorTypeConverter.java:44)
        at org.apache.camel.component.file.FileConsumer.pollFile(FileConsumer.java:131)
        at org.apache.camel.component.file.FileConsumer.pollFileOrDirectory(FileConsumer.java:68)
        at org.apache.camel.component.file.FileConsumer.pollFileOrDirectory(FileConsumer.java:76)
        at org.apache.camel.component.file.FileConsumer.poll(FileConsumer.java:49)
        at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:63)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:417)
        at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:280)
        at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:135)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:65)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:142)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:166)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675)
        at java.lang.Thread.run(Thread.java:595)
Caused by: java.sql.BatchUpdateException: failed batch
        at org.hsqldb.jdbc.jdbcStatement.executeBatch(Unknown Source)
        at org.hsqldb.jdbc.jdbcPreparedStatement.executeBatch(Unknown Source)
        at org.hibernate.jdbc.BatchingBatcher.doExecuteBatch(BatchingBatcher.java:48)
        at org.hibernate.jdbc.AbstractBatcher.executeBatch(AbstractBatcher.java:242)
        ... 28 more
[nent.file.FileComponent@db248c] BamProcessorSupport            INFO  Attempt to insert duplicate row due to concurrency issue, so retrying: org.springframework.orm.jpa.JpaSystemException: org.hibernate.exception.GenericJDBCException: Could not execute JDBC batch update; nested exception is javax.persistence.PersistenceException: org.hibernate.exception.GenericJDBCException: Could not execute JDBC batch update
[nent.file.FileComponent@db248c] BamProcessorSupport            INFO  Retry attempt due to duplicate row: 1
[         ActivityMonitorEngine] BamFailures                    ERROR Exchange[Message: ActivityState[2 on ProcessInstance[p3] Activity[2 name: file:src/data/invoices?noop=true]]]
[         ActivityMonitorEngine] BamFailures                    ERROR Exchange[Message: ActivityState[7 on ProcessInstance[p2] Activity[2 name: file:src/data/invoices?noop=true]]]</description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.bam.processor.JpaBamProcessorSupport.java</file>
			<file type="M">org.apache.camel.bam.processor.BamProcessorSupport.java</file>
			<file type="M">org.apache.camel.bam.BamRouteTest.java</file>
			<file type="M">org.apache.camel.example.bam.MyActivities.java</file>
		</fixedFiles>
	</bug>
	<bug id="415" opendate="2008-03-30 14:23:43" fixdate="2008-03-30 14:48:03" resolution="Fixed">
		<buginformation>
			<summary>multicast parallelProcessing is always true</summary>
			<description>
    public MulticastType multicast(AggregationStrategy aggregationStrategy, boolean parallelProcessing) {
        MulticastType answer = new MulticastType();
        addOutput(answer);
        answer.setAggregationStrategy(aggregationStrategy);
        answer.setParallelProcessing(true);
        return answer;
    }


The parameter parallelProcessing is never used. setParallelProcessing is always true.</description>
			<version>1.3.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.CamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.util.ProducerCache.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.processor.Aggregator.java</file>
			<file type="M">org.apache.camel.converter.jaxp.StringSource.java</file>
			<file type="M">org.apache.camel.ProducerTemplate.java</file>
			<file type="M">org.apache.camel.impl.LoggingExceptionHandler.java</file>
			<file type="M">org.apache.camel.component.jmx.JMXMessage.java</file>
			<file type="M">org.apache.camel.model.config.StreamResequencerConfig.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilder.java</file>
			<file type="M">org.apache.camel.model.RouteContainer.java</file>
			<file type="M">org.apache.camel.converter.jaxp.XmlConverter.java</file>
			<file type="M">org.apache.camel.AsyncProcessor.java</file>
			<file type="M">org.apache.camel.converter.jaxp.BytesSource.java</file>
			<file type="M">org.apache.camel.CamelExchangeException.java</file>
			<file type="M">org.apache.camel.view.NodeData.java</file>
			<file type="M">org.apache.camel.NoSuchEndpointException.java</file>
			<file type="M">org.apache.camel.processor.ErrorHandlerSupport.java</file>
			<file type="M">org.apache.camel.model.language.ExpressionType.java</file>
			<file type="M">org.apache.camel.processor.loadbalancer.TopicLoadBalancer.java</file>
			<file type="M">org.apache.camel.util.DefaultTimeoutMap.java</file>
			<file type="M">org.apache.camel.impl.DefaultConsumer.java</file>
			<file type="M">org.apache.camel.Message.java</file>
			<file type="M">org.apache.camel.impl.converter.AnnotationTypeConverterLoader.java</file>
			<file type="M">org.apache.camel.util.CamelContextHelper.java</file>
			<file type="M">org.apache.camel.util.jndi.JndiContext.java</file>
			<file type="M">org.apache.camel.CamelTemplate.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
			<file type="M">org.apache.camel.Route.java</file>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.spi.TypeConverterAware.java</file>
			<file type="M">org.apache.camel.AsyncCallback.java</file>
			<file type="M">org.apache.camel.management.CamelNamingStrategy.java</file>
			<file type="M">org.apache.camel.RuntimeExchangeException.java</file>
			<file type="M">org.apache.camel.impl.MessageSupport.java</file>
			<file type="M">org.apache.camel.spi.LifecycleStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="404" opendate="2008-03-28 05:51:11" fixdate="2008-03-30 17:15:46" resolution="Fixed">
		<buginformation>
			<summary>Javadoc warnings</summary>
			<description>Get the javadoc warnings reported by the javadoc generator fixed.</description>
			<version>1.3.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xmpp.XmppExchange.java</file>
			<file type="M">org.apache.camel.spring.CamelBeanPostProcessor.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppConsumer.java</file>
			<file type="M">org.apache.camel.spring.SpringRouteBuilder.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppBinding.java</file>
			<file type="M">org.apache.camel.component.jms.JmsExchange.java</file>
			<file type="M">org.apache.camel.component.jms.JmsConfiguration.java</file>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
			<file type="M">org.apache.camel.builder.script.ScriptBuilder.java</file>
			<file type="M">org.apache.camel.component.rmi.RmiConsumer.java</file>
			<file type="M">org.apache.camel.component.mail.MailConsumer.java</file>
			<file type="M">org.apache.camel.component.jms.requestor.FailedToProcessResponse.java</file>
			<file type="M">org.apache.camel.component.mail.MailExchange.java</file>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
			<file type="M">org.apache.camel.component.http.HttpEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.invoker.InvokingContext.java</file>
			<file type="M">org.apache.camel.component.cxf.transport.CamelDestination.java</file>
			<file type="M">org.apache.camel.component.cxf.transport.CamelDestinationTest.java</file>
			<file type="M">org.apache.camel.component.cxf.MessageInvoker.java</file>
			<file type="M">org.apache.camel.component.cxf.CamelInvoker.java</file>
			<file type="M">org.apache.camel.component.cxf.interceptors.AbstractMessageInInterceptor.java</file>
			<file type="M">org.apache.camel.CamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.util.ProducerCache.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.processor.Aggregator.java</file>
			<file type="M">org.apache.camel.converter.jaxp.StringSource.java</file>
			<file type="M">org.apache.camel.ProducerTemplate.java</file>
			<file type="M">org.apache.camel.impl.LoggingExceptionHandler.java</file>
			<file type="M">org.apache.camel.component.jmx.JMXMessage.java</file>
			<file type="M">org.apache.camel.model.config.StreamResequencerConfig.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilder.java</file>
			<file type="M">org.apache.camel.model.RouteContainer.java</file>
			<file type="M">org.apache.camel.converter.jaxp.XmlConverter.java</file>
			<file type="M">org.apache.camel.AsyncProcessor.java</file>
			<file type="M">org.apache.camel.converter.jaxp.BytesSource.java</file>
			<file type="M">org.apache.camel.CamelExchangeException.java</file>
			<file type="M">org.apache.camel.view.NodeData.java</file>
			<file type="M">org.apache.camel.NoSuchEndpointException.java</file>
			<file type="M">org.apache.camel.processor.ErrorHandlerSupport.java</file>
			<file type="M">org.apache.camel.model.language.ExpressionType.java</file>
			<file type="M">org.apache.camel.processor.loadbalancer.TopicLoadBalancer.java</file>
			<file type="M">org.apache.camel.util.DefaultTimeoutMap.java</file>
			<file type="M">org.apache.camel.impl.DefaultConsumer.java</file>
			<file type="M">org.apache.camel.Message.java</file>
			<file type="M">org.apache.camel.impl.converter.AnnotationTypeConverterLoader.java</file>
			<file type="M">org.apache.camel.util.CamelContextHelper.java</file>
			<file type="M">org.apache.camel.util.jndi.JndiContext.java</file>
			<file type="M">org.apache.camel.CamelTemplate.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
			<file type="M">org.apache.camel.Route.java</file>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.spi.TypeConverterAware.java</file>
			<file type="M">org.apache.camel.AsyncCallback.java</file>
			<file type="M">org.apache.camel.management.CamelNamingStrategy.java</file>
			<file type="M">org.apache.camel.RuntimeExchangeException.java</file>
			<file type="M">org.apache.camel.impl.MessageSupport.java</file>
			<file type="M">org.apache.camel.spi.LifecycleStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="430" opendate="2008-04-02 19:20:26" fixdate="2008-04-03 05:08:53" resolution="Fixed">
		<buginformation>
			<summary>consumeDelete=false option of etl sample doesn&amp;apos;t seem to work</summary>
			<description>In org/apache/camel/example/etl/EtlRoutes.java, the following line:

    from("jpa:org.apache.camel.example.etl.CustomerEntity?consumeDelete=false?consumer.delay=3000&amp;amp;consumeLockEntity=false")
        .setHeader(FileComponent.HEADER_FILE_NAME, el("${in.body.userName}.xml"))
        .to("file:target/customers?append=false");


seems to successfully dump the database entries to files in the target/customers directory.  Unless I&amp;amp;apos;m misunderstanding the sample, the consumeDelete=false is meant to ensure that the dump of the database does not delete the entries from the database.  However, when running the etl sample querying the customer table in the database, the list is empty.  I suspect the consumeDelete=false isn&amp;amp;apos;t working.</description>
			<version>1.2.0</version>
			<fixedVersion>1.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.example.etl.EtlRoutes.java</file>
		</fixedFiles>
	</bug>
	<bug id="410" opendate="2008-03-28 19:51:00" fixdate="2008-04-05 11:23:27" resolution="Fixed">
		<buginformation>
			<summary>Exception handling of the ErrorHandlerSupport class</summary>
			<description>When you configure your route builder and say you want to configure two exceptions lets say: NullPointer and Exception. 
Now say the bean you call as your end point throws a NullPointer, wouldn&amp;amp;apos;t you think the NullPointer policy would handle that exception? 
Well I&amp;amp;apos;m seeing sometimes it does and sometimes it doesn&amp;amp;apos;t due to the map not keeping the exceptions in any particular order.  Is there anyway this could be changed to a LinkedHashMap or a List?
Issue with class: org.apache.camel.processor.ErrorHandlerSupport
</description>
			<version>1.2.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategy.java</file>
			<file type="M">org.apache.camel.processor.exceptionpolicy.CustomExceptionPolicyStrategyTest.java</file>
			<file type="M">org.apache.camel.processor.ErrorHandlerSupport.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerTest.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannelTest.java</file>
			<file type="M">org.apache.camel.builder.DeadLetterChannelBuilder.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannel.java</file>
		</fixedFiles>
	</bug>
	<bug id="457" opendate="2008-04-10 08:04:27" fixdate="2008-04-12 08:20:33" resolution="Fixed">
		<buginformation>
			<summary>Camel should raise an exception if parsing of xslt file fails</summary>
			<description>Consider a Camel route that involves an xslt component. When Camel sets up the route, the XsltBuilder ignores any errors coming from the xerces xml parser and continues constructing the route even though the xslt transformer is not initialized. 
Later when the route is executed Camel correctly checks if the transformer is initialized and raises an error if not:
java.lang.IllegalArgumentException: No transformer configured!
However in case of a parse error in the xslt file, the whole route becomes unusable and the setup routine that constructs the route should fail with an appropriate error message. A sanity check needs to be added in method
org.apache.camel.builder.xml.XsltBuilder.setTransformerSource(javax.xml.transform.Source).
</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.xml.XsltBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="420" opendate="2008-04-01 11:46:17" fixdate="2008-04-12 14:32:51" resolution="Fixed">
		<buginformation>
			<summary>FTPComponent - problems and improvements</summary>
			<description>See this forum:
http://www.nabble.com/FTP-to-FILE-td16354813s22882.html
Problems:

Using ASCII you need to use convertBodyTo(String.class) to let it work out of the box Fixed
Using BINARY we need some Type Converters to let it consume files from a FTP Server and store it as a File Fixed
You have to set the filename using the header in the configuration otherwise the filename can be wrong Fixed

</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FromFtpToFileNoFileNameHeaderTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileConverter.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFileToFtpTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpToAsciiFileTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpToBinaryFileTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpToMockTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumer.java</file>
			<file type="D">org.apache.camel.component.file.remote.FtpRouteTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="461" opendate="2008-04-14 04:02:54" fixdate="2008-04-14 04:22:03" resolution="Fixed">
		<buginformation>
			<summary>Interceptor does not work with the logging example</summary>
			<description>The wiki logging example does not work out of the box
http://activemq.apache.org/camel/dsl.html
It has been discussed on the forum:
http://www.nabble.com/interceptors---something-is-terrible-wrong-td16661322s22882.html
Jonathan was so kind to provide a patch.</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
			<file type="M">org.apache.camel.issues.InterceptorLogTest.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="is depended upon by">462</link>
		</links>
	</bug>
	<bug id="476" opendate="2008-04-21 19:13:46" fixdate="2008-05-07 18:40:42" resolution="Duplicate">
		<buginformation>
			<summary>Add support for errorHandler in the xml (spring) DSL</summary>
			<description></description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.processor.SpringFaultRouteTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">122</link>
		</links>
	</bug>
	<bug id="412" opendate="2008-03-29 15:04:28" fixdate="2008-05-08 14:42:31" resolution="Fixed">
		<buginformation>
			<summary>OSX mvn -e -o org.apache.camel:camel-maven-plugin:dot fails due to the lack of dot.exe</summary>
			<description>Though the intent seemed to be there, the DotMojo does not skip conversion of the file if there is no value for &amp;lt;executable/&amp;gt; in the pom.xml.  The parameter was defaulted.
#. removed the default.
#. added log message.</description>
			<version>1.2.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.maven.DotMojo.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="depends upon">418</link>
		</links>
	</bug>
	<bug id="498" opendate="2008-05-08 09:09:35" fixdate="2008-05-08 18:22:49" resolution="Fixed">
		<buginformation>
			<summary>file endpoint with noop=true does not detect old files moved into a directory</summary>
			<description></description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.MoveFilesToDirectoryTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="499" opendate="2008-05-08 17:24:17" fixdate="2008-05-09 05:09:04" resolution="Fixed">
		<buginformation>
			<summary>camel-core does not compile on HP-UX</summary>
			<description>camel-core/src/main/java/org/apache/camel/model/ProcessorType.java:[871,12] inconvertible types
 found   : org.apache.camel.model.ProcessorType&amp;lt;Type&amp;gt;
 required: org.apache.camel.model.InterceptType
camel-core/src/main/java/org/apache/camel/model/ProcessorType.java:[872,39] inconvertible types
 found   : org.apache.camel.model.ProcessorType&amp;lt;Type&amp;gt;
 required: org.apache.camel.model.InterceptType
camel-core/src/main/java/org/apache/camel/model/ProcessorType.java:[884,12] inconvertible types
 found   : org.apache.camel.model.ProcessorType&amp;lt;Type&amp;gt;
 required: org.apache.camel.model.InterceptType
camel-core/src/main/java/org/apache/camel/model/ProcessorType.java:[885,38] inconvertible types
 found   : org.apache.camel.model.ProcessorType&amp;lt;Type&amp;gt;
 required: org.apache.camel.model.InterceptType </description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
		</fixedFiles>
	</bug>
	<bug id="509" opendate="2008-05-12 20:58:18" fixdate="2008-05-13 02:01:04" resolution="Fixed">
		<buginformation>
			<summary>JMX Connector is not closed by InstrumentationAgentImpl.doStop()</summary>
			<description></description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.InstrumentationAgentImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="510" opendate="2008-05-13 03:43:12" fixdate="2008-05-13 04:21:26" resolution="Fixed">
		<buginformation>
			<summary>Intermittent test failure in MultiCastAggregatorTest</summary>
			<description>There is a race condition in the test that both in/out aggregators are aggregating the output.  It looks like the InAggregator should to make a copy of the exchange.  The attached patch also gets rid of a unused method.</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.MultiCastAggregatorTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="504" opendate="2008-05-12 14:00:11" fixdate="2008-05-16 04:52:24" resolution="Fixed">
		<buginformation>
			<summary>AtomProducer lacks to set several entries on the feed</summary>
			<description>The AtomProducer that creates the feed does not set all needed entries such as author and other fields.
There is a TODO in the code:
// TODO categories, authors etc
Also we need an unit test that covers the producing part. We now only have the consuming.</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.atom.UpdatedDateFilterTest.java</file>
			<file type="M">org.apache.camel.component.atom.AtomComponent.java</file>
			<file type="M">org.apache.camel.component.atom.AtomPollingConsumer.java</file>
			<file type="M">org.apache.camel.component.atom.AtomEndpoint.java</file>
			<file type="M">org.apache.camel.component.atom.AtomEntryPollingConsumer.java</file>
			<file type="M">org.apache.camel.component.atom.AtomPollingConsumerTest.java</file>
			<file type="M">org.apache.camel.component.atom.EntryFilter.java</file>
			<file type="M">org.apache.camel.component.atom.UpdatedDateFilter.java</file>
			<file type="M">org.apache.camel.component.atom.AtomProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="518" opendate="2008-05-16 04:38:19" fixdate="2008-05-16 05:43:56" resolution="Fixed">
		<buginformation>
			<summary>camel-mail thrown NotSupportedOperation for nntp protocol as not supporter (yet)</summary>
			<description>nntp is reserved for future implementation in camel-mail. Camel registers this protocol as supported by the autoscan of the META-INF files.
We should throw an exception to the end-user stating its not implemented yet.
Link to ticket that has the request for NNTP protocol support.</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.InvalidConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.mail.MailComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="524" opendate="2008-05-16 21:04:12" fixdate="2008-05-19 02:17:42" resolution="Fixed">
		<buginformation>
			<summary>IntrumentationProcessor does properly record processing time</summary>
			<description>The InstrumentationLifeCycleStrategy inserts an InstrumentationProcessor interceptor at the end of a route which is intercepted after the processing has been done.  The InstrumentationProcessor does not actually record the time spent on the route.  It is fixed by inserting InstrumentationProcessor at the beginning of the route and wrapping all the outputs.
There two MBeans (ManagedRoute and PerformanceCounter) registered for each route eventhough ManagedRoute already extends PerformanceCounter.  We probably only need to expose one MBean.  The ManagedRoute MBean shows performance attributes and operations (since it extends PerformanceCoutner) but these performance related stuffs don&amp;amp;apos;t really work.  This is fixed by registering only the ManagedRoute MBean and making the performance related attributes and operations functional.
This patch supports exposing all processors within a route as PerformanceCounter MBeans so that users are possible to monitor performance at the processor&amp;amp;apos;s level.
With this patch, the org.apache.camel.spi package no longer depends CamelNamingStrategy of the org.apache.camel.management.management package.  It follows the suggestion mentioned in https://issues.apache.org/activemq/browse/CAMEL-264.
Another update is to following the JMX spec convention of including a "type" property in the ObjectName (replacing the current "groups" property).  This patch also simplify the ManagedRoute&amp;amp;apos;s ObjectName a bit by removing builder and group properties.  If for some reasons, they need to be in the ObjectName, please add them back.</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.InstrumentationLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.management.InstrumentationAgentImpl.java</file>
			<file type="M">org.apache.camel.spi.InstrumentationAgent.java</file>
			<file type="M">org.apache.camel.management.InstrumentationProcessor.java</file>
			<file type="M">org.apache.camel.management.JmxInstrumentationUsingDefaultsTest.java</file>
			<file type="M">org.apache.camel.impl.RouteContext.java</file>
			<file type="M">org.apache.camel.management.CamelNamingStrategy.java</file>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
		</fixedFiles>
	</bug>
	<bug id="519" opendate="2008-05-16 05:58:15" fixdate="2008-05-21 07:13:54" resolution="Fixed">
		<buginformation>
			<summary>XML Syntax does not support enabling/disabling stream caching</summary>
			<description></description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.RouteType.java</file>
		</fixedFiles>
	</bug>
	<bug id="534" opendate="2008-05-21 07:53:03" fixdate="2008-05-21 08:04:57" resolution="Fixed">
		<buginformation>
			<summary>camel mina udp throws exception "Already released buffer"</summary>
			<description>http://www.nabble.com/camel-mina-udp-throws-exception-%22Already-released-buffer%22-td17342374.html#a17343387</description>
			<version>1.2.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina.MinaConverter.java</file>
			<file type="M">org.apache.camel.component.mina.MinaUdpTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="537" opendate="2008-05-21 10:31:12" fixdate="2008-05-21 12:38:32" resolution="Duplicate">
		<buginformation>
			<summary>Errors when camel jars are used witin a Web Start context</summary>
			<description>I found this link:
http://mail-archives.apache.org/mod_mbox/geronimo-servicemix-commits/200704.mbox/%3C20070407083556.0AFFC1A983A@eris.apache.org%3E
which led me to belief it is a bug in Camel. 
Here are the errors I got:
ERROR - Could not search jar file &amp;amp;apos;http:\82.110.65.157\jsp-examples\lib\camel\camel-fix-1.3.6.0-fuse.jar&amp;amp;apos; for classes matching criteria: annotated with @Converterdue to an IOException: http:\82.110.65.157\jsp-examples\lib\camel\camel-fix-1.3.6.0-fuse.jar (The filename, directory name, or volume label syntax is incorrect) 
ERROR - Could not search jar file &amp;amp;apos;http:\82.110.65.157\jsp-examples\lib\camel\camel-ftp-1.3.6.0-fuse.jar&amp;amp;apos; for classes matching criteria: annotated with @Converterdue to an IOException: http:\82.110.65.157\jsp-examples\lib\camel\camel-ftp-1.3.6.0-fuse.jar (The filename, directory name, or volume label syntax is incorrect) 
ERROR - Could not search jar file &amp;amp;apos;http:\82.110.65.157\jsp-examples\lib\camel\camel-artixds-1.3.6.0-fuse.jar&amp;amp;apos; for classes matching criteria: annotated with @Converterdue to an IOException: http:\82.110.65.157\jsp-examples\lib\camel\camel-artixds-1.3.6.0-fuse.jar (The filename, directory name, or volume label syntax is incorrect) 
ERROR - Could not search jar file &amp;amp;apos;http:\82.110.65.157\jsp-examples\lib\camel\camel-mina-1.3.6.0-fuse.jar&amp;amp;apos; for classes matching criteria: annotated with @Converterdue to an IOException: http:\82.110.65.157\jsp-examples\lib\camel\camel-mina-1.3.6.0-fuse.jar (The filename, directory name, or volume label syntax is incorrect) 
ERROR - Could not search jar file &amp;amp;apos;http:\82.110.65.157\jsp-examples\lib\camel\camel-jhc-1.3.6.0-fuse.jar&amp;amp;apos; for classes matching criteria: annotated with @Converterdue to an IOException: http:\82.110.65.157\jsp-examples\lib\camel\camel-jhc-1.3.6.0-fuse.jar (The filename, directory name, or volume label syntax is incorrect) 
ERROR - Could not search jar file &amp;amp;apos;http:\82.110.65.157\jsp-examples\lib\camel\camel-core-1.3.6.0-fuse.jar&amp;amp;apos; for classes matching criteria: annotated with @Converterdue to an IOException: http:\82.110.65.157\jsp-examples\lib\camel\camel-core-1.3.6.0-fuse.jar (The filename, directory name, or volume label syntax is incorrect) 
ERROR - Could not search jar file &amp;amp;apos;http:\82.110.65.157\jsp-examples\lib\camel\camel-jaxb-1.3.6.0-fuse.jar&amp;amp;apos; for classes matching criteria: annotated with @Converterdue to an IOException: http:\82.110.65.157\jsp-examples\lib\camel\camel-jaxb-1.3.6.0-fuse.jar (The filename, directory name, or volume label syntax is incorrect) 
ERROR - Could not search jar file &amp;amp;apos;http:\82.110.65.157\jsp-examples\lib\camel\camel-xmlbeans-1.3.6.0-fuse.jar&amp;amp;apos; for classes matching criteria: annotated with @Converterdue to an IOException: http:\82.110.65.157\jsp-examples\lib\camel\camel-xmlbeans-1.3.6.0-fuse.jar (The filename, directory name, or volume label syntax is incorrect) 
ERROR - Could not search jar file &amp;amp;apos;http:\82.110.65.157\jsp-examples\lib\camel\camel-mail-1.3.6.0-fuse.jar&amp;amp;apos; for classes matching criteria: annotated with @Converterdue to an IOException: http:\82.110.65.157\jsp-examples\lib\camel\camel-mail-1.3.6.0-fuse.jar (The filename, directory name, or volume label syntax is incorrect) 
ERROR - Could not search jar file &amp;amp;apos;http:\82.110.65.157\jsp-examples\lib\camel\camel-xmlbeans-1.3.6.0-fuse.jar&amp;amp;apos; for classes matching criteria: annotated with @Converterdue to an IOException: http:\82.110.65.157\jsp-examples\lib\camel\camel-xmlbeans-1.3.6.0-fuse.jar (The filename, directory name, or volume label syntax is incorrect) 
ERROR - Could not search jar file &amp;amp;apos;http:\82.110.65.157\jsp-examples\lib\camel\camel-http-1.3.6.0-fuse.jar&amp;amp;apos; for classes matching criteria: annotated with @Converterdue to an IOException: http:\82.110.65.157\jsp-examples\lib\camel\camel-http-1.3.6.0-fuse.jar (The filename, directory name, or volume label syntax is incorrect) 
ERROR - Could not search jar file &amp;amp;apos;http:\82.110.65.157\jsp-examples\lib\activemq\activemq-core-5.0.0.13-fuse.jar&amp;amp;apos; for classes matching criteria: annotated with @Converterdue to an IOException: http:\82.110.65.157\jsp-examples\lib\activemq\activemq-core-5.0.0.13-fuse.jar (The filename, directory name, or volume label syntax is incorrect) 
ERROR - Could not search jar file &amp;amp;apos;http:\82.110.65.157\jsp-examples\lib\camel\camel-jcr-1.3.6.0-fuse.jar&amp;amp;apos; for classes matching criteria: annotated with @Converterdue to an IOException: http:\82.110.65.157\jsp-examples\lib\camel\camel-jcr-1.3.6.0-fuse.jar (The filename, directory name, or volume label syntax is incorrect) </description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ResolverUtil.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">522</link>
		</links>
	</bug>
	<bug id="528" opendate="2008-05-18 04:40:00" fixdate="2008-05-22 04:17:21" resolution="Fixed">
		<buginformation>
			<summary>Intermittent MailFetchSizeTest failure</summary>
			<description>I am seeing MailFetchSizeTest failing on my windows box.  After taking a look at the mock mailbox code, I think it is because mock mailbox (org.jvnet.mock_javamail.Mailbox) is not threadsafe.  If I add a half second sleep before checking mailbox.size() (see attached patch), it does not fail on my box anymore.  It is still not a guaranteed fix though.  I think we could remove the mailbox size checks if the "sleep" trick does not work because mock mailbox does not seem to support our testcase and we already verify messages on the receiving mock endpoint.</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailFetchSizeTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="536" opendate="2008-05-21 09:13:29" fixdate="2008-05-23 08:37:10" resolution="Fixed">
		<buginformation>
			<summary>camel-cxf component not propagating context data</summary>
			<description>For POJO data formats the CxfProducer currently invokes the following method to invoke on a target server
result = client.invoke(operation, parameters.toArray());
This fails to setup the Request and Response contexts for the out (request) message and in (response) message. It should instead be copying the relevant data from the consumer and invoking the following operation on the Client interface
Object[] invoke(BindingOperationInfo oi,   Object[] params,  Map&amp;lt;String, Object&amp;gt; context) throws Exception;
Likewise the PAYLOAD and MESSAGE data formats are not setting up their contexts before they call the dispatch operation. In fact there is comments in the current codebase...
                // invoke the message prepare the context
                Map&amp;lt;String, Object&amp;gt; context = new HashMap&amp;lt;String, Object&amp;gt;();
                Map&amp;lt;String, Object&amp;gt; requestContext = new HashMap&amp;lt;String, Object&amp;gt;();
                Map&amp;lt;String, Object&amp;gt; responseContext = new HashMap&amp;lt;String, Object&amp;gt;();
                // TODO Get the requestContext from the CamelExchange
                context.put(CxfClient.REQUEST_CONTEXT, requestContext);
                context.put(CxfClient.RESPONSE_CONTEXT, responseContext);
The fix should also include a fix for all three data format types</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfProducerRouterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.invoker.CxfClient.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducer.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="548" opendate="2008-05-24 17:23:55" fixdate="2008-05-25 12:23:12" resolution="Fixed">
		<buginformation>
			<summary>File component should have option for deleting file if it was handled by an exception handler etc</summary>
			<description>See the user forum where a user has detailed the problem:
http://www.nabble.com/File-Component-Error-handling-td15372041s22882.html</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileConsumer.java</file>
			<file type="M">org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="307" opendate="2008-01-22 12:37:24" fixdate="2008-05-26 04:20:10" resolution="Fixed">
		<buginformation>
			<summary>when renaming a file, we should ensure that the new file name does not exist first (deleting any existing files if they are there)</summary>
			<description>See this discussion for more detail : http://www.nabble.com/From-file-to-ftp-tp14921828s22882p15016618.html</description>
			<version>1.2.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.strategy.RenameFileProcessStrategy.java</file>
			<file type="M">org.apache.camel.component.file.strategy.DeleteFileProcessStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="551" opendate="2008-05-26 04:17:46" fixdate="2008-05-26 05:10:21" resolution="Fixed">
		<buginformation>
			<summary>File component - noop does not lock the file during processing</summary>
			<description>The noop=true option does not lock the file during processing as it states in its class javadoc. The parameter is false. It should be true instead.
    public NoOpFileProcessStrategy() 
{
        super(false);
    }</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileConsumerFailureHandledTest.java</file>
			<file type="M">org.apache.camel.component.file.strategy.NoOpFileProcessStrategy.java</file>
			<file type="M">org.apache.camel.component.file.strategy.FileProcessStrategyFactory.java</file>
			<file type="M">org.apache.camel.component.file.FileProducerRenameStrategyTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="549" opendate="2008-05-25 06:19:07" fixdate="2008-05-26 15:45:39" resolution="Fixed">
		<buginformation>
			<summary>org.apache.camel.spring.Main can&amp;apos;t take -o output and -d duration operations</summary>
			<description>The added -d Debugger option broke the  org.apache.camel.spring.Main&amp;amp;apos;s parameters consumption. </description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.Main.java</file>
		</fixedFiles>
	</bug>
	<bug id="550" opendate="2008-05-25 06:30:06" fixdate="2008-05-26 15:49:16" resolution="Fixed">
		<buginformation>
			<summary>NPE from came:run with below route codes</summary>
			<description>With the following route:

				from("timer://tutorial?fixedRate=true&amp;amp;period=10")
						.setBody(
								constant("&amp;lt;?xml version=&amp;amp;apos;1.0&amp;amp;apos; encoding=&amp;amp;apos;UTF-8&amp;amp;apos;?&amp;gt;&amp;lt;greetMe&amp;gt;Hello World&amp;lt;/greetMe&amp;gt;"))
						.setHeader("CBR1", constant("No")).choice().when(
								header("CBR1").isEqualTo("Yes")).setHeader(
								"CreditcardValidation", constant("Yes")).to(
								"log:CBRBean?level=INFO").to("log:XSLT for provider1?level=INFO")
						.when(header("CBR1").isEqualTo("No")).setHeader(
								"CreditcardValidation", constant("No")).to(
								"log:XSLT for provider2?level=INFO").end().choice()
						.when(header("CreditcardValidation").isEqualTo("Yes"))
						.to("log:CCVBean?level=INFO").to("log:XSLT for consumer1?level=INFO").when(
								header("CreditcardValidation").isEqualTo("No"))
						.to("log:XSLT for consumer2?level=INFO").otherwise()
						.to("log:test?level=INFO").end();


running mvn camel:run 
I get the following stack trace:

java.lang.NullPointerException
	at org.apache.camel.view.NodeData.&amp;lt;init&amp;gt;(NodeData.java:136)
	at org.apache.camel.view.GraphGeneratorSupport.getNodeData(GraphGeneratorSupport.java:142)
	at org.apache.camel.view.RouteDotGenerator.printNode(RouteDotGenerator.java:101)
	at org.apache.camel.view.RouteDotGenerator.printNode(RouteDotGenerator.java:123)
	at org.apache.camel.view.RouteDotGenerator.printRoute(RouteDotGenerator.java:87)
	at org.apache.camel.view.RouteDotGenerator.printRoutes(RouteDotGenerator.java:64)
	at org.apache.camel.view.RouteDotGenerator.printRoutes(RouteDotGenerator.java:48)
	at org.apache.camel.view.RouteDotGenerator.generateFile(RouteDotGenerator.java:169)
	at org.apache.camel.view.GraphGeneratorSupport.generateFile(GraphGeneratorSupport.java:103)
	at org.apache.camel.view.GraphGeneratorSupport.drawRoutes(GraphGeneratorSupport.java:81)
	at org.apache.camel.spring.Main.generateDot(Main.java:392)
	at org.apache.camel.spring.Main.postProcessContext(Main.java:374)
	at org.apache.camel.spring.Main.doStart(Main.java:333)
	at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:47)
	at org.apache.camel.spring.Main.run(Main.java:123)
	at org.apache.camel.spring.Main.run(Main.java:114)
	at org.apache.camel.spring.Main.main(Main.java:106)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.apache.camel.maven.RunMojo$1.run(RunMojo.java:333)
	at java.lang.Thread.run(Thread.java:613)


the error seems related to the maven camel plugin failing generating the dot file for the route.</description>
			<version>1.2.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.view.NodeData.java</file>
			<file type="M">org.apache.camel.component.file.FileConsumer.java</file>
			<file type="M">org.apache.camel.management.InstrumentationLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.component.mock.MockEndpoint.java</file>
			<file type="M">org.apache.camel.model.ChoiceType.java</file>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
			<file type="M">org.apache.camel.builder.BuilderSupport.java</file>
			<file type="M">org.apache.camel.component.file.FilerProducerFileNamesTest.java</file>
			<file type="M">org.apache.camel.component.vm.VmComponent.java</file>
			<file type="M">org.apache.camel.component.file.FileNoOpLockFileTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="517" opendate="2008-05-16 03:58:22" fixdate="2008-05-26 19:24:48" resolution="Fixed">
		<buginformation>
			<summary>Javadoc - improve summaries etc</summary>
			<description>The javadoc could use to be polished for eg. summaries statis the Apache license instead of a short brief summary what the class/package does etc.
It&amp;amp;apos;s all the javadoc also for the components.</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.SpringInstrumentationAgent.java</file>
			<file type="M">org.apache.camel.impl.DefaultExchange.java</file>
			<file type="M">org.apache.camel.builder.xml.Namespaces.java</file>
			<file type="M">org.apache.camel.impl.DefaultEndpoint.java</file>
			<file type="M">org.apache.camel.component.bean.BeanComponent.java</file>
			<file type="M">org.apache.camel.converter.jaxp.DomConverter.java</file>
			<file type="M">org.apache.camel.processor.ThrowFaultProcessor.java</file>
			<file type="M">org.apache.camel.impl.converter.AnnotationTypeConverterLoader.java</file>
			<file type="M">org.apache.camel.util.IntrospectionSupport.java</file>
			<file type="M">org.apache.camel.component.jmx.JMXEndpoint.java</file>
			<file type="M">org.apache.camel.component.direct.DirectEndpoint.java</file>
			<file type="M">org.apache.camel.component.bean.XPathAnnotationExpressionFactory.java</file>
			<file type="M">org.apache.camel.management.DefaultInstrumentationAgent.java</file>
			<file type="M">org.apache.camel.converter.ObjectConverter.java</file>
			<file type="M">org.apache.camel.component.bean.MethodInvocation.java</file>
			<file type="M">org.apache.camel.builder.xml.DomResultHandlerFactory.java</file>
			<file type="M">org.apache.camel.converter.jaxp.StringSource.java</file>
			<file type="M">org.apache.camel.impl.DefaultUnitOfWork.java</file>
			<file type="M">org.apache.camel.management.InstrumentationProcessor.java</file>
			<file type="M">org.apache.camel.processor.TryProcessor.java</file>
			<file type="M">org.apache.camel.ExchangePattern.java</file>
			<file type="M">org.apache.camel.util.UuidGenerator.java</file>
			<file type="M">org.apache.camel.impl.SerializationDataFormat.java</file>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
			<file type="M">org.apache.camel.converter.jaxp.XmlConverter.java</file>
			<file type="M">org.apache.camel.component.bean.DefaultAnnotationExpressionFactory.java</file>
			<file type="M">org.apache.camel.converter.CamelConverter.java</file>
			<file type="M">org.apache.camel.converter.CollectionConverter.java</file>
			<file type="M">org.apache.camel.impl.converter.ArrayTypeConverter.java</file>
			<file type="M">org.apache.camel.impl.converter.EnumTypeConverter.java</file>
			<file type="M">org.apache.camel.impl.ProducerCache.java</file>
			<file type="M">org.apache.camel.component.bean.BeanProcessor.java</file>
			<file type="M">org.apache.camel.util.DefaultTimeoutMap.java</file>
			<file type="M">org.apache.camel.builder.xml.MessageVariableResolver.java</file>
			<file type="M">org.apache.camel.component.timer.TimerEndpoint.java</file>
			<file type="M">org.apache.camel.component.bean.BeanHolder.java</file>
			<file type="M">org.apache.camel.component.jmx.JMXConsumer.java</file>
			<file type="M">org.apache.camel.component.vm.VmComponent.java</file>
			<file type="M">org.apache.camel.builder.xml.StreamResultHandlerFactory.java</file>
			<file type="M">org.apache.camel.processor.resequencer.SequenceSender.java</file>
			<file type="M">org.apache.camel.builder.xml.ResultHandlerFactory.java</file>
			<file type="M">org.apache.camel.impl.DefaultRouteContext.java</file>
			<file type="M">org.apache.camel.component.dataset.DataSet.java</file>
			<file type="M">org.apache.camel.management.CamelNamingStrategy.java</file>
			<file type="M">org.apache.camel.impl.MessageSupport.java</file>
			<file type="M">org.apache.camel.processor.resequencer.ResequencerEngine.java</file>
			<file type="M">org.apache.camel.builder.xml.ResultHandler.java</file>
			<file type="M">org.apache.camel.model.MulticastType.java</file>
			<file type="M">org.apache.camel.model.FinallyType.java</file>
			<file type="M">org.apache.camel.model.LoadBalanceType.java</file>
			<file type="M">org.apache.camel.model.ChoiceType.java</file>
			<file type="M">org.apache.camel.model.TransformType.java</file>
			<file type="M">org.apache.camel.model.ThrottlerType.java</file>
			<file type="M">org.apache.camel.model.WhenType.java</file>
			<file type="M">org.apache.camel.model.HandleFaultType.java</file>
			<file type="M">org.apache.camel.model.ProceedType.java</file>
			<file type="M">org.apache.camel.model.ProcessorRef.java</file>
			<file type="M">org.apache.camel.model.ThrowFaultType.java</file>
			<file type="M">org.apache.camel.model.InterceptType.java</file>
			<file type="M">org.apache.camel.model.loadbalancer.TopicLoadBalanceStrategy.java</file>
			<file type="M">org.apache.camel.model.IdentifiedType.java</file>
			<file type="M">org.apache.camel.model.loadbalancer.StickyLoadBalanceStrategy.java</file>
			<file type="M">org.apache.camel.model.CompletedPredicate.java</file>
			<file type="M">org.apache.camel.model.RoutingSlipType.java</file>
			<file type="M">org.apache.camel.model.dataformat.DataFormatType.java</file>
			<file type="M">org.apache.camel.model.BeanRef.java</file>
			<file type="M">org.apache.camel.model.loadbalancer.LoadBalancerType.java</file>
			<file type="M">org.apache.camel.model.PolicyRef.java</file>
			<file type="M">org.apache.camel.model.FilterType.java</file>
			<file type="M">org.apache.camel.model.loadbalancer.RandomLoadBalanceStrategy.java</file>
			<file type="M">org.apache.camel.model.InterceptorRef.java</file>
			<file type="M">org.apache.camel.model.ConvertBodyType.java</file>
			<file type="M">org.apache.camel.model.ResequencerType.java</file>
			<file type="M">org.apache.camel.model.RedeliveryPolicyType.java</file>
			<file type="M">org.apache.camel.model.ExceptionType.java</file>
			<file type="M">org.apache.camel.model.RouteBuilderRef.java</file>
			<file type="M">org.apache.camel.model.OtherwiseType.java</file>
			<file type="M">org.apache.camel.model.CatchType.java</file>
			<file type="M">org.apache.camel.model.Block.java</file>
			<file type="M">org.apache.camel.model.TryType.java</file>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
			<file type="M">org.apache.camel.model.loadbalancer.RoundRobinLoadBalanceStrategy.java</file>
			<file type="M">org.apache.camel.model.IdempotentConsumerType.java</file>
			<file type="M">org.apache.camel.model.RecipientListType.java</file>
			<file type="M">org.apache.camel.model.RouteContainer.java</file>
			<file type="M">org.apache.camel.model.AggregatorType.java</file>
			<file type="M">org.apache.camel.model.InterceptorType.java</file>
			<file type="M">org.apache.camel.model.DelayerType.java</file>
			<file type="M">org.apache.camel.model.SetHeaderType.java</file>
			<file type="M">org.apache.camel.model.SplitterType.java</file>
			<file type="M">org.apache.camel.model.ServiceActivationType.java</file>
			<file type="M">org.apache.camel.management.JmxInstrumentationUsingPropertiesTest.java</file>
			<file type="D">org.apache.camel.management.InstrumentationAgentImpl.java</file>
			<file type="M">org.apache.camel.management.JmxInstrumentationUsingPlatformMBSTest.java</file>
			<file type="M">org.apache.camel.management.JmxInstrumentationUsingDefaultsTest.java</file>
			<file type="M">org.apache.camel.impl.ReportingTypeConverterRegistry.java</file>
			<file type="M">org.apache.camel.impl.ReportingTypeConverterLoader.java</file>
			<file type="M">org.apache.camel.component.jms.JmsProducer.java</file>
			<file type="M">org.apache.camel.management.InstrumentationLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.component.mock.MockEndpoint.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
			<file type="M">org.apache.camel.builder.BuilderWithScopesTest.java</file>
			<file type="M">org.apache.camel.component.file.FileEndpoint.java</file>
			<file type="M">org.apache.camel.builder.BuilderSupport.java</file>
			<file type="M">org.apache.camel.processor.loadbalancer.StickyLoadBalancer.java</file>
			<file type="M">org.apache.camel.processor.idempotent.MemoryMessageIdRepository.java</file>
			<file type="M">org.apache.camel.spi.ComponentResolver.java</file>
			<file type="M">org.apache.camel.impl.converter.AsyncProcessorTypeConverter.java</file>
			<file type="M">org.apache.camel.util.AsyncProcessorHelper.java</file>
			<file type="M">org.apache.camel.processor.LoadBalanceTest.java</file>
			<file type="M">org.apache.camel.impl.converter.DefaultTypeConverter.java</file>
			<file type="M">org.apache.camel.processor.InterceptWithoutProceedRouteTest.java</file>
			<file type="M">org.apache.camel.model.dataformat.CsvDataFormat.java</file>
			<file type="M">org.apache.camel.view.DotViewTest.java</file>
			<file type="M">org.apache.camel.component.dataset.DataSetConsumeTest.java</file>
			<file type="M">org.apache.camel.processor.ChoiceTest.java</file>
			<file type="M">org.apache.camel.component.dataset.DataSetComponent.java</file>
			<file type="M">org.apache.camel.processor.DataFormatTest.java</file>
			<file type="M">org.apache.camel.processor.InterceptWithPredicateAndProceedRouteTest.java</file>
			<file type="M">org.apache.camel.processor.MultiCastAggregatorTest.java</file>
			<file type="M">org.apache.camel.processor.ValidationTest.java</file>
			<file type="M">org.apache.camel.processor.RecipientListTest.java</file>
			<file type="M">org.apache.camel.builder.NoErrorHandlerBuilder.java</file>
			<file type="M">org.apache.camel.processor.XPathChoiceTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultConsumer.java</file>
			<file type="M">org.apache.camel.processor.UnitOfWorkProcessor.java</file>
			<file type="M">org.apache.camel.processor.LoggingErrorHandler.java</file>
			<file type="M">org.apache.camel.processor.StaticRecipientListTest.java</file>
			<file type="M">org.apache.camel.processor.InterceptWithPredicateRouteTest.java</file>
			<file type="M">org.apache.camel.processor.DelegateAsyncProcessor.java</file>
			<file type="M">org.apache.camel.processor.MulticastTest.java</file>
			<file type="M">org.apache.camel.processor.ThreadTest.java</file>
			<file type="M">org.apache.camel.LanguageTestSupport.java</file>
			<file type="M">org.apache.camel.converter.stream.StreamCacheConverterTest.java</file>
			<file type="M">org.apache.camel.builder.xml.XPathTest.java</file>
			<file type="M">org.apache.camel.component.file.DirectoryCreateIssueTest.java</file>
			<file type="M">org.apache.camel.component.bean.BeanMethodWithMultipleParametersTest.java</file>
			<file type="D">org.apache.camel.util.Out.java</file>
			<file type="M">org.apache.camel.util.URISupport.java</file>
			<file type="M">org.apache.camel.util.IOHelper.java</file>
			<file type="M">org.apache.camel.util.UnsafeUriCharactersEncoder.java</file>
			<file type="M">org.apache.camel.util.FactoryFinder.java</file>
			<file type="M">org.apache.camel.util.TimeoutMap.java</file>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.impl.converter.TypeConverterRegistry.java</file>
			<file type="M">org.apache.camel.impl.converter.PropertyEditorTypeConverter.java</file>
			<file type="M">org.apache.camel.converter.stream.StreamCacheConverter.java</file>
			<file type="M">org.apache.camel.impl.DefaultExchangeConverter.java</file>
			<file type="M">org.apache.camel.spi.Injector.java</file>
			<file type="M">org.apache.camel.impl.DefaultLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.impl.DefaultLanguageResolver.java</file>
			<file type="M">org.apache.camel.impl.converter.TypeConverterLoader.java</file>
			<file type="M">org.apache.camel.component.jmx.JMXExchange.java</file>
			<file type="M">org.apache.camel.component.seda.ListPollingConsumer.java</file>
			<file type="M">org.apache.camel.component.file.FileProducer.java</file>
			<file type="M">org.apache.camel.component.log.LogComponent.java</file>
			<file type="M">org.apache.camel.component.seda.SedaConsumer.java</file>
			<file type="M">org.apache.camel.processor.loadbalancer.TopicLoadBalancer.java</file>
			<file type="M">org.apache.camel.component.file.FileMessage.java</file>
			<file type="M">org.apache.camel.component.list.ListEndpoint.java</file>
			<file type="M">org.apache.camel.component.jmx.JMXComponent.java</file>
			<file type="M">org.apache.camel.component.list.ListComponent.java</file>
			<file type="M">org.apache.camel.component.timer.TimerConsumer.java</file>
			<file type="M">org.apache.camel.component.bean.BeanEndpoint.java</file>
			<file type="M">org.apache.camel.component.bean.BeanInvocation.java</file>
			<file type="M">org.apache.camel.component.dataset.DataSetSupport.java</file>
			<file type="M">org.apache.camel.component.bean.BeanExchange.java</file>
			<file type="M">org.apache.camel.component.dataset.DataSetEndpoint.java</file>
			<file type="M">org.apache.camel.component.dataset.DataSetConsumer.java</file>
			<file type="M">org.apache.camel.component.direct.DirectProducer.java</file>
			<file type="M">org.apache.camel.component.bean.ParameterInfo.java</file>
			<file type="M">org.apache.camel.component.bean.MethodInfo.java</file>
			<file type="M">org.apache.camel.component.bean.NoBeanAvailableException.java</file>
			<file type="M">org.apache.camel.processor.validation.ValidatorErrorHandler.java</file>
			<file type="M">org.apache.camel.builder.DataFormatClause.java</file>
			<file type="M">org.apache.camel.language.LanguageExpression.java</file>
			<file type="M">org.apache.camel.builder.xml.StringResultHandlerFactory.java</file>
			<file type="M">org.apache.camel.language.ExpressionEvaluationException.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilder.java</file>
			<file type="M">org.apache.camel.processor.FilterProcessor.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilderSupport.java</file>
			<file type="M">org.apache.camel.processor.CatchProcessor.java</file>
			<file type="M">org.apache.camel.processor.exceptionpolicy.ExceptionPolicyStrategy.java</file>
			<file type="M">org.apache.camel.builder.PredicateFactory.java</file>
			<file type="M">org.apache.camel.language.LanguageAnnotation.java</file>
			<file type="M">org.apache.camel.language.bean.RuntimeBeanExpressionException.java</file>
			<file type="M">org.apache.camel.builder.xml.XPathLanguage.java</file>
			<file type="M">org.apache.camel.builder.ConstantProcessorBuilder.java</file>
			<file type="M">org.apache.camel.builder.ExpressionBuilder.java</file>
			<file type="M">org.apache.camel.spi.InstrumentationAgent.java</file>
			<file type="M">org.apache.camel.spi.LifecycleStrategy.java</file>
			<file type="M">org.apache.camel.processor.ThroughputLogger.java</file>
			<file type="M">org.apache.camel.processor.SendProcessor.java</file>
			<file type="M">org.apache.camel.processor.aggregate.UseLatestAggregationStrategy.java</file>
			<file type="M">org.apache.camel.InvalidHeaderTypeException.java</file>
			<file type="M">org.apache.camel.InvalidPayloadException.java</file>
			<file type="M">org.apache.camel.CamelException.java</file>
			<file type="M">org.apache.camel.ProducerTemplate.java</file>
			<file type="M">org.apache.camel.RuntimeCamelException.java</file>
			<file type="M">org.apache.camel.FailedToCreateProducerException.java</file>
			<file type="M">org.apache.camel.AlreadyStoppedException.java</file>
			<file type="M">org.apache.camel.impl.ServiceSupport.java</file>
			<file type="M">org.apache.camel.InvalidPayloadRuntimeException.java</file>
			<file type="M">org.apache.camel.InvalidTypeException.java</file>
			<file type="M">org.apache.camel.CamelTemplate.java</file>
			<file type="M">org.apache.camel.model.language.MethodCallExpression.java</file>
			<file type="M">org.apache.camel.language.simple.SimpleLanguage.java</file>
		</fixedFiles>
	</bug>
	<bug id="561" opendate="2008-05-30 08:06:25" fixdate="2008-05-30 08:37:36" resolution="Fixed">
		<buginformation>
			<summary>some samples&amp;apos; poms are using apache-activemq module which will introduce some lower version of Spring and wstx-asl to the eclipse workspace</summary>
			<description>When using mvn eclipse:eclipse to setup the workspace for camel example to run. 
I found some camel-cxf related example can&amp;amp;apos;t work in eclipse which is caused by using the lower version of wstx-asl.
We can using the activemq-core instead of apache-activemq to fix this issue.</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.example.cxf.Server.java</file>
		</fixedFiles>
	</bug>
	<bug id="562" opendate="2008-05-30 08:32:35" fixdate="2008-05-31 15:08:37" resolution="Fixed">
		<buginformation>
			<summary>camel-example-jms-file can&amp;apos;t work within the Camel 1.4.0 snapshot</summary>
			<description>The stack trace :
SEVERE: Failed delivery for exchangeId: ID-TsingTao/53940-1212136063400/0-0. On delivery attempt: 0 caught: java.io.FileNotFoundException: target\ID:TsingTao-53937-1212136063115-2:1:1:1:1 (The filename, directory name, or volume label syntax is incorrect)
java.io.FileNotFoundException: target\ID:TsingTao-53937-1212136063115-2:1:1:1:1 (The filename, directory name, or volume label syntax is incorrect)
	at java.io.RandomAccessFile.open(Native Method)
	at java.io.RandomAccessFile.&amp;lt;init&amp;gt;(RandomAccessFile.java:212)
	at org.apache.camel.component.file.FileProducer.process(FileProducer.java:76)
	at org.apache.camel.component.file.FileProducer.process(FileProducer.java:54)
	at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsyncProcessorBridge.process(AsyncProcessorTypeConverter.java:43)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:75)
	at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:146)
	at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:90)
	at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:39)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:41)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:66)
	at org.apache.camel.component.jms.EndpointMessageListener.onMessage(EndpointMessageListener.java:67)
	at org.springframework.jms.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:531)
	at org.springframework.jms.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:466)
	at org.springframework.jms.listener.AbstractMessageListenerContainer.doExecuteListener(AbstractMessageListenerContainer.java:435)
	at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.doReceiveAndExecute(AbstractPollingMessageListenerContainer.java:322)
	at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:260)
	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:944)
	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:875)
	at java.lang.Thread.run(Thread.java:595)
BTW, The sample is workable with Camel-1.3.0.</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.UuidGenerator.java</file>
			<file type="M">org.apache.camel.component.file.FileProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="567" opendate="2008-06-01 09:34:58" fixdate="2008-06-01 09:44:08" resolution="Fixed">
		<buginformation>
			<summary>camel-route archetype missing depends on camel-core</summary>
			<description>When creating a new camel route project using maven archetype there is no dependeny on camel-core. This should be added.
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.apache.camel&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;camel-core&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;$
{camel-version}
&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsRouteRequestReplyTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="566" opendate="2008-06-01 08:13:26" fixdate="2008-06-01 14:58:55" resolution="Fixed">
		<buginformation>
			<summary>CamelInvoker fail if operationName in the wsdl portype begin with uppercase</summary>
			<description>the generated method name in java file is always begin with lower case, but the operationName in the servicemodel begin with uppercase per the wsdl, this mismatch will cause the invocation fail throwing NO_OPERATION_FOUND exception
we should set CxfConstants.OPERATION_NAME as the one from servicemodel</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CamelInvoker.java</file>
		</fixedFiles>
	</bug>
	<bug id="574" opendate="2008-06-04 01:42:58" fixdate="2008-06-04 02:38:07" resolution="Fixed">
		<buginformation>
			<summary>Multicast default excecutor do not create the enough thread for parallel processing </summary>
			<description>When I added the loan broker example CAMEL-556, I found there is no performance improvement when using the parallelly mulitcast.
After digging into to code, I found we should create the enough thread for the parallel processing.</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="581" opendate="2008-06-05 09:13:58" fixdate="2008-06-06 05:14:07" resolution="Fixed">
		<buginformation>
			<summary>CamelTemplate should clear endpoint cache when stopping</summary>
			<description>Only the producer cache is stopped and cleared

  // start and stop in camel template

    protected void doStart() throws Exception {
        producerCache.start();
    }

    protected void doStop() throws Exception {
        producerCache.stop();
    }


  // stop in producer cache
    protected void doStop() throws Exception {
        ServiceHelper.stopServices(producers.values());
        producers.clear();
    }

</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultProducerTemplate.java</file>
			<file type="M">org.apache.camel.component.dataset.DataSetEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="584" opendate="2008-06-06 11:33:22" fixdate="2008-06-06 12:27:33" resolution="Fixed">
		<buginformation>
			<summary>BeanWithPropertiesAndHeadersAndBodyInjectionTest causes java.lang.StackOverflowError</summary>
			<description>This unit test cases infinitive loop

Caused by: java.lang.StackOverflowError
	at java.util.HashMap$HashIterator.&amp;lt;init&amp;gt;(HashMap.java:822)
	at java.util.HashMap$EntryIterator.&amp;lt;init&amp;gt;(HashMap.java:881)
	at java.util.HashMap$EntryIterator.&amp;lt;init&amp;gt;(HashMap.java:881)
	at java.util.HashMap.newEntryIterator(HashMap.java:895)
	at java.util.HashMap$EntrySet.iterator(HashMap.java:988)
	at java.util.AbstractMap.toString(AbstractMap.java:584)
	at java.lang.String.valueOf(String.java:2615)
	at java.lang.StringBuilder.append(StringBuilder.java:116)
	at org.apache.camel.component.bean.BeanWithPropertiesAndHeadersAndBodyInjectionTest$MyBean.toString(BeanWithPropertiesAndHeadersAndBodyInjectionTest.java:91)
	at java.lang.String.valueOf(String.java:2615)
	at java.lang.StringBuffer.append(StringBuffer.java:220)
	at java.util.AbstractMap.toString(AbstractMap.java:598)
	at java.lang.String.valueOf(String.java:2615)
	at java.lang.StringBuilder.append(StringBuilder.java:116)
	at org.apache.camel.component.bean.BeanWithPropertiesAndHeadersAndBodyInjectionTest$MyBean.toString(BeanWithPropertiesAndHeadersAndBodyInjectionTest.java:91)
	at java.lang.String.valueOf(String.java:2615)

</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanProcessor.java</file>
			<file type="M">org.apache.camel.component.bean.BeanWithPropertiesAndHeadersAndBodyInjectionTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="583" opendate="2008-06-06 08:32:15" fixdate="2008-06-07 14:24:35" resolution="Fixed">
		<buginformation>
			<summary>JAXB - Unit test failing - DumpToXmlTest</summary>
			<description>The unit test in camel-jaxb is failing DumpToXmlTest
However since there are no assertions its not failing the build.

2008-06-06 10:31:16,546 [mponent@15ee671] ERROR DeadLetterChannel              - Failed delivery for exchangeId: ID-claus-acer/1691-1212741073109/0-0. On delivery attempt: 3 caught: org.apache.camel.RuntimeCamelException: com.sun.xml.bind.v2
notationExceptions
XmlElementRef points to a non-existent class.
        this problem is related to the following location:
                at java.util.List org.apache.camel.converter.jaxb.MessageType.headers
                at org.apache.camel.converter.jaxb.MessageType

org.apache.camel.RuntimeCamelException: com.sun.xml.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions
XmlElementRef points to a non-existent class.
        this problem is related to the following location:
                at java.util.List org.apache.camel.converter.jaxb.MessageType.headers
                at org.apache.camel.converter.jaxb.MessageType

        at org.apache.camel.converter.jaxb.FallbackTypeConverter.convertTo(FallbackTypeConverter.java:70)
        at org.apache.camel.impl.converter.DefaultTypeConverter.convertTo(DefaultTypeConverter.java:71)
        at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:52)
        at org.apache.camel.processor.ConvertBodyProcessor.process(ConvertBodyProcessor.java:40)
        at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsyncProcessorBridge.process(AsyncProcessorTypeConverter.java:43)
        at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:146)
        at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:90)
        at org.apache.camel.processor.Pipeline.process(Pipeline.java:101)
        at org.apache.camel.processor.Pipeline.process(Pipeline.java:85)
        at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:39)
        at org.apache.camel.component.file.FileConsumer.pollFile(FileConsumer.java:128)
        at org.apache.camel.component.file.FileConsumer.pollFileOrDirectory(FileConsumer.java:77)
        at org.apache.camel.component.file.FileConsumer.pollFileOrDirectory(FileConsumer.java:84)
        at org.apache.camel.component.file.FileConsumer.poll(FileConsumer.java:57)
        at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:65)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:417)
        at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:280)
        at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:135)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:65)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:142)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:166)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675)
        at java.lang.Thread.run(Thread.java:595)
Caused by: com.sun.xml.bind.v2.runtime.IllegalAnnotationsException: 1 counts of IllegalAnnotationExceptions
XmlElementRef points to a non-existent class.
        this problem is related to the following location:
                at java.util.List org.apache.camel.converter.jaxb.MessageType.headers
                at org.apache.camel.converter.jaxb.MessageType

        at com.sun.xml.bind.v2.runtime.IllegalAnnotationsException$Builder.check(IllegalAnnotationsException.java:66)
        at com.sun.xml.bind.v2.runtime.JAXBContextImpl.getTypeInfoSet(JAXBContextImpl.java:422)
        at com.sun.xml.bind.v2.runtime.JAXBContextImpl.&amp;lt;init&amp;gt;(JAXBContextImpl.java:270)
        at com.sun.xml.bind.v2.ContextFactory.createContext(ContextFactory.java:103)
        at com.sun.xml.bind.v2.ContextFactory.createContext(ContextFactory.java:81)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:585)
        at javax.xml.bind.ContextFinder.newInstance(ContextFinder.java:211)
        at javax.xml.bind.ContextFinder.find(ContextFinder.java:372)
        at javax.xml.bind.JAXBContext.newInstance(JAXBContext.java:574)
        at javax.xml.bind.JAXBContext.newInstance(JAXBContext.java:522)
        at org.apache.camel.converter.jaxb.FallbackTypeConverter.createContext(FallbackTypeConverter.java:141)
        at org.apache.camel.converter.jaxb.FallbackTypeConverter.unmarshall(FallbackTypeConverter.java:84)
        at org.apache.camel.converter.jaxb.FallbackTypeConverter.convertTo(FallbackTypeConverter.java:61)
        ... 23 more

</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.jaxb.DumpToXmlTest.java</file>
			<file type="M">org.apache.camel.converter.jaxb.MessageType.java</file>
			<file type="M">org.apache.camel.converter.jaxb.MessageTypeTest.java</file>
			<file type="M">org.apache.camel.example.JAXBConvertTest.java</file>
			<file type="M">org.apache.camel.example.UnmarshalTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="547" opendate="2008-05-24 16:40:51" fixdate="2008-06-08 11:22:32" resolution="Duplicate">
		<buginformation>
			<summary>remove cycle between builder and spi</summary>
			<description>Currently the spi package references builder.RouteBuilder. This creates a bad cycle in Camel as builder is one of the top level packages and spi is one of the lowest level packages. The method where RouteBuilder is used is in CamelContext.addRoutes(RouteBuilder builder). I think this reference is not necessary. CamelContext already has a method addRoutes(Collection&amp;lt;Route&amp;gt; routes). 
So instead of calling camelContext.addRoutes(builder) I think the better way would to call:
builder.setContext(camelContext);
builder.addRoutesToContext(); // This is a new method that replaces the functionality of CamelContext.addRoutes(RouteBuilder builder)
This way we will also cut some part of the cycle between impl and builder. impl.DefaultCamelContext references both RouteBuilder and BuilderSupport from the builder package. Both will not be necessary anymore as as soon as we get rid of the addRoutes method.
This way CamelContext does not have to know anything about its builder. What do you think about this change?</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.CamelContext.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilder.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.model.InterceptType.java</file>
			<file type="M">org.apache.camel.model.dataformat.JaxbDataFormat.java</file>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.spi.RouteContext.java</file>
			<file type="M">org.apache.camel.processor.Interceptor.java</file>
			<file type="M">org.apache.camel.converter.ObjectConverter.java</file>
			<file type="M">org.apache.camel.impl.DefaultRouteContext.java</file>
			<file type="M">org.apache.camel.Processor.java</file>
		</fixedFiles>
		<links>
			<link type="Supercedes" description="is superceded by">588</link>
		</links>
	</bug>
	<bug id="593" opendate="2008-06-08 21:59:59" fixdate="2008-06-09 08:23:38" resolution="Fixed">
		<buginformation>
			<summary>[patch] Make sure streams get closed</summary>
			<description>a couple places streams are opened and are not closed. patch fixes this.</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.PackageHelper.java</file>
			<file type="M">org.apache.camel.component.file.FileEndpoint.java</file>
			<file type="M">org.apache.camel.converter.NIOConverter.java</file>
			<file type="M">org.apache.camel.model.RedeliveryPolicyType.java</file>
			<file type="M">org.apache.camel.management.CamelNamingStrategy.java</file>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannel.java</file>
			<file type="M">org.apache.camel.util.ResolverUtil.java</file>
			<file type="M">org.apache.camel.converter.ObjectConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="597" opendate="2008-06-09 17:51:10" fixdate="2008-06-09 18:50:35" resolution="Fixed">
		<buginformation>
			<summary>[patch] faulty ctor initialization</summary>
			<description>JmsQueueEndpoint has faulty initialization logic, checking a parameter and if null, setting that parameter. The code should be setting the member variable instead.
Code was
     public JmsQueueEndpoint(String uri, JmsComponent component, String destination,
             JmsConfiguration configuration, QueueBrowseStrategy queueBrowseStrategy) {
         super(uri, component, destination, false, configuration);
         this.queueBrowseStrategy = queueBrowseStrategy;
         if (queueBrowseStrategy == null) 
{
            queueBrowseStrategy = createQueueBrowseStrategy();
         }
     }
patch fixes this (two places)</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsQueueEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="587" opendate="2008-06-08 08:31:08" fixdate="2008-06-11 02:06:29" resolution="Fixed">
		<buginformation>
			<summary>Can&amp;apos;t switch to log4j in the camel-cxf component</summary>
			<description>Need to make sure we Use CXF LogUtils to get logger , so we can switch the logger from java.utils.Logger to log4j.</description>
			<version>1.2.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.feature.PayLoadDataFormatFeature.java</file>
			<file type="M">org.apache.camel.component.cxf.invoker.RawMessageInvokingContext.java</file>
			<file type="M">org.apache.camel.component.cxf.invoker.PayloadInvokingContext.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.CamelInvoker.java</file>
			<file type="M">org.apache.camel.component.cxf.invoker.CxfClient.java</file>
			<file type="M">org.apache.camel.component.cxf.interceptors.AbstractMessageInInterceptor.java</file>
			<file type="M">org.apache.camel.component.cxf.invoker.AbstractInvokingContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="558" opendate="2008-05-29 07:57:05" fixdate="2008-06-12 10:30:33" resolution="Fixed">
		<buginformation>
			<summary>Scanning for Type Converters doesn&amp;apos;t work in OSGi</summary>
			<description>Even the core type converters could not be loaded:
18:26:04,982 | ERROR | ExtenderThread-4 | ResolverUtil | g.apache.camel.util.ResolverUtil  364 | Could not search jar file &amp;amp;apos;/org/apache/camel/converter&amp;amp;apos; for classes matching criteria: annotated with @Converterdue to an IOException: /org/apache/camel/converter (No such file or directory) </description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ResolverUtil.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">577</link>
		</links>
	</bug>
	<bug id="462" opendate="2008-04-14 04:26:57" fixdate="2008-06-18 15:23:47" resolution="Duplicate">
		<buginformation>
			<summary>Intercept logging seda sometimes produces more exchanges than expected</summary>
			<description>Working on the previous issue with the intercept to log every step failed I discovered that using the seda queues on some unit tests I got more messages than expected.

    intercept().to("log:foo").proceed();

    from("seda:foo").to("seda:bar");
    from("seda:bar").to("seda:baz");
    from("seda:baz").to("mock:result");


Will sometimes result in 3 messages incoming to mock:result.

java.lang.AssertionError: mock:result Received message count. Expected: &amp;lt;1&amp;gt; but was: &amp;lt;3&amp;gt;
	at org.apache.camel.component.mock.MockEndpoint.fail(MockEndpoint.java:658)

</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.RoutesType.java</file>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
			<file type="M">org.apache.camel.model.InterceptType.java</file>
			<file type="M">org.apache.camel.issues.InterceptorLogTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">482</link>
			<link type="dependent" description="depends upon">461</link>
		</links>
	</bug>
	<bug id="482" opendate="2008-04-24 21:30:28" fixdate="2008-06-19 01:26:28" resolution="Fixed">
		<buginformation>
			<summary>Incorrect behavior of intercept() if more than one route configured</summary>
			<description>With the RouteBuilder defining more than one route, the intercept() will actually have one instance of the interceptor shared among routes which causes the odd behavior of proceeding to a destination in all routes.  For instance in the example below, sending a message to "direct:foo" will cause both "mock:one" and "mock:two" to receive a message.

    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                intercept().to("log:foo").proceed();

                from("direct:foo").to("mock:one");
                from("direct:bar").to("mock:two");
            }
        };
    }

</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.RoutesType.java</file>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
			<file type="M">org.apache.camel.model.InterceptType.java</file>
			<file type="M">org.apache.camel.issues.InterceptorLogTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">462</link>
		</links>
	</bug>
	<bug id="618" opendate="2008-06-19 15:25:05" fixdate="2008-06-19 16:57:56" resolution="Fixed">
		<buginformation>
			<summary>Oracle AQ contains a typo "JMSXRecvTimeStamp" -- the JMS spec lists  the correct spelling as "JMSXRcvTimeStamp". Camel&amp;apos;s JmsBinding also has the correct spelling, but can be patched to prevent Oracle AQ from puking.</summary>
			<description>http://www.nabble.com/%28Fixed-%29-Updated---Help-w--Oracle-JMS-and-AQjmsException-%28JMS-147%29-td17989368s22882.html
Oracle&amp;amp;apos;s Message implementation (AQjmsMessage) has a typo, I am pretty certain that it exists as "JMSXRecvTimeStamp". To workaround this typo I patched org.apache.camel.component.jms.JMSBinding to include the misspelled property name in set of ignored headers/properties.
Additionally, I believe Oracle might be setting null values for empty or missing standard and optional JMS reserved properties/headers. Most notably JMSReplyTo. This is resulting in JMSBinding attempting to set a null Destination on the JMSReplyTo header which then results in an Oracle exception. A quick patch was to check for null values and ignore them in the method JmsBinding.appendJmsProperties() for the JMSReplyTo header. A better fix is probably to prevent empty/blank headers or properties from originating at the Oracle level... assuming nulls/blanks are not allowed by the JMS 1.1 spec.
Anyhoo, I will attach some diff patches to this issue for your review. 
Cheers!
Seon</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="612" opendate="2008-06-16 06:38:46" fixdate="2008-06-23 12:41:58" resolution="Fixed">
		<buginformation>
			<summary>Exchange should end in error when no choice in a ChoiceType matches</summary>
			<description>When you define a route with a choice() and no matching when() clause is found, the Exchange just ends successfully without doing anything.  In my mind, it should fail by default in this case (or we should at least have an easy way to get this behavior).

from(DIRECT_ROUTER).choice()
  .when(xpath("/oc:order_confirmation/oc:order/oc:customer/@category = &amp;amp;apos;140&amp;amp;apos;"))
    .to(DIRECT_CUSTOMER1)
  .when(xpath("/oc:order_confirmation/oc:order/oc:customer/@category = &amp;amp;apos;116&amp;amp;apos;"))
    .to(DIRECT_CUSTOMER2);

</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ChoiceType.java</file>
		</fixedFiles>
	</bug>
	<bug id="629" opendate="2008-06-23 13:02:34" fixdate="2008-06-23 13:33:14" resolution="Fixed">
		<buginformation>
			<summary>Re-add getContext/setContext to Endpoint as deprecated methods to improve backward compatibilty</summary>
			<description>In recent refactorings, the getContext()/setContext() methods on Endpoint were renamed to getCamelContext()/setCamelContext().  As discussed recently (http://www.nabble.com/Deprecating-old-methods-and-changing-the-default-error-handler-td17998268s22882.html), it would be better to use deprecation for now and only actually remove the method on our next big release.</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultEndpoint.java</file>
			<file type="M">org.apache.camel.Endpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSoapEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="631" opendate="2008-06-23 19:04:43" fixdate="2008-06-23 23:31:46" resolution="Fixed">
		<buginformation>
			<summary>Camel won&amp;apos;t compile on AIX</summary>
			<description>Failure is:
[INFO] ------------------------------------------------------------------------
[ERROR] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Compilation failure
/x1/camel/camel-core/src/main/java/org/apache/camel/model/ProcessorType.java:[1587,18] inconvertible types
found   : org.apache.camel.model.ProcessorType&amp;lt;Type&amp;gt;
required: org.apache.camel.model.ExceptionType
/x1/camel/camel-core/src/main/java/org/apache/camel/model/ProcessorType.java:[1587,51] inconvertible types
found   : org.apache.camel.model.ProcessorType&amp;lt;Type&amp;gt;
required: org.apache.camel.model.TryType
/x1/camel/camel-core/src/main/java/org/apache/camel/model/InterceptType.java:[90,16] inconvertible types
found   : org.apache.camel.model.ProcessorType&amp;lt;capture of ?&amp;gt;
required: org.apache.camel.model.ChoiceType
/x1/camel/camel-core/src/main/java/org/apache/camel/model/InterceptType.java:[91,49] inconvertible types
found   : org.apache.camel.model.ProcessorType&amp;lt;capture of ?&amp;gt;
required: org.apache.camel.model.ChoiceType
/x1/camel/camel-core/src/main/java/org/apache/camel/management/InstrumentationLifecycleStrategy.java:[203,20] inconvertible types
found   : org.apache.camel.model.ProcessorType&amp;lt;capture of ?&amp;gt;
required: org.apache.camel.model.ExceptionType</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
			<file type="M">org.apache.camel.management.InstrumentationLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.model.InterceptType.java</file>
		</fixedFiles>
	</bug>
	<bug id="620" opendate="2008-06-19 22:45:43" fixdate="2008-06-24 04:45:36" resolution="Fixed">
		<buginformation>
			<summary>ResequencerType.createProcessor could throw NPE as stream config does not get initialized.</summary>
			<description>java.lang.NullPointerException
	at org.apache.camel.model.ResequencerType.createStreamResequencer(ResequencerType.java:198)
	at org.apache.camel.model.ResequencerType.createProcessor(ResequencerType.java:163)
	at org.apache.camel.model.ProcessorType.createOutputsProcessor(ProcessorType.java:1584)
	at org.apache.camel.model.ProcessorType.createOutputsProcessor(ProcessorType.java:93)
	at org.apache.camel.model.InterceptorRef.createProcessor(InterceptorRef.java:61)
	at org.apache.camel.model.ProcessorType.makeProcessor(ProcessorType.java:1471)
	at org.apache.camel.model.ProcessorType.addRoutes(ProcessorType.java:97)
	at org.apache.camel.model.RouteType.addRoutes(RouteType.java:210)
	at org.apache.camel.model.RouteType.addRoutes(RouteType.java:80)
	at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:462)
	at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:454)
	at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:47)
	at org.apache.camel.ContextTestSupport.startCamelContext(ContextTestSupport.java:108)
	at org.apache.camel.ContextTestSupport.setUp(ContextTestSupport.java:81)
	at org.apache.camel.processor.ResequencerTest.setUp(ResequencerTest.java:48)
	at junit.framework.TestCase.runBare(TestCase.java:128)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:120)
	at junit.framework.TestSuite.runTest(TestSuite.java:230)
	at junit.framework.TestSuite.run(TestSuite.java:225)
	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:130)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.ResequencerTest.java</file>
			<file type="M">org.apache.camel.processor.StreamResequencerTest.java</file>
			<file type="M">org.apache.camel.model.ResequencerType.java</file>
		</fixedFiles>
	</bug>
	<bug id="634" opendate="2008-06-24 22:09:21" fixdate="2008-07-01 14:29:54" resolution="Fixed">
		<buginformation>
			<summary>DeadLetterChannel default redelivery policy eclipsed expected transactional behaviour in a transacted route</summary>
			<description>Camel routes get a DLC processor with a redelivery policy, which defaults to redeliverying a message to a destination processor up to 6 times.  In case of a transacted route it is preferable that DLC&amp;amp;apos;s delivery policy be reset to a single attempt, so that a fan-out transacted route would not hold tx locks on destinations for too long. 
The DLC&amp;amp;apos;s default redelivery policy has also made transactional tests not really testing tx behavior of Camel Components backed runtimes (jms brokers, etc), rather DLC would catch the exception and try to redeliver the message to destination processor and not letting the components to rollback native transactions initiated by components backed runtimes (jms, db)
The attached patch installs a property into Camel Exchange that indicates weather a route is transacted. This is done in org.apache.camel.spring.spi.TransactionInterceptor.java
DLC then checks if the flow is transacted and sets its redelivery policy to 1
With this change JMS transactions are actually rolled back and messages are put back into the queue and then consumed again, verifying that brokers support transactions and can redeliver messages into Camel routes that were previously rolled back.</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultExchange.java</file>
			<file type="M">org.apache.camel.spring.spi.TransactionInterceptor.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannel.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.component.jms.tx.QueueToQueueRequestReplyTransactionTest.java</file>
			<file type="M">org.apache.camel.component.jms.tx.ConditionalExceptionProcessor.java</file>
			<file type="M">org.apache.camel.component.jms.EndpointMessageListener.java</file>
		</fixedFiles>
	</bug>
	<bug id="651" opendate="2008-06-30 06:55:49" fixdate="2008-07-01 16:27:07" resolution="Fixed">
		<buginformation>
			<summary>BeanProcessor more intelligent choosing of correct method (AOP proxies problems)</summary>
			<description>The example: example-spring-jms using AOP proxies as a part of the enhancer server demonstration to do somekind of audit tracking using aspectj and spring.
However Camel now have trouble picking the correct method (broken in later 1.4-SNAPSHOT) or as the AOP proxied object now has an removeAdvisor(int) method that Camel think it can invoke also.
However the BeanInfo#chooseMethodWithMatchingBody method doens&amp;amp;apos;t consider the MEP pattern (InOut etc). So when there is an Out pattern the method should not be void.</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.MethodInfo.java</file>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
			<file type="M">org.apache.camel.example.client.CamelClientEndpoint.java</file>
			<file type="M">org.apache.camel.example.server.AuditTracker.java</file>
		</fixedFiles>
	</bug>
	<bug id="577" opendate="2008-06-04 08:43:00" fixdate="2008-07-02 09:26:13" resolution="Fixed">
		<buginformation>
			<summary>ResolverUtil can&amp;apos;t resolve class under osgi enviroment</summary>
			<description>in method of 
protected void find(Test test, String packageName, ClassLoader loader) 
it try to load class  from directory or jar, it works for standalone mode.
But if the classloader of the method is osgi bundle class loader, it will fail since the getResource(packgename) return neither directory nor jar
for example, package name is org/apache/camel/convert, then what returned is /org/apache/camel/convert, so both loadImplementationsInDirectory and loadImplementationsInJar doesn&amp;amp;apos;t work in this case</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ResolverUtil.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">558</link>
		</links>
	</bug>
	<bug id="653" opendate="2008-06-30 12:57:16" fixdate="2008-07-02 18:45:20" resolution="Fixed">
		<buginformation>
			<summary>Bean method lost when sending a message from one JMS queue to another</summary>
			<description>I noticed a problem in JmsBinding.java. If Camel has read a JMS message from a queue and that message has a bean method specified in the header ("org.apache.camel.MethodName"), the method header will removed if that message is written to another queue. Here&amp;amp;apos;s the offending code: 
    protected boolean shouldOutputHeader(org.apache.camel.Message camelMessage, String headerName, 
                                         Object headerValue) 
{ 
        return headerValue != null &amp;amp;&amp;amp; !getIgnoreJmsHeaders().contains(headerName) 
               &amp;amp;&amp;amp; ObjectHelper.isJavaIdentifier(headerName); 
    }
 
"org.apache.camel.MethodName" fails the check isJavaIdentifier and is excluded from the headers written to the new message. I&amp;amp;apos;m not sure the purpose of this check, but this might be an unintended side effect. 
The call chain is something like this: 
JmsProducer.process 
JmsBinding.makeJmsMessage 
JmsBinding.appendJmsProperties 
JmsBinding.shouldOutputHeader 
Update: Experimenting later with WebLogic&amp;amp;apos;s JMS, I noticed that WebLogic (9.2) does not allow this header name. Maybe this was the original motivation for this check. In order to be compatible with WebLogic, perhaps the method header name should changed to something like "CamelMethod". I believe this would correct both problems.</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsMessage.java</file>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="657" opendate="2008-07-02 13:19:52" fixdate="2008-07-02 19:08:12" resolution="Fixed">
		<buginformation>
			<summary>CsvDataFormat.marshal never uses custom CSVConfig</summary>
			<description>Affected class: org.apache.camel.dataformat.csv.CsvDataFormat 
Method "marshal" has a strange behaviour. The CSVConfig for the CSVWriter can not be set via setConfig, because "marshal" has this line:

CSVConfig conf = createConfig();


Therefore you can not use your own CSVConfig to adjust marshalling. 
Fix proposal:

remove method createConfig
see unmarshaling with corresponding getter/setter

</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.csv.CsvDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="664" opendate="2008-07-03 21:50:24" fixdate="2008-07-04 06:26:28" resolution="Fixed">
		<buginformation>
			<summary>Operattion namespace never gets set.</summary>
			<description>Operattion namespace never gets set.  As the result, invoking an operation that has a different namespace than the service will not work.</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CamelInvoker.java</file>
		</fixedFiles>
	</bug>
	<bug id="642" opendate="2008-06-27 12:51:28" fixdate="2008-07-04 08:32:51" resolution="Fixed">
		<buginformation>
			<summary>jms aggregation does not work</summary>
			<description>I found this issue when I test  Camel 1.4.0 RC2 kit, I just add a test case to show the error.
https://svn.apache.org/repos/asf/activemq/camel/trunk/components/camel-jms/src/test/java/org/apache/camel/component/jms/AggregratedJmsRouteTest.java
You can reproduce the error if you remove the x character from xtestJmsMulticastAndAggregration() method.
BTW the test case works with the Camel 1.4.0 RC1.</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.AggregratedJmsRouteTest.java</file>
			<file type="M">org.apache.camel.loanbroker.queue.version.LoanBroker.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
			<file type="M">org.apache.camel.spi.RouteContext.java</file>
			<file type="M">org.apache.camel.model.AggregatorType.java</file>
			<file type="M">org.apache.camel.impl.DefaultRouteContext.java</file>
			<file type="M">org.apache.camel.loanbroker.queue.version.BankResponseAggregationStrategy.java</file>
			<file type="M">org.apache.camel.loanbroker.queue.version.Client.java</file>
			<file type="M">org.apache.camel.loanbroker.queue.version.Bank.java</file>
		</fixedFiles>
	</bug>
	<bug id="667" opendate="2008-07-04 10:24:07" fixdate="2008-07-04 19:51:37" resolution="Fixed">
		<buginformation>
			<summary>Transactional Client - Uses DeadLetterChannel to much</summary>
			<description>The new changes to the transactional client EIP pattern to let Camel support spring based TX does a trick to the DLC to set its max redeliveries to 1 if in transacted mode.
This causes the normal DLC code to be executed and it will report that in case of failures that its being handled by its error handler, this is normally to move it to an error queue.
This of course doesn&amp;amp;apos;t happen. The DLC should be short cutted to let the underlying system handling the redelivery without the DLC infecting it currently. </description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.DeadLetterChannel.java</file>
		</fixedFiles>
	</bug>
	<bug id="675" opendate="2008-07-06 07:56:03" fixdate="2008-07-06 09:43:57" resolution="Fixed">
		<buginformation>
			<summary>intercept with stop and predicate causes NPE</summary>
			<description>I am working to improve the intercept DSL documentation and the new stop() type
This code fails with a NPE

    public void testInterceptor() throws Exception {
        MockEndpoint mockOk = getMockEndpoint("mock:ok");
        mockOk.expectedBodiesReceived("Camel in Action");

        template.sendBodyAndHeader("direct:order", "Camel in Action", "user", "James");

        mockOk.assertIsSatisfied();
    }

    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                intercept(header("user").isEqualTo("test")).to("mock:test").stop();

                from("direct:order").to("mock:ok");
            }
        };
    }


java.lang.NullPointerException
	at org.apache.camel.processor.ChoiceProcessor.process(ChoiceProcessor.java:48)
	at org.apache.camel.processor.Interceptor.process(Interceptor.java:41)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:69)
	at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:155)


</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.ChoiceProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="685" opendate="2008-07-08 11:05:13" fixdate="2008-07-08 12:07:00" resolution="Fixed">
		<buginformation>
			<summary>JMS - propation of message properties should honor jms spec that only primitives is allowed</summary>
			<description>See the user forum:
http://www.nabble.com/Fwd%3A-Using-Apache-Camel-as-Transport-for-Apache-CXF-with-SOAP-over-JMS-td18314917s22882.html
Basically JmsBinding should check for primitives before setting the object property on the jms message.</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="679" opendate="2008-07-07 05:05:04" fixdate="2008-07-08 12:37:41" resolution="Fixed">
		<buginformation>
			<summary>Instrumentation agent should be able to register multiple instances of a processor</summary>
			<description>If you have a route like this: from("jms:queue").to("bean:testBean").to("bean:testBean"),
the second instance of the processor "to(bean:testBean)" will fail to register with mbean server because of duplicated objectname.  As a result, only one instance of the "to(bean:testBean)" processor is visible to mbean server and we won&amp;amp;apos;t set the performance counter of the second instance.
 http://www.nabble.com/Starting-Camel-context-causes-JMX-exception.-tp18304692s22882p18304692.html</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.InstrumentationLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.management.CamelNamingStrategy.java</file>
			<file type="M">org.apache.camel.management.JmxInstrumentationUsingDefaultsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="636" opendate="2008-06-25 11:40:27" fixdate="2008-07-09 16:18:26" resolution="Fixed">
		<buginformation>
			<summary>ResolverUtil can&amp;apos;t resolve converter annotations in WebSphere 6.1</summary>
			<description>I have a simple hello world file based ESB that scans a folder for files, invoke a POJO and store the output as a file in another folder.
Deployed as a WAR file in WebSphere it seems as if Camel 1.4-SNAPSHOT can not load the converters needed to converter to String to InputStream for the FileProducer when it is about to store the file.
The logging output where the ResolverUtil can&amp;amp;apos;t find the annotated converters in camel jar itself

[06-25 13:31:23] DEBUG ResolverUtil [Thread: 1 org.apache.camel.component.file.FileComponent@7ade7ade]: Searching for annotations of org.apache.camel.Converter in packages: [org.apache.camel.spring.converter, org.apache.camel.converter]
[06-25 13:31:23] DEBUG ResolverUtil [Thread: 1 org.apache.camel.component.file.FileComponent@7ade7ade]: Found: []


And the stacktrace:

org.apache.camel.InvalidPayloadException: No in body available of type: java.io.InputStream but has value: This is important work
\temp\camel\in\README.txt
Done by me. of type: java.lang.String on: Message: This is important work
\temp\camel\in\README.txt
Done by me. on the exchange: Exchange[Message: This is important work
\temp\camel\in\README.txt
Done by me.]
	at org.apache.camel.util.ExchangeHelper.getMandatoryInBody(ExchangeHelper.java:127)
	at org.apache.camel.component.file.FileProducer.process(FileProducer.java:67)
	at org.apache.camel.component.file.FileProducer.process(FileProducer.java:55)
	at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsyncProcessorBridge.process(AsyncProcessorTypeConverter.java:43)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:75)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:57)
	at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:146)

</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.WebSphereResolverUtil.java</file>
			<file type="M">org.apache.camel.impl.converter.AnnotationTypeConverterLoader.java</file>
			<file type="M">org.apache.camel.util.ResolverUtil.java</file>
		</fixedFiles>
	</bug>
	<bug id="686" opendate="2008-07-08 11:05:57" fixdate="2008-07-10 04:02:19" resolution="Fixed">
		<buginformation>
			<summary>CXF - Feedback from Eduard on problems with CXF over JMS</summary>
			<description>See user forum:
http://www.nabble.com/Fwd%3A-Using-Apache-Camel-as-Transport-for-Apache-CXF-with-SOAP-over-JMS-td18314917s22882.html</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.transport.CamelDestination.java</file>
			<file type="M">org.apache.camel.component.cxf.transport.CamelConduit.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSoapBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="655" opendate="2008-07-01 20:03:50" fixdate="2008-07-10 04:49:47" resolution="Fixed">
		<buginformation>
			<summary>Jython Expressions always return null/false</summary>
			<description>A Jython expression used for example like this always returns null, which is now translated to false:
from("...").choice().when().jython("some expression").to(...)
For example, here&amp;amp;apos;s an expression that always evaluates to null/false:
request.headers['foo'] == &amp;amp;apos;bar&amp;amp;apos;
To see this, look at the test PythonExpressionTest in the camel-script module.</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.language.script.PythonLanguageTest.java</file>
			<file type="M">org.apache.camel.builder.script.PythonExpressionTest.java</file>
			<file type="M">org.apache.camel.builder.script.ScriptBuilder.java</file>
			<file type="M">org.apache.camel.builder.script.Jsr223Test.java</file>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.builder.script.JavaScriptExpressionTest.java</file>
			<file type="M">org.apache.camel.language.script.JavaScriptLanguageTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="691" opendate="2008-07-10 07:26:00" fixdate="2008-07-10 08:26:14" resolution="Fixed">
		<buginformation>
			<summary>CxfExchange  do not copy the exchange pattern when copying itself.</summary>
			<description>When I applied the CAMEL-688 patch , I found the CxfSoapMessageProviderTest failed. 
After digging into the code , I found CxfExchange do not copy the exchange pattern when the exchange copying itself.</description>
			<version>1.2.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfExchange.java</file>
		</fixedFiles>
	</bug>
	<bug id="688" opendate="2008-07-10 03:22:28" fixdate="2008-07-10 10:20:43" resolution="Fixed">
		<buginformation>
			<summary>process method of should check ExchnagePAttern before setting out</summary>
			<description></description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanProcessor.java</file>
			<file type="M">org.apache.camel.component.jms.issues.JmsRedeliveryWithInitialRedeliveryDelayTest.java</file>
			<file type="M">org.apache.camel.spring.config.MyFailureProcessor.java</file>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
			<file type="M">org.apache.camel.util.ResolverUtil.java</file>
			<file type="M">org.apache.camel.component.bean.NewInstanceTest.java</file>
			<file type="M">org.apache.camel.component.jms.issues.JmsHeaderAsObjectTest.java</file>
			<file type="M">org.apache.camel.language.bean.BeanExpression.java</file>
			<file type="M">org.apache.camel.component.jms.issues.JmsBeanMethodHeaderTest.java</file>
			<file type="M">org.apache.camel.processor.MethodFilterTest.java</file>
			<file type="M">org.apache.camel.util.WebSphereResolverUtil.java</file>
			<file type="M">org.apache.camel.component.jms.issues.DummyOrder.java</file>
			<file type="M">org.apache.camel.language.BeanTest.java</file>
			<file type="M">org.apache.camel.component.jms.issues.JmsConcurrentConsumersTest.java</file>
			<file type="M">org.apache.camel.component.direct.DirectNoToTypeTest.java</file>
			<file type="M">org.apache.camel.spring.bind.BeanAsEndpointTest.java</file>
			<file type="M">org.apache.camel.component.jms.temp.TemporaryQueueRouteTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="694" opendate="2008-07-11 04:43:56" fixdate="2008-07-11 06:48:29" resolution="Fixed">
		<buginformation>
			<summary>CXF component&amp;apos;s CamelDestination gets configured twice</summary>
			<description>CamelTransportFactory does not need to call
"configurer.configurationBean(destination)" as it has been performed
by CamelDestination..initConfig() in its constructor.  

Index: components/camel-cxf/src/main/java/org/apache/camel/component/cxf/transport/CamelTransportFactory.java
===================================================================
--- components/camel-cxf/src/main/java/org/apache/camel/component/cxf/transport/CamelTransportFactory.java	(revision 675685)
+++ components/camel-cxf/src/main/java/org/apache/camel/component/cxf/transport/CamelTransportFactory.java	(working copy)
@@ -26,7 +26,6 @@
 
 import org.apache.camel.CamelContext;
 import org.apache.cxf.Bus;
-import org.apache.cxf.configuration.Configurer;
 import org.apache.cxf.service.model.EndpointInfo;
 import org.apache.cxf.transport.AbstractTransportFactory;
 import org.apache.cxf.transport.Conduit;
@@ -87,12 +86,7 @@
     }
 
     public Destination getDestination(EndpointInfo endpointInfo) throws IOException {
-        CamelDestination destination = new CamelDestination(camelContext, bus, this, endpointInfo);
-        Configurer configurer = bus.getExtension(Configurer.class);
-        if (null != configurer) {
-            configurer.configureBean(destination);
-        }
-        return destination;
+        return new CamelDestination(camelContext, bus, this, endpointInfo);
     }
 
     public Set&amp;lt;String&amp;gt; getUriPrefixes() {

</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.transport.CamelTransportFactory.java</file>
			<file type="M">org.apache.camel.language.bean.BeanExpression.java</file>
		</fixedFiles>
	</bug>
	<bug id="697" opendate="2008-07-11 08:53:15" fixdate="2008-07-11 09:23:31" resolution="Fixed">
		<buginformation>
			<summary>transform() doesnt propogate headers</summary>
			<description>The new transform() DSL doesn&amp;amp;apos;t propogate headers so you can not do:

                from("direct:four")
                    .transform().constant("London")
                    .to("mock:result");


And expect that any headers on the exchange at direct:four is received after the transform</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.TransformProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="695" opendate="2008-07-11 08:35:09" fixdate="2008-07-11 09:26:22" resolution="Fixed">
		<buginformation>
			<summary>xquery doesnt propogate headers</summary>
			<description>You can not propagate headers through the xquery component

                from("direct:one")
                    .to("xquery:org/apache/camel/component/xquery/transform.xquery")
                    .to("mock:result");


The mock will not receive any of the headers the exchange had when it was send to direct:one</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xquery.XQueryPropogateHeadersTest.java</file>
			<file type="M">org.apache.camel.component.xquery.XQueryBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="696" opendate="2008-07-11 08:38:47" fixdate="2008-07-11 11:20:31" resolution="Fixed">
		<buginformation>
			<summary>ProducerTemplate doenst honor exchange pattern when it extracts the result</summary>
			<description>The code the extracts the result that is returned when you use the sendXXX, requestXXX methods on the producer template doens&amp;amp;apos;t honor the exchange pattern.

    protected Object extractResultBody(E result) {
        Object answer = null;
        if (result != null) {
            Message out = result.getOut(false);
            if (out != null) {
                answer = out.getBody();
            } else {
                answer = result.getIn().getBody();
            }
        }
        return answer;
    }


It defaults to preferring out messages all the time. But in some circumstances the out body could be set to null but the real response is in the in body.
Setting the exchange pattern to InOnly doesn&amp;amp;apos;t honor this.
Maybe this ticket is a symptom of the MEP problem that we have in Camel. See the discussion on the dev forum.</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultProducerTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="701" opendate="2008-07-11 12:02:35" fixdate="2008-07-11 12:38:20" resolution="Fixed">
		<buginformation>
			<summary>BeanInvocation - Do not allow Exchange as the return type</summary>
			<description>Currently if you have a bean invocation configure that is something like this

public Exchange doSomething(Exchange exchange) {
 ..
 return exchange;
}


Then Camel will set the exchange on the exchange out body. This should not be allowed.
Wiki documentation is updated about this, but the code does not check for such condition.</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
		</fixedFiles>
	</bug>
	<bug id="677" opendate="2008-07-06 17:09:24" fixdate="2008-07-11 16:45:30" resolution="Fixed">
		<buginformation>
			<summary>BAM example does not work</summary>
			<description>Currently the BAM example is commented out for the distribution. As Claus said probably as it does not work at the moment. Does anyone know what exactly goes wrong with the example?</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.example.bam.MyActivities.java</file>
			<file type="M">org.apache.camel.bam.model.ActivityState.java</file>
		</fixedFiles>
	</bug>
	<bug id="707" opendate="2008-07-12 06:29:31" fixdate="2008-07-12 08:43:15" resolution="Fixed">
		<buginformation>
			<summary>JMX Instrumentation - Nodeid can be null</summary>
			<description>The processors that is registered in JMX can have null in their id. So the JMX path is processor -&amp;gt; null -&amp;gt; 0.
Either we should replace null with unknown as we do for endpoints. Or try to fix that the id is generated.</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.CamelNamingStrategy.java</file>
			<file type="M">org.apache.camel.management.MultiInstanceProcessorTest.java</file>
			<file type="M">org.apache.camel.management.InstrumentationLifecycleStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="710" opendate="2008-07-12 19:08:50" fixdate="2008-07-12 19:41:45" resolution="Fixed">
		<buginformation>
			<summary>Presence is sent twice by xmpp</summary>
			<description>When using smack library sending presence message after login is redundant.
According to smack documentation (and confirmed by experiment) login sends the presence.
http://www.igniterealtime.org/builds/smack/docs/latest/javadoc/org/jivesoftware/smack/XMPPConnection.html#login(java.lang.String,%20java.lang.String)
Logs in to the server using the strongest authentication mode supported by the server, then sets presence to available</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xmpp.XmppEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="712" opendate="2008-07-12 19:53:22" fixdate="2008-07-12 20:38:03" resolution="Fixed">
		<buginformation>
			<summary>Xmpp private chat does not work</summary>
			<description>This configuration logs in, presence works, but message is not received by the participant.

		from("timer://kickoff?period=10000&amp;amp;delay=1").
		setBody(constant("xmpp message")).
		to("xmpp://xxxxxxxx@gmail.com/?resource=camel-user&amp;amp;password=xxxxxx&amp;amp;participant=xxxxxxxx@jabber.org");


It is cause by the code 

message.setFrom(endpoint.getUser());

1. There is no need to set "from" field: smack will fetch this info from the connection info and will set it up properly.
2. I can&amp;amp;apos;t find the link, but according to common sence and examples in Instant Messaging and Presence  "from" should be JID (Jabber ID) and not just user name!

   &amp;lt;message
       to=&amp;amp;apos;romeo@example.net&amp;amp;apos;
       from=&amp;amp;apos;juliet@example.com/balcony&amp;amp;apos;
       type=&amp;amp;apos;chat&amp;amp;apos;
       xml:lang=&amp;amp;apos;en&amp;amp;apos;&amp;gt;
     &amp;lt;body&amp;gt;Wherefore art thou, Romeo?&amp;lt;/body&amp;gt;
   &amp;lt;/message&amp;gt;
3. "Normal" message is just a hint to UI that the message is not part of conversation but a standalone message. It does not matter practically but ideologically  xmpp component will send messages as they flow and I&amp;amp;apos;d say it is a conversation (or monologue to be precise). So no need to set "Normal" flag either. Smack will set it to the default "chat" type.</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xmpp.XmppPrivateChatProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="713" opendate="2008-07-13 11:50:01" fixdate="2008-07-13 12:35:45" resolution="Fixed">
		<buginformation>
			<summary>FileProducer - consumes file instead of producing!</summary>
			<description>The strange code in the FileProducer that if the exchange is out capable it will poll the file instead bites us big time.
James must have had a beer and a fancy moment when he created the code. Something with a dynamic receipentlist where the endpoints should be polled from a file but the expression uses a Producer when the endpoints is created. For the file it should consume instead but it doesn&amp;amp;apos;t. Any basically it should consume instead.
It also bites us when we send an InOut exchange to the FileProducer it will not produce the file but consume it and there is no file so nothing happens.
This code

public class FileBackupTest extends ContextTestSupport {

    public void testMailGeneration() throws Exception {
        MockEndpoint mock = getMockEndpoint("mock:result");
        mock.expectedMessageCount(1);

        template.requestBody("seda:mails", "Hello World");

        mock.assertIsSatisfied();
    }

    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                from("seda:mails")
                    .to("file:target/mails")
                    .to("mock:result");
            }
        };
    }


Would not create a file in target/mails folder as we are using template.request that is an InOut MEP.
I will fix it by removing the strange consumer code in the FileProducer and change the fancy dynamic recepientlist test (SimulatorTest), to not use file based endpoints.
It could be a blocker for the 1.4 release and we should consider creating a new RC!</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileComponent.java</file>
			<file type="M">org.apache.camel.processor.SimulatorTest.java</file>
			<file type="M">org.apache.camel.component.file.FileProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="702" opendate="2008-07-11 15:38:49" fixdate="2008-07-14 14:48:55" resolution="Fixed">
		<buginformation>
			<summary>net.sf.saxon.trans.StaticError: XQuery syntax error in ##: generated when several threads are created for a route</summary>
			<description>Hi,
When I configure the following routes to process 10 xml files in a directory , everything works correctly
A) 
		from("file:///c:/temp/test/?delete=false&amp;amp;lock=true&amp;amp;consumer.delay=500&amp;amp;consumer.initialDelay=10").thread(10)
		.to("bean:authenticate")
				.choice().when(header("authenticated").isEqualTo(true))
					//.to("display")
				    .to("direct:extractDocument")
		.otherwise().to("activemq:queue:rejectedmessages.queue");
B) 
			from("direct:extractDocument").thread(1)
			.setHeader("responder").xpath("//XyZ:Response/text()", String.class, ns)
			.setHeader("channel", "File-Channel")
			.to("bean:saveContent")
			.to("xquery:com/myapplication/transformation/in/extract.xquery")
			.to("activemq:queue:A.in.queue");
	}
C) 		from("activemq:queue:A.in.queue").thread(10)
		.filter(body().isInstanceOf(String.class))
		.unmarshal(jaxb)
		.to("bean:convert")
		.to("bean:save")
		.to("activemq:queue:A.in.queue");
Here is the log trace
4336937 [Thread Processor] INFO  Authenticate  - Company authenticated
4336937 [Thread Processor] INFO  Authenticate  - Company authenticated
4336937 [Thread Processor] INFO  Authenticate  - Company authenticated
4336937 [Thread Processor] INFO  Authenticate  - Company authenticated
4336937 [Thread Processor] INFO  Authenticate  - Company authenticated
4336937 [Thread Processor] INFO  Authenticate  - Company authenticated
4336937 [Thread Processor] INFO  Authenticate  - Company authenticated
4336937 [Thread Processor] INFO  Authenticate  - Company authenticated
4336937 [Thread Processor] INFO  Authenticate  - Company authenticated
4336937 [Thread Processor] INFO  Authenticate  - Company authenticated
4337359 [Thread Processor] INFO  SaveContent  - Message saved
4338562 [Thread Processor] INFO  SaveContent  - Message saved
4338828 [Thread Processor] INFO  SaveContent  - Message saved
4339062 [Thread Processor] INFO  SaveContent  - Message saved
4339328 [Thread Processor] INFO  SaveContent  - Message saved
4339890 [Thread Processor] INFO  SaveContent  - Message saved
4340312 [Thread Processor] INFO  SaveContent  - Message saved
4340515 [Thread Processor] INFO  SaveContent  - Message saved
4340687 [Thread Processor] INFO  SaveContent  - Message saved
4340750 [Thread Processor] INFO  Convert  - Message send
4340906 [Thread Processor] INFO  SaveContent  - Message saved
4341218 [Thread Processor] INFO  Save  - Order saved
4341328 [Thread Processor] INFO  Convert  - Message send
4341890 [Thread Processor] INFO  Save  - Order saved
4341922 [Thread Processor] INFO  Convert  - Message send
4342672 [Thread Processor] INFO  Save  - Order saved
4342734 [Thread Processor] INFO  Convert  - Message send
4343672 [Thread Processor] INFO  Save  - Order saved
4343718 [Thread Processor] INFO  Convert  - Message send
4344703 [Thread Processor] INFO  Save  - Order saved
4344734 [Thread Processor] INFO  Convert  - Message send
4345937 [Thread Processor] INFO  Save  - Order saved
4345984 [Thread Processor] INFO  Convert  - Message send
4347359 [Thread Processor] INFO  Save  - Order saved
4347375 [Thread Processor] INFO  Convert  - Message send
4349078 [Thread Processor] INFO  Save  - Order saved
4349109 [Thread Processor] INFO  Convert  - Message send
4350859 [Thread Processor] INFO  Save  - Order saved
4350906 [Thread Processor] INFO  Convert  - Message send
4352593 [Thread Processor] INFO  Save  - Order saved
but when I would like to increase the number of threads to execute more than one XQUERY at a time
B)			from("direct:extractDocument").thread(10)
			.setHeader("responder").xpath("//XyZ:Response/text()", String.class, ns)
			.setHeader("channel", "File-Channel")
			.to("bean:saveContent")
			.to("xquery:com/myapplication/transformation/in/extract.xquery")
			.to("activemq:queue:A.in.queue");
 the following error is generated
4315906 [Thread Processor] INFO  com.bravura.babel.server.common.Authenticate  - Company authenticated
4315906 [Thread Processor] INFO  com.bravura.babel.server.common.Authenticate  - Company authenticated
4315906 [Thread Processor] INFO  com.bravura.babel.server.common.Authenticate  - Company authenticated
4315906 [Thread Processor] INFO  com.bravura.babel.server.common.Authenticate  - Company authenticated
4315906 [Thread Processor] INFO  com.bravura.babel.server.common.Authenticate  - Company authenticated
4315906 [Thread Processor] INFO  com.bravura.babel.server.common.Authenticate  - Company authenticated
4315906 [Thread Processor] INFO  com.bravura.babel.server.common.Authenticate  - Company authenticated
4315906 [Thread Processor] INFO  com.bravura.babel.server.common.Authenticate  - Company authenticated
4315906 [Thread Processor] INFO  com.bravura.babel.server.common.Authenticate  - Company authenticated
4315906 [Thread Processor] INFO  com.bravura.babel.server.common.Authenticate  - Company authenticated
4316750 [Thread Processor] INFO  com.bravura.babel.server.common.SaveContent  - Message saved
4316781 [Thread Processor] INFO  com.bravura.babel.server.common.SaveContent  - Message saved
4316781 [Thread Processor] INFO  com.bravura.babel.server.common.SaveContent  - Message saved
4317094 [Thread Processor] INFO  com.bravura.babel.server.common.SaveContent  - Message saved
4317125 [Thread Processor] INFO  com.bravura.babel.server.common.SaveContent  - Message saved
4317172 [Thread Processor] INFO  com.bravura.babel.server.common.SaveContent  - Message saved
4317203 [Thread Processor] INFO  com.bravura.babel.server.common.SaveContent  - Message saved
4317250 [Thread Processor] INFO  com.bravura.babel.server.common.SaveContent  - Message saved
4317281 [Thread Processor] INFO  com.bravura.babel.server.common.SaveContent  - Message saved
4317328 [Thread Processor] INFO  com.bravura.babel.server.common.SaveContent  - Message saved
43Error on line 1 column 0 
  XPST0003: XQuery syntax error in ##:
    Unexpected token "&amp;lt;eof&amp;gt;" in path expression
Error on line 1 column 0 
  XPST0003: XQuery syntax error in ##:
    Unexpected token "&amp;lt;eof&amp;gt;" in path expression
Error on line 1 column 0 
  XPST0003: XQuery syntax error in ##:
    Unexpected token "&amp;lt;eof&amp;gt;" in path expression
Error on line 1 column 0 
  XPST0003: XQuery syntax error in ##:
    Unexpected token "&amp;lt;eof&amp;gt;" in path expression
Error on line 1 column 0 
  XPST0003: XQuery syntax error in ##:
    Unexpected token "&amp;lt;eof&amp;gt;" in path expression
Error on line 1 column 0 
  XPST0003: XQuery syntax error in ##:
    Unexpected token "&amp;lt;eof&amp;gt;" in path expression
Error on line 1 column 0 
  XPST0003: XQuery syntax error in ##:
    Unexpected token "&amp;lt;eof&amp;gt;" in path expression
Error on line 1 column 0 
  XPST0003: XQuery syntax error in ##:
    Unexpected token "&amp;lt;eof&amp;gt;" in path expression
Error on line 1 column 0 
  XPST0003: XQuery syntax error in ##:
    Unexpected token "&amp;lt;eof&amp;gt;" in path expression
18219 [Thread Processor] ERROR org.apache.camel.processor.DeadLetterChannel  - Failed delivery for exchangeId: ID-dell-charles/4777-1215789902562/0-1. On delivery attempt: 0 caught: org.apache.camel.RuntimeExpressionException: net.sf.saxon.trans.StaticError: XQuery syntax error in ##:
    Unexpected token "&amp;lt;eof&amp;gt;" in path expression
43org.apache.camel.RuntimeExpressionException: net.sf.saxon.trans.StaticError: XQuery syntax error in ##:
    Unexpected token "&amp;lt;eof&amp;gt;" in path expression
	at org.apache.camel.component.xquery.XQueryBuilder.evaluate(XQueryBuilder.java:125)
	at org.apache.camel.component.xquery.XQueryBuilder.process(XQueryBuilder.java:89)
	at org.apache.camel.impl.ProcessorEndpoint.onExchange(ProcessorEndpoint.java:92)
	at org.apache.camel.impl.ProcessorEndpoint$1.process(ProcessorEndpoint.java:66)
	at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsyncProcessorBridge.process(AsyncProcessorTypeConverter.java:43)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:75)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:101)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:85)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:101)
	at org.apache.camel.processor.Pipeline.access$100(Pipeline.java:40)
	at org.apache.camel.processor.Pipeline$1.done(Pipeline.java:124)
	at org.apache.camel.processor.ThreadProcessor$ProcessCall.run(ThreadProcessor.java:66)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675)
	at java.lang.Thread.run(Thread.java:595)
Caused by: net.sf.saxon.trans.StaticError: XQuery syntax error in ##:
    Unexpected token "&amp;lt;eof&amp;gt;" in path expression
	at net.sf.saxon.query.QueryParser.grumble(QueryParser.java:323)
	at net.sf.saxon.expr.ExpressionParser.grumble(ExpressionParser.java:136)
	at net.sf.saxon.expr.ExpressionParser.parseBasicStep(ExpressionParser.java:1403)
	at net.sf.saxon.expr.ExpressionParser.parseStepExpression(ExpressionParser.java:1220)
	at net.sf.saxon.expr.ExpressionParser.parseRelativePath(ExpressionParser.java:1160)
	at net.sf.saxon.expr.ExpressionParser.parsePathExpression(ExpressionParser.java:1146)
	at net.sf.saxon.expr.ExpressionParser.parseUnaryExpression(ExpressionParser.java:1025)
	at net.sf.saxon.expr.ExpressionParser.parseCastExpression(ExpressionParser.java:684)
	at net.sf.saxon.expr.ExpressionParser.parseCastableExpression(ExpressionParser.java:639)
	at net.sf.saxon.expr.ExpressionParser.parseTreatExpression(ExpressionParser.java:620)
	at net.sf.saxon.expr.ExpressionParser.parseInstanceOfExpression(ExpressionParser.java:602)
	at net.sf.saxon.expr.ExpressionParser.parseIntersectExpression(ExpressionParser.java:1058)
	at net.sf.saxon.expr.ExpressionParser.parseUnionExpression(ExpressionParser.java:1040)
	at net.sf.saxon.expr.ExpressionParser.parseMultiplicativeExpression(ExpressionParser.java:977)
	at net.sf.saxon.expr.ExpressionParser.parseAdditiveExpression(ExpressionParser.java:957)
	at net.sf.saxon.expr.ExpressionParser.parseRangeExpression(ExpressionParser.java:873)
	at net.sf.saxon.expr.ExpressionParser.parseComparisonExpression(ExpressionParser.java:823)
	at net.sf.saxon.expr.ExpressionParser.parseAndExpression(ExpressionParser.java:414)
	at net.sf.saxon.expr.ExpressionParser.parseOrExpression(ExpressionParser.java:396)
	at net.sf.saxon.expr.ExpressionParser.parseExprSingle(ExpressionParser.java:350)
	at net.sf.saxon.expr.ExpressionParser.parseExpression(ExpressionParser.java:314)
	at net.sf.saxon.query.QueryParser.parseQuery(QueryParser.java:256)
	at net.sf.saxon.query.QueryParser.makeXQueryExpression(QueryParser.java:97)
	at net.sf.saxon.query.StaticQueryContext.compileQuery(StaticQueryContext.java:450)
	at net.sf.saxon.query.StaticQueryContext.compileQuery(StaticQueryContext.java:513)
	at org.apache.camel.component.xquery.XQueryBuilder$3.createQueryExpression(XQueryBuilder.java:216)
	at org.apache.camel.component.xquery.XQueryBuilder.getExpression(XQueryBuilder.java:294)
	at org.apache.camel.component.xquery.XQueryBuilder.evaluateAsDOM(XQueryBuilder.java:153)
	at org.apache.camel.component.xquery.XQueryBuilder.evaluate(XQueryBuilder.java:115)
	... 14 more
</description>
			<version>1.4.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xquery.XQueryURLBasedConcurrencyTest.java</file>
			<file type="M">org.apache.camel.component.xquery.XQueryConcurrencyTest.java</file>
			<file type="M">org.apache.camel.component.xquery.XQueryBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="727" opendate="2008-07-15 18:35:03" fixdate="2008-07-15 19:35:11" resolution="Fixed">
		<buginformation>
			<summary>Propagated CXF header&amp;apos;s value should not include quotes</summary>
			<description>CAMEL-686 fixed the issue of not propagating transport headers (e.g. SOAPAction) but it looks like we added quotes around the value (i.e. getCustomer becomes "getCustomer").  I updated the CustomerServicesTest to illustrate the problem.  Also, I cleaned up the client/server-application.xml.</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.itest.customerrelations.CustomerServicesTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="718" opendate="2008-07-14 16:27:15" fixdate="2008-07-16 04:43:42" resolution="Fixed">
		<buginformation>
			<summary>Anonymous FTP doesn&amp;apos;t work without username</summary>
			<description>The web site for the FTP modules says you can use a URL like ftp://publicftpserver.com/download for anonymous FTP, but this doesn&amp;amp;apos;t work unless you specify a username.</description>
			<version>1.3.0</version>
			<fixedVersion>1.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpToFileNoFileNameHeaderTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpToBinarySampleTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="737" opendate="2008-07-18 13:01:00" fixdate="2008-07-18 18:26:24" resolution="Fixed">
		<buginformation>
			<summary>When getContext().addInterceptorStrategy(new Tracer());  is added in a RouteBuilder class, then the timer component does not work</summary>
			<description>When 
getContext().addInterceptorStrategy(new Tracer());
is added in a RouteBuilder Class, then the timer component does not start.
e.g. 
public class RouteBuilder extends RouteBuilder {
    getContext().addInterceptorStrategy(new Tracer());
    public void configure() 
{

        from("timer://export")
        .to("bean:myBean");
    }
}</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.log.LogFormatter.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.processor.interceptor.TraceFormatter.java</file>
		</fixedFiles>
	</bug>
	<bug id="738" opendate="2008-07-20 01:50:50" fixdate="2008-07-20 02:52:45" resolution="Fixed">
		<buginformation>
			<summary>After the downloading process, the layout of the remote file system doesn&amp;apos;t match the local&amp;apos;s one</summary>
			<description>When downloading a directory with a complex layout (mutli level directory), the downloaded files do not reflect the local one
more info here http://www.nabble.com/FTP-component%3A-Possible-bug-td18540318s22882.html</description>
			<version>1.3.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpToBinaryFilesTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="747" opendate="2008-07-23 19:17:01" fixdate="2008-07-23 19:45:50" resolution="Fixed">
		<buginformation>
			<summary>xpath expression with $header and the header doesnt exist on the in message results in NPE</summary>
			<description>Using the $headerkey shorthand for xpath expression throws a NPE if the headerkey doesn&amp;amp;apos;t exists on the in message.
We should try to find a better workaround for key doesn&amp;amp;apos;t exists. The NPE is thrown by SUN in their xpath engine.
Check nabble:
http://www.nabble.com/Camel-XPath-and-no-variables-found-in-MessageVariableResolver---What-should-Camel-do--td18603960s22882.html</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.processor.SpringXPathHeaderTest.java</file>
			<file type="M">org.apache.camel.builder.xml.XPathHeaderTest.java</file>
			<file type="M">org.apache.camel.builder.xml.MessageVariableResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="741" opendate="2008-07-22 10:08:08" fixdate="2008-07-24 03:12:35" resolution="Fixed">
		<buginformation>
			<summary>CamelConduit&amp;apos;s should check the TargetReference when create its instance</summary>
			<description>CAMEL-726 shows a ws-address error when using Camel transport for CXF.
After running the code , I found there is no To address tag  generated in the soap header. It was caused by the CamelConduit can set right targe reference.
</description>
			<version>1.3.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.transport.CamelConduit.java</file>
		</fixedFiles>
	</bug>
	<bug id="715" opendate="2008-07-14 10:19:14" fixdate="2008-07-24 05:17:37" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentModificationException in ThreadProcessor</summary>
			<description>When defining very simple routing with ThreadProcessor I get ConcurrentModificationException on multicore systems.
Example:
 from("direct:a").thread(10).process(new Processor() {
          @Override
          public void process(Exchange ex) throws Exception 
{
            //sth
          }
});
Stack trace:
Exception in thread "Thread Processor"
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextEntry(HashMap.java:793)
	at java.util.HashMap$EntryIterator.next(HashMap.java:834)
	at java.util.HashMap$EntryIterator.next(HashMap.java:832)
	at java.util.HashMap.putAll(HashMap.java:523)
	at
org.apache.camel.processor.Pipeline.createNextExchange(Pipeline.java:146
)
	at org.apache.camel.processor.Pipeline$1.done(Pipeline.java:123)
	at
org.apache.camel.processor.ThreadProcessor$ProcessCall.run(ThreadProcess
or.j
ava:66)
	at
java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecuto
r.ja
va:885)
	at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.ja
va:9
07)
	at java.lang.Thread.run(Thread.java:619)
</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.Camel715ThreadProcessorTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultExchange.java</file>
		</fixedFiles>
	</bug>
	<bug id="755" opendate="2008-07-24 18:02:12" fixdate="2008-07-24 18:45:26" resolution="Fixed">
		<buginformation>
			<summary>AMQP Tests are disabled</summary>
			<description>The AMQP tests are currently disabled. Adding an older version of MINA (than Camel uses) &amp;amp; commons lang to the classpath got the tests passing except for ObjectMessage type test.
Sending a TextMessage and BytesMessage work fine so I&amp;amp;apos;m opening up a separate JIRA for the ObjectMessage issue.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.amqp.AMQPRouteTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="763" opendate="2008-07-28 04:07:30" fixdate="2008-07-28 08:10:20" resolution="Fixed">
		<buginformation>
			<summary>CamelContext&amp;apos;s setErrorHandler is not effect when the jmx agent is disabled</summary>
			<description>The example applications from Camel 1.4 source distribution work correctly on my machine.  After comparing the sample Spring XML configuration and my Spring configuration, I noticed there is no jmxAgent element in the sample XML where my configuration has this element.  The problem I noticed was that when the disabled attribute of the jmxAgent element is set to true, the redelivery policy does not work.   
http://www.nabble.com/DeadLetterChannel-Configuration-Camel-1.4-td18622356s22882.html#a18622356</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.config.ErrorHandlerTest.java</file>
			<file type="M">org.apache.camel.builder.ContextErrorHandlerTest.java</file>
			<file type="M">org.apache.camel.management.InstrumentationLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
			<file type="M">org.apache.camel.spring.processor.SpringXPathHeaderTest.java</file>
			<file type="D">org.apache.camel.spring.processor.SpringSetHeaderWithChildProcessorTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultLifecycleStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="765" opendate="2008-07-29 04:02:15" fixdate="2008-07-29 07:03:03" resolution="Fixed">
		<buginformation>
			<summary>InstrumentationProcessor should catch Throwable</summary>
			<description>The InstrumentationProcessor currently only catches exception and sets it in the exception.   Runtime errors and throwables can be thrown all the way out of the DeadLetterChannel&amp;amp;apos;s process method, out of the reach of exception policy.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.InstrumentationProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="773" opendate="2008-07-30 15:06:58" fixdate="2008-07-30 15:33:39" resolution="Fixed">
		<buginformation>
			<summary>Trace does not look at camel.trace property</summary>
			<description>This has a simple fix - it was a spelling error </description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="758" opendate="2008-07-25 07:39:03" fixdate="2008-07-31 18:07:22" resolution="Fixed">
		<buginformation>
			<summary>SFTP Producer - Doesn&amp;apos;t handle folder already exists when trying to create the remote folder</summary>
			<description>The SFTP (the secure) has this bug that it doesn&amp;amp;apos;t check if the folder already exsits before it tries to create the remote folder.
See nabble:
http://www.nabble.com/SftpProducer-bug-td18640519s22882.html
Bela the reported want to contribute a patch later, or he will be able to test it.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpProducer.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpProducer.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="774" opendate="2008-07-31 20:39:19" fixdate="2008-08-04 12:14:27" resolution="Fixed">
		<buginformation>
			<summary>ResolverUtil under OSGi error: Could not search jar file &amp;apos;/org/apache/camel/converter&amp;apos;</summary>
			<description>This is a sequel of CAMEL-577, which itself duplicated by CAMEL-558 and CAMEL-522. Probably related to CAMEL-636, CAMEL-693, and CAMEL-689.
First of all, to even get this to "work" requires my own bundle to have this manifest:
DynamicImport-Package: org.apache.camel.*
Failing to do so will result in more classloading errors.
Even so, it still fails with this:
[SpringOsgiExtenderThread-2] TRACE org.apache.camel.util.ResolverUtil - Testing for class org.apache.camel.converter.jaxp.XmlConverter matches criteria [annotated with @Converter]
[SpringOsgiExtenderThread-2] TRACE org.apache.camel.util.ResolverUtil - Found class: class org.apache.camel.converter.jaxp.XmlConverter in classloader: BundleDelegatingClassLoader for [org.elfattah.shell (org.elfattah.shell)]
[SpringOsgiExtenderThread-2] TRACE org.apache.camel.util.ResolverUtil - Testing for class org.apache.camel.converter.stream.StreamCacheConverter$StreamSourceCache matches criteria [annotated with @Converter]
[SpringOsgiExtenderThread-2] TRACE org.apache.camel.util.ResolverUtil - Testing for class org.apache.camel.converter.stream.StreamCacheConverter$InputStreamCache matches criteria [annotated with @Converter]
[SpringOsgiExtenderThread-2] TRACE org.apache.camel.util.ResolverUtil - Searching for: annotated with @Converter in package: org/apache/camel/converter using classloader: org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader
[SpringOsgiExtenderThread-2] TRACE org.apache.camel.util.ResolverUtil - It&amp;amp;apos;s not an osgi bundle classloader
[SpringOsgiExtenderThread-2] TRACE org.apache.camel.util.ResolverUtil - Getting resource URL for package: org/apache/camel/converter with classloader: org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader@1a5db4b
[SpringOsgiExtenderThread-2] TRACE org.apache.camel.util.ResolverUtil - URL from classloader: bundleresource://20/org/apache/camel/converter
[SpringOsgiExtenderThread-2] TRACE org.apache.camel.util.ResolverUtil - Decoded urlPath: /org/apache/camel/converter
[SpringOsgiExtenderThread-2] TRACE org.apache.camel.util.ResolverUtil - Scanning for classes in [/org/apache/camel/converter] matching criteria: annotated with @Converter
[SpringOsgiExtenderThread-2] DEBUG org.apache.camel.util.ResolverUtil - Loading from jar: /org/apache/camel/converter
[SpringOsgiExtenderThread-2] ERROR org.apache.camel.util.ResolverUtil - Could not search jar file &amp;amp;apos;/org/apache/camel/converter&amp;amp;apos; for classes matching criteria: annotated with @Converter due to an IOException: /org/apache/camel/converter (No such file or directory)
java.io.FileNotFoundException: /org/apache/camel/converter (No such file or directory)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.&amp;lt;init&amp;gt;(FileInputStream.java:106)
	at org.apache.camel.util.ResolverUtil.loadImplementationsInJar(ResolverUtil.java:476)
	at org.apache.camel.util.ResolverUtil.find(ResolverUtil.java:362)
	at org.apache.camel.util.ResolverUtil.find(ResolverUtil.java:277)
	at org.apache.camel.util.ResolverUtil.findAnnotated(ResolverUtil.java:253)
	at org.apache.camel.impl.converter.AnnotationTypeConverterLoader.load(AnnotationTypeConverterLoader.java:66)
	at org.apache.camel.impl.converter.DefaultTypeConverter.checkLoaded(DefaultTypeConverter.java:218)
	at org.apache.camel.impl.converter.DefaultTypeConverter.convertTo(DefaultTypeConverter.java:64)
	at org.apache.camel.util.IntrospectionSupport.convert(IntrospectionSupport.java:216)
	at org.apache.camel.util.IntrospectionSupport.setProperty(IntrospectionSupport.java:194)
	at org.apache.camel.util.IntrospectionSupport.setProperties(IntrospectionSupport.java:167)
	at org.apache.camel.impl.DefaultComponent.setProperties(DefaultComponent.java:187)
	at org.apache.camel.impl.DefaultComponent.createEndpoint(DefaultComponent.java:89)
	at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:270)
	at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:52)
	at org.apache.camel.model.RouteType.resolveEndpoint(RouteType.java:100)
	at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:102)
	at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:108)
	at org.apache.camel.model.FromType.resolveEndpoint(FromType.java:73)
	at org.apache.camel.impl.DefaultRouteContext.getEndpoint(DefaultRouteContext.java:77)
	at org.apache.camel.model.RouteType.addRoutes(RouteType.java:214)
	at org.apache.camel.model.RouteType.addRoutes(RouteType.java:90)
	at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:537)
	at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:529)
	at org.apache.camel.spring.SpringCamelContext.doStart(SpringCamelContext.java:149)
	at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:47)
	at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:103)
	at org.springframework.context.event.SimpleApplicationEventMulticaster$1.run(SimpleApplicationEventMulticaster.java:78)
	at org.springframework.core.task.SyncTaskExecutor.execute(SyncTaskExecutor.java:49)
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:76)
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:275)
	at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:737)
	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.finishRefresh(AbstractDelegatedExecutionApplicationContext.java:306)
	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.completeRefresh(AbstractDelegatedExecutionApplicationContext.java:279)
	at org.springframework.osgi.extender.internal.dependencies.startup.DependencyWaiterApplicationContextExecutor$CompleteRefreshTask.run(DependencyWaiterApplicationContextExecutor.java:145)
	at java.lang.Thread.run(Thread.java:619)
[SpringOsgiExtenderThread-2] DEBUG org.apache.camel.util.ResolverUtil - Found: [class org.apache.camel.converter.ObjectConverter, class org.apache.camel.converter.jaxp.DomConverter, class org.apache.camel.converter.IOConverter, class org.apache.camel.converter.jaxp.StaxConverter, class org.apache.camel.converter.jaxp.XmlConverter, class org.apache.camel.converter.stream.StreamCacheConverter, class org.apache.camel.converter.jaxp.StreamSourceConverter, class org.apache.camel.converter.NIOConverter, class org.apache.camel.converter.CollectionConverter, class org.apache.camel.converter.CamelConverter]
The project that demonstrates this error is open source, check it out here:
http://svn.assembla.com/svn/elfattah/trunk
do mvn install on elfattah-api and elfattah-shell
Then go to elfattah-shell and:
mvn pax:provision</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ResolverUtil.java</file>
		</fixedFiles>
	</bug>
	<bug id="793" opendate="2008-08-08 02:49:46" fixdate="2008-08-08 04:07:33" resolution="Fixed">
		<buginformation>
			<summary>smtp connection without authentication (no username and password given) doesn&amp;apos;t work</summary>
			<description>Connections to smtp servers with no authentication fail. The mail.smtp.auth is always set to true. The patch sets it to false if no username is given.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="777" opendate="2008-08-01 09:11:29" fixdate="2008-08-08 05:53:57" resolution="Fixed">
		<buginformation>
			<summary>Allow &amp;apos;@&amp;apos; in usernames.</summary>
			<description>Many servers use &amp;amp;apos;username&amp;amp;apos;@&amp;amp;apos;servername&amp;amp;apos; as a login name. Camel-mail doesn&amp;amp;apos;t allow this.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailConfiguration.java</file>
			<file type="M">org.apache.camel.component.mail.MailRouteTest.java</file>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
			<file type="M">org.apache.camel.component.mail.MailUsingHeadersTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="795" opendate="2008-08-08 05:48:57" fixdate="2008-08-08 05:57:28" resolution="Fixed">
		<buginformation>
			<summary>MinaConsumerTest failure</summary>
			<description>The test fails with the following error:
junit.framework.ComparisonFailure: expected:&amp;lt;[Bye World]&amp;gt; but was:&amp;lt;[]&amp;gt;
	at junit.framework.Assert.assertEquals(Assert.java:81)
	at junit.framework.Assert.assertEquals(Assert.java:87)
	at org.apache.camel.component.mina.MinaConsumerTest.testSendTextlineSyncText(MinaConsumerTest.java:28)
...
One test sends sync the text "World" and the should receive "Bye World" in response.
2008-08-08 01:35:25,589 DEBUG MinaProducer - Message received: Bye World 
2008-08-08 01:35:25,589 DEBUG MinaProducer - Message received:  
2008-08-08 01:35:25,589 DEBUG MinaProducer - Message received: Bye  
2008-08-08 01:35:25,589 DEBUG MinaProducer - Message received:  
There are actually not one, but two messages received which causes the reply to be overridden by the second message.  The problem is with the test itself that actually returns "Bye " + body + "\n"!  Because the test uses the &amp;amp;apos;textline&amp;amp;apos; mina codec, the encoder actually adds another &amp;amp;apos;\n&amp;amp;apos;.  With the textline codec there&amp;amp;apos;s one message per line, so the extra \n makes it two lines and hence the extra message.  The decoder at the other end suppresses the LineDelimiter (\n), so the extra message is actually an empty string.
Removing the extra \n in the message fixes the test, but the notes above should be considered when camel-mina is used with the textline codec.
</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina.MinaConsumerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="803" opendate="2008-08-09 06:27:45" fixdate="2008-08-09 17:33:45" resolution="Fixed">
		<buginformation>
			<summary>ValidatingProcessor not thread-safe</summary>
			<description>The method org.apache.camel.processor.validation.ValidatingProcessor.process() is executed concurrently but error information is stored in a shared errorHandler. Because each thread calls errorHandler.reset() it may clean errors written by another thread. The easiest way to fix this issue would be a synchronized block:
ValidatingProcessor.java
...
synchronized (errorHandler) {
    errorHandler.reset();
    validator.setErrorHandler(errorHandler);
    
    DOMResult result = new DOMResult();
    validator.validate(source, result);
    
    errorHandler.handleErrors(exchange, schema, result);
}
... 


The disadvantage of this solution is that is serializes threads. A locally created error handler would be preferrable ...</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.validation.DefaultValidationErrorHandler.java</file>
			<file type="M">org.apache.camel.processor.validation.ValidatingProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="806" opendate="2008-08-10 06:52:59" fixdate="2008-08-11 08:34:09" resolution="Fixed">
		<buginformation>
			<summary>Strict Uri option validation fails HTTP Get Requests</summary>
			<description>The new strict URI validation requires that the named parameter options be validated prior to calling endpoint. This has the unfortunate side effect of failing exchanges to Endpoints where the parameter options are variable e.g. a GET request to HTTP server. In cases such as these it would be useful to be able to circumvent this strict validation.
The attached test illustrates the issue.
</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultEndpoint.java</file>
			<file type="M">org.apache.camel.Endpoint.java</file>
			<file type="M">org.apache.camel.component.http.HttpComponent.java</file>
			<file type="M">org.apache.camel.impl.DefaultComponent.java</file>
			<file type="M">org.apache.camel.component.http.HttpGetWithQueryParamsTest.java</file>
			<file type="M">org.apache.camel.component.http.HttpGetWithHeadersTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSoapEndpoint.java</file>
			<file type="M">org.apache.camel.component.http.HttpEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="811" opendate="2008-08-11 16:45:49" fixdate="2008-08-11 17:43:50" resolution="Fixed">
		<buginformation>
			<summary>delayer pattern doesn&amp;apos;t work in Spring DSL</summary>
			<description>You can&amp;amp;apos;t configure the delayer pattern properly in the Spring DSL currently. I will be attaching a patch for this shortly.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.DelayerType.java</file>
			<file type="M">org.apache.camel.spring.SpringCamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="792" opendate="2008-08-07 21:22:13" fixdate="2008-08-13 18:42:52" resolution="Fixed">
		<buginformation>
			<summary>Exception is not logged or handled when error handler is LoggingErrorHandler and processing occurs inside Pipeline</summary>
			<description>Exception throw inside Pipeline is not reported or handled when error handler is LoggingErrorHandler.
Attached unit test fails - exchange with exception is not passed to "mock:error" endpoints.
Test will pass when you change error handler to default (DeadLetterErrorHandler)
or when processor throwing an exception is processed not inside Pipeline.
After some digging inside source code I noticed Pipeline source code fragment.

    public void process(Exchange exchange) throws Exception {
        AsyncProcessorHelper.process(this, exchange);
    }


AsyncProcessorHelper.process(..) never throws exception directly.
Instead it passes exception information in exchange object properties.
Problem is LoggingErrorHandler doesn&amp;amp;apos;t use it correctly because (code snipped from LoggingErrorHandler):

    public void process(Exchange exchange) throws Exception {
        try {
            output.process(exchange);
        } catch (Throwable e) {
            if (!customProcessorForException(exchange, e)) {
                logError(exchange, e);
            }
        }
    }


it is logging only exception returned directly by output.process call.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.LoggingErrorHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="826" opendate="2008-08-14 23:38:53" fixdate="2008-08-15 00:06:58" resolution="Fixed">
		<buginformation>
			<summary>File polling consumer does not remove file lock if exchange fails</summary>
			<description></description>
			<version>1.3.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileRenameRouteTest.java</file>
			<file type="M">org.apache.camel.component.file.FileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.strategy.NoOpFileProcessStrategy.java</file>
			<file type="M">org.apache.camel.component.file.FileNoOpRouteTest.java</file>
			<file type="M">org.apache.camel.component.file.FileDeleteRouteTest.java</file>
			<file type="M">org.apache.camel.component.file.FileFilterOnNameRouteTest.java</file>
			<file type="M">org.apache.camel.component.file.FileProcessStrategy.java</file>
			<file type="M">org.apache.camel.impl.DefaultConsumer.java</file>
			<file type="M">org.apache.camel.component.file.FileRouteTest.java</file>
			<file type="M">org.apache.camel.component.file.strategy.FileProcessStrategySupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="818" opendate="2008-08-13 11:25:14" fixdate="2008-08-15 07:49:42" resolution="Fixed">
		<buginformation>
			<summary>Should preserve the exchange type in the routing slip</summary>
			<description>Currently, the routing slip will create a new InOut exchange for each target based on the target endpoint type. This means that someone calling from a jbi endpoint (or other endpoint with custom exchange) into the routing slip will have their exchange type changed (to mostly likely DefaultExchange). I will be including a patch to fix this issue shortly. </description>
			<version>1.3.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.RoutingSlip.java</file>
			<file type="M">org.apache.camel.processor.routingslip.RoutingSlipDataModificationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="834" opendate="2008-08-18 13:09:07" fixdate="2008-08-20 04:08:19" resolution="Fixed">
		<buginformation>
			<summary>Trailing slash missing in SftpConsumer</summary>
			<description>When this route 

    &amp;lt;camel:route&amp;gt;
        &amp;lt;camel:from uri="sftp://someuser@hostname/path/to/directory/?password=secret&amp;amp;amp;directory=true&amp;amp;amp;binary=true&amp;amp;amp;consumer.useFixedDelay=false&amp;amp;amp;consumer.setNames=true&amp;amp;amp;consumer.recursive=false" /&amp;gt;
        &amp;lt;camel:to uri="file:///C:/camel/output/" /&amp;gt;
    &amp;lt;/camel:route&amp;gt;


is configured the files in the remote directory are download, but subsequent calls of the method "pollDir" result in this exception:

[ Thread: 1 RemoteFileComponent] SftpConsumer                   WARN  Caught SftpException:2: No such file
[ Thread: 1 RemoteFileComponent] SftpConsumer                   WARN  Doing nothing for now, need to determine an appropriate action
[ Thread: 1 RemoteFileComponent] ScheduledPollConsumer          WARN  An exception occured while polling: Endpoint[sftp://someuser@hostname/path/to/directory/?password=secret&amp;amp;amp;directory=true&amp;amp;amp;binary=true&amp;amp;amp;consumer.useFixedDelay=false&amp;amp;amp;consumer.setNames=true&amp;amp;amp;consumer.recursive=false]: No such file 2: No such file


As you can see the slash is definitely in the configured route. If I check for the missing slash and add it to the dir variable (line 115 in SftpConsumer) then the consumer works:

    	if(!dir.startsWith("/")) {
    		dir = "/" + dir;
    	}


Didn&amp;amp;apos;t have the time to have a closer look. The root cause of the missing slash is somewhere else.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpServerTestSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="842" opendate="2008-08-21 15:58:41" fixdate="2008-08-21 21:53:21" resolution="Fixed">
		<buginformation>
			<summary>handleFault does not interrupt processing on successful retry</summary>
			<description>See following thread for more details.
http://www.nabble.com/Handling-JBI-faults-td19090487s22882.html#a19090487</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.HandleFaultProcessor.java</file>
			<file type="M">org.apache.camel.processor.FaultRouteTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="857" opendate="2008-08-27 05:20:25" fixdate="2008-08-27 06:24:58" resolution="Fixed">
		<buginformation>
			<summary>DeadLetterChannel - maximum redelivery is not corrent and redelivery counter is wrong when failure handled</summary>
			<description>The unit test from CAMEL-794 demonstrates a few issues with the DLC in Camel

the maximum redelivery is not reached - eg. setting it to 2 will only perform 1 normal attempt + 1 redelivery, and not as expected 2 redeliveries
when the exchanged could not be redelivered at all then the redeliverycounter has already been incremented and thus is off by +1

</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.BuilderWithScopesTest.java</file>
			<file type="M">org.apache.camel.processor.RedeliveryPolicyPerExceptionTest.java</file>
			<file type="M">org.apache.camel.processor.RedeliveryPolicy.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannel.java</file>
			<file type="M">org.apache.camel.processor.ValidationFinallyBlockNoCatchTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="782" opendate="2008-08-05 11:41:44" fixdate="2008-08-27 07:44:38" resolution="Fixed">
		<buginformation>
			<summary>Tracer incorrectly treats messages with InputStream as body</summary>
			<description>Suppose we have the following flow:
 from("activemq:vasea")
  .to("cxf:bean:serviceEndpoint?dataFormat=MESSAGE")
    .unmarshal().string()
  .to("activemq:petea");
In this flow cxf:bean:serviceEndpoint returns ByteArrayInputStream as body. Under normal conditions everything works fine: WS output gets to the queue.
But if we add:
getContext().addInterceptStrategy(new Tracer());
Queue starts receiving empty messages. After digging in the code I found out that tracer reads input stream in order to display body, but not resets it. Thus when message reaches unmarshaller, nothing could be read from the stream.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.interceptor.TraceFormatter.java</file>
			<file type="M">org.apache.camel.component.log.LogFormatter.java</file>
			<file type="M">org.apache.camel.converter.stream.StreamCache.java</file>
			<file type="M">org.apache.camel.converter.stream.StreamCacheConverter.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannel.java</file>
			<file type="M">org.apache.camel.issues.CacheInputStreamInDeadLetterIssue520Test.java</file>
			<file type="M">org.apache.camel.itest.jetty.JettyJmsTest.java</file>
			<file type="M">org.apache.camel.itest.jetty.SetExchangeProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="858" opendate="2008-08-27 07:26:43" fixdate="2008-08-27 07:44:55" resolution="Fixed">
		<buginformation>
			<summary>Log component should cache the message body&amp;apos;s InputStream </summary>
			<description>If we put the log between an InputStream consumer and InputStream producer like below 
from("InputStream Consumer").to("log:ShowMessageBody").to("InputStream Producer");
The InputStream Producer can&amp;amp;apos;t read the any date from the in message body.
</description>
			<version>1.3.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.interceptor.TraceFormatter.java</file>
			<file type="M">org.apache.camel.component.log.LogFormatter.java</file>
			<file type="M">org.apache.camel.converter.stream.StreamCache.java</file>
			<file type="M">org.apache.camel.converter.stream.StreamCacheConverter.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannel.java</file>
			<file type="M">org.apache.camel.issues.CacheInputStreamInDeadLetterIssue520Test.java</file>
			<file type="M">org.apache.camel.itest.jetty.JettyJmsTest.java</file>
			<file type="M">org.apache.camel.itest.jetty.SetExchangeProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="520" opendate="2008-05-16 06:19:01" fixdate="2008-08-30 01:28:02" resolution="Fixed">
		<buginformation>
			<summary>Enable stream caching on DeadLetterChannel by default</summary>
			<description>The dead letter channel will retry to send the same message multiple times, so the message content should be stream-cached before trying to process it the first time.</description>
			<version>1.3.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.StreamSourceContentBasedRouterTest.java</file>
			<file type="M">org.apache.camel.util.MessageHelper.java</file>
			<file type="M">org.apache.camel.processor.interceptor.StreamCachingInterceptor.java</file>
			<file type="M">org.apache.camel.component.dataset.DataSetSedaTest.java</file>
			<file type="M">org.apache.camel.builder.DeadLetterChannelBuilder.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannel.java</file>
			<file type="M">org.apache.camel.issues.CacheInputStreamInDeadLetterIssue520Test.java</file>
			<file type="M">org.apache.camel.processor.StreamResequencerTest.java</file>
			<file type="M">org.apache.camel.processor.ThreadTest.java</file>
			<file type="M">org.apache.camel.processor.interceptor.TraceFormatter.java</file>
			<file type="M">org.apache.camel.component.log.LogFormatter.java</file>
			<file type="M">org.apache.camel.converter.stream.StreamCache.java</file>
			<file type="M">org.apache.camel.converter.stream.StreamCacheConverter.java</file>
			<file type="M">org.apache.camel.processor.interceptor.StreamCachingInterceptorTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="860" opendate="2008-08-27 13:58:57" fixdate="2008-08-30 11:00:58" resolution="Fixed">
		<buginformation>
			<summary>DeadLetterChannel does not set the EXCEPTION_CAUSE_PROPERTY</summary>
			<description>The DeadLetterChannel does not set the EXCEPTION_CAUSE_PROPERTY.
It looks like a bug in the method:
public boolean process(final Exchange exchange, final AsyncCallback callback, final RedeliveryData data) 
The property is set by getting the Exception from the exchange:
exchange.setProperty(EXCEPTION_CAUSE_PROPERTY, exchange.getException());
but several lines before the Exception ist set to null in exchange:
if (exchange.getException() != null) {
                Throwable e = exchange.getException();
                exchange.setException(null); // Reset it since we are handling it.
to fix the bug, i think it is simply done by preserving the Throwable like this
Throwable e = exchange.getException();
if (exchange.getException() != null) {
                exchange.setException(null); // Reset it since we are handling it.
...
exchange.setProperty(EXCEPTION_CAUSE_PROPERTY, e);
</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.DeadLetterChannelTest.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerTest.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannel.java</file>
		</fixedFiles>
	</bug>
	<bug id="851" opendate="2008-08-26 11:43:31" fixdate="2008-09-01 09:51:45" resolution="Fixed">
		<buginformation>
			<summary>camel:dot - spring xml files located in different folder </summary>
			<description>camel:dot doesn&amp;amp;apos;t support loading spring .xml files using the configuration option to the plugin. Currently it loads from META-INF/spring/*.xml
The other two: run and embedded has this feature.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.maven.EmbeddedMojo.java</file>
			<file type="M">org.apache.camel.maven.DotMojo.java</file>
		</fixedFiles>
	</bug>
	<bug id="873" opendate="2008-09-01 09:27:18" fixdate="2008-09-03 07:00:07" resolution="Fixed">
		<buginformation>
			<summary>Current mina component can&amp;apos;t tansfer the exchange fault message body</summary>
			<description>I just found MinaTransferExchangeOptionTest don&amp;amp;apos;t show how to set fault message and the fault message is not a part of MinaPayloadHolder.
You can&amp;amp;apos;t set the exception on the exchange in the processor , sine the camel DeadLetterChannel will try to redeliver the message.
So we just need to support put the exception which need to send back to the camel client into the fault message body.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina.MinaTcpWithInOutUsingPlainSocketTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaTcpWithIoOutProcessorExceptionTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaConsumer.java</file>
			<file type="M">org.apache.camel.component.mina.MinaPayloadHolder.java</file>
			<file type="M">org.apache.camel.component.jms.JmsIOConverter.java</file>
			<file type="M">org.apache.camel.component.mina.MinaProducer.java</file>
			<file type="M">org.apache.camel.component.mina.MinaEndpoint.java</file>
			<file type="M">org.apache.camel.component.mina.MinaConverterTest.java</file>
			<file type="M">org.apache.camel.converter.IOConverter.java</file>
			<file type="M">org.apache.camel.component.mina.MinaComponent.java</file>
			<file type="M">org.apache.camel.converter.NIOConverter.java</file>
			<file type="M">org.apache.camel.component.mina.MinaPayloadHelper.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.component.mina.MinaUdpWithInOutUsingPlainSocketTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaConverter.java</file>
			<file type="M">org.apache.camel.component.mina.MinaTransferExchangeOptionTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="880" opendate="2008-09-05 18:21:56" fixdate="2008-09-06 03:18:44" resolution="Fixed">
		<buginformation>
			<summary>Headers lost when using scriptBuilder to set headers dynamically</summary>
			<description>When running a dynamic script evaluation in a setHeader, the header is lost as the Pipeline chain uses the data from the out body as the source of headers. 
So trying to figure this out, I looked into the source, and found that if the getOut is not null, the out message is used to set the header in the setHeader processor. Unfortunately in the script engine this block of code always ensures that it&amp;amp;apos;s NOT null. 
script builder class line 520 of Camel 1.4 
        ScriptContext context = engine.getContext(); 
        int scope = ScriptContext.ENGINE_SCOPE; 
        context.setAttribute("context", exchange.getContext(), scope); 
        context.setAttribute("exchange", exchange, scope); 
        context.setAttribute("request", exchange.getIn(), scope); 
        context.setAttribute("response", exchange.getOut(), scope); 
The place were the out message is used is here in the Pipeline class at line 79 
            if (first) 
{ 
                first = false; 
            }
 else 
{ 
                nextExchange = createNextExchange(processor, nextExchange); 
            }
 
The specifics of my setup were:
Used spring with the following configuration:
	&amp;lt;camel:camelContext&amp;gt;
		&amp;lt;camel:route&amp;gt;
			&amp;lt;camel:from uri="jms://LLAQueue?disableReplyTo=true" /&amp;gt;
			&amp;lt;camel:setHeader headerName="activity.type"&amp;gt;
				&amp;lt;camel:jxpath&amp;gt;exchange.getIn().getBody().getExerciseHighLevelActivity().getActivityType()&amp;lt;/camel:jxpath&amp;gt;
			&amp;lt;/camel:setHeader&amp;gt;
			&amp;lt;camel:choice&amp;gt;
				&amp;lt;camel:when&amp;gt;
					&amp;lt;camel:javaScript&amp;gt;
						exchange.getIn().getHeader(&amp;amp;apos;activity.type&amp;amp;apos;) == 3
					&amp;lt;/camel:javaScript&amp;gt;
					&amp;lt;camel:transform&amp;gt;
						&amp;lt;camel:javaScript&amp;gt;
							exchange.getIn().getBody().getData() !=
							undefined ?
							exchange.getIn().getBody().getData() : ""
						&amp;lt;/camel:javaScript&amp;gt;
					&amp;lt;/camel:transform&amp;gt;
					&amp;lt;camel:to uri="log:info?showAll=true" /&amp;gt;
				&amp;lt;/camel:when&amp;gt;
			&amp;lt;/camel:choice&amp;gt;
		&amp;lt;/camel:route&amp;gt;
	&amp;lt;/camel:camelContext&amp;gt;
I did not test this problem with other exchange types, just the JMS type.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.script.GroovyScriptRouteTest.java</file>
			<file type="M">org.apache.camel.builder.script.ScriptBuilder.java</file>
			<file type="M">org.apache.camel.builder.script.JavaScriptExpressionTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="881" opendate="2008-09-07 13:32:28" fixdate="2008-09-07 13:53:33" resolution="Fixed">
		<buginformation>
			<summary>camel-mina - codec options should fail if not possible to find i registry</summary>
			<description>If you configure the codec option on camel-mina and you eg make a spelling mistake camel will default to Mina default protocol if not found. We should throw an exception instead so end user knows about this and can fix his spelling mistake.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina.MinaCustomCodecTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaEncodingTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaTcpTextlineProtocolTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="794" opendate="2008-08-08 03:02:15" fixdate="2008-09-07 16:58:04" resolution="Fixed">
		<buginformation>
			<summary>Pipeline with thread() processor also redelivers following the default policy independently from the preset  errorhadling </summary>
			<description>When using the thread processor in a simple pipeline, the exchange will be redelivered 6 times (default policy) along with the preset errorhandler settings. The code below will re-deliver 6 times to the default DeadLetterChannel and once to the log:errorTester.
    	errorHandler(deadLetterChannel("log:errorTester?level=ERROR").maximumRedeliveries(1));
    	from("seda:whatEver")
        .thread(2)
       	.process(new Processor() {
        		public void process(Exchange exchange) throws Exception 
{
        			System.out.println("### Exchg : " + exchange.getExchangeId());
        			throw new Exception("Kaboom 2!");
        		}
        });</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.issues.BelasThreadErrorHandlerIssue794Test.java</file>
			<file type="M">org.apache.camel.model.ThreadType.java</file>
		</fixedFiles>
	</bug>
	<bug id="882" opendate="2008-09-07 21:51:51" fixdate="2008-09-08 01:10:40" resolution="Fixed">
		<buginformation>
			<summary>SftpEndpoint ignores custom ssh port</summary>
			<description>SftpEndpoint ignores custom ssh port. It works only if server runs on port 22. </description>
			<version>1.5.0</version>
			<fixedVersion>1.4.0, 1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.SftpEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="890" opendate="2008-09-10 16:57:34" fixdate="2008-09-12 15:29:38" resolution="Fixed">
		<buginformation>
			<summary>Camel-RMI looks up wrong name in RMI Registry</summary>
			<description>It appears the RMI component is not pulling the right name from the URI I defined in my routebuilder.  
In a separate application (the one I&amp;amp;apos;m trying to connect and send data to), I&amp;amp;apos;ve bound a remote object in the RMI Registry as: "GDRService".  (I even wrote a little app to list the RMI registry entries and it does indeed show up as "GDRService").
However, my camel route:    .to("rmi://localhost:1099/GDRService");
produces this result...
java.rmi.NotBoundException: /GDRService
        at sun.rmi.registry.RegistryImpl.lookup(RegistryImpl.java:106)
        at sun.rmi.registry.RegistryImpl_Skel.dispatch(Unknown Source)
....
I think this is the problem...
According to the code for  RMIEndPoint:
public String getName() {
        String path = uri.getPath();
        if (path == null) 
{
            path = uri.getSchemeSpecificPart();
        }
        return path;
    }
I believe uri.getPath() is returning "/GDRService" and not "GDRService" and thus, Camel can&amp;amp;apos;t find the actual service. 
Here&amp;amp;apos;s a longer stacktrace (just the last of the 5 attempts to route via RMI prior to dead-letter drop).
[          AnonymousIoService-2] DeadLetterChannel              ERROR Failed delivery for exchangeId: ID-dmco500084358/
683-1221065595195/0-0. On delivery attempt: 5 caught: java.rmi.NotBoundException: /GDRService
java.rmi.NotBoundException: /GDRService
        at sun.rmi.registry.RegistryImpl.lookup(RegistryImpl.java:106)
        at sun.rmi.registry.RegistryImpl_Skel.dispatch(Unknown Source)
        at sun.rmi.server.UnicastServerRef.oldDispatch(UnicastServerRef.java:386)
        at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:250)
        at sun.rmi.transport.Transport$1.run(Transport.java:159)
        at java.security.AccessController.doPrivileged(Native Method)
        at sun.rmi.transport.Transport.serviceCall(Transport.java:155)
        at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:535)
        at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:790)
        at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:649)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:885)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)
        at java.lang.Thread.run(Thread.java:619)
        at sun.rmi.transport.StreamRemoteCall.exceptionReceivedFromServer(StreamRemoteCall.java:255)
        at sun.rmi.transport.StreamRemoteCall.executeCall(StreamRemoteCall.java:233)
        at sun.rmi.server.UnicastRef.invoke(UnicastRef.java:359)
        at sun.rmi.registry.RegistryImpl_Stub.lookup(Unknown Source)
        at org.apache.camel.component.rmi.RmiRegistryBean.lookupBean(RmiRegistryBean.java:44)
        at org.apache.camel.component.bean.RegistryBean.getBean(RegistryBean.java:61)
        at org.apache.camel.component.bean.BeanProcessor.process(BeanProcessor.java:73)
        at org.apache.camel.component.rmi.RmiProducer.process(RmiProducer.java:46)
        at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsyncProcessorBridge.process(AsyncPro
essorTypeConverter.java:43)
        at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:75)
        at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:57)
        at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:155)
        at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:91)
        at org.apache.camel.processor.Pipeline.process(Pipeline.java:101)
        at org.apache.camel.processor.Pipeline.process(Pipeline.java:85)
        at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:57)
        at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:39)
        at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:41)
        at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:66)
        at org.apache.camel.component.mina.MinaConsumer$ReceiveHandler.messageReceived(MinaConsumer.java:95)
        at org.apache.mina.common.support.AbstractIoFilterChain$TailFilter.messageReceived(AbstractIoFilterChain.java:5
0)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:299)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1100(AbstractIoFilterChain.java:53)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:
48)
        at org.apache.mina.filter.codec.support.SimpleProtocolDecoderOutput.flush(SimpleProtocolDecoderOutput.java:58)
        at org.apache.mina.filter.codec.ProtocolCodecFilter.messageReceived(ProtocolCodecFilter.java:180)
        at org.apache.mina.common.support.AbstractIoFilterChain.callNextMessageReceived(AbstractIoFilterChain.java:299)
        at org.apache.mina.common.support.AbstractIoFilterChain.access$1100(AbstractIoFilterChain.java:53)
        at org.apache.mina.common.support.AbstractIoFilterChain$EntryImpl$1.messageReceived(AbstractIoFilterChain.java:
48)
        at org.apache.mina.filter.executor.ExecutorFilter.processEvent(ExecutorFilter.java:220)
        at org.apache.mina.filter.executor.ExecutorFilter$ProcessEventsRunnable.run(ExecutorFilter.java:264)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:885)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:907)
        at org.apache.mina.util.NamePreservingRunnable.run(NamePreservingRunnable.java:51)
        at java.lang.Thread.run(Thread.java:619)
[          AnonymousIoService-2] DefaultListableBeanFactory     DEBUG Creating instance of bean &amp;amp;apos;org.apache.camel.compo
ent.log.LogComponent&amp;amp;apos;
[          AnonymousIoService-2] DefaultListableBeanFactory     DEBUG Finished creating instance of bean &amp;amp;apos;org.apache.ca
el.component.log.LogComponent&amp;amp;apos;
[          AnonymousIoService-2] DeadLetterChannel              ERROR Exchange[BodyType:String, Body:&amp;lt;?xml version="1.0............
</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rmi.RmiEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="885" opendate="2008-09-09 15:08:36" fixdate="2008-09-12 17:53:30" resolution="Fixed">
		<buginformation>
			<summary>DefaultProducerTemplate.extractResultBody() should throw an exception if there was a failure rather than returning the input message</summary>
			<description>we should throw an exception if there was a Fault or the exchange contains an Exception</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanExchangeAsReturnTypeNotAllowedTest.java</file>
			<file type="M">org.apache.camel.spring.config.DeadLetterChannelRedeliveryConfigTest.java</file>
			<file type="M">org.apache.camel.processor.ValidationFinallyBlockNoCatchTest.java</file>
			<file type="M">org.apache.camel.ContextTestSupport.java</file>
			<file type="M">org.apache.camel.issues.ExceptionTest.java</file>
			<file type="M">org.apache.camel.issues.CacheInputStreamInDeadLetterIssue520Test.java</file>
			<file type="M">org.apache.camel.issues.ThreadErrorHandlerTest.java</file>
			<file type="M">org.apache.camel.issues.RomeksExceptionTest.java</file>
			<file type="M">org.apache.camel.processor.MultiErrorHandlerInRouteTest.java</file>
			<file type="M">org.apache.camel.issues.BelasThreadErrorHandlerIssue794Test.java</file>
			<file type="M">org.apache.camel.ProducerTemplate.java</file>
			<file type="M">org.apache.camel.spring.spi.TransactionInterceptor.java</file>
			<file type="M">org.apache.camel.impl.DefaultProducerTemplate.java</file>
			<file type="M">org.apache.camel.processor.ValidationTest.java</file>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientDataSourceTest.java</file>
			<file type="M">org.apache.camel.processor.interceptor.TraceInterceptorTest.java</file>
			<file type="M">org.apache.camel.builder.ExceptionBuilderTest.java</file>
			<file type="M">org.apache.camel.processor.FaultRouteTest.java</file>
			<file type="M">org.apache.camel.processor.BeanWithExceptionTest.java</file>
			<file type="M">org.apache.camel.processor.LoggingErrorHandlerTest.java</file>
			<file type="M">org.apache.camel.component.jms.JmsRouteRequestReplyTest.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannelRedeliveryTest.java</file>
			<file type="M">org.apache.camel.processor.ValidationWithErrorInHandleAndFinallyBlockTest.java</file>
			<file type="M">org.apache.camel.processor.ValidatingProcessorTest.java</file>
			<file type="M">org.apache.camel.processor.exceptionpolicy.CustomExceptionPolicyStrategyTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="894" opendate="2008-09-13 16:16:07" fixdate="2008-09-13 21:11:04" resolution="Fixed">
		<buginformation>
			<summary>camel-ftp - handle invalid login better</summary>
			<description>If the login to the FTP server fails then Camel will at the 2nd pool still try to consume files from the ftp server as it has network connection, but end-user is still not connected. Camel will of course not be able to get anything from the server but you get some stacktrace errors</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpProducer.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpToAsciiFileNoBodyConversionTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpOperationFailedException.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpUtils.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="871" opendate="2008-08-30 12:51:01" fixdate="2008-09-15 17:24:52" resolution="Fixed">
		<buginformation>
			<summary>camel-spring - data format using camel xml elements doesnt work</summary>
			<description>If you have a route that uses data format and you configure the data format using camel xml elements it doesn&amp;amp;apos;t work.
See nabble: 
http://www.nabble.com/xstream-in-xml-configuration-td19227970s22882.html</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.CamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.model.dataformat.DataFormatType.java</file>
			<file type="M">org.apache.camel.spi.RouteContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultRouteContext.java</file>
			<file type="M">org.apache.camel.spring.handler.CamelNamespaceHandler.java</file>
			<file type="M">org.apache.camel.model.MarshalType.java</file>
			<file type="M">org.apache.camel.model.UnmarshalType.java</file>
		</fixedFiles>
	</bug>
	<bug id="886" opendate="2008-09-09 16:12:34" fixdate="2008-09-15 19:19:35" resolution="Fixed">
		<buginformation>
			<summary>&lt;jaxb&gt; element should not require contextPath attribute</summary>
			<description>In the Java DSL, you can say from("foo").marshal().jaxb().to("bar")
In XML I think it would look like this:
&amp;lt;from uri="..." /&amp;gt;
&amp;lt;marshal&amp;gt;
  &amp;lt;jaxb /&amp;gt;
&amp;lt;/marshal&amp;gt;
&amp;lt;to uri="..." /&amp;gt;
The problem is that you can&amp;amp;apos;t use the &amp;lt;jaxb /&amp;gt; element without the contextPath attribute, which the XSD says is required.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.dataformat.JaxbDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="902" opendate="2008-09-15 07:05:14" fixdate="2008-09-16 04:46:10" resolution="Fixed">
		<buginformation>
			<summary>The should throw the exception if there is some thing wrong with &lt;convertBodyTo&gt; type attribute</summary>
			<description>If you specify an invalided class name in the  convertBodyTo@type, you will get a NPE error, but no detail log information for the type attribute.
We need to throw the exception for user to locate the error.</description>
			<version>1.3.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.ConvertBodyProcessor.java</file>
			<file type="M">org.apache.camel.model.ConvertBodyType.java</file>
		</fixedFiles>
	</bug>
	<bug id="906" opendate="2008-09-16 07:36:50" fixdate="2008-09-16 08:45:51" resolution="Fixed">
		<buginformation>
			<summary>JmsProducer - option requestTimeout isn&amp;apos;t configured properly</summary>
			<description>When sending a JMS message to a destination using camel-jms (JMSProducer) I can&amp;amp;apos;t get it to use my requestTimeout option in the endpoint configuration. It always default to 20000.

template.requestBody("activemq:queue:slow?requestTimeout=1000", "Hello World");


This doesn&amp;amp;apos;t work as expected with a timeout of only 1 sec.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.JmsConfiguration.java</file>
			<file type="M">org.apache.camel.component.jms.JmsProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="912" opendate="2008-09-16 22:16:34" fixdate="2008-09-17 00:38:59" resolution="Fixed">
		<buginformation>
			<summary>camel-cxf component is not passing request context through correctly</summary>
			<description>CxfProducer.process() is not setting up the request context correctly during createCxfMessage, so later in that method propagateContext has no request data to propagate.  Also, we need the exchange properties to be added to the request context, so that non-camel components can pass properties into the cxf request context.
I have coded a fix for this, along with a unit test of course.  I&amp;amp;apos;ll attach the patch to this JIRA.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfProducerContextTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="914" opendate="2008-09-17 12:26:38" fixdate="2008-09-18 18:33:56" resolution="Fixed">
		<buginformation>
			<summary>Camel Maven plugin should not look for routes in target/test-classes</summary>
			<description>Currently the Maven Plugin attempts to load Camel Routes from both target/classes and target/test-classes.  This causes an issue when you have the same package defined for testing as you have in your Camel Context.  An example problem is using a super class for a test which is only available a test dependency which results in a ClassNotFoundException.
I would propose one of the following:

Prevent the plugin from using target/test-classes altogther
Add a mojo parameter to allow for routes under test-classes to be scanned
	
This should default to False
If this parameter is set to True then the plugin should add dependencies marked as "test" to the classpath



</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.maven.RunMojo.java</file>
		</fixedFiles>
	</bug>
	<bug id="921" opendate="2008-09-19 10:25:31" fixdate="2008-09-19 10:35:58" resolution="Fixed">
		<buginformation>
			<summary>ResolverUtil complain about cant find the convert package in Servicemix 4</summary>
			<description>java.io.FileNotFoundException: /org/apache/camel/converter (No such file or directory)
        at java.io.FileInputStream.open(Native Method)
        at java.io.FileInputStream.&amp;lt;init&amp;gt;(FileInputStream.java:106)
        at org.apache.camel.util.ResolverUtil.loadImplementationsInJar(ResolverUtil.java:476)
        at org.apache.camel.util.ResolverUtil.find(ResolverUtil.java:362)
        at org.apache.camel.util.ResolverUtil.find(ResolverUtil.java:277)
        at org.apache.camel.util.ResolverUtil.findAnnotated(ResolverUtil.java:253)
        at org.apache.camel.impl.converter.AnnotationTypeConverterLoader.load(AnnotationTypeConverterLoader.java:66)
        at org.apache.camel.impl.converter.DefaultTypeConverter.checkLoaded(DefaultTypeConverter.java:218)
        at org.apache.camel.impl.converter.DefaultTypeConverter.convertTo(DefaultTypeConverter.java:64)
        at org.apache.camel.util.IntrospectionSupport.convert(IntrospectionSupport.java:216)
        at org.apache.camel.util.IntrospectionSupport.setProperty(IntrospectionSupport.java:194)
        at org.apache.camel.util.IntrospectionSupport.setProperties(IntrospectionSupport.java:167)
        at org.apache.camel.impl.DefaultComponent.setProperties(DefaultComponent.java:181)
        at org.apache.camel.component.timer.TimerComponent.createEndpoint(TimerComponent.java:54)
        at org.apache.camel.impl.DefaultComponent.createEndpoint(DefaultComponent.java:81)
        at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:253)
        at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:52)
        at org.apache.camel.model.RouteType.resolveEndpoint(RouteType.java:100)
        at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:102)
        at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:108)
        at org.apache.camel.model.FromType.resolveEndpoint(FromType.java:73)
        at org.apache.camel.impl.DefaultRouteContext.getEndpoint(DefaultRouteContext.java:77)
        at org.apache.camel.model.RouteType.addRoutes(RouteType.java:214)
        at org.apache.camel.model.RouteType.addRoutes(RouteType.java:90)
        at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:520)
        at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:512)
        at org.apache.camel.spring.SpringCamelContext.doStart(SpringCamelContext.java:149)
        at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:47)
        at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:103)
        at org.springframework.context.event.SimpleApplicationEventMulticaster$1.run(SimpleApplicationEventMulticaster.java:78)
        at org.springframework.core.task.SyncTaskExecutor.execute(SyncTaskExecutor.java:49)
        at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:76)
        at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:275)
        at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:737)
        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:384)
        at org.apache.servicemix.common.xbean.AbstractXBeanDeployer.deploy(AbstractXBeanDeployer.java:86)
        at org.apache.servicemix.camel.CamelSpringDeployer.deploy(CamelSpringDeployer.java:71)
        at org.apache.servicemix.common.BaseServiceUnitManager.doDeploy(BaseServiceUnitManager.java:88)
        at org.apache.servicemix.common.BaseServiceUnitManager.deploy(BaseServiceUnitManager.java:69)
        at org.apache.servicemix.jbi.deployer.impl.ServiceUnitImpl.deploy(ServiceUnitImpl.java:89)
        at org.apache.servicemix.jbi.deployer.impl.Deployer.deployServiceAssembly(Deployer.java:306)
        at org.apache.servicemix.jbi.deployer.impl.Deployer.register(Deployer.java:170)
        at org.apache.servicemix.jbi.deployer.impl.AbstractBundleWatcher.onBundleStarted(AbstractBundleWatcher.java:80)
        at org.apache.servicemix.jbi.deployer.impl.AbstractBundleWatcher.access$000(AbstractBundleWatcher.java:34)
        at org.apache.servicemix.jbi.deployer.impl.AbstractBundleWatcher$1.bundleChanged(AbstractBundleWatcher.java:53)
        at org.apache.felix.framework.util.EventDispatcher.invokeBundleListenerCallback(EventDispatcher.java:690)
        at org.apache.felix.framework.util.EventDispatcher.fireEventImmediately(EventDispatcher.java:619)
        at org.apache.felix.framework.util.EventDispatcher.fireBundleEvent(EventDispatcher.java:532)
        at org.apache.felix.framework.Felix.fireBundleEvent(Felix.java:3601)
        at org.apache.felix.framework.Felix._startBundle(Felix.java:1616)
        at org.apache.felix.framework.Felix.startBundle(Felix.java:1544)
        at org.apache.felix.framework.BundleImpl.start(BundleImpl.java:371)
        at org.apache.servicemix.kernel.filemonitor.FileMonitor.refreshPackagesAndStartOrUpdateBundles(FileMonitor.java:550)
        at org.apache.servicemix.kernel.filemonitor.FileMonitor.onFilesChanged(FileMonitor.java:297)
        at org.apache.servicemix.kernel.filemonitor.FileMonitor$1.filesChanged(FileMonitor.java:140)
        at org.apache.servicemix.kernel.filemonitor.Scanner.reportBulkChanges(Scanner.java:433)
        at org.apache.servicemix.kernel.filemonitor.Scanner.reportDifferences(Scanner.java:322)
        at org.apache.servicemix.kernel.filemonitor.Scanner.scan(Scanner.java:254)
        at org.apache.servicemix.kernel.filemonitor.Scanner$1.run(Scanner.java:214)
        at java.util.TimerThread.mainLoop(Timer.java:512)
        at java.util.TimerThread.run(Timer.java:462)
18:10:15,452 | ERROR | Timer-1          | ResolverUtil                     | g.apache.camel.util.ResolverUtil  489 | Could not search jar file &amp;amp;apos;/org/apache/camel/converter&amp;amp;apos; for classes matching criteria: annotated with @Converter due to an IOException: /org/apache/camel/converter (No such file or directory)
java.io.FileNotFoundException: /org/apache/camel/converter (No such file or directory)
        at java.io.FileInputStream.open(Native Method)
        at java.io.FileInputStream.&amp;lt;init&amp;gt;(FileInputStream.java:106)
        at org.apache.camel.util.ResolverUtil.loadImplementationsInJar(ResolverUtil.java:476)
        at org.apache.camel.util.ResolverUtil.find(ResolverUtil.java:362)
        at org.apache.camel.util.ResolverUtil.find(ResolverUtil.java:277)
        at org.apache.camel.util.ResolverUtil.findAnnotated(ResolverUtil.java:253)
        at org.apache.camel.impl.converter.AnnotationTypeConverterLoader.load(AnnotationTypeConverterLoader.java:66)
        at org.apache.camel.impl.converter.DefaultTypeConverter.checkLoaded(DefaultTypeConverter.java:218)
        at org.apache.camel.impl.converter.DefaultTypeConverter.convertTo(DefaultTypeConverter.java:64)
        at org.apache.camel.util.IntrospectionSupport.convert(IntrospectionSupport.java:216)
        at org.apache.camel.util.IntrospectionSupport.setProperty(IntrospectionSupport.java:194)
        at org.apache.camel.util.IntrospectionSupport.setProperties(IntrospectionSupport.java:167)
        at org.apache.camel.impl.DefaultComponent.setProperties(DefaultComponent.java:181)
        at org.apache.camel.component.timer.TimerComponent.createEndpoint(TimerComponent.java:54)
        at org.apache.camel.impl.DefaultComponent.createEndpoint(DefaultComponent.java:81)
        at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:253)
        at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:52)
        at org.apache.camel.model.RouteType.resolveEndpoint(RouteType.java:100)
        at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:102)
        at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:108)
        at org.apache.camel.model.FromType.resolveEndpoint(FromType.java:73)
        at org.apache.camel.impl.DefaultRouteContext.getEndpoint(DefaultRouteContext.java:77)
        at org.apache.camel.model.RouteType.addRoutes(RouteType.java:214)
        at org.apache.camel.model.RouteType.addRoutes(RouteType.java:90)
        at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:520)
        at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:512)
        at org.apache.camel.spring.SpringCamelContext.doStart(SpringCamelContext.java:149)
        at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:47)
        at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:103)
        at org.springframework.context.event.SimpleApplicationEventMulticaster$1.run(SimpleApplicationEventMulticaster.java:78)
        at org.springframework.core.task.SyncTaskExecutor.execute(SyncTaskExecutor.java:49)
        at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:76)
        at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:275)
        at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:737)
        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:384)
        at org.apache.servicemix.common.xbean.AbstractXBeanDeployer.deploy(AbstractXBeanDeployer.java:86)
        at org.apache.servicemix.camel.CamelSpringDeployer.deploy(CamelSpringDeployer.java:71)
        at org.apache.servicemix.common.BaseServiceUnitManager.doDeploy(BaseServiceUnitManager.java:88)
        at org.apache.servicemix.common.BaseServiceUnitManager.deploy(BaseServiceUnitManager.java:69)
        at org.apache.servicemix.jbi.deployer.impl.ServiceUnitImpl.deploy(ServiceUnitImpl.java:89)
        at org.apache.servicemix.jbi.deployer.impl.Deployer.deployServiceAssembly(Deployer.java:306)
        at org.apache.servicemix.jbi.deployer.impl.Deployer.register(Deployer.java:170)
        at org.apache.servicemix.jbi.deployer.impl.AbstractBundleWatcher.onBundleStarted(AbstractBundleWatcher.java:80)
        at org.apache.servicemix.jbi.deployer.impl.AbstractBundleWatcher.access$000(AbstractBundleWatcher.java:34)
        at org.apache.servicemix.jbi.deployer.impl.AbstractBundleWatcher$1.bundleChanged(AbstractBundleWatcher.java:53)
        at org.apache.felix.framework.util.EventDispatcher.invokeBundleListenerCallback(EventDispatcher.java:690)
        at org.apache.felix.framework.util.EventDispatcher.fireEventImmediately(EventDispatcher.java:619)
        at org.apache.felix.framework.util.EventDispatcher.fireBundleEvent(EventDispatcher.java:532)
        at org.apache.felix.framework.Felix.fireBundleEvent(Felix.java:3601)
        at org.apache.felix.framework.Felix._startBundle(Felix.java:1616)
        at org.apache.felix.framework.Felix.startBundle(Felix.java:1544)
        at org.apache.felix.framework.BundleImpl.start(BundleImpl.java:371)
        at org.apache.servicemix.kernel.filemonitor.FileMonitor.refreshPackagesAndStartOrUpdateBundles(FileMonitor.java:550)
        at org.apache.servicemix.kernel.filemonitor.FileMonitor.onFilesChanged(FileMonitor.java:297)
        at org.apache.servicemix.kernel.filemonitor.FileMonitor$1.filesChanged(FileMonitor.java:140)
        at org.apache.servicemix.kernel.filemonitor.Scanner.reportBulkChanges(Scanner.java:433)
        at org.apache.servicemix.kernel.filemonitor.Scanner.reportDifferences(Scanner.java:322)
        at org.apache.servicemix.kernel.filemonitor.Scanner.scan(Scanner.java:254)
        at org.apache.servicemix.kernel.filemonitor.Scanner$1.run(Scanner.java:214)
        at java.util.TimerThread.mainLoop(Timer.java:512)
        at java.util.TimerThread.run(Timer.java:462)</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.interceptor.Delayer.java</file>
			<file type="M">org.apache.camel.processor.interceptor.DelayInterceptor.java</file>
			<file type="M">org.apache.camel.util.ResolverUtil.java</file>
		</fixedFiles>
	</bug>
	<bug id="920" opendate="2008-09-19 08:47:15" fixdate="2008-09-19 18:59:39" resolution="Fixed">
		<buginformation>
			<summary>file component consumer.regexPattern does not work as expected (matching is applied not only to file, but also to directory)</summary>
			<description>file component consumer.regexPattern does not work as expected
example : from("file://d:/the_input_dir?consumer.regexPattern=.*\.xml$".to(whatever)
(should match only files, that has extention .xml)
the result of the above regexPattern is, that no file will be proccessed, regardless if an existing filename matches the pattern.
FileConsumer.pollFileOrDirectory() applies the regexPattern on the starting directory (the_input_dir) which will not match.
</description>
			<version>1.5.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="922" opendate="2008-09-19 16:06:50" fixdate="2008-09-19 20:37:25" resolution="Fixed">
		<buginformation>
			<summary>Remove deps on persistence-api jar, non compliant with the spec</summary>
			<description>I mentioned a while ago a warning I couldn&amp;amp;apos;t explain in eclipse related to the use of @UniqueConstraint in camel-jpa.
It turned out to be due to the fact that camel-jpa has a dependency on persistence api, but used for testing openjpa that has a dependency on geronimo-jpa_3.0_spec.  So camel-jpa pulls in two different implementation of the same spec.  So far so good.  It also turns out that the definition of the @UniqueConstraint annotation is different in the two jars, the persistence-api (and the camel-jpa code as implemented) being non spec compliant.  I found other inconsistencies in the persistence-api impl and it seems to be based on an older version of the spec.
(More precisely persistence api annotates the @interface UniqueConstraint with @Target(
{TYPE}
) whereas the spec and the geronimo impl use: @Target({}))
My recommendation is to replace the dependency on persistence-api with the geronimo version.  I will commit a change for this in the next hour or so, but leave this issue open.  If anybody has any objections please shout and I will revert the change.
</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.bam.model.ProcessDefinition.java</file>
			<file type="M">org.apache.camel.bam.model.ActivityDefinition.java</file>
			<file type="M">org.apache.camel.processor.idempotent.jpa.MessageProcessed.java</file>
		</fixedFiles>
	</bug>
	<bug id="925" opendate="2008-09-21 10:18:11" fixdate="2008-09-21 11:03:12" resolution="Fixed">
		<buginformation>
			<summary>file component - should throw exception if can not delete or renamed consumed file</summary>
			<description>Currently it logs at WARN level that camel could not rename/delete the consumer file after processing.
However as end-users might not notice this "could be bigger problem" we should throw an IOException instead.
PS: The File API is terrible as it returns a boolean of this operation (will be fixed in NIO2 with a much better API).
The bigger problem is that if you don&amp;amp;apos;t want to consume the file twice you should get a "exception" to track down the problem. WARN logs can be harder to track down.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileAlwaysConsumeTest.java</file>
			<file type="M">org.apache.camel.component.file.strategy.RenameFileProcessStrategy.java</file>
			<file type="M">org.apache.camel.component.file.strategy.DeleteFileProcessStrategy.java</file>
			<file type="M">org.apache.camel.component.file.strategy.FileProcessStrategySupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="919" opendate="2008-09-19 06:52:10" fixdate="2008-09-21 17:09:17" resolution="Fixed">
		<buginformation>
			<summary>RouteBuilder.getRoutes does not return routes</summary>
			<description>Suspected reason:
Looking at the code reveals that the initalization of the routebuilder actually sets the routes in the injected CamelContext, but does not populate the local list of routes. 
Consequence:
One is not able to replace routes in the CamelContext by fetching routes from routebuilders, and then set the list of routes in the camel context.



List&amp;lt;Routes&amp;gt; routeList = new ArrayList();

//Some method fetching all my builders
List&amp;lt;Routes&amp;gt; routesList = getRouteBuilders();

//Build a list of all routes, thereby updating my camel context with fresh routes...
for(Routes routes:routesList){

    //Fetches an empty list, but the builder now sets the route in the context
    List&amp;lt;Route&amp;gt; routeListFromBuilder = routes.getRouteList();

    //I am now adding an empty list to my list of routes
    routeList.addAll( routeListFromBuilder );

}

//Sets an empty list into the context, thereby clearing all routes
camleContext.setRoutes( routeList );


Possible solution:
in RouteBuilder replace:

protected void populateRoutes(List&amp;lt;Route&amp;gt; routes) throws Exception {
        CamelContext camelContext = getContext();
        if (camelContext == null) {
            throw new IllegalArgumentException("No CamelContext has been injected!");
        }
        routeCollection.setCamelContext(camelContext);
        camelContext.addRouteDefinitions(routeCollection.getRoutes());
}


with


protected void populateRoutes(List&amp;lt;Route&amp;gt; routes) throws Exception {
        CamelContext camelContext = getContext();
        if (camelContext == null) {
            throw new IllegalArgumentException("No CamelContext has been injected!");
        }
        routeCollection.setCamelContext(camelContext);
        routes.addAll(routeCollection.getRoutes());
}

</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.RouteBuilder.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.management.CamelChoiceWithManagementTest.java</file>
			<file type="M">org.apache.camel.spring.produce.MyListener.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilderTest.java</file>
			<file type="M">org.apache.camel.spring.produce.MyListenerService.java</file>
			<file type="M">org.apache.camel.spring.produce.ProduceTest.java</file>
			<file type="M">org.apache.camel.Routes.java</file>
		</fixedFiles>
	</bug>
	<bug id="934" opendate="2008-09-24 01:59:20" fixdate="2008-09-25 07:38:50" resolution="Fixed">
		<buginformation>
			<summary>current http component producer don&amp;apos;t support the https protocol</summary>
			<description>http://www.nabble.com/Is-there-an-HTTPS-producer-endpoint--td19635772s22882.html</description>
			<version>1.2.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.script.BeanShellScriptRouteTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="807" opendate="2008-08-10 22:22:11" fixdate="2008-09-25 23:27:51" resolution="Fixed">
		<buginformation>
			<summary>HttpProducer premature out message creation</summary>
			<description>I believe there is incorrect flow in the HttpProducer which can subvert error handling in the route:
in Camel 1.4.0 in HttpProducer on line 76 a "blank" out message is set on the exchange:
Message out = exchange.getOut(true);
        try {
            int responseCode = httpClient.executeMethod(method);
...
1. If an IO error occurs on connect, the out message will be passed to the error handling code and if the originating endpoint was a JmsMessage it will cause an NPE when JmsMessage.getMessageId() is called. It also obscures the offending message I believe.
2. A similar situation will happen if the HTTP service returned an error code; the out message will contain a reply message even though the processing resulted in an error (e.g. HTTP Status 500) 
3. Also, shouldn&amp;amp;apos;t this code test whether the exchange expects an "out" altogether, and if not, perhaps, put just put the return HTTP status into the "in" message header.
--Bill</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.HttpPostWithBodyTest.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="942" opendate="2008-09-28 04:02:35" fixdate="2008-09-28 04:13:00" resolution="Fixed">
		<buginformation>
			<summary>Can&amp;apos;t set the jms message header which has the Data object in JMS Component</summary>
			<description>When I came across to fix the FileRouteToJMSTest failure, I found the JMSComponent can&amp;amp;apos;t handle the message header with the Data object rightly.
org.springframework.jms.MessageFormatException: Only objectified primitive objects, String, Map and List types are allowed but was: Sun Sep 28 09:52:36 CST 2008 type: class java.util.Date; nested exception is javax.jms.MessageFormatException: Only objectified primitive objects, String, Map and List types are allowed but was: Sun Sep 28 09:52:36 CST 2008 type: class java.util.Date
	at org.springframework.jms.support.JmsUtils.convertJmsAccessException(JmsUtils.java:273)
	at org.springframework.jms.support.JmsAccessor.convertJmsAccessException(JmsAccessor.java:168)
	at org.springframework.jms.core.JmsTemplate.execute(JmsTemplate.java:474)
	at org.springframework.jms.core.JmsTemplate.send(JmsTemplate.java:548)
	at org.apache.camel.component.jms.JmsProducer.process(JmsProducer.java:227)
	at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsyncProcessorBridge.process(AsyncProcessorTypeConverter.java:43)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:75)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:57)
	at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:174)
	at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:96)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:57)
	at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:39)
	at org.apache.camel.component.file.FileConsumer.pollFile(FileConsumer.java:153)
	at org.apache.camel.component.file.FileConsumer.pollFileOrDirectory(FileConsumer.java:89)
	at org.apache.camel.component.file.FileConsumer.pollFileOrDirectory(FileConsumer.java:99)
	at org.apache.camel.component.file.FileConsumer.poll(FileConsumer.java:65)
	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:66)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:417)
	at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:280)
	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:135)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:65)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:142)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:166)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675)
	at java.lang.Thread.run(Thread.java:595)
Caused by: javax.jms.MessageFormatException: Only objectified primitive objects, String, Map and List types are allowed but was: Sun Sep 28 09:52:36 CST 2008 type: class java.util.Date
	at org.apache.activemq.command.ActiveMQMessage.checkValidObject(ActiveMQMessage.java:432)
	at org.apache.activemq.command.ActiveMQMessage.setObjectProperty(ActiveMQMessage.java:397)
	at org.apache.activemq.command.ActiveMQMessage.setObjectProperty(ActiveMQMessage.java:385)
	at org.apache.activemq.command.ActiveMQBytesMessage.setObjectProperty(ActiveMQBytesMessage.java:844)
	at org.apache.camel.component.jms.JmsBinding.appendJmsProperty(JmsBinding.java:254)
	at org.apache.camel.component.jms.JmsBinding.appendJmsProperties(JmsBinding.java:220)
	at org.apache.camel.component.jms.JmsBinding.makeJmsMessage(JmsBinding.java:198)
	at org.apache.camel.component.jms.JmsProducer$2.createMessage(JmsProducer.java:229)
	at org.springframework.jms.core.JmsTemplate.doSend(JmsTemplate.java:570)
	at org.springframework.jms.core.JmsTemplate$4.doInJms(JmsTemplate.java:551)
	at org.springframework.jms.core.JmsTemplate.execute(JmsTemplate.java:471)
	... 23 more
</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="927" opendate="2008-09-22 06:09:04" fixdate="2008-09-28 08:35:56" resolution="Fixed">
		<buginformation>
			<summary>Double input without output produce exception</summary>
			<description>Turn trace on.
Run this route:
		from("timer://kickoff_1?period=10000&amp;amp;delay=1");
As expected there is output from Trace Interceptor every 10 sec.
Now run this route:
		from("timer://kickoff_1?period=10000&amp;amp;delay=1").
		from("timer://kickoff_2?period=10000&amp;amp;delay=2");
You will get exception:
2008-09-22 06:03:01,871 [d=10000&amp;amp;delay=2] INFO  TraceInterceptor               - ID-ubuntu/50540-1222063381751/2-1 -&amp;gt; interceptor1 Interceptor[Delegate(null)] InOnly Properties:
{org.apache.camel.timer.name=kickoff_2, org.apache.camel.timer.firedTime=Mon Sep 22 06:03:01 GMT 2008, org.apache.camel.timer.period=10000}
 Headers:
{firedTime=Mon Sep 22 06:03:01 GMT 2008}
 BodyType:null Body:Message: null
2008-09-22 06:03:01,872 [d=10000&amp;amp;delay=2] ERROR DeadLetterChannel              - Failed delivery for exchangeId: ID-ubuntu/50540-1222063381751/0-0. On delivery attempt: 0 caught: java.lang.NullPointerException
java.lang.NullPointerException
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:69)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:41)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:50)
	at org.apache.camel.processor.DelegateProcessor.processNext(DelegateProcessor.java:50)
	at org.apache.camel.processor.DelegateProcessor.proceed(DelegateProcessor.java:79)
	at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:67)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:69)
	at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:174)
	at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:96)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:57)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:41)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:50)
	at org.apache.camel.processor.DelegateProcessor.processNext(DelegateProcessor.java:50)
	at org.apache.camel.processor.DelegateProcessor.proceed(DelegateProcessor.java:79)
	at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:67)
	at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsyncProcessorBridge.process(AsyncProcessorTypeConverter.java:43)
	at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:39)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:41)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:66)
	at org.apache.camel.component.timer.TimerConsumer.sendTimerExchange(TimerConsumer.java:98)
	at org.apache.camel.component.timer.TimerConsumer$1.run(TimerConsumer.java:49)
	at java.util.TimerThread.mainLoop(Timer.java:512)
	at java.util.TimerThread.run(Timer.java:462)
Why single input works fine and two produce an exception?</description>
			<version>1.5.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.camel.issues.TwoTimerWithJMSIssue.java</file>
			<file type="M">org.apache.camel.management.InstrumentationProcessor.java</file>
			<file type="M">org.apache.camel.TestSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="958" opendate="2008-10-02 14:31:50" fixdate="2008-10-05 14:45:12" resolution="Fixed">
		<buginformation>
			<summary>Inconsistency in recipient list documentation?</summary>
			<description>The mail thread at http://tinyurl.com/47bqre seems to contradict the documentation at http://activemq.apache.org/camel/recipient-list.html  not sure if this is a doc issue, or a camel behavioural issue.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.WireTapTest.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilderTest.java</file>
			<file type="M">org.apache.camel.processor.RecipientList.java</file>
			<file type="M">org.apache.camel.language.XPathTest.java</file>
			<file type="M">org.apache.camel.builder.ValueBuilder.java</file>
			<file type="M">org.apache.camel.NoSuchEndpointException.java</file>
		</fixedFiles>
	</bug>
	<bug id="970" opendate="2008-10-08 17:40:06" fixdate="2008-10-08 18:23:21" resolution="Fixed">
		<buginformation>
			<summary>createConnector attribute for CamelJMXAgentType should default to &amp;apos;true&amp;apos;</summary>
			<description></description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.CamelJMXAgentType.java</file>
		</fixedFiles>
	</bug>
	<bug id="969" opendate="2008-10-08 14:16:39" fixdate="2008-10-08 19:16:01" resolution="Fixed">
		<buginformation>
			<summary>CamelContext.setRoutes() documentation is misleading</summary>
			<description>The javaDoc for CamelContext.setRoutes() states:
"Sets the routes for this context, replacing any current routes"
Yet when used, and the context started, startRouteDefinitions() is used first, causing any existing routes created through the definitions (such as those from RouteBuilders) to be re-created and started before the new routes provided to setRoutes() are started.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.CamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="983" opendate="2008-10-13 19:05:35" fixdate="2008-10-15 18:54:29" resolution="Fixed">
		<buginformation>
			<summary>BeanInfo - should consider overridden methods when selecting method from operations list</summary>
			<description>See nabble:
http://www.nabble.com/BeanInfo.chooseMethodWithMatchingBody-throws-an-AmbiguousMethodCallException-when-there%27s-no-ambiguity-td19959124s22882.html</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
			<file type="M">org.apache.camel.processor.SplitterTest.java</file>
			<file type="M">org.apache.camel.processor.BeanRecipientListTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="980" opendate="2008-10-13 07:20:02" fixdate="2008-10-16 20:53:45" resolution="Fixed">
		<buginformation>
			<summary>File component - can not delete consumed file when processing failed (look into real cause)</summary>
			<description>See nabble:
http://www.nabble.com/Problem-with-FileEndpoint-td19940096s22882.html
Workaround
Use .convertBodyTo(String.class) in the route so the file is read into memory, and the java.io.File handler shouldn&amp;amp;apos;t be open/locked when camel attempts to delete it after wards.</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.camel.dataformat.xstream.MarshalDomainObject.java</file>
			<file type="M">org.apache.camel.impl.SerializationDataFormat.java</file>
			<file type="M">org.apache.camel.component.flatpack.FlatpackDataFormat.java</file>
			<file type="M">org.apache.camel.converter.jaxb.FallbackTypeConverter.java</file>
			<file type="M">org.apache.camel.dataformat.xstream.XStreamDataFormat.java</file>
			<file type="M">org.apache.camel.example.JAXBConvertTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1003" opendate="2008-10-21 05:42:14" fixdate="2008-10-21 14:32:28" resolution="Fixed">
		<buginformation>
			<summary>seda component - will lose message if its stopped while it polls</summary>
			<description>See attached patch for details
Unit test inspired by nabble:
http://www.nabble.com/Wait-for-condition-td20064420s22882.html</description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.seda.SedaConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1001" opendate="2008-10-20 15:33:27" fixdate="2008-10-21 17:36:01" resolution="Fixed">
		<buginformation>
			<summary>ExceptionType handledPolicy is not exposed in the XSD</summary>
			<description>ExceptionType handledPolicy is not exposed in the XSD. 
See nabble thread http://www.nabble.com/RE%3A-How-to-express-new-%22handled%22-predicate-in-Spring-DSL-p20069223.html.</description>
			<version>1.5.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ExceptionType.java</file>
		</fixedFiles>
	</bug>
	<bug id="901" opendate="2008-09-14 21:17:42" fixdate="2008-10-22 04:51:57" resolution="Fixed">
		<buginformation>
			<summary>If using thread() processor followed by a pipeline Camel redelivers to the wrong processor</summary>
			<description>Setup:
Error handler is specified before the thread processor and there are 3 processor after the thread() call. Third processor fails. 
Bug #1:
The exchange received by the failed processor (#3) gets redelivered to the first processor in the pipe.
It should be redeliver to #3 (this works without the thread processor).
Bug #2:
The specified errorHandler (log:testError) receives the exchange that entered processor #1 (first in the pipe).
See details in the attached unit test. Also take a look at the log4j log (copy attached). The 3rd line from the bottom is the log by testError. </description>
			<version>1.0.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.Pipeline.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannel.java</file>
			<file type="M">org.apache.camel.issues.BelasThreadErrorHandlerIssue901Test.java</file>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.model.ExceptionType.java</file>
		</fixedFiles>
	</bug>
	<bug id="1027" opendate="2008-10-27 08:30:13" fixdate="2008-10-27 09:00:58" resolution="Fixed">
		<buginformation>
			<summary>ConvertBodyType toString doesn&amp;apos;t take consideration of the typeClass setting</summary>
			<description>The toString() codes of  ConvertBodyType 

public String toString() {
        return "convertBodyTo[" + getType() + "]";
 }


if the ConvertBodyType&amp;amp;apos;s  typeClass member is set, the toString() method will not not reflect that.
Here is the mail thread which talks about it.
http://markmail.org/message/irikh3gxsff6vnlg?q=Problems+with+convertBodyTo+in+Java+DSL
</description>
			<version>1.3.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
			<file type="M">org.apache.camel.model.ConvertBodyType.java</file>
		</fixedFiles>
	</bug>
	<bug id="1021" opendate="2008-10-23 17:57:39" fixdate="2008-10-27 12:35:58" resolution="Fixed">
		<buginformation>
			<summary>some issues with the examples in 1.5RC1</summary>
			<description>This is a ticket holding some issues I have seen with the examples we ship in Camel. Please add if you find any issues as well</description>
			<version>1.5.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xquery.XQueryEndpointTest.java</file>
			<file type="M">org.apache.camel.component.xquery.XQueryPropogateHeadersTest.java</file>
			<file type="M">org.apache.camel.component.xquery.XQueryWithExplicitTypeTest.java</file>
			<file type="M">org.apache.camel.builder.saxon.XQueryRecipientListTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1023" opendate="2008-10-24 05:51:53" fixdate="2008-10-27 12:36:30" resolution="Fixed">
		<buginformation>
			<summary>camel:dot - pipeline is drawn as a multicast</summary>
			<description>And it has a few other areas as well that could be polished.</description>
			<version>1.5.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.view.NodeData.java</file>
			<file type="M">org.apache.camel.view.ModelFileGenerator.java</file>
			<file type="M">org.apache.camel.view.RouteDotGenerator.java</file>
			<file type="M">org.apache.camel.view.DotViewTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="939" opendate="2008-09-26 12:15:24" fixdate="2008-10-29 12:09:07" resolution="Fixed">
		<buginformation>
			<summary>Investigate test failures on AIX</summary>
			<description></description>
			<version>1.4.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.ruby.RubyTest.java</file>
			<file type="M">org.apache.camel.builder.script.Jsr223Test.java</file>
			<file type="M">org.apache.camel.LanguageTestSupport.java</file>
			<file type="M">org.apache.camel.language.script.PythonLanguageTest.java</file>
			<file type="M">org.apache.camel.dataformat.csv.CsvRouteTest.java</file>
			<file type="M">org.apache.camel.builder.xml.XPathTest.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.model.XmlParseTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1034" opendate="2008-10-29 14:09:25" fixdate="2008-10-30 15:07:18" resolution="Fixed">
		<buginformation>
			<summary>Messages in StreamResequencer between 2 ActiveMQ queues seem to be stuck</summary>
			<description>Perhaps some subtle configuration issue, but a Camel stream resequencer that is a route between 2 ActiveMQ queues fails to deliver all ordered messages. In fact, using the defaults for a StreamResequencer only 1 out of 100 messages are delivered. However, all 100 messages have been removed from the Producer queue by the resequencer and are not moved to the consumer queue either (even unordered). 
Relevant points:

Broker is run external to Camel route (non-embedded, no VM transport)
Producer is a Camel ProducerTemplate
Consumer is a Camel route that listens on another delivery queue and delivers message to a simple stdout Processor
Resequencer uses stream defaults (100, 1000ms)
Trace warns of some Converter override (see attached trace) and throws a breadcrumb error
Resequencer fails delivery whether using body (long) or seqnum header (long)
all JMS components are configured for AutoAcks

</description>
			<version>1.4.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.StreamResequencer.java</file>
			<file type="M">org.apache.camel.processor.resequencer.ResequencerEngine.java</file>
		</fixedFiles>
	</bug>
	<bug id="1054" opendate="2008-11-05 00:48:36" fixdate="2008-11-05 02:22:12" resolution="Duplicate">
		<buginformation>
			<summary>Update spring-integration to 1.0.0.RC1</summary>
			<description>The api has changed, plus there are tests failures anyway that need to be addressed, but i think better is to upgrade.</description>
			<version>2.0.0</version>
			<fixedVersion></fixedVersion>
			<type>Task</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationConsumer.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelTargetAdapter.java</file>
			<file type="M">org.apache.camel.component.spring.integration.HelloWorldService.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.AbstractCamelAdapter.java</file>
			<file type="M">org.apache.camel.component.spring.integration.converter.SpringIntegrationConverter.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationProducerTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.config.CamelTargetAdapterParser.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationOneWayConsumerTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationProducer.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelSourceAdapterTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.ConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationBinding.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelSourceAdapter.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationEndpoint.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationTwoWayConsumerTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationMessage.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelTargetAdapterTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1053</link>
		</links>
	</bug>
	<bug id="1053" opendate="2008-11-05 00:21:13" fixdate="2008-11-05 12:48:40" resolution="Fixed">
		<buginformation>
			<summary>spring integration xsd change breaks component</summary>
			<description>Thread is here http://www.nabble.com/-HEADS-UP--camel-spring-integration-issue-td20331450s22882.html</description>
			<version>1.4.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationConsumer.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelTargetAdapter.java</file>
			<file type="M">org.apache.camel.component.spring.integration.HelloWorldService.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.AbstractCamelAdapter.java</file>
			<file type="M">org.apache.camel.component.spring.integration.converter.SpringIntegrationConverter.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationProducerTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.config.CamelTargetAdapterParser.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationOneWayConsumerTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationProducer.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelSourceAdapterTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.ConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationBinding.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelSourceAdapter.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationEndpoint.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationTwoWayConsumerTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationMessage.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelTargetAdapterTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1054</link>
		</links>
	</bug>
	<bug id="1057" opendate="2008-11-07 00:56:37" fixdate="2008-11-07 13:23:32" resolution="Fixed">
		<buginformation>
			<summary>XQuery creates an empty out message that makes it impossible to chain more processors behind it</summary>
			<description>When using XQuery the getOut() function is called on the message so if it is not used at a place where the out is filled an empty out message will be created. With this xquery cannot be used for example in setBody, setHeader... and anywhere where the out is not filled.
An example where this causes real trouble:
&amp;lt;choice&amp;gt;
  &amp;lt;when&amp;gt;
    &amp;lt;xquery&amp;gt;...&amp;lt;/xquery&amp;gt;
    &amp;lt;to uri="direct:follow" /&amp;gt;
  &amp;lt;/when&amp;gt;
&amp;lt;/choice&amp;gt;
...
&amp;lt;from uri="direct:follow"&amp;gt;
&amp;lt;to ...&amp;gt;
&amp;lt;to ...&amp;gt;
In the patch the out property in the xquery context is filled only if it is not null. With it all of my pipelines seem to work well for me.</description>
			<version>1.4.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xquery.XQueryBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1062" opendate="2008-11-07 15:26:21" fixdate="2008-11-07 21:27:04" resolution="Fixed">
		<buginformation>
			<summary>PipelineConcurrentTest.java fails randomly</summary>
			<description>The test fails with an IllegalStateException: Queue full.  I believe the reason for this is that there are 10000 messages sent, but the default queue size is 1000.   On a fast machine, the queue fills up before the consumer gets a chance to pop the messages from the queue.</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.PipelineConcurrentTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1070" opendate="2008-11-10 16:38:32" fixdate="2008-11-10 16:55:17" resolution="Fixed">
		<buginformation>
			<summary>org.apache.camel.Message - hasAttachments is buggy</summary>
			<description>I must use
                        if (exchange.getIn().getAttachments().size() &amp;gt; 0) {
Instead of
                        if (exchange.getIn().hasAttachments()) {
As the latter always returns false. Or at least returns false even though the size is &amp;gt; 0</description>
			<version>1.4.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultMessage.java</file>
		</fixedFiles>
	</bug>
	<bug id="1063" opendate="2008-11-08 08:57:41" fixdate="2008-11-12 09:26:19" resolution="Fixed">
		<buginformation>
			<summary>camel-sql - setting datasource should be easier, and improve the wiki documentation</summary>
			<description>See nabble:
http://www.nabble.com/Camel-SQL-Component---dataSource-property-td20386559s22882.html</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sql.SqlDataSourceRefTest.java</file>
			<file type="M">org.apache.camel.component.sql.SqlProducer.java</file>
			<file type="M">org.apache.camel.component.sql.SqlEndpoint.java</file>
			<file type="M">org.apache.camel.component.sql.SqlComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="1080" opendate="2008-11-12 08:23:00" fixdate="2008-11-13 03:46:18" resolution="Fixed">
		<buginformation>
			<summary>The DataSetSedaTest will fail in a slower box</summary>
			<description>org.apache.camel.component.dataset.DataSetSedaTest.test
 =================
java.lang.AssertionError: dataset:foo Failed due to caught exception: java.lang.AssertionError: Header: camelDataSetIndex does not match. Expected: 363 but was: 362 on Exchange[Message: &amp;lt;hello&amp;gt;world!&amp;lt;/hello&amp;gt;] with headers: 
{camelDataSetIndex=362}
	at org.apache.camel.component.mock.MockEndpoint.fail(MockEndpoint.java:712)
	at org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied(MockEndpoint.java:255)
	at org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied(MockEndpoint.java:214)
	at org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied(MockEndpoint.java:141)
	at org.apache.camel.ContextTestSupport.assertMockEndpointsSatisfied(ContextTestSupport.java:274)
	at org.apache.camel.component.dataset.DataSetSedaTest.test(DataSetSedaTest.java:35)
</description>
			<version>1.4.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.dataset.DataSetSedaTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1088" opendate="2008-11-14 07:15:27" fixdate="2008-11-14 07:26:09" resolution="Fixed">
		<buginformation>
			<summary>Can&amp;apos;t get the soap header when the camel-cxf endpoint working in the PAYLOAD data fromat</summary>
			<description>When I added a unit test to show how to get the SOAP header from a PAYLOAD camel-cxf endpoint , I found the soap header stuff is not working.</description>
			<version>1.3.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.invoker.PayloadMessage.java</file>
			<file type="M">org.apache.camel.component.cxf.interceptors.SoapMessageInInterceptor.java</file>
			<file type="M">org.apache.camel.component.cxf.invoker.PayloadInvokingContext.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfPayLoadMessageRouterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.interceptors.XMLMessageInInterceptor.java</file>
			<file type="M">org.apache.camel.component.cxf.interceptors.SoapMessageOutInterceptor.java</file>
			<file type="M">org.apache.camel.component.cxf.interceptors.AbstractMessageInInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="1090" opendate="2008-11-14 15:28:52" fixdate="2008-11-14 15:30:23" resolution="Fixed">
		<buginformation>
			<summary>ThroughputLogger incorrectly reports duration 0</summary>
			<description>from the apache-camel-load test:
2008-11-14 15:27:01,114 [mponent@1296d1d] INFO  aset:myDataSet?produceDelay=10 - Sent: 600 messages so far. Last group took: 0 millis which is: 85.106 messages per second. average: 80.128
The ThroughputLogger used by DataSet resets the duration before reporting it.</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.ThroughputLogger.java</file>
		</fixedFiles>
	</bug>
	<bug id="1091" opendate="2008-11-14 16:54:13" fixdate="2008-11-17 14:03:33" resolution="Fixed">
		<buginformation>
			<summary>jetty endpoints ignore host specified in URI and expose an endpoint on all interfaces</summary>
			<description>http://www.nabble.com/Jetty-and-Mina%3A-how-to-bind-to-%22anylocal%22-AKA-%22wildcard%22-address--tp20475674s22882p20494645.html</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.InterfacesTest.java</file>
			<file type="M">org.apache.camel.component.jetty.CamelContinuationServlet.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="1103" opendate="2008-11-19 16:13:45" fixdate="2008-11-19 19:55:36" resolution="Fixed">
		<buginformation>
			<summary>Delayer not working as expected.</summary>
			<description>The delayer expression is not evaluated in my route builder:
from(waitQueueName).delayer(header(HEADER_EXECUTION_TIME)).bean(routerBean).recipientList(header(HEADER_TARGET_ROUTE));
While the recipientList expression is working the header expression is always ignored. I stepped through the code and saw that in DelayerType.createAbsoluteTimeDelayExpression() "expr.getLanguage()" is always null:
    private Expression createAbsoluteTimeDelayExpression(RouteContext routeContext) {
        ExpressionType expr = getExpression();
        if (expr != null) {
            if (ObjectHelper.isNotNullAndNonEmpty(expr.getLanguage())) 
{
                return expr.createExpression(routeContext);
            }
        }
        return null;
    }
I have seen that this was changed in 1.5.0 (http://issues.apache.org/activemq/browse/CAMEL-811). </description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.DelayerType.java</file>
		</fixedFiles>
	</bug>
	<bug id="1095" opendate="2008-11-16 09:17:58" fixdate="2008-11-21 18:42:51" resolution="Fixed">
		<buginformation>
			<summary>camel-jetty - Content-Type should be set on response if provided as OUT header</summary>
			<description>The Content-Type is not set in HttpBinding if an end-user has provided one as a OUT header.
So if an user exposes a Jetty service and lets requests fly in that is text/plain and want to return a response that is image/jpeg or the likes the content type can not be set as:
            exchange.getOut().setHeader("Content-Type", "image/jpeg");</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.HttpMessage.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.http.HttpComponent.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.http.HttpOperationFailedException.java</file>
			<file type="M">org.apache.camel.component.http.HttpBinding.java</file>
			<file type="M">org.apache.camel.component.http.HttpEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="1107" opendate="2008-11-21 10:23:50" fixdate="2008-11-21 18:43:37" resolution="Fixed">
		<buginformation>
			<summary>camel-http - does not remove httpClient.xxx URI options</summary>
			<description>When using the options to configure httpClient using URI option, they should be removed from the uri that is left over to the HTTPProducer.

http://someserver?httpClient.soTimeOut=5000


should remove the httpClient.xxx so it&amp;amp;apos;s

http://someserver


</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.HttpMessage.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.http.HttpComponent.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.http.HttpOperationFailedException.java</file>
			<file type="M">org.apache.camel.component.http.HttpBinding.java</file>
			<file type="M">org.apache.camel.component.http.HttpEndpoint.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1111</link>
		</links>
	</bug>
	<bug id="1093" opendate="2008-11-15 11:01:11" fixdate="2008-11-21 18:43:55" resolution="Fixed">
		<buginformation>
			<summary>camel-jetty - Exchange failures should not be returned as 200</summary>
			<description>The code below:

    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() throws Exception {
                errorHandler(noErrorHandler());
                from("jetty:http://localhost:8080/myapp/myservice").process(new MyBookService());
            }
        };
    }

    public class MyBookService implements Processor {
        public void process(Exchange exchange) throws Exception {
            throw new IllegalArgumentException("Damm");
        }
    }


Will return http response code 200. We should let end users easily set what response code they want and in case of route failures we should probably return 500 and return the stracktrace in the body</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.HttpMessage.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.http.HttpComponent.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.http.HttpOperationFailedException.java</file>
			<file type="M">org.apache.camel.component.http.HttpBinding.java</file>
			<file type="M">org.apache.camel.component.http.HttpEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="1111" opendate="2008-11-24 02:35:05" fixdate="2008-11-24 19:33:50" resolution="Fixed">
		<buginformation>
			<summary>HttpProducer - Side effect of using URI-based endpoint config disables POST method use</summary>
			<description>Hello all,
I&amp;amp;apos;m using Camel HTTP component to send data across to HTTP web services.  Of course we need to POST this data over, and it&amp;amp;apos;s all been peachy until I started on a storycard to implement error handling and retry on timeouts.
Following the docco here (http://activemq.apache.org/camel/http.html), I made the same change to my endpoint to include ?httpClient.SoTimeout=5000, and that&amp;amp;apos;s when the problems started.
After stepping through the code, I have now found that Camel thinks "httpClient.soTimeout" is actually a query string parameter that I want to pass across to the remote service, when it is not - it&amp;amp;apos;s just a configuration option for the HTTPClient.  Perhaps Camel needs a QueryStringFilter (or something like it) so that it can distinguish configuration options as opposed to real GET method parameters, or maybe for now ignore any parameters beginning with httpClient.
Filing as a bug for now because at the very least, the documentation should be updated to highlight the limitation of only allowing GET methods when URI-based configuration is employed.  I haven&amp;amp;apos;t identified a workaround yet (using Spring DSL) but I&amp;amp;apos;m sure it won&amp;amp;apos;t be too difficult.
Thanks!
Jason</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.HttpMessage.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.http.HttpComponent.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.http.HttpOperationFailedException.java</file>
			<file type="M">org.apache.camel.component.http.HttpBinding.java</file>
			<file type="M">org.apache.camel.component.http.HttpEndpoint.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1107</link>
		</links>
	</bug>
	<bug id="1118" opendate="2008-11-25 17:35:32" fixdate="2008-11-25 17:46:30" resolution="Fixed">
		<buginformation>
			<summary>SFTP endpoint does not peform host key verification</summary>
			<description>Camel does allow users to configure JSch with a known_hosts file. This makes the users vulnerable to man in the middle type attacks.</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileConfiguration.java</file>
			<file type="M">org.apache.camel.component.file.remote.UriConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="1122" opendate="2008-11-26 11:21:44" fixdate="2008-11-26 13:05:24" resolution="Fixed">
		<buginformation>
			<summary>Camel should propagate exception cause in InOnly scenarios</summary>
			<description>In the case an exception is handled by the DeadLetterChannel, Camel will currently set the exception to null and add an exchange property containing the exception. We should also add this as a message header so that it will be propagated to external services, like a JBI service.</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.DeadLetterChannel.java</file>
		</fixedFiles>
	</bug>
	<bug id="1074" opendate="2008-11-11 00:21:20" fixdate="2008-11-27 10:23:43" resolution="Fixed">
		<buginformation>
			<summary>.unmarshal(new JaxbDataFormat("com.foo.bar")) returning JAXBElement</summary>
			<description>using .unmarshal(new JaxbDataFormat("com.foo.bar") is returning a JAXBElement instead of the desired object that was generated by xjc.</description>
			<version>1.4.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.jaxb.CamelJaxbTest.java</file>
			<file type="M">org.apache.camel.model.dataformat.JaxbDataFormat.java</file>
			<file type="M">org.apache.camel.converter.jaxb.JaxbDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="1108" opendate="2008-11-21 20:33:13" fixdate="2008-11-27 20:50:19" resolution="Fixed">
		<buginformation>
			<summary>ParallelProcessing and executor flags are ignored in Multicast processor</summary>
			<description>The parallelProcessing and executor arguments are ignored in the constructor of MulticastProcessor. 
Here is a call that MulticastType makes
org.apache.camel.model.MulticastType.java
    return new MulticastProcessor(list, aggregationStrategy, isParallelProcessing(), threadPoolExecutor);


MulticastProcessor ignores parallelProcessing and executor arguments and invokes a chain constructor with "..,false, null,.."
org.apache.camel.processor.MulticastProcessor.java
    public MulticastProcessor(Collection&amp;lt;Processor&amp;gt; processors, AggregationStrategy aggregationStrategy, boolean parallelProcessing, ThreadPoolExecutor executor) {
        this(processors, aggregationStrategy, false, null, false);
    }

    public MulticastProcessor(Collection&amp;lt;Processor&amp;gt; processors, AggregationStrategy aggregationStrategy, boolean parallelProcessing, ThreadPoolExecutor executor, boolean streaming) {
        notNull(processors, "processors");
        this.processors = processors;
        this.aggregationStrategy = aggregationStrategy;
        this.isParallelProcessing = parallelProcessing;
        if (isParallelProcessing) {
            if (executor != null) {
                this.executor = executor;
            } else { 
                // setup default Executor
                this.executor = new ThreadPoolExecutor(processors.size(), processors.size(), 0, TimeUnit.MILLISECONDS, new ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(processors.size()));
            }
        }
        this.streaming = streaming;
    }


Attached a patch but have not tested it. Also need a unit test for this.</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="1125" opendate="2008-11-28 07:14:09" fixdate="2008-11-28 07:23:16" resolution="Fixed">
		<buginformation>
			<summary>MockEndpont.expectedMinimumMessageCount() doesn&amp;apos;t work right</summary>
			<description>In MockEndpoint.assertIsSatisfied(), don&amp;amp;apos;t use the right counter for assertion.

      
      if (expectedMinimumCount &amp;gt;= 0) {
            int receivedCounter = getReceivedCounter();
            assertTrue("Received message count " + receivedCounter + ", expected at least " + expectedCount, expectedCount &amp;lt;= receivedCounter);
        }


it should be change to 

      
      if (expectedMinimumCount &amp;gt;= 0) {
            int receivedCounter = getReceivedCounter();
            assertTrue("Received message count " + receivedCounter + ", expected at least " + expectedMinimumCount, expectedMinimumCount &amp;lt;= receivedCounter);
        }

</description>
			<version>1.3.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mock.MockEndpoint.java</file>
			<file type="M">org.apache.camel.builder.ValueBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1131" opendate="2008-11-29 12:56:04" fixdate="2008-11-29 13:07:41" resolution="Duplicate">
		<buginformation>
			<summary>Invalid contructor intitialization in MulticastProcessor</summary>
			<description>parallelProcessing and executor being overridden in constructor.
MulticastProcessor.java
    public MulticastProcessor(Collection&amp;lt;Processor&amp;gt; processors, AggregationStrategy aggregationStrategy, boolean parallelProcessing, ThreadPoolExecutor executor) {
        this(processors, aggregationStrategy, false, null, false);
    }


</description>
			<version>2.0.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.Splitter.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="1119" opendate="2008-11-26 10:19:49" fixdate="2008-11-30 14:09:14" resolution="Fixed">
		<buginformation>
			<summary>HttpProducer discards response headers, if response code &gt;= 300</summary>
			<description>In Camel 1.4.0, when a Web server sends an error page to HttpProducer, the Camel route can access the response headers that were sent by the server.  In Camel 1.5.0, these headers are discarded by HttpProducer, so the Camel route cannot access them.
Camel 1.5.0 also discards the content of the error page, but that was fixed in CAMEL-1083.
See discussion: HttpProducer: how to access the body of an error page?</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyResponseBodyWhenErrorTest.java</file>
			<file type="M">org.apache.camel.component.http.HttpOperationFailedException.java</file>
		</fixedFiles>
	</bug>
	<bug id="1135" opendate="2008-12-01 14:36:58" fixdate="2008-12-02 07:40:32" resolution="Fixed">
		<buginformation>
			<summary>TestEndpointTest  Unit test failed which may be caused by recent change of File Component</summary>
			<description>Here are the stack trace of the TestEndpointTest.testMocksAreValid on different machines
org.apache.camel.component.test.TestEndpointTest.testMocksAreValid =================
java.lang.AssertionError: test:file://src/test/data?noop=true&amp;amp;consumer.recursive=true&amp;amp;consumer.delay=2000 Received message count. Expected: &amp;lt;567&amp;gt; but was: &amp;lt;78&amp;gt;
	at org.apache.camel.component.mock.MockEndpoint.fail(MockEndpoint.java:712)
	at org.apache.camel.component.mock.MockEndpoint.assertEquals(MockEndpoint.java:694)
	at org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied(MockEndpoint.java:238)
	at org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied(MockEndpoint.java:214)
	at org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied(MockEndpoint.java:141)
	at org.apache.camel.component.test.TestEndpointTest.testMocksAreValid(TestEndpointTest.java:49)
org.apache.camel.component.test.TestEndpointTest.testMocksAreValid =================
java.lang.AssertionError: test:file://src/test/data?noop=true&amp;amp;consumer.recursive=true&amp;amp;consumer.delay=2000 Received message count. Expected: &amp;lt;219&amp;gt; but was: &amp;lt;78&amp;gt;
	at org.apache.camel.component.mock.MockEndpoint.fail(MockEndpoint.java:712)
	at org.apache.camel.component.mock.MockEndpoint.assertEquals(MockEndpoint.java:694)
	at org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied(MockEndpoint.java:238)
	at org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied(MockEndpoint.java:214)
	at org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied(MockEndpoint.java:141)
	at org.apache.camel.component.test.TestEndpointTest.testMocksAreValid(TestEndpointTest.java:49)
I don&amp;amp;apos;t know why the test endpoint could get so many received message.</description>
			<version>2.0.0</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileConsumer.java</file>
			<file type="M">org.apache.camel.component.test.TestEndpointTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1140" opendate="2008-12-03 09:29:04" fixdate="2008-12-03 14:12:01" resolution="Fixed">
		<buginformation>
			<summary>MinaProducer - when remote session closed it should raise exception</summary>
			<description>See nabble:
http://www.nabble.com/camel-mina-in-servicemix---how-to-process-TCP-response--td20794416s22882.html</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina.MinaProducer.java</file>
			<file type="M">org.apache.camel.component.mina.MinaNoResponseFromServerTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaProducerShutdownMockTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaTcpTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaTcpTextlineProtocolTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaTcpTextlineDelimiterTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaProducerShutdownTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaCustomCodecTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1144" opendate="2008-12-04 10:44:39" fixdate="2008-12-04 13:38:34" resolution="Fixed">
		<buginformation>
			<summary>Exceptions thrown from converters are not correctly handled</summary>
			<description>Related nabble: http://www.nabble.com/Handling-converter-failure-td20830148s22882.html
When an exception is thrown from a @Converter it is not correctly handled by onException.  The handler is receiving a RuntimeCamelException and not checking the cause when determining the best handler.

/////Converter
@Converter
public static LocalDateTime toLocalDateTime(final Object localDateTime)
{
  System.out.println("Converting to local date time");
  throw new IllegalArgumentException("Bad data");
}

/////Routes
Routes routes = new RouteBuilder() {

  @Override
  public void configure() throws Exception {
    onException(IllegalArgumentException.class).handled(true).to("mock:exception");
    from("direct:test").convertBodyTo(LocalDateTime.class).to("mock:end");
  }
};


/////Test
MockEndpoint endpoint = (MockEndpoint)
camelContext.getEndpoint("mock:end");
endpoint.expectedMessageCount(0);
MockEndpoint endpoint2 = (MockEndpoint)
camelContext.getEndpoint("mock:exception");
endpoint2.expectedMessageCount(1);

camelContext.createProducerTemplate().sendBody("direct:test", "test");

endpoint.assertIsSatisfied();
endpoint2.assertIsSatisfied();


</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategyTest.java</file>
			<file type="M">org.apache.camel.processor.idempotent.MemoryIdempotentRepository.java</file>
			<file type="M">org.apache.camel.processor.idempotent.FileIdempotentRepository.java</file>
			<file type="M">org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="1145" opendate="2008-12-04 11:42:32" fixdate="2008-12-05 10:05:28" resolution="Fixed">
		<buginformation>
			<summary>CxfExchange does not copy unit of work and thus its null and thus NPE is thrown</summary>
			<description>William could you check this error reported by end user
See nabble:
http://www.nabble.com/UnitOfWork-td20829434s22882.html</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfExchange.java</file>
		</fixedFiles>
	</bug>
	<bug id="1150" opendate="2008-12-06 09:48:18" fixdate="2008-12-06 10:56:58" resolution="Fixed">
		<buginformation>
			<summary>Aggregator must be the only output added to the route is fooled by onException</summary>
			<description>See nabble:
http://www.nabble.com/Redelivery-Strategy-td20861316s22882.html
We should convert the 
        if (!getOutputs().isEmpty()) 
{
            throw new IllegalArgumentException("Aggregator must be the only output added to the route: " + this);
        }

nto a WARN log until we get the aggreagator fixed so you can define it anywhere in the route path. We have a ticket for this bug also.</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
			<file type="M">org.apache.camel.processor.aggregator.AggregatorAndOnExceptionTest.java</file>
			<file type="M">org.apache.camel.util.CollectionHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="1037" opendate="2008-10-30 16:00:11" fixdate="2008-12-09 07:22:25" resolution="Fixed">
		<buginformation>
			<summary>Messages in Resequencer between 2 JMS queues get stuck</summary>
			<description>Martin describes the issue as follows in CAMEL-1034:
"The issue with the regular resequencer (the one that extends the BatchProcessor) remains because the process(Exchange) method is empty. In addition to the BatchProcessor&amp;amp;apos;s polling consumer, an additional JmsConsumer is created by the JMS endpoint that competes with the polling consumer. The JmsConsumer then calls the empty process(Exchange) method and the exchange is lost."</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.StreamResequencer.java</file>
			<file type="M">org.apache.camel.model.ResequencerType.java</file>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
			<file type="M">org.apache.camel.processor.BatchProcessor.java</file>
			<file type="M">org.apache.camel.processor.Resequencer.java</file>
			<file type="M">org.apache.camel.processor.AggregatorTest.java</file>
			<file type="M">org.apache.camel.model.AggregatorType.java</file>
			<file type="M">org.apache.camel.processor.Aggregator.java</file>
		</fixedFiles>
	</bug>
	<bug id="1187" opendate="2008-12-15 05:48:47" fixdate="2008-12-15 08:17:21" resolution="Fixed">
		<buginformation>
			<summary>The Mina VM protocol is not recognising codec and other options</summary>
			<description>Use of the vm protocol appears to ignore any codec options. There could be other options that are missed also.
Using the same URI but for tcp works fine.</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileConsumer.java</file>
			<file type="M">org.apache.camel.component.mina.MinaCustomCodecTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaVMCustomCodecTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaTransferExchangeOptionTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="1188" opendate="2008-12-16 13:52:52" fixdate="2008-12-16 18:40:24" resolution="Fixed">
		<buginformation>
			<summary>Exceptions thrown from when - methodCall are not caught by onException</summary>
			<description>See the route below. beanOne throws ExceptionOneException and beanTwo throws ExceptionTwoException. ExceptionOneException it caught and handled as it&amp;amp;apos;s supposed to.  But ExceptionTwoException goes all the way through, without  being caught and routed to the exceptionTwoQueue. Is it the when tag or the methodCall tag that is the cause of this?

&amp;lt;camelContext id="MyCamelContext xmlns="http://activemq.apache.org/camel/schema/spring"&amp;gt;
	&amp;lt;endpoint id="myMainQueue" uri="activemq:${my.project.queue.main}"/&amp;gt;
	&amp;lt;endpoint id="exceptionOneQueue" uri="activemq:${my.project.queue.exceptionOne}"/&amp;gt;
	&amp;lt;endpoint id="exceptionTwoQueue" uri="activemq:${my.project.queue.exceptionTwo}"/&amp;gt;
	&amp;lt;route&amp;gt;		
		&amp;lt;from ref="myMainQueue" /&amp;gt;
		&amp;lt;onException&amp;gt;
			&amp;lt;exception&amp;gt;my.project.queue.ExceptionOneException&amp;lt;/exception&amp;gt;
			&amp;lt;redeliveryPolicy maximumRedeliveries="0" /&amp;gt;
			&amp;lt;handled&amp;gt;
				&amp;lt;constant&amp;gt;true&amp;lt;/constant&amp;gt;
			&amp;lt;/handled&amp;gt;
			&amp;lt;to ref="exceptionOneQueue"/&amp;gt;
		&amp;lt;/onException&amp;gt;
		&amp;lt;onException&amp;gt;
			&amp;lt;exception&amp;gt;my.project.queue.ExceptionTwoException&amp;lt;/exception&amp;gt;
			&amp;lt;redeliveryPolicy maximumRedeliveries="0" /&amp;gt;
			&amp;lt;handled&amp;gt;
				&amp;lt;constant&amp;gt;true&amp;lt;/constant&amp;gt;
			&amp;lt;/handled&amp;gt;
			&amp;lt;to ref="exceptionTwoQueue"/&amp;gt;
		&amp;lt;/onException&amp;gt;
		&amp;lt;onException&amp;gt;
			&amp;lt;exception&amp;gt;java.lang.Exception&amp;lt;/exception&amp;gt;
			&amp;lt;redeliveryPolicy maximumRedeliveries="0" /&amp;gt;
			&amp;lt;handled&amp;gt;
				&amp;lt;constant&amp;gt;false&amp;lt;/constant&amp;gt;
			&amp;lt;/handled&amp;gt;
		&amp;lt;/onException&amp;gt;
		&amp;lt;unmarshal&amp;gt;
			&amp;lt;jaxb prettyPrint="true" contextPath="my.project.domain" /&amp;gt;
		&amp;lt;/unmarshal&amp;gt;
		&amp;lt;choice&amp;gt;
			&amp;lt;when&amp;gt;
				&amp;lt;methodCall bean="beanTwo" method="methodFromBeanTwo"/&amp;gt;
			&amp;lt;/when&amp;gt;
			&amp;lt;otherwise&amp;gt;
				&amp;lt;to uri="bean:beanOne?methodName=methodFromBeanOne" /&amp;gt;
			&amp;lt;/otherwise&amp;gt;
		&amp;lt;/choice&amp;gt;
	&amp;lt;/route&amp;gt;
&amp;lt;/camelContext&amp;gt;

</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.ProducerTemplate.java</file>
			<file type="M">org.apache.camel.builder.ValueBuilder.java</file>
			<file type="M">org.apache.camel.impl.DefaultComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="1190" opendate="2008-12-16 21:02:43" fixdate="2008-12-16 21:36:08" resolution="Fixed">
		<buginformation>
			<summary>SoapMessageInInterceptor imports test generated code(pizza.types.CallerIDHeaderType)</summary>
			<description>org.apache.camel.component.cxf.interceptors.SoapMessageInInterceptor imports a class generated from test code 
import org.apache.camel.pizza.types.CallerIDHeaderType;
This makes life a bit annoying when trying to debug/develop with camel-cxf without generating the full test code.</description>
			<version>2.0.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.interceptors.SoapMessageInInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="1196" opendate="2008-12-18 05:59:04" fixdate="2008-12-18 13:09:59" resolution="Fixed">
		<buginformation>
			<summary>MockEndpoint - sleep for empty test doesnt work</summary>
			<description>See nabble:
http://www.nabble.com/MockEndpoint---sleep-for-empty-tests-is-flawed--td21067367s22882.html</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mock.MockEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="1193" opendate="2008-12-17 14:53:31" fixdate="2008-12-19 08:18:54" resolution="Fixed">
		<buginformation>
			<summary>Interceptors for multicast</summary>
			<description>MulticastType override the method wrapProcessorInInterceptors() and adds a StreamCachingInterceptor.
This is giving a problem for the debugger in FUSE Integration designer. FID debugger works using the Debug Interceptor, because we are not add an interceptor for Multicast node, it will not stop at that node even if we place a break point.
camel-dev mailing list thread related to this: http://www.nabble.com/Camel-Multicast-and-Interceptors-td21053645s22882.html</description>
			<version>1.4.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.MulticastType.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilderTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1217" opendate="2009-01-03 08:18:59" fixdate="2009-01-04 07:18:03" resolution="Fixed">
		<buginformation>
			<summary>Get the Jetty component&amp;apos;s &amp;apos;httpClient.&amp;apos; options to work with indeed apache http client</summary>
			<description>Current Jetty component just set the &amp;amp;apos;httpClient.&amp;amp;apos; parameter to a useless Jetty http client, and using the apache common http client indeed.
We need to pass the parameters into the apache common http client and remove the useless Jetty http client.</description>
			<version>1.3.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyHttpClientOptionsTest.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpEndpoint.java</file>
			<file type="M">org.apache.camel.component.http.BasicAuthenticationHttpClientConfigurer.java</file>
			<file type="M">org.apache.camel.component.http.HttpComponent.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="1207" opendate="2008-12-29 09:59:17" fixdate="2009-01-05 00:07:29" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentModificationException when stop the camel-osgi bundle</summary>
			<description>ERROR: Error stopping mvn:org.apache.camel/camel-osgi/1.5.0 (org.osgi.fra
mework.BundleException: Activator stop error.)
java.util.ConcurrentModificationException
        at java.util.HashMap$HashIterator.nextEntry(HashMap.java:841)
        at java.util.HashMap$ValueIterator.next(HashMap.java:871)
        at org.apache.camel.osgi.Activator.mayBeRemoveComponentFor(Activator.jav
a:85)
        at org.apache.camel.osgi.Activator.stop(Activator.java:120)
        at org.apache.felix.framework.util.SecureAction.stopActivator(SecureActi
on.java:613)
        at org.apache.felix.framework.Felix._stopBundle(Felix.java:1995)
        at org.apache.felix.framework.Felix.stopBundle(Felix.java:1952)
        at org.apache.felix.framework.Felix.setFrameworkStartLevel(Felix.java:11
51)
        at org.apache.felix.framework.StartLevelImpl.run(StartLevelImpl.java:267
)
        at java.lang.Thread.run(Thread.java:595)</description>
			<version>1.4.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.osgi.OsgiComponentResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="1199" opendate="2008-12-19 12:20:41" fixdate="2009-01-05 08:53:57" resolution="Fixed">
		<buginformation>
			<summary>Throttler appears to "throttle" per thread instead of throttling across multiple threads</summary>
			<description></description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.Throttler.java</file>
			<file type="M">org.apache.camel.processor.ThrottlerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1225" opendate="2009-01-05 10:11:48" fixdate="2009-01-05 15:11:32" resolution="Fixed">
		<buginformation>
			<summary>Duplicate type converter toString(Source) in two classes in camel-core</summary>
			<description>See nabble
http://www.nabble.com/Seda-StaticMethodTypeConverter-TransformerException-td21287333s22882.html
This type converter is needed by JBI containers so we should make sure the fix is correct.</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.IOConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1213" opendate="2009-01-02 17:13:09" fixdate="2009-01-06 05:46:06" resolution="Fixed">
		<buginformation>
			<summary>camel-jms consumer does not set camel message id based on JMS message id if the next node is not JMS based</summary>
			<description>The code in org.apache.camel.component.jms.copyFrom looks odd
I think the ! should be removed
BEFORE

        if (!copyMessageId) {
            setMessageId(that.getMessageId());
        }


AFTER

        if (copyMessageId) {
            setMessageId(that.getMessageId());
        }


I will add a unit test (JmsToFileMessageIdTest) based on end user having some trouble with it</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsMessage.java</file>
			<file type="M">org.apache.camel.converter.jaxp.BytesSource.java</file>
			<file type="M">org.apache.camel.converter.jaxp.StringSource.java</file>
		</fixedFiles>
	</bug>
	<bug id="1221" opendate="2009-01-03 22:58:45" fixdate="2009-01-09 07:24:30" resolution="Fixed">
		<buginformation>
			<summary>Unable to find dynamically loaded languages when using OSGi</summary>
			<description>The camel-osgi component only supports loading Components via the OSGi bundles in the 1.5.0 release code. It looks like someone started to add more things that can be automatically loaded on the trunk, because there was a refactor to allow TypeConverters to be added via OSGi bundles. 
Definitely, adding Languages is still missing (both in 1.5.0 and on the trunk). Perhaps there are more as well, as I&amp;amp;apos;m not up on all the things that Camel loads using the same mechanism.
I&amp;amp;apos;ve got Languages working by patching my copy of 1.5.0 (basically by creating my own version of the LanguageResolver based on the OSGiComponentResolver), but as the refactor seems to be taking the code in a different direction, I&amp;amp;apos;m not going to push a patch yet.</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.osgi.OsgiComponentResolver.java</file>
			<file type="M">org.apache.camel.osgi.Activator.java</file>
			<file type="M">org.apache.camel.osgi.CamelContextFactoryBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="1249" opendate="2009-01-12 18:06:03" fixdate="2009-01-13 09:05:10" resolution="Fixed">
		<buginformation>
			<summary>MailConfiguration injected into MailComponent by Spring is ignored.</summary>
			<description>A Camel org.apache.camel.component.mail.MailComponent is configured via Spring as:

&amp;lt;bean id="mailbox" class="org.apache.camel.component.mail.MailComponent"&amp;gt;
  &amp;lt;property name="configuration"&amp;gt;
    &amp;lt;bean id="mailbox_config" class="org.apache.camel.component.mail.MailConfiguration"&amp;gt;
      &amp;lt;property name="protocol"&amp;gt;&amp;lt;value&amp;gt;pop3&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;
      &amp;lt;property name="host"&amp;gt;&amp;lt;value&amp;gt;mail.abc.com&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;
      &amp;lt;property name="username"&amp;gt;&amp;lt;value&amp;gt;test&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;
      &amp;lt;property name="password"&amp;gt;&amp;lt;value&amp;gt;test&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
  &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;


It is silly to use the hard-coded URI in Java code to create a mail endpoint. Instead I want to use the above method to specify everything (I mean everything) about how to access a mail server (send or receive) in different deployments.  Up to Camel 1.5, line 73 of MailComponent.createEndpoint() ignored the MailConfiguration variable MailComponent.configuration and created a new one to parse the URI. This defeats the Spring injection above, which is recommended by Camel&amp;amp;apos;s own User&amp;amp;apos;s Guide.
Line 73 and 74 should be changed from:

        MailConfiguration config = new MailConfiguration();
        config.configure(url);
to

        configuration.configure(url);
In addition, if the uri parameter equals the component name, createEndpoint() should not parse it at all, so that the following route builder will create the mail endpoint solely according to the Spring injection of MailConfiguration:

    from("mailbox").to("my_queue");</description>
			<version>1.4.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailConfiguration.java</file>
			<file type="M">org.apache.camel.component.mail.MailComponent.java</file>
			<file type="M">org.apache.camel.component.mail.MailEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="1247" opendate="2009-01-12 12:18:20" fixdate="2009-01-14 05:05:12" resolution="Fixed">
		<buginformation>
			<summary>SFTP : Polling - Cannot list directory Error</summary>
			<description>http://www.nabble.com/SFTP-%3A-Polling---Cannot-list-directory-to21413159s22882.html
</description>
			<version>2.0.0</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.SftpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpRemoteFileOperations.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpRemoteFileOperations.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1261" opendate="2009-01-15 13:34:29" fixdate="2009-01-16 07:34:55" resolution="Duplicate">
		<buginformation>
			<summary>camel-spring - method call language can not be used with split</summary>
			<description>Using a method call for the split expression is not possible in Spring DSL. It wants to resolve the language.
As we dont have all the expression builder helper in Spring XML its a bit harder to do routing. But I want to use a bean for the splitting. End users should always have the true power of java, regardless.

            &amp;lt;split&amp;gt;
                &amp;lt;expression&amp;gt;
                    &amp;lt;method bean="echoService" method="splitWords"/&amp;gt;
                &amp;lt;/expression&amp;gt;
                &amp;lt;to uri="bean:echoService?method=hello"/&amp;gt;
                &amp;lt;to uri="stream:out"/&amp;gt;
            &amp;lt;/split&amp;gt;



And gives this exception:

2009-01-15 14:15:18,831 [ing.Main.main()] ERROR MainSupport                    - Failed: org.apache.camel.NoSuchLanguageException: No language could be found for: null
org.apache.camel.NoSuchLanguageException: No language could be found for: null
        at org.apache.camel.impl.DefaultLanguageResolver.noSpecificLanguageFound(DefaultLanguageResolver.java:72)
        at org.apache.camel.impl.DefaultLanguageResolver.resolveLanguage(DefaultLanguageResolver.java:52)
        at org.apache.camel.impl.DefaultCamelContext.resolveLanguage(DefaultCamelContext.java:430)
        at org.apache.camel.model.language.ExpressionType.createExpression(ExpressionType.java:158)
        at org.apache.camel.model.SplitterType.createProcessor(SplitterType.java:86)

</description>
			<version>1.5.0</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.language.LanguageExpression.java</file>
			<file type="M">org.apache.camel.model.language.MethodCallExpression.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1265</link>
		</links>
	</bug>
	<bug id="1265" opendate="2009-01-16 07:32:03" fixdate="2009-01-16 07:37:01" resolution="Fixed">
		<buginformation>
			<summary>Expression should be renamed to Language</summary>
			<description></description>
			<version>1.5.0</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Sub-task</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.language.LanguageExpression.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1261</link>
		</links>
	</bug>
	<bug id="1270" opendate="2009-01-18 09:56:18" fixdate="2009-01-18 10:06:27" resolution="Fixed">
		<buginformation>
			<summary>Starting Camel using Main from camel:run or Main.class - countdown latch is hanging</summary>
			<description>The countdown latch in MainSupport is not completed when Main is stopping.
Then we have a hanging thread. Can bee seen using ctrl + \</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.MainSupport.java</file>
			<file type="M">org.apache.camel.spring.Main.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="is depended upon by">1269</link>
		</links>
	</bug>
	<bug id="1263" opendate="2009-01-15 19:12:05" fixdate="2009-01-18 10:21:52" resolution="Fixed">
		<buginformation>
			<summary>MailConsumer throws exception on line 113</summary>
			<description>When the mail box is empty (no mail available), MailConsumer throws the following exception on line 113.  It happens for both pop3 and imap protocols (Java Mail API 1.4.1 Sun implementation).  
Regardless the cause, closing the folder should be enclosed in a try/catch block and ignore any exception thrown, because it is no longer interesting to the client application.  It can surely log the exception, but shouldn&amp;amp;apos;t throw it.

[java] javax.mail.MessagingException: A6 NO Mailbox is locked by POP server;
[java]   nested exception is:
[java]     com.sun.mail.iap.CommandFailedException: A6 NO Mailbox is locked by POP server
[java]     at com.sun.mail.imap.IMAPFolder.close(IMAPFolder.java:1128)
[java]     at com.sun.mail.imap.IMAPFolder.close(IMAPFolder.java:1055)
[java]     at org.apache.camel.component.mail.MailConsumer.poll(MailConsumer.java:113)
[java]     at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:66)
[java]     at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)
[java]     at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:317)
[java]     at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:150)
[java]     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:98)
[java]     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:181)
[java]     at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:205)
[java]     at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
[java]     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
[java]     at java.lang.Thread.run(Thread.java:619)
[java] Caused by: com.sun.mail.iap.CommandFailedException: A6 NO Mailbox is locked by POP server
[java]     at com.sun.mail.iap.Protocol.handleResult(Protocol.java:341)
[java]     at com.sun.mail.iap.Protocol.simpleCommand(Protocol.java:363)
[java]     at com.sun.mail.imap.protocol.IMAPProtocol.close(IMAPProtocol.java:976)
[java]     at com.sun.mail.imap.IMAPFolder.close(IMAPFolder.java:1125)
[java]     ... 12 more

</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1274" opendate="2009-01-19 22:02:36" fixdate="2009-01-19 22:49:11" resolution="Fixed">
		<buginformation>
			<summary>Jetty HTTP SelectChannelConnector is not closed when CamelContext is stopped</summary>
			<description>When the camel-jetty component is shut down, it leaves Jetty SelectChannelConnector instances active.</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="1278" opendate="2009-01-20 16:59:19" fixdate="2009-01-20 17:49:29" resolution="Fixed">
		<buginformation>
			<summary>VelocityEndpoint reads velocity templates using default encoding - add parameter to set encoding</summary>
			<description>VelocityEndpoints reads templates using default encoding, so I cannot get correct content while running on Windows and Linux.
The reason is that there is used InputStreamReader constructor without encoding parameter.
I&amp;amp;apos;ve added simple support for setting encoding - see attached patch</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.velocity.VelocityEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="122" opendate="2007-08-25 06:55:26" fixdate="2009-01-20 18:25:55" resolution="Fixed">
		<buginformation>
			<summary>port the error handler / dead letter channel / redelivery policy over to JAXB2 so you can fully customize it via XML</summary>
			<description></description>
			<version>1.3.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Task</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.processor.SpringFaultRouteTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">476</link>
		</links>
	</bug>
	<bug id="1283" opendate="2009-01-21 23:41:48" fixdate="2009-01-22 15:39:54" resolution="Fixed">
		<buginformation>
			<summary>SQL component doesn&amp;apos;t handle wrong number of parameters</summary>
			<description>NPE thrown when null body sent to to SQL endpoint. When to many parameters are set then exception is thrown but nothing wrong happens when to less parameters are set.
It should be possible to set null as a body as there might be parameterless statement to execute. There should be consistent Exception thrown when wrong number of parameters is set.</description>
			<version>1.5.0</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sql.SqlRouteTest.java</file>
			<file type="M">org.apache.camel.component.sql.SqlProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1292" opendate="2009-01-23 06:02:44" fixdate="2009-01-23 06:07:18" resolution="Fixed">
		<buginformation>
			<summary>SQLComponent should preserve headers</summary>
			<description>
                from("direct:start")
                    .setHeader("foo", constant("bar"))
                    .to("sql:select * from projects")
                    .to("mock:result");


The foo header should be preserved so when its routed to the mock its still there.</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sql.SqlProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="849" opendate="2008-08-26 05:23:53" fixdate="2009-01-23 07:29:37" resolution="Duplicate">
		<buginformation>
			<summary>mina component / endpoint - easier spring configuration</summary>
			<description>The camel-mina component and the endpoint should be spring xml firendly for configuration.
So you can configure the endpoint in the spring xml as a bean and use it in the routing. The configuration in spring should support IDE property completion so can easily see which properties this endpoint supports and set them using simple text values.</description>
			<version>1.4.0</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.JmsComponent.java</file>
			<file type="M">org.apache.camel.component.rmi.RmiConsumer.java</file>
			<file type="M">org.apache.camel.component.rmi.RmiRouteTest.java</file>
			<file type="M">org.apache.camel.component.rmi.RmiEndpoint.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaWithNamedQueryTest.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaEndpoint.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppComponent.java</file>
			<file type="M">org.apache.camel.component.xmpp.RuntimeXmppException.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppEndpoint.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppBinding.java</file>
			<file type="M">org.apache.camel.component.quartz.StatefulCamelJob.java</file>
			<file type="M">org.apache.camel.component.quartz.CamelJob.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzEndpoint.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzRouteTest.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzComponent.java</file>
			<file type="M">org.apache.camel.component.quartz.StatefulQuartzRouteTest.java</file>
			<file type="M">org.apache.camel.component.ResourceBasedEndpoint.java</file>
			<file type="M">org.apache.camel.component.freemarker.FreemarkerComponent.java</file>
			<file type="M">org.apache.camel.component.velocity.VelocityComponent.java</file>
			<file type="M">org.apache.camel.component.freemarker.FreemarkerEndpoint.java</file>
			<file type="M">org.apache.camel.component.velocity.VelocityEndpoint.java</file>
			<file type="M">org.apache.camel.component.ResourceBasedComponent.java</file>
			<file type="M">org.apache.camel.component.feed.FeedEndpoint.java</file>
			<file type="M">org.apache.camel.component.rss.RssEndpoint.java</file>
			<file type="M">org.apache.camel.component.rss.AggregateRssFeedStrategy.java</file>
			<file type="M">org.apache.camel.component.rss.RssPollingConsumer.java</file>
			<file type="M">org.apache.camel.component.rss.RssComponent.java</file>
			<file type="M">org.apache.camel.component.atom.AtomEndpoint.java</file>
			<file type="M">org.apache.camel.component.rss.UpdatedDateFilter.java</file>
			<file type="M">org.apache.camel.component.rss.AggregateRssFeedCollection.java</file>
			<file type="M">org.apache.camel.dataformat.rss.RssDataFormat.java</file>
			<file type="M">org.apache.camel.component.rss.RssDateComparator.java</file>
			<file type="M">org.apache.camel.component.rss.RssEntryPollingConsumer.java</file>
			<file type="M">org.apache.camel.component.jdbc.JdbcEndpoint.java</file>
			<file type="M">org.apache.camel.component.jdbc.JdbcRouteTest.java</file>
			<file type="M">org.apache.camel.component.sql.SqlEndpoint.java</file>
			<file type="M">org.apache.camel.component.sql.SqlComponent.java</file>
			<file type="M">org.apache.camel.impl.DefaultComponent.java</file>
			<file type="M">org.apache.camel.component.http.HttpComponent.java</file>
			<file type="M">org.apache.camel.component.http.HttpEndpoint.java</file>
			<file type="M">org.apache.camel.component.mina.MinaProducer.java</file>
			<file type="M">org.apache.camel.component.mina.MinaEndpoint.java</file>
			<file type="M">org.apache.camel.component.mina.MinaComponent.java</file>
			<file type="M">org.apache.camel.component.mina.MinaPayloadHelper.java</file>
			<file type="M">org.apache.camel.component.mina.MinaUdpUsingTemplateTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaConsumer.java</file>
			<file type="M">org.apache.camel.component.mail.MailEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileEndpoint.java</file>
			<file type="M">org.apache.camel.processor.Logger.java</file>
			<file type="M">org.apache.camel.component.jms.JmsQueueEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.JmsProducer.java</file>
			<file type="M">org.apache.camel.impl.ProcessorEndpoint.java</file>
			<file type="M">org.apache.camel.component.bean.RegistryBean.java</file>
			<file type="M">org.apache.camel.impl.DefaultPollingEndpoint.java</file>
			<file type="M">org.apache.camel.component.bean.BeanComponent.java</file>
			<file type="M">org.apache.camel.component.file.SpringFileRouteTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.FileEndpoint.java</file>
			<file type="M">org.apache.camel.impl.ScheduledPollEndpoint.java</file>
			<file type="M">org.apache.camel.component.test.TestEndpoint.java</file>
			<file type="M">org.apache.camel.component.jmx.JMXEndpoint.java</file>
			<file type="M">org.apache.camel.component.stringtemplate.StringTemplateEndpoint.java</file>
			<file type="M">org.apache.camel.component.direct.DirectEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfEndpoint.java</file>
			<file type="M">org.apache.camel.component.rmi.RmiProducer.java</file>
			<file type="M">org.apache.camel.component.mock.MockEndpoint.java</file>
			<file type="M">org.apache.camel.component.seda.SedaEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.JmsTemporaryQueueEndpoint.java</file>
			<file type="M">org.apache.camel.component.jhc.JhcEndpoint.java</file>
			<file type="M">org.apache.camel.spring.SpringCamelContext.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpEndpoint.java</file>
			<file type="M">org.apache.camel.impl.ProducerTest.java</file>
			<file type="M">org.apache.camel.component.irc.IrcEndpoint.java</file>
			<file type="M">org.apache.camel.component.uface.UFaceEndpoint.java</file>
			<file type="M">org.apache.camel.component.jcr.JcrEndpoint.java</file>
			<file type="M">org.apache.camel.component.jdbc.JdbcProducer.java</file>
			<file type="M">org.apache.camel.component.event.EventEndpoint.java</file>
			<file type="M">org.apache.camel.Endpoint.java</file>
			<file type="M">org.apache.camel.component.timer.TimerEndpoint.java</file>
			<file type="M">org.apache.camel.component.http.HttpExchange.java</file>
			<file type="M">org.apache.camel.component.stream.StreamEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.JmsTemporaryTopicEndpoint.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationProducer.java</file>
			<file type="M">org.apache.camel.component.ibatis.IBatisEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.EndpointMessageListener.java</file>
			<file type="M">org.apache.camel.component.dataset.DataSetEndpoint.java</file>
			<file type="M">org.apache.camel.component.bean.CamelInvocationHandler.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpEndpoint.java</file>
			<file type="M">org.apache.camel.management.CamelNamingStrategy.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationConsumer.java</file>
			<file type="M">org.apache.camel.component.list.ListEndpoint.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSoapEndpoint.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">505</link>
		</links>
	</bug>
	<bug id="1296" opendate="2009-01-27 07:27:08" fixdate="2009-01-27 07:28:30" resolution="Fixed">
		<buginformation>
			<summary>camel-ftp : uri set on endpoint has stripped all parameters, that is wrong as they should be there as well</summary>
			<description>See nabble
http://www.nabble.com/Camel-Remote-File-Producer---Recipient-List-Password-Issue-td21678952s22882.html
The bug is introduced with CAMEL-941</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpRemoteFileComponent.java</file>
			<file type="M">org.apache.camel.component.file.remote.UriConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumerMultipleDirectoriesTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1301" opendate="2009-01-29 01:52:37" fixdate="2009-01-30 08:09:15" resolution="Fixed">
		<buginformation>
			<summary>NPE in FactoryFinder.findClass when context classloader is null</summary>
			<description>My program works fine, when I run it as a normal Windows app.  But when I try to run it as a service, it throws a "Could not auto create component: http" which is caused by a NullPointerException which is caused by Thread.currentThread().getContextClassLoader() returning null.
A quick search found this ActiveMQ bug: http://issues.apache.org/activemq/browse/AMQ-1229 which is essentially identical.  If it&amp;amp;apos;s been fixed in ActiveMQ, probably you can just merge the fix from org.apache.activemq.util.FactoryFinder into org.apache.camel.util.FactoryFinder.
Incidentally, the fact that the context classloader is null has also been reported as a bug: http://issues.apache.org/jira/browse/DAEMON-100</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.util.FactoryFinder.java</file>
			<file type="M">org.apache.camel.impl.DefaultComponentResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="1325" opendate="2009-02-08 21:33:07" fixdate="2009-02-08 23:10:16" resolution="Fixed">
		<buginformation>
			<summary>Two more NullPointerExceptions when context classloader is null</summary>
			<description>When I applied the CAMEL-1301 fix (thanks Claus) I hit two more NullPointerExceptions caused by code that assumes that the context classloader will never be null.
Here&amp;amp;apos;s the relevant part of one stack trace:
java.lang.NullPointerException
 at org.apache.camel.impl.converter.AnnotationTypeConverterLoader.findPackages(AnnotationTypeConverterLoader.java:97)
 at org.apache.camel.impl.converter.AnnotationTypeConverterLoader.findPackageNames(AnnotationTypeConverterLoader.java:91)
And the other:
java.lang.NullPointerException
 at org.apache.camel.util.ResolverUtil.getResources(ResolverUtil.java:402)
 at org.apache.camel.util.ResolverUtil.find(ResolverUtil.java:313)
 at org.apache.camel.util.ResolverUtil.find(ResolverUtil.java:290)
A patch is attached.</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ResolverUtil.java</file>
			<file type="M">org.apache.camel.impl.converter.AnnotationTypeConverterLoader.java</file>
		</fixedFiles>
	</bug>
	<bug id="1271" opendate="2009-01-18 20:30:59" fixdate="2009-02-10 15:39:01" resolution="Fixed">
		<buginformation>
			<summary>Can only interact with servicemix-http if logging is at DEBUG</summary>
			<description>Given the following camel DSL:
from("activemq:queue.testJms.in")                                              
    .to("jbi:service:urn:oms:testHttp?mep=in-out")                           
    .to("activemq:queue.testJms.out"); 
and the following xbean.xml for the smx (3.3) SU:
&amp;lt;http:endpoint                                                                            
    service="oms:testHttp"                                                   
    endpoint="testHttp"                                                       
    role="provider"                                                                       
    locationURI="http://localhost:8080/testP1"&amp;gt;                                           
&amp;lt;/http:endpoint&amp;gt;   
then Camel operates correctly (or at least as desired) only if DEBUG logging is enabled in the org.apache.servicemix.http package.  This seems to be because a DOMSource is returned (which Camel can convert).  If the log level is reduced (say to WARN) then a StreamSource object is returned instead which Camel appears unable to convert.  This results in stack traces such as:
ERROR - DeadLetterChannel              - Failed delivery for exchangeId:                  
ID-davisond-laptop/53380-1232099798317/0-0. On delivery attempt: 0                        
caught: org.apache.camel.RuntimeCamelException:                                           
javax.xml.transform.TransformerException: java.io.IOException: Attempted                  
read on closed stream.                                                                    
org.apache.camel.RuntimeCamelException:                                                   
javax.xml.transform.TransformerException: java.io.IOException: Attempted                  
read on closed stream.                                                                    
        at                                                                                
org.apache.camel.util.ObjectHelper.invokeMethod(ObjectHelper.java:441)                    
        at                                                                                
org.apache.camel.impl.converter.InstanceMethodTypeConverter.convertTo(InstanceMethodTypeCo
+nverter.java:57) </description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.example.JAXBConvertTest.java</file>
			<file type="M">org.apache.camel.example.JAXBConverterMessageTypeTest.java</file>
			<file type="M">org.apache.camel.converter.jaxb.FallbackTypeConverter.java</file>
			<file type="M">org.apache.camel.processor.StreamSourceContentBasedRouterTest.java</file>
			<file type="M">org.apache.camel.util.MessageHelper.java</file>
			<file type="M">org.apache.camel.processor.interceptor.StreamCachingInterceptor.java</file>
			<file type="M">org.apache.camel.component.dataset.DataSetSedaTest.java</file>
			<file type="M">org.apache.camel.builder.DeadLetterChannelBuilder.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannel.java</file>
			<file type="M">org.apache.camel.issues.CacheInputStreamInDeadLetterIssue520Test.java</file>
			<file type="M">org.apache.camel.processor.StreamResequencerTest.java</file>
			<file type="M">org.apache.camel.processor.ThreadTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="973" opendate="2008-10-10 19:29:45" fixdate="2009-02-10 15:40:05" resolution="Fixed">
		<buginformation>
			<summary>TypeConverter Exception is thrown in the latest build of camel</summary>
			<description>I have upgraded to the latest of Camel and when I attempt to use the content based router pattern - its now throwing an error.
The contents of the Message passed is a StringSource object and from debugging camel - the BodyType is a StringSource but it is attempting to convert from a StreamCache to a StringSource. 
I will try and put a testcase together but if anyone has any ideas of its cause in the meantime ?
The error it throws it below.
thanks, Edell.
No type converter available to convert from type: class org.apache.servicemix.camel.JbiMessage to the required type: org.w3c.dom.Document with value JbiMessage: org.apache.servicemix.jbi.runtime.impl.NormalizedMessageImpl@1d03b5b
org.apache.camel.NoTypeConversionAvailableException: No type converter available to convert from type: class org.apache.servicemix.camel.JbiMessage to the required type: org.w3c.dom.Document with value JbiMessage: org.apache.servicemix.jbi.runtime.impl.NormalizedMessageImpl@1d03b5b
	at org.apache.camel.impl.converter.DefaultTypeConverter.convertTo(DefaultTypeConverter.java:117)
	at org.apache.camel.impl.converter.DefaultTypeConverter.convertTo(DefaultTypeConverter.java:65)
	at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:69)
	at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:51)
	at org.apache.camel.builder.xml.XPathBuilder.getDocument(XPathBuilder.java:528)
	at org.apache.camel.builder.xml.XPathBuilder.evaluateAs(XPathBuilder.java:420)
	at org.apache.camel.builder.xml.XPathBuilder.matches(XPathBuilder.java:98)
	at org.apache.camel.builder.xml.XPathBuilder.matches(XPathBuilder.java:63)
	at org.apache.camel.processor.ChoiceProcessor.process(ChoiceProcessor.java:47)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:75)
	at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:174)
	at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:96)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:63)
	at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:47)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:41)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:66)
	at org.apache.servicemix.camel.CamelProviderEndpoint.handleActiveProviderExchange(CamelProviderEndpoint.java:115)
	at org.apache.servicemix.camel.CamelProviderEndpoint.process(CamelProviderEndpoint.java:73)
	at org.apache.servicemix.common.AsyncBaseLifeCycle.doProcess(AsyncBaseLifeCycle.java:600)
	at org.apache.servicemix.common.AsyncBaseLifeCycle.processExchange(AsyncBaseLifeCycle.java:554)
	at org.apache.servicemix.common.AsyncBaseLifeCycle.processExchangeInTx(AsyncBaseLifeCycle.java:456)
	at org.apache.servicemix.common.AsyncBaseLifeCycle$2.run(AsyncBaseLifeCycle.java:341)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:650)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:675)
	at java.lang.Thread.run(Thread.java:595)</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.stream.StreamCacheConverter.java</file>
			<file type="M">org.apache.camel.processor.interceptor.StreamCachingInterceptorTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1205" opendate="2008-12-29 09:32:39" fixdate="2009-02-10 16:30:24" resolution="Fixed">
		<buginformation>
			<summary>@EndpointInject can not lookup bean if endpoint is defined directly as a consumer (from)</summary>
			<description>I was messing with camel-spring and routes using spring DSL
I had this part of unit test code

    @EndpointInject(name = "myFileEndpoint")
    protected Endpoint inputFile;


To lookup an endppoint with the given name myFileEndpoint
But if I define it directly then it cannot be found

        &amp;lt;route&amp;gt;
            &amp;lt;from id="myFileEndpoint" uri="file://target/antpathmatcher?consumer.recursive=true&amp;amp;amp;filter=#myFilter"/&amp;gt;
            &amp;lt;to uri="mock:result"/&amp;gt;
        &amp;lt;/route&amp;gt;


So I have to define it as a loose endpoint as:

        &amp;lt;endpoint id="myFileEndpoint" uri="file://target/antpathmatcher?consumer.recursive=true&amp;amp;amp;filter=#myFilter"/&amp;gt;

        &amp;lt;route&amp;gt;
            &amp;lt;from ref="myFileEndpoint"/&amp;gt;
            &amp;lt;to uri="mock:result"/&amp;gt;
        &amp;lt;/route&amp;gt;


</description>
			<version>1.6.0</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.xml.Namespaces.java</file>
			<file type="M">org.apache.camel.spring.handler.CamelNamespaceHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1321" opendate="2009-02-07 01:03:17" fixdate="2009-02-11 12:55:30" resolution="Fixed">
		<buginformation>
			<summary>Classloading leak in camel-jaxb component</summary>
			<description>See message thread:
http://www.nabble.com/Classloading-leak-in-camel-jaxb-component-td21879801s22882.html</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.jaxb.JaxbConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1330" opendate="2009-02-10 13:33:47" fixdate="2009-02-11 13:05:57" resolution="Fixed">
		<buginformation>
			<summary>camel-cxf Soap-Fault not returned as 500 http error code</summary>
			<description>Here is the mail thread which talks about it.
http://markmail.org/message/4qvwufpboro3lj34?q=camel-cxf+Soap-Fault+not+returned+as+500+http+error+code</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.0, 2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CXFGreeterRouterTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="505" opendate="2008-05-12 15:16:46" fixdate="2009-02-12 14:35:58" resolution="Fixed">
		<buginformation>
			<summary>make it easier to create Endpoint instances nicely via Spring XML</summary>
			<description>right now its a bit tricky creating Endpoint instances in a spring XML using the &amp;lt;bean&amp;gt;&amp;lt;property&amp;gt; mechanism.
It&amp;amp;apos;d be nice to be able to configure them more easily as...

&amp;lt;bean id="foo" class="org.apache.camel.component.file.FileEndpoint"&amp;gt;
  &amp;lt;property name="foo" value="bar"/&amp;gt; 
   ...


type stuff and have folks Spring IDE&amp;amp;apos;s smart complete stuff etc</description>
			<version>1.3.0</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.JmsComponent.java</file>
			<file type="M">org.apache.camel.component.rmi.RmiConsumer.java</file>
			<file type="M">org.apache.camel.component.rmi.RmiRouteTest.java</file>
			<file type="M">org.apache.camel.component.rmi.RmiEndpoint.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaWithNamedQueryTest.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaEndpoint.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppComponent.java</file>
			<file type="M">org.apache.camel.component.xmpp.RuntimeXmppException.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppEndpoint.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppBinding.java</file>
			<file type="M">org.apache.camel.component.quartz.StatefulCamelJob.java</file>
			<file type="M">org.apache.camel.component.quartz.CamelJob.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzEndpoint.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzRouteTest.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzComponent.java</file>
			<file type="M">org.apache.camel.component.quartz.StatefulQuartzRouteTest.java</file>
			<file type="M">org.apache.camel.component.ResourceBasedEndpoint.java</file>
			<file type="M">org.apache.camel.component.freemarker.FreemarkerComponent.java</file>
			<file type="M">org.apache.camel.component.velocity.VelocityComponent.java</file>
			<file type="M">org.apache.camel.component.freemarker.FreemarkerEndpoint.java</file>
			<file type="M">org.apache.camel.component.velocity.VelocityEndpoint.java</file>
			<file type="M">org.apache.camel.component.ResourceBasedComponent.java</file>
			<file type="M">org.apache.camel.component.feed.FeedEndpoint.java</file>
			<file type="M">org.apache.camel.component.rss.RssEndpoint.java</file>
			<file type="M">org.apache.camel.component.rss.AggregateRssFeedStrategy.java</file>
			<file type="M">org.apache.camel.component.rss.RssPollingConsumer.java</file>
			<file type="M">org.apache.camel.component.rss.RssComponent.java</file>
			<file type="M">org.apache.camel.component.atom.AtomEndpoint.java</file>
			<file type="M">org.apache.camel.component.rss.UpdatedDateFilter.java</file>
			<file type="M">org.apache.camel.component.rss.AggregateRssFeedCollection.java</file>
			<file type="M">org.apache.camel.dataformat.rss.RssDataFormat.java</file>
			<file type="M">org.apache.camel.component.rss.RssDateComparator.java</file>
			<file type="M">org.apache.camel.component.rss.RssEntryPollingConsumer.java</file>
			<file type="M">org.apache.camel.component.jdbc.JdbcEndpoint.java</file>
			<file type="M">org.apache.camel.component.jdbc.JdbcRouteTest.java</file>
			<file type="M">org.apache.camel.component.sql.SqlEndpoint.java</file>
			<file type="M">org.apache.camel.component.sql.SqlComponent.java</file>
			<file type="M">org.apache.camel.impl.DefaultComponent.java</file>
			<file type="M">org.apache.camel.component.http.HttpComponent.java</file>
			<file type="M">org.apache.camel.component.http.HttpEndpoint.java</file>
			<file type="M">org.apache.camel.component.mina.MinaProducer.java</file>
			<file type="M">org.apache.camel.component.mina.MinaEndpoint.java</file>
			<file type="M">org.apache.camel.component.mina.MinaComponent.java</file>
			<file type="M">org.apache.camel.component.mina.MinaPayloadHelper.java</file>
			<file type="M">org.apache.camel.component.mina.MinaUdpUsingTemplateTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaConsumer.java</file>
			<file type="M">org.apache.camel.component.mail.MailEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileEndpoint.java</file>
			<file type="M">org.apache.camel.processor.Logger.java</file>
			<file type="M">org.apache.camel.component.jms.JmsQueueEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.JmsProducer.java</file>
			<file type="M">org.apache.camel.impl.ProcessorEndpoint.java</file>
			<file type="M">org.apache.camel.component.bean.RegistryBean.java</file>
			<file type="M">org.apache.camel.impl.DefaultPollingEndpoint.java</file>
			<file type="M">org.apache.camel.component.bean.BeanComponent.java</file>
			<file type="M">org.apache.camel.component.file.SpringFileRouteTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.FileEndpoint.java</file>
			<file type="M">org.apache.camel.impl.ScheduledPollEndpoint.java</file>
			<file type="M">org.apache.camel.component.test.TestEndpoint.java</file>
			<file type="M">org.apache.camel.component.jmx.JMXEndpoint.java</file>
			<file type="M">org.apache.camel.component.stringtemplate.StringTemplateEndpoint.java</file>
			<file type="M">org.apache.camel.component.direct.DirectEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfEndpoint.java</file>
			<file type="M">org.apache.camel.component.rmi.RmiProducer.java</file>
			<file type="M">org.apache.camel.component.mock.MockEndpoint.java</file>
			<file type="M">org.apache.camel.component.seda.SedaEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.JmsTemporaryQueueEndpoint.java</file>
			<file type="M">org.apache.camel.component.jhc.JhcEndpoint.java</file>
			<file type="M">org.apache.camel.spring.SpringCamelContext.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpEndpoint.java</file>
			<file type="M">org.apache.camel.impl.ProducerTest.java</file>
			<file type="M">org.apache.camel.component.irc.IrcEndpoint.java</file>
			<file type="M">org.apache.camel.component.uface.UFaceEndpoint.java</file>
			<file type="M">org.apache.camel.component.jcr.JcrEndpoint.java</file>
			<file type="M">org.apache.camel.component.jdbc.JdbcProducer.java</file>
			<file type="M">org.apache.camel.component.event.EventEndpoint.java</file>
			<file type="M">org.apache.camel.Endpoint.java</file>
			<file type="M">org.apache.camel.component.timer.TimerEndpoint.java</file>
			<file type="M">org.apache.camel.component.http.HttpExchange.java</file>
			<file type="M">org.apache.camel.component.stream.StreamEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.JmsTemporaryTopicEndpoint.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationProducer.java</file>
			<file type="M">org.apache.camel.component.ibatis.IBatisEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.EndpointMessageListener.java</file>
			<file type="M">org.apache.camel.component.dataset.DataSetEndpoint.java</file>
			<file type="M">org.apache.camel.component.bean.CamelInvocationHandler.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpEndpoint.java</file>
			<file type="M">org.apache.camel.management.CamelNamingStrategy.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationConsumer.java</file>
			<file type="M">org.apache.camel.component.list.ListEndpoint.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSoapEndpoint.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">849</link>
			<link type="dependent" description="depends upon">1289</link>
			<link type="dependent" description="is depended upon by">506</link>
		</links>
	</bug>
	<bug id="1352" opendate="2009-02-18 02:32:54" fixdate="2009-02-18 03:58:22" resolution="Fixed">
		<buginformation>
			<summary>HttpHeaderFilterStrategy tries to filter out "http.requestMethod" but doesn&amp;apos;t</summary>
			<description>I actually found this in 1.5.0, but a quick look in ViewVC indicates that it still happens in 1.6.0 and in the trunk.
HttpHeaderFilterStrategy uses String.toLowerCase on "http.responseCode" because of the capital C.
It should also use toLowerCase on "http.requestMethod" because of the capital M, but it doesn&amp;amp;apos;t.
Thus the http.requestMethod header leaks into the HTTP protocol headers.</description>
			<version>1.6.0</version>
			<fixedVersion>2.0-M1, 1.6.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultHeaderFilterStrategy.java</file>
			<file type="M">org.apache.camel.component.http.HttpHeaderFilterStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="879" opendate="2008-09-05 14:25:34" fixdate="2009-02-19 14:09:56" resolution="Fixed">
		<buginformation>
			<summary>Intercept does not work properly in Spring DSL</summary>
			<description>Fixed in 1.x:
New Revision: 745870
This was a hard one to get fixed. Took me most of 2 x 0.5 days to get done.</description>
			<version>1.4.0</version>
			<fixedVersion>2.0-M1, 1.6.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.InterceptType.java</file>
			<file type="M">org.apache.camel.model.OutputType.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.util.EndpointHelper.java</file>
			<file type="M">org.apache.camel.model.ProcessorType.java</file>
			<file type="M">org.apache.camel.model.ProceedType.java</file>
		</fixedFiles>
	</bug>
	<bug id="1356" opendate="2009-02-18 16:43:02" fixdate="2009-02-25 15:33:43" resolution="Fixed">
		<buginformation>
			<summary>TryProcessor sets "caught.exception" header to in message, while there can be out already</summary>
			<description>Error exists in org.apache.camel.processor.TryProcessor.handleException(Exchange, Throwable). If your exchange has already out message (that can happen if you set out and then throw an exception. Then the exception caught is set on in message. When it reaches a pipeline it will be lost after first hop.
I believe TryProcessor should do what Pipelient does - copy out to in in new exchange if out exists.</description>
			<version>1.6.0</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.TryProcessor.java</file>
			<file type="M">org.apache.camel.processor.TryProcessorHandleTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1401" opendate="2009-02-27 06:31:24" fixdate="2009-02-27 09:12:42" resolution="Fixed">
		<buginformation>
			<summary>JaxbDataFormat is not thread-safe</summary>
			<description>JaxbDataFormat reuses the Marshaller/Unmarshaller instances.
However, according to the https://jaxb.dev.java.net/faq/index.html#threadSafety, Marshaller/Unmarshaller instances are NOT thread safe, so you can&amp;amp;apos;t use them from separate threads at the same time.
Due to this we are getting exceptions from the JAXB implementation (like ClassCastException or "org.xml.sax.SAXException: FWK005 parse may not be called while parsing."). Everything works nice with our custom JaxbDataFormat that creates new Unmarshaller/Marshaller instance on every request.
Also, lazy-creating instances (like JAXBContext) in getter methods is not thread-safe as well (because explicit synchronization is required).</description>
			<version>1.5.0</version>
			<fixedVersion>2.0-M1, 1.6.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.jaxb.JaxbDataFormat.java</file>
			<file type="M">org.apache.camel.example.JAXBConvertTest.java</file>
			<file type="M">org.apache.camel.converter.jaxb.JaxbConverter.java</file>
			<file type="M">org.apache.camel.converter.jaxb.FallbackTypeConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1384" opendate="2009-02-25 17:54:15" fixdate="2009-02-27 10:00:24" resolution="Fixed">
		<buginformation>
			<summary>ExchangeHelper should respect ExchangePattern.InOptionalOut </summary>
			<description>The utility method org.apache.camel.util.ExchangeHelper.copyResults() is use by many core classes. However, this method does not properly support MEP InOptionalOut.
Assuming in an InOptionalOut exchange, having no out message means just that  no out message should be sent, then the following lines in this method

//
            Message out = source.getOut(false);
            if (out != null) {
                result.getOut(true).copyFrom(out);
            } else {
                // no results so lets copy the last input


should be changed to:

//
            Message out = source.getOut(false);
            if (out != null) {
                result.getOut(true).copyFrom(out);
            } else if (result.getPattern() == ExchangePattern.InOptionalOut) {
                result.setOut(null);
            } else {
                // no results so lets copy the last input


</description>
			<version>1.6.0</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.dataset.DataSetConsumer.java</file>
			<file type="M">org.apache.camel.component.dataset.DataSetEndpoint.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
			<file type="M">org.apache.camel.impl.DefaultProducerTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="is depended upon by">1366</link>
		</links>
	</bug>
	<bug id="1366" opendate="2009-02-20 22:28:22" fixdate="2009-02-27 13:16:49" resolution="Fixed">
		<buginformation>
			<summary>EndpointMessageListener should respect ExchangePattern</summary>
			<description>In all current releases, org.apache.camel.component.jms.EndpointMessageListener.onMessage() has the following logic (line 90 in 1.6.0 code):

// send the reply
if (rce == null &amp;amp;&amp;amp; body != null &amp;amp;&amp;amp; !disableReplyTo) {
    sendReply(replyDestination, message, exchange, body);
}


This logic should also respect ExchangePattern of the exchange, so I propose a change to:

// send the reply
if (rce == null &amp;amp;&amp;amp; body != null &amp;amp;&amp;amp; exchange.isOutCapable()) {
    sendReply(replyDestination, message, exchange, body);
}


This change allows a processing pattern where the route may change the ExchangePattern using methods like RouteBuilder.inOnly() to switch the MEP at will so that the reply is send at a later time (true asynchronous exchange).  This processing pattern is particularly useful for integrating long running services. For example,

// Java DSL
from("activemq:my_queue?exchangePattern=InOnly").to("predict_weather://?reply_later=true");
// or
from("activemq:my_queue2").inOnly().to("predict_weather://?reply_later=true");


The flaw of the current logic makes it impossible to do true asynchronous exchange, because 1) it does not respect the ExchangePattern; 2) if property "disableReplyTo" is used, the "org.apache.camel.jms.replyDestination" property will not be set (see method createExchange in the same file), thus downstream cannot find the reply destination.
The proposed change can also deprecate the disableReplyTo property and put the MEP concept into good use.</description>
			<version>1.6.0</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.EndpointMessageListener.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="depends upon">1384</link>
			<link type="dependent" description="depends upon">1405</link>
		</links>
	</bug>
	<bug id="1406" opendate="2009-02-28 10:03:56" fixdate="2009-02-28 12:57:08" resolution="Fixed">
		<buginformation>
			<summary>DelayProcessor should handle interrupting while shutting down</summary>
			<description>See nabble:
http://www.nabble.com/Re%3A-Delayer%3A-%22Transport-disposed%22-at-JVM-Shutdown-td22202577s22882.html</description>
			<version>1.6.0</version>
			<fixedVersion>2.0-M1, 1.6.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.DelayerTest.java</file>
			<file type="M">org.apache.camel.processor.DelayProcessorSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="1408" opendate="2009-02-28 16:36:21" fixdate="2009-02-28 17:38:00" resolution="Fixed">
		<buginformation>
			<summary>File component - better support for absolute path</summary>
			<description>See nabble:
http://www.nabble.com/File%3A-using-absolute-file-paths-with-moveExpressions-td22253199.html</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.language.FileLanguageTest.java</file>
			<file type="M">org.apache.camel.language.simple.FileExpressionBuilder.java</file>
			<file type="M">org.apache.camel.language.simple.FileLanguage.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileExchange.java</file>
			<file type="M">org.apache.camel.component.file.FileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.GenericFile.java</file>
			<file type="M">org.apache.camel.component.file.strategy.FileLockExclusiveReadLockStrategy.java</file>
			<file type="M">org.apache.camel.component.file.strategy.GenericFileRenameExclusiveReadLockStrategy.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.FileConsumerCommitRenameAbsolutePathStrategyTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1379" opendate="2009-02-24 22:36:52" fixdate="2009-03-02 02:03:32" resolution="Fixed">
		<buginformation>
			<summary>Mina configuration is shared between endpoints</summary>
			<description>Establishing a MINA endpoint with a custom codec, and then establishing another without a custom codec is a problem. The second endpoint inherits the first endpoint&amp;amp;apos;s codec.
My recommendation is to not share configuration data between endpoint creation. I recommend that the MINA component instantiate a new configuration for each new endpoint instead of copying the previous configuration.
As a workaround the user can specify "codec" as a URI parameter with no value.</description>
			<version>1.5.0</version>
			<fixedVersion>2.0-M1, 1.6.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina.MinaCustomCodecTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaEncodingTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="1414" opendate="2009-03-03 14:37:47" fixdate="2009-03-03 15:46:35" resolution="Fixed">
		<buginformation>
			<summary>JMSMessage vanishes attachments</summary>
			<description>When using this kind of route
&amp;lt;from uri="activemq:queue:test"/&amp;gt;
&amp;lt;camel:process ref="mailProcessor" /&amp;gt;
&amp;lt;to uri="smtp://localhost:25?to=user@localhost" /&amp;gt;
and trying to enrich the message in the mailProcessor with
exchange.getIn().addAttachment("attachement.txt",
                new DataHandler("Hello world", "text/plain"));
The received mail doesn&amp;amp;apos;t contains any attachment.
If the input "from" is a "direct" instead of activemq, it works fine.
Inspecting source code,  MessageSupport.copyFrom(Message that) does
getAttachments().putAll(that.getAttachments());
but the child class JmsMessage doesn&amp;amp;apos;t.
</description>
			<version>2.0.0</version>
			<fixedVersion>2.0-M1, 1.6.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationMessage.java</file>
			<file type="M">org.apache.camel.component.jms.JmsMessage.java</file>
		</fixedFiles>
	</bug>
	<bug id="1411" opendate="2009-03-03 09:24:47" fixdate="2009-03-03 16:59:02" resolution="Fixed">
		<buginformation>
			<summary>CamelContext - Add ClassResolver to be used when you need to load a class instead of ObjectHelper.loadClass to work in OSGi environments</summary>
			<description>Add the skeleton and let Willem add the stuff in camel-osgi</description>
			<version>1.6.0</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultClassResolver.java</file>
			<file type="M">org.apache.camel.component.jms.JmsComponent.java</file>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.component.xslt.XsltComponent.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaComponent.java</file>
			<file type="M">org.apache.camel.spring.util.SimpleRouteBuilder.java</file>
			<file type="M">org.apache.camel.web.resources.ConvertersResource.java</file>
			<file type="M">org.apache.camel.component.jms.JmsQueueEndpoint.java</file>
			<file type="M">org.apache.camel.CamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileEndpoint.java</file>
			<file type="M">org.apache.camel.converter.ConverterTest.java</file>
			<file type="M">org.apache.camel.osgi.OsgiAnnotationTypeConverterLoader.java</file>
			<file type="M">org.apache.camel.component.jcr.JcrConverterTest.java</file>
			<file type="M">org.apache.camel.osgi.OsgiAnnotationTypeConverterLoaderTest.java</file>
			<file type="M">org.apache.camel.util.WebSphereResolverUtil.java</file>
			<file type="M">org.apache.camel.osgi.CamelOsgiTestSupport.java</file>
			<file type="D">org.apache.camel.osgi.OsgiResolverUtil.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyKeyValuePairFactory.java</file>
			<file type="M">org.apache.camel.impl.ReportingTypeConverterLoader.java</file>
			<file type="M">org.apache.camel.util.ResolverUtil.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindyCsvDataFormat.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.model.dataformat.DataFormatType.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyAbstractFactory.java</file>
			<file type="M">org.apache.camel.osgi.OsgiResolverUtilTest.java</file>
			<file type="M">org.apache.camel.model.loadbalancer.LoadBalancerType.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyCsvFactory.java</file>
			<file type="M">org.apache.camel.processor.interceptor.TraceInterceptor.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.util.AnnotationModelLoader.java</file>
			<file type="M">org.apache.camel.converter.StringSourceTest.java</file>
			<file type="M">org.apache.camel.impl.converter.DefaultTypeConverter.java</file>
			<file type="M">org.apache.camel.impl.converter.AnnotationTypeConverterLoader.java</file>
			<file type="M">org.apache.camel.util.FactoryFinder.java</file>
			<file type="M">org.apache.camel.spring.RouteBuilderFinder.java</file>
			<file type="M">org.apache.camel.converter.JaxpTest.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.kvp.BindyKeyValuePairDataFormat.java</file>
			<file type="M">org.apache.camel.osgi.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.maven.ConvertersMojo.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="is depended upon by">1404</link>
		</links>
	</bug>
	<bug id="1416" opendate="2009-03-03 20:35:41" fixdate="2009-03-03 21:49:36" resolution="Fixed">
		<buginformation>
			<summary>Using # notation to reference CXF serviceClass is not working</summary>
			<description>See issue reported in mailing list.
http://www.nabble.com/camel-cxf-endpoint---error-%3A-Failed-to-convert-property-value-of-type--...-tp22312601p22312601.html</description>
			<version>2.0.0</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfComponent.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSpringEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="1417" opendate="2009-03-04 08:26:41" fixdate="2009-03-04 10:58:01" resolution="Fixed">
		<buginformation>
			<summary>StreamCache causes to many type converters not possible</summary>
			<description>Since StreamCache is default turned on it cause to many convters attempt that fails in MessageSupport.
No type converter available to convert from type: java.lang.Integer to the required type: org.apache.camel.StreamCache with value 1
It hurts performance to much. 
See nabble:
http://www.nabble.com/Performance-and-MessageSupport.getBody-%281.6.0%29-td22291841s22882.html</description>
			<version>1.6.0</version>
			<fixedVersion>2.0-M1, 1.6.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mock.MockEndpointTest.java</file>
			<file type="M">org.apache.camel.processor.RoutePerformanceTest.java</file>
			<file type="M">org.apache.camel.component.mock.MockEndpoint.java</file>
			<file type="M">org.apache.camel.processor.interceptor.StreamCachingInterceptor.java</file>
			<file type="M">org.apache.camel.impl.MessageSupport.java</file>
			<file type="M">org.apache.camel.processor.Camel715ThreadProcessorTest.java</file>
			<file type="M">org.apache.camel.impl.converter.DefaultTypeConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1421" opendate="2009-03-04 20:33:33" fixdate="2009-03-04 20:39:10" resolution="Fixed">
		<buginformation>
			<summary>Cxf Endpoint String bean properites are not merged</summary>
			<description>CxfEndpointBeanDefinitionParser maintains a property map that can be overridden by user provided property map.  They should be merged.
Please see the email thread. 
http://www.nabble.com/camel-cxf---dataformat-tp22332652p22332652.html</description>
			<version>2.0.0</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.ServiceClassRefTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="1426" opendate="2009-03-05 09:46:23" fixdate="2009-03-06 07:21:20" resolution="Fixed">
		<buginformation>
			<summary>Camel Spring configuration doen&amp;apos;t support to scan the SpringRouteBuilder</summary>
			<description>Here is the mail thread which talks about it.
http://www.nabble.com/Error%3A-This-SpringBuilder-is-not-being-used-with-a-SpringCamelContext-and-there-is-no-applicationContext-property-configured-to22326547s22882.html</description>
			<version>1.4.0</version>
			<fixedVersion>2.0-M1, 1.6.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.SpringRouteBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1412" opendate="2009-03-03 09:58:51" fixdate="2009-03-06 07:35:54" resolution="Fixed">
		<buginformation>
			<summary>Can not load the QueueBrowserStrategy in OSGI environment</summary>
			<description>Here is the mail thread which discusses about it.
http://www.nabble.com/Classloading-and-OSGI-to22303475.html#a22303475</description>
			<version>1.6.0</version>
			<fixedVersion>2.0-M1, 1.6.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="1441" opendate="2009-03-09 13:25:25" fixdate="2009-03-09 15:26:00" resolution="Fixed">
		<buginformation>
			<summary>camel-file : java.lang.StringIndexOutOfBoundsException: String index out of range: 1</summary>
			<description>The following spring DSL routes generates an error :  
	&amp;lt;camelContext trace="true" xmlns="http://camel.apache.org/schema/osgi"&amp;gt;
		&amp;lt;camel:package&amp;gt;org.apache.camel.example.reportincident.routing&amp;lt;/camel:package&amp;gt;
		&amp;lt;!-- File route  --&amp;gt;
		&amp;lt;camel:route&amp;gt;
			&amp;lt;camel:from	uri="file://d:/temp/data/?move=d:/temp/done/$
{file:name}
" /&amp;gt;
			&amp;lt;camel:unmarshal ref="bindyDataformat" /&amp;gt;
			&amp;lt;camel:to uri="bean:csv" /&amp;gt;
			&amp;lt;camel:to uri="activemq:queue:in" /&amp;gt;
		&amp;lt;/camel:route&amp;gt;
		&amp;lt;camel:route&amp;gt;
			&amp;lt;camel:from uri="activemq:queue:in" /&amp;gt;
			&amp;lt;camel:from	uri="file://d:/temp/data/queue" /&amp;gt;
		&amp;lt;/camel:route&amp;gt;
2009-03-09 14:23:09,968 WARN  ScheduledPollConsumer - An exception occurred while polling: Endpoint[file://d:/temp/data/?move=d:/temp/done/$
{file:name}
]: String index out of range: 1 
java.lang.StringIndexOutOfBoundsException: String index out of range: 1
	at java.lang.String.charAt(String.java:687)
	at java.util.regex.Matcher.appendReplacement(Matcher.java:703)
	at java.util.regex.Matcher.replaceAll(Matcher.java:813)
	at java.lang.String.replaceAll(String.java:2190)
	at org.apache.camel.component.file.GenericFile.normalizePathToProtocol(GenericFile.java:238)
	at org.apache.camel.component.file.GenericFile.setEndpointPath(GenericFile.java:223)
	at org.apache.camel.component.file.FileConsumer.asGenericFile(FileConsumer.java:103)
	at org.apache.camel.component.file.FileConsumer.pollDirectory(FileConsumer.java:56)
	at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:66)
	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:66)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)
	at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:317)
	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:150)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:98)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:181)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:205)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:619)</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFile.java</file>
			<file type="M">org.apache.camel.util.FileUtil.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFile.java</file>
		</fixedFiles>
	</bug>
	<bug id="1428" opendate="2009-03-05 17:08:26" fixdate="2009-03-09 15:30:51" resolution="Fixed">
		<buginformation>
			<summary>SftpConsumer : GenericFileRenameProcessStrategy - String index out of bounds</summary>
			<description>While trying to consume a file via SFTP and using the moveExpression to move the file into a done folder a renameException is thrown.
In GenericFile the relativeFileName reads something like the following.   /incoming/test/file1.txt
When it tries to call this code and exception is thrown because File.separator is &amp;amp;apos;\&amp;amp;apos; in a windows environment.
String relative = relativeFileName.substring(0, relativeFileName.lastIndexOf(File.separator));</description>
			<version>2.0.0</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFileExchange.java</file>
			<file type="M">org.apache.camel.component.file.GenericFile.java</file>
			<file type="M">org.apache.camel.component.file.remote.PaddyRouteTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpOperations.java</file>
			<file type="M">org.apache.camel.util.FileUtil.java</file>
			<file type="M">org.apache.camel.component.file.remote.UriConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFile.java</file>
			<file type="M">org.apache.camel.component.file.FileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.strategy.FileProcessStrategyFactory.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileConfiguration.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpOperations.java</file>
			<file type="M">org.apache.camel.language.FileLanguageTest.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilder.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileEndpoint.java</file>
			<file type="M">org.apache.camel.language.simple.FileLanguage.java</file>
			<file type="M">org.apache.camel.component.file.strategy.FileLockExclusiveReadLockStrategy.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.component.file.strategy.GenericFileRenameExclusiveReadLockStrategy.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpMoveFileAbsoluteFolderRecursiveTest.java</file>
			<file type="D">org.apache.camel.component.file.FileConsumeMoveMultipleDirectoriesTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpMoveFileToHiddenFolderRecursiveTest.java</file>
			<file type="M">org.apache.camel.component.file.FileBinding.java</file>
			<file type="M">org.apache.camel.component.file.AntPathMatcherGenericFileFilter.java</file>
			<file type="M">org.apache.camel.component.file.FileConsumerBeginRenameStrategyTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpRemoteFileSortByExpressionTest.java</file>
			<file type="M">org.apache.camel.component.file.strategy.MarkerFileExclusiveReadLockStrategy.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpRemoteFileSortByNestedExpressionTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumerWithNoFileOptionTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumerMultipleDirectoriesTest.java</file>
			<file type="M">org.apache.camel.component.file.FileConfigureTest.java</file>
			<file type="M">org.apache.camel.component.file.strategy.GenericFileRenameProcessStrategy.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpMoveFileRecursiveTest.java</file>
			<file type="M">org.apache.camel.component.file.FileConsumerBeginAndCommitExpressionRenameStrategyTest.java</file>
			<file type="M">org.apache.camel.component.file.strategy.GenericFileDeleteProcessStrategy.java</file>
			<file type="M">org.apache.camel.component.file.FileSortByExpressionTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpSetNamesWithMultiDirectoriesTest.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.FileConsumerBeginAndCommitRenameStrategyTest.java</file>
			<file type="M">org.apache.camel.component.file.FileSortByNestedExpressionTest.java</file>
			<file type="M">org.apache.camel.language.simple.FileExpressionBuilder.java</file>
			<file type="M">org.apache.camel.component.file.FileConsumeFilesAndDelete.java</file>
			<file type="M">org.apache.camel.component.file.FileConsumerBeginExpressionRenameStrategyTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpLoginTest.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileProducer.java</file>
			<file type="D">org.apache.camel.component.file.remote.RemoteFileOperationFailedException.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumerDeleteNoWritePermissionTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileConfiguration.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.model.dataformat.XStreamDataFormat.java</file>
			<file type="M">org.apache.camel.language.jxpath.JXPathExpression.java</file>
			<file type="M">org.apache.camel.model.dataformat.CsvDataFormat.java</file>
			<file type="M">org.apache.camel.component.file.FileEndpoint.java</file>
			<file type="M">org.apache.camel.processor.interceptor.StreamCachingInterceptorTest.java</file>
			<file type="M">org.apache.camel.model.dataformat.RssDataFormat.java</file>
			<file type="M">org.apache.camel.model.dataformat.ZipDataFormat.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.converter.stream.StreamCacheConverter.java</file>
			<file type="M">org.apache.camel.model.Constants.java</file>
			<file type="M">org.apache.camel.processor.interceptor.StreamCachingInterceptor.java</file>
			<file type="M">org.apache.camel.util.URISupport.java</file>
			<file type="M">org.apache.camel.processor.DelegateProcessor.java</file>
			<file type="M">org.apache.camel.processor.ExchangePatternProcessor.java</file>
			<file type="M">org.apache.camel.impl.DelegateLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.util.UuidGenerator.java</file>
			<file type="M">org.apache.camel.model.dataformat.HL7DataFormat.java</file>
			<file type="M">org.apache.camel.impl.DefaultMessage.java</file>
			<file type="M">org.apache.camel.impl.DefaultRouteContext.java</file>
			<file type="M">org.apache.camel.processor.aggregate.DefaultAggregationCollection.java</file>
			<file type="M">org.apache.camel.model.loadbalancer.LoadBalancerDefinition.java</file>
			<file type="M">org.apache.camel.impl.DefaultConsumer.java</file>
			<file type="M">org.apache.camel.NoSuchPropertyException.java</file>
			<file type="M">org.apache.camel.EndpointInject.java</file>
			<file type="M">org.apache.camel.processor.loadbalancer.LoadBalancerConsumer.java</file>
			<file type="M">org.apache.camel.processor.DelegateAsyncProcessor.java</file>
			<file type="M">org.apache.camel.util.CamelContextHelper.java</file>
			<file type="M">org.apache.camel.component.file.FileComponent.java</file>
			<file type="M">org.apache.camel.management.InstrumentationLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.util.concurrent.CountingLatch.java</file>
			<file type="M">org.apache.camel.util.CollectionStringBuffer.java</file>
			<file type="M">org.apache.camel.impl.ExpressionAdapter.java</file>
			<file type="M">org.apache.camel.component.direct.DirectEndpoint.java</file>
			<file type="M">org.apache.camel.model.language.MethodCallExpression.java</file>
			<file type="M">org.apache.camel.impl.ServiceSupport.java</file>
			<file type="M">org.apache.camel.NoSuchBeanException.java</file>
			<file type="M">org.apache.camel.management.CamelNamingStrategy.java</file>
			<file type="M">org.apache.camel.impl.DefaultComponent.java</file>
			<file type="M">org.apache.camel.model.InterceptDefinition.java</file>
			<file type="M">org.apache.camel.NoSuchHeaderException.java</file>
			<file type="M">org.apache.camel.component.file.FileConsumerMoveExpressionTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultScheduledPollConsumer.java</file>
			<file type="M">org.apache.camel.impl.DefaultPollingEndpoint.java</file>
			<file type="M">org.apache.camel.model.dataformat.FlatpackDataFormat.java</file>
			<file type="D">org.apache.camel.component.file.FileConsumeFileOnlyTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpDirectoryToBinaryFilesTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpPollFileOnlyTest.java</file>
			<file type="M">org.apache.camel.component.file.FileOperations.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromQueueThenConsumeFtpToMockTest.java</file>
			<file type="D">org.apache.camel.component.file.FileConsumeFileOnlyNoDirectoryOptionTest.java</file>
			<file type="M">org.apache.camel.component.file.FilerProducerFileNamesTest.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="is depended upon by">1430</link>
		</links>
	</bug>
	<bug id="1444" opendate="2009-03-10 11:17:23" fixdate="2009-03-10 11:34:15" resolution="Fixed">
		<buginformation>
			<summary>camel-mina - UDP protocol could have an issue if used in same camel context as both client and server sending to localhost</summary>
			<description>A mina bytebuffer could be shared in a mina session. It should not be.
See nabble, that could lead to that problem the end user has:
http://www.nabble.com/Camel-1.6-2.0-MINA-UDP-issue-td22426433s22882.html</description>
			<version>1.6.0</version>
			<fixedVersion>2.0-M1, 1.6.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina.MinaProducer.java</file>
			<file type="M">org.apache.camel.component.mina.MinaTcpLineDelimiterUsingPlainSocketTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaComponent.java</file>
			<file type="M">org.apache.camel.component.mina.MinaTcpWithIoOutProcessorExceptionTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaConsumer.java</file>
			<file type="M">org.apache.camel.component.mina.MinaUdpWithInOutUsingPlainSocketTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1443" opendate="2009-03-10 04:14:36" fixdate="2009-03-12 07:47:48" resolution="Fixed">
		<buginformation>
			<summary>Unable to resolve scripting languages in OSGi environment</summary>
			<description>The OsgiLanguageResolver.java created since CAMEL-1221 does not resolve scripting languages by using the default resolver declared in camel-script. The DefaultLanguageResolver, however in the non-osgi context, handles it properly.
This leads to NullPointerException while launching a route in an OSGi container using a scripting language, e.g. javascript.
Exception in thread "SpringOsgiExtenderThread-2" java.lang.NullPointerException
	at org.apache.camel.model.language.ExpressionType.createPredicate(ExpressionType.java:145)
	at org.apache.camel.model.ExpressionNode.createFilterProcessor(ExpressionNode.java:95)
	at org.apache.camel.model.WhenType.createProcessor(WhenType.java:57)
	at org.apache.camel.model.ChoiceType.createProcessor(ChoiceType.java:73)
...
</description>
			<version>1.6.0</version>
			<fixedVersion>2.0-M1, 1.6.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.osgi.OsgiLanguageResolver.java</file>
			<file type="M">org.apache.camel.impl.DefaultLanguageResolver.java</file>
			<file type="M">org.apache.camel.osgi.OsgiLanguageResolverTest.java</file>
			<file type="M">org.apache.camel.osgi.Activator.java</file>
			<file type="M">org.apache.camel.osgi.CamelMockBundle.java</file>
		</fixedFiles>
	</bug>
	<bug id="1442" opendate="2009-03-09 15:37:35" fixdate="2009-03-12 13:59:54" resolution="Fixed">
		<buginformation>
			<summary>unmarshaling of data always send the last occurence of the stream</summary>
			<description>The unmarshaling method of BindyDataFormat (CSV or Key Value Pair) does not create a new model object for each new line of the stream readed</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindyComplexCsvMarshallTest.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyKeyValuePairFactory.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindySimpleCsvMarshallTest.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.model.complex.twoclassesandonelink.Order.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindyCsvDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindySimpleCsvUnmarshallTest.java</file>
			<file type="D">org.apache.camel.dataformat.bindy.util.ConvertSeparator.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindyComplexCsvUnmarshallTest.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.fix.BindySimpleKeyValuePairTabUnmarshallTest.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyAbstractFactory.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.kvp.BindyKeyValuePairDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.annotation.CsvRecord.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.model.simple.oneclass.Order.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.fix.BindySimpleKeyValuePairTabMarshallTest.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyCsvFactory.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.model.complex.twoclassesandonelink.Client.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.annotation.Message.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.fix.BindySimpleKeyValuePairMarshallTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1454" opendate="2009-03-12 17:04:50" fixdate="2009-03-12 19:09:26" resolution="Fixed">
		<buginformation>
			<summary>CXF component running in Payload mode does not work with Holders</summary>
			<description>If you convert the CxfWsdlFirstTest to run in PAYLOAD mode (by simply changing the endpoint URI in Spring xml), the client.getPerson() invocation will fail.</description>
			<version>1.6.0</version>
			<fixedVersion>2.0-M1, 1.6.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.feature.PayLoadDataFormatFeature.java</file>
			<file type="M">org.apache.camel.component.cxf.interceptors.AbstractMessageInInterceptor.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1462" opendate="2009-03-17 05:43:34" fixdate="2009-03-17 07:35:55" resolution="Fixed">
		<buginformation>
			<summary>JMXAgent - If no privileges then lifecycle is null</summary>
			<description>If you run Camel on OC4j then it will by default not grant access to its JMX MbeanServer.
So if you use jmxAgent in Camel spring configuration it is setup but Camel cannot access it and it causes a NPE when you do endpoint lookup later.</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.management.InstrumentationLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.spring.CamelJMXAgentDefinition.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.management.DefaultInstrumentationAgent.java</file>
			<file type="M">org.apache.camel.component.cxf.converter.CxfConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1463" opendate="2009-03-17 08:27:47" fixdate="2009-03-18 07:05:38" resolution="Fixed">
		<buginformation>
			<summary>JMX instrumentation - will add DeadLetterChannel even if you have defined to use NoErrorHandler</summary>
			<description>See nabble:
http://www.nabble.com/StreamCaching-in-Camel-1.6-td22305654s22882.html
I will add an unit test that demonstrates this:
org.apache.camel.processor.ChoiceNoErrorHandlerTest
The route should at all time not contain any error handler at all, regardless wether JMX is enabled or not.</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.InstrumentationLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.management.InstrumentationInterceptStrategy.java</file>
			<file type="M">org.apache.camel.processor.ChoiceNoErrorHandlerTest.java</file>
			<file type="M">org.apache.camel.issues.BelasThreadErrorHandlerIssue901Test.java</file>
			<file type="M">org.apache.camel.impl.DefaultLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.builder.xml.XPathBuilder.java</file>
			<file type="M">org.apache.camel.processor.SendProcessor.java</file>
			<file type="D">org.apache.camel.util.ProcessorTypeHelper.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="1477" opendate="2009-03-23 04:54:32" fixdate="2009-03-23 06:53:30" resolution="Fixed">
		<buginformation>
			<summary>RouteBuilderRef - does not work with injected endpoints</summary>
			<description>When using routeBuilderRef instead of package to configure route builder in spring XML then the former does not work if you have eg endpoint defined as well and injected the endpoint using EndpointInjected

    @EndpointInject(name = "data")
    protected Endpoint data;

    public void configure() throws Exception {
        // configure a global transacted error handler
        errorHandler(transactionErrorHandler(required));

        from(data)
        ...
}


And the Spring DSL

    &amp;lt;bean id="route" class="org.apache.camel.itest.tx.JmsToHttpWithRollbackRoute"/&amp;gt;

    &amp;lt;!-- Camel context --&amp;gt;
    &amp;lt;camelContext id="camel" xmlns="http://camel.apache.org/schema/spring"&amp;gt;
        &amp;lt;!-- use our route --&amp;gt;
        &amp;lt;routeBuilder ref="route"/&amp;gt;

        &amp;lt;!-- define our data endpoint as the activemq queue we send a message to --&amp;gt;
        &amp;lt;endpoint id="data" uri="activemq:queue:data"/&amp;gt;
    &amp;lt;/camelContext&amp;gt;

</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultExchange.java</file>
			<file type="M">org.apache.camel.spring.spi.TransactionInterceptor.java</file>
			<file type="M">org.apache.camel.impl.PollingConsumerSupport.java</file>
			<file type="M">org.apache.camel.impl.LoggingExceptionHandler.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannel.java</file>
			<file type="D">org.apache.camel.spring.config.AutoRegisteredRouteBuilderTest.java</file>
			<file type="M">org.apache.camel.itest.tx.JmsToHttpRoute.java</file>
		</fixedFiles>
	</bug>
	<bug id="1480" opendate="2009-03-24 07:10:42" fixdate="2009-03-24 08:33:46" resolution="Fixed">
		<buginformation>
			<summary>JMS - Sending a message with jmsTemplate102=true fails</summary>
			<description>See nabble:
http://www.nabble.com/Apache-Camel-2.0-M1-java.lang.ClassCastException%3A-org.apache.camel.component.jms.JmsConfiguration%24CamelJmsTeemplate102-td22665483s22882.html
The ClassCastException is because of the old JMS API is used.
Camel should test whether the template is 1.1 or 1.0.2 and cast to correct type.
</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsTransferExceptionTest.java</file>
			<file type="M">org.apache.camel.component.jms.JmsProducer.java</file>
			<file type="M">org.apache.camel.component.jms.JmsConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="1461" opendate="2009-03-16 18:15:23" fixdate="2009-03-24 11:19:23" resolution="Fixed">
		<buginformation>
			<summary>A request route with a topic node incurs a 20 second wait and refers to the wrong MEP.</summary>
			<description>If a route contains a node that publishes to a topic, the route is incorrectly suspended for a default 20 seconds at the topic node.  Further, JmsProducer.java checks the MEP of the original request Exchange and not the endpoint of the topic.
For example, say I have a route built like this:

from("activemq:queue:request").
  to("generate_news").
  to("activemq:topic:news").
  to("do_something_else");


The original request is expecting a reply. However, after the "news" is pumped into the news topic, there is a default 20 second wait (requestTimeout).  This wait always results in the exception: "The OUT message was not received within: 20000 millis on the exchange..." 
After reading the JmsProducer code, I changed the route to the following:

from("activemq:queue:request").
  to("generate_news").
  to("activemq:topic:news?exchangePattern=InOnly").
  to("do_something_else");


This reveals the root of the bug, which is in the first few lines of method org.apache.camel.component.jms.JmsProducer.process(Exchange):

//
    public void process(final Exchange exchange) {
        final org.apache.camel.Message in = exchange.getIn();

        if (exchange.getPattern().isOutCapable()) {


The above if statement checks the MEP of the original request&amp;amp;apos;s Exchange and not the new endpoint of the news topic. This makes the above "?exchangePattern=InOnly" configuration useless, because the original request MEP is InOut.  The result is that after that 20 second time-out, the temporary queue for the original request has expired, so the whole request failed. Note that the next node "do_something_else" is never reached due to the time-out exception.</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsProducer.java</file>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
			<file type="M">org.apache.camel.component.jms.EndpointMessageListener.java</file>
		</fixedFiles>
	</bug>
	<bug id="1474" opendate="2009-03-20 19:26:34" fixdate="2009-03-26 04:26:04" resolution="Fixed">
		<buginformation>
			<summary>On the wire headers are dropped inside camel route between two CxfEndpoints</summary>
			<description>Currently if there is a Camel route that involves two or more cxf endpoints, then the on the wire message headers such as SOAP headers are dropped.
This fix enables one to relay these headers along the route or preserve the old behaviour and drop the headers. 
Headers relay/drop is bidirectional. Both out-of-band (not defined  in WSDL contract) and in-band (defined in WSDL contract) headers are supported.
Relaying headers can be further customized by implementing additional logic inside of MessageHeadersRelay interface. 
The default behaviour is to relay headers provided that  an instance of MessageHeadersRelay bound to message binding namespace allows a header to be relayed. 
Please see .../components/camel-cxf/src/test/java/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest.java for details on how this is done.
Attached is the patch that provides this functionality.
Thanks,
Marat</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xmpp.XmppMessage.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppBinding.java</file>
			<file type="M">org.apache.camel.spi.HeaderFilterStrategy.java</file>
			<file type="M">org.apache.camel.component.cxf.util.CxfHeaderHelper.java</file>
			<file type="M">org.apache.camel.component.http.DefaultHttpBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfHeaderFilterStrategy.java</file>
			<file type="M">org.apache.camel.component.jhc.JhcProducer.java</file>
			<file type="M">org.apache.camel.component.cxf.transport.CamelConduit.java</file>
			<file type="M">org.apache.camel.component.http.HttpPollingConsumer.java</file>
			<file type="M">org.apache.camel.impl.DefaultHeaderFilterStrategy.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumer.java</file>
			<file type="M">org.apache.camel.component.http.HttpBinding.java</file>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSoapBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBinding.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfBinding.java</file>
			<file type="M">org.apache.camel.component.mail.MailMessage.java</file>
			<file type="M">org.apache.camel.component.restlet.DefaultRestletBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducer.java</file>
			<file type="M">org.apache.camel.component.jms.JmsMessage.java</file>
			<file type="M">org.apache.camel.component.cxf.transport.CamelDestination.java</file>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="1488" opendate="2009-03-25 20:18:08" fixdate="2009-03-26 09:23:05" resolution="Fixed">
		<buginformation>
			<summary>BeanInfo.overridesExistingMethod() doesn&amp;apos;t handle overloaded methods correctly.</summary>
			<description>Camel can fail to determine the appropriate method to call on a bean that has overloaded (vs. overridden) methods. It will always call the first overloaded method, even if the parameter is not the same type as that of the message being processed.
The bug is in BeanInfo.overridesExistingMethod. Here&amp;amp;apos;s the offending code:
            for (int i = 0; i &amp;lt; info.getMethod().getParameterTypes().length; i++) {
                Class type1 = info.getMethod().getParameterTypes()[i];
                Class type2 = methodInfo.getMethod().getParameterTypes()[i];
                if (!type1.equals(type2)) 
{
                    continue;
                }
            }
            // same name, same parameters, then its overrides an existing class
            return info;
If the parameter types don&amp;amp;apos;t match, the continue statement is not going to do what you&amp;amp;apos;d want. The author obviously intended the "continue" to continue with the next methodInfo. Instead, it checks the next parameter and will always return the current methodInfo  if it reaches this point.
Here&amp;amp;apos;s a unit test that exemplifies the issue:
----------------------------------
package biz.firethorn.hostinterface.camel;
import java.lang.reflect.Method;
import junit.framework.Assert;
import junit.framework.TestCase;
import org.apache.camel.CamelContext;
import org.apache.camel.Exchange;
import org.apache.camel.Message;
import org.apache.camel.RuntimeCamelException;
import org.apache.camel.component.bean.AmbiguousMethodCallException;
import org.apache.camel.component.bean.BeanInfo;
import org.apache.camel.component.bean.MethodInvocation;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.impl.DefaultExchange;
import org.apache.camel.impl.DefaultMessage;
public class BeanInfoTest extends TestCase {
	public void test() throws Exception 
{
		
		CamelContext camelContext = new DefaultCamelContext();
		BeanInfo beanInfo = new BeanInfo(camelContext, Bean.class);
		
		Message message = new DefaultMessage();
		message.setBody(new RequestB());
		Exchange exchange = new DefaultExchange(camelContext);
		exchange.setIn(message);
		
		MethodInvocation methodInvocation = beanInfo.createInvocation(new Bean(), exchange);
		Method method = methodInvocation.getMethod();
		
		Assert.assertEquals("doSomething", method.getName());
		
		Assert.assertEquals(RequestB.class, method.getGenericParameterTypes()[0]);
	}
}
class Bean {
	public void doSomething(RequestA request) {	
	}
	public void doSomething(RequestB request) {
	}
}
class RequestA {
	public int i;
}
class RequestB {
	public String s;
}</description>
			<version>2.0-M1</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
		</fixedFiles>
	</bug>
	<bug id="1492" opendate="2009-03-26 18:35:32" fixdate="2009-03-27 09:28:56" resolution="Fixed">
		<buginformation>
			<summary>Allow parementer append for jms bindings with no endpoint</summary>
			<description>See test failures in https://issues.apache.org/activemq/browse/AMQ-2182</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="1498" opendate="2009-03-28 10:49:34" fixdate="2009-03-29 09:36:27" resolution="Fixed">
		<buginformation>
			<summary>CamelContext.getEndpoint - returns null if scheme not defined properly</summary>
			<description>If you for instance forget to add a colon as the scheme name, then Camel cannot find a component and will return null.
This happens typically when you mistype an URI: eg activemq.queue.foo instead of correct activemq:queue.foo</description>
			<version>1.6.0</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.CamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.impl.RouteWithMistypedComponentNameTest.java</file>
			<file type="D">org.apache.camel.spring.EndpointFactoryBean.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContextTest.java</file>
			<file type="M">org.apache.camel.management.CamelChoiceWithManagementTest.java</file>
			<file type="D">org.apache.camel.spring.CamelTemplateFactoryBean.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.ContextTestSupport.java</file>
			<file type="M">org.apache.camel.ResolveEndpointFailedException.java</file>
			<file type="M">org.apache.camel.spring.handler.CamelNamespaceHandler.java</file>
			<file type="D">org.apache.camel.spring.factory.BeanEndpointFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="1505" opendate="2009-03-31 09:57:55" fixdate="2009-04-01 04:48:27" resolution="Fixed">
		<buginformation>
			<summary>deploy the CamelContext with velocity endpoint into the Servicemix 4.0 will get the  NoClassDefFoundError</summary>
			<description>[trace] ***********************************************************
********
[debug] Starting Apache Velocity v1.5 (compiled: 2007-02-22 08:52:29)
[trace] RuntimeInstance initializing.
[debug] Default Properties File: org\apache\velocity\runtime\defaults\velocity.
properties
[debug] Trying to use logger class org.apache.velocity.runtime.log.Log4JLogChut
e
[debug] Couldn&amp;amp;apos;t find class org.apache.velocity.runtime.log.Log4JLogChute or ne
cessary supporting classes in classpath.
org/apache/log4j/Layout
java.lang.NoClassDefFoundError: org/apache/log4j/Layout
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Class.java:164)
        at org.apache.velocity.util.ClassUtils.getClass(ClassUtils.java:76)
        at org.apache.velocity.util.ClassUtils.getNewInstance(ClassUtils.java:95
)
        at org.apache.velocity.runtime.log.LogManager.createLogChute(LogManager.
java:147)
We can get around this issue by replacing the org.apache.velocity.runtime.log.Log4JLogChute with
org.apache.velocity.runtime.log.Log4JLogChute, and also need to update the Servicemix Velocity bundle to 1.6.</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.velocity.VelocityEndpoint.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="depends upon">261</link>
		</links>
	</bug>
	<bug id="1508" opendate="2009-04-01 11:25:05" fixdate="2009-04-01 13:20:39" resolution="Fixed">
		<buginformation>
			<summary>TypeConverter - Can find Object type converter even though there is a more specialized converter to use</summary>
			<description>The code travels down the super to fast. And the code that checks for Object and inherited types in the end of the lookup code should be run as last resort.</description>
			<version>1.6.0</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.converter.DefaultTypeConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1506" opendate="2009-03-31 21:18:17" fixdate="2009-04-02 07:43:19" resolution="Fixed">
		<buginformation>
			<summary>Recursively scan multipart nodes of an email for attachments - not just top level nodes</summary>
			<description>The current code will only scan the top level of a multipart message. This misses any attachments that are under another node.
All unit tests still run for me after applying this patch.</description>
			<version>2.0.0</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailMessage.java</file>
			<file type="M">org.apache.camel.component.mail.MailConfiguration.java</file>
			<file type="M">org.apache.camel.component.mail.MailUtils.java</file>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="depends upon">1507</link>
		</links>
	</bug>
	<bug id="1504" opendate="2009-03-31 08:47:08" fixdate="2009-04-02 16:16:23" resolution="Fixed">
		<buginformation>
			<summary>HTTP_URI and HTTP_PATH message headers not concatenated when sending messages to http endpoint</summary>
			<description>When a message is sent to an http endpoint, the path specified in the HTTP_PATH header is ignored.
In the HttpProducer.createMethod() of the camel-http component, the URI is taken from the HTTP_URI header or the endpoint, but the HTTP_PATH header is not concatenated. 
See also the discussion on the mailing list: http://www.nabble.com/Setting-a-path-in-message-header-with-Camel-http-2.0M1-td22781504.html</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1496" opendate="2009-03-27 16:01:46" fixdate="2009-04-03 06:41:49" resolution="Fixed">
		<buginformation>
			<summary>Using request parameters in the feed url will result in ResolveEndpointFailedException for Unknown parameters</summary>
			<description>While configuring a route like:
&amp;lt;route&amp;gt;
 &amp;lt;from uri="atom://http://somehost/?feed=1234567"/&amp;gt;
 &amp;lt;to uri="seda:feeds"/&amp;gt;
&amp;lt;/route&amp;gt;
camel throws an exception with:
Failed to resolve endpoint due to: org.apache.camel.ResolveEndpointFailedException: There are 1 parameters that couldn&amp;amp;apos;t be set on the endpoint</description>
			<version>2.0-M1</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.atom.AtomComponent.java</file>
			<file type="M">org.apache.camel.component.feed.FeedEndpoint.java</file>
			<file type="M">org.apache.camel.component.atom.AtomProducerTest.java</file>
			<file type="M">org.apache.camel.component.rss.RssComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="1511" opendate="2009-04-02 04:56:30" fixdate="2009-04-04 17:41:25" resolution="Fixed">
		<buginformation>
			<summary>TransactionErrorHandler and DefaultErrorHandler - support onException</summary>
			<description>The onException is a great feature and we should try to see if we can get it supported in the TransactionErrorHandler and DefaultErrorHandler as well.
</description>
			<version>1.5.0</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.spi.TransactionErrorHandlerBuilder.java</file>
			<file type="M">org.apache.camel.spring.SpringRouteBuilder.java</file>
			<file type="M">org.apache.camel.component.jms.tx.AbstractTransactionTest.java</file>
			<file type="M">org.apache.camel.spring.spi.SpringTransactionPolicy.java</file>
			<file type="D">org.apache.camel.spring.spi.TransactionInterceptor.java</file>
			<file type="M">org.apache.camel.component.jms.TransactedJmsRouteTest.java</file>
			<file type="M">org.apache.camel.management.InstrumentationErrorHandlerWrappingStrategy.java</file>
			<file type="M">org.apache.camel.spi.Policy.java</file>
			<file type="M">org.apache.camel.impl.NoPolicy.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilderRef.java</file>
			<file type="M">org.apache.camel.impl.DefaultErrorHandlerWrappingStrategy.java</file>
			<file type="M">org.apache.camel.model.PolicyDefinition.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilderSupport.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannelExceptionCausePropagatedTest.java</file>
			<file type="M">org.apache.camel.builder.DeadLetterChannelBuilder.java</file>
			<file type="M">org.apache.camel.processor.DefaultErrorHandler.java</file>
			<file type="M">org.apache.camel.builder.DefaultErrorHandlerBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1216</link>
			<link type="dependent" description="is depended upon by">1475</link>
		</links>
	</bug>
	<bug id="1216" opendate="2009-01-03 08:07:22" fixdate="2009-04-06 09:57:28" resolution="Duplicate">
		<buginformation>
			<summary>DeadLetterChannel - allow it to be enabled for transacted exchanges as well</summary>
			<description>See nabble:
http://www.nabble.com/Please-keep-this-unintended-feature-in-camel-and-other-requests-td21025627s22882.html</description>
			<version>1.5.0</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.spi.TransactionErrorHandlerBuilder.java</file>
			<file type="M">org.apache.camel.spring.SpringRouteBuilder.java</file>
			<file type="M">org.apache.camel.component.jms.tx.AbstractTransactionTest.java</file>
			<file type="M">org.apache.camel.spring.spi.SpringTransactionPolicy.java</file>
			<file type="D">org.apache.camel.spring.spi.TransactionInterceptor.java</file>
			<file type="M">org.apache.camel.component.jms.TransactedJmsRouteTest.java</file>
			<file type="M">org.apache.camel.management.InstrumentationErrorHandlerWrappingStrategy.java</file>
			<file type="M">org.apache.camel.spi.Policy.java</file>
			<file type="M">org.apache.camel.impl.NoPolicy.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilderRef.java</file>
			<file type="M">org.apache.camel.impl.DefaultErrorHandlerWrappingStrategy.java</file>
			<file type="M">org.apache.camel.model.PolicyDefinition.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilderSupport.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannelExceptionCausePropagatedTest.java</file>
			<file type="M">org.apache.camel.builder.DeadLetterChannelBuilder.java</file>
			<file type="M">org.apache.camel.processor.DefaultErrorHandler.java</file>
			<file type="M">org.apache.camel.builder.DefaultErrorHandlerBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1511</link>
			<link type="dependent" description="depends upon">123</link>
		</links>
	</bug>
	<bug id="1519" opendate="2009-04-06 15:52:44" fixdate="2009-04-06 17:16:33" resolution="Fixed">
		<buginformation>
			<summary>Spring DSL - Transacted routes with policy seems to not work - same route in Java DSL works </summary>
			<description>In 1.x see rev 762400 where I added an unit test demonstrating the bug
The TX interceptor gets applied wrong with Spring DSL versus Java DSL.</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="1509" opendate="2009-04-01 17:12:45" fixdate="2009-04-08 09:23:01" resolution="Fixed">
		<buginformation>
			<summary>DefaultCamelContext.isStarting returns incorrect status</summary>
			<description>DefaultCamelContext.isStarting returns true while it actually not started.
So the following groovy test case fails:
test.groovy
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.language.groovy.GroovyRouteBuilder;

class Foo {
    def name
    def data
    void run(data) {
        println "[${name}] got ${data}"
        this.data = data
    }
}

public class MyRoute extends GroovyRouteBuilder {
    def bean = new Foo(name: "bean")
    protected void configure() {
        from("direct:start").bean(bean, "run")
    }
}

camelCtx = new DefaultCamelContext()
route = new MyRoute()
camelCtx.addRoutes(route);

Thread.start {
    camelCtx.start();
}

while (camelCtx.isStarting()) {
    Thread.sleep(1000)
}

camelCtx.createProducerTemplate().sendBody("direct:start", "data")
if (!route.bean.data) {
    println "FAILED: no data has been received!"
} else {
    println "PASSED"
}

camelCtx.stop();


Note, after moving of  

camelCtx.addRoutes(route)


 after

Thread.start {
    camelCtx.start();
}


the test passes.
Also the program does not finish after camelCtx.stop();</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.ServiceStatus.java</file>
			<file type="M">org.apache.camel.processor.RoutePerformanceTest.java</file>
			<file type="M">org.apache.camel.impl.ServiceSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="1513" opendate="2009-04-02 14:42:51" fixdate="2009-04-09 08:17:15" resolution="Fixed">
		<buginformation>
			<summary>camel-csv : mutliple messages lead to repeated values</summary>
			<description>I have this config : 

&amp;lt;route&amp;gt;
  &amp;lt;from uri="direct:msgIn"/&amp;gt;
  &amp;lt;marshal&amp;gt;&amp;lt;csv /&amp;gt;&amp;lt;/marshal&amp;gt;
  &amp;lt;to uri="file://msgs?fileName=messages.csv" /&amp;gt;
&amp;lt;/route&amp;gt;


I send Map objects with this :


ProducerTemplate template = context.createProducerTemplate();

Map msg1 = new HashMap();
msg1.put("A", 1);
msg1.put("B", 1);
Map msg2 = new HashMap();
msg2.put("A", 2);
msg2.put("B", 2);
template.sendBody("direct:msgIn", msg1);
template.sendBody("direct:msgIn", msg2);


This produces the following result :

1,1
2,2,2,2


instead of 

1,1
2,2


The more messages are pumped into the CSV marshaller, the more the values are repeated. This is because the marshal method in CsvDataFormat keeps adding columns to the config even if they are already present :
CsvDataFormat.java
  ........
        CSVConfig conf = getConfig();
        // lets add fields
        Set set = map.keySet();
        for (Object value : set) {
            if (value != null) {
                String text = value.toString();
                CSVField field = new CSVField(text);
                conf.addField(field);
            }
        }
        CSVWriter writer = new CSVWriter(conf);

  .......


I think the marshal method should perform something like

if (config == null) {
    config = createConfig();
    // lets add fields
    Set set = map.keySet();
    for (Object value : set) {
        if (value != null) {
     ..............
}


</description>
			<version>2.0-M1</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.csv.CsvDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.csv.CsvRouteTest.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.http.HttpEndpoint.java</file>
			<file type="M">org.apache.camel.component.http.HttpComponent.java</file>
			<file type="M">org.apache.camel.component.jetty.JettySimplifiedHandle404Test.java</file>
		</fixedFiles>
	</bug>
	<bug id="1525" opendate="2009-04-09 09:09:54" fixdate="2009-04-10 08:24:02" resolution="Fixed">
		<buginformation>
			<summary>seda component - the exchange copied should not use the UoW from the source</summary>
			<description>The async endpoints such as seda and wireTap should not share the same UnitOfWork as the source.
They are a total new independent exchange and should have their own UnitOfWork.
See nabble
http://www.nabble.com/UnitOfWork-ends-too-soon-with-Seda-endpoints-td22950359.html</description>
			<version>1.6.0</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultExchange.java</file>
			<file type="M">org.apache.camel.processor.WireTapProcessor.java</file>
			<file type="M">org.apache.camel.model.TransactedDefinition.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.processor.interceptor.DefaultTraceFormatter.java</file>
			<file type="M">org.apache.camel.component.seda.CollectionProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1332" opendate="2009-02-10 15:37:13" fixdate="2009-04-15 14:26:13" resolution="Fixed">
		<buginformation>
			<summary>StreamCachingInterceptor can be enabled both as a strategy and as an interceptor -- should only be a strategy</summary>
			<description>Right now, there are two ways of enabling stream caching:

explicitly enable it through the DSL
implicitly enable it through e.g. a Multicast or DeadletterChannel

We should make that a single way of enablement or else document the rationale for the difference properly.</description>
			<version>1.5.0</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyImageFileTest.java</file>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientWithRollbackTest.java</file>
			<file type="M">org.apache.camel.spring.spi.TransactionErrorHandler.java</file>
			<file type="M">org.apache.camel.component.jetty.HttpClientRouteTest.java</file>
			<file type="M">org.apache.camel.util.ProcessorDefinitionHelper.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilderRef.java</file>
			<file type="M">org.apache.camel.spring.spi.SpringTransactionPolicy.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyContentTypeTest.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.impl.RouteService.java</file>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientDataSourceWithOnExceptionTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.processor.interceptor.StreamCachingInterceptorTest.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilderTest.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.spring.xml.SpringXmlRouteBuilderTest.java</file>
			<file type="M">org.apache.camel.spi.InterceptStrategy.java</file>
			<file type="M">org.apache.camel.management.InstrumentationInterceptStrategy.java</file>
			<file type="M">org.apache.camel.processor.interceptor.StreamCaching.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilder.java</file>
			<file type="M">org.apache.camel.processor.interceptor.Tracer.java</file>
			<file type="M">org.apache.camel.management.InstrumentationErrorHandlerWrappingStrategy.java</file>
			<file type="M">org.apache.camel.spring.interceptor.StreamCachingInterceptorTest.java</file>
			<file type="M">org.apache.camel.processor.DefaultErrorHandler.java</file>
			<file type="M">org.apache.camel.processor.StreamSourceContentBasedRouterTest.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerTest.java</file>
			<file type="M">org.apache.camel.processor.interceptor.Delayer.java</file>
			<file type="M">org.apache.camel.model.config.PropertyDefinition.java</file>
			<file type="M">org.apache.camel.processor.ResequencerTest.java</file>
			<file type="M">org.apache.camel.issues.TwoTimerWithJMXIssue.java</file>
			<file type="M">org.apache.camel.model.config.PropertiesDefinition.java</file>
			<file type="M">org.apache.camel.processor.interceptor.Debugger.java</file>
			<file type="M">org.apache.camel.processor.ChoiceNoErrorHandlerTest.java</file>
			<file type="M">org.apache.camel.processor.interceptor.StreamCachingInterceptor.java</file>
			<file type="M">org.apache.camel.model.RouteDefinition.java</file>
			<file type="M">org.apache.camel.builder.DeadLetterChannelBuilder.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannel.java</file>
			<file type="D">org.apache.camel.processor.interceptor.StreamCachingTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1535" opendate="2009-04-16 07:00:46" fixdate="2009-04-16 08:11:35" resolution="Fixed">
		<buginformation>
			<summary>java.lang.Error thrown in mock/dataset assertions causes the async processing to not complete as just catches Exception</summary>
			<description>java.lang.AssertionException extends java.lang.Error
So the mock endpoint should deal with this and catch Throwable instead of Exception when it handles failures.</description>
			<version>2.0-M1</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.TransformProcessor.java</file>
			<file type="M">org.apache.camel.component.mock.MockEndpoint.java</file>
			<file type="M">org.apache.camel.component.dataset.DataSetConsumer.java</file>
			<file type="M">org.apache.camel.component.dataset.DataSetSedaTest.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilderRef.java</file>
			<file type="M">org.apache.camel.component.file.DirectoryCreateIssueTest.java</file>
			<file type="M">org.apache.camel.processor.RoutePerformanceTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1510" opendate="2009-04-02 01:05:12" fixdate="2009-04-16 20:31:33" resolution="Fixed">
		<buginformation>
			<summary>BatchProcessor interrupt has side effects</summary>
			<description>I have noticed that the BatchProcessor class uses the Thread class interrupt method to wake the run loop from sleeping within the enqueueExchange method.
The unfortunate side effect of this is that if the run loop is in the middle of processing exchanges, and the processing involves something slow like establishing a JMS connection over SSL or queuing to an asynchronous processor, then the processing can become interrupted. The consequence of this side effect is that the batch sender thread rarely gets the opportunity to complete properly and exceptions regarding the interrupt are thrown.
This all became apparent during some performance testing that resulted in continuously adding exchanges to the aggregator, the threshold becoming reached, and then trying to enqueue the aggregated result to a JMS queue.
If my analysis of the BatchProcessor is correct then I would recommend finer grained concurrency controls being used instead of relying upon interrupting a thread. Perhaps something like the following (untested) re-write of the sender:

    private class BatchSender extends Thread {
        private Queue&amp;lt;Exchange&amp;gt; queue;
        private boolean exchangeQueued = false;
        private Lock queueMutex = new ReentrantLock();
        private Condition queueCondition = queueMutex.newCondition();

        public BatchSender() {
            super("Batch Sender");
            this.queue = new LinkedList&amp;lt;Exchange&amp;gt;();
        }

        public void cancel() {
            interrupt();
        }

        private void drainQueueTo(Collection&amp;lt;Exchange&amp;gt; collection, int batchSize) {
            for (int i = 0; i &amp;lt; batchSize; ++i) {
                Exchange e = queue.poll();
                if (e != null) {
                    collection.add(e);
                } else {
                    break;
                }
            }
        }

        public void enqueueExchange(Exchange exchange) {
            queueMutex.lock();
            try {
                queue.add(exchange);
                exchangeQueued = true;
                queueCondition.signal();
            } finally {
                queueMutex.unlock();
            }
        }

        @Override
        public void run() {
            queueMutex.lock();
            try {
                do {
                    try {
                        if (!exchangeQueued) {
                            queueCondition.await(batchTimeout,
                                    TimeUnit.MILLISECONDS);
                            if (!exchangeQueued) {
                                drainQueueTo(collection, batchSize);
                            }
                        }

                        if (exchangeQueued) {
                            exchangeQueued = false;
                            queueMutex.unlock();
                            try {
                                while (isInBatchCompleted(queue.size())) {
                                    queueMutex.lock();
                                    try {
                                        drainQueueTo(collection, batchSize);
                                    } finally {
                                        queueMutex.unlock();
                                    }
                                }

                                if (!isOutBatchCompleted()) {
                                    continue;
                                }
                            } finally {
                                queueMutex.lock();
                            }

                        }

                        queueMutex.unlock();
                        try {
                            try {
                                sendExchanges();
                            } catch (Exception e) {
                                getExceptionHandler().handleException(e);
                            }
                        } finally {
                            queueMutex.lock();
                        }
                    } catch (InterruptedException e) {
                        break;
                    }
                } while (true);
            } finally {
                queueMutex.unlock();
            }
        }

        private void sendExchanges() throws Exception {
            Iterator&amp;lt;Exchange&amp;gt; iter = collection.iterator();
            while (iter.hasNext()) {
                Exchange exchange = iter.next();
                iter.remove();
                processExchange(exchange);
            }
        }
    }


I have replaced the concurrent queue with a regular linked list and mutexed its access. In addition any queuing of exchanges is noted. This should result in less locking.
The main change though is that queuing an exchange does not interrupt the batch sender&amp;amp;apos;s current activity.
I hope that this sample is useful.</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.BatchProcessor.java</file>
			<file type="M">org.apache.camel.processor.StreamResequencer.java</file>
			<file type="M">org.apache.camel.processor.StreamResequencerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1475" opendate="2009-03-22 11:45:29" fixdate="2009-04-17 09:33:45" resolution="Fixed">
		<buginformation>
			<summary>Easier transacted configuration of routes</summary>
			<description>See TransactionalClientWithRollbackTest in camel-spring
The .policy(required) is needed in the routes even though we have a global transaction error handler with a default policy set:

                 errorHandler(transactionErrorHandler(required));


So Camel should fallback and use the global policy if the route itself does not have a policy defined.</description>
			<version>1.6.0</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.tx.QueueToProcessorTransactionTest.java</file>
			<file type="M">org.apache.camel.spring.spi.TransactionErrorHandler.java</file>
			<file type="M">org.apache.camel.spring.config.DummyErrorHandlerBuilder.java</file>
			<file type="M">org.apache.camel.spring.spi.SpringTransactionPolicy.java</file>
			<file type="M">org.apache.camel.spring.spi.TransactedRuntimeCamelException.java</file>
			<file type="M">org.apache.camel.component.jms.tx.QueueToQueueRequestReplyTransactionTest.java</file>
			<file type="M">org.apache.camel.component.jms.TransactedJmsRouteTest.java</file>
			<file type="M">org.apache.camel.processor.ErrorHandlerSupportTest.java</file>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientDataSourceNotTransactedTest.java</file>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientWithRollbackTest.java</file>
			<file type="M">org.apache.camel.spring.spi.TransactionErrorHandlerBuilder.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilderRef.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilder.java</file>
			<file type="M">org.apache.camel.builder.DefaultErrorHandlerBuilder.java</file>
			<file type="M">org.apache.camel.builder.LoggingErrorHandlerBuilder.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilderSupport.java</file>
			<file type="M">org.apache.camel.builder.NoErrorHandlerBuilder.java</file>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientDataSourceTest.java</file>
			<file type="M">org.apache.camel.processor.ErrorHandlerSupport.java</file>
			<file type="M">org.apache.camel.processor.DefaultErrorHandler.java</file>
			<file type="M">org.apache.camel.component.jms.tx.QueueToQueueTransactionTest.java</file>
			<file type="M">org.apache.camel.processor.LoggingErrorHandler.java</file>
			<file type="M">org.apache.camel.model.TransactedDefinition.java</file>
			<file type="M">org.apache.camel.spring.SpringRouteBuilder.java</file>
			<file type="M">org.apache.camel.spring.interceptor.route.DataSourceSpringRouteBuilder.java</file>
			<file type="M">org.apache.camel.builder.DeadLetterChannelBuilder.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannel.java</file>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientDataSourceWithOnExceptionTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultEndpoint.java</file>
			<file type="M">org.apache.camel.model.UnmarshalDefinition.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.processor.Interceptor.java</file>
			<file type="M">org.apache.camel.processor.DelegateProcessor.java</file>
			<file type="M">org.apache.camel.processor.HandleFaultProcessor.java</file>
			<file type="M">org.apache.camel.model.PolicyDefinition.java</file>
			<file type="M">org.apache.camel.model.XmlTestSupport.java</file>
			<file type="M">org.apache.camel.BodyAndHeaderConvertTest.java</file>
			<file type="M">org.apache.camel.management.InstrumentationProcessor.java</file>
			<file type="M">org.apache.camel.impl.ProducerTest.java</file>
			<file type="M">org.apache.camel.model.dataformat.DataFormatsDefinition.java</file>
			<file type="M">org.apache.camel.impl.DefaultRouteContext.java</file>
			<file type="M">org.apache.camel.spi.InterceptStrategy.java</file>
			<file type="M">org.apache.camel.processor.resequencer.ResequencerRunner.java</file>
			<file type="M">org.apache.camel.processor.Delayer.java</file>
			<file type="M">org.apache.camel.model.MarshalDefinition.java</file>
			<file type="M">org.apache.camel.management.InstrumentationLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.processor.interceptor.StreamCachingInterceptor.java</file>
			<file type="M">org.apache.camel.builder.InterceptorBuilderTest.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.spring.spi.ApplicationContextRegistry.java</file>
			<file type="M">org.apache.camel.impl.JndiRegistry.java</file>
			<file type="M">org.apache.camel.spi.RouteContext.java</file>
			<file type="M">org.apache.camel.spi.Registry.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="depends upon">1511</link>
		</links>
	</bug>
	<bug id="974" opendate="2008-10-11 00:23:39" fixdate="2009-04-18 10:15:54" resolution="Fixed">
		<buginformation>
			<summary>DataSetSedaTest intermittent test failure</summary>
			<description>I get this kind of failures in the DataSetSedaTest now and then:
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 4.731 sec &amp;lt;&amp;lt;&amp;lt; FAILURE!
test(org.apache.camel.component.dataset.DataSetSedaTest)  Time elapsed: 4.49 sec  &amp;lt;&amp;lt;&amp;lt; ERROR!
java.lang.AssertionError: dataset:foo Failed due to caught exception: java.lang.AssertionError: Header: camelDataSetIndex does not match. Expected: 33 but was: 32 on Exchange[Message: &amp;lt;hello&amp;gt;world!&amp;lt;/hello&amp;gt;] with headers: 
{camelDataSetIndex=32}
        at org.apache.camel.component.mock.MockEndpoint.fail(MockEndpoint.java:712)
        at org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied(MockEndpoint.java:255)
        at org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied(MockEndpoint.java:214)
        at org.apache.camel.component.mock.MockEndpoint.assertIsSatisfied(MockEndpoint.java:141)
        at org.apache.camel.ContextTestSupport.assertMockEndpointsSatisfied(ContextTestSupport.java:283)
        at org.apache.camel.component.dataset.DataSetSedaTest.test(DataSetSedaTest.java:35)
I am not sure yet if it&amp;amp;apos;s just a test issue (quite probable) or there&amp;amp;apos;s a more serious underlying issue.  If anybody else experienced this please add a comment.</description>
			<version>1.4.0</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.dataset.DataSetConsumer.java</file>
			<file type="M">org.apache.camel.component.mock.MockEndpoint.java</file>
			<file type="M">org.apache.camel.component.dataset.DataSetSedaTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1524" opendate="2009-04-07 19:29:42" fixdate="2009-04-18 10:29:10" resolution="Fixed">
		<buginformation>
			<summary>camel-irc URI parsing is flawed</summary>
			<description>the example URI for the camel-irc component (see http://camel.apache.org/irc.html) does not work.  Further, the current URI parsing code is flawed and subject to NPE&amp;amp;apos;s.
In IrcConfiguration.configure(URI uri) (see https://svn.apache.org/repos/asf/camel/branches/camel-1.x/components/camel-irc/src/main/java/org/apache/camel/component/irc/IrcConfiguration.java) the code attempts to parse a channel name as a path.  Because the &amp;amp;apos;#&amp;amp;apos; char is a fragment marker in a URI, the path (in the documented example) is zero length.
The following URI works with the current code implementation (note the required &amp;amp;apos;//&amp;amp;apos; and html-escaped &amp;amp;apos;#&amp;amp;apos; char):

irc://nick@server.org/%23channel
</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.irc.IrcRouteTest.java</file>
			<file type="M">org.apache.camel.component.irc.IrcConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="1516" opendate="2009-04-03 10:31:32" fixdate="2009-04-19 02:13:20" resolution="Fixed">
		<buginformation>
			<summary>NPE of camel-restlet </summary>
			<description>I&amp;amp;apos;m getting a NullPointerException in Restlet when I use the Restlet component as a client.  I set up a Route that&amp;amp;apos;s something like:
from(endpointUri).setExchangePattern(ExchangePattern.InOut)
    .to("restlet:http://localhost:9000/whatever")
    .process(new SomeProcessor());
When I hit this route, I gett a NullPointerException at com.noelios.restlet.http.HttpConverter.getLogger().  Ultimately, it&amp;amp;apos;s trying to warn me about some headers that Restlet is going to ignore.  I see that when the RestletProducer creates the Restlet Client, it doesn&amp;amp;apos;t set a context (which is the object that&amp;amp;apos;s null, causing the NPE).  If I simply hack in:
client.setContext(new Context());
after the client is instantiated, it works.</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.RestletProducer.java</file>
			<file type="M">org.apache.camel.component.restlet.RestletResponseTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1548" opendate="2009-04-20 12:14:54" fixdate="2009-04-21 11:14:53" resolution="Fixed">
		<buginformation>
			<summary>ErrorHandler to be wrapped at every node incl children</summary>
			<description></description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.discovery.JmsDiscoveryTest.java</file>
			<file type="D">org.apache.camel.management.InstrumentationErrorHandlerWrappingStrategy.java</file>
			<file type="M">org.apache.camel.management.InstrumentationLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.spring.interceptor.DelayerInterceptorTest.java</file>
			<file type="M">org.apache.camel.processor.FaultRouteTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContextTest.java</file>
			<file type="M">org.apache.camel.management.InstrumentationInterceptStrategy.java</file>
			<file type="M">org.apache.camel.component.jms.tx.AbstractTransactionTest.java</file>
			<file type="M">org.apache.camel.processor.FaultRetryRouteTest.java</file>
			<file type="M">org.apache.camel.processor.RollbackTest.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilderTest.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerTest.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.impl.DefaultErrorHandlerWrappingStrategy.java</file>
			<file type="M">org.apache.camel.processor.RoutePerformanceTest.java</file>
			<file type="M">org.apache.camel.issues.BelasThreadErrorHandlerIssue901Test.java</file>
			<file type="D">org.apache.camel.processor.interceptor.InterceptAlterMessageBeforeRedeliveryTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.processor.HandleFaultProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="1544" opendate="2009-04-20 03:00:45" fixdate="2009-04-23 06:28:23" resolution="Fixed">
		<buginformation>
			<summary>Multiple consumers getting created in custom endpoint</summary>
			<description>If you restart the camel context ,you will get into trouble of creating multiple consumers.
Here is the mail thread with talks about it.
http://www.nabble.com/Multiple-consumers-getting-created-in-custom-endpoint-td22928845.html#a22928845</description>
			<version>1.4.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContextTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1565" opendate="2009-04-24 12:32:39" fixdate="2009-04-24 16:10:16" resolution="Fixed">
		<buginformation>
			<summary>Make camel-validation thread-safe</summary>
			<description>When a flow which contains a camel-validation endpoint is started, the XSD schemas are not loaded until the first request comes in and the camel-validation endpoint is first hit.
If two requests come in simultaneously, the initialization will be performed twice, at the same time. It seems that SchemaFactory is not thread-safe, so this results in the following exception:
10:38:20,860 | ERROR - org.apache.camel.processor.DeadLetterChannel - org.apache.camel.processor.Logger - Failed delivery for exchangeId: ID-ATOS-B624
E47AF0/3211-1240562892751/0-11. On delivery attempt: 0 caught: org.xml.sax.SAXException: FWK005 parse may not be called while parsing.
org.xml.sax.SAXException: FWK005 parse may not be called while parsing.
        at com.sun.org.apache.xerces.internal.jaxp.validation.Util.toSAXException(Util.java:62)
        at com.sun.org.apache.xerces.internal.jaxp.validation.XMLSchemaFactory.newSchema(XMLSchemaFactory.java:214)
        at javax.xml.validation.SchemaFactory.newSchema(SchemaFactory.java:594)
        at org.apache.camel.processor.validation.ValidatingProcessor.createSchema(ValidatingProcessor.java:204)
        at org.apache.camel.processor.validation.ValidatingProcessor.getSchema(ValidatingProcessor.java:118)
        at org.apache.camel.processor.validation.ValidatingProcessor.process(ValidatingProcessor.java:54)
        at org.apache.camel.impl.ProcessorEndpoint.onExchange(ProcessorEndpoint.java:92)
        at org.apache.camel.impl.ProcessorEndpoint$1.process(ProcessorEndpoint.java:66)
        at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsyncProcessorBridge.process(AsyncProcessorTypeConverter.java:43) 
.....
For more info: http://www.nabble.com/Concurrency-Issue-with-camel-validation-td23213294.html
Is it possible to backport the fix to 1.4?</description>
			<version>1.4.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.validator.ValidatorComponent.java</file>
			<file type="M">org.apache.camel.processor.validation.ValidatingProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="1568" opendate="2009-04-27 09:43:33" fixdate="2009-04-28 05:00:15" resolution="Fixed">
		<buginformation>
			<summary>Converting from stream/reader to string changes line breaks other than "\n"</summary>
			<description>The IOConverter#toString(Reader/Stream) copies the input data line by line. A line is considered to be terminated by any one of a line feed (&amp;amp;apos;\n&amp;amp;apos;), a carriage return (&amp;amp;apos;\r&amp;amp;apos;), or a carriage return followed immediately by a linefeed. Unfortunately, the lines are always concatenated with "\n", so that HL7 messages (which use "\r") become unusable after conversion.
Also see http://www.nabble.com/HL7-messages-become-unusable-after-convertBodyTo%28String.class%29-td23219748.html</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.IOConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1566" opendate="2009-04-24 15:56:23" fixdate="2009-04-29 20:11:43" resolution="Fixed">
		<buginformation>
			<summary>HL7/MLLP receivers fails for long HL7 messages</summary>
			<description>Long HL7 messages are split up into several exchanges,
see http://www.nabble.com/HL7-ProtocolCodec-truncates-long-HL7-messages-td23219074.html for more details</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.hl7.HL7MLLPCodecLongTest.java</file>
			<file type="M">org.apache.camel.component.hl7.HL7MLLPCodecStandAndEndBytesTest.java</file>
			<file type="M">org.apache.camel.component.hl7.HL7MLLPCodecTest.java</file>
			<file type="M">org.apache.camel.component.hl7.HL7MLLPCodecPlainStringTest.java</file>
			<file type="M">org.apache.camel.component.hl7.HL7MLLPCodec.java</file>
			<file type="M">org.apache.camel.component.hl7.HL7RouteTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1547" opendate="2009-04-20 08:16:30" fixdate="2009-04-30 08:22:45" resolution="Fixed">
		<buginformation>
			<summary>Delayer and StreamCaching will not be exculded if the CamelContext is restarted</summary>
			<description>The InterceptStrategy of Delayer and StreamCaching can&amp;amp;apos;t tell if the camelContext&amp;amp;apos;s InterceptStrategies has the instance of Delayer or StreamCaching.
So the  InterceptStrategy of Delayer and StreamCaching  will be added to the CamelContext&amp;amp;apos;s InterceptStrategies, when the CamelContext  is restarted.</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.processor.interceptor.Delayer.java</file>
			<file type="M">org.apache.camel.processor.interceptor.StreamCaching.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContextTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1583" opendate="2009-05-02 10:20:11" fixdate="2009-05-04 14:05:00" resolution="Fixed">
		<buginformation>
			<summary>ldap component is not thread safe</summary>
			<description>JNDI context objects are not thread-safe. The LDAP component shares a directory context across all threads that use the component. This is not safe.
In addition the LDAP component will attempt to establish a connection on instantiation of the component, and not when the component is required to process requests. If the LDAP server is not ready e.g. temporarily unavailable then the entire Camel application will stop.
JNDI directory contexts should be established when a consuming thread needs it and should be released when the thread is finished with the component i.e.:

ctx = new InitialDirContext(env);
try {
  ...
} finally {
  ctx.close();
}


The above will release the connection with the LDAP server as soon as possible. The existing component relies on JNDI to release the socket in its own time (several seconds later).</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.ldap.LdapProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1585" opendate="2009-05-05 19:52:33" fixdate="2009-05-06 06:59:34" resolution="Fixed">
		<buginformation>
			<summary>SFTP GenericFileProducer.createFileName produces OS normalized file name, that doesn&amp;apos;t work with SFTP</summary>
			<description>The use of File.separator and FileUtil.normalizePath in GenericFileProducer.createFileName produce a OS normalized file name, that doesn&amp;amp;apos;t work with SFTP
e.g. outboundout_20090501_091940_ACC.txt which will not work produce a file called outboundout_20090501_091940_ACC.txt
The proper name should be outbound/out_20090501_091940_ACC.txt</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileProducer.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileProducer.java</file>
			<file type="M">org.apache.camel.model.RoutesDefinition.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.model.InterceptSendToEndpointDefinition.java</file>
			<file type="M">org.apache.camel.processor.DefaultChannel.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilder.java</file>
			<file type="M">org.apache.camel.model.InterceptFromDefinition.java</file>
			<file type="M">org.apache.camel.util.EndpointHelper.java</file>
			<file type="M">org.apache.camel.processor.Pipeline.java</file>
		</fixedFiles>
	</bug>
	<bug id="1586" opendate="2009-05-06 03:47:30" fixdate="2009-05-06 07:00:26" resolution="Fixed">
		<buginformation>
			<summary>camel-cxf producer loses the content-type </summary>
			<description>camel-cxf doesn&amp;amp;apos;t put the Protocol-Header into the camel message header, so we lost the content-type message.
Here is the mail thread for the discussion.
http://www.nabble.com/camel-cxf-content-type-response-header-tt23370337.html</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfRawMessageRouterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfHeaderFilterStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="1590" opendate="2009-05-07 15:42:44" fixdate="2009-05-07 15:43:19" resolution="Fixed">
		<buginformation>
			<summary>camel-test.jar - jndi.properties is required, should be optional</summary>
			<description>See nabble:
http://www.nabble.com/Unit-Tests-without-jndi.properties-td23428533s22882.html</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultExchange.java</file>
			<file type="M">org.apache.camel.processor.AsyncProcessor.java</file>
			<file type="D">org.apache.camel.ExchangeProperty.java</file>
			<file type="D">org.apache.camel.ExchangePropertyTest.java</file>
			<file type="M">org.apache.camel.test.CamelTestSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="1609" opendate="2009-05-13 11:47:13" fixdate="2009-05-13 15:14:21" resolution="Fixed">
		<buginformation>
			<summary>Content type for HTTP not being send in header</summary>
			<description>I use the following route:
		final	String	spurl = protocols.get(0).getEpUrl();
			cc.addRoutes(new RouteBuilder()
			{
				public	void	configure()
				{
					from("direct:say")
					.setHeader(HttpConstants.HTTP_CONTENT_TYPE, 
							constant("application/octet-stream"))
					.to(spurl);
				}
			});
where "spurl" is the servlet URL endpoint. The messages are being sent to the servlet, but the content type in the "doPost(...)" is null.
</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.http.HttpMessage.java</file>
			<file type="M">org.apache.camel.component.http.DefaultHttpBinding.java</file>
			<file type="M">org.apache.camel.component.http.helper.GZIPHelper.java</file>
			<file type="M">org.apache.camel.component.http.RequestEntityConverter.java</file>
			<file type="M">org.apache.camel.component.http.HttpHeaderFilterStrategy.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyContentTypeTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1614" opendate="2009-05-14 07:11:59" fixdate="2009-05-14 08:44:26" resolution="Fixed">
		<buginformation>
			<summary>Warning "Disabling JMSReplyTo as this Exchange is not OUT capable" on false positives in JBossAS5</summary>
			<description>see: http://www.nabble.com/Disabling-JMSReplyTo-as-this-Exchange-is-not-OUT-capable-td23524909s22882.html</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.2, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="123" opendate="2007-08-25 06:58:53" fixdate="2009-05-15 07:55:41" resolution="Duplicate">
		<buginformation>
			<summary>add an &amp;apos;on commit / on rollback&amp;apos; hook so that non-transactional components can do things like delete files when the processing has completed</summary>
			<description>e.g. file / FTP should only delete the file after successful processing has occurred etc</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.impl.DefaultExchange.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1604</link>
			<link type="dependent" description="is depended upon by">1216</link>
		</links>
	</bug>
	<bug id="1604" opendate="2009-05-12 08:29:38" fixdate="2009-05-15 09:02:08" resolution="Fixed">
		<buginformation>
			<summary>UnitOfWork synchronization callbacks - add DSL for easy registering custom processor</summary>
			<description>See nabble:
http://www.nabble.com/-DISCUSS---Camel-2.0---Synchronization-%28UnitOfWork-callbacks%29-and--needed-syntax-DSL-sugar-td23498213s22882.html</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.OnCompletionDefinition.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilder.java</file>
			<file type="M">org.apache.camel.processor.OnCompletionProcessor.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.model.RoutesDefinition.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.PollingConsumerAware.java</file>
			<file type="M">org.apache.camel.spring.handler.CamelNamespaceHandler.java</file>
			<file type="M">org.apache.camel.spring.processor.onexception.SpringOnExceptionFromChoiceUseOriginalBodyTest.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannelHandledPolicyTest.java</file>
			<file type="M">org.apache.camel.processor.OnCompletionTest.java</file>
			<file type="M">org.apache.camel.processor.OnCompletionOnFailureOnlyTest.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.spi.Synchronization.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">123</link>
		</links>
	</bug>
	<bug id="1618" opendate="2009-05-15 09:46:55" fixdate="2009-05-16 13:25:33" resolution="Fixed">
		<buginformation>
			<summary>DSL doesn&amp;apos;t support the bean expression without registry</summary>
			<description>Here is the mail thread of it
[1] http://www.nabble.com/Non-registry-beans-td20088181.html</description>
			<version>1.5.0</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientWithRollbackTest.java</file>
			<file type="M">org.apache.camel.impl.RouteWithMistypedComponentNameTest.java</file>
			<file type="M">org.apache.camel.spring.SpringRouteBuilder.java</file>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientDataSourceTest.java</file>
			<file type="M">org.apache.camel.component.jms.tx.QueueToProcessorTransactionTest.java</file>
			<file type="M">org.apache.camel.builder.BuilderSupport.java</file>
			<file type="M">org.apache.camel.component.jms.tx.QueueToQueueTransactionTest.java</file>
			<file type="M">org.apache.camel.component.jms.tx.QueueToQueueRequestReplyTransactionTest.java</file>
			<file type="M">org.apache.camel.component.jms.TransactedJmsRouteTest.java</file>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientDataSourceWithOnExceptionTest.java</file>
			<file type="M">org.apache.camel.spring.interceptor.route.DataSourceSpringRouteBuilder.java</file>
			<file type="M">org.apache.camel.processor.jpa.JpaIdempotentConsumerTest.java</file>
			<file type="M">org.apache.camel.builder.ExpressionClause.java</file>
			<file type="M">org.apache.camel.processor.ChoiceWhenBeanExpressionTest.java</file>
			<file type="M">org.apache.camel.model.language.MethodCallExpression.java</file>
			<file type="M">org.apache.camel.processor.ChoiceCompoundPredicateTest.java</file>
			<file type="M">org.apache.camel.builder.Builder.java</file>
			<file type="M">org.apache.camel.builder.ExpressionBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1615" opendate="2009-05-14 10:48:29" fixdate="2009-05-16 15:25:03" resolution="Fixed">
		<buginformation>
			<summary>CamelExchangeException implements Serializable but may not be serializable</summary>
			<description>CamelExchangeException implements Serializable (as inheriting from Exception) but has not transient field Exchange.</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.InvalidPayloadException.java</file>
			<file type="M">org.apache.camel.NoSuchPropertyException.java</file>
			<file type="M">org.apache.camel.RuntimeExchangeException.java</file>
			<file type="M">org.apache.camel.CamelExchangeException.java</file>
			<file type="M">org.apache.camel.ExpressionEvaluationException.java</file>
			<file type="M">org.apache.camel.NoSuchEndpointException.java</file>
			<file type="M">org.apache.camel.InvalidPayloadRuntimeException.java</file>
			<file type="M">org.apache.camel.NoSuchHeaderException.java</file>
			<file type="M">org.apache.camel.FailedToCreateConsumerException.java</file>
			<file type="M">org.apache.camel.FailedToCreateProducerException.java</file>
			<file type="M">org.apache.camel.NoTypeConversionAvailableException.java</file>
			<file type="M">org.apache.camel.ExpectedBodyTypeException.java</file>
		</fixedFiles>
	</bug>
	<bug id="1621" opendate="2009-05-16 16:32:26" fixdate="2009-05-16 18:16:03" resolution="Fixed">
		<buginformation>
			<summary>StickyLoadBalancer - Not possible to configure easily from Spring DSL</summary>
			<description>The correlation expression is not easy to set from Spring DSL.</description>
			<version>1.6.1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.loadbalancer.FailOverLoadBalanceStrategy.java</file>
			<file type="D">org.apache.camel.spring.processor.SpringLoadBalanceTest.java</file>
			<file type="M">org.apache.camel.model.loadbalancer.RoundRobinLoadBalanceStrategy.java</file>
			<file type="M">org.apache.camel.model.LoadBalanceDefinition.java</file>
			<file type="M">org.apache.camel.model.loadbalancer.StickyLoadBalanceStrategy.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.model.loadbalancer.TopicLoadBalanceStrategy.java</file>
			<file type="M">org.apache.camel.model.XmlParseTest.java</file>
			<file type="D">org.apache.camel.processor.LoadBalanceTest.java</file>
			<file type="M">org.apache.camel.model.loadbalancer.RandomLoadBalanceStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="1622" opendate="2009-05-18 13:59:37" fixdate="2009-05-18 14:28:22" resolution="Fixed">
		<buginformation>
			<summary>camel-osgi doesn&amp;apos;t support to look up the fallback converter</summary>
			<description>camel-osgi module doesn&amp;amp;apos;t support to lookup the fallback coverter from the active bundles.
And I got the user complain in the support forums
http://fusesource.com/forums/message.jspa?messageID=2787#2787 </description>
			<version>1.6.0</version>
			<fixedVersion>1.6.2, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.itest.osgi.OSGiIntegrationTestSupport.java</file>
			<file type="M">org.apache.camel.osgi.OsgiFactoryFinderResolver.java</file>
			<file type="M">org.apache.camel.osgi.CamelContextFactory.java</file>
			<file type="M">org.apache.camel.spi.FactoryFinderResolver.java</file>
			<file type="M">org.apache.camel.osgi.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="1624" opendate="2009-05-18 16:19:13" fixdate="2009-05-19 06:44:09" resolution="Fixed">
		<buginformation>
			<summary>Subject not correctly set in xmpp message in both chat producers.</summary>
			<description>The code in XmppPrivateChatProducer and XmppGroupChatProducer does not call setSubject() on the org.jivesoftware.smack.packet.Message object.
Setting a subject property on the org.apache.camel.Message object produces a header on the Smack object via its superclass org.jivesoftware.smack.packet.Packet, but that never gets reflected in the Message object because the Message object does not override the setProperty() method on Packet.

private void send(String camelConnectionString) {
		final CamelContext camel = new DefaultCamelContext();
		camel.start();
		Endpoint endpoint = camel.getEndpoint(camelConnectionString);
		Exchange exchange = endpoint.createExchange(ExchangePattern.InOut);
		Producer producer = endpoint.createProducer();
		producer.start();

		// send the message
		Message message = exchange.getIn();
		message.setBody("The message body");
		message.setHeader("subject", "Message subject for filtering.");
		producer.process(exchange);
}


The annoying part about this, is that I am trying to integrate with a receiving system that handles messages using the subject as a key to determine how the message should be handled.</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xmpp.GoogleTalkTest.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="1630" opendate="2009-05-19 13:01:49" fixdate="2009-05-19 14:44:59" resolution="Fixed">
		<buginformation>
			<summary>GenericFileProducer does not work with absolute URLs on Linux</summary>
			<description>I have the following simple configuration :

&amp;lt;route&amp;gt;
    &amp;lt;from uri="file:///home/julien/tests/a?include=.*?\.xml" /&amp;gt;
    &amp;lt;to uri="file:///home/julien/tests/b?fileName=${date:now:yyyy_MM_dd}/${file:onlyname}"/&amp;gt;
&amp;lt;/route&amp;gt;


After putting an input file into /home/julien/tests/a I get the following error:

 
org.apache.camel.component.file.GenericFileOperationFailedException: Cannot store file: /home/julien/tests/b/2009_05_19/160903061200040046.xml
        at org.apache.camel.component.file.FileOperations.storeFile(FileOperations.java:188)
        at org.apache.camel.component.file.GenericFileProducer.writeFile(GenericFileProducer.java:135)
        at org.apache.camel.component.file.GenericFileProducer.processExchange(GenericFileProducer.java:78)
        at org.apache.camel.component.file.GenericFileProducer.process(GenericFileProducer.java:49)
        at org.apache.camel.impl.converter.AsyncProcessorTypeConverter$ProcessorToAsyncProcessorBridge.process(AsyncProcessorTypeConverter.java:43)
        at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:83)
        at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:68)
        at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:195)
        at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:130)
        at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:68)
        at org.apache.camel.processor.interceptor.StreamCachingInterceptor.proceed(StreamCachingInterceptor.java:88)
        at org.apache.camel.processor.interceptor.StreamCachingInterceptor.process(StreamCachingInterceptor.java:83)
        at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:52)
        at org.apache.camel.component.file.GenericFileConsumer.processExchange(GenericFileConsumer.java:157)
        at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:98)
        at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:66)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)
        at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:317)
        at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:150)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:98)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:181)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:205)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
        at java.lang.Thread.run(Thread.java:619)
Caused by: java.io.FileNotFoundException: /home/julien/tests/b/2009_05_19/160903061200040046.xml (No such file or directory)
        at java.io.RandomAccessFile.open(Native Method)
        at java.io.RandomAccessFile.&amp;lt;init&amp;gt;(RandomAccessFile.java:212)
        at org.apache.camel.component.file.FileOperations.prepareOutputFileChannel(FileOperations.java:253)
        at org.apache.camel.component.file.FileOperations.writeFileByFile(FileOperations.java:205)
        at org.apache.camel.component.file.FileOperations.storeFile(FileOperations.java:178)
        ... 24 more


In the meantime, Camel has created a fubar directory /home/julien/tests/b/home/julien/tests/b/2009_05_19 .
I tracked the problem and found it to be cause by the following code section in GenericFileProducer.java


    protected void writeFile(GenericFileExchange&amp;lt;T&amp;gt; exchange, String fileName) throws GenericFileOperationFailedException {
        InputStream payload = exchange.getIn().getBody(InputStream.class);
        try {
            // build directory if auto create is enabled
            if (endpoint.isAutoCreate()) {
                int lastPathIndex = fileName.lastIndexOf(File.separator);
                if (lastPathIndex != -1) {
                    String directory = fileName.substring(0, lastPathIndex);
                    // skip trailing /
                    directory = FileUtil.stripLeadingSeparator(directory);
                    if (!operations.buildDirectory(directory, false)) {
                        log.debug("Cannot build directory [" + directory + "] (could be because of denied permissions)");
                    }
                }
            }
          ....................


Instead of stripping the trailing separator as noted in the comment, the code strips the leading separator...</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFileProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1632" opendate="2009-05-19 15:46:37" fixdate="2009-05-19 16:02:45" resolution="Fixed">
		<buginformation>
			<summary>File component - from endpoint is not set on file consumer</summary>
			<description>So when you later call exchange.getFromEndpoint() it returns null. What it should return is the file/ftp endpoint that it was consumed from.
See nabble:
http://www.nabble.com/Get-The-intercepted-endpoint-when-using-inetrcept%28%29-td23543993s22882.html</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFileExchange.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileExchange.java</file>
			<file type="M">org.apache.camel.component.file.FileEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="1642" opendate="2009-05-24 08:15:24" fixdate="2009-05-24 08:29:54" resolution="Fixed">
		<buginformation>
			<summary>Splitter with streaming - GenericFile is not detected when creating the java.util.Scanner</summary>
			<description>getScanner should recognize GenericFile as type so we can leverage the underlying java.io.File handle.</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.builder.ExpressionBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1646" opendate="2009-05-25 12:08:09" fixdate="2009-05-25 12:16:02" resolution="Fixed">
		<buginformation>
			<summary>camel-restlet - Should be InOut exchange pattern</summary>
			<description>camel-restlet creates exchanges that are inOnly. But they should be InOut.</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.RestletEndpoint.java</file>
			<file type="M">org.apache.camel.component.restlet.RestletBinding.java</file>
			<file type="M">org.apache.camel.component.restlet.DefaultRestletBinding.java</file>
			<file type="M">org.apache.camel.component.restlet.RestletProducer.java</file>
			<file type="M">org.apache.camel.component.restlet.RestletComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="1641" opendate="2009-05-23 08:14:55" fixdate="2009-05-25 13:26:34" resolution="Fixed">
		<buginformation>
			<summary>camel-ftp is not thread safe</summary>
			<description>See nabble for discussion:
http://www.nabble.com/Threadsafety-of-Camel-FTP-td23615932.html
Basically FTPClient should be created as a new instance for each created producer or consumer (like http component does)</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpProducerConcurrentTest.java</file>
			<file type="M">org.apache.camel.component.file.FileComponent.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpOperations.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileProducer.java</file>
			<file type="M">org.apache.camel.component.file.FileEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpComponent.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpComponent.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.FileConsumerMoveExpressionTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1652" opendate="2009-05-27 21:45:28" fixdate="2009-05-28 05:05:31" resolution="Fixed">
		<buginformation>
			<summary>Memory leak in File component when using batch processing</summary>
			<description>See http://www.nabble.com/convertBodyTo-heap-problem-to23743181.html
When using a file endpoint with sorting as start of a route then the files are processed in a batch. In the current implementation this means a List of exchanges is created and given to the batch processing. The list is then traversed and each exchange is processed. This means the list references all exchanges during the whole batch processing. So none of the exchanges can be collected by the garbage collector till the whole batch is fully processed.
The problem really becomes bad when the exchanges are large. For example if you use convertBodyTo(String.class) and the files are large. If you have 100 files with 10 MB each then camel will consume 1 GB of heap. What is even worse is that it seems the processing simply stops when the heap is full. 
I have written a small test that shows the problem and a patch that corrects this problem. I hope this gets into 2.0-M2 as this is a quite serious bug. </description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.ibatis.IBatisPollingConsumer.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
			<file type="M">org.apache.camel.BatchConsumer.java</file>
			<file type="M">org.apache.camel.component.mail.MailConsumer.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1651" opendate="2009-05-27 15:05:04" fixdate="2009-05-28 09:33:51" resolution="Fixed">
		<buginformation>
			<summary>DefaultHttpBinding prevents response streaming</summary>
			<description>http://www.nabble.com/DefaultHttpBinding-prevents-response-streaming-to23742014s22882.html</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyImageFileTest.java</file>
			<file type="M">org.apache.camel.component.http.helper.LoadingByteArrayOutputStream.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyContentTypeTest.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.http.DefaultHttpBinding.java</file>
			<file type="M">org.apache.camel.component.http.HttpConverter.java</file>
			<file type="M">org.apache.camel.component.http.helper.GZIPHelper.java</file>
			<file type="M">org.apache.camel.component.http.HttpConstants.java</file>
			<file type="D">org.apache.camel.component.http.GZIPHelperTest.java</file>
			<file type="M">org.apache.camel.component.http.RequestEntityConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1663" opendate="2009-05-31 10:52:21" fixdate="2009-06-03 12:05:22" resolution="Fixed">
		<buginformation>
			<summary>Spring BeanPostProcessors do not work on beans which are used in Camel route builders </summary>
			<description>Spring PostProcessors stop working for beans which are injected into Camel route builders.  See attached test cases showing processor breaks as soon as injected into a route builder.</description>
			<version>1.5.0</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.interceptor.AnnotatedBookServiceImpl.java</file>
			<file type="D">org.apache.camel.spring.interceptor.TransactionClientWithAnnotatedBeanTest.java</file>
			<file type="M">org.apache.camel.spring.SpringCamelContext.java</file>
			<file type="M">org.apache.camel.component.event.EventRouteTest.java</file>
			<file type="M">org.apache.camel.component.event.EventEndpoint.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.spring.CamelBeanPostProcessor.java</file>
			<file type="M">org.apache.camel.spring.CamelJMXAgentDefinition.java</file>
			<file type="M">org.apache.camel.spring.spi.SpringInjector.java</file>
			<file type="M">org.apache.camel.spring.handler.CamelNamespaceHandler.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="is depended upon by">1601</link>
			<link type="dependent" description="is depended upon by">1636</link>
		</links>
	</bug>
	<bug id="1671" opendate="2009-06-04 23:03:11" fixdate="2009-06-05 02:42:31" resolution="Fixed">
		<buginformation>
			<summary>Incorrect enum name for WaitForTaskToComplete enum</summary>
			<description>The WaitForTaskToComplete  enum has 3 possible values:  Newer, IfReplyExpected, Always.  The first one should be Never, with a "v" as the third letter instead of a "w".</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.vm.VmWaitForTaskNewerTest.java</file>
			<file type="M">org.apache.camel.builder.PredicateBinaryCoerceRouteTest.java</file>
			<file type="M">org.apache.camel.component.seda.SedaWaitForTaskNewerTest.java</file>
			<file type="M">org.apache.camel.processor.async.AsyncRouteNoWaitWithErrorTest.java</file>
			<file type="M">org.apache.camel.WaitForTaskToComplete.java</file>
			<file type="M">org.apache.camel.processor.async.AsyncDefaultErrorHandlerTest.java</file>
			<file type="M">org.apache.camel.processor.async.AsyncRouteNoWaitTest.java</file>
			<file type="M">org.apache.camel.processor.async.AsyncDeadLetterChannelTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1650" opendate="2009-05-27 12:38:36" fixdate="2009-06-07 11:23:29" resolution="Fixed">
		<buginformation>
			<summary>Race condition in IdempotentConsumer</summary>
			<description>A possible possible race condition exists in the IdempotentConsumer implementation:
The code first checks in the MessageIdRepository if the message was already processed. If not then it processes the message and
afterwards adds the id to the repository. (See also http://issues.apache.org/activemq/browse/CAMEL-1451). There is no locking
between the check with "contains" and the insert with "add". So if multiple threads/instances try this in parallel for the same id, then
it might happen that more than one finds the id not yet contained in the repository and the same message is processed multiple
times.
I enclose an extended version of IdempotentConsumerTest which illustrates the problem.
It is important to note that even if the test demonstrates the issue with an MemoryIdempotentRepository a solution should also
address the case of a database based respository in a clustered environment. So this might imply that some locking mechanism on the
database is required.</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.idempotent.IdempotentOnCompletion.java</file>
			<file type="M">org.apache.camel.processor.idempotent.MemoryIdempotentRepository.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
			<file type="M">org.apache.camel.processor.idempotent.IdempotentConsumer.java</file>
			<file type="M">org.apache.camel.model.IdempotentConsumerDefinition.java</file>
			<file type="M">org.apache.camel.processor.idempotent.FileIdempotentRepository.java</file>
			<file type="M">org.apache.camel.spi.IdempotentRepository.java</file>
			<file type="M">org.apache.camel.component.file.FileConsumerIdempotentRefTest.java</file>
			<file type="M">org.apache.camel.processor.idempotent.jpa.JpaMessageIdRepository.java</file>
			<file type="M">org.apache.camel.management.MultiInstanceProcessorTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumerIdempotentRefTest.java</file>
			<file type="M">org.apache.camel.processor.jpa.JpaIdempotentConsumerTest.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="is depended upon by">1679</link>
			<link type="dependent" description="is depended upon by">1680</link>
		</links>
	</bug>
	<bug id="1670" opendate="2009-06-04 22:57:47" fixdate="2009-06-08 07:04:03" resolution="Fixed">
		<buginformation>
			<summary>thread() and File Components</summary>
			<description>I just experimented with adding calls to thread(10) to my route to make it multithreaded.  This definitely speeds up by route, but it keeps throwing java.nio.channels.OverlappingFileLockException  errors and leaving lock files behind it.  The start of my route looks like
from("file:startDirectory?move=endDirectory")
.threads(10)
.bean("myBean", "myMethod")
Afterwards, my route ran successfully but an OverlappingFileLockException was thrown for every file that was read and all the lock files were left in my source directory.</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.stress.FileAsyncStressTest.java</file>
			<file type="M">org.apache.camel.component.file.strategy.MarkerFileExclusiveReadLockStrategy.java</file>
			<file type="M">org.apache.camel.component.file.strategy.FileProcessStrategyFactory.java</file>
			<file type="D">org.apache.camel.component.file.strategy.GenericFileRenameProcessStrategy.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumerIdempotentRefTest.java</file>
			<file type="M">org.apache.camel.component.file.strategy.GenericFileProcessStrategySupport.java</file>
			<file type="M">org.apache.camel.component.file.strategy.FileLockExclusiveReadLockStrategy.java</file>
			<file type="M">org.apache.camel.component.file.strategy.GenericFileRenameExclusiveReadLockStrategy.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.strategy.GenericFileProcessStrategyFactory.java</file>
			<file type="M">org.apache.camel.component.file.FileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileOnCompletion.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1676" opendate="2009-06-05 20:54:19" fixdate="2009-06-08 15:45:26" resolution="Fixed">
		<buginformation>
			<summary>Endpoint.getParticipant should return Endpoint.getUser() if participant is null.</summary>
			<description>The participant should default to the user  if the participant is null.

    public String getParticipant() {
        return participant != null ? participant : getUser();
    }


</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xmpp.XmppEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="756" opendate="2008-07-24 18:09:21" fixdate="2009-06-10 08:12:35" resolution="Fixed">
		<buginformation>
			<summary>AMQP component can&amp;apos;t send an ObjectMessage</summary>
			<description>Sending a TextMessage and BytesMessage work fine but when you try to send a Serializable object it gets lost somehow... see the testJmsRouteWithObjectMessage test in http://svn.apache.org/repos/asf/activemq/camel/trunk/components/camel-amqp/src/test/java/org/apache/camel/component/amqp/AMQPRouteTest.java to see what happens.</description>
			<version>1.4.0</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.amqp.AMQPRouteTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1645" opendate="2009-05-25 09:40:18" fixdate="2009-06-11 05:47:06" resolution="Fixed">
		<buginformation>
			<summary>Can&amp;apos;t set the outgoing mail&amp;apos;s content-type and charset</summary>
			<description>The document at http://camel.apache.org/mail.html suggests that contentType header should set the Content-Type of the out going mail, but that doesn&amp;amp;apos;t work.
I am trying to set the content type of the mail I send using the contentType header. That doesn&amp;amp;apos;t work, but it works if I put the contentType in the endpoint uri. i.e. - 
            &amp;lt;camel:setHeader headerName="contentType"&amp;gt; 
                &amp;lt;camel:constant&amp;gt;text/html&amp;lt;/camel:constant&amp;gt; 
            &amp;lt;/camel:setHeader&amp;gt; 
Has no effect, while this works - 
             smtp://rohitr@xyzab.pramati.com?password=32478hds78&amp;amp;contentType=text/html 
But I am not able to set the charset and it always takes us-ascii 
So for the mail the content type header comes as - 
Content-Type: text/html; charset=us-ascii
I tried using 
            &amp;lt;camel:setHeader headerName="contentType"&amp;gt; 
                &amp;lt;camel:constant&amp;gt;text/html;charset=UTF-8&amp;lt;/camel:constant&amp;gt; 
            &amp;lt;/camel:setHeader&amp;gt; 
and also 
            &amp;lt;camel:setHeader headerName="content-type"&amp;gt; 
                &amp;lt;camel:constant&amp;gt;text/html;charset=UTF-8&amp;lt;/camel:constant&amp;gt; 
            &amp;lt;/camel:setHeader&amp;gt; 
and 
smtp://rohitr@xyzab.pramati.com?password= 32478hds78&amp;amp;contentType=text/html;charset=UTF-8 
but nothing works</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.2, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailCustomContentTypeTest.java</file>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="1633" opendate="2009-05-20 14:24:36" fixdate="2009-06-11 05:53:54" resolution="Fixed">
		<buginformation>
			<summary>XMPPConsumer.processPacket does not correctly handle received non-message packets.</summary>
			<description>I am currently porting an application using an in house Smack integration to Apache Camel.
Specifically, I am getting failures with multiuser chat where messages stop being received in the middle of the message stream I am sending.
I have yet to verify the issue exists with private chat as well, but the XMPPConsumer source looks like there will be a similar issue.
The XMPPConsumer class registers itself for all packet types in the doStart method, but in the processPacket method immediately casts the received Packet to Message.
I have found with the in house integration that Smack sends several types of Packets, and I could not find assurance that it would not call the packet listener with a null message.
A simple if((null != packet) &amp;amp;&amp;amp; (packet instanceof Message))  should be used to prevent improper packets from being utilized.
FYI: the above if statement should also prevent packets from building up in the Smack message queue, since all messages will be processed without throwing an exception.
So a call to muc.nextMessage() is unnecessary, and actually detrimental (since if the next packet is a message, it will be dropped without processing).
It may be wise to actually use a try/catch block to prevent exceptions from being thrown by the processPacket method, since messages that throw exceptions seem to stay in the Smack message queue.</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xmpp.XmppConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1696" opendate="2009-06-11 09:14:11" fixdate="2009-06-11 13:31:10" resolution="Fixed">
		<buginformation>
			<summary>Refreshing a bundle with a camel-cxf route gives exception &amp;apos;BeanFactory not initialized or already closed</summary>
			<description>smx@root:/&amp;gt; osgi/refresh 120
smx@root:/&amp;gt; Exception in thread "SpringOsgiExtenderThread-16" org.springframework.beans.factory.BeanCreationException: E
rror creating bean with name &amp;amp;apos;illustrationGenerationEndpoint&amp;amp;apos;: Initialization of bean failed; nested exception is java.l
ang.IllegalStateException: BeanFactory not initialized or already closed - call &amp;amp;apos;refresh&amp;amp;apos; before accessing beans via the
ApplicationContext
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCap
ableBeanFactory.java:480)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$1.run(AbstractAutowireCapableBea
nFactory.java:409)
at java.security.AccessController.doPrivileged(Native Method)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapab
leBeanFactory.java:380)
at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:264)
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegis
try.java:222)
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:261)
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185)
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164)
at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListable
BeanFactory.java:429)
at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplic
ationContext.java:728)
at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.access$1600(AbstractDel
egatedExecutionApplicationContext.java:68)
at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext$4.run(AbstractDelegated
ExecutionApplicationContext.java:343)
at org.springframework.osgi.util.internal.PrivilegedUtils.executeWithCustomTCCL(PrivilegedUtils.java:85)
at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.completeRefresh(Abstrac
tDelegatedExecutionApplicationContext.java:308)
at org.springframework.osgi.extender.internal.dependencies.startup.DependencyWaiterApplicationContextExecutor$Co
mpleteRefreshTask.run(DependencyWaiterApplicationContextExecutor.java:138)
at java.lang.Thread.run(Thread.java:595)
Caused by: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call &amp;amp;apos;refresh&amp;amp;apos; before access
ing beans via the ApplicationContext
at org.springframework.context.support.AbstractRefreshableApplicationContext.getBeanFactory(AbstractRefreshableA
pplicationContext.java:153)
at org.springframework.context.support.AbstractApplicationContext.getBeanDefinitionNames(AbstractApplicationCont
ext.java:929)
at org.apache.cxf.configuration.spring.ConfigurerImpl.initWildcardDefinitionMap(ConfigurerImpl.java:77)
at org.apache.cxf.configuration.spring.ConfigurerImpl.addApplicationContext(ConfigurerImpl.java:223)
at org.apache.cxf.bus.spring.BusWiringBeanFactoryPostProcessor.updateBusReferencesInContext(BusWiringBeanFactory
PostProcessor.java:118)
at org.apache.camel.component.cxf.spring.CxfEndpointBeanDefinitionParser$CxfSpringEndpointBean.setApplicationCon
text(CxfEndpointBeanDefinitionParser.java:115)
at org.springframework.context.support.ApplicationContextAwareProcessor.postProcessBeforeInitialization(Applicat
ionContextAwareProcessor.java:70)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeIni
tialization(AbstractAutowireCapableBeanFactory.java:350)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireC
apableBeanFactory.java:1331)
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCap
ableBeanFactory.java:473)
... 16 more</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.2, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.spring.AbstractSpringBeanTestSupport.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSpringEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBean.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="1697" opendate="2009-06-11 09:56:27" fixdate="2009-06-12 09:00:51" resolution="Fixed">
		<buginformation>
			<summary>Java DSL for multicast, split, aggregate does not use block explicit</summary>
			<description>When using one of the EIP that uses a nested route for sub processing, typically EIPs that does some sort of aggregation such as

multicast (for aggregating a response)
split
aggregate
And maybe a few others

They should use pushBlock so the end() DSL to indicate end of sub route works correctly in Java DSL.</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.InstrumentationLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.processor.intercept.InterceptFromWhenWithChoiceTest.java</file>
			<file type="M">org.apache.camel.processor.TryProcessorTest.java</file>
			<file type="M">org.apache.camel.model.TryDefinition.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.processor.SplitShouldSkipFilteredExchanges.java</file>
			<file type="M">org.apache.camel.model.ChoiceDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="1716" opendate="2009-06-15 21:18:43" fixdate="2009-06-16 05:04:54" resolution="Fixed">
		<buginformation>
			<summary>Simple language support for AND / OR to concat multiple expressions fails if string constants are enclosed in single quotation marks</summary>
			<description>The current implementation for CAMEL-1637 fails if the string constants in the two expressions are enclosed in single quotation marks as given in the following example 

${in.header.foo} == &amp;amp;apos;abc&amp;amp;apos; and ${in.header.bar} == &amp;amp;apos;123&amp;amp;apos;


This is due to an issue with the GROUP_PATTERN regular expression in SimpleLanguageSupport.java. The matching pattern in between the single quotes is greedy and thus does not match correctly.</description>
			<version>2.0.0</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.spi.TransactionErrorHandlerBuilder.java</file>
			<file type="M">org.apache.camel.language.simple.SimpleLanguageSupport.java</file>
			<file type="M">org.apache.camel.language.SimpleOperatorTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1719" opendate="2009-06-16 11:47:15" fixdate="2009-06-16 13:24:57" resolution="Fixed">
		<buginformation>
			<summary>bean component should thrown NoTypeConverterException when bean parameter binding cannot convert to method signature type</summary>
			<description>See nabble:
http://www.nabble.com/Error-not-raised-by-Camel-if-the-%40Header-type-define-in-a-bean-is-not--correct-td24051086s22882.html</description>
			<version>2.0-M2</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.MethodInfo.java</file>
		</fixedFiles>
	</bug>
	<bug id="1711" opendate="2009-06-15 11:16:27" fixdate="2009-06-17 13:02:14" resolution="Fixed">
		<buginformation>
			<summary>Routes are started twice with webapplication context</summary>
			<description>I&amp;amp;apos;ve a spring based web application that has 2 applicationContexts (the second has the first as parent). My problem is that the SpringCamelContext listens to the ContextRefreshedEvent and starts the camel context.
This works fine if you have only 1 context but if the ContextRefreshedEvent of the second context is received the routes are started a second time.
The second start of the camel context is catched correctly (in ServiceSupport) but I think the the startRoutes() in the start()-method of DefaultCamelContext should also prevent to be called twice...  
See discussion here http://www.nabble.com/How-to-prevent-routes-from-started-twice--td23983653.html
Attached is a test-project. The core project simply defines a service that is exported in the web project. The applicationContext-services.xml creates the camelContext and the DispatcherServlet is used to export the service as remoteService.
Start the webapp with the jetty-run.cmd in the web project. The logfile is created in the web project.
The root web application context is started:

2009-06-15 11:43:24.771 DEBUG [main][org.apache.camel.spring.SpringCamelContext] - Publishing spring-event: \
   org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.web.context.support.XmlWebApplicationContext@1d4e49a: \
   display name [Root WebApplicationContext]; startup date [Mon Jun 15 11:43:22 CEST 2009]; root of context hierarchy]
2009-06-15 11:43:24.771 DEBUG [main][org.apache.camel.spring.SpringCamelContext] - Starting the CamelContext now that the ApplicationContext has started
2009-06-15 11:43:24.771 INFO  [main][org.apache.camel.impl.DefaultCamelContext] - Apache Camel 1.6.1 (CamelContext:camel-amq) is starting
....
2009-06-15 11:43:25.245 INFO  [main][org.apache.camel.impl.DefaultCamelContext] - Apache Camel 1.6.1 (CamelContext:camel-amq) started
....
2009-06-15 11:43:25.372 INFO  [main][org.springframework.web.context.ContextLoader] - Root WebApplicationContext: initialization completed in 2420 ms
2009-06-15 11:43:25.435 INFO  [main][/camel-spring-problem-web] - Initializing Spring FrameworkServlet &amp;amp;apos;CamelSpringProblem&amp;amp;apos;
2009-06-15 11:43:25.435 INFO  [main][org.springframework.web.servlet.DispatcherServlet] - FrameworkServlet &amp;amp;apos;CamelSpringProblem&amp;amp;apos;: initialization started
2009-06-15 11:43:25.435 INFO  [main][org.springframework.web.context.support.XmlWebApplicationContext] - Refreshing org.springframework.web.context.support.XmlWebApplicationContext@1ccbdf7: \
   display name [WebApplicationContext for namespace &amp;amp;apos;CamelSpringProblem-servlet&amp;amp;apos;]; startup date [Mon Jun 15 11:43:25 CEST 2009]; parent: \
   org.springframework.web.context.support.XmlWebApplicationContext@1d4e49a
...


And now the web application context for the servlet is started:

2009-06-15 11:43:25.530 DEBUG [main][org.apache.camel.spring.SpringCamelContext] - Publishing spring-event: \
   org.springframework.context.event.ContextRefreshedEvent[source=org.springframework.web.context.support.XmlWebApplicationContext@1ccbdf7: \
   display name [WebApplicationContext for namespace &amp;amp;apos;CamelSpringProblem-servlet&amp;amp;apos;]; startup date [Mon Jun 15 11:43:25 CEST 2009]; \
   parent: org.springframework.web.context.support.XmlWebApplicationContext@1d4e49a]
2009-06-15 11:43:25.530 DEBUG [main][org.apache.camel.spring.SpringCamelContext] - Starting the CamelContext now that the ApplicationContext has started
2009-06-15 11:43:25.530 DEBUG [main][org.apache.camel.management.DefaultInstrumentationAgent] - Registered MBean with objectname: \
   org.apache.camel:context=chaw389c/camel-amq,type=consumers,name=JmsConsumer(0x14bcb5c)
2009-06-15 11:43:25.530 INFO  [main][org.apache.camel.impl.DefaultCamelContext] - Apache Camel 1.6.1 (CamelContext:camel-amq) started
2009-06-15 11:43:25.530 INFO  [main][org.springframework.web.servlet.DispatcherServlet] - FrameworkServlet &amp;amp;apos;CamelSpringProblem&amp;amp;apos;: initialization completed in 95 ms


The ContextRefreshedEvent is published and causes the SpringCamelContext to handle the event and try to start the camel context again. But the start() in DefaultCamelContext calls super.start() and ServiceSupport detects correctly that the context is already started and does nothing but the call to startRoutes(...) is executed and this should no happen.
DefaultCamelContext.java
public void start() throws Exception {
        super.start();
        
        // the context is now considered started (i.e. isStarted() == true))
        // starting routes is done after, not during context startup
        synchronized (this) {
            startRoutes(routes);
        }

        LOG.info("Apache Camel " + getVersion() + " (CamelContext:" + getName() + ") started");
}


My favorite solution would be to add a flag that would prevent the camel context to be started from the ContextRefreshed event but allows to start the context manually from another user defined bean (possible by calling the start() method on SpringCamelContext. The shouldStartContext blocks both ways if set to false.</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.spring.SpringCamelContext.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="1727" opendate="2009-06-18 05:45:50" fixdate="2009-06-18 05:53:37" resolution="Fixed">
		<buginformation>
			<summary>camel-mail - Alternative Body Header is included in mail as a header, it should be skipped</summary>
			<description>See nabble
http://www.nabble.com/Camel-Mail%3A-Alternate-body-is-included-twice-td24049547.html</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailContentTypeResolverTest.java</file>
			<file type="M">org.apache.camel.component.mail.MimeMultipartAlternativeTest.java</file>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="1728" opendate="2009-06-18 06:37:35" fixdate="2009-06-18 07:26:50" resolution="Fixed">
		<buginformation>
			<summary>camel-bean - should throw MethodNotExist exception if method name provided but not found on bean</summary>
			<description>See nabble
http://www.nabble.com/AmbiguousMethodCallException-td24042324s22882.html</description>
			<version>1.6.1</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
		</fixedFiles>
	</bug>
	<bug id="1724" opendate="2009-06-17 10:46:16" fixdate="2009-06-18 07:28:34" resolution="Fixed">
		<buginformation>
			<summary>camel-mail - sending mails with text/plain could give a content type error by java mail</summary>
			<description></description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="1497" opendate="2009-03-28 10:37:52" fixdate="2009-06-23 05:37:30" resolution="Fixed">
		<buginformation>
			<summary>JmsPollingConsumer - receive does not work</summary>
			<description>The timeout values to set on Spring JmsTemplate is wrong. We should uses the provided constants on JmsTemplate for this

	/**
	 * Timeout value indicating that a receive operation should
	 * check if a message is immediately available without blocking.
	 */
	public static final long RECEIVE_TIMEOUT_NO_WAIT = -1;

	/**
	 * Timeout value indicating a blocking receive without timeout.
	 */
	public static final long RECEIVE_TIMEOUT_INDEFINITE_WAIT = 0;


Is the correct values. Looks like the values was reverted in the camel-jms code </description>
			<version>1.6.0</version>
			<fixedVersion>1.6.1, 2.0-M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsPollingConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1736" opendate="2009-06-22 09:17:10" fixdate="2009-06-23 06:55:23" resolution="Fixed">
		<buginformation>
			<summary>camel-cxf defaultHeaderFilterStrategy doesn&amp;apos;t filter the Camel releates headers</summary>
			<description>Here is the mailing thread[1] which discuss this issue.
[1] http://www.nabble.com/-camel-cxf--Stripping-headers-td24143323.html</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfHeaderFilterStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="1743" opendate="2009-06-23 07:29:56" fixdate="2009-06-23 08:19:20" resolution="Fixed">
		<buginformation>
			<summary>Validator component lacks a DOMSource converter from an InputStream</summary>
			<description>The Validator component requires the payload to be of type DOMSource so it converters it to this type.
But we lack a XmlConverter from an InputStream to this type.
See nabble:
http://www.nabble.com/XML-Validation-throws-NoXmlBodyValidationException-td24147734.html</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.itest.jetty.JettyValidatorTest.java</file>
			<file type="M">org.apache.camel.converter.jaxp.XmlConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1735" opendate="2009-06-22 08:35:30" fixdate="2009-06-24 05:29:54" resolution="Fixed">
		<buginformation>
			<summary>camel-example-etl - bug in sample about type converter</summary>
			<description></description>
			<version>2.0-M2</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jpa.JpaProducer.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaEndpoint.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaConsumer.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaTest.java</file>
			<file type="M">org.apache.camel.example.etl.CustomerTransformer.java</file>
			<file type="M">org.apache.camel.example.etl.EtlRoutes.java</file>
		</fixedFiles>
	</bug>
	<bug id="1753" opendate="2009-06-24 09:19:31" fixdate="2009-06-24 09:32:19" resolution="Fixed">
		<buginformation>
			<summary>validator component should be configurable for either Sax or Dom as MSV component requires Dom</summary>
			<description></description>
			<version>2.0-M2</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.validator.msv.MsvComponent.java</file>
			<file type="M">org.apache.camel.processor.validation.DefaultValidationErrorHandler.java</file>
			<file type="M">org.apache.camel.processor.validation.ValidatorErrorHandler.java</file>
			<file type="M">org.apache.camel.processor.validation.ValidatingProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="1752" opendate="2009-06-24 01:38:56" fixdate="2009-06-24 10:27:05" resolution="Fixed">
		<buginformation>
			<summary>SpringCamelContext will get into endless loop of calling start method if the route service calling the ApplicationContext refresh method in it&amp;apos;s initial method</summary>
			<description>Here is the mail thread which discusses this issue.
http://www.nabble.com/StackOverFlow-error-with-Camel-1.6.1-tp24172060p24172060.html</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.SpringCamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="1755" opendate="2009-06-24 11:14:47" fixdate="2009-06-24 11:31:53" resolution="Fixed">
		<buginformation>
			<summary>Failover load balancer - should prepare exchange before failover</summary>
			<description>When the failover load balancer does a fail over it only clears the exception.
When you use dead letter channel or default error handler with redeliveries enabled they will have such information.
This should also be cleared before failover. So we have a clean and fresh start.</description>
			<version>2.0-M2</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.loadbalancer.FailOverLoadBalancer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1760" opendate="2009-06-25 12:45:14" fixdate="2009-06-25 16:07:38" resolution="Fixed">
		<buginformation>
			<summary>Unable to read post params from request</summary>
			<description>If consuming messsages from jetty endpoint there is no way to read post parameters from HttpServletRequest. 
In example  getting HttpServletRequest  from body :
HttpServletRequest req = exchange.getIn().getBody(HttpServletRequest.class);
req.getParameterMap() returns allways empty map
The problem is that jetty Request.extractParameters() method is trying  to read post parameters from Request.getInputStream().  But unfortunately someone strips the input stream before and req.getInputStream() returns allways 0 bytes
The workaround for me is to extend DefaultHttpBinding as described in:  http://camel.apache.org/jetty.html
MyHttpBinding .java
public class MyHttpBinding extends DefaultHttpBinding {
    
    public void readRequest(HttpServletRequest request, HttpMessage message) {
       request.getParameterMap();
       super.readRequest(request,message);
    }
}


calling  request.getParameterMap()  will cache parameters inside jetty Request and it&amp;amp;apos;s possible to query params later,  without having inputStream
</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.2, 2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.DefaultHttpBinding.java</file>
			<file type="M">org.apache.camel.component.jetty.HttpRouteTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1759" opendate="2009-06-25 08:09:20" fixdate="2009-06-26 17:48:08" resolution="Fixed">
		<buginformation>
			<summary>Tracer - when using delay, throttle the to node keeps displaying the parent</summary>
			<description>.delay(100) does affect the Tracer log and do not output correctly in the to destination
See SedaComplexInOutTest
Also Throttler, Split. Looks like sub routes in general is not displayed correctly in tracer</description>
			<version>2.0-M2</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFileExchange.java</file>
			<file type="M">org.apache.camel.processor.intercept.InterceptSimpleRouteTest.java</file>
			<file type="M">org.apache.camel.processor.interceptor.DefaultTraceEventMessage.java</file>
			<file type="M">org.apache.camel.processor.OnCompletionGlobalTest.java</file>
			<file type="M">org.apache.camel.component.bean.DefaultParameterMappingStrategy.java</file>
			<file type="M">org.apache.camel.processor.TraceableUnitOfWorkTest.java</file>
			<file type="M">org.apache.camel.processor.interceptor.TraceInterceptor.java</file>
			<file type="M">org.apache.camel.processor.DefaultErrorHandlerOnExceptionTest.java</file>
			<file type="M">org.apache.camel.processor.TraceInterceptorTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultExchange.java</file>
			<file type="D">org.apache.camel.model.RouteNode.java</file>
			<file type="M">org.apache.camel.model.OnCompletionDefinition.java</file>
			<file type="M">org.apache.camel.processor.OnCompletionProcessor.java</file>
			<file type="M">org.apache.camel.spi.TraceableUnitOfWork.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.impl.DefaultUnitOfWork.java</file>
			<file type="M">org.apache.camel.processor.interceptor.DefaultTraceFormatter.java</file>
			<file type="M">org.apache.camel.processor.interceptor.JpaTraceEventMessageTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultRouteNode.java</file>
			<file type="M">org.apache.camel.model.RoutesDefinition.java</file>
			<file type="M">org.apache.camel.model.InterceptDefinition.java</file>
			<file type="M">org.apache.camel.issues.MultipleFromTest.java</file>
			<file type="M">org.apache.camel.processor.Traceable.java</file>
			<file type="M">org.apache.camel.processor.MarshalProcessor.java</file>
			<file type="M">org.apache.camel.processor.TryProcessor.java</file>
			<file type="M">org.apache.camel.processor.RoutingSlip.java</file>
			<file type="M">org.apache.camel.processor.SortProcessor.java</file>
			<file type="M">org.apache.camel.processor.StopProcessor.java</file>
			<file type="M">org.apache.camel.processor.Aggregator.java</file>
			<file type="M">org.apache.camel.processor.CatchProcessor.java</file>
			<file type="M">org.apache.camel.processor.ThrowExceptionProcessor.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
			<file type="M">org.apache.camel.processor.Throttler.java</file>
			<file type="M">org.apache.camel.processor.loadbalancer.RoundRobinLoadBalancer.java</file>
			<file type="M">org.apache.camel.processor.JoinRoutesTest.java</file>
			<file type="M">org.apache.camel.processor.FilterProcessor.java</file>
			<file type="M">org.apache.camel.processor.TransformProcessor.java</file>
			<file type="M">org.apache.camel.processor.RollbackProcessor.java</file>
			<file type="M">org.apache.camel.processor.ExchangePatternProcessor.java</file>
			<file type="M">org.apache.camel.processor.loadbalancer.TopicLoadBalancer.java</file>
			<file type="M">org.apache.camel.processor.loadbalancer.StickyLoadBalancer.java</file>
			<file type="M">org.apache.camel.processor.WireTapProcessor.java</file>
			<file type="M">org.apache.camel.processor.intercept.InterceptFromWhenTest.java</file>
			<file type="M">org.apache.camel.processor.ChoiceProcessor.java</file>
			<file type="M">org.apache.camel.processor.ThreadsProcessor.java</file>
			<file type="M">org.apache.camel.processor.Splitter.java</file>
			<file type="M">org.apache.camel.processor.Delayer.java</file>
			<file type="M">org.apache.camel.processor.onexception.OnExceptionFromChoiceTest.java</file>
			<file type="M">org.apache.camel.processor.loadbalancer.RandomLoadBalancer.java</file>
			<file type="M">org.apache.camel.processor.LoopProcessor.java</file>
			<file type="M">org.apache.camel.processor.loadbalancer.FailOverLoadBalancer.java</file>
			<file type="M">org.apache.camel.processor.intercept.InterceptSendToEndpointTest.java</file>
			<file type="M">org.apache.camel.processor.UnmarshalProcessor.java</file>
			<file type="M">org.apache.camel.processor.Resequencer.java</file>
			<file type="M">org.apache.camel.processor.Enricher.java</file>
			<file type="M">org.apache.camel.processor.SendProcessor.java</file>
			<file type="M">org.apache.camel.processor.StreamResequencer.java</file>
			<file type="M">org.apache.camel.processor.Pipeline.java</file>
			<file type="M">org.apache.camel.processor.Logger.java</file>
			<file type="M">org.apache.camel.processor.interceptor.Tracer.java</file>
			<file type="M">org.apache.camel.CamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.component.dataset.DataSetSupport.java</file>
			<file type="M">org.apache.camel.processor.SplitWithEndTest.java</file>
			<file type="M">org.apache.camel.Channel.java</file>
			<file type="M">org.apache.camel.processor.RoutePerformanceTest.java</file>
			<file type="M">org.apache.camel.component.seda.SedaComplexInOutTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1774" opendate="2009-06-30 01:33:51" fixdate="2009-06-30 01:53:36" resolution="Fixed">
		<buginformation>
			<summary>cxfbean does not propagate in http response code to Camel header</summary>
			<description></description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.cxfbean.CxfBeanTest.java</file>
			<file type="M">org.apache.camel.component.cxf.cxfbean.CxfBeanBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.transport.CamelDestination.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.testbean.CustomerService.java</file>
			<file type="M">org.apache.camel.component.cxf.cxfbean.DefaultCxfBeanBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.cxfbean.CxfBeanDestination.java</file>
		</fixedFiles>
	</bug>
	<bug id="1771" opendate="2009-06-29 09:22:11" fixdate="2009-06-30 07:45:53" resolution="Fixed">
		<buginformation>
			<summary>ProducerCache should be limited to not eat memory (was: recipientList leaks memory)</summary>
			<description>I found that RecipientList leaks memory .
The problem is that RecipientList stores endpoints in producerCache and cache key computed by using getEndpointUri. If endpoint uris are unique ( as we have ) then every new entry will stored in cache and will never released.
In example we are using recipientList  to send messages to the external http server, every url contains unique query parameters therefor every recipientList entry will create new producer ant that producer will stored in producerCache.
In our system recipientList wlil leak about 20M per day
Unfortunately I was unable to find any workaround </description>
			<version>1.4.0</version>
			<fixedVersion>1.6.2, 2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.impl.ConsumerCache.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
			<file type="M">org.apache.camel.impl.InterceptSendToEndpoint.java</file>
			<file type="M">org.apache.camel.Endpoint.java</file>
			<file type="M">org.apache.camel.component.direct.DirectEndpoint.java</file>
			<file type="M">org.apache.camel.management.CamelNamingStrategy.java</file>
			<file type="M">org.apache.camel.impl.ProducerCache.java</file>
			<file type="M">org.apache.camel.impl.DefaultEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSoapEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="1777" opendate="2009-07-01 07:34:42" fixdate="2009-07-01 09:50:20" resolution="Fixed">
		<buginformation>
			<summary>The Exchange.BEAN_METHOD_NAME header is not be set rightly when the message exchange pattern is InOut</summary>
			<description>If the Bean endpoint has an explicit method name ,   the Bean processor will set the message header of Exchange.Bean_METHOD_NAME with the value of method name  before the invocation and will try to reset the message header of Exchange.Bean_METHOD_NAME with the preview method name after the invocation. 
Current camel code just set the InMessage&amp;amp;apos;s header , if the ExchangePatter is InOut , it forget to reset the OutMessage&amp;amp;apos;s header.</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.2, 2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanWithMethodHeaderTest.java</file>
			<file type="M">org.apache.camel.component.bean.BeanProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="1689" opendate="2009-06-09 15:49:40" fixdate="2009-07-01 12:46:55" resolution="Fixed">
		<buginformation>
			<summary>JMS-Headers are ignored in Producer</summary>
			<description>Camel jms producer ignores some JMSHeaders. For example the header JMSPriority is ignored - due to the comment in the code, because it is set by the producer. But it should not only be set by the produer due to the received message, it should also be possible to set a priority using the JMSPriority header on the consumer. (See also the option preserveMessageQos on the jms endpoint - if every JMSHeader is ignored by the producer it is impossible to set Qos-Properties on the message.)
The reason for the bug is in org.apache.camel.component.jms.JmsBinding#appendJmsProperty. 
The follwoing JMS message headers are useful for sending messages and therefore should be copied to the jms message:

JMSDestination
JMSDeliveryMode
JMSExpiration
JMSPriority
JMSMessageID
JMSTimestamp

</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsConfiguration.java</file>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
			<file type="M">org.apache.camel.component.jms.JmsProducer.java</file>
			<file type="M">org.apache.camel.component.jms.JmsConstants.java</file>
			<file type="M">org.apache.camel.component.jms.JmsMessageHelper.java</file>
			<file type="M">org.apache.camel.component.jms.JmsProducerWithJMSHeaderTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1786" opendate="2009-07-02 17:54:04" fixdate="2009-07-02 18:23:40" resolution="Fixed">
		<buginformation>
			<summary>camel-irc parsing of channel name and parameters is incorrect</summary>
			<description>If you try and pass some parameters to camel-irc it turns out that camel joins a different IRC channel than expected, for example a URI like:
irc://camel-con@irc.codehaus.org:6667/#camel-test?nickname=camel-con
causes camel to join #camel-test?nickname=camel-con and not #camel-test with a nickname of camel-con.  Will attach a patch that addresses this and updates the unit test.</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.irc.IrcRouteTest.java</file>
			<file type="M">org.apache.camel.component.irc.IrcConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="1740" opendate="2009-06-22 20:37:12" fixdate="2009-07-03 07:03:15" resolution="Fixed">
		<buginformation>
			<summary>Docs for the http component are incorrect regarding the HttpConstants class</summary>
			<description>The documentation on the wiki needs updating after many of the HTTP constants were moved from HttpConstants to Exchange in r777808.
The HttpConstants class is not even necessary anymore, the only constant remaining there is HttpConstants.CONTENT_ENCODING which is duplicated actually by Exchange.HTTP_CHARACTER_ENCODING.  The latter should be used, HttpConstants.java removed and the wiki updated.</description>
			<version>2.0-M2</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.HttpMessage.java</file>
			<file type="M">org.apache.camel.component.http.helper.GZIPHelper.java</file>
			<file type="M">org.apache.camel.util.MessageHelper.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyContentTypeTest.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.http.DefaultHttpBinding.java</file>
			<file type="M">org.apache.camel.component.http.HttpConverter.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyImageFileTest.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.component.http.RequestEntityConverter.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyWithXPathChoiceTest.java</file>
			<file type="M">org.apache.camel.component.http.CamelServlet.java</file>
			<file type="M">org.apache.camel.itest.tx.JmsToHttpWithOnExceptionAndNoTransactionErrorHandlerConfiguredRoute.java</file>
			<file type="D">org.apache.camel.component.http.HttpConstants.java</file>
			<file type="M">org.apache.camel.component.http.HttpEndpoint.java</file>
			<file type="M">org.apache.camel.itest.tx.JmsToHttpWithOnExceptionRoute.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpGetWithParamAsExchangeHeaderTest.java</file>
			<file type="M">org.apache.camel.component.jetty.JettySimplifiedHandle404Test.java</file>
		</fixedFiles>
	</bug>
	<bug id="1795" opendate="2009-07-03 14:54:34" fixdate="2009-07-03 15:13:45" resolution="Fixed">
		<buginformation>
			<summary>camel-jms - wrong defaults causes message listener to use new thread when receiving a message</summary>
			<description>JmsConfiguratiuon have a bad default
maxMessagesPerTask=1
It should be -1 as we do not want to strict the DefaultMessageListenerContainer to only handle 1 message per thread.</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="1797" opendate="2009-07-05 09:46:38" fixdate="2009-07-05 10:17:59" resolution="Fixed">
		<buginformation>
			<summary>Spring DSL - tracer is tracing double in some cases</summary>
			<description>The tracer is Spring DSL is under some circumstances being registered twice and thus doing double tracing.
</description>
			<version>2.0-M2</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.processor.OnCompletionGlobalTraceTest.java</file>
			<file type="M">org.apache.camel.spring.processor.SpringInterceptSimpleRouteTest.java</file>
			<file type="M">org.apache.camel.processor.DefaultErrorHandlerOnExceptionTraceTest.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.processor.interceptor.TraceInterceptorDestinationTest.java</file>
			<file type="M">org.apache.camel.model.ProcessDefinition.java</file>
			<file type="M">org.apache.camel.ContextTestSupport.java</file>
			<file type="M">org.apache.camel.test.CamelTestSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="1803" opendate="2009-07-06 11:11:04" fixdate="2009-07-06 12:13:58" resolution="Fixed">
		<buginformation>
			<summary>RedeliverErrorHandler - Should remove redeliver headers is failure processor is handling the caused exception</summary>
			<description>If for instance an onException() is handling a given exception the traces of the redelivery headers should be removed from the message.
As if the exchange will fail yet another again then it will continue using counters from where the old left. It should start from 0 again.
</description>
			<version>1.6.1</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.DeadLetterChannelRedeliveryTest.java</file>
			<file type="M">org.apache.camel.processor.async.AsyncDeadLetterChannelTest.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannelTest.java</file>
			<file type="M">org.apache.camel.spring.config.DeadLetterChannelRedeliveryConfigTest.java</file>
			<file type="M">org.apache.camel.processor.RedeliveryErrorHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1813" opendate="2009-07-09 00:45:40" fixdate="2009-07-09 04:48:16" resolution="Fixed">
		<buginformation>
			<summary>HttpProducer doesn&amp;apos;t copy the in message header to out message</summary>
			<description>Here is the mail thread which discuss about it.
http://www.nabble.com/HTTP-component-and-IN-head-loss-to24393415.html</description>
			<version>2.0-M2</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.HttpGetTest.java</file>
			<file type="M">org.apache.camel.component.http.HttpGetWithHeadersTest.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1815" opendate="2009-07-09 04:06:23" fixdate="2009-07-09 09:16:17" resolution="Fixed">
		<buginformation>
			<summary>Remove debug interceptor as it was newer implemented</summary>
			<description>See nabble
http://www.nabble.com/Missing-debug.xml-in-2.0-M2-td24400032.html</description>
			<version>2.0-M2</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Task</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.camel.processor.interceptor.Debugger.java</file>
			<file type="D">org.apache.camel.processor.interceptor.Breakpoint.java</file>
			<file type="M">org.apache.camel.impl.DefaultProducerTemplateAsyncTest.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpRemoteFileSorterTest.java</file>
			<file type="D">org.apache.camel.processor.interceptor.ExceptionEvent.java</file>
			<file type="D">org.apache.camel.processor.interceptor.DebugInterceptor.java</file>
			<file type="M">org.apache.camel.component.file.ToFileRouteTest.java</file>
			<file type="M">org.apache.camel.impl.MainSupport.java</file>
			<file type="M">org.apache.camel.maven.RunMojo.java</file>
			<file type="M">org.apache.camel.spring.Main.java</file>
			<file type="D">org.apache.camel.processor.DebugInterceptorTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1814</link>
		</links>
	</bug>
	<bug id="1814" opendate="2009-07-09 04:00:58" fixdate="2009-07-09 09:19:16" resolution="Duplicate">
		<buginformation>
			<summary>Missing debug.xml in 2.0-M2</summary>
			<description>I get the following error trying to run camel from ant with the debug arg. I checked and debug.xml is indeed missing from the 2.0-M2 release.  (trace.xml is missing as well).
Adding java] [                          main] MainSupport                    INFO  Apache Camel 2.0-M2 starting
[java] [                          main] ClassPathXmlApplicationContext INFO  Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@253498: display name [org.spri
ngframework.context.support.ClassPathXmlApplicationContext@253498]; startup date [Wed Jul 08 14:45:33 PDT 2009]; root of context hierarchy
[java] [                          main] XmlBeanDefinitionReader        INFO  Loading XML bean definitions from class path resource [META-INF/services/org/apache/camel/spring/debug.xml]
[java] [                          main] MainSupport                    INFO  Apache Camel 2.0-M2 stopping
[java] [                          main] MainSupport                    ERROR Failed: org.springframework.beans.factory.BeanDefinitionStoreException: IOException parsing XML document fro
m class path resource [META-INF/services/org/apache/camel/spring/debug.xml]; nested exception is java.io.FileNotFoundException: class path resource [META-INF/services/org/apache/camel/spring
/debug.xml] cannot be opened because it does not exist
[java] org.springframework.beans.factory.BeanDefinitionStoreException: IOException parsing XML document from class path resource [META-INF/services/org/apache/camel/spring/debug.xml]; n
ested exception is java.io.FileNotFoundException: class path resource [META-INF/services/org/apache/camel/spring/debug.xml] cannot be opened because it does not exist
[java]     at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:349)
[java]     at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:310)
[java]     at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:143)
[java]     at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:178)
[java]     at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:149)
[java]     at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:212)
[java]     at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:113)
[java]     at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:80)
[java]     at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:123)
[java]     at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:423)
[java]     at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:353)
[java]     at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:139)
[java]     at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:83)
[java]     at org.apache.camel.spring.Main.getParentApplicationContext(Main.java:159)
[java]     at org.apache.camel.spring.Main.createDefaultApplicationContext(Main.java:227)
[java]     at org.apache.camel.spring.Main.doStart(Main.java:185)
[java]     at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:52)
[java]     at org.apache.camel.impl.MainSupport.run(MainSupport.java:120)
[java]     at org.apache.camel.impl.MainSupport.run(MainSupport.java:298)
[java]     at org.apache.camel.spring.Main.main(Main.java:97)
[java] Caused by: java.io.FileNotFoundException: class path resource [META-INF/services/org/apache/camel/spring/debug.xml] cannot be opened because it does not exist
[java]     at org.springframework.core.io.ClassPathResource.getInputStream(ClassPathResource.java:142)
[java]     at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:336)</description>
			<version>2.0-M2</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.camel.processor.interceptor.Debugger.java</file>
			<file type="D">org.apache.camel.processor.interceptor.Breakpoint.java</file>
			<file type="M">org.apache.camel.impl.DefaultProducerTemplateAsyncTest.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpRemoteFileSorterTest.java</file>
			<file type="D">org.apache.camel.processor.interceptor.ExceptionEvent.java</file>
			<file type="D">org.apache.camel.processor.interceptor.DebugInterceptor.java</file>
			<file type="M">org.apache.camel.component.file.ToFileRouteTest.java</file>
			<file type="M">org.apache.camel.impl.MainSupport.java</file>
			<file type="M">org.apache.camel.maven.RunMojo.java</file>
			<file type="M">org.apache.camel.spring.Main.java</file>
			<file type="D">org.apache.camel.processor.DebugInterceptorTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1815</link>
		</links>
	</bug>
	<bug id="1824" opendate="2009-07-11 21:03:04" fixdate="2009-07-12 08:11:52" resolution="Fixed">
		<buginformation>
			<summary>GenericFileConsumer fails to pick up all files in a directory if there are more files than maxMessagePerPoll setting</summary>
			<description>Camel adds filenames it is processing to an in memory, in progress map.  Once it is finished processing it removes them.  If we specific a maxMessagesPerPoll number less then the files in a directory, it only processes up to the number of files we specify for each poll.  It then removes the rest from the in progress map and tries them again next poll.  This is the code (from GenericFileConsumer:processBatch()) for the last part:
       for (int index = 0; index &amp;lt; exchanges.size() &amp;amp;&amp;amp; isRunAllowed(); index++) 
{
            GenericFileExchange&amp;lt;T&amp;gt; exchange = (GenericFileExchange&amp;lt;T&amp;gt;) exchanges.poll();
            String key = exchange.getGenericFile().getFileName();
            endpoint.getInProgressRepository().remove(key);
        }

Unfortunately, as you can see it uses exchanges.size() to determine how many file names to remove (i.e. how many times to loop), however exchanges.poll() removes one from the head of exchanges for each loop.  This means that the exchanges.size() reduces by one for each loop, which means it only cleans up half of the filenames that are in exchanges, which means these files are never picked up again as Camel thinks it is still processing them.

The fix is to replace the for loop with a while:

        while ((exchanges.size() &amp;gt; 0) &amp;amp;&amp;amp; isRunAllowed()) {            GenericFileExchange&amp;lt;T&amp;gt; exchange = (GenericFileExchange&amp;lt;T&amp;gt;) exchanges.poll();            String key = exchange.getGenericFile().getFileName();            endpoint.getInProgressRepository().remove(key);        }

</description>
			<version>2.0-M2</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileOperations.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileOperations.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
			<file type="M">org.apache.camel.processor.LoggingErrorHandler.java</file>
			<file type="M">org.apache.camel.impl.DefaultUnitOfWork.java</file>
			<file type="M">org.apache.camel.component.file.strategy.GenericFileDeleteProcessStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="1825" opendate="2009-07-11 21:17:20" fixdate="2009-07-12 08:12:06" resolution="Fixed">
		<buginformation>
			<summary>GenericFileDeleteProcessStrategy in some cases seems to delete a file, but then throw an exception saying it can&amp;apos;t delete the file, even though it has.</summary>
			<description>In some cases, GenericFileDeleteProcessStrategy seems to delete a file, but then it throws an exception saying it can&amp;amp;apos;t delete the file, even though it has.  Because this happens, it causes a rollback even though the file has been processed and deleted correctly.  This only seems to happen on our Linux box which is using a network share to process files from.  We have managed to work around it by checking if the file exists again straightaway after "operations.deleteFile(...)", and this always says the file does not exist as expected, so not sure why the call  "operations.deleteFile(...)" returns false.  The modified code below works around this issue, and logs a warning if the file still exists (though you may wish to throw and exception instead), but so far the log statement has not been called in our test runs even though it does enter the " if (!deleted)" block.
    @Override
    public void commit(GenericFileOperations&amp;lt;T&amp;gt; operations, GenericFileEndpoint&amp;lt;T&amp;gt; endpoint, GenericFileExchange&amp;lt;T&amp;gt; exchange, GenericFile&amp;lt;T&amp;gt; file) throws Exception {
        // must invoke super
        super.commit(operations, endpoint, exchange, file);
        boolean deleted = operations.deleteFile(file.getAbsoluteFilePath());
        if (!deleted) {
            final File javaFile = new File(file.getAbsoluteFilePath());
            if (javaFile.exists()) 
{
                log.warn("Cannot delete file: " + file);
            }
        }
    }</description>
			<version>2.0-M2</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileOperations.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileOperations.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
			<file type="M">org.apache.camel.processor.LoggingErrorHandler.java</file>
			<file type="M">org.apache.camel.impl.DefaultUnitOfWork.java</file>
			<file type="M">org.apache.camel.component.file.strategy.GenericFileDeleteProcessStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="1828" opendate="2009-07-13 11:20:38" fixdate="2009-07-16 10:02:14" resolution="Fixed">
		<buginformation>
			<summary>jaxb prettyPrint does not work</summary>
			<description>Here is the mail thread with discuss about it.
 http://www.nabble.com/JAXB-pretty-print-marshaling-td24449564.html</description>
			<version>1.4.0</version>
			<fixedVersion>1.6.2, 2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.example.DataFormatTest.java</file>
			<file type="M">org.apache.camel.converter.jaxb.JaxbDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="1838" opendate="2009-07-17 05:10:29" fixdate="2009-07-18 05:56:14" resolution="Fixed">
		<buginformation>
			<summary>camel-ftp - Recover from lost connection issue</summary>
			<description>See nabble
http://www.nabble.com/FTP-Component-Network-Failure-Recovery-Problem-td24517828.html</description>
			<version>2.0-M2</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpOperations.java</file>
			<file type="M">org.apache.camel.impl.DefaultPollingConsumerPollStrategy.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileConsumer.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8639</link>
		</links>
	</bug>
	<bug id="1839" opendate="2009-07-19 03:22:18" fixdate="2009-07-19 03:34:02" resolution="Fixed">
		<buginformation>
			<summary>camel-web can&amp;apos;t process the endpoint with "://" schema, like /endpoints/mock://results</summary>
			<description>After improving the endpoint URI schema on http://issues.apache.org/activemq/browse/CAMEL-1756, camel-web&amp;amp;apos;s endpoint request URL is changed from http://localhost:8080/endpoints/mock:results into http://localhost:8080/endpoints/mock://results while "//" is a separator for URL, so camel-web will use only the "mock:" to get the expected endpoint, which will throw an exception:
org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: mock: due to: Expected scheme-specific part at index 5: mock:
	at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:367)
	at org.apache.camel.web.resources.EndpointsResource.getEndpoint(EndpointsResource.java:75)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at com.sun.jersey.server.impl.uri.rules.SubLocatorRule.invokeSubLocator(SubLocatorRule.java:135)
	at com.sun.jersey.server.impl.uri.rules.SubLocatorRule.accept(SubLocatorRule.java:89)
	at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:111)
	at com.sun.jersey.server.impl.uri.rules.SubLocatorRule.accept(SubLocatorRule.java:105)
	at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:111)
	at com.sun.jersey.server.impl.uri.rules.ResourceClassRule.accept(ResourceClassRule.java:71)
	at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:111)
	at com.sun.jersey.server.impl.uri.rules.RootResourceClassesRule.accept(RootResourceClassesRule.java:63)
	at com.sun.jersey.server.impl.application.WebApplicationImpl._handleRequest(WebApplicationImpl.java:654)
	at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:612)
	at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:603)
	at com.sun.jersey.spi.container.servlet.WebComponent.service(WebComponent.java:309)
	at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:425)
	at com.sun.jersey.spi.container.servlet.ServletContainer.doFilter(ServletContainer.java:737)
	at com.sun.jersey.spi.container.servlet.ServletContainer.doFilter(ServletContainer.java:689)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1148)
	at com.opensymphony.module.sitemesh.filter.PageFilter.parsePage(PageFilter.java:119)
	at com.opensymphony.module.sitemesh.filter.PageFilter.doFilter(PageFilter.java:55)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1148)
	at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:387)
	at org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)
	at org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:181)
	at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:765)
	at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:417)
	at org.mortbay.jetty.handler.HandlerCollection.handle(HandlerCollection.java:114)
	at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)
	at org.mortbay.jetty.Server.handle(Server.java:324)
	at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:535)
	at org.mortbay.jetty.HttpConnection$RequestHandler.headerComplete(HttpConnection.java:865)
	at org.mortbay.jetty.HttpParser.parseNext(HttpParser.java:539)
	at org.mortbay.jetty.HttpParser.parseAvailable(HttpParser.java:212)
	at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:404)
	at org.mortbay.io.nio.SelectChannelEndPoint.run(SelectChannelEndPoint.java:409)
	at org.mortbay.thread.QueuedThreadPool$PoolThread.run(QueuedThreadPool.java:520)
Caused by: java.net.URISyntaxException: Expected scheme-specific part at index 5: mock:
	at java.net.URI$Parser.fail(URI.java:2816)
	at java.net.URI$Parser.failExpecting(URI.java:2822)
	at java.net.URI$Parser.parse(URI.java:3025)
	at java.net.URI.&amp;lt;init&amp;gt;(URI.java:578)
	at org.apache.camel.util.URISupport.normalizeUri(URISupport.java:354)
	at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:365)
	... 39 more</description>
			<version>2.0-M2</version>
			<fixedVersion>2.0-M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.web.model.EndpointLink.java</file>
		</fixedFiles>
	</bug>
	<bug id="1848" opendate="2009-07-23 13:33:00" fixdate="2009-07-23 14:40:17" resolution="Fixed">
		<buginformation>
			<summary>MockEndPoint yields nullpointer due to mixed up typeconversion</summary>
			<description>MockEndpoint yields a failed unit test with very confusing message:
        resultEndpointHub.expectedHeaderReceived("portalId", 30);
Yields: ... expected &amp;lt;null&amp;gt; but got ...
Of course the expected value of null must never happen if a value is put in there</description>
			<version>2.0-M2</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mock.MockEndpointTest.java</file>
			<file type="M">org.apache.camel.processor.BatchProcessor.java</file>
			<file type="M">org.apache.camel.component.mock.MockEndpoint.java</file>
			<file type="M">org.apache.camel.processor.aggregate.DefaultAggregationCollection.java</file>
		</fixedFiles>
	</bug>
	<bug id="1844" opendate="2009-07-21 14:43:06" fixdate="2009-07-24 07:03:37" resolution="Fixed">
		<buginformation>
			<summary>Files size after simply route from file to file is smaller then the original size.</summary>
			<description>I&amp;amp;apos;ve got very simply camel route:
CamelContext context = new DefaultCamelContext();
context.addRoutes(new RouteBuilder() {
  public void configure() 
{
    from("file://" + INBOX_DIR + "?noop=false").to("file://" + OUTBOX_DIR);
  }
});
context.start();
All this route does, is to copy a file from INBOX_DIR to OUTBOX_DIR.
And everything goes fine for smaller files, but when I put something bigger into INBOX_DIR (on my machine problem starts with files bigger than ~100MB) things go wrong.
The file in OUTBOX_DIR has different size than the original one. In general it is smaller than the original (its size varies - can be 3/4 of the original, can be 1/2 etc).
With Camel 1.6.1 with noop set to "true" the file in OUTBOX was bigger than the original one (even 1,5-2 times larger !). With Camel 2.0-M2 setting noop to true or false didn&amp;amp;apos;t matter - the file in OUTBOX was smaller than the original one.
It is possible to avoid this bug, by setting delay but this is no good. To handle large files, I&amp;amp;apos;d have to set a very high value which would slow down the whole application.
I&amp;amp;apos;ve tried all possible configurations noop=true/false, readLock, readLockTimeout but without success.
Tested on both Apache Camel 1.6.1 and 2.0-M2 with similar results.
My environment:
Java: 1.6.0.14
OS: Linux, Kubuntu 9.04
Attached you will find a Maven project which exposes the bug.
Unpack it, run
mvn assembly:assembly
next run
run.sh
and copy big file to inbox dir and observe resulting file in outbox dir.
To kill the application hit CTRL+C </description>
			<version>2.0-M2</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.strategy.FileProcessStrategyFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="1849" opendate="2009-07-23 18:26:52" fixdate="2009-07-26 12:34:51" resolution="Fixed">
		<buginformation>
			<summary>CachedOutputStream not cleaning up tmp files when using file based caching</summary>
			<description>A recent feature of Camel&amp;amp;apos;s CachedOutputStream is to serialize any messages over 64k to disk. In some cases the *tmp message files are not being cleaned up. </description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStreamTest.java</file>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStream.java</file>
			<file type="M">org.apache.camel.util.FileUtil.java</file>
			<file type="M">org.apache.camel.converter.stream.StreamSourceCache.java</file>
			<file type="M">org.apache.camel.converter.stream.FileInputStreamCache.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.converter.stream.StreamCacheConverterTest.java</file>
			<file type="M">org.apache.camel.converter.stream.StreamCacheConverter.java</file>
			<file type="M">org.apache.camel.issues.CacheInputStreamInDeadLetterIssue520Test.java</file>
			<file type="M">org.apache.camel.util.IOHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="1851" opendate="2009-07-24 08:20:08" fixdate="2009-07-26 13:25:58" resolution="Fixed">
		<buginformation>
			<summary>Route JMX attributes not being updated</summary>
			<description>Some routes are not getting instrumented using JMX and we get the following WARN for those on startup;
InstrumentationLifecycleStrategy: Route has not been instrumented for endpoint: ...
It turns out that its only those routes that have an onException handler as the first processor in the route, e.g.
&amp;lt;route id="per-msg-route" errorHandlerRef="RouteErrorHandler"&amp;gt;
  &amp;lt;from uri="jms:MSG_IN"/&amp;gt;
  &amp;lt;onException&amp;gt;
    &amp;lt;exception&amp;gt;can.retry.Exception&amp;lt;/exception&amp;gt;
    &amp;lt;redeliveryPolicy ref="UnlimitedRedeliveryPolicyConfig"/&amp;gt;
    &amp;lt;handled&amp;gt;&amp;lt;constant&amp;gt;true&amp;lt;/constant&amp;gt;&amp;lt;/handled&amp;gt;
  &amp;lt;/onException&amp;gt;
  &amp;lt;bean ref="Formatter" method="formatInput"/&amp;gt;
...8&amp;lt;... 
More info and proposed fix at http://www.nabble.com/Routes-JMX-attributes-not-updated-in-2.0-M2-td24631265.html#a24639433</description>
			<version>2.0-M2</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.InstrumentationLifecycleStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="1852" opendate="2009-07-24 14:28:42" fixdate="2009-07-29 09:53:32" resolution="Fixed">
		<buginformation>
			<summary>The broker example doesn&amp;apos;t work in camel 2.0 M3</summary>
			<description>There some NPE when you run the example of loan broker which is caused by the change of CAMEL-1722.</description>
			<version>2.0-M3</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.loanbroker.queue.version.BankResponseAggregationStrategy.java</file>
			<file type="M">org.apache.camel.loanbroker.queue.version.LoanBroker.java</file>
			<file type="M">org.apache.camel.loanbroker.webservice.version.BankResponseAggregationStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="1864" opendate="2009-07-30 07:03:14" fixdate="2009-07-30 08:51:46" resolution="Fixed">
		<buginformation>
			<summary>interceptSendToEndpoint does not trigger endpoints defined in onException</summary>
			<description>The reason is that onException is initialized before interceptors</description>
			<version>2.0-M3</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.CamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.processor.SendProcessor.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
			<file type="M">org.apache.camel.model.RoutesDefinition.java</file>
			<file type="M">org.apache.camel.processor.intercept.InterceptSendToIssue.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.model.InterceptSendToEndpointDefinition.java</file>
			<file type="M">org.apache.camel.processor.intercept.FromFileInterceptSendToIssue.java</file>
		</fixedFiles>
	</bug>
	<bug id="1865" opendate="2009-07-30 11:40:27" fixdate="2009-07-30 15:32:43" resolution="Fixed">
		<buginformation>
			<summary>NPE thrown when DEBUG logging on</summary>
			<description>Stack trace;
org.apache.camel.language.bean.RuntimeBeanExpressionException: Failed to invoke method: doSplit on MySplitter due to: java.lang.NullPointerException
        at org.apache.camel.language.bean.BeanExpression.evaluate(BeanExpression.java:82)
        at org.apache.camel.language.bean.BeanExpression.evaluate(BeanExpression.java:87)
        at org.apache.camel.processor.Splitter.createProcessorExchangePairs(Splitter.java:72)
...
Caused by: java.lang.NullPointerException
        at org.apache.camel.util.MessageHelper.extractBodyForLogging(MessageHelper.java:129)
        at org.apache.camel.impl.DefaultMessage.toString(DefaultMessage.java:38)
        at java.lang.String.valueOf(String.java:2827)
        at java.lang.StringBuilder.append(StringBuilder.java:115)
        at java.util.AbstractCollection.toString(AbstractCollection.java:422)
        at java.lang.String.valueOf(String.java:2827)
        at java.lang.StringBuilder.append(StringBuilder.java:115)
        at org.apache.camel.component.bean.BeanProcessor.process(BeanProcessor.java:139)
Steps to reproduce;
1. Create simple route with splitter pattern; e.g.
&amp;lt;route&amp;gt;
	&amp;lt;from uri="jms:IN_QUEUE"/&amp;gt;
	&amp;lt;split&amp;gt;&amp;lt;method bean="MySplitter" method="doSplit"/&amp;gt;
		&amp;lt;to uri="log:route.log"/&amp;gt;
	&amp;lt;/split&amp;gt;
&amp;lt;/route&amp;gt;
2. Set DEBUG logging on for org.apache.camel classes, e.g.
log4j.logger.org.apache.camel=DEBUG
3. Fire message into route - message fails with NPE inside Camel</description>
			<version>2.0-M3</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.MessageHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="1870" opendate="2009-08-03 03:06:06" fixdate="2009-08-03 03:58:49" resolution="Fixed">
		<buginformation>
			<summary>current the consumer template does&amp;apos;t not work if define it out side of the camel context</summary>
			<description>Here is the mail thread which discuss about it[1]
[1] http://www.nabble.com/Cannot-Autowire-consumerTemplate-for-client-test-td24781739.html</description>
			<version>2.0-M1</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.CamelConsumerTemplateFactoryBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="1873" opendate="2009-08-03 12:52:36" fixdate="2009-08-03 14:17:09" resolution="Fixed">
		<buginformation>
			<summary>template , consumerTemplate, service, proxy can&amp;apos;t be set with right camel context if there are more than one camel context in the spring application context</summary>
			<description>
Current camel support to define a producer template OUTSIDE a camel context, I think it works well just like the autowire function which is provided in Spring.
If there more than two Camel context in the Spring Application context , the user should specify the camel context which the template should use.
But I have a concern that even we put the template INSIDE the camel context, the template will not be set with a right version of camel context, since we use a CamelPostProcessor to inject CamelContext.
So I did a quick test on the current Camel code and found there is a bug  if there are more one CamelContext  CamelPostProcessor will inject the last create camel context into the CamelContextAware object. 
Since it is not easy to add the camelContext referece id into the template element attribute, we&amp;amp;apos;d better just support to parser these elements inside the camel context.</description>
			<version>1.4.0</version>
			<fixedVersion>1.6.2, 2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultConsumerTemplate.java</file>
			<file type="M">org.apache.camel.spring.CamelContextAwareTest.java</file>
			<file type="M">org.apache.camel.spring.handler.CamelNamespaceHandler.java</file>
			<file type="M">org.apache.camel.spring.CamelBeanPostProcessor.java</file>
			<file type="D">org.apache.camel.spring.SpringConsumerTemplateCAMEL1870Test.java</file>
			<file type="M">org.apache.camel.spring.CamelProducerTemplateFactoryBean.java</file>
			<file type="M">org.apache.camel.spring.CamelConsumerTemplateFactoryBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="1867" opendate="2009-07-30 15:11:50" fixdate="2009-08-05 11:30:29" resolution="Fixed">
		<buginformation>
			<summary>JmsKeyFormatStrategy not used consistently and JmsMessage.getHeader() not returning correct value</summary>
			<description>On entry to a route from a JMS endpoint configured with PassthroughJmsKeyFormatStrategy the headers with underscores (_) are passed through correctly.
However, when any header value in the message is then changed, the original headers are added back into the message using the DefaultJmsKeyFormatStrategy.  For example, sending a JMS message with headers;
HEADER_1=VALUE_1
HEADER_2=VALUE_1
we do see just these two headers in the message received into the route.
However, if we then set a header value in the route, say HEADER_1=VALUE_2, we now see the headers;
HEADER.1=VALUE_1
HEADER.2=VALUE_1
HEADER_1=VALUE_2
HEADER_2=VALUE_1
For some reason in the set header process the original message headers and values get added into the message after being passed through the DefaultJmsKeyFormatStrategy.  This has the implication of unnecessary duplication of the headers.
Also, when a message header is accessed using the getHeader(key) method it also goes through the DefaultJmsKeyFormatStrategy to decode the key that is passed.  
In the example above, if after we have updated &amp;amp;apos;HEADER_1&amp;amp;apos; to &amp;amp;apos;VALUE_2&amp;amp;apos;, we do;
message.getHeader("HEADER_1") this goes through the DefaultJmsKeyFormatStrategy and actually gets executed as message.getHeader("HEADER.1") which returns VALUE_1 (wrong!).
Note: if instead we lookup the header through message.getHeaders() which returns the all headers in a Map, we can correctly access the &amp;amp;apos;HEADER_1&amp;amp;apos; key.  (Why is getHeader(key) even going through the KeyFormatStrategy anyway if setHeader() isn&amp;amp;apos;t?)</description>
			<version>2.0-M3</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsProducerWithJMSHeaderTest.java</file>
			<file type="M">org.apache.camel.component.jms.JmsConfiguration.java</file>
			<file type="M">org.apache.camel.component.jms.JmsMessage.java</file>
			<file type="M">org.apache.camel.component.jms.JmsProducer.java</file>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
			<file type="M">org.apache.camel.component.jms.JmsXMLRouteTest.java</file>
			<file type="M">org.apache.camel.component.jms.JmsSimpleRequestReplyTest.java</file>
			<file type="M">org.apache.camel.component.jms.issues.JmsPassThroughtJmsKeyFormatStrategyTest.java</file>
			<file type="M">org.apache.camel.component.jms.issues.JmsPassThroughtJmsKeyFormatStrategyUsingJmsConfigurationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1878" opendate="2009-08-05 07:37:51" fixdate="2009-08-05 12:50:21" resolution="Fixed">
		<buginformation>
			<summary>Bean component - invokes onMessage from javax.jms.MessageListener even though a specific method name have been provided</summary>
			<description>This is only an issue when your bean implements javax.jms.MessageListener and then specify a specific method to use, then Camel will still prefer to use the onMessage method.</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanProcessor.java</file>
			<file type="M">org.apache.camel.component.bean.issues.DerivedClass.java</file>
			<file type="M">org.apache.camel.component.bean.issues.BaseClass.java</file>
			<file type="M">org.apache.camel.component.bean.issues.BeanRouteToDerivedClassTest.java</file>
			<file type="M">org.apache.camel.impl.ProducerCache.java</file>
		</fixedFiles>
	</bug>
	<bug id="1882" opendate="2009-08-06 08:26:07" fixdate="2009-08-06 09:11:12" resolution="Fixed">
		<buginformation>
			<summary>Aggregator fails permanently if exception thrown from aggregation strategy</summary>
			<description>BatchSender thread in BatchProcessor doesn&amp;amp;apos;t expect any error thrown from Collection.add() method, so when it is thrown the whole thread dies and is never recovered. In Aggregator, where aggregation strategy exists such exceptions can be easily thrown from Collection.add() and can render Aggregator unusable.</description>
			<version>2.0-M3</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.BatchProcessor.java</file>
			<file type="M">org.apache.camel.processor.aggregator.AggregatorExceptionInPredicateTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1883" opendate="2009-08-06 10:41:37" fixdate="2009-08-06 12:09:41" resolution="Fixed">
		<buginformation>
			<summary>EXCEPTION_CAUGHT header should be set to exception caught</summary>
			<description>Currently whatever exception is caught in doCatch there is a EXCEPTION_CAUGHT header set to the exception that was set on the exchange itself. As doCatch() traverses causes of exception it might happen that something else is caught and something else is in EXCEPTION_CAUGHT header.</description>
			<version>2.0-M3</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.CatchProcessor.java</file>
			<file type="M">org.apache.camel.processor.TryProcessorTest.java</file>
			<file type="M">org.apache.camel.processor.TryProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="1885" opendate="2009-08-07 07:59:40" fixdate="2009-08-07 13:00:24" resolution="Fixed">
		<buginformation>
			<summary>Stream Caching is enabled by default when using CamelContextFactoryBean</summary>
			<description>According to the documentation Stream Caching should be disabled by default in Camel 2.0. The default is overriden when using CamelContextFactoryBean because of this line:
    private Boolean streamCache = Boolean.TRUE;
Unit test showing the problem:
public class DefaultStreamCachingTest {
     @Test
     public void test() throws Exception {
         ApplicationContext appContext = new ClassPathXmlApplicationContext(new String[] 
{"context.xml"}
);
         DefaultCamelContext camelContext = (DefaultCamelContext) appContext.getBean("camelContext");
         assertFalse(camelContext.isStreamCacheEnabled());
     }
}
context.xml:
&amp;lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:camel="http://camel.apache.org/schema/spring" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd"&amp;gt;
    &amp;lt;camel:camelContext id="camelContext" /&amp;gt;
&amp;lt;/beans&amp;gt;
Currently one must use:
    &amp;lt;camel:camelContext id="camelContext" streamCache="false" /&amp;gt;</description>
			<version>2.0-M3</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="1922" opendate="2009-08-20 00:38:49" fixdate="2009-08-23 03:16:45" resolution="Fixed">
		<buginformation>
			<summary>BeanEndpoint fails in the presence of bridge methods</summary>
			<description>When a message is sent to a bean: endpoint, camel searches for a method with the right signature.  If multiple methods are found, an exception is thrown.
If a have an interface like
public interface &amp;lt;T&amp;gt; I {
  T function(T arg);
}
and a class like
public class C implements I&amp;lt;Number&amp;gt; {
  Number function(Number arg) 
{
    return new Double(arg.doubleValue() * 2);
  }
}

then I can&amp;amp;apos;t use an instance of C as an endpoint.

The problem is that under the hood java has created a bridge method, and the "real" class C looks like

public class C implements I&amp;lt;Number&amp;gt; {
  Number function(Number arg) {    return new Double(arg.doubleValue() * 2);  }

  Object function(Object arg) 
{
    return function((Number) arg);
  }
}
Camel then discovers that there are two methods it could call (f(Object) and f(Number)) and throws an exception even though there&amp;amp;apos;s no real ambiguity because both methods do the same thing.
I recommend rejecting bridge methods in BeanInfo.isValidMethod with somehting like
if (method.isBridgeMethod()) return false;
Does this sound reasonable?</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
		</fixedFiles>
	</bug>
	<bug id="1917" opendate="2009-08-17 03:38:18" fixdate="2009-08-23 23:11:49" resolution="Fixed">
		<buginformation>
			<summary>DefaultPackageScanClassResolver not able to scan package in jar url</summary>
			<description>The DefaultPackageScanClassResolver seems to have problem finding packages from URL jar:file:/path/to/my.jar!/"</description>
			<version>2.0-M3</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultPackageScanClassResolver.java</file>
			<file type="M">org.apache.camel.impl.scan.DefaultPackageScanClassResolverTest.java</file>
		</fixedFiles>
		<links>
			<link type="Regression" description="breaks">2530</link>
		</links>
	</bug>
	<bug id="1927" opendate="2009-08-22 06:20:47" fixdate="2009-08-24 05:35:46" resolution="Fixed">
		<buginformation>
			<summary>FileConsumer preMove setting causes filename to be left in in progress repository.</summary>
			<description>If the FileConsumer preMove setting is used, then files are picked up the first time only, as the original file name is added to the in progress repository, whereas the new file name is removed from the in progress repository (though nothing is actually removed as the new file name is not in the in progress repository).
This causes a few problems:
i) If the maxMessagePerPoll is used, then messages not processed the first time are never picked up again.
ii) If the intention is to reprocess the same file, or a new file with the same name, then it will never be picked up again after the first time.
iii)  As the wrong file names are removed from the in progress repository, it results in a slow memory leak in the in progress repository.</description>
			<version>2.0-M3</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileOnCompletion.java</file>
		</fixedFiles>
	</bug>
	<bug id="1924" opendate="2009-08-20 13:37:15" fixdate="2009-08-24 12:28:33" resolution="Fixed">
		<buginformation>
			<summary>Unit test failures on Windows in 2.0.0 release</summary>
			<description>3 failures in camel-core that do not seem to occur on linux and mac.
Failure Details
	testCannotDeleteFile
	junit.framework.AssertionFailedError: Should have thrown an exception
org.apache.camel.component.file.strategy.GenericFileDeleteProcessStrategyTest:125
	testCacheStreamToFileAndNotCloseStream
	junit.framework.AssertionFailedError: we should have no temp file expected:&amp;lt;1&amp;gt; but was:&amp;lt;0&amp;gt;
org.apache.camel.converter.stream.CachedOutputStreamTest:117
	testRouteIsCorrectAtRuntime
	junit.framework.AssertionFailedError: expected:&amp;lt;4&amp;gt; but was:&amp;lt;1&amp;gt;
org.apache.camel.processor.ChoiceWithEndTest:39</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStreamTest.java</file>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStream.java</file>
			<file type="M">org.apache.camel.processor.ChoiceWithEndTest.java</file>
			<file type="M">org.apache.camel.component.file.strategy.GenericFileDeleteProcessStrategyTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1914" opendate="2009-08-15 13:34:16" fixdate="2009-08-25 14:02:31" resolution="Fixed">
		<buginformation>
			<summary>Xmpp consumer stops consuming after some time</summary>
			<description>Noticed after creating some more complicated routes that my xmpp consumers would stop receiving messages.  This patch sorts that out, I also improved some of the logging in the producer and consumer classes and tweaked the XmppRouteChatTest to work properly.</description>
			<version>2.0-M3</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xmpp.XmppConsumer.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppRouteChatTest.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppPrivateChatProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1934" opendate="2009-08-25 08:00:28" fixdate="2009-08-26 08:46:04" resolution="Fixed">
		<buginformation>
			<summary>Unit test failure in Windows for StreamCache. Temp file is not deleted</summary>
			<description>The temporary file is not deleted. I think the file is still open in some other stream. The problem is I have no idea how to find this place. Like in issue  	 CAMEL-1924 this only happens on windows as on unix you can delete a file even if there are open streams.
testStreamCacheToFileShouldBeDeletedInCaseOfException
	java.lang.AssertionError: There should be no files expected:&amp;lt;1&amp;gt; but was:&amp;lt;0&amp;gt;
org.apache.camel.component.jetty.HttpStreamCacheFileTest:71</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.HttpStreamCacheFileTest.java</file>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStreamTest.java</file>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStream.java</file>
		</fixedFiles>
	</bug>
	<bug id="1948" opendate="2009-08-27 07:49:06" fixdate="2009-08-27 07:50:18" resolution="Fixed">
		<buginformation>
			<summary>ServiceSupport - incorrect state after restart</summary>
			<description>This hampers restart of services by example the overhauled JMX in CAMEL-1933.
When a service was restarted it had the following incorrect state:

started = true
starting = false
stopped = true
stopping = false

The stopped should have been changed to false as its started.
</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.ServiceSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="1955" opendate="2009-08-28 12:06:34" fixdate="2009-08-28 12:24:31" resolution="Fixed">
		<buginformation>
			<summary>MessageSupport.copyFrom() doesn&amp;apos;t clean the message header and the attachments</summary>
			<description>If the we want to clean up the attachment in the pipeline processor, we will hit this bug.

 from("direct:start")
                    .process(new Processor() {
                        public void process(Exchange exchange) throws Exception {
                            exchange.getOut().copyFrom(exchange.getIn());
                            //Added the header and attachment
                            exchange.getOut().setHeader("test", "testValue");
                            exchange.getOut().addAttachment("test1.xml", new DataHandler(new FileDataSource("pom.xml")));
                        }
                    })
                    .process(new Processor() {
                        public void process(Exchange exchange) throws Exception {
                            exchange.getOut().copyFrom(exchange.getIn());
                            assertNotNull("The test attachment should not be null", exchange.getOut().getAttachment("test1.xml"));
                            assertNotNull("The test header should not be null", exchange.getOut().getHeader("test"));
                            exchange.getOut().removeAttachment("test1.xml");
                            exchange.getOut().removeHeader("test");
                        }
                    });

</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.2, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.HttpRoundtripHeaderTest.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
			<file type="M">org.apache.camel.management.DefaultEventFactory.java</file>
			<file type="M">org.apache.camel.impl.EventDrivenConsumerRoute.java</file>
			<file type="M">org.apache.camel.impl.MessageSupport.java</file>
			<file type="M">org.apache.camel.spi.EventFactory.java</file>
			<file type="M">org.apache.camel.processor.RedeliveryErrorHandler.java</file>
			<file type="M">org.apache.camel.impl.DefaultMessage.java</file>
			<file type="M">org.apache.camel.processor.PipelineTest.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="is depended upon by">626</link>
		</links>
	</bug>
	<bug id="1957" opendate="2009-08-29 07:32:49" fixdate="2009-08-29 07:41:20" resolution="Fixed">
		<buginformation>
			<summary>The construction method of SourceCache is wrong  </summary>
			<description>The construction of SourceCache is wrong , it will cause the NPE when you enable the stream cache.

  public SourceCache(String data) {
        new StringSource(data);
        // It should be changed to 
        // super(data);
    }

</description>
			<version>2.0-M2</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.stream.SourceCache.java</file>
			<file type="M">org.apache.camel.converter.stream.StreamCacheConverterTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1960" opendate="2009-08-29 11:27:32" fixdate="2009-08-29 12:22:10" resolution="Fixed">
		<buginformation>
			<summary>Enricher - AggregationStrategy - Problem with preparing logic</summary>
			<description>The ExchangeHelper.prepareAggregation method moves the message to IN to avoid confusing end users whether what they are looking for is on either IN or OUT.
Hover we some recent changes in MessageSupport to clear some headers it could cause problems as it was in fact the same message being copied from OUT to IN.
What it should do instead is to move it instead of using copy mechanism.
</description>
			<version>2.1.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.HttpRoundtripHeaderTest.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
			<file type="M">org.apache.camel.management.DefaultEventFactory.java</file>
			<file type="M">org.apache.camel.impl.EventDrivenConsumerRoute.java</file>
			<file type="M">org.apache.camel.impl.MessageSupport.java</file>
			<file type="M">org.apache.camel.spi.EventFactory.java</file>
			<file type="M">org.apache.camel.processor.RedeliveryErrorHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1940" opendate="2009-08-26 11:43:46" fixdate="2009-08-31 11:43:29" resolution="Fixed">
		<buginformation>
			<summary>pollEnrich does not work with queue and quartz or timer endpoints</summary>
			<description>Hi,
In the following route example, the pollenrich processor is never called

            &amp;lt;camel:from uri="quartz://x3sReporting/clientError?cron=0+0/5+9-18+?+*+MON-FRI"/&amp;gt;
            &amp;lt;camel:pollEnrich uri="queuingservice:x3s:reporting" strategyRef="queueAggregator"/&amp;gt;

            &amp;lt;camel:transacted ref="PROPAGATION_REQUIRED_NEW" /&amp;gt;
            &amp;lt;camel:choice&amp;gt;
                &amp;lt;camel:when&amp;gt;
                    &amp;lt;camel:simple&amp;gt;${body} != null&amp;lt;/camel:simple&amp;gt;
                    &amp;lt;camel:doTry&amp;gt;
                        &amp;lt;camel:marshal ref="csvAuditBindyDataFormat" /&amp;gt;


Definiton of the AggregationStrategy class used

public class QueueAggregator implements AggregationStrategy {
   
    private static final transient Log LOG = LogFactory.getLog(QueueAggregator.class);

    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        if (newExchange == null) {
            LOG.info("Old object received (null exchange) : " + oldExchange.getIn().getBody().toString());
            return oldExchange;
        }
        Object oldBody = oldExchange.getIn().getBody();
        LOG.info("Old object received : " + oldBody.toString());
        Object newBody = newExchange.getIn().getBody();
        LOG.info("New object received : " + newBody.toString());
        oldExchange.getIn().setBody(newBody);
        return oldExchange;
    }
}


Unfortunately, the aggregator is not called (no info trace in the LOG) and the body object send to the endpoint (marshall) is of type org.quartz.JobDetail

11:10:02,703 | INFO  | heduler_Worker-1 | TraceInterceptor                 | rg.apache.camel.processor.Logger   88 | ID-dell-charles-3372-1251127950838-0-10 &amp;gt;&amp;gt;&amp;gt; from(quartz://x3sReporting/clientError?cron=0+0%2F5+9-18+%3F+*+MON-FRI) --&amp;gt; ref:PROPAGATION_REQUIRED_NEW, Pattern:InOnly, Headers:{triggerGroup=x3sReporting, jobInstance=org.apache.camel.component.quartz.CamelJob@1264f27, nextFireTime=Tue Aug 25 11:15:00 CEST 2009, previousFireTime=null, jobDetail=JobDetail &amp;amp;apos;DEFAULT.quartz://x3sReporting/clientError?cron=0+0%2F5+9-18+%3F+*+MON-FRI&amp;amp;apos;:  jobClass: &amp;amp;apos;org.apache.camel.component.quartz.CamelJob isStateful: false isVolatile: false isDurable: false requestsRecovers: false, triggerName=clientError, trigger=Trigger &amp;amp;apos;x3sReporting.clientError&amp;amp;apos;:  triggerClass: &amp;amp;apos;org.quartz.CronTrigger isVolatile: false calendar: &amp;amp;apos;null&amp;amp;apos; misfireInstruction: 0 nextFireTime: Tue Aug 25 11:15:00 CEST 2009, scheduler=org.quartz.impl.StdScheduler@16975d, jobRunTime=-1, scheduledFireTime=Tue Aug 25 11:10:00 CEST 2009, result=null, calendar=null, mergedJobDataMap=org.quartz.JobDataMap@ccc462dc, refireCount=0, fireTime=Tue Aug 25 11:10:00 CEST 2009}, BodyType:org.quartz.JobDetail, Body:JobDetail &amp;amp;apos;DEFAULT.quartz://x3sReporting/clientError?cron=0+0%2F5+9-18+%3F+*+MON-FRI&amp;amp;apos;:  jobClass: &amp;amp;apos;org.apache.camel.component.quartz.CamelJob isStateful: false isVolatile: false isDurable: false requestsRecovers: false
11:10:02,718 | INFO  | heduler_Worker-1 | TraceInterceptor                 | rg.apache.camel.processor.Logger   88 | ID-dell-charles-3372-1251127950838-0-10 &amp;gt;&amp;gt;&amp;gt; ref:PROPAGATION_REQUIRED_NEW --&amp;gt; Choice, Pattern:InOnly, Headers:{triggerGroup=x3sReporting, jobInstance=org.apache.camel.component.quartz.CamelJob@1264f27, nextFireTime=Tue Aug 25 11:15:00 CEST 2009, previousFireTime=null, jobDetail=JobDetail &amp;amp;apos;DEFAULT.quartz://x3sReporting/clientError?cron=0+0%2F5+9-18+%3F+*+MON-FRI&amp;amp;apos;:  jobClass: &amp;amp;apos;org.apache.camel.component.quartz.CamelJob isStateful: false isVolatile: false isDurable: false requestsRecovers: false, triggerName=clientError, trigger=Trigger &amp;amp;apos;x3sReporting.clientError&amp;amp;apos;:  triggerClass: &amp;amp;apos;org.quartz.CronTrigger isVolatile: false calendar: &amp;amp;apos;null&amp;amp;apos; misfireInstruction: 0 nextFireTime: Tue Aug 25 11:15:00 CEST 2009, scheduler=org.quartz.impl.StdScheduler@16975d, jobRunTime=-1, scheduledFireTime=Tue Aug 25 11:10:00 CEST 2009, result=null, calendar=null, mergedJobDataMap=org.quartz.JobDataMap@ccc462dc, refireCount=0, fireTime=Tue Aug 25 11:10:00 CEST 2009}, BodyType:org.quartz.JobDetail, Body:JobDetail &amp;amp;apos;DEFAULT.quartz://x3sReporting/clientError?cron=0+0%2F5+9-18+%3F+*+MON-FRI&amp;amp;apos;:  jobClass: &amp;amp;apos;org.apache.camel.component.quartz.CamelJob isStateful: false isVolatile: false isDurable: false requestsRecovers: false
11:10:02,734 | INFO  | heduler_Worker-1 | TraceInterceptor                 | rg.apache.camel.processor.Logger   88 | ID-dell-charles-3372-1251127950838-0-10 &amp;gt;&amp;gt;&amp;gt; Choice --&amp;gt; Try, Pattern:InOnly, Headers:{triggerGroup=x3sReporting, jobInstance=org.apache.camel.component.quartz.CamelJob@1264f27, nextFireTime=Tue Aug 25 11:15:00 CEST 2009, previousFireTime=null, jobDetail=JobDetail &amp;amp;apos;DEFAULT.quartz://x3sReporting/clientError?cron=0+0%2F5+9-18+%3F+*+MON-FRI&amp;amp;apos;:  jobClass: &amp;amp;apos;org.apache.camel.component.quartz.CamelJob isStateful: false isVolatile: false isDurable: false requestsRecovers: false, triggerName=clientError, trigger=Trigger &amp;amp;apos;x3sReporting.clientError&amp;amp;apos;:  triggerClass: &amp;amp;apos;org.quartz.CronTrigger isVolatile: false calendar: &amp;amp;apos;null&amp;amp;apos; misfireInstruction: 0 nextFireTime: Tue Aug 25 11:15:00 CEST 2009, scheduler=org.quartz.impl.StdScheduler@16975d, jobRunTime=-1, scheduledFireTime=Tue Aug 25 11:10:00 CEST 2009, result=null, calendar=null, mergedJobDataMap=org.quartz.JobDataMap@ccc462dc, refireCount=0, fireTime=Tue Aug 25 11:10:00 CEST 2009}, BodyType:org.quartz.JobDetail, Body:JobDetail &amp;amp;apos;DEFAULT.quartz://x3sReporting/clientError?cron=0+0%2F5+9-18+%3F+*+MON-FRI&amp;amp;apos;:  jobClass: &amp;amp;apos;org.apache.camel.component.quartz.CamelJob isStateful: false isVolatile: false isDurable: false requestsRecovers: false
11:10:02,734 | INFO  | heduler_Worker-1 | TraceInterceptor                 | rg.apache.camel.processor.Logger   88 | ID-dell-charles-3372-1251127950838-0-10 &amp;gt;&amp;gt;&amp;gt; Try --&amp;gt;, Pattern:InOnly, Headers:{triggerGroup=x3sReporting, jobInstance=org.apache.camel.component.quartz.CamelJob@1264f27, nextFireTime=Tue Aug 25 11:15:00 CEST 2009, previousFireTime=null, jobDetail=JobDetail &amp;amp;apos;DEFAULT.quartz://x3sReporting/clientError?cron=0+0%2F5+9-18+%3F+*+MON-FRI&amp;amp;apos;:  jobClass: &amp;amp;apos;org.apache.camel.component.quartz.CamelJob isStateful: false isVolatile: false isDurable: false requestsRecovers: false, triggerName=clientError, trigger=Trigger &amp;amp;apos;x3sReporting.clientError&amp;amp;apos;:  triggerClass: &amp;amp;apos;org.quartz.CronTrigger isVolatile: false calendar: &amp;amp;apos;null&amp;amp;apos; misfireInstruction: 0 nextFireTime: Tue Aug 25 11:15:00 CEST 2009, scheduler=org.quartz.impl.StdScheduler@16975d, jobRunTime=-1, scheduledFireTime=Tue Aug 25 11:10:00 CEST 2009, result=null, calendar=null, mergedJobDataMap=org.quartz.JobDataMap@ccc462dc, refireCount=0, fireTime=Tue Aug 25 11:10:00 CEST 2009}, BodyType:org.quartz.JobDetail, Body:JobDetail &amp;amp;apos;DEFAULT.quartz://x3sReporting/clientError?cron=0+0%2F5+9-18+%3F+*+MON-FRI&amp;amp;apos;:  jobClass: &amp;amp;apos;org.apache.camel.component.quartz.CamelJob isStateful: false isVolatile: false isDurable: false requestsRecovers: false
11:10:03,171 | INFO  | heduler_Worker-1 | TraceInterceptor                 | rg.apache.camel.processor.Logger  166 | ID-dell-charles-3372-1251127950838-0-10 &amp;gt;&amp;gt;&amp;gt; Try --&amp;gt;, Pattern:InOnly, Headers:{triggerGroup=x3sReporting, jobInstance=org.apache.camel.component.quartz.CamelJob@1264f27, nextFireTime=Tue Aug 25 11:15:00 CEST 2009, previousFireTime=null, jobDetail=JobDetail &amp;amp;apos;DEFAULT.quartz://x3sReporting/clientError?cron=0+0%2F5+9-18+%3F+*+MON-FRI&amp;amp;apos;:  jobClass: &amp;amp;apos;org.apache.camel.component.quartz.CamelJob isStateful: false isVolatile: false isDurable: false requestsRecovers: false, triggerName=clientError, trigger=Trigger &amp;amp;apos;x3sReporting.clientError&amp;amp;apos;:  triggerClass: &amp;amp;apos;org.quartz.CronTrigger isVolatile: false calendar: &amp;amp;apos;null&amp;amp;apos; misfireInstruction: 0 nextFireTime: Tue Aug 25 11:15:00 CEST 2009, scheduler=org.quartz.impl.StdScheduler@16975d, jobRunTime=-1, scheduledFireTime=Tue Aug 25 11:10:00 CEST 2009, result=null, calendar=null, mergedJobDataMap=org.quartz.JobDataMap@ccc462dc, refireCount=0, fireTime=Tue Aug 25 11:10:00 CEST 2009}, BodyType:org.quartz.JobDetail, Body:JobDetail &amp;amp;apos;DEFAULT.quartz://x3sReporting/clientError?cron=0+0%2F5+9-18+%3F+*+MON-FRI&amp;amp;apos;:  jobClass: &amp;amp;apos;org.apache.camel.component.quartz.CamelJob isStateful: false isVolatile: false isDurable: false requestsRecovers: false, Exception: java.lang.ClassCastException: org.quartz.JobDetail
11:10:03,171 | INFO  | heduler_Worker-1 | TraceInterceptor                 | rg.apache.camel.processor.Logger   88 | ID-dell-charles-3372-1251127950838-0-11 &amp;gt;&amp;gt;&amp;gt;  --&amp;gt; log://com.xpectis.x3s?level=INFO&amp;amp;multiline=true&amp;amp;showCaughtException=true&amp;amp;showException=true&amp;amp;showStackTrace=true, Pattern:InOnly, Headers:{calendar=null, scheduledFireTime=Tue Aug 25 11:10:00 CEST 2009, trigger=Trigger &amp;amp;apos;x3sReporting.clientError&amp;amp;apos;:  triggerClass: &amp;amp;apos;org.quartz.CronTrigger isVolatile: false calendar: &amp;amp;apos;null&amp;amp;apos; misfireInstruction: 0 nextFireTime: Tue Aug 25 11:15:00 CEST 2009, triggerGroup=x3sReporting, previousFireTime=null, jobRunTime=-1, jobDetail=JobDetail &amp;amp;apos;DEFAULT.quartz://x3sReporting/clientError?cron=0+0%2F5+9-18+%3F+*+MON-FRI&amp;amp;apos;:  jobClass: &amp;amp;apos;org.apache.camel.component.quartz.CamelJob isStateful: false isVolatile: false isDurable: false requestsRecovers: false, result=null, triggerName=clientError, fireTime=Tue Aug 25 11:10:00 CEST 2009, mergedJobDataMap=org.quartz.JobDataMap@ccc462dc, jobInstance=org.apache.camel.component.quartz.CamelJob@1264f27, scheduler=org.quartz.impl.StdScheduler@16975d, refireCount=0, nextFireTime=Tue Aug 25 11:15:00 CEST 2009}, BodyType:org.quartz.JobDetail, Body:JobDetail &amp;amp;apos;DEFAULT.quartz://x3sReporting/clientError?cron=0+0%2F5+9-18+%3F+*+MON-FRI&amp;amp;apos;:  jobClass: &amp;amp;apos;org.apache.camel.component.quartz.CamelJob isStateful: false isVolatile: false isDurable: false requestsRecovers: false
11:10:03,187 | INFO  | heduler_Worker-1 | x3s                              | rg.apache.camel.processor.Logger   88 | Exchange[
, BodyType:org.quartz.JobDetail
, Body:JobDetail &amp;amp;apos;DEFAULT.quartz://x3sReporting/clientError?cron=0+0%2F5+9-18+%3F+*+MON-FRI&amp;amp;apos;:  jobClass: &amp;amp;apos;org.apache.camel.component.quartz.CamelJob isStateful: false isVolatile: false isDurable: false requestsRecovers: false
, CaughtExceptionType:java.lang.ClassCastException, CaughtExceptionMessage:org.quartz.JobDetail, StackTrace:java.lang.ClassCastException: org.quartz.JobDetail
    at org.apache.camel.dataformat.bindy.csv.BindyCsvDataFormat.marshal(BindyCsvDataFormat.java:60)

</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsPollingConsumerTest.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
			<file type="M">org.apache.camel.processor.PollEnricher.java</file>
			<file type="M">org.apache.camel.model.SortDefinition.java</file>
			<file type="M">org.apache.camel.component.jms.JmsPollingConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1982" opendate="2009-09-02 17:45:15" fixdate="2009-09-02 17:49:14" resolution="Fixed">
		<buginformation>
			<summary>JMSBinding needs to be able to deal with an null endpoint</summary>
			<description>migrating activemq from 2.0-M2 to 2.0.0 some tests fail with internal NPE - problem is activemq camel uses JMSBinding() no arg creation and some of the methods do not check for a null endpoint.</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="1983" opendate="2009-09-03 04:07:48" fixdate="2009-09-07 02:24:17" resolution="Fixed">
		<buginformation>
			<summary>camel-cxf should let users to set out SOAP headers</summary>
			<description>User reported trouble setting out SOAP headers in 1.x 
http://www.nabble.com/setting-soap-headers-in-camel-cxf-router-td25068148.html#a25068148
We should also test/fix it in 2.x as well as adding documentation on how to set/get SOAP headers in POJO and PAYLOAD modes.</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.soap.headers.CxfMessageHeadersRelayTest.java</file>
			<file type="M">org.apache.camel.component.cxf.soap.headers.HeaderTesterImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="1965" opendate="2009-08-31 15:05:48" fixdate="2009-09-07 06:43:41" resolution="Fixed">
		<buginformation>
			<summary>onException does not work correctly when used in a transacted route and exception is not send to the bean component called</summary>
			<description>Hi,
When onException is used within a transacted route, it does not work. With the following route, the onException process does not propagate information to the from endpoint (in my case : file component). So, when X3Sexception occurs, the bean component is called where record is created in an Audit table, error message is put in a reporting queue BUT the file could not be renamed and move to temp directory. In consequence, the file is reprocessed continuously !!!!!

Route
&amp;lt;camel:route errorHandlerRef="txErrorHandlerReqNew"&amp;gt;
	&amp;lt;camel:from ref="fileClientEndpoint" /&amp;gt;
	&amp;lt;camel:transacted ref="PROPAGATION_REQUIRED_NEW" /&amp;gt;
		
         &amp;lt;camel:onException&amp;gt;
	       	&amp;lt;camel:exception&amp;gt;com.xpectis.x3s.exception.X3SClientException&amp;lt;/camel:exception&amp;gt;
		&amp;lt;camel:bean ref="serviceHelper" method="processException" /&amp;gt;
		&amp;lt;camel:to ref="queueReportingEndpoint" /&amp;gt;
           &amp;lt;/camel:onException&amp;gt;
	
	&amp;lt;camel:onException&amp;gt;
		&amp;lt;camel:exception&amp;gt;java.lang.Exception&amp;lt;/camel:exception&amp;gt;
		&amp;lt;camel:to uri="log:com.xpectis.x3s?level=INFO&amp;amp;amp;multiline=true&amp;amp;amp;showException=true&amp;amp;amp;showCaughtException=true&amp;amp;amp;showStackTrace=true" /&amp;gt;
		&amp;lt;camel:rollback/&amp;gt;
    &amp;lt;/camel:onException&amp;gt;



Log

16:51:12,896 | INFO  | 9: FileComponent | TraceInterceptor                 | rg.apache.camel.processor.Logger   88 | ID-dell-charles-2415-1251709696459-0-85 &amp;gt;&amp;gt;&amp;gt; from(file://d:/temp/data/oinp/?delay=15000&amp;amp;move=d%3A%2Ftemp%2Fdata%2Foinp%2Fbackup%2F%24%7Bdate%3Anow%3AyyyyMMdd%7D%2F%24%7Bfile%3Aname.noext%7D.bak&amp;amp;moveFailed=d%3A%2Ftemp%2Fdata%2Foinp%2Ferror%2F%2F%24%7Bdate%3Anow%3AyyyyMMdd%7D%2F%24%7Bfile%3Aname.noext%7D.error) --&amp;gt; ref:PROPAGATION_REQUIRED_NEW, Pattern:InOnly, Headers:{CamelFileNameOnly=OINP_Example.csv, CamelFileLastModified=Mon Jul 27 16:33:12 CEST 2009, CamelFileAbsolute=true, CamelFileLength=892, CamelFileName=OINP_Example.csv, CamelFileParent=d:\temp\data\oinp, CamelFilePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileRelativePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileAbsolutePath=d:\temp\data\oinp\OINP_Example.csv}, BodyType:org.apache.camel.component.file.GenericFile, Body:ORD_REF_ID, ...

16:51:12,912 | INFO  | 9: FileComponent | TraceInterceptor                 | rg.apache.camel.processor.Logger   88 | ID-dell-charles-2415-1251709696459-0-85 &amp;gt;&amp;gt;&amp;gt; ref:PROPAGATION_REQUIRED_NEW --&amp;gt; ref:PROPAGATION_REQUIRED_NEW, Pattern:InOnly, Headers:{CamelFileNameOnly=OINP_Example.csv, CamelFileLastModified=Mon Jul 27 16:33:12 CEST 2009, CamelFileAbsolute=true, CamelFileLength=892, CamelFileName=OINP_Example.csv, CamelFileParent=d:\temp\data\oinp, CamelFilePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileRelativePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileAbsolutePath=d:\temp\data\oinp\OINP_Example.csv}, BodyType:org.apache.camel.component.file.GenericFile, Body:ORD_REF_ID,...
16:51:12,912 | INFO  | 9: FileComponent | TraceInterceptor                 | rg.apache.camel.processor.Logger   88 | ID-dell-charles-2415-1251709696459-0-85 &amp;gt;&amp;gt;&amp;gt; ref:PROPAGATION_REQUIRED_NEW --&amp;gt; OnException, Pattern:InOnly, Headers:{CamelFileNameOnly=OINP_Example.csv, CamelFileLastModified=Mon Jul 27 16:33:12 CEST 2009, CamelFileAbsolute=true, CamelFileLength=892, CamelFileName=OINP_Example.csv, CamelFileParent=d:\temp\data\oinp, CamelFilePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileRelativePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileAbsolutePath=d:\temp\data\oinp\OINP_Example.csv}, BodyType:org.apache.camel.component.file.GenericFile, Body:ORD_REF_ID,...
16:51:12,928 | INFO  | 9: FileComponent | TraceInterceptor                 | rg.apache.camel.processor.Logger   88 | ID-dell-charles-2415-1251709696459-0-85 &amp;gt;&amp;gt;&amp;gt; OnException --&amp;gt;, Pattern:InOnly, Headers:{CamelFileNameOnly=OINP_Example.csv, CamelFileLastModified=Mon Jul 27 16:33:12 CEST 2009, CamelFileAbsolute=true, CamelFileLength=892, CamelFileName=OINP_Example.csv, CamelFileParent=d:\temp\data\oinp, CamelFilePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileRelativePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileAbsolutePath=d:\temp\data\oinp\OINP_Example.csv}, BodyType:org.apache.camel.component.file.GenericFile, Body:ORD_REF_ID,...
16:51:12,928 | INFO  | 9: FileComponent | ServiceHelper                    | ctis.x3s.core.util.ServiceHelper 1033 | ###### processException ######
16:51:12,928 | INFO  | 9: FileComponent | ServiceHelper                    | ctis.x3s.core.util.ServiceHelper 1046 | #### Exception received was null so create a dummy exception !
16:51:12,928 | INFO  | 9: FileComponent | ServiceHelper                    | ctis.x3s.core.util.ServiceHelper 1054 | &amp;gt;&amp;gt;&amp;gt;processException AUDIT:E9998:Error:ERR
16:51:12,975 | INFO  | 9: FileComponent | TraceInterceptor                 | rg.apache.camel.processor.Logger   88 | ID-dell-charles-2415-1251709696459-0-85 &amp;gt;&amp;gt;&amp;gt;  --&amp;gt; queuingservice://x3s:reporting, Pattern:InOnly, Headers:{CamelFileLastModified=Mon Jul 27 16:33:12 CEST 2009, CamelFilePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileLength=892, CamelFileAbsolutePath=d:\temp\data\oinp\OINP_Example.csv, CamelBeanMethodName=null, CamelFileNameOnly=OINP_Example.csv, CamelFileAbsolute=true, CamelBeanMultiParameterArray=false, CamelFileName=OINP_Example.csv, CamelFileRelativePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileParent=d:\temp\data\oinp}, BodyType:org.apache.camel.component.file.GenericFile, Body:ORD_REF_ID,
16:51:13,068 | INFO  | 9: FileComponent | TraceInterceptor                 | rg.apache.camel.processor.Logger   88 | ID-dell-charles-2415-1251709696459-0-85 &amp;gt;&amp;gt;&amp;gt; queuingservice://x3s:reporting --&amp;gt; ref:PROPAGATION_REQUIRED_NEW, Pattern:InOnly, Headers:{CamelFileAbsolute=true, CamelFileLength=892, CamelBeanMethodName=null, CamelFileName=OINP_Example.csv, CamelFileLastModified=Mon Jul 27 16:33:12 CEST 2009, CamelFileAbsolutePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileRelativePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileNameOnly=OINP_Example.csv, CamelBeanMultiParameterArray=false, CamelFilePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileParent=d:\temp\data\oinp}, BodyType:org.apache.camel.component.file.GenericFile, Body:ORD_REF_ID,...
16:51:13,068 | INFO  | 9: FileComponent | TraceInterceptor                 | rg.apache.camel.processor.Logger   88 | ID-dell-charles-2415-1251709696459-0-85 &amp;gt;&amp;gt;&amp;gt; ref:PROPAGATION_REQUIRED_NEW --&amp;gt; OnException, Pattern:InOnly, Headers:{CamelFileAbsolute=true, CamelFileLength=892, CamelBeanMethodName=null, CamelFileName=OINP_Example.csv, CamelFileLastModified=Mon Jul 27 16:33:12 CEST 2009, CamelFileAbsolutePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileRelativePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileNameOnly=OINP_Example.csv, CamelBeanMultiParameterArray=false, CamelFilePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileParent=d:\temp\data\oinp}, BodyType:org.apache.camel.component.file.GenericFile, Body:ORD_REF_ID,...
16:51:13,084 | INFO  | 9: FileComponent | TraceInterceptor                 | rg.apache.camel.processor.Logger   88 | ID-dell-charles-2415-1251709696459-0-85 &amp;gt;&amp;gt;&amp;gt; OnException --&amp;gt; log://com.xpectis.x3s?level=INFO&amp;amp;multiline=true&amp;amp;showCaughtException=true&amp;amp;showException=true&amp;amp;showStackTrace=true, Pattern:InOnly, Headers:{CamelFileAbsolute=true, CamelFileLength=892, CamelBeanMethodName=null, CamelFileName=OINP_Example.csv, CamelFileLastModified=Mon Jul 27 16:33:12 CEST 2009, CamelFileAbsolutePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileRelativePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileNameOnly=OINP_Example.csv, CamelBeanMultiParameterArray=false, CamelFilePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileParent=d:\temp\data\oinp}, BodyType:org.apache.camel.component.file.GenericFile, Body:ORD_REF_ID,...
16:51:13,084 | INFO  | 9: FileComponent | x3s                              | rg.apache.camel.processor.Logger   88 | Exchange[
, BodyType:org.apache.camel.component.file.GenericFile
, Body:ORD_REF_ID,...
16:51:13,084 | INFO  | 9: FileComponent | TraceInterceptor                 | rg.apache.camel.processor.Logger   88 | ID-dell-charles-2415-1251709696459-0-85 &amp;gt;&amp;gt;&amp;gt; log://com.xpectis.x3s?level=INFO&amp;amp;multiline=true&amp;amp;showCaughtException=true&amp;amp;showException=true&amp;amp;showStackTrace=true --&amp;gt; Rollback, Pattern:InOnly, Headers:{CamelFileName=OINP_Example.csv, CamelBeanMethodName=null, CamelBeanMultiParameterArray=false, CamelFileParent=d:\temp\data\oinp, CamelFileNameOnly=OINP_Example.csv, CamelFileAbsolutePath=d:\temp\data\oinp\OINP_Example.csv, CamelFilePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileRelativePath=d:\temp\data\oinp\OINP_Example.csv, CamelFileLastModified=Mon Jul 27 16:33:12 CEST 2009, CamelFileAbsolute=true, CamelFileLength=892}, BodyType:org.apache.camel.component.file.GenericFile, Body:ORD_REF_ID,...
16:51:13,100 | ERROR | 9: FileComponent | GenericFileOnCompletion          | rg.apache.camel.processor.Logger  202 | org.apache.camel.RollbackExchangeException: Intended rollback on the exchange: Exchange[GenericFileMessage with file: GenericFile[d:\temp\data\oinp\OINP_Example.csv]]
16:51:13,100 | WARN  | 9: FileComponent | GenericFileOnCompletion          | ent.file.GenericFileOnCompletion  142 | Rollback file strategy: org.apache.camel.component.file.strategy.GenericFileRenameProcessStrategy@29e26 for file: GenericFile[d:\temp\data\oinp\OINP_Example.csv]
16:51:13,100 | ERROR | 9: FileComponent | GenericFileOnCompletion          | rg.apache.camel.processor.Logger  248 | Cannot rename file: GenericFile[d:\temp\data\oinp\OINP_Example.csv] to: GenericFile[d:\temp\data\oinp\error\\20090831\OINP_Example.error]
org.apache.camel.component.file.GenericFileOperationFailedException: Cannot rename file: GenericFile[d:\temp\data\oinp\OINP_Example.csv] to: GenericFile[d:\temp\data\oinp\error\\20090831\OINP_Example.error]
	at org.apache.camel.component.file.strategy.GenericFileRenameProcessStrategy.renameFile(GenericFileRenameProcessStrategy.java:96)
	at org.apache.camel.component.file.strategy.GenericFileRenameProcessStrategy.rollback(GenericFileRenameProcessStrategy.java:61)
	at org.apache.camel.component.file.GenericFileOnCompletion.processStrategyRollback(GenericFileOnCompletion.java:145)
	at org.apache.camel.component.file.GenericFileOnCompletion.onCompletion(GenericFileOnCompletion.java:95)
	at org.apache.camel.component.file.GenericFileOnCompletion.onFailure(GenericFileOnCompletion.java:58)
	at org.apache.camel.impl.DefaultUnitOfWork.done(DefaultUnitOfWork.java:126)



REMARK : 

Exception object is not received by the bean component

but everything works fine if the route is defined like this 

		&amp;lt;camel:route&amp;gt;
			&amp;lt;camel:from ref="fileClientEndpoint" /&amp;gt;

		    &amp;lt;camel:onException&amp;gt;
	        	&amp;lt;camel:exception&amp;gt;com.xpectis.x3s.exception.X3SClientException&amp;lt;/camel:exception&amp;gt;
				&amp;lt;camel:bean ref="serviceHelper" method="processException" /&amp;gt;
				&amp;lt;camel:to ref="queueReportingEndpoint" /&amp;gt;
            &amp;lt;/camel:onException&amp;gt;
			
			&amp;lt;camel:onException&amp;gt;
				&amp;lt;camel:exception&amp;gt;java.lang.Exception&amp;lt;/camel:exception&amp;gt;
				&amp;lt;camel:to uri="log:com.xpectis.x3s?level=INFO&amp;amp;amp;multiline=true&amp;amp;amp;showException=true&amp;amp;amp;showCaughtException=true&amp;amp;amp;showStackTrace=true" /&amp;gt;
		    &amp;lt;/camel:onException&amp;gt;

</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.component.file.FileOperations.java</file>
			<file type="M">org.apache.camel.CamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="1997" opendate="2009-09-08 22:56:20" fixdate="2009-09-09 11:30:05" resolution="Fixed">
		<buginformation>
			<summary>PackageScanDefinition missing public setter methods making it difficult to configure CamelContext via CamelContextFactoryBean using regular Spring definition</summary>
			<description>In order to use spring features like "depends-on" and PropertyPlaceholderConfigure, it is desirable to configure the CamelContext using the standard Spring boolean definition (bean and property tags, etc), instead of the shortcut xbean style definition (&amp;lt;camelContext&amp;gt; tag).
However, the org.apache.camel.spring.CamelContextFactoryBean, which is typically used to configure the CamelContext bean, uses the org.apache.camel.model.PackageScanDefinition class to hold the package scanning information. This class does not have any public setter for its private properties and can only be configured via xbean. This makes it very hard to configure the CamelContext bean using the standard Spring bean definition. Please add the public setters to this class so it can be used by Spring directly.
At present, a workaround is to implement a subclass of the org.apache.camel.model.PackageScanDefinition to add the missing setters. A sample Spring definition would look like this:
    &amp;lt;bean id="camel" class="org.apache.camel.spring.CamelContextFactoryBean" depends-on="my-other-bean"&amp;gt;
        &amp;lt;property name="trace" value="false"/&amp;gt;
        &amp;lt;property name="packageScan"&amp;gt;
            &amp;lt;bean class="com.mypackage.CamelPackageScanDefinition"&amp;gt;
                &amp;lt;property name="packageList"&amp;gt;&amp;lt;value&amp;gt;$
{route.packageScan}
&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;
            &amp;lt;/bean&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;
    &amp;lt;bean id="template" class="org.apache.camel.spring.CamelProducerTemplateFactoryBean"&amp;gt;
        &amp;lt;property name="camelContext" ref="camel"/&amp;gt;
    &amp;lt;/bean&amp;gt;
In the above sample, the CamelPackageScanDefinition is the custom subclass.</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.PackageScanDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="1963" opendate="2009-08-31 07:03:23" fixdate="2009-09-10 08:27:39" resolution="Fixed">
		<buginformation>
			<summary>Graceful shutdown problem</summary>
			<description>While running camel-example-spring-jms in 2.0M3, I&amp;amp;apos;ve noticed that GracefulShutdownService can&amp;amp;apos;t stop Camel. It calls
    Main.getInstance().stop();
but this call blocks and never returns. With enabled debug logging for org.springframework.jms, console outputs
[aultMessageListenerContainer-1] efaultMessageListenerContainer DEBUG Waiting for shutdown of message listener invokers
[aultMessageListenerContainer-1] efaultMessageListenerContainer DEBUG Still waiting for shutdown of 1 message listener invokers
Related forum thread:
http://www.nabble.com/Garceful-shutdown-bug-in-2.0M3--td25113519.html
Dado</description>
			<version>2.0-M3</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.processor.RedeliveryPolicy.java</file>
			<file type="M">org.apache.camel.impl.MainSupport.java</file>
			<file type="M">org.apache.camel.spring.Main.java</file>
			<file type="M">org.apache.camel.processor.Pipeline.java</file>
			<file type="M">org.apache.camel.impl.ServiceSupport.java</file>
			<file type="M">org.apache.camel.processor.RedeliveryErrorHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="2002" opendate="2009-09-11 02:11:18" fixdate="2009-09-11 02:54:45" resolution="Fixed">
		<buginformation>
			<summary>The matchOnUriPrefix option should set per endpoint</summary>
			<description>Current camel-http component&amp;amp;apos;s  matchOnUriPrefix option is set to the component level. If we have the route like this

    from("jetty://http://localhost:9000/hello?matchOnUriPerfix").to(...)
    from("jetty://http://localhost:9000/test").to(...)   


You can&amp;amp;apos;t access the service with http://localhost:9000/helloworld, since the Jetty compnent&amp;amp;apos;s matchOnUriPrefix is override by last route rule.
So we need to set the matchOnUriPrefix per Jetty endpoint.
The fix will also effect to the camel-servlet component 
</description>
			<version>2.0-M1</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.servlet.CamelHttpTransportServlet.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.servlet.HttpClientRouteTest.java</file>
			<file type="M">org.apache.camel.component.jetty.CamelContinuationServlet.java</file>
			<file type="M">org.apache.camel.component.http.HttpComponent.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.http.HttpEndpoint.java</file>
			<file type="M">org.apache.camel.component.http.CamelServlet.java</file>
		</fixedFiles>
	</bug>
	<bug id="1925" opendate="2009-08-21 06:51:11" fixdate="2009-09-13 10:00:12" resolution="Fixed">
		<buginformation>
			<summary>HTTP component throwing IllegalArgumentException in M3 release while bridging between jetty and http</summary>
			<description>The CamelHttpUri header is not set to the right value while routing between jetty and http components. Because of which the construction of the HttpMethod in the http component fails and throws up an IllegalArgumentException.
Detailed discussion regarding this issue can be found in this following thread.
http://www.nabble.com/HTTP-component-throwing-IllegalArgumentException-in-M3-release.-tt25057133.html#a25057133
</description>
			<version>2.0-M3</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.servlet.CamelHttpTransportServlet.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.servlet.HttpClientRouteTest.java</file>
			<file type="M">org.apache.camel.component.jetty.CamelContinuationServlet.java</file>
			<file type="M">org.apache.camel.component.http.HttpComponent.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.http.HttpEndpoint.java</file>
			<file type="M">org.apache.camel.component.http.CamelServlet.java</file>
		</fixedFiles>
	</bug>
	<bug id="1977" opendate="2009-09-02 07:43:24" fixdate="2009-09-14 10:37:29" resolution="Fixed">
		<buginformation>
			<summary>Camel HTTP binding incorrectly filters out the headers</summary>
			<description>Camel does not filter out internal headers when creating HTTP response. The internal headers like "CamelBeanMultiParameterArray" occur in HTTP response.
The reason is that in the following piece of code (from DefaultHttpBinding.java, around line 157):

        for (String key : message.getHeaders().keySet()) {
            String value = message.getHeader(key, String.class);
            if (headerFilterStrategy != null
                    &amp;amp;&amp;amp; !headerFilterStrategy.applyFilterToCamelHeaders(key, value, exchange)) {
                response.setHeader(key, value);
            }
        }


the "key" returned is lowercase, even in case the real header is "CamelBeanMultiParameterArray" (because CaseInsensitiveMap is used, which turns all keys to lowercase). Since pattern match in DefaultHeaderFilterStrategy is case-sensitive, the header is not filter out when filling the response headers.
The suggested solution is to make pattern case-insensitive.</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.HttpHeaderFilterStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="2016" opendate="2009-09-15 12:12:11" fixdate="2009-09-15 13:04:02" resolution="Fixed">
		<buginformation>
			<summary>camel-jpa exports the org.apache.camel.processor.interceptor which leads to a split package</summary>
			<description>The package is already exported by camel-core, so the class in this package needs to be moved to another package.</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.camel.processor.interceptor.JpaTraceEventMessage.java</file>
			<file type="M">org.apache.camel.processor.interceptor.TraceInterceptor.java</file>
			<file type="M">org.apache.camel.processor.interceptor.JpaTraceEventMessageTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1974" opendate="2009-09-01 09:24:25" fixdate="2009-09-16 14:41:56" resolution="Fixed">
		<buginformation>
			<summary>Package scanning cannot be used for folders containing special characters</summary>
			<description>I found out this problem developing a test case with cargo on my macbook. Temporary directory on leopard is something like (/private/var/folders/is/ispMf0ylEtCIOP8skg0va++++TI/Tmp) and cargo deploys the embedded container there.
Problem happens when camel tries to find converters by using DefaultPackageScanClassResolver class; it converts the temporary path, using URLDecoder, in the invalid path "/private/var/folders/is/ispMf0ylEtCIOP8skg0va    TI/Tmp"
You can reproduce this bug by patching the DefaultPackageScanClassResolverTest and adding the following resource file, that I&amp;amp;apos;m going to attach to this issue.</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultPackageScanClassResolver.java</file>
			<file type="M">org.apache.camel.impl.scan.DefaultPackageScanClassResolverTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2020" opendate="2009-09-17 09:21:34" fixdate="2009-09-17 10:32:46" resolution="Fixed">
		<buginformation>
			<summary>NPE when the bundle is camel-osgi bundle is inactive</summary>
			<description>The stack trace.

   java.lang.NullPointerException
	at
org.apache.camel.osgi.OsgiFactoryFinder.getResource(OsgiFactoryFinder.java:85)
	at
org.apache.camel.osgi.OsgiFactoryFinder.findClass(OsgiFactoryFinder.java:51)
	at
org.apache.camel.component.file.GenericFileEndpoint.createGenericFileStrategy(GenericFileEndpoint.java:130)
	at
org.apache.camel.component.file.GenericFileEndpoint.getGenericFileProcessStrategy(GenericFileEndpoint.java:114)
	at
org.apache.camel.component.file.GenericFileConsumer.processExchange(GenericFileConsumer.java:162)
	at
org.apache.camel.component.file.GenericFileConsumer.processBatch(GenericFileConsumer.java:120)
	at
org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:93)
	at
org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:98)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)
	at
java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:317)
	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:150)
	at
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:98)
	at
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:181)
	at
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:205)
	at
java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:619)


Here is the mail thread[1]  which discusses about this issue.
[1]http://www.nabble.com/Error-using-camel-file-with-windows-tt25475829.html#a25486384</description>
			<version>1.5.0</version>
			<fixedVersion>1.6.2, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.osgi.OsgiFactoryFinder.java</file>
		</fixedFiles>
	</bug>
	<bug id="2018" opendate="2009-09-16 16:15:45" fixdate="2009-09-18 07:42:28" resolution="Fixed">
		<buginformation>
			<summary>Timer Endpoint starts the thread before configuration</summary>
			<description>The Timer endpoint does not appear to allow configuration using Spring XML.  When debugging, the Timer is created (with default configuration) and then the configuration magic happens
TimerComponent.createEndpoint calls
new TimerEndpoint() which calls
component.getTimer(this)
Which creates the timer before the properties are set</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.timer.TimerEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="2025" opendate="2009-09-18 13:35:03" fixdate="2009-09-18 21:28:24" resolution="Fixed">
		<buginformation>
			<summary>serviceClass needs to be specified for PAYLOAD or MESSAGE mode even though it&amp;apos;s documented as not being required.</summary>
			<description>According to http://camel.apache.org/cxf.html if you specify PAYLOAD or MESSAGE mode you don&amp;amp;apos;t need to specify the serviceClass parameter if wsdlUrl is provided. However this isn&amp;amp;apos;t the case, with a route like:
cxf://localhost:8080/blah?wsdlURL=classpath:hello/HelloWorld-DOC.wsdl&amp;amp;dataFormat=PAYLOAD
The following exception is thrown:

java.lang.IllegalArgumentException: serviceClass must be specified and not empty
	at org.apache.camel.util.ObjectHelper.notEmpty(ObjectHelper.java:271)
	at org.apache.camel.component.cxf.CxfEndpoint.createServerFactoryBean(CxfEndpoint.java:303)
	at org.apache.camel.component.cxf.CxfConsumer.&amp;lt;init&amp;gt;(CxfConsumer.java:47)
	at org.apache.camel.component.cxf.CxfEndpoint.createConsumer(CxfEndpoint.java:97)
	at org.apache.camel.impl.EventDrivenConsumerRoute.addServices(EventDrivenConsumerRoute.java:59)
	at org.apache.camel.impl.DefaultRoute.onStartingServices(DefaultRoute.java:83)
	at org.apache.camel.impl.RouteService.doStart(RouteService.java:94)
	at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:52)
	at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:843)
	at org.apache.camel.test.junit4.CamelTestSupport.startCamelContext(CamelTestSupport.java:147)
	at org.apache.camel.test.junit4.CamelTestSupport.setUp(CamelTestSupport.java:100)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:616)


as the code doesn&amp;amp;apos;t check what mode is being used before testing if serviceClass is set or not.
Attached patch adds a test that reproduces this and also fixes the issue.</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.CXFWsdlOnlyTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2027" opendate="2009-09-18 22:50:48" fixdate="2009-09-20 08:12:57" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException when defining Camel route using Spring JavaConfig</summary>
			<description>Following unit test fails. 
Similar test, but using Spring XML with &amp;lt;routeBuilder ref="..."/&amp;gt; instead of Spring JavaConfig,  would succeed.

@ContextConfiguration(
    locations = "org.plos.camel.BeanJavaConfigTest$ContextConfig",
    loader = JavaConfigContextLoader.class
)
public class BeanJavaConfigTest extends AbstractTestNGSpringContextTests {

  @EndpointInject(uri = "mock:end")
  protected MockEndpoint endpoint;

  @EndpointInject(uri = "mock:error")
  protected MockEndpoint errorEndpoint;

  @Produce(uri = "direct:start")
  protected ProducerTemplate producer;

  @Test
  @DirtiesContext
  public void testSomething() throws Exception {
    endpoint.expectedMessageCount(1);
    endpoint.message(0).body().isEqualTo("Message Body");
    producer.sendBody("Message Body");
    endpoint.assertIsSatisfied();
  }

  public static class SomeBean {

    @Handler
    public String someMethod(String body) {
      System.out.println("Received: " + body);
      return body;
    }
  }

  @Configuration
  public static class ContextConfig extends SingleRouteCamelConfiguration {

    @Bean
    @Override
    public RouteBuilder route() {
      return new RouteBuilder() {
        @Override
        public void configure() throws Exception {
          from("direct:start")
              .bean(new SomeBean())
              .to("mock:end")
              .errorHandler(deadLetterChannel("mock:end"));
        }
      };
    }
  }
}


Error stack:

java.lang.IllegalStateException: Failed to load ApplicationContext

...

Caused by: java.lang.NullPointerException
	at org.apache.camel.spring.spi.ApplicationContextRegistry.lookup(ApplicationContextRegistry.java:41)
	at org.apache.camel.component.bean.BeanInfo.createParameterMappingStrategy(BeanInfo.java:115)
	at org.apache.camel.component.bean.BeanProcessor.&amp;lt;init&amp;gt;(BeanProcessor.java:55)
	at org.apache.camel.model.BeanDefinition.createProcessor(BeanDefinition.java:156)
	at org.apache.camel.model.ProcessorDefinition.makeProcessor(ProcessorDefinition.java:276)
	at org.apache.camel.model.ProcessorDefinition.addRoutes(ProcessorDefinition.java:116)
	at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:439)
	at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:126)
	at org.apache.camel.impl.DefaultCamelContext.startRoute(DefaultCamelContext.java:569)
	at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:924)
	at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:901)
	at org.apache.camel.spring.SpringCamelContext.maybeDoStart(SpringCamelContext.java:165)
	at org.apache.camel.spring.SpringCamelContext.doStart(SpringCamelContext.java:160)
	at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:52)
	at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:816)
	at org.apache.camel.spring.SpringCamelContext.maybeStart(SpringCamelContext.java:99)
	at org.apache.camel.spring.SpringCamelContext.afterPropertiesSet(SpringCamelContext.java:87)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1369)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1335)
	... 74 more


</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.CamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.model.RouteDefinition.java</file>
			<file type="M">org.apache.camel.spring.javaconfig.CamelConfiguration.java</file>
			<file type="M">org.apache.camel.spring.SpringCamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultRouteContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="1994" opendate="2009-09-07 16:42:48" fixdate="2009-09-21 13:26:32" resolution="Fixed">
		<buginformation>
			<summary>WS-Adressing: No headers in the respose, [MAPs retrieved from message null]</summary>
			<description>I am using a cxf endpoint configured in POJO mode and running in wsdl-first-approach. When a web-service client(Soap-UI) send a request with headers, it expects headers back with appropriate response Action defined in wsdl, however, with this configuration no headers are not being sent back.
Error seen on debug logs:
ContextUtils                   DEBUG retrieving MAPs from context property javax.xml.ws.addressing.context.inbound
ContextUtils                   WARN  WS-Addressing - failed to retrieve Message Addressing Properties from context
MAPAggregator                  DEBUG MAPs retrieved from message null
ContextUtils                   DEBUG retrieving MAPs from context property javax.xml.ws.addressing.context.outbound
ContextUtils                   WARN  WS-Addressing - failed to retrieve Message Addressing Properties from context
ContextUtils                   DEBUG retrieving MAPs from context property javax.xml.ws.addressing.context.outbound
ContextUtils                   WARN  WS-Addressing - failed to retrieve Message Addressing Properties from context
Please find attached detailed logs, a sample project, and a sample xml request.
Some more details:
Endpoint configuration: CxfEndpoint, WSAdressing Feature enabled, Wsdl First approach
Camel Version: 2.0.0
CXF Version: 2.2.2</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfConsumer.java</file>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="2032" opendate="2009-09-21 16:24:19" fixdate="2009-09-21 17:27:33" resolution="Fixed">
		<buginformation>
			<summary>XmppMessages don&amp;apos;t get converted to strings</summary>
			<description>This has been bugging me for awhile, when you have a route using XMPP you get instances of XmppMessage in your route rather than just a string containing the body of the XmppMessage.  Tracked that down and took out the work arounds I had previously put in my contributed xmpp tests.</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xmpp.XmppMessage.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppRouteMultipleProducersSingleConsumerTest.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppRouteChatTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1912" opendate="2009-08-14 20:18:23" fixdate="2009-09-29 08:36:50" resolution="Fixed">
		<buginformation>
			<summary>DefaultCamelContext.removeEndpoints() fails due to ConcurrentModificationException</summary>
			<description>The removeEndpoints() method iterates over the endpoints map, and attempts to remove entries inside of the iterator loop.  This causes near immediate ConcurrentModificationException&amp;amp;apos;s.</description>
			<version>1.5.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="2049" opendate="2009-10-01 09:00:11" fixdate="2009-10-08 06:23:36" resolution="Fixed">
		<buginformation>
			<summary>Improper configuration of MINA connector and acceptor instances; Better producer</summary>
			<description>A sample scenario where both MINA producer(s) and consumer(s) are used in the same route (e.g. some kind of dispatching or proxying):
from("mina:tcp://localhost:8888?lazySessionCreation=true&amp;amp;sync=true")
    .to("mina:tcp://localhost:7777?lazySessionCreation=true&amp;amp;sync=true");
from("mina:tcp://localhost:7777?lazySessionCreation=true&amp;amp;sync=true")
    .process(/prepare answer/);
Due to improper configuration of MINA acceptor and connector instances in MinaComponent#createSocketEndpoint(), no more than 15 incoming threads can be served at port 8888  the producer becomes unable to open an outgoing session.  This is actually an issue of MINA, not of Camel  a test application written using "raw" MINA shows the same behaviour.
A solution is to apply configuration rules described, e.g., at http://mina.apache.org/configuring-thread-model.html, as done in the attached patch.
Moreover, the standard Camel-MINA producer is not thread-safe  actually a well-known point.  A second attached file contains a thread pool-based reentrant version, which can be efficiently used for TCP endpoints with both parameters &amp;amp;apos;lazySessionCreation&amp;amp;apos; and &amp;amp;apos;sync&amp;amp;apos; set to true.
</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.2, 2.0.0, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina.MinaComponent.java</file>
			<file type="M">org.apache.camel.component.mina.MinaProducer.java</file>
			<file type="M">org.apache.camel.component.bean.BeanProcessor.java</file>
			<file type="M">org.apache.camel.component.mina.MinaConsumer.java</file>
			<file type="M">org.apache.camel.util.concurrent.ExecutorServiceHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="2056" opendate="2009-10-09 07:06:10" fixdate="2009-10-09 10:07:07" resolution="Fixed">
		<buginformation>
			<summary>Optional charset parameter in convertBodyTo is ignored by most converters in IOConverter</summary>
			<description>Most of the converters in IOConverter that do a char &amp;lt;-&amp;gt; byte conversion ignore the charset given as second argument to convertBodyTo. The attached patch fixes this.

For relevant converter methods, it introduces an additional second Exchange parameter from which the desired charset is obtained.
For backwards compatibility to code that uses the IOConverter directly, a one-parameter version of these methods was kept but the @Converter annotation was removed (Camel doesn&amp;amp;apos;t allow overloaded static type converter methods to be registered i.e. they overwrite in other in the registry).
The patch furthermore removes existing redundancies in code like getting the charset from the exchange, check if the exchange is null etc.
The String-&amp;gt;byte[] converter from ObjectConverter was moved to IOConverter because its implementation is more closely related to other methods in this converter class.

</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.xmlsecurity.XMLSecurityDataFormat.java</file>
			<file type="M">org.apache.camel.converter.jaxp.XmlConverterTest.java</file>
			<file type="M">org.apache.camel.converter.stream.StreamCacheConverterTest.java</file>
			<file type="M">org.apache.camel.converter.JaxpTest.java</file>
			<file type="M">org.apache.camel.converter.IOConverter.java</file>
			<file type="M">org.apache.camel.converter.IOConverterTest.java</file>
			<file type="M">org.apache.camel.converter.NIOConverterTest.java</file>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStreamTest.java</file>
			<file type="M">org.apache.camel.processor.cache.CacheBasedXPathReplacer.java</file>
			<file type="M">org.apache.camel.converter.jaxp.XmlConverter.java</file>
			<file type="M">org.apache.camel.component.stringtemplate.StringTemplateEndpoint.java</file>
			<file type="M">org.apache.camel.impl.GzipDataFormatTest.java</file>
			<file type="M">org.apache.camel.converter.NIOConverter.java</file>
			<file type="M">org.apache.camel.processor.ConvertBodyTest.java</file>
			<file type="M">org.apache.camel.converter.ObjectConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2060" opendate="2009-10-12 03:40:55" fixdate="2009-10-12 06:50:49" resolution="Fixed">
		<buginformation>
			<summary>Camel Bean component should not remember the last called method name if the bean&amp;apos;s method name is not explicitly specified.</summary>
			<description>Here is the mail thread which discuses this issue.
http://www.nabble.com/Bean-endpoint-in-a-route-is-holding-reference-to-the-last-used-methodName-and-does-not-invoke-Camel%27s-Bean-binding-tp25838095p25838095.html</description>
			<version>2.0-M3</version>
			<fixedVersion>1.6.2, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="2064" opendate="2009-10-12 17:43:37" fixdate="2009-10-12 17:53:21" resolution="Fixed">
		<buginformation>
			<summary>Redundant interceptions when using interceptSendToEndpoint</summary>
			<description>See http://www.nabble.com/Issue-with-interceptSendToEndpoint-to25859201s22882.html</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.intercept.InterceptSendToEndpointTest.java</file>
			<file type="M">org.apache.camel.management.ManagedErrorHandlerOptionsTest.java</file>
			<file type="M">org.apache.camel.model.InterceptSendToEndpointDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="1930" opendate="2009-08-24 09:15:20" fixdate="2009-10-13 07:41:30" resolution="Fixed">
		<buginformation>
			<summary>Synchronized access to XPathExpression resulting in contention for multiple consumers</summary>
			<description>Hi,
I&amp;amp;apos;m using Camel to do some JMS message routing. Messages are XML so xpath is a natural choice.
However when using a choice with an xpath expression, the XPathBuilder creates one XPathExpression object. According to the specification, these objects are not thread safe so synchronizing looks natural. But then, using multiple jms consumers is totally useless since no concurrent evaluations can be made.
XPathExpression objects would rather need to be stored in a ThreadLocal to avoid synchronization and contention.
Cheers,
Fabrice</description>
			<version>2.0-M3</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.xml.XPathBuilder.java</file>
			<file type="M">org.apache.camel.builder.xml.MessageVariableResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="2067" opendate="2009-10-14 17:11:13" fixdate="2009-10-16 04:28:44" resolution="Fixed">
		<buginformation>
			<summary>Mail Component: Character "|" in recipient addresses causes failure</summary>
			<description>It looks like there is minor bug in regex used in MailBinding.java, it causes "|" to act as delimiter, splitting email address into 2 parts.  
For ex: Using email address as - first|last@test.com causes it to split into two parts:
1) first
2) last@test.com
"|" is acceptable character in email as per wikipedia http://en.wikipedia.org/wiki/Email_address. I did not bother to read RFC specification.
Here is snippet of code causing issue:
 private static void appendRecipientToMimeMessage(MimeMessage mimeMessage, String type, String recipient)
        throws MessagingException {
        // we support that multi recipient can be given as a string seperated by comma or semi colon
        String[] lines = recipient.split("[,|;]");
        for (String line : lines) {
Regex above should either be "[,;]" or ";|,"
Also, having email addresses separate out by , or ; seems to be issue as it can be part of name. ex: "firstName, I like comma &amp;lt;first.last@test.com&amp;gt;" is valid. Above code will still cause failure for such messages. Can camel support addresses as List/Array rather than comma delimited string?
See Forum thread: http://www.nabble.com/Camel-Mail-Component%3A-%22|%22-in-email-causes-message-to-fail-td25883099.html</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="2054" opendate="2009-10-08 00:20:39" fixdate="2009-10-16 04:54:54" resolution="Fixed">
		<buginformation>
			<summary>Mail Component: Content-ID reference in multipart broken</summary>
			<description>It looks like Camel Mail Component does not set Content-ID mime header correctly or probably assumption is that BodyPart will take care of it. As a result embedded images in html body do not work ( img src="cid:somename.img").
Currently Content-ID is set as -
//MailBinding.java
// add a Content-ID header to the attachment
messageBodyPart.addHeader("Content-ID", attachmentFilename.substring(4));
But according to RFC standards http://www.ietf.org/rfc/rfc2392.txt, Content-ID value should be enclosed with in angle brackets, so it should be modified to -
//MailBinding.java
// add a Content-ID header to the attachment
messageBodyPart.addHeader("Content-ID", "&amp;lt;" + attachmentFilename.substring(4) + "&amp;gt;");
Also, below should be modified which incorrectly sets fileName inclusive of "cid:", but expectation would be strip off "cid" off it, similar to Content-ID
// Set the filename
messageBodyPart.setFileName(attachmentFilename);
Should be -
// Set the filename
messageBodyPart.setFileName(attachmentFilename.substring(4));
Also, RFC standard mentions that Content-ID should be globally unique but Camel Mail just sets it to filename instead. I understand this can be problematic as camel will have to replace references to each of such cid&amp;amp;apos;s  in any of the mail parts. 
As I understand from RFC document, is that this is required in case you send emails itself attachments, and attachments can same name can trample each other(I may be wrong here). I guess we can live with this for a while </description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultExchange.java</file>
			<file type="M">org.apache.camel.spring.interceptor.MixedPropagationTransactedTest.java</file>
			<file type="M">org.apache.camel.model.RollbackDefinition.java</file>
			<file type="M">org.apache.camel.processor.RollbackProcessor.java</file>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientDataSourceWithOnExceptionRollbackTest.java</file>
			<file type="M">org.apache.camel.spi.UnitOfWork.java</file>
			<file type="M">org.apache.camel.impl.DefaultUnitOfWork.java</file>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientDataSourceOnExceptionRedeliveryTest.java</file>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientDataSourceMinimalConfigurationTest.java</file>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientDataSourceTest.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="D">org.apache.camel.spring.spi.TransactedRuntimeCamelException.java</file>
			<file type="M">org.apache.camel.spring.interceptor.SpringTransactionalClientDataSourceTransactedTest.java</file>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientDataSourceRedeliveryTest.java</file>
			<file type="M">org.apache.camel.spring.spi.TransactionErrorHandler.java</file>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientWithRollbackTest.java</file>
			<file type="M">org.apache.camel.spring.interceptor.TransactionalClientDataSourceWithOnExceptionTest.java</file>
			<file type="M">org.apache.camel.component.mail.MimeMultipartAlternativeTest.java</file>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="2070" opendate="2009-10-16 05:16:07" fixdate="2009-10-16 05:58:08" resolution="Fixed">
		<buginformation>
			<summary>Dynamic Recipient List - Comma is always delimiter even if custom specified</summary>
			<description>See nabble
http://www.nabble.com/Dynamic-RecipientList-delimeter-issue-td25917854.html</description>
			<version>1.6.1</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.RecipientList.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.model.RecipientListDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="2072" opendate="2009-10-16 15:47:53" fixdate="2009-10-16 15:50:48" resolution="Fixed">
		<buginformation>
			<summary>camel-mail - extracting mails with headers using multi values inserts duplicates</summary>
			<description>Sending a message with headers that contains 2 values such a String[] with 2 values will result on the other side when consuming that mail message to contain a header with 2 entries. There should only be 1 entry with the 2 values.</description>
			<version>1.6.1</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="2076" opendate="2009-10-18 16:22:51" fixdate="2009-10-18 19:03:14" resolution="Fixed">
		<buginformation>
			<summary>Setting global error handler in camel-spring may not work correctly</summary>
			<description>Really weird since recently upgrading junit in camel-spring some unit tests started failing based on global error handling configuration with camel-spring.
I have tracked it down to a bug how error handlers was resolved when using spring XML only. It always worked with Java DSL.</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilderRef.java</file>
		</fixedFiles>
	</bug>
	<bug id="2075" opendate="2009-10-18 13:25:05" fixdate="2009-10-19 06:39:45" resolution="Fixed">
		<buginformation>
			<summary>camel-bean - When a method name is given it should be more strict to be sure always invoking a method with that name</summary>
			<description>You could potential invoke another method name if you have annotated that with a Camel annotation. Even if you have told Camel that the method should be named foo etc.
What Camel should do is to ensure that only methods with the name foo is possible to invoke.</description>
			<version>1.6.1</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
		</fixedFiles>
	</bug>
	<bug id="2074" opendate="2009-10-17 12:48:39" fixdate="2009-10-19 06:40:02" resolution="Fixed">
		<buginformation>
			<summary>camel-bean - should skip getter/setter methods when looking for method candidates</summary>
			<description>If you have a POJO and you have a setter for a Camel concept such as a org.apache.camel.TypeConverter then the bean component could consider invoking the setTypeConverter method as a candidate.
In fact it should skip any getter/setter all together.
For example this pojo

public class RiderOrderService {

    private TypeConverter converter;

    public void setConverter(TypeConverter converter) {
        this.converter = converter;
    }

    public String handleCustom(GenericFile file) {
    ...
    }

    public String handleXML(Document doc) {
    ...
    }


Camel should only consider the 2 handle methods. The setter should be skipped.</description>
			<version>1.6.1</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
			<file type="M">org.apache.camel.util.IntrospectionSupportTest.java</file>
			<file type="M">org.apache.camel.util.IntrospectionSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="2084" opendate="2009-10-20 11:02:12" fixdate="2009-10-20 11:07:11" resolution="Fixed">
		<buginformation>
			<summary>http polling consumer does not support timeout</summary>
			<description>When using the consumer template to receive from a remote http service using camel-http the method receive(5000) that uses a 5 sec timeout does not work as expected.
Camel does not use the 5000 value.</description>
			<version>1.6.1</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.DefaultHttpBinding.java</file>
			<file type="M">org.apache.camel.component.http.HttpPollingConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2088" opendate="2009-10-21 05:46:00" fixdate="2009-10-21 06:45:22" resolution="Fixed">
		<buginformation>
			<summary>camel-bean - Null String bodies is converted to a logging message instead of being null</summary>
			<description>See nabble
http://www.nabble.com/ToStringTypeConverter-and-null-message-bodies-td25978515.html</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.converter.ToStringTypeConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2089" opendate="2009-10-21 08:23:09" fixdate="2009-10-21 10:07:39" resolution="Fixed">
		<buginformation>
			<summary>camel-jms - Fixed ReplyTo configured on endpoint should also work for consumers</summary>
			<description>Endpoint option: ReplyTo is currently only applicable for producers. It should also work for consumers.</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.tx.NonTransactedInOutForJmsWithTxnMgrTest.java</file>
			<file type="M">org.apache.camel.component.jms.tx.QueueToQueueRequestReplyTransactionTest.java</file>
			<file type="M">org.apache.camel.component.jms.EndpointMessageListener.java</file>
			<file type="M">org.apache.camel.component.jms.JmsConfiguration.java</file>
			<file type="M">org.apache.camel.component.jms.JmsRouteRequestReplyTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2090" opendate="2009-10-21 12:27:41" fixdate="2009-10-21 12:46:54" resolution="Fixed">
		<buginformation>
			<summary>camel-jms - Option autoStartup does not work</summary>
			<description>It does in fact auto startup it anyway.</description>
			<version>1.6.1</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsConsumer.java</file>
			<file type="M">org.apache.camel.component.jms.JmsEndpointConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.jms.EndpointMessageListener.java</file>
			<file type="M">org.apache.camel.component.jms.JmsConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="2092" opendate="2009-10-22 02:46:52" fixdate="2009-10-22 04:08:09" resolution="Fixed">
		<buginformation>
			<summary>velocity endpoint should not remember the last used template uri</summary>
			<description>If there are two velocity endpoint linked with the pipeline, you will find the last velocity will not effect anymore.</description>
			<version>2.0-M1</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.velocity.VelocityEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="2095" opendate="2009-10-22 07:04:20" fixdate="2009-10-22 12:28:46" resolution="Fixed">
		<buginformation>
			<summary>Support Issue: Routing a TextMessage from a &lt;camel:proxy&gt; to a JMS queue</summary>
			<description>I did not find any example or documentation for using the &amp;lt;camel:proxy&amp;gt; with a simple send(String textMessage) method and a route sending the textMessage String as body to a JMS queue (for example).
The thing is that &amp;lt;camel:proxy&amp;gt; creates a messages with body of type BeanInvocation. I would expect that Camel provides some builtin transformer/converter to change the body to the String argument, so that the message on the queue is of type TextMessage.
Did I miss something? </description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.converter.ToStringTypeConverter.java</file>
			<file type="M">org.apache.camel.component.bean.CamelInvocationHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="2058" opendate="2009-10-10 00:26:23" fixdate="2009-10-23 10:42:34" resolution="Fixed">
		<buginformation>
			<summary>File Component - Rename operations fail sometimes on certain filesystems (Windows)</summary>
			<description>On Windows (don&amp;amp;apos;t know if there are other platforms that suffer from this problem), the file component fails to successfully rename files with the File.renameTo operation.  It fails when the rename is performed immediately after closing a file.  On Windows this usually indicates that some other process has the file open.  This occurs due to things like Virus scanners which keep the file open for very short periods of time.  Given a slight pause the rename would succeed.
This is a serious problem which effectively makes useless options like "tempPrefix" in the File Producer and "localWorkDirectory" with the FTP Consumer.  Workarounds like "disable your virus scanner" don&amp;amp;apos;t cut it for everyone (me specifically) as I&amp;amp;apos;m system privilege restricted from doing so, and even then, there&amp;amp;apos;s no guarantee that other windows processes might not do similar things (file indexers, etc).
The Java spec doesn&amp;amp;apos;t define the behavior of the rename operation and specifically says that this can vary from implementation to implementation / filesystem to filesystem.  Second, rename doesn&amp;amp;apos;t say why it fails, it merely returns false which is very unhelpful.
A couple ways to fix:
1).  Provide an option to disable this optimization.  ie, a "alwaysCopyInsteadOfRename" or something (clean, simple, easy).
This would be a simple fix.  More or less just a few clauses/tests in GenericFileProducer around any "is local" checks....
2).  Attempt a copy instead if the rename fails

maybe after a brief pause
maybe even after a number of rename attempts
maybe watch to see the file is closed prior to a rename attempt.

Rename operation failures may affect other things as well like certain locking schemes.
http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4167147</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFileProducer.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpOperations.java</file>
			<file type="M">org.apache.camel.component.file.FileEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpOperations.java</file>
			<file type="M">org.apache.camel.component.file.FileOperations.java</file>
			<file type="M">org.apache.camel.component.file.strategy.GenericFileProcessStrategySupport.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileOperations.java</file>
			<file type="M">org.apache.camel.component.file.strategy.MarkerFileExclusiveReadLockStrategy.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaWithNamedQueryTest.java</file>
			<file type="M">org.apache.camel.util.FileUtil.java</file>
			<file type="M">org.apache.camel.component.file.strategy.FileBigFileCopyManually.java</file>
			<file type="M">org.apache.camel.component.jpa.QueryBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">3793</link>
		</links>
	</bug>
	<bug id="2106" opendate="2009-10-25 11:20:18" fixdate="2009-10-25 15:03:29" resolution="Fixed">
		<buginformation>
			<summary>camel-bean - Should throw NoTypeConversionAvailableException if body cannot be converted to parameter type</summary>
			<description>If you route a message to a bean which has for example a org.w3c.Document as parameter type for the body, then Camel should thrown an conversion exception in case the payload cannot be converted to that type. And on the same time if the payload is really null then Camel should of course pass in null.</description>
			<version>1.6.1</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.component.bean.OrderServiceBean.java</file>
			<file type="M">org.apache.camel.component.bean.MethodInfo.java</file>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
			<file type="M">org.apache.camel.builder.ExpressionBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="2102" opendate="2009-10-22 21:14:57" fixdate="2009-10-26 10:37:17" resolution="Fixed">
		<buginformation>
			<summary>Transacted routes don&amp;apos;t allow custom error handlers to mark exception as handled AND set rollback only</summary>
			<description>If a route is transacted using transacted(), and a custom error handler is registered using onException() which handles the exception using handled(), creates a custom error response, and marks the transaction to be rolled back using rollback(), Camel wraps a non-existent &amp;amp;apos;null&amp;amp;apos; exception with a TransactedRuntimeCamelException in TransactionErrorHandler.wrapTransactedRuntimeException() and throws the TRCE, causing the custom error response to be ignored. 
Route looks like:
		// configure error handler for all routes
		onException(Exception.class).handled(true).to("bean:transformerBean?method=exceptionToResponse").rollback();
		from("cxfrs://bean:categoriesEndpoint").transacted()
			.choice()...
Basically the application wants to handle exceptions by sending a custom error message back to the route client, and also mark transactions for rollback. 
Attached patch checks for the presence of an exception, and only raises a TRCE if its not null. </description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.RollbackDefinition.java</file>
			<file type="M">org.apache.camel.processor.RollbackProcessor.java</file>
			<file type="M">org.apache.camel.spring.spi.SpringTransactionPolicy.java</file>
			<file type="M">org.apache.camel.model.TransformDefinition.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.spring.spi.TransactionErrorHandler.java</file>
			<file type="M">org.apache.camel.spring.interceptor.SpringTransactionalClientDataSourceUsingTransactedTest.java</file>
			<file type="M">org.apache.camel.CamelExchangeException.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="depends upon">2107</link>
		</links>
	</bug>
	<bug id="2112" opendate="2009-10-27 07:35:36" fixdate="2009-10-27 11:44:28" resolution="Fixed">
		<buginformation>
			<summary>Problem using a CamelTransportFactory from a junit 4 unit test or together with &lt;context:annotation-config/&gt;</summary>
			<description>I recently tried to convert my unit tests to junit 4 using the new Spring test framework.
Since then I get the following exception when calling the test.
Error creating bean with name &amp;amp;apos;org.apache.camel.component.cxf.transport.CamelTransportFactory#0&amp;amp;apos;: Injection of resource methods failed; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No matching bean of type [java.lang.String] found for dependency [collection of java.lang.String]: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {}
The same happens when I activate /&amp;lt;context:annotation-config/&amp;gt;/
I think it has to do with autowiring. Do you have any idea what goes wrong here and how I can fix it? </description>
			<version>1.4.0</version>
			<fixedVersion>1.6.2, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.transport.CamelTransportFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="2109" opendate="2009-10-26 10:21:25" fixdate="2009-10-29 11:59:14" resolution="Fixed">
		<buginformation>
			<summary>ID of route is not set when onException is used</summary>
			<description>When building a route like this:

....
public void configure() {

from("jms:fileIn?transacted=true")
  .onException(UnmarshalException.class)
   .handled(true)
    .bean(FileProcessExceptionBean.class,"handleException")
.end()
.id("fileMapping")
.transacted()
.process(new FileProcessor())
.to("jms:fileOut");

}


the id is not set. When the onException-section is removed, the id is set correctly</description>
			<version>2.1.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.RouteIdTest.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.model.RouteDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="2122" opendate="2009-10-30 09:54:07" fixdate="2009-11-01 13:28:38" resolution="Fixed">
		<buginformation>
			<summary>XPath injection cannot handle expressions returning strings</summary>
			<description>trying to inject following:
public void insert(@XPath("concat(&amp;amp;apos;48&amp;amp;apos;,&amp;amp;apos;//node/msisdn/text())") String msisdn) { }
results in  
Can not convert #STRING to a NodeList! exception.
The reason is that XPathAnnotationExpressionFactory uses 
XPathBuilder.xpath(xpath); 
and by default xpath is evaluated as nodeSet.
I think it would be nice to be able to define result type in annotation e.g.
@XPath(value = "concat(&amp;amp;apos;48&amp;amp;apos;,&amp;amp;apos;//node/msisdn/text())", resultType = String.class)
The default would be NodeSet to be backward compatible</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.language.XPath.java</file>
			<file type="M">org.apache.camel.processor.ThrottelingRoutePolicyTest.java</file>
			<file type="M">org.apache.camel.component.bean.XPathAnnotationExpressionFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="2128" opendate="2009-11-03 12:30:30" fixdate="2009-11-04 02:27:51" resolution="Fixed">
		<buginformation>
			<summary>Rollback does not work for transactional routes using camel-cxf</summary>
			<description>I have a request reply service that should be able to do three different
things:
1)  no exception occurs in the implementation: The jms Message should be
committed and the normal reply should be sent
2) The implementation throws an exception defined in the service contract:
The jms message should be committed and a fault should be sent
3) The implemementation throws another kind of exception: The message delivery should
be rolled back so it can be received again
Case 1 and 2 currently work as expected.
For Case 3 a fault is returned to the caller and the transaction is committed which is wrong. </description>
			<version>2.0.0</version>
			<fixedVersion>1.6.2, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.transport.CamelDestination.java</file>
		</fixedFiles>
	</bug>
	<bug id="522" opendate="2008-05-16 13:35:45" fixdate="2009-11-04 05:16:13" resolution="Fixed">
		<buginformation>
			<summary>Problem with scanning Jar files for Converters if application is loaded with webstart</summary>
			<description>I&amp;amp;apos;ve encountered a problem with the scanning of jar files with the @Converter annotation if the Jars are loaded with the webstart classloader. Because the URL starts with http: the conversion to a file fails in ResolverUtil. 
I&amp;amp;apos;ve attached a patch that uses an UrlResource if the url starts with http: and this works if the jar-resource has the version information added to the jar file in the JNLP-file (like &amp;lt;jar href="camel-core-1.4-SNAPSHOT.jar"/&amp;gt;). But if the version is added separately (like &amp;lt;jar href="activemq-core.jar" version="5.1.0"/&amp;gt;) it fails because the classloader returns the name of the jar-file without the version information (like http://....../activemq-core.jar) and this file does not exist. 
I&amp;amp;apos;m currently trying if it is possible to check whether the application is started via webstart (there is a class Tool that should only exist in the webstart classloader) and in this case I&amp;amp;apos;ll check if the filename of the jar-file is returned correctly. If yes maybe we can provide another patch to get rid of the problem described above.</description>
			<version>1.3.0</version>
			<fixedVersion>1.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ResolverUtil.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">537</link>
		</links>
	</bug>
	<bug id="2132" opendate="2009-11-04 10:12:18" fixdate="2009-11-04 10:46:05" resolution="Fixed">
		<buginformation>
			<summary>camel-jms - Sending Object message should fail if payload cannot be converted to serializable</summary>
			<description>If not a null message is created and send.
See nabble:
http://old.nabble.com/JPA%3A-Could-not-pass-Object-from-jpa-to-jms-to26160124.html</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="2133" opendate="2009-11-04 12:23:55" fixdate="2009-11-04 12:31:42" resolution="Fixed">
		<buginformation>
			<summary>The converter&amp;apos;s MandatoryConvert method doesn&amp;apos;t throw the exception when the value is null</summary>
			<description></description>
			<version>2.0-M1</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
			<file type="M">org.apache.camel.builder.ExpressionBuilder.java</file>
			<file type="M">org.apache.camel.converter.ConverterTest.java</file>
			<file type="M">org.apache.camel.impl.converter.DefaultTypeConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2139" opendate="2009-11-06 02:53:39" fixdate="2009-11-06 05:49:57" resolution="Fixed">
		<buginformation>
			<summary>Some methods of SftpOperations create streams that are never closed</summary>
			<description>Where SftpOperations creates streams for storing or retrieving files via ChannelSftp, these streams are not always closed. For example, the retrieveFileToStreamInBody method creates an OutputStream object, but never closes it.</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpOperations.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="2146" opendate="2009-11-06 14:37:10" fixdate="2009-11-06 14:38:37" resolution="Fixed">
		<buginformation>
			<summary>Type converter - Should respect Future ExecutionException as not failed to convert but some other error</summary>
			<description></description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.converter.FutureTypeConverter.java</file>
			<file type="M">org.apache.camel.processor.ThrottlingInflightRoutePolicyTest.java</file>
			<file type="M">org.apache.camel.impl.converter.DefaultTypeConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2145" opendate="2009-11-06 14:17:13" fixdate="2009-11-06 14:46:04" resolution="Fixed">
		<buginformation>
			<summary>camel-http - creating http uri may contain special endpoint options</summary>
			<description>For example sending to an endpoint as follows

to("http://www.google.com?throwExceptionOnFailure=false");


Could potentially added throwExceptionOnFailure as a parameter but its an endpoint parameter not a HTTP parameter.
This issue is for components that build on top of camel-http.</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="2153" opendate="2009-11-09 14:37:25" fixdate="2009-11-10 13:32:22" resolution="Fixed">
		<buginformation>
			<summary>FTP Component issue with tempPrefix or tempFileName</summary>
			<description>using FTP component to push files via FTP I am facing issues pushing a file on subfolder when using tempPrefix or tempFileName. 
route sample: 
from("direct:start").to("ftp://username@ipaddress?password=mypass&amp;amp;fileName=./camel/test/message.txt&amp;amp;tempFileName=$
{file:name.noext}
.tmp");
no errors are raised if the final destination file doesn&amp;amp;apos;t exists, if it exists following error is raised: 
Exception in thread "main" org.apache.camel.CamelExecutionException: Exception occurred during execution on the exchange: Exchange[Message: Message content] 
        at org.apache.camel.util.ObjectHelper.wrapCamelExecutionException(ObjectHelper.java:1055) 
        at org.apache.camel.util.ExchangeHelper.extractResultBody(ExchangeHelper.java:446) 
        at org.apache.camel.impl.DefaultProducerTemplate.extractResultBody(DefaultProducerTemplate.java:431) 
        at org.apache.camel.impl.DefaultProducerTemplate.extractResultBody(DefaultProducerTemplate.java:427) 
        at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:112) 
        at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:117) 
        at com.opta.camel.test.FTPTester.main(FTPTester.java:30) 
Caused by: java.lang.NullPointerException 
        at org.apache.camel.component.file.remote.FtpOperations.existsFile(FtpOperations.java:372)
        at org.apache.camel.component.file.GenericFileProducer.processExchange(GenericFileProducer.java:92) 
        at org.apache.camel.component.file.remote.RemoteFileProducer.process(RemoteFileProducer.java:52) 
        at org.apache.camel.processor.SendProcessor$1.doInProducer(SendProcessor.java:86) 
        at org.apache.camel.processor.SendProcessor$1.doInProducer(SendProcessor.java:84) 
        at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:146) 
        at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:83) 
        at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:67) 
        at org.apache.camel.processor.DelegateProcessor.processNext(DelegateProcessor.java:53) 
        at org.apache.camel.processor.DelegateProcessor.proceed(DelegateProcessor.java:82) 
        at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:85) 
        at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:67) 
        at org.apache.camel.processor.RedeliveryErrorHandler.processExchange(RedeliveryErrorHandler.java:232) 
        at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:162) 
        at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:91) 
        at org.apache.camel.processor.DefaultErrorHandler.process(DefaultErrorHandler.java:49) 
        at org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:201) 
        at org.apache.camel.processor.UnitOfWorkProcessor.processNext(UnitOfWorkProcessor.java:54) 
        at org.apache.camel.processor.DelegateProcessor.process(DelegateProcessor.java:48) 
        at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:67) 
        at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:45) 
        at org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:179) 
        at org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:161) 
        at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:146) 
        at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:160) 
        at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:98) 
        at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:97) 
        at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:110) 
        ... 2 more</description>
			<version>2.1.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpOperations.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="2129" opendate="2009-11-03 13:01:35" fixdate="2009-11-11 01:52:04" resolution="Fixed">
		<buginformation>
			<summary>Misleading exception when a Camel-CXF Service call times out (Null InputStream is not a valid argument)</summary>
			<description>We use camel-cxf and camel-jms to offer CXF services over SOAP/JMS.
When the client calls the service by using the generated stub code and a timeout occurs I get an exception "Null InputStream is not a valid argument". I would rather expect something like "Timeout calling service". Full stack trace is attached below.
The routing config is attached below.
&amp;lt;client id="customerService" xmlns="http://cxf.apache.org/jaxws"
xmlns:service="http://examples.etg.services.enbw.net/"
  serviceName="service:CustomerService"
  endpointName="service:CustomerServiceEndpoint"
  serviceClass="net.enbw.services.etg.examples.customerservice.CustomerServiceV1"
  address="camel://direct:client"&amp;gt;
&amp;lt;/client&amp;gt;
&amp;lt;camelContext id="camelContext" trace="false" xmlns="http://camel.apache.org/schema/spring"&amp;gt;
  &amp;lt;route&amp;gt;
    &amp;lt;from uri="direct:client"/&amp;gt;
    &amp;lt;to uri="jms://queue.net.enbw.services.etg.examples.customerservice.CustomerService" /&amp;gt;
  &amp;lt;/route&amp;gt;
&amp;lt;/camelContext&amp;gt;
------
03.11.2009 13:20:58 org.apache.cxf.phase.PhaseInterceptorChain doIntercept
WARNUNG: Interceptor has thrown exception, unwinding now
java.lang.IllegalArgumentException: Null InputStream is not a valid argument
	at com.ctc.wstx.stax.WstxInputFactory.createSR(WstxInputFactory.java:614)
	at com.ctc.wstx.stax.WstxInputFactory.createXMLStreamReader(WstxInputFactory.java:324)
	at org.apache.cxf.staxutils.StaxUtils.createXMLStreamReader(StaxUtils.java:879)
	at org.apache.cxf.interceptor.StaxInInterceptor.handleMessage(StaxInInterceptor.java:83)
	at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:236)
	at org.apache.cxf.endpoint.ClientImpl.onMessage(ClientImpl.java:664)
	at org.apache.camel.component.cxf.transport.CamelConduit$CamelOutputStream.handleResponse(CamelConduit.java:191)
	at org.apache.camel.component.cxf.transport.CamelConduit$CamelOutputStream.commitOutputMessage(CamelConduit.java:183)
	at org.apache.camel.component.cxf.transport.CamelConduit$CamelOutputStream.doClose(CamelConduit.java:153)
	at org.apache.cxf.io.CachedOutputStream.close(CachedOutputStream.java:185)
	at org.apache.cxf.transport.AbstractConduit.close(AbstractConduit.java:66)
	at org.apache.cxf.interceptor.MessageSenderInterceptor$MessageSenderEndingInterceptor.handleMessage(MessageSenderInterceptor.java:62)
	at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:236)
	at org.apache.cxf.endpoint.ClientImpl.invoke(ClientImpl.java:478)
	at org.apache.cxf.endpoint.ClientImpl.invoke(ClientImpl.java:308)
	at org.apache.cxf.endpoint.ClientImpl.invoke(ClientImpl.java:260)
	at org.apache.cxf.frontend.ClientProxy.invokeSync(ClientProxy.java:73)
	at org.apache.cxf.jaxws.JaxWsClientProxy.invoke(JaxWsClientProxy.java:124)
	at $Proxy63.readCustomersByName(Unknown Source)
	at net.enbw.endur.AppModule.doBusiness(AppModule.java:34)
	at net.enbw.endur.AppMain.main(AppMain.java:23)
Exception in thread "main" javax.xml.ws.soap.SOAPFaultException: Null InputStream is not a valid argument
	at org.apache.cxf.jaxws.JaxWsClientProxy.invoke(JaxWsClientProxy.java:146)
	at $Proxy63.readCustomersByName(Unknown Source)
	at net.enbw.endur.AppModule.doBusiness(AppModule.java:34)
	at net.enbw.endur.AppMain.main(AppMain.java:23)
Caused by: java.lang.IllegalArgumentException: Null InputStream is not a valid argument
	at com.ctc.wstx.stax.WstxInputFactory.createSR(WstxInputFactory.java:614)
	at com.ctc.wstx.stax.WstxInputFactory.createXMLStreamReader(WstxInputFactory.java:324)
	at org.apache.cxf.staxutils.StaxUtils.createXMLStreamReader(StaxUtils.java:879)
	at org.apache.cxf.interceptor.StaxInInterceptor.handleMessage(StaxInInterceptor.java:83)
	at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:236)
	at org.apache.cxf.endpoint.ClientImpl.onMessage(ClientImpl.java:664)
	at org.apache.camel.component.cxf.transport.CamelConduit$CamelOutputStream.handleResponse(CamelConduit.java:191)
	at org.apache.camel.component.cxf.transport.CamelConduit$CamelOutputStream.commitOutputMessage(CamelConduit.java:183)
	at org.apache.camel.component.cxf.transport.CamelConduit$CamelOutputStream.doClose(CamelConduit.java:153)
	at org.apache.cxf.io.CachedOutputStream.close(CachedOutputStream.java:185)
	at org.apache.cxf.transport.AbstractConduit.close(AbstractConduit.java:66)
	at org.apache.cxf.interceptor.MessageSenderInterceptor$MessageSenderEndingInterceptor.handleMessage(MessageSenderInterceptor.java:62)
	at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:236)
	at org.apache.cxf.endpoint.ClientImpl.invoke(ClientImpl.java:478)
	at org.apache.cxf.endpoint.ClientImpl.invoke(ClientImpl.java:308)
	at org.apache.cxf.endpoint.ClientImpl.invoke(ClientImpl.java:260)
	at org.apache.cxf.frontend.ClientProxy.invokeSync(ClientProxy.java:73)
	at org.apache.cxf.jaxws.JaxWsClientProxy.invoke(JaxWsClientProxy.java:124)
	... 3 more
</description>
			<version>2.0.0</version>
			<fixedVersion>1.6.2, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.ServiceSupport.java</file>
			<file type="M">org.apache.camel.component.cxf.transport.CamelConduit.java</file>
		</fixedFiles>
	</bug>
	<bug id="2158" opendate="2009-11-11 07:09:34" fixdate="2009-11-11 08:33:21" resolution="Fixed">
		<buginformation>
			<summary>onException - Should look up the hierarchy for exact matches to avoid being handled by Exception.class where an exact match existed</summary>
			<description>See nabble
http://old.nabble.com/Exception-handling-...-onException-to26215607.html

                onException(UnmarshalException.class).handled(true).to("mock:ue");
                
                onException(Exception.class).handled(true).to("mock:exception");

                from("direct:start")
                    .throwException(new UnmarshalException("Could not unmarshal", new IllegalArgumentException("Damn")));


The code above should be handled by the UnmarshalException.class as its the best candidate.</description>
			<version>1.6.1</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategy.java</file>
			<file type="M">org.apache.camel.processor.exceptionpolicy.ExceptionPolicyStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="2168" opendate="2009-11-12 19:26:25" fixdate="2009-11-12 19:36:40" resolution="Fixed">
		<buginformation>
			<summary>Logger logs INFO level messages at DEBUG level</summary>
			<description>The Camel logger logs INFO level messages at the DEBUG level. CAMEL-1048 fixed the problem in one of two cases (logging without an exception), but it is still broken for logging with an exception. Patch to fix this is attached.</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.Logger.java</file>
		</fixedFiles>
	</bug>
	<bug id="1780" opendate="2009-07-01 19:05:25" fixdate="2009-11-12 20:08:47" resolution="Duplicate">
		<buginformation>
			<summary>Allow for templated/common routes</summary>
			<description>This is a follow-up from my exchange with Claus on the user-forum. If the camel routes are spread across multiple files, it&amp;amp;apos;d be very useful to allow for a templating or hierarchical mechanism that&amp;amp;apos;d allow for common routes (in my case Exception processing) to be re-used without copy-pasting in the different files.
http://www.nabble.com/Multiple-camelContext-elements-in-camel-2.0.m2-Spring-DSL-td24293351.html</description>
			<version>1.6.1</version>
			<fixedVersion>Future</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.RouteBuilder.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilderAddRoutesOnlyInterceptTest.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilderAddRoutesTest.java</file>
			<file type="M">org.apache.camel.spring.processor.SpringTestHelper.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1919</link>
		</links>
	</bug>
	<bug id="2144" opendate="2009-11-06 13:38:40" fixdate="2009-11-16 07:50:42" resolution="Fixed">
		<buginformation>
			<summary>A null-Message to a cxf-endpoint (e.g. HTTP-GET) can disable accepting regular requests</summary>
			<description>Start a fine configured system with came-cxf consumer endpoint using http. Make some tests with valid SOAP-Messages. Then just send a HTTP-Get-Request to the endpoint (e.g. with Browser). You&amp;amp;apos;ll get some kind of Exception saying
java.lang.ClassCastException: org.apache.cxf.message.MessageContentsList cannot be cast to org.w3c.dom.Node
Ok, this could be interpreted as "There is no content to convert into Node..." as, if you debug, you&amp;amp;apos;ll see, that an empty MessageContentsList is provided by camel-cxf as the body of the camel message. Of course, if the Request would contain a body, the camel body would be a non empty MessageContentsList and the type converter mechanism would find a way to convert the list into a w3c Document, but that&amp;amp;apos;s not the point. The Bug is, that this null-body-request puts the DefaultTypeConverter into a state, that let always return null for bodies of type MessageContentsList, even if it&amp;amp;apos;s not empty (which is normal). I think that there is certain &amp;amp;apos;misses&amp;amp;apos;-map responsible for that kind of &amp;amp;apos;miss&amp;amp;apos;-state...</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.converter.CxfConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2175" opendate="2009-11-16 13:32:10" fixdate="2009-11-16 14:20:25" resolution="Fixed">
		<buginformation>
			<summary>Initialization code of camel-cxf is not thread safe</summary>
			<description>getCxfBinding is not thread safe in case multiple threads hit a CXF webserive at once and it hasnt been initialized before.
Code like this

    public CxfBinding getCxfBinding() {
        if (cxfBinding == null) {
            cxfBinding = new DefaultCxfBinding();   
            if (LOG.isDebugEnabled()) {
                LOG.debug("Create default CXF Binding " + cxfBinding);
            }
        }
        
        if (!cxfBindingInitialized.getAndSet(true) 
                &amp;amp;&amp;amp; cxfBinding instanceof HeaderFilterStrategyAware) {
            ((HeaderFilterStrategyAware)cxfBinding)
                .setHeaderFilterStrategy(getHeaderFilterStrategy());
        }
        return cxfBinding;
    }


Is a false sense as the getAndSet will let other threads pass it with a cxfBinding that still may not have been initialized.</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.RestletEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="2150" opendate="2009-11-09 09:35:45" fixdate="2009-11-16 20:31:05" resolution="Fixed">
		<buginformation>
			<summary>RSS Component - parameter filtering not working</summary>
			<description>I have tried to sort RRS feeds or to split the entries  as described in the documentation. The problem is that the parameters that are to be consumed by Camel are passed through to the endpoint, who does not understand the parameters.
Here is my code:  from("rss:" + feedLocation+ "?sortEntries=true&amp;amp;feedHeader=true").marshal().rss()...
where feedLocation = "http://www.iafrica.com/pls/cms/grapevine.xml"
It results in:
java.io.FileNotFoundException: http://www.iafrica.com/pls/cms/grapevine.xml?feedHeader=true&amp;amp;sortEntries=true
	at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1311)
	at java.net.URL.openStream(URL.java:1010)
	at org.apache.camel.component.rss.RssUtils.createFeed(RssUtils.java:32)
	at org.apache.camel.component.rss.RssEntryPollingConsumer.createFeed(RssEntryPollingConsumer.java:54)
	at org.apache.camel.component.feed.FeedEntryPollingConsumer.poll(FeedEntryPollingConsumer.java:42)
	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:99)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)
	at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:317)
	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:150)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:98)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:181)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:205)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:637)</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.feed.FeedEndpoint.java</file>
			<file type="M">org.apache.camel.component.atom.AtomPollingConsumerTest.java</file>
			<file type="M">org.apache.camel.component.atom.AtomComponent.java</file>
			<file type="M">org.apache.camel.impl.DefaultComponent.java</file>
			<file type="M">org.apache.camel.component.rss.RssComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="2183" opendate="2009-11-17 10:03:36" fixdate="2009-11-17 17:35:09" resolution="Fixed">
		<buginformation>
			<summary>camel-cxf - Empty body causes http error 500 even for GET when using cxfbean</summary>
			<description>CxfSoapBinding has a bug that it mandates a body to exist. But when you send a GET then there is of course no body.
The code below fixed this in the method getCxfInMessage

        // body can be empty in case of GET etc.
        InputStream body = message.getBody(InputStream.class);
        if (body != null) {
            answer.setContent(InputStream.class, body);
        } else if (message.getBody() != null) {
            // fallback and set the body as what it is
            answer.setContent(Object.class, body);
        }


Willem Tam can you review if that is okay? Maybe the code can be more finer to check the HTTP method and in cases of GET etc. it allows no body.
I will commit my fix to get the unit tests passing.</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfSoapBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="2186" opendate="2009-11-17 16:29:26" fixdate="2009-11-18 08:47:28" resolution="Fixed">
		<buginformation>
			<summary>if ftp endpoint is not writeable, the only messages you get are logged at DEBUG level.</summary>
			<description>Using the same project attached to CAMEL-2165, you can delete the "ftp_home" directory, or simply edit user.properties to make the ftp account readonly.
While every single write to the camel ftp endpoint will then fail, the only notification of this is at DEBUG level.  In my opinion this should be at least WARN</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.quartz.CamelJob.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileProducer.java</file>
			<file type="M">org.apache.camel.processor.interceptor.AdviceWithTest.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzEndpoint.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzConsumer.java</file>
			<file type="M">org.apache.camel.component.timer.TimerConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2165" opendate="2009-11-12 15:33:19" fixdate="2009-11-18 08:47:47" resolution="Fixed">
		<buginformation>
			<summary>ftp uploads can fail: File operation failed:  Connection closed without indication.. Code: 421</summary>
			<description>Looks like something that was fixed for CAMEL-444 didn&amp;amp;apos;t make it into 2.0?
On 2.0.0, this is not a warning, this is a fatal.
SEVERE: Exception occured during execution on the exchange: Exchange[Message: XXXXXX]
org.apache.camel.CamelExecutionException: Exception occured during execution on the exchange: Exchange[Message: XXXXX]
        at org.apache.camel.util.ObjectHelper.wrapCamelExecutionException(ObjectHelper.java:1027)
        at org.apache.camel.util.ExchangeHelper.extractResultBody(ExchangeHelper.java:479)
        at org.apache.camel.impl.DefaultProducerTemplate.extractResultBody(DefaultProducerTemplate.java:431)
        at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:106)
        at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:122)
        at org.apache.camel.impl.DefaultProducerTemplate.requestBody(DefaultProducerTemplate.java:266)
        at... into my code here...
Caused by: org.apache.camel.component.file.GenericFileOperationFailedException: File operation failed:  Connection closed without indication.. Code: 421
        at org.apache.camel.component.file.remote.FtpOperations.disconnect(FtpOperations.java:167)
        at org.apache.camel.component.file.remote.RemoteFileProducer.disconnect(RemoteFileProducer.java:77)
        at org.apache.camel.component.file.remote.RemoteFileProducer.handleFailedWrite(RemoteFileProducer.java:66)
        at org.apache.camel.component.file.GenericFileProducer.processExchange(GenericFileProducer.java:104)
        at org.apache.camel.component.file.remote.RemoteFileProducer.process(RemoteFileProducer.java:52)
        at org.apache.camel.processor.SendProcessor$1.doInProducer(SendProcessor.java:81)
        at org.apache.camel.processor.SendProcessor$1.doInProducer(SendProcessor.java:79)
        at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:141)
        at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:78)
        at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:61)
        at org.apache.camel.processor.RedeliveryErrorHandler.processExchange(RedeliveryErrorHandler.java:186)
        at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:155)
        at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:88)
        at org.apache.camel.processor.DefaultErrorHandler.process(DefaultErrorHandler.java:49)
        at org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:148)
        at org.apache.camel.processor.Pipeline.process(Pipeline.java:74)
        at org.apache.camel.processor.UnitOfWorkProcessor.processNext(UnitOfWorkProcessor.java:54)
        at org.apache.camel.processor.DelegateProcessor.process(DelegateProcessor.java:48)
        at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:45)
        at org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:170)
        at org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:156)
        at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:141)
        at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:155)
        at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:111)
        at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:101)
        at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:105)
        ... 37 more
Caused by: org.apache.commons.net.ftp.FTPConnectionClosedException: Connection closed without indication.
        at org.apache.commons.net.ftp.FTP.__getReply(FTP.java:297)
This is "not what I want"  and there doesn&amp;amp;apos;t seem to be any keep alive or other option on the ftp2 component.</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileProducer.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpOperations.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileOperations.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="2196" opendate="2009-11-18 10:32:55" fixdate="2009-11-18 11:06:33" resolution="Fixed">
		<buginformation>
			<summary>camel-cxf - CxfProducer in POJO mode should be able to use POJO object directly without wrapped as List</summary>
			<description>See camel-example-cxf-async
In the client code that sends to the server using CxfProducer. I have to wrap my POJO in a List object.
CxfProducer should be smarter and be able to do this itself.
It can do this by converting the payload to an iterator and use that to construct the list.
Then it works for POJO objects directly.</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfProducer.java</file>
			<file type="M">org.apache.camel.example.client.CamelClient.java</file>
		</fixedFiles>
	</bug>
	<bug id="2201" opendate="2009-11-19 04:58:52" fixdate="2009-11-19 05:48:26" resolution="Fixed">
		<buginformation>
			<summary>RedeliveryPolicy - Setting delay &gt; maxDelay should should also set max value</summary>
			<description>See nabble
http://old.nabble.com/maximumRedeliveryDelay-applies-even-if-you-are-not-using-exponential-back-off-to26415728.html
</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.RedeliveryPolicy.java</file>
		</fixedFiles>
	</bug>
	<bug id="2156" opendate="2009-11-11 01:39:03" fixdate="2009-11-21 11:39:27" resolution="Fixed">
		<buginformation>
			<summary>ActivityMonitorEngine uses ?1 parameters in JPAQL, which don&amp;apos;t work with (at least) the hibernate JPA provider.</summary>
			<description>Trying to just replace my RouteBuilder with a ProcessBuilder to start moving towards using BAM. I converted everything over to JPA, to make bam happy, but then found that it still explodes   (Full stack trace below)
Line 80 of ActivityMonitorEngine has this JPAQL,
                        List&amp;lt;ActivityState&amp;gt; list = template.find("select x from " + ActivityState.class.getName() + " x where x.timeOverdue &amp;lt; ?1", timeNow);
The ?1 named/numbered parameter seems to not be supported by hibernate&amp;amp;apos;s JPA provider.
I can&amp;amp;apos;t find much of any documentation on this, could this just be made a normal positional?  I can&amp;amp;apos;t even try out the BAM module without this 
2009-11-11 01:33:53,815 ERROR [org.apache.camel.bam.processor.ActivityMonitorEngine:ActivityMonitorEngine] - &amp;lt;Caught: org.springframework.dao.InvalidDataAccessApiUsageException: org.hibernate.QueryParameterException: could not locate named parameter [1]; nested exception is java.lang.IllegalArgumentException: org.hibernate.QueryParameterException: could not locate named parameter [1]&amp;gt;
org.springframework.dao.InvalidDataAccessApiUsageException: org.hibernate.QueryParameterException: could not locate named parameter [1]; nested exception is java.lang.IllegalArgumentException: org.hibernate.QueryParameterException: could not locate named parameter [1]
	at org.springframework.orm.jpa.EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(EntityManagerFactoryUtils.java:271)
	at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:97)
	at org.springframework.dao.support.DataAccessUtils.translateIfNecessary(DataAccessUtils.java:212)
	at org.springframework.orm.jpa.JpaAccessor.translateIfNecessary(JpaAccessor.java:152)
	at org.springframework.orm.jpa.JpaTemplate.execute(JpaTemplate.java:189)
	at org.springframework.orm.jpa.JpaTemplate.executeFind(JpaTemplate.java:151)
	at org.springframework.orm.jpa.JpaTemplate.find(JpaTemplate.java:311)
	at org.apache.camel.bam.processor.ActivityMonitorEngine$1.doInTransactionWithoutResult(ActivityMonitorEngine.java:80)
	at org.springframework.transaction.support.TransactionCallbackWithoutResult.doInTransaction(TransactionCallbackWithoutResult.java:33)
	at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:128)
	at org.apache.camel.bam.processor.ActivityMonitorEngine.run(ActivityMonitorEngine.java:77)
	at java.lang.Thread.run(Thread.java:619)
Caused by: java.lang.IllegalArgumentException: org.hibernate.QueryParameterException: could not locate named parameter [1]
	at org.hibernate.ejb.QueryImpl.setParameter(QueryImpl.java:206)
	at org.hibernate.ejb.QueryImpl.setParameter(QueryImpl.java:261)
	at org.springframework.orm.jpa.JpaTemplate$9.doInJpa(JpaTemplate.java:316)
	at org.springframework.orm.jpa.JpaTemplate.execute(JpaTemplate.java:184)
	... 7 more
Caused by: org.hibernate.QueryParameterException: could not locate named parameter [1]
	at org.hibernate.engine.query.ParameterMetadata.getNamedParameterDescriptor(ParameterMetadata.java:99)
	at org.hibernate.engine.query.ParameterMetadata.getNamedParameterExpectedType(ParameterMetadata.java:105)
	at org.hibernate.impl.AbstractQueryImpl.determineType(AbstractQueryImpl.java:437)
	at org.hibernate.impl.AbstractQueryImpl.setParameter(AbstractQueryImpl.java:407)
	at org.hibernate.ejb.QueryImpl.setParameter(QueryImpl.java:201)
	... 10 more
Line 80</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.bam.model.ProcessDefinition.java</file>
			<file type="M">org.apache.camel.bam.ProcessBuilder.java</file>
			<file type="M">org.apache.camel.bam.processor.ProcessContext.java</file>
			<file type="M">org.apache.camel.bam.processor.JpaBamProcessorSupport.java</file>
			<file type="M">org.apache.camel.bam.processor.ActivityMonitorEngine.java</file>
		</fixedFiles>
	</bug>
	<bug id="2209" opendate="2009-11-21 09:27:48" fixdate="2009-11-21 11:52:46" resolution="Fixed">
		<buginformation>
			<summary>SetBody DSL should remove specialized Message as its no long apply</summary>
			<description>Also an issue from
http://old.nabble.com/Original-message-body-lost-in-transacted-route-to26451809.html
This issue is because the JmsMessage is still set as the IN message object and it contain the backing javax.jms.Message object. So when you for example use the setBody DSL to set a {{null} body or empty body then it may fallback and look into the specialized JmsMessage object.
Set SetBodyProcessor should set a new DefaultMessage with the headers propagated and the new body evaluated.</description>
			<version>1.6.1</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.SetBodyDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="2215" opendate="2009-11-24 05:37:35" fixdate="2009-11-24 06:05:15" resolution="Fixed">
		<buginformation>
			<summary>CaseInsensitiveMap should be serializable</summary>
			<description>CaseInsensitiveMap should be fully serializable
See nabble
http://old.nabble.com/DataSet-header-%7BCamelDataSetIndex%3D0%7D-causes-failure-to26487985.html</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.CaseInsensitiveMap.java</file>
			<file type="M">org.apache.camel.util.CaseInsensitiveMapTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2216" opendate="2009-11-24 08:33:01" fixdate="2009-11-24 13:52:12" resolution="Fixed">
		<buginformation>
			<summary>camel-cxf should not relay on the default Bus</summary>
			<description>Sergey reported some bug  recently ,  after digging the code I found current camel-cxf&amp;amp;apos;s get defaultBus code is not safe to use when we deploy the camel route into the JBI container or OSGi container.
So we need to create the new bus if there is no bus set into the camel-cxf endpoint.</description>
			<version>1.3.0</version>
			<fixedVersion>1.6.3, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.spring.CxfRsClientFactoryBeanDefinitionParser.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfRsServerFactoryBeanDefinitionParser.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBeanDefinitionParser.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="depends upon">422</link>
		</links>
	</bug>
	<bug id="2222" opendate="2009-11-24 14:10:40" fixdate="2009-11-24 17:07:46" resolution="Fixed">
		<buginformation>
			<summary>camel-bean - Classes enhanced by CGLIB should skip cglib methods</summary>
			<description>See nabble
http://old.nabble.com/AmbiguousMethodCallException-on-transactional-spring-bean-to26496269.html</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
		</fixedFiles>
	</bug>
	<bug id="2221" opendate="2009-11-24 12:55:55" fixdate="2009-11-24 19:18:27" resolution="Fixed">
		<buginformation>
			<summary>Inconsistent out message when using recipient list</summary>
			<description>When using the Dynamic Recipient List pattern, there&amp;amp;apos;s an inconsistency between two ways of of defining that pattern:

when using a @RecipientList-annotated method with a beanRef, you get the list of endpoints as the out message body
when using the same method with a recipientList(bean(...)) call, you get the aggregated result of the invoked endpoints

I think it would be better if both options returned the same response message and I would suggested the aggregated result of the invoked endpoints is the more appropriate one.</description>
			<version>2.0.0</version>
			<fixedVersion>1.6.3, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.MethodInfo.java</file>
		</fixedFiles>
	</bug>
	<bug id="2227" opendate="2009-11-25 10:22:46" fixdate="2009-11-25 11:28:11" resolution="Fixed">
		<buginformation>
			<summary>Mock component - expectedBodiesReceived(List) does not work as expected</summary>
			<description>Java chooses the varargs methods always instead of the List method.</description>
			<version>2.0.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mock.MockEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="2231" opendate="2009-11-26 11:13:36" fixdate="2009-11-26 11:50:59" resolution="Fixed">
		<buginformation>
			<summary>Exception during mail connection requires folder to be reset</summary>
			<description>I think that this problem may still be around with 2.1-SNAPSHOT:
http://fusesource.com/forums/thread.jspa?threadID=746&amp;amp;tstart=0
I noticed that I had a pop3 server outage and then subsequently had a similar problem i.e. IllegalStateException, folder not open.
Here&amp;amp;apos;s when the outage started.

2009-11-26 11:57:55,316 [: MailComponent] WARN  ultPollingConsumerPollStrategy - Consumer Consumer[pop3://...] could not poll endpoint: pop3://... caused by: Connect failed
javax.mail.MessagingException: Connect failed;
  nested exception is:
        java.net.NoRouteToHostException: No route to host
        at com.sun.mail.pop3.POP3Store.protocolConnect(POP3Store.java:161)
        at javax.mail.Service.connect(Service.java:288)
        at org.apache.camel.component.mail.MailConsumer.ensureIsConnected(MailConsumer.java:241)
        at org.apache.camel.component.mail.MailConsumer.poll(MailConsumer.java:79)
        at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:108)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)
        at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:317)
        at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:150)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:98)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:181)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:205)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
        at java.lang.Thread.run(Thread.java:619)
Caused by: java.net.NoRouteToHostException: No route to host
        at java.net.PlainSocketImpl.socketConnect(Native Method)
        at java.net.PlainSocketImpl.doConnect(PlainSocketImpl.java:333)
        at java.net.PlainSocketImpl.connectToAddress(PlainSocketImpl.java:195)
        at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:182)
        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:366)
        at java.net.Socket.connect(Socket.java:519)
        at java.net.Socket.connect(Socket.java:469)
        at com.sun.mail.util.SocketFetcher.createSocket(SocketFetcher.java:233)
        at com.sun.mail.util.SocketFetcher.getSocket(SocketFetcher.java:189)
        at com.sun.mail.pop3.Protocol.&amp;lt;init&amp;gt;(Protocol.java:94)
        at com.sun.mail.pop3.POP3Store.getPort(POP3Store.java:214)
        at com.sun.mail.pop3.POP3Store.protocolConnect(POP3Store.java:157)
        ... 13 more


This went on for about a minute or so and there was no more in the log file until several hours later - in fact when an email appeared in the INBOX. I know this because my personal email account was copied on the email and so I have the timestamp.
I then get the following message every time I poll the server and have to re-start my application to get over it:

2009-11-26 19:19:57,293 [: MailComponent] ERROR MailConsumer                   - Folder not open
java.lang.IllegalStateException: Folder not open
        at javax.mail.Folder.getMessages(Folder.java:938)
        at javax.mail.Folder.search(Folder.java:1226)
        at org.apache.camel.component.mail.MailConsumer.poll(MailConsumer.java:107)
        at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:108)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)
        at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:317)
        at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:150)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:98)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:181)
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:205)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
        at java.lang.Thread.run(Thread.java:619)


I took a look at MailConsumer.java and note the following code:

236	        if (!connected) {
237	            if (LOG.isDebugEnabled()) {
238	                LOG.debug("Connecting to MailStore: " + endpoint.getConfiguration().getMailStoreLogInformation());
239	            }
240	            store = sender.getSession().getStore(config.getProtocol());
241	            store.connect(config.getHost(), config.getPort(), config.getUsername(), config.getPassword());
242	        }


If you&amp;amp;apos;re not connected then how is it possible to have a folder? Following this logic my recommendation is to insert the following at line 242:

241	            store.connect(config.getHost(), config.getPort(), config.getUsername(), config.getPassword());
                    folder = null;
242	        }

</description>
			<version>1.6.2</version>
			<fixedVersion>1.6.3, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailConsumer.java</file>
		</fixedFiles>
		<links>
			<link type="Supercedes" description="supercedes">1501</link>
		</links>
	</bug>
	<bug id="2232" opendate="2009-11-26 17:52:34" fixdate="2009-11-27 06:46:26" resolution="Fixed">
		<buginformation>
			<summary>Mail component sends to the wrong address</summary>
			<description>The camel mail page states that the issues with the Mail Component are related to geronimo.  However there is a fundamental problem when you have more than 1 endpoint defined.  We define multiple endpoints so we can place different To addresses
        &amp;lt;endpoint id="oneEmail" uri="smtp://MAILSERVER?To=$
{one.email}
&amp;amp;From=blah@blah.com" /&amp;gt;
        &amp;lt;endpoint id="twoEmail" uri="smtp://MAILSERVER?To=$
{two.email}
&amp;amp;From=blah@blah.com" /&amp;gt;
        &amp;lt;endpoint id="errorEmail" uri="smtp://MAILSERVER?To=$
{error.email}
&amp;amp;From=blah@blah.com" /&amp;gt;
            &amp;lt;to uri="bean:errorFormatter?method=formatErrorEmail" /&amp;gt;
            &amp;lt;to ref="errorEmail" /&amp;gt;
It is not possible to configure the uri in &amp;lt;to /&amp;gt; since it does not support spring properties.  
The bug is that MailConfiguration.copy() does not create a new Map for recipients, so when the second endpoint is created it overwrites the first. there are other fields that may be affected e.g. javaMailProperties, additionalJavaMailProperties, javaMailSender
http://camel.apache.org/mail.html
If you have trouble with sending mails that, for instance, don&amp;amp;apos;t contain any subject, have wrong recipients, or manifest other unforeseen errors, it could be due to having geronimo-javamail_1.4_spec-1.3.jar in your classpath. This was the culprit in a long bug hunt reported in CAMEL-869.
This should be changed as wrong recipients are more likely related to camel bugs, than geronimo issues.</description>
			<version>2.0.0</version>
			<fixedVersion>1.6.3, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailConfiguration.java</file>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="2238" opendate="2009-11-30 11:15:04" fixdate="2009-11-30 11:27:55" resolution="Fixed">
		<buginformation>
			<summary>JettyHttpProducer - Sending sync using waitForDone should cater for connection failures</summary>
			<description>Even though we follow the Jetty documentation it will make the jetty http producer appear as blocked as waitForDone() will block when connection failure occurred.
We need to add logic which polls the status instead and thus can detect the problem.
The async producer done not have this issue by which is likely the main use case for using Jetty as a client</description>
			<version>2.1.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyHttpProducer.java</file>
			<file type="M">org.apache.camel.component.jetty.jettyproducer.JettyHttpProducerGetWithParamAsExchangeHeaderTest.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyContentExchange.java</file>
		</fixedFiles>
	</bug>
	<bug id="2237" opendate="2009-11-30 09:46:44" fixdate="2009-12-01 14:31:16" resolution="Fixed">
		<buginformation>
			<summary>Improper ordering of MINA filters</summary>
			<description>When we want to use SSL on the consumer side, MINA&amp;amp;apos;s SSLFilter must be inserted as the very first filter into the chain (or, at least, as the second one after an ExecutorFilter), but it is currently not possible, because MinaComponent#createSocketEndpoint() always inserts a ProtocolCodecFilter at the very beginning by calling configureCodecFactory().
A proposed workaround is to introduce an additional URL parameter noDefaultCodec which prohibits the installation of the default protocol codec filter. The protocol codec must be then configured manually, e.g. using Spring:

&amp;lt;bean id="sslFilter" class="org.apache.mina.filter.SSLFilter"&amp;gt;
    &amp;lt;constructor-arg&amp;gt;
        &amp;lt;bean class="javax.net.ssl.SSLContext" factory-method="getDefault" /&amp;gt;
    &amp;lt;/constructor-arg&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id="codecFilter" class="org.apache.mina.filter.codec.ProtocolCodecFilter"&amp;gt;
    &amp;lt;constructor-arg ref="hl7codec" /&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id="hl7codec" class="org.apache.camel.component.hl7.HL7MLLPCodec" /&amp;gt;
&amp;lt;bean id="minaFilters" class="java.util.ArrayList"&amp;gt;
    &amp;lt;constructor-arg&amp;gt;
        &amp;lt;list value-type="org.apache.mina.common.IoFilter"&amp;gt;
             &amp;lt;ref bean="sslFilter" /&amp;gt; 
             &amp;lt;ref bean="codecFilter" /&amp;gt; 
        &amp;lt;/list&amp;gt;
    &amp;lt;/constructor-arg&amp;gt;
&amp;lt;/bean&amp;gt;
After that, the consumer endpoint URL can look like
from("mina:tcp://0.0.0.0:8888?sync=true&amp;amp;lazySessionCreation=true&amp;amp;noDefaultCodec=true&amp;amp;filters=#minaFilters").
I am not sure whether this approach is optimal, therefore I call it "workaround" and not "solution".  The corresponding patch is attached.</description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina.MinaFiltersTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaConfiguration.java</file>
			<file type="M">org.apache.camel.component.mina.MinaComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="2245" opendate="2009-12-01 19:11:08" fixdate="2009-12-01 19:20:05" resolution="Fixed">
		<buginformation>
			<summary>Routing slip does not stop when Exchange is failed</summary>
			<description></description>
			<version>1.6.2</version>
			<fixedVersion>1.6.3, 2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.RoutingSlip.java</file>
			<file type="M">org.apache.camel.processor.routingslip.RoutingSlipWithExceptionTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2250" opendate="2009-12-03 07:12:16" fixdate="2009-12-03 07:44:51" resolution="Fixed">
		<buginformation>
			<summary>InterceptSendToEndpoint - Should stop sending to intercepted endpoint in case of Exchange failure</summary>
			<description>We had a similar issue recently with the routing slip. The same goes for intercept send to endpoint.</description>
			<version>2.0.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultExchange.java</file>
			<file type="M">org.apache.camel.impl.InterceptSendToEndpoint.java</file>
			<file type="M">org.apache.camel.processor.interceptor.AdviceWithTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2251" opendate="2009-12-03 09:36:37" fixdate="2009-12-03 10:00:23" resolution="Fixed">
		<buginformation>
			<summary>CXFBean should not call the BusFactory.getDefaultBus() </summary>
			<description>The defaultBus could be polluted in the container like ServceMix.</description>
			<version>2.0-M2</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.cxfbean.CxfBeanEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="2255" opendate="2009-12-04 08:20:59" fixdate="2009-12-04 08:36:58" resolution="Fixed">
		<buginformation>
			<summary>camel-example-etl throw error when running it.</summary>
			<description>Here is the stack trace.

[  Camel thread 0: JpaComponent] JuelExpression                 DEBUG No
impl class for juel ExpressionFactory defined in
&amp;amp;apos;META-INF/services/org/apach
e/camel/component/el&amp;amp;apos;
org.apache.camel.NoFactoryAvailableException: Could not find factory class
for resource: META-INF/services/org/apache/camel/component/juel
        at
org.apache.camel.impl.DefaultFactoryFinder.doFindFactoryProperties(DefaultFactoryFinder.java:135)
        at
org.apache.camel.impl.DefaultFactoryFinder.findClass(DefaultFactoryFinder.java:77)
        at
org.apache.camel.language.juel.JuelExpression.getExpressionFactory(JuelExpression.java:81)
        at
org.apache.camel.language.juel.JuelExpression.evaluate(JuelExpression.java:70)
        at
org.apache.camel.builder.ProcessorBuilder$4.process(ProcessorBuilder.java:94)
        at
org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:67)
        at
org.apache.camel.processor.DelegateProcessor.processNext(DelegateProcessor.java:53)
        at
org.apache.camel.processor.DelegateProcessor.proceed(DelegateProcessor.java:82)
        at
org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:93)
        at
org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:67)
        at
org.apache.camel.processor.RedeliveryErrorHandler.processExchange(RedeliveryErrorHandler.java:223)
        at
org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:153)
        at
org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:91)
        at
org.apache.camel.processor.DefaultErrorHandler.process(DefaultErrorHandler.java:49)
        at
org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:206)
        at org.apache.camel.processor.Pipeline.process(Pipeline.java:74)
        at
org.apache.camel.processor.UnitOfWorkProcessor.processNext(UnitOfWorkProcessor.java:54)
        at
org.apache.camel.processor.DelegateProcessor.process(DelegateProcessor.java:48)
        at
org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:67)
        at
org.apache.camel.component.jpa.JpaConsumer.processBatch(JpaConsumer.java:133)
        at
org.apache.camel.component.jpa.JpaConsumer$1.doInJpa(JpaConsumer.java:86)
        at
org.apache.camel.component.jpa.JpaTemplateTransactionStrategy$1$1.doInJpa(JpaTemplateTransactionStrategy.java:81)
        at
org.springframework.orm.jpa.JpaTemplate.execute(JpaTemplate.java:184)
        at
org.springframework.orm.jpa.JpaTemplate.execute(JpaTemplate.java:147)
        at
org.apache.camel.component.jpa.JpaTemplateTransactionStrategy$1.doInTransaction(JpaTemplateTransactionStrategy.java:79)
        at
org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:128)
        at
org.apache.camel.component.jpa.JpaTemplateTransactionStrategy.execute(JpaTemplateTransactionStrategy.java:77)
        at
org.apache.camel.component.jpa.JpaConsumer.poll(JpaConsumer.java:70)
        at
org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:108)
        at
java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)
        at
java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:317)
        at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:150)
        at
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:98)
        at
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:181)
        at
java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:205)
        at
java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
        at
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
        at java.lang.Thread.run(Thread.java:619)

</description>
			<version>2.2.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.language.juel.JuelExpression.java</file>
		</fixedFiles>
	</bug>
	<bug id="2269" opendate="2009-12-09 05:47:29" fixdate="2009-12-09 07:40:13" resolution="Fixed">
		<buginformation>
			<summary>doCatch() - Without any exception given should report that as a problem</summary>
			<description>Code like this

                    .doTry()
                        .to("mock:b")
                        .throwException(new IllegalArgumentException("Damn"))
                    .doCatch()
                        .to("mock:catch")
                    .end();


Should report a failure in the route as doCatch must have at least 1 exception as parameter.
It should correctly be
                    .doCatch(Exception.class)
We could also consider using Excpetion.class as default but in Java you must also provide the exception to catch and thus its more intuitive if its 100% like Java</description>
			<version>2.0.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.CatchDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="2274" opendate="2009-12-10 08:28:38" fixdate="2009-12-10 09:43:25" resolution="Fixed">
		<buginformation>
			<summary>Camel proxy - Detect the proxied method returned null and allow that as a valid answer</summary>
			<description>See nabble
http://old.nabble.com/Can%27t-return-null-with-Camel-remoting-ts26682177.html</description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.CamelInvocationHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="2275" opendate="2009-12-10 09:56:59" fixdate="2009-12-10 12:44:21" resolution="Fixed">
		<buginformation>
			<summary>camel-jpa JPAEndpoint eat up the cause of  InvalidPayloadException</summary>
			<description>Here is the mail thread discuss this issue.
http://old.nabble.com/TypeConverter-%3A-Should-it-be-blocking-for-camel-route-or-not-in-case--of-error---td26723837.html</description>
			<version>1.4.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.InvalidPayloadRuntimeException.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="2278" opendate="2009-12-10 14:08:26" fixdate="2009-12-14 09:27:16" resolution="Fixed">
		<buginformation>
			<summary>recipientList onException redelivery issue</summary>
			<description>using a recipientList containing a csv list of ftp endpoints.
I would like to retry the delivery to a given ftp enpoint fails. 
I&amp;amp;apos;ve set up an onException with maximumRedeliveries set to 2. 
In case an error occurs sending the message to 1 ftp endpoint the redelivery is performed on all endpoints specified on the csv list; the redelivery should be performed only on the failed endpoint is there a way to achieve this?
route sample 
from("direct:delivery.notification.test")
.onException(Exception.class).maximumRedeliveries(2).redeliverDelay(60L).handled(true).end()
.recipientList(header("recipientListHeader").tokenize(","))
.parallelProcessing().executorService(customThreadPoolExecutor)
						//.aggregationStrategy(new recipientAggregationStrategy())
						.to("direct:chunk.completed");</description>
			<version>2.2.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.RecipientListFineGrainedErrorHandlingTest.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
			<file type="M">org.apache.camel.processor.MulticastParallelStopOnExceptionTest.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.processor.MulticastStopOnExceptionTest.java</file>
			<file type="M">org.apache.camel.processor.MulticastFineGrainedErrorHandlingTest.java</file>
			<file type="M">org.apache.camel.spi.UnitOfWork.java</file>
			<file type="M">org.apache.camel.issues.CharlesSplitAndTryCatchRollbackIssueTest.java</file>
			<file type="M">org.apache.camel.Channel.java</file>
			<file type="M">org.apache.camel.impl.DefaultRouteContext.java</file>
			<file type="M">org.apache.camel.processor.interceptor.TraceInterceptor.java</file>
			<file type="M">org.apache.camel.CamelExchangeException.java</file>
			<file type="M">org.apache.camel.processor.DefaultChannel.java</file>
			<file type="M">org.apache.camel.model.ThreadsDefinition.java</file>
			<file type="M">org.apache.camel.processor.UnitOfWorkProcessor.java</file>
			<file type="M">org.apache.camel.model.MulticastDefinition.java</file>
			<file type="M">org.apache.camel.processor.SplitterStopOnExceptionTest.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
			<file type="M">org.apache.camel.model.OnCompletionDefinition.java</file>
			<file type="M">org.apache.camel.processor.SplitterParallelStopOnExceptionTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultUnitOfWork.java</file>
			<file type="M">org.apache.camel.model.ToDefinition.java</file>
			<file type="M">org.apache.camel.processor.RedeliveryErrorHandler.java</file>
			<file type="M">org.apache.camel.processor.ErrorHandlerSupport.java</file>
			<file type="M">org.apache.camel.TestSupport.java</file>
			<file type="M">org.apache.camel.processor.ErrorHandlerSupportTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2289" opendate="2009-12-14 16:29:11" fixdate="2009-12-14 16:30:34" resolution="Fixed">
		<buginformation>
			<summary>camel-bindy - csv - Make it easier to marshal with POJO out of the box</summary>
			<description>Its to ugly that you must use List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; to wrap you POJO to let Bindy be able to marhal my POJO to a CSV record.
It should be able to detect that its not a List but a plain POJO and construct the List itself and based on defaults.</description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindyCsvDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyCsvFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="2303" opendate="2009-12-18 12:10:15" fixdate="2009-12-18 13:12:44" resolution="Fixed">
		<buginformation>
			<summary>GroupedExchange in Aggregator is not working correctly</summary>
			<description>See nabble
http://old.nabble.com/Help%21-org.apache.camel.impl.GroupedExchange-does-not-exist-in-the-latest-download-ts26841584.html</description>
			<version>2.0.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.aggregator.AggregateGroupedExchangeTest.java</file>
			<file type="M">org.apache.camel.model.AggregateDefinition.java</file>
			<file type="M">org.apache.camel.processor.BatchProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="2306" opendate="2009-12-20 08:18:23" fixdate="2009-12-20 08:57:37" resolution="Fixed">
		<buginformation>
			<summary>IOConverter - File to byte[] should close input stream</summary>
			<description>See nabble
http://old.nabble.com/Problem-with-JMS-and-file-ts26857645.html
Most likely a problem on Windows as it tend to lock files for much longer duration than needed.</description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.IOConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2318" opendate="2009-12-24 09:25:29" fixdate="2009-12-24 09:35:10" resolution="Fixed">
		<buginformation>
			<summary>camel-bindy dataformat KeyValue DSL can&amp;apos;t work</summary>
			<description>     When you set the bindy dataformat with below DSL , you will get the error that camel can&amp;amp;apos;t find the DataFormat. 

 
     public void configure() {
            from("direct:start").marshal()
                .bindy(BindyType.KeyValue, "org.apache.camel.dataformat.bindy.model.fix.simple")
                .to("mock:result");
        }
     
</description>
			<version>2.0-M1</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.dataformat.BindyDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="2320" opendate="2009-12-24 18:11:03" fixdate="2009-12-25 08:53:21" resolution="Fixed">
		<buginformation>
			<summary>JDBC component doesn&amp;apos;t preserve headers</summary>
			<description>JDBC component doesn&amp;amp;apos;t preserve any of the headers that are sent into it</description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jdbc.JdbcProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2292" opendate="2009-12-15 15:18:02" fixdate="2009-12-29 02:01:00" resolution="Fixed">
		<buginformation>
			<summary>RejectedExecutionException after restarting camel context</summary>
			<description>User reported over the #camel channel the following exception trying to send a message after the context was stopped and restarted
 "Failed to create Producer for endpoint:". Thats the exception I&amp;amp;apos;m getting
Reason: java.util.concurrent.RejectedExecutionException

Exception in thread "core" org.apache.camel.FailedToCreateProducerException: Failed to create Producer for endpoint: Endpoint[activemq://queue:request.lavaOrderProducer.powerTraderServer]. Reason: java.util.concurrent.RejectedExecutionException
	at org.apache.camel.component.jms.JmsProducer.testAndSetRequestor(JmsProducer.java:116)
	at org.apache.camel.component.jms.JmsProducer.processInOut(JmsProducer.java:175)
	at org.apache.camel.component.jms.JmsProducer.process(JmsProducer.java:147)
	at org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:179)
	at org.apache.camel.impl.ProducerCache$1.doInProducer(ProducerCache.java:161)
	at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:146)
	at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:160)
	at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:98)
	at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:97)
	at com.wjb.producer.lavaData.dispatcher.ServerRequestDispatcher.requestSymbolSectorArray(ServerRequestDispatcher.java:122)
	at com.wjb.producer.core.LavaDataManager.initialize(LavaDataManager.java:64)
	at com.wjb.producer.core.ProducerCore.run(ProducerCore.java:98)
	at java.lang.Thread.run(Thread.java:619)
Caused by: java.util.concurrent.RejectedExecutionException
	at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:1760)
	at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:767)
	at java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute(ScheduledThreadPoolExecutor.java:216)
	at java.util.concurrent.ScheduledThreadPoolExecutor.schedule(ScheduledThreadPoolExecutor.java:366)
	at org.apache.camel.util.DefaultTimeoutMap.schedulePoll(DefaultTimeoutMap.java:156)
	at org.apache.camel.util.DefaultTimeoutMap.&amp;lt;init&amp;gt;(DefaultTimeoutMap.java:52)
	at org.apache.camel.component.jms.requestor.Requestor.&amp;lt;init&amp;gt;(Requestor.java:68)
	at org.apache.camel.component.jms.JmsProducer.testAndSetRequestor(JmsProducer.java:107)


The following unit tests seems to reproduce the problem:

ublic final class StartStopTest 
{
	private final GenericApplicationContext applicationContext = new GenericApplicationContext();
	private final int testCount = 3;
	
	@Test
	public void test() throws Exception 
	{		
		//Initialize
		final File propertiesFile = new File(Constants.RESOURCE_DIRECTORY_NAME, Constants.PROPERTIES_FILE_NAME);
		PropertyConfigurator.configure(propertiesFile.getPath());
		
		final File applicationContextFile = new File(Constants.RESOURCE_DIRECTORY_NAME, Constants.CONTEXT_FILE_NAME);	
		final Resource applicationContextResource = new FileSystemResource(applicationContextFile);
				
		final AbstractBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(this.applicationContext);
		
		beanDefinitionReader.loadBeanDefinitions(applicationContextResource);
		this.applicationContext.refresh();	
		
		//Begin Testing
		for (int i = 0; i &amp;lt; this.testCount; i++)
		{			
			this.startSendStop();
		    Thread.sleep(3000);
		}		
	}
	
	private void startSendStop() throws Exception
	{
		final SpringCamelContext springCamelContext = (SpringCamelContext)this.applicationContext.getBean(Constants.CAMEL_CONTEXT_NAME);
		final ProducerTemplate producerTemplate;
		final Endpoint serverRequestQueue;
		
		springCamelContext.start();
		
		producerTemplate = springCamelContext.createProducerTemplate();
		serverRequestQueue = springCamelContext.getEndpoint("serverRequestQueue");
		
		final Exchange exchange = producerTemplate.send(serverRequestQueue, new Processor()
		{
			public void process(final Exchange exchange) throws Exception 
			{				
				exchange.setPattern(ExchangePattern.InOut);	
				exchange.getIn().setHeader(ServerJmsServices.REQUEST, ServerJmsServices.GET_SYMBOL_INFO);
				exchange.getIn().setBody("");
			}			
		});
		final String responseString = (String)exchange.getOut().getBody();
		
		Assert.assertTrue(responseString.length() &amp;gt; 0);
		
		springCamelContext.stop();
	}
}


&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;beans xmlns="http://www.springframework.org/schema/beans" 
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:camel="http://camel.apache.org/schema/spring"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
                           http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd"&amp;gt;
        
    &amp;lt;!-- ActiveMQ component for Camel to use --&amp;gt;   
    &amp;lt;bean id="activemq" class="org.apache.activemq.camel.component.ActiveMQComponent" &amp;gt; 
        &amp;lt;property name="connectionFactory"&amp;gt; 
            &amp;lt;bean class="org.apache.activemq.ActiveMQConnectionFactory"&amp;gt; 
                &amp;lt;property name="brokerURL" value="tcp://192.168.5.10:61616?daemon=true" /&amp;gt;
            &amp;lt;/bean&amp;gt; 
        &amp;lt;/property&amp;gt; 
    &amp;lt;/bean&amp;gt; 
           
    &amp;lt;!-- Camel Context --&amp;gt;
    &amp;lt;camelContext id="camelContext" xmlns="http://camel.apache.org/schema/spring" autoStartup="false"&amp;gt;   	
    	&amp;lt;camel:endpoint id="serverRequestQueue"	uri="activemq:queue:request.lavaOrderProducer.powerTraderServer" /&amp;gt;   	
    &amp;lt;/camelContext&amp;gt;
&amp;lt;/beans&amp;gt;

</description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultProducerTemplate.java</file>
			<file type="M">org.apache.camel.component.jms.JmsConfiguration.java</file>
			<file type="M">org.apache.camel.impl.ProducerCache.java</file>
		</fixedFiles>
	</bug>
	<bug id="1966" opendate="2009-09-01 04:55:28" fixdate="2009-12-30 02:24:33" resolution="Fixed">
		<buginformation>
			<summary>CamelNamespaceHandler is not thread safe</summary>
			<description>Here is the mail thread[1] which discusses about it.
[1] http://www.nabble.com/Occasional-CamelNamespaceHandler-exception-when-running-with-Spring-DM-1.2-td25195171.html</description>
			<version>1.4.0</version>
			<fixedVersion>1.6.2, 2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.handler.CamelNamespaceHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="2327" opendate="2010-01-02 04:59:03" fixdate="2010-01-02 05:13:25" resolution="Fixed">
		<buginformation>
			<summary>The NP check of the remote service is wrong in CamelServiceExporter </summary>
			<description>We should check the export service instead of the camelContext.
 components/camel-spring/src/main/java/org/apache/camel/spring/remoting/CamelServiceExporter.jav(revision 895109)
+++ components/camel-spring/src/main/java/org/apache/camel/spring/remoting/CamelServiceExporter.jav(working copy)
@@ -83,7 +83,7 @@
         }
         Endpoint endpoint = CamelContextHelper.getMandatoryEndpoint(camelContext, uri);

notNull(camelContext, "service");
+        notNull(getService(), "service");
         Object proxy = getProxyForService();

         consumer = endpoint.createConsumer(new BeanProcessor(proxy, camelContext));</description>
			<version>1.4.0</version>
			<fixedVersion>1.6.3, 2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.remoting.CamelServiceExporter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2325" opendate="2010-01-01 17:08:10" fixdate="2010-01-03 17:53:53" resolution="Fixed">
		<buginformation>
			<summary>@Produce - Causes BeanInvocation to be kept as Body which causes problem with subsequent bean invocations</summary>
			<description>The route

    &amp;lt;camelContext id="camel" trace="true" xmlns="http://camel.apache.org/schema/spring"&amp;gt;
        &amp;lt;route&amp;gt;
            &amp;lt;from uri="direct:start"/&amp;gt;
            &amp;lt;to uri="log:foo"/&amp;gt;
            &amp;lt;split&amp;gt;
                &amp;lt;method bean="cool" method="split"/&amp;gt;
                &amp;lt;transform&amp;gt;&amp;lt;simple&amp;gt;Hello ${body}&amp;lt;/simple&amp;gt;&amp;lt;/transform&amp;gt;
                &amp;lt;to uri="mock:split"/&amp;gt;
            &amp;lt;/split&amp;gt;
        &amp;lt;/route&amp;gt;
    &amp;lt;/camelContext&amp;gt;


Is caused problem when a @Produce bean is used to send a message to the route.
2010-01-01 18:07:43,720 [main           ] ERROR DefaultErrorHandler            - Failed delivery for exchangeId: b7098680-4a16-4289-bdf4-3197b0b37aea. Exhausted after delivery attempt: 1 caught: org.apache.camel.language.bean.RuntimeBeanExpressionException: Failed to invoke method: split on cool due to: org.apache.camel.RuntimeCamelException: java.lang.IllegalArgumentException: object is not an instance of declaring class</description>
			<version>2.0.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanProcessor.java</file>
			<file type="M">org.apache.camel.spring.remoting.CamelProxyFactoryBean.java</file>
			<file type="M">org.apache.camel.component.bean.BeanInvocation.java</file>
			<file type="M">org.apache.camel.builder.ExpressionBuilder.java</file>
			<file type="M">org.apache.camel.issues.ProxyReturnNullIssueTest.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.component.bean.BeanProxyTest.java</file>
			<file type="M">org.apache.camel.component.bean.BeanConverter.java</file>
			<file type="M">org.apache.camel.component.bean.OrderService.java</file>
		</fixedFiles>
	</bug>
	<bug id="2059" opendate="2009-10-11 15:57:10" fixdate="2010-01-05 19:21:57" resolution="Fixed">
		<buginformation>
			<summary>Creating a transacted pipeline with custom error handling is difficult</summary>
			<description>When trying to add error logging to a transacted pipeline, I discovered the following issues:
(1) onException/onCompletion do not work in a transacted route
(2) if the transacted tag is not the first element in the route, all the endpoints above it will be silently ignored
(3) custom error handlers interact very awkwardly with transacted routes (specifically, a non-transacted error handler will not work at all on a transacted route)
I was able to solve my problem using doTry/doCatch; this may be a good candidate for adding to the docs.
I suggest that, if the above issues are not corrected (especially 2+3, which may not be route designs that it is desired to support), they should trigger errors in the corresponding pipeline.
I have attached a tgz of examples showing problems (1) and (2) above, as well as my successful route.</description>
			<version>2.0.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.OnExceptionDefinition.java</file>
			<file type="M">org.apache.camel.model.TransactedDefinition.java</file>
			<file type="M">org.apache.camel.model.OnCompletionDefinition.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.model.InterceptSendToEndpointDefinition.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.model.InterceptFromDefinition.java</file>
			<file type="M">org.apache.camel.model.InterceptDefinition.java</file>
			<file type="M">org.apache.camel.model.PolicyDefinition.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="depends upon">2336</link>
		</links>
	</bug>
	<bug id="2336" opendate="2010-01-05 16:07:11" fixdate="2010-01-05 19:22:41" resolution="Fixed">
		<buginformation>
			<summary>Spring DSL - Some route scoped concerns such as onException etc. can vanish in some edge cases</summary>
			<description>The JAXB creates the Spring DSL model in a bit wacky way so we need to work on it a bit before Camel can create the runtime routes.
In some cases some of the cross functions such as onCompletion, onException could potentially vanish. 
The problem is really that we should have divided the route into a upper / lower section where upper is the cross functions and the lower the actual route.</description>
			<version>2.0.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.OnCompletionAndInterceptAndOnExceptionGlobalTest.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.model.OnExceptionDefinition.java</file>
			<file type="M">org.apache.camel.model.TransactedDefinition.java</file>
			<file type="M">org.apache.camel.model.OnCompletionDefinition.java</file>
			<file type="M">org.apache.camel.model.InterceptSendToEndpointDefinition.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.model.InterceptFromDefinition.java</file>
			<file type="M">org.apache.camel.model.InterceptDefinition.java</file>
			<file type="M">org.apache.camel.model.PolicyDefinition.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="is depended upon by">2059</link>
		</links>
	</bug>
	<bug id="2341" opendate="2010-01-07 08:35:30" fixdate="2010-01-08 08:00:44" resolution="Fixed">
		<buginformation>
			<summary>camel-web - Using Sun marshal resolver not possible on non SUN JDK platforms</summary>
			<description>For example on RH 5.2 64bit JDK 1.6

Compilation failure 
/x1/TeamCity/buildAgent/work/1ad9cee4e4314563/camel-fuse-trunk/components/camel-web/src/main/java/org/apache/camel/web/util/JAXBMarshallerResolver.java:[25,34] package com.sun.xml.bind.marshaller does not exist 
/x1/TeamCity/buildAgent/work/1ad9cee4e4314563/camel-fuse-trunk/components/camel-web/src/main/java/org/apache/camel/web/util/JAXBMarshallerResolver.java:[42,12] cannot find symbol 
symbol : class NamespacePrefixMapper 
location: class org.apache.camel.web.util.JAXBMarshallerResolver 
/x1/TeamCity/buildAgent/work/1ad9cee4e4314563/camel-fuse-trunk/components/camel-web/src/main/java/org/apache/camel/web/util/JAXBMarshallerResolver.java:[42,56] cannot find symbol 
symbol : class NamespacePrefixMapper 
location: class org.apache.camel.web.util.JAXBMarshallerResolver 


I assume AIX, HP-UX and others do have this issue as well.
James maybe we need to revert that change you made?</description>
			<version>2.2.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.web.resources.RoutesResource.java</file>
			<file type="M">org.apache.camel.web.resources.RouteResource.java</file>
			<file type="M">org.apache.camel.web.resources.EndpointsResource.java</file>
			<file type="M">org.apache.camel.web.resources.Constants.java</file>
			<file type="M">org.apache.camel.web.resources.CamelContextResource.java</file>
		</fixedFiles>
		<links>
			<link type="Regression" description="is broken by">2301</link>
		</links>
	</bug>
	<bug id="2249" opendate="2009-12-02 22:54:20" fixdate="2010-01-08 10:33:43" resolution="Fixed">
		<buginformation>
			<summary>Wrong handling of useMessageIDAsCorrelationID</summary>
			<description>Camel jms seems to contain two bugs in correlation id handling.
The first shows when you have a sender that has UseMessageIDAsCorrelationID="false" and a server that has UseMessageIDAsCorrelationID="true". If you send a message with correlationId="a" then the response message will contain correlationId="&amp;lt;request message id&amp;gt;". Even if this could be a valid behaviour as you wanted UseMessageIDAsCorrelationID="true" I dont think it makes sense as the sender will not be able to correlate the message. So for this case I propose to only set the correlation id to the request message id on the server if the correlation id of the request was not set.
The second bug seems to hide the first bug. Perhaps someone found a quick (and wrong way to make the tests work). It shows when you set UseMessageIDAsCorrelationID="true" on both client and server. If you send a message with correlation id = "a" the client sends it out with this correlation id. The server then sets the correlation id to the request message id (first bug). Then on the client the reply is received. After that the correlation id is set back to "a" on the client. So the tests think all is well. This part of the code should be removed.
I have marked both problems in the code with FIXME markers in my patch. I can also provide a patch with the solution but first I wanted to only show the problem and provide a failing test. 
Hope my explanations were not to confused </description>
			<version>2.0.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsSimpleInOnlyNoMutateTest.java</file>
			<file type="M">org.apache.camel.component.jms.EndpointMessageListener.java</file>
			<file type="M">org.apache.camel.component.jms.JmsProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2353" opendate="2010-01-13 05:38:03" fixdate="2010-01-13 06:16:01" resolution="Fixed">
		<buginformation>
			<summary>Simple Language - Parsing complex date patterns fails if they contain additional colons</summary>
			<description>See nabble
http://old.nabble.com/Camel-%3A-Date-Pattern-ts27131137.html</description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.language.simple.SimpleLanguage.java</file>
			<file type="M">org.apache.camel.language.SimpleTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2345" opendate="2010-01-08 15:23:28" fixdate="2010-01-14 10:24:19" resolution="Fixed">
		<buginformation>
			<summary>One should not have to explicitly provide the service/port for cxf is there&amp;apos;s only one</summary>
			<description>This is due to the following code in Client createClient() in CxfEnpoint

        } else {
            ObjectHelper.notNull(portName, "Please provide endpoint/port name");
            ObjectHelper.notNull(serviceName, "Please provide service name");
            ClientFactoryBean factoryBean = createClientFactoryBean();


When there&amp;amp;apos;s only one service/port, we should just use it.</description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="2362" opendate="2010-01-14 11:54:18" fixdate="2010-01-15 08:25:18" resolution="Fixed">
		<buginformation>
			<summary>FTP assumes that directory name do not have dot </summary>
			<description>
See http://old.nabble.com/FTP-assume-directory-do-not-have-dot-td27153817.html#a27160086
(COpy paste)
&amp;gt;
&amp;gt; I have the following error:
&amp;gt;
&amp;gt; Caused by: java.lang.IllegalArgumentException: Only directory is supported.
&amp;gt; Endpoint must be configured with a valid directory: ftp.test
&amp;gt;        at
&amp;gt; org.apache.camel.component.file.remote.RemoteFileEndpoint.createConsumer(RemoteFileEndpoint.java:68)
&amp;gt;        at
&amp;gt; org.apache.camel.component.file.remote.RemoteFileEndpoint.createConsumer(RemoteFileEndpoint.java:31)
&amp;gt;        at
&amp;gt; org.apache.camel.impl.EventDrivenConsumerRoute.addServices(EventDrivenConsumerRoute.java:60)
&amp;gt;        at
&amp;gt; org.apache.camel.impl.DefaultRoute.onStartingServices(DefaultRoute.java:83)
&amp;gt;        at org.apache.camel.impl.RouteService.doStart(RouteService.java:123)
&amp;gt;        at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:55)
&amp;gt;        at
&amp;gt; org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:906)
&amp;gt;        ... 1 more
&amp;gt;
&amp;gt; By looking at the source code I saw the following :
&amp;gt;        // we assume its a file if the name has a dot in it (eg foo.txt)
&amp;gt;        if (configuration.getDirectory().contains(".")) 
{
&amp;gt;            throw new IllegalArgumentException("Only directory is supported.
&amp;gt; Endpoint must be configured with a valid directory: "
&amp;gt;                    + configuration.getDirectory());
&amp;gt;        }
&amp;gt;
&amp;gt; I remove that code and my code is working!! 
&amp;gt;
&amp;gt; I think the above code should not assume that.....
&amp;gt; What do you think ?
&amp;gt;
... [show rest of quote]
Its really a bad habit having a dot in a directory name.
On windows will that not often be considered a file?.
And since its a remote path we cannot on startup determine if its a
path or file.
The check was made in the transition from 1.x to 2.x where in 1.x you
could define a starting file or directory.
In 2.x you must specify a directory only.
We could relax the check but then people may still enter a filename
and think Camel will pickup that file.
[SIMON]
Windows directory can contains a dot... a good example is in your eclipse installation... example:
Directory name=org.eclipse.emf.teneo.jpox_1.0.1.v200902271808
Also I think that check is useless because you can still enter something without a dot and it is in fact a file... so the endpoint should verify that after the connection.
Simon 
Yeah good call
Do you mind creating a ticket in JIRA about this?
http://issues.apache.org/activemq/browse/CAMEL</description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.UriConfigurationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2376" opendate="2010-01-18 18:07:40" fixdate="2010-01-19 06:05:26" resolution="Fixed">
		<buginformation>
			<summary>org.apache.camel.issues.RetryRouteScopedUntilRecipientListParallelIssueTest failing on build on trunk</summary>
			<description>Unit test failing on mvn install on latest head from trunk.
mvn -e output
-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running org.apache.camel.issues.RetryRouteScopedUntilRecipientListParallelIssueTest
Tests run: 7, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 11.866 sec &amp;lt;&amp;lt;&amp;lt; FAILURE!
Results :
Failed tests: 
  testRetryUntilRecipientListOkAndFail(org.apache.camel.issues.RetryRouteScopedUntilRecipientListParallelIssueTest)
Tests run: 7, Failures: 1, Errors: 0, Skipped: 0
[INFO] ------------------------------------------------------------------------
[ERROR] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] There are test failures.
Please refer to /data/workspace/camel/camel-core/target/surefire-reports for the individual test results.
[INFO] ------------------------------------------------------------------------
[INFO] Trace
org.apache.maven.BuildFailureException: There are test failures.
Please refer to /data/workspace/camel/camel-core/target/surefire-reports for the individual test results.
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoals(DefaultLifecycleExecutor.java:715)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoalWithLifecycle(DefaultLifecycleExecutor.java:556)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoal(DefaultLifecycleExecutor.java:535)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoalAndHandleFailures(DefaultLifecycleExecutor.java:387)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeTaskSegments(DefaultLifecycleExecutor.java:348)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.execute(DefaultLifecycleExecutor.java:180)
	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:328)
	at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:138)
	at org.apache.maven.cli.MavenCli.main(MavenCli.java:362)
	at org.apache.maven.cli.compat.CompatibleMain.main(CompatibleMain.java:60)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.classworlds.Launcher.launchEnhanced(Launcher.java:315)
	at org.codehaus.classworlds.Launcher.launch(Launcher.java:255)
	at org.codehaus.classworlds.Launcher.mainWithExitCode(Launcher.java:430)
	at org.codehaus.classworlds.Launcher.main(Launcher.java:375)
Caused by: org.apache.maven.plugin.MojoFailureException: There are test failures.
Please refer to /data/workspace/camel/camel-core/target/surefire-reports for the individual test results.
	at org.apache.maven.plugin.surefire.SurefirePlugin.execute(SurefirePlugin.java:575)
	at org.apache.maven.plugin.DefaultPluginManager.executeMojo(DefaultPluginManager.java:490)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoals(DefaultLifecycleExecutor.java:694)
	... 17 more
Surefire output
-------------------------------
-------------------------------------------------------------------------------
Test set: org.apache.camel.issues.RetryRouteScopedUntilRecipientListParallelIssueTest
-------------------------------------------------------------------------------
Tests run: 7, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 10.217 sec &amp;lt;&amp;lt;&amp;lt; FAILURE!
testRetryUntilRecipientListOkAndFail(org.apache.camel.issues.RetryRouteScopedUntilRecipientListParallelIssueTest)  Time elapsed: 3.729 sec  &amp;lt;&amp;lt;&amp;lt; FAILURE!
junit.framework.AssertionFailedError: expected:&amp;lt;3&amp;gt; but was:&amp;lt;0&amp;gt;
	at junit.framework.Assert.fail(Assert.java:47)
	at junit.framework.Assert.failNotEquals(Assert.java:280)
	at junit.framework.Assert.assertEquals(Assert.java:64)
	at junit.framework.Assert.assertEquals(Assert.java:198)
	at junit.framework.Assert.assertEquals(Assert.java:204)
	at org.apache.camel.issues.RetryRouteScopedUntilRecipientListParallelIssueTest.testRetryUntilRecipientListOkAndFail(RetryRouteScopedUntilRecipientListParallelIssueTest.java:38)
</description>
			<version>2.2.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.issues.RetryRouteScopedUntilRecipientListIssueTest.java</file>
			<file type="M">org.apache.camel.issues.RetryRouteScopedUntilRecipientListParallelIssueTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2377" opendate="2010-01-18 18:19:52" fixdate="2010-01-19 06:33:53" resolution="Fixed">
		<buginformation>
			<summary>org.apache.camel.impl.DefaultProducerTemplateAsyncTest failing on build on trunk</summary>
			<description>Unit test failing on mvn install on latest head from trunk.
mvn -e output
------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running org.apache.camel.impl.DefaultProducerTemplateAsyncTest
Tests run: 22, Failures: 3, Errors: 0, Skipped: 0, Time elapsed: 17.012 sec &amp;lt;&amp;lt;&amp;lt; FAILURE!
Results :
Failed tests: 
  testAsyncCallbackExchangeInOut(org.apache.camel.impl.DefaultProducerTemplateAsyncTest)
  testAsyncCallbackBodyInOut(org.apache.camel.impl.DefaultProducerTemplateAsyncTest)
  testAsyncCallbackBodyInOutGetResult(org.apache.camel.impl.DefaultProducerTemplateAsyncTest)
Tests run: 22, Failures: 3, Errors: 0, Skipped: 0
[INFO] ------------------------------------------------------------------------
[ERROR] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] There are test failures.
Please refer to /data/workspace/camel/camel-core/target/surefire-reports for the individual test results.
[INFO] ------------------------------------------------------------------------
[INFO] Trace
org.apache.maven.BuildFailureException: There are test failures.
Please refer to /data/workspace/camel/camel-core/target/surefire-reports for the individual test results.
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoals(DefaultLifecycleExecutor.java:715)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoalWithLifecycle(DefaultLifecycleExecutor.java:556)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoal(DefaultLifecycleExecutor.java:535)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoalAndHandleFailures(DefaultLifecycleExecutor.java:387)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeTaskSegments(DefaultLifecycleExecutor.java:348)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.execute(DefaultLifecycleExecutor.java:180)
	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:328)
	at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:138)
	at org.apache.maven.cli.MavenCli.main(MavenCli.java:362)
	at org.apache.maven.cli.compat.CompatibleMain.main(CompatibleMain.java:60)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.classworlds.Launcher.launchEnhanced(Launcher.java:315)
	at org.codehaus.classworlds.Launcher.launch(Launcher.java:255)
	at org.codehaus.classworlds.Launcher.mainWithExitCode(Launcher.java:430)
	at org.codehaus.classworlds.Launcher.main(Launcher.java:375)
Caused by: org.apache.maven.plugin.MojoFailureException: There are test failures.
Please refer to /data/workspace/camel/camel-core/target/surefire-reports for the individual test results.
	at org.apache.maven.plugin.surefire.SurefirePlugin.execute(SurefirePlugin.java:575)
	at org.apache.maven.plugin.DefaultPluginManager.executeMojo(DefaultPluginManager.java:490)
	at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoals(DefaultLifecycleExecutor.java:694)
	... 17 more
Surefire Output
-------------------------------------------------------------------------------
Test set: org.apache.camel.impl.DefaultProducerTemplateAsyncTest
-------------------------------------------------------------------------------
Tests run: 22, Failures: 3, Errors: 0, Skipped: 0, Time elapsed: 17.013 sec &amp;lt;&amp;lt;&amp;lt; FAILURE!
testAsyncCallbackExchangeInOut(org.apache.camel.impl.DefaultProducerTemplateAsyncTest)  Time elapsed: 0.431 sec  &amp;lt;&amp;lt;&amp;lt; FAILURE!
junit.framework.ComparisonFailure: expected:&amp;lt;[AB]C&amp;gt; but was:&amp;lt;[BA]C&amp;gt;
	at junit.framework.Assert.assertEquals(Assert.java:81)
	at junit.framework.Assert.assertEquals(Assert.java:87)
	at org.apache.camel.impl.DefaultProducerTemplateAsyncTest.testAsyncCallbackExchangeInOut(DefaultProducerTemplateAsyncTest.java:357)
testAsyncCallbackBodyInOut(org.apache.camel.impl.DefaultProducerTemplateAsyncTest)  Time elapsed: 0.206 sec  &amp;lt;&amp;lt;&amp;lt; FAILURE!
junit.framework.ComparisonFailure: expected:&amp;lt;[AB]C&amp;gt; but was:&amp;lt;[BA]C&amp;gt;
	at junit.framework.Assert.assertEquals(Assert.java:81)
	at junit.framework.Assert.assertEquals(Assert.java:87)
	at org.apache.camel.impl.DefaultProducerTemplateAsyncTest.testAsyncCallbackBodyInOut(DefaultProducerTemplateAsyncTest.java:451)
testAsyncCallbackBodyInOutGetResult(org.apache.camel.impl.DefaultProducerTemplateAsyncTest)  Time elapsed: 0.176 sec  &amp;lt;&amp;lt;&amp;lt; FAILURE!
junit.framework.ComparisonFailure: expected:&amp;lt;[AB]C&amp;gt; but was:&amp;lt;[BA]C&amp;gt;
	at junit.framework.Assert.assertEquals(Assert.java:81)
	at junit.framework.Assert.assertEquals(Assert.java:87)
	at org.apache.camel.impl.DefaultProducerTemplateAsyncTest.testAsyncCallbackBodyInOutGetResult(DefaultProducerTemplateAsyncTest.java:492)
</description>
			<version>2.2.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultProducerTemplateAsyncTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2385" opendate="2010-01-20 20:49:28" fixdate="2010-01-20 21:42:27" resolution="Fixed">
		<buginformation>
			<summary>BindingOperationInfos that are stored in exchange are inconsistent between CxfProducer and CxfConsumer</summary>
			<description>CxfProducer could store a unwrapped version of the BindingOperationInfo in the exchange which is inconsistent with CxfConsumer and it puts burden on the application to revert back to the wrapped version.  CxfProducer should store the original version before calling.

                boi = boi.getUnwrappedOperation();

</description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2387" opendate="2010-01-21 11:04:01" fixdate="2010-01-21 11:44:50" resolution="Fixed">
		<buginformation>
			<summary>GenericFileConverter should honor charset from Exchange</summary>
			<description>GenericFileConverter should pass in Exchange as parameter to converter so it can leverage any CHARSET set on the Exchange such as from a .convertBodyTo(String.class, "UTF-8");</description>
			<version>2.0.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFileConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2395" opendate="2010-01-24 13:38:44" fixdate="2010-01-24 16:23:26" resolution="Fixed">
		<buginformation>
			<summary>file component - Using fileName option should better detect constant vs dynamic name</summary>
			<description>eg using fileName=header.txt makes Camel think its header with the name txt you want to use.
</description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FromFileMulticastToFilesTest.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="2397" opendate="2010-01-25 02:33:20" fixdate="2010-01-25 05:40:51" resolution="Fixed">
		<buginformation>
			<summary>camel-cxf producer should copy the inMessage headers to the outMessage</summary>
			<description>If we try to chain some different endponit together in the camel route, we need to make sure the in message header be copied to the out message. </description>
			<version>1.4.0</version>
			<fixedVersion>1.6.3, 2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfProducerContextTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducer.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2188" opendate="2009-11-17 23:24:31" fixdate="2010-01-26 19:12:12" resolution="Fixed">
		<buginformation>
			<summary>JcrProducer node creation throws javax.jcr.PathNotFoundException when using exchange ID as node name</summary>
			<description>To reproduce, use the camel-jcr component without specifying a node name in the message properties.  JcrProducer will attempt to use the exchange ID as the node name, but in ServiceMix 4, this ID contains path separator characters, which results in a PathNotFound exception when the producer attempts to create the node.  IMHO, the producer should attempt to create parent nodes as needed when the value of either the exchange ID or the property named JcrConstants.JCR_NODE_NAME contain path separators.</description>
			<version>1.6.0</version>
			<fixedVersion>2.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jcr.JcrEndpoint.java</file>
			<file type="M">org.apache.camel.component.jcr.JcrProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2266" opendate="2009-12-08 12:35:43" fixdate="2010-01-29 04:52:20" resolution="Fixed">
		<buginformation>
			<summary>java.lang.ClassNotFoundException: org.apache.camel.converter.jaxb.JaxbConverter not found from bundle [org.apache.camel.camel-core] (Equinox - Karaf)</summary>
			<description>The example camel-example-etl cannot run on Apache Felix Karaf 1.2 - Equinox. the following error is generated

12:48:24,184 | DEBUG | ExtenderThread-6 | OsgiPackageScanClassResolver | sgi.OsgiPackageScanClassResolver 79 | Loading from osgi bundle using classloader: org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader@10bbf6d
12:48:24,246 | DEBUG | ExtenderThread-6 | OsgiPackageScanClassResolver | sgi.OsgiPackageScanClassResolver 59 | Using only osgi bundle classloader
12:48:24,246 | DEBUG | ExtenderThread-6 | OsgiPackageScanClassResolver | sgi.OsgiPackageScanClassResolver 79 | Loading from osgi bundle using classloader: BundleDelegatingClassLoader for [camel-core (org.apache.camel.camel-core)]
12:48:24,309 | DEBUG | ExtenderThread-6 | OsgiPackageScanClassResolver | sgi.OsgiPackageScanClassResolver 59 | Using only osgi bundle classloader
12:48:24,309 | DEBUG | ExtenderThread-6 | OsgiPackageScanClassResolver | sgi.OsgiPackageScanClassResolver 79 | Loading from osgi bundle using classloader: BundleDelegatingClassLoader for [camel-core (org.apache.camel.camel-core)]
12:48:24,371 | DEBUG | ExtenderThread-6 | OsgiPackageScanClassResolver | .DefaultPackageScanClassResolver 418 | Cannot find class &amp;amp;apos;org/apache/camel/converter/jaxb/JaxbDataFormat.class&amp;amp;apos; in classloader: BundleDelegatingClassLoader for [camel-core (org.apache.camel.camel-core)]. Reason: java.lang.ClassNotFoundException: java.lang.ClassNotFoundException: org.apache.camel.converter.jaxb.JaxbConverter not found from bundle [org.apache.camel.camel-core]
	at org.springframework.osgi.util.BundleDelegatingClassLoader.findClass(BundleDelegatingClassLoader.java:103)
	at org.springframework.osgi.util.BundleDelegatingClassLoader.loadClass(BundleDelegatingClassLoader.java:156)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:252)
	at org.apache.camel.impl.DefaultPackageScanClassResolver.addIfMatching(DefaultPackageScanClassResolver.java:405)
	at org.apache.camel.osgi.OsgiPackageScanClassResolver.loadImplementationsInBundle(OsgiPackageScanClassResolver.java:121)
	at org.apache.camel.osgi.OsgiPackageScanClassResolver.findInOsgiClassLoader(OsgiPackageScanClassResolver.java:81)
	at org.apache.camel.osgi.OsgiPackageScanClassResolver.find(OsgiPackageScanClassResolver.java:60)
	at org.apache.camel.impl.DefaultPackageScanClassResolver.findAnnotated(DefaultPackageScanClassResolver.java:100)
	at org.apache.camel.osgi.OsgiAnnotationTypeConverterLoader.load(OsgiAnnotationTypeConverterLoader.java:42)
	at org.apache.camel.impl.converter.DefaultTypeConverter.checkLoaded(DefaultTypeConverter.java:379)
	at org.apache.camel.impl.converter.DefaultTypeConverter.doConvertTo(DefaultTypeConverter.java:160)
	at org.apache.camel.impl.converter.DefaultTypeConverter.mandatoryConvertTo(DefaultTypeConverter.java:120)
	at org.apache.camel.impl.converter.DefaultTypeConverter.mandatoryConvertTo(DefaultTypeConverter.java:113)
...
Caused by: java.lang.ClassNotFoundException: org.apache.camel.converter.jaxb.JaxbConverter
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:494)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:410)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:398)
	at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.loadClass(DefaultClassLoader.java:105)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:252)
	at org.eclipse.osgi.internal.loader.BundleLoader.loadClass(BundleLoader.java:326)
	at org.eclipse.osgi.framework.internal.core.BundleHost.loadClass(BundleHost.java:231)
	at org.eclipse.osgi.framework.internal.core.AbstractBundle.loadClass(AbstractBundle.java:1193)
	at org.springframework.osgi.util.BundleDelegatingClassLoader.findClass(BundleDelegatingClassLoader.java:99)



REMARKs : 

The project works fine with FELIX
Packages to be imported is defined in MANIFEST : org.apache.camel.converter.jaxb;version="[2.2.0,3.0.0)";resolution:=optional,
Resolution when bundle is deployed is ok


[  77] [Resolved   ] [            ] [       ] [   60] camel-example-etl (2.2.0.SNAPSHOT)
[  78] [Resolved   ] [            ] [       ] [   60] JBoss Hibernate Annotations (3.4.0.GA)
                                       Hosts: 72
[  80] [Active     ] [            ] [       ] [   60] JBoss Hibernate Common Annotations (3.3.0.ga)
[  81] [Active     ] [            ] [       ] [   60] Apache ServiceMix Bundles: commons-dbcp-1.2.2 (1.2.2.3)
[  82] [Active     ] [            ] [       ] [   60] camel-jaxb (2.2.0.SNAPSHOT)
karaf@root&amp;gt; packages:

packages:exports    packages:imports
karaf@root&amp;gt; packages:imports  77
OSGi System Bundle (0): javax.xml.bind.annotation; version="0.0.0"
OPS4J Pax Logging - API (27): org.apache.commons.logging; version="1.1.1"
camel-core (43): org.apache.camel.model; version="2.2.0.SNAPSHOT"
camel-core (43): org.apache.camel.util; version="2.2.0.SNAPSHOT"
camel-core (43): org.apache.camel; version="2.2.0.SNAPSHOT"
Spring Transaction (50): org.springframework.transaction.support; version="2.5.6.SEC01"
camel-spring-osgi (51): org.apache.camel.spring; version="2.2.0.SNAPSHOT"
Apache ServiceMix Specs :: JAVA PERSISTENCE API 1.4 (52): javax.persistence; version="1.1.1"
Apache ServiceMix Bundles: openjpa-1.2.1 (62): org.apache.openjpa.enhance; version="1.2.1"
Apache ServiceMix Bundles: openjpa-1.2.1 (62): org.apache.openjpa.util; version="1.2.1"
Spring ORM (63): org.springframework.orm.jpa; version="2.5.6.SEC01"
Spring ORM (63): org.springframework.orm.jpa.vendor; version="2.5.6.SEC01"
camel-jpa (64): org.apache.camel.component.jpa; version="2.2.0.SNAPSHOT"
wrap_mvn_hsqldb_hsqldb_1.8.0.7 (65): org.hsqldb; version="0.0.0"
camel-juel (76): org.apache.camel.language.juel; version="2.2.0.SNAPSHOT"
camel-jaxb (82): org.apache.camel.converter.jaxb; version="2.2.0.SNAPSHOT"

</description>
			<version>2.2.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultPackageScanClassResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="2420" opendate="2010-01-28 16:42:53" fixdate="2010-01-29 09:19:40" resolution="Fixed">
		<buginformation>
			<summary>In camel-cache CacheConfiguration "diskExpiryThreadIntervalSeconds" not set correctly</summary>
			<description>See CacheConfiguration.java
CacheConfiguration.java

 if (cacheSettings.containsKey("diskExpiryThreadIntervalSeconds")) {
	setTimeToLiveSeconds(Long.valueOf((String) cacheSettings.get("diskExpiryThreadIntervalSeconds")).longValue());
} 


 </description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cache.CacheConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="2428" opendate="2010-01-29 11:39:46" fixdate="2010-01-29 11:52:26" resolution="Fixed">
		<buginformation>
			<summary>In camel-cache "diskStorePath" property not efficient</summary>
			<description>If you want to change path to persisent cache with "diskStorePath", it has no effect  because cacheManager erase this value.
In "addCacheNoCheck" method, "setDiskStorePath" call with "diskStorePath" CacheManager property value.
CacheManager.java

    public void addCache(Ehcache cache) throws IllegalStateException,
            ObjectExistsException, CacheException {
        checkStatus();
        if (cache == null) {
            return;
        }
        addCacheNoCheck(cache);
    }

    private void addCacheNoCheck(Ehcache cache) throws IllegalStateException,
            ObjectExistsException, CacheException {
        if (ehcaches.get(cache.getName()) != null) {
            throw new ObjectExistsException("Cache " + cache.getName() + " already exists");
        }
        cache.setCacheManager(this);
        cache.setDiskStorePath(diskStorePath);
        cache.initialise();
        try {
            cache.bootstrap();
        } catch (CacheException e) {
            LOG.log(Level.WARNING, "Cache " + cache.getName() + "requested bootstrap but a CacheException occured. " + e.getMessage(), e);
        }
        ehcaches.put(cache.getName(), cache);
        if (cache instanceof Cache) {
            caches.put(cache.getName(), cache);
        }

        //Don&amp;amp;apos;t notify initial config. The init method of each listener should take care of this.
        if (status.equals(Status.STATUS_ALIVE)) {
            cacheManagerEventListenerRegistry.notifyCacheAdded(cache.getName());
        }
    }


</description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cache.CacheConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="2426" opendate="2010-01-29 02:41:42" fixdate="2010-01-29 21:38:08" resolution="Fixed">
		<buginformation>
			<summary>CXF Header "ResponseContext" cannot be filtered by HeaderFilterStrategy</summary>
			<description></description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="2436" opendate="2010-02-02 09:14:31" fixdate="2010-02-02 11:59:10" resolution="Fixed">
		<buginformation>
			<summary>BeanProcessor - Should differentiate between void and method returning null values</summary>
			<description>When invoking a bean method it should better detect whether the bean is a void or has a return type.
And if it returns null it should be regarded as a valid response and set as body.
See nabble
http://old.nabble.com/filtering-messages-ts27403559.html</description>
			<version>2.0.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.component.bean.BeanProcessor.java</file>
			<file type="M">org.apache.camel.component.bean.MethodInfo.java</file>
			<file type="M">org.apache.camel.component.bean.BeanWithPropertiesAndHeadersAndBodyInjectionTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">3354</link>
		</links>
	</bug>
	<bug id="2439" opendate="2010-02-02 16:59:49" fixdate="2010-02-02 17:26:43" resolution="Fixed">
		<buginformation>
			<summary>File consumer - Consuming from absolute paths can cause issue on Windows when moving file when done</summary>
			<description>When using a file consumer with an absolute path, eg from("file:/data") then when the process is done and it wants to move the file to .camel sub dir of /data it may not do that correctly on Windows.
The issue is the logic in Camel is based upon that a path starting with \ is considered absolute, as it is on Unix OS and other platforms. Where as on Windows java.io.File returns false for such files. The other return true. So we need to cater for this and make Windows return true as well so the logic is consistent across OS.</description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileProducer.java</file>
			<file type="M">org.apache.camel.component.file.FileEndpoint.java</file>
			<file type="M">org.apache.camel.util.FileUtil.java</file>
			<file type="M">org.apache.camel.component.file.GenericFile.java</file>
			<file type="M">org.apache.camel.language.FileLanguageTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2447" opendate="2010-02-04 02:45:52" fixdate="2010-02-04 03:38:16" resolution="Fixed">
		<buginformation>
			<summary>cxfbean should  propagate CONTENT_TYPE for other camel component to use</summary>
			<description>There is no "content-type" header return from the below route

 &amp;lt;route&amp;gt;

      &amp;lt;from uri="jetty:http://localhost:9006/employeesBase?matchOnUriPrefix=true"/&amp;gt;

      &amp;lt;to uri="cxfbean:EmployeesPOJO"/&amp;gt;

  &amp;lt;/route&amp;gt;

</description>
			<version>2.0-M3</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.cxfbean.CxfBeanTest.java</file>
			<file type="M">org.apache.camel.component.cxf.cxfbean.DefaultCxfBeanBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="2444" opendate="2010-02-03 20:27:16" fixdate="2010-02-04 06:13:51" resolution="Fixed">
		<buginformation>
			<summary>Log Component documentation for "showAll" option is misleading</summary>
			<description>Log Component documentation for "showAll" option is misleading or the option does not work as expected.
"showAll 	 false 	 Quick option for turning all options on."
There appear to be several options that are not turned as expected such as "multiline" and "showStackTrace", etc..  
</description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.log.LogFormatter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2445" opendate="2010-02-03 21:57:34" fixdate="2010-02-04 07:09:39" resolution="Fixed">
		<buginformation>
			<summary>BatchProcesser.processExchange needs to catch Throwable</summary>
			<description>If an aggregator sends an exchange to a processor that throws an Error this causes the thread started by BatchProcessor to exit, exchanges will then accumulate in the aggregator until an OutOfMemoryError occurs.
This patch sorts that out and adds a unit test, however there&amp;amp;apos;s another problem that I&amp;amp;apos;m still looking into, namely that BatchProcessor just uses an instance of LoggingErrorHandler as it&amp;amp;apos;s exception handler, so any exceptions/errors caught by this processor will just get logged and not follow the normal Camel error handling.</description>
			<version>1.6.2</version>
			<fixedVersion>1.6.3, 2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.BatchProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="2451" opendate="2010-02-05 08:56:13" fixdate="2010-02-05 09:14:49" resolution="Fixed">
		<buginformation>
			<summary>HL7MLLPDecoder fails if message length is exactly 1022</summary>
			<description>When an HL7 message length is exactly 1022 then the two end control charcters are not read from the same packet/buffer. This causes HL7MLLPDecoder.scan() method to fail.</description>
			<version>2.1.0</version>
			<fixedVersion>2.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.hl7.HL7MLLPDecoder.java</file>
		</fixedFiles>
	</bug>
	<bug id="2360" opendate="2010-01-14 10:14:29" fixdate="2010-02-09 08:24:27" resolution="Fixed">
		<buginformation>
			<summary>recipientList retryUntil not working</summary>
			<description>summary:
the bean gets intialized but it looks like the method retryUntil is never called, could it be an error of implementation? am I doing something wrong?
using following route:

from("jms-test:queue:queue.delivery.notification.test") 
.process(processor) 
.onException(Exception.class).retryUntil(bean("myRetryBean")).end() 
.recipientList(header("recipientListHeader").tokenize(",")) 
.parallelProcessing().executorService(customThreadPoolExecutor) 
.aggregationStrategy(new RecipientAggregationStrategy()) 
.to("direct:chunk.completed"); 


bean is registered in such way: 

JndiRegistry jndi = new JndiRegistry(new JndiContext()); 
jndi.bind("myRetryBean", new RetryBean()); 


bean class is: 

public class RetryBean { 

        private int _invoked; 
        private Logger _logger; 
        
    public RetryBean() { 
    this._logger = Logger.getLogger(RetryBean.class); 
    this._invoked = 0; 
    _logger.debug("BEAN INITIALIZED " + _invoked); 
    } 
        
    // using bean binding we can bind the information from the exchange to the types we have in our method signature 
    public boolean retryUntil(@Header(Exchange.REDELIVERY_COUNTER) Integer counter, @Body String body, @ExchangeException Exception causedBy) { 
        // NOTE: counter is the redelivery attempt, will start from 1 
    _invoked++; 
    
    
    _logger.debug("invoked" + _invoked); 
    _logger.debug("counter" + counter); 
    _logger.debug("result" + (counter &amp;lt; 2)); 
    
        // we can of course do what ever we want to determine the result but this is a unit test so we end after 3 attempts 
        return counter &amp;lt; 7; 
    } 

</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.issues.RetryRouteScopedUntilRecipientListIssueTest.java</file>
			<file type="M">org.apache.camel.processor.Splitter.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
			<file type="M">org.apache.camel.processor.DefaultChannel.java</file>
			<file type="M">org.apache.camel.impl.DefaultUnitOfWork.java</file>
			<file type="M">org.apache.camel.processor.ShutdownDeferTest.java</file>
			<file type="M">org.apache.camel.spi.UnitOfWork.java</file>
		</fixedFiles>
	</bug>
	<bug id="2458" opendate="2010-02-10 17:39:09" fixdate="2010-02-11 05:39:20" resolution="Fixed">
		<buginformation>
			<summary>HttpHeaderFilterStrategy should filter the HTTP &amp;apos;Date&amp;apos; header when applyFilterToCamelHeaders is called</summary>
			<description>See rfc2616.</description>
			<version>2.1.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.HttpHeaderFilterStrategy.java</file>
			<file type="M">org.apache.camel.component.http.HttpHeaderFilterStrategyTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2456" opendate="2010-02-10 02:13:00" fixdate="2010-02-12 07:09:03" resolution="Fixed">
		<buginformation>
			<summary>WARNING log of JmsTemporaryTopicEndpoint , JmsTemporaryQueueEndpoint don&amp;apos;t have the ManagedResource annotation</summary>
			<description>Here is the mail thread which discusses about this issue.
http://old.nabble.com/Attemp-to-send-message-to-activemq-temporary-queue-using-producerTemplate%3A-InvalidMetadataException-tp27520096p27520096.html</description>
			<version>2.1.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsTemporaryTopicEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.JmsTemporaryQueueEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="2214" opendate="2009-11-23 19:43:29" fixdate="2010-02-16 20:39:35" resolution="Fixed">
		<buginformation>
			<summary>NPE thrown from RssDateComparator when using a feed that doesn&amp;apos;t parse properly.</summary>
			<description>If a feed contains entries that don&amp;amp;apos;t have an updatedDate or publishDate and you&amp;amp;apos;re using splitEntries=true + sortEntries=true you can run into this NPE:

2009-11-23 14:31:50,152 [0: RssComponent] WARN  ultPollingConsumerPollStrategy -
 Consumer Consumer[rss://http://www.iafrica.com/pls/cms/grapevine.xml?consumer.initialDelay=9000&amp;amp;p_city=cape+town&amp;amp;p_section=weather&amp;amp;sortEntries=true&amp;amp;splitEntries=true] 
could not poll endpoint: rss://http://www.iafrica.com/pls/cms/grapevine.xml?consumer.initialDelay=9000&amp;amp;p_city=cape+town&amp;amp;p_section=weather&amp;amp;sortEntries=true&amp;amp;splitEntries=true 
caused by: null
java.lang.NullPointerException
	at org.apache.camel.component.rss.RssDateComparator.compare(RssDateComparator.java:27)
	at org.apache.camel.component.rss.RssDateComparator.compare(RssDateComparator.java:24)
	at java.util.Arrays.mergeSort(Arrays.java:1270)
	at java.util.Arrays.mergeSort(Arrays.java:1281)
	at java.util.Arrays.sort(Arrays.java:1210)
	at java.util.Collections.sort(Collections.java:159)
	at org.apache.camel.component.rss.RssEntryPollingConsumer.sortEntries(RssEntryPollingConsumer.java:49)
	at org.apache.camel.component.rss.RssEntryPollingConsumer.populateList(RssEntryPollingConsumer.java:42)
	at org.apache.camel.component.feed.FeedEntryPollingConsumer.poll(FeedEntryPollingConsumer.java:43)
	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:108)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)
	at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:317)
	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:150)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:98)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:181)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:205)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:637)

</description>
			<version>2.0.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rss.RssDateComparator.java</file>
		</fixedFiles>
	</bug>
	<bug id="2476" opendate="2010-02-17 09:01:27" fixdate="2010-02-17 15:55:59" resolution="Fixed">
		<buginformation>
			<summary>Camel Velocity: change the case of all fields properties Header</summary>
			<description>Using the velocity component doesn&amp;amp;apos;t respect the case matching of all fields of the header.
For example: the exchange of properties CorrelationID change the case matching, after using velocity component, it puts the property in lowercase correlationid.</description>
			<version>2.1.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.velocity.VelocityEndpoint.java</file>
			<file type="M">org.apache.camel.component.velocity.VelocityTemplateInHeaderTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2478" opendate="2010-02-17 09:09:42" fixdate="2010-02-17 16:02:56" resolution="Fixed">
		<buginformation>
			<summary>Camel Stringtemplate : lose all fields properties</summary>
			<description>the component Camel-stringtemplate loses all fields properties after the generation of Result.</description>
			<version>2.1.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.stringtemplate.StringTemplateEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="2477" opendate="2010-02-17 09:04:20" fixdate="2010-02-17 16:06:33" resolution="Fixed">
		<buginformation>
			<summary>Camel Freemarker: change the case of all fields properties Header</summary>
			<description>Using the Freemarker component doesn&amp;amp;apos;t respect the case matching of all fields of the header.
For example: the exchange of properties CorrelationID change the case matching, after using Freemarker component, it puts the property in lowercase correlationid.</description>
			<version>2.1.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.freemarker.FreemarkerEndpoint.java</file>
			<file type="M">org.apache.camel.component.freemarker.FreemarkerTemplateInHeaderTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2486" opendate="2010-02-18 20:37:04" fixdate="2010-02-19 10:45:49" resolution="Fixed">
		<buginformation>
			<summary>DefaultCamelContext throws NPE in start() for route with no destination</summary>
			<description>Not easy to track down when you have a lot of routes.  This might be new with the introduction of StartupRouteHolder (I think that was introduced in 2.1, right?)

public class TriggerNPETest extends CamelTestSupport {
	@Override
	protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            public void configure() {
            	// This will generate an NPE on DefaultCamelContext.start() (line 973)
            	// If this is an invalid route a proper message should be given far before 
            	// this and/or NPE should be tested on line 973
            	from("direct:psd.nowhere");
            }
        };
	}
	@Test
	public void testme() throws Exception {
		Thread.sleep(10000);
	}
}


java.lang.NullPointerException
	at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:973)
	at org.apache.camel.test.junit4.CamelTestSupport.startCamelContext(CamelTestSupport.java:145)
	at org.apache.camel.test.junit4.CamelTestSupport.setUp(CamelTestSupport.java:98)

            // now start the inputs for all the route services as we have prepared Camel
            // yeah open the floods so messages can start flow into Camel
            for (Map.Entry&amp;lt;Integer, StartupRouteHolder&amp;gt; entry : inputs.entrySet()) {
                Integer order = entry.getKey();
                Route route = entry.getValue().getRoute();  //  &amp;lt;&amp;lt;&amp;lt;-------  Right here.

</description>
			<version>2.1.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.RouteDefinition.java</file>
			<file type="M">org.apache.camel.language.bean.BeanExpression.java</file>
		</fixedFiles>
	</bug>
	<bug id="2484" opendate="2010-02-18 09:21:41" fixdate="2010-02-23 10:17:22" resolution="Fixed">
		<buginformation>
			<summary>camel-mina - Using close session could potentially cause memory to be not released</summary>
			<description>See nabble
http://old.nabble.com/SocketSessionImpl-in-Mina-component-retained-in-memory-indefinitely-ts27624487.html</description>
			<version>2.1.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultProducerCacheTest.java</file>
			<file type="M">org.apache.camel.util.LRUCache.java</file>
			<file type="M">org.apache.camel.processor.RecipientList.java</file>
			<file type="M">org.apache.camel.management.JmxInstrumentationUsingDefaultsTest.java</file>
			<file type="M">org.apache.camel.impl.ProducerCache.java</file>
			<file type="M">org.apache.camel.management.ManagedUnregisterProducerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2495" opendate="2010-02-23 18:54:04" fixdate="2010-03-01 14:31:17" resolution="Fixed">
		<buginformation>
			<summary>Application SOAP fault support in camel-cxf PAYLOAD mode</summary>
			<description>Camel-cxf component does not seem to support application SOAP fault in PAYLOAD mode.</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfConsumer.java</file>
			<file type="M">org.apache.camel.component.cxf.feature.PayLoadDataFormatFeature.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfHeaderFilterStrategy.java</file>
			<file type="M">org.apache.camel.component.cxf.CXFWsdlOnlyPayloadModeNoSpringTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CXFWsdlOnlyTest.java</file>
			<file type="M">org.apache.camel.component.cxf.interceptors.PayloadContentRedirectInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="2529" opendate="2010-03-08 10:18:12" fixdate="2010-03-08 13:35:25" resolution="Fixed">
		<buginformation>
			<summary>ConsumerTemplate don&amp;apos;t support the jms uri with selector</summary>
			<description>This unit test can shows the issue that selector option don&amp;amp;apos;t work for ConsumerTemplate

@Test
    public void testConsumerTemplate() throws Exception {
        template.sendBodyAndHeader("activemq:queue:consumer", "Message1", "SIZE_NUMBER", 1505);
        template.sendBodyAndHeader("activemq:queue:consumer", "Message3", "SIZE_NUMBER", 1300);
        template.sendBodyAndHeader("activemq:queue:consumer", "Message2", "SIZE_NUMBER", 1600);

        // process every exchange which is ready. If no exchange is left break
        // the loop
        while (true) {
            Exchange ex = consumer.receiveNoWait("activemq:queue:consumer?selector=SIZE_NUMBER&amp;lt;1500");
            if (ex != null) {
                Message message = ex.getIn();
                int size = message.getHeader("SIZE_NUMBER", int.class);
                assertTrue("The message header SIZE_NUMBER should be less than 1500", size &amp;lt; 1500);
                assertEquals("The message body is wrong", "Message3", message.getBody());
            } else {
                break;
            }
        }

    }



And here is mail thread which discusses about it.</description>
			<version>2.0.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsSelectorOptionTest.java</file>
			<file type="M">org.apache.camel.component.jms.JmsPollingConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2510" opendate="2010-03-01 13:45:23" fixdate="2010-03-10 10:01:21" resolution="Fixed">
		<buginformation>
			<summary>Mixing jetty/http in a route screws up the URI used by HttpClient</summary>
			<description>Below test shows the Http producer can&amp;amp;apos;t build up right HttpRequest URI as a bridgeEndpoint.

   public class JettyHttpTest extends CamelTestSupport {

    private String targetProducerUri = "http://localhost:8542/someservice?bridgeEndpoint=true&amp;amp;throwExceptionOnFailure=false";
    private String targetConsumerUri = "jetty:http://localhost:8542/someservice?matchOnUriPrefix=true";
    private String sourceUri = "jetty:http://localhost:6323/myservice?matchOnUriPrefix=true";
    private String sourceProducerUri = "http://localhost:6323/myservice";

    @Test
    public void testGetRootPath() throws Exception {
        MockEndpoint mock = getMockEndpoint("mock:result");
        mock.expectedBodiesReceived("Hi! /someservice");

        template.sendBody("direct:root", "");

        assertMockEndpointsSatisfied();
    }
    
    @Test
    public void testGetWithRelativePath() throws Exception {
        MockEndpoint mock = getMockEndpoint("mock:result");
        mock.expectedBodiesReceived("Hi! /someservice/relative");
        
        template.sendBody("direct:relative", "");
        assertMockEndpointsSatisfied();
        
    }

    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {

                from(targetConsumerUri)
                    .process(new Processor() {
                        public void process(Exchange exchange) throws Exception {
                            String path = exchange.getIn().getHeader(Exchange.HTTP_PATH, String.class);
                            exchange.getOut().setBody("Hi! " + path);
                        }   
                    });

                from(sourceUri)
                    .to(targetProducerUri);

                from("direct:root")
                    .to(sourceProducerUri)
                    .to("mock:result");
                
                from("direct:relative")
                    .to(sourceProducerUri + "/relative")
                    .to("mock:result");

            }
        };
    }
}

</description>
			<version>2.1.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.helper.HttpProducerHelper.java</file>
			<file type="M">org.apache.camel.component.jetty.HttpBridgeRouteTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2551" opendate="2010-03-15 11:17:10" fixdate="2010-03-16 12:06:25" resolution="Fixed">
		<buginformation>
			<summary>File component does not correctly handle PipedInputStream in message body.</summary>
			<description>Streams that do not have their contents length at immediate disposal, like PipedInputStream, are not processed correctly by the file component.


    private void writeFileByStream(InputStream in, File target) throws IOException {
        FileChannel out = null;
        try {
            out = prepareOutputFileChannel(target, out);

            if (LOG.isTraceEnabled()) {
                LOG.trace("Using InputStream to transfer from: " + in + " to: " + out);
            }
            int size = endpoint.getBufferSize();
            byte[] buffer = new byte[size];
            ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);
            while (true) {
                int count = in.read(buffer);
                if (count &amp;lt;= 0) {
                    break;
                } else if (count &amp;lt; size) {
                    byteBuffer = ByteBuffer.wrap(buffer, 0, count);
                    out.write(byteBuffer);
                    break;
                } else {
                    out.write(byteBuffer);
                    byteBuffer.clear();
                }
            }
        } finally {
            ObjectHelper.close(in, target.getName(), LOG);
            ObjectHelper.close(out, target.getName(), LOG);
        }
    }



The code 

                } else if (count &amp;lt; size) {
                    byteBuffer = ByteBuffer.wrap(buffer, 0, count);
                    out.write(byteBuffer);
                    break;
                } else {


does not take into account that bytes read can be less than the size of the buffer passed into the InputStream.read method and stream can still have more content. The only indication that EOF was reached is -1 returned from the read method according to Java API.</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="1913" opendate="2009-08-15 10:22:51" fixdate="2010-03-18 13:49:46" resolution="Fixed">
		<buginformation>
			<summary>camel-jetty - Should support multipart/form posted data in the message body better</summary>
			<description>See CAMEL-1801
It does not work as expected as the posted data should be in the body and not as it does currently stored as a message header with the body as a key and with an empty value!
For instance sending a file using curl

curl -F data=@src/test/data/plain.txt http://localhost:9080/myapp/myservice


You want Camel to provide the file content in the body and the other as headers. But what you get in the body is

------------------------------30cc29f24df6
Content-Disposition: form-data; name="data"; filename="plain.txt"
Content-Type: text/plain

Hello World
This is the second line
------------------------------30cc29f24df6--


</description>
			<version>2.0-M3</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.MultiPartFormTest.java</file>
			<file type="M">org.apache.camel.component.http.DefaultHttpBinding.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="2554" opendate="2010-03-16 15:58:51" fixdate="2010-03-19 03:11:01" resolution="Fixed">
		<buginformation>
			<summary>IndexOutOfBoundsException occur in UnsafeUriCharactersEncoder.class</summary>
			<description>Here is the mail thread for the detail discussion.</description>
			<version>1.3.0</version>
			<fixedVersion>1.6.3, 2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.web.util.UriCharactersEncoder.java</file>
			<file type="M">org.apache.camel.web.util.UriCharachersEncoderTest.java</file>
			<file type="M">org.apache.camel.util.UnsafeCharactersEncoderTest.java</file>
			<file type="M">org.apache.camel.util.UnsafeUriCharactersEncoder.java</file>
		</fixedFiles>
	</bug>
	<bug id="2545" opendate="2010-03-12 22:51:43" fixdate="2010-03-19 06:54:21" resolution="Fixed">
		<buginformation>
			<summary>Camel-Mail: Alternative body part does not handle charset</summary>
			<description>Mail component does not set charset for alternative body part. See - http://old.nabble.com/Camel-Mail:-Alternative-part-does-not-handle-charset--td27882178.html for more information.</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="2559" opendate="2010-03-18 15:04:22" fixdate="2010-03-21 12:29:22" resolution="Fixed">
		<buginformation>
			<summary>HttpComponent only checks the registry for an HttpClientConfigurer, setHttpClientConfigurer no longer works.</summary>
			<description>Basically you can&amp;amp;apos;t currently do this:

            public void configure() {

                ProxyHttpClientConfigurer configurer = new ProxyHttpClientConfigurer(
                        "proxyhost",
                        80,
                        "user",
                        "password",
                        null,
                        null);

                getContext().getComponent("http", HttpComponent.class).setHttpClientConfigurer(configurer);

                from("direct:start")
                    .to("http://www.google.com/search");
            }


HttpComponent only looks in the registry for an HttpClientConfigurer.</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.SpringHttpsRouteTest.java</file>
			<file type="M">org.apache.camel.component.http.HttpComponent.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.http.HttpClientConfigurerTest.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducerSelectMethodTest.java</file>
			<file type="M">org.apache.camel.component.servlet.ServletComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="2540" opendate="2010-03-11 15:33:58" fixdate="2010-03-22 09:28:05" resolution="Fixed">
		<buginformation>
			<summary>async route not working with Mina</summary>
			<description>here is my route:
		from("mina:tcp://localhost:6202?textline=true&amp;amp;sync=true").process(new Processor() {
		    public void process(Exchange exchange) throws Exception 
{
		        String body = exchange.getIn().getBody(String.class);
				Thread.sleep(5000);
		        exchange.getOut().setBody("Bye 1" + body);
		    }
		});
		from("file:///test/test/response")
		.convertBodyTo(String.class)//.threads(1)
		.toAsync("mina:tcp://localhost:6202?sync=true&amp;amp;textline=true",10)
		.to("log:+++ reply++++"); 
here is the output, you can see all reply logs have a same message body and async process is releasing all threads at the first response, this is probably Mina component bug in the context of aync route.
2010-03-11 10:21:16,405 [Camel thread 11: FileComponent] FileConsumer                   DEBUG Total 3 files to consume
2010-03-11 10:21:16,405 [Camel thread 11: FileComponent] FileConsumer                   DEBUG About to process file: GenericFile[C:\test\test\response\Copy (2) of New Text Document (3).txt] using exchange: Exchange[GenericFileMessage with file: GenericFile[C:\test\test\response\Copy (2) of New Text Document (3).txt]]
2010-03-11 10:21:16,452 [Camel thread 11: FileComponent] DefaultManagementAgent         DEBUG Registered MBean with objectname: org.apache.camel:context=tamlft0spj1/cameltest,type=producers,name=MinaProducer(0x2e6c66)
2010-03-11 10:21:16,452 [Camel thread 11: FileComponent] MinaProducer                   DEBUG Starting producer: Producer[mina://tcp://localhost:6202?sync=true&amp;amp;textline=true]
2010-03-11 10:21:16,452 [Camel thread 11: FileComponent] ProducerCache                  DEBUG Adding to producer service pool with key: Endpoint[mina://tcp://localhost:6202?sync=true&amp;amp;textline=true] for producer: Producer[mina://tcp://localhost:6202?sync=true&amp;amp;textline=true]
2010-03-11 10:21:16,452 [2: SendAsyncProcessor-Producer] MinaProducer                   DEBUG Creating connector to address: localhost/127.0.0.1:6202 using connector: org.apache.mina.transport.socket.nio.SocketConnector@16cefa8 timeout: 30000 millis.
2010-03-11 10:21:16,452 [Camel thread 11: FileComponent] FileConsumer                   DEBUG About to process file: GenericFile[C:\test\test\response\Copy of New Text Document (3).txt] using exchange: Exchange[GenericFileMessage with file: GenericFile[C:\test\test\response\Copy of New Text Document (3).txt]]
2010-03-11 10:21:16,467 [3: SendAsyncProcessor-Producer] MinaProducer                   DEBUG Creating connector to address: localhost/127.0.0.1:6202 using connector: org.apache.mina.transport.socket.nio.SocketConnector@16cefa8 timeout: 30000 millis.
2010-03-11 10:21:16,467 [Camel thread 11: FileComponent] FileConsumer                   DEBUG About to process file: GenericFile[C:\test\test\response\New Text Document (3).txt] using exchange: Exchange[GenericFileMessage with file: GenericFile[C:\test\test\response\New Text Document (3).txt]]
2010-03-11 10:21:16,467 [4: SendAsyncProcessor-Producer] MinaProducer                   DEBUG Creating connector to address: localhost/127.0.0.1:6202 using connector: org.apache.mina.transport.socket.nio.SocketConnector@16cefa8 timeout: 30000 millis.
2010-03-11 10:21:16,499 [SocketConnectorIoProcessor-0.1] ExecutorFilter                 DEBUG Launching thread for localhost/127.0.0.1:6202
2010-03-11 10:21:16,499 [ SocketAcceptorIoProcessor-0.0] ExecutorFilter                 DEBUG Launching thread for /127.0.0.1:3362
2010-03-11 10:21:16,499 [ SocketAcceptorIoProcessor-0.1] ExecutorFilter                 DEBUG Launching thread for /127.0.0.1:3363
2010-03-11 10:21:16,499 [SocketConnectorIoProcessor-0.0] ExecutorFilter                 DEBUG Launching thread for localhost/127.0.0.1:6202
2010-03-11 10:21:16,499 [ SocketAcceptorIoProcessor-0.2] ExecutorFilter                 DEBUG Launching thread for /127.0.0.1:3374
2010-03-11 10:21:16,499 [SocketConnectorIoProcessor-0.2] ExecutorFilter                 DEBUG Launching thread for localhost/127.0.0.1:6202
2010-03-11 10:21:16,514 [amel thread 22: MinaThreadPool] ExecutorFilter                 DEBUG Exiting since queue is empty for /127.0.0.1:3363
2010-03-11 10:21:16,514 [amel thread 24: MinaThreadPool] ExecutorFilter                 DEBUG Exiting since queue is empty for /127.0.0.1:3362
2010-03-11 10:21:16,514 [amel thread 23: MinaThreadPool] ExecutorFilter                 DEBUG Exiting since queue is empty for localhost/127.0.0.1:6202
2010-03-11 10:21:16,514 [2: SendAsyncProcessor-Producer] MinaProducer                   DEBUG Writing body : hello2
2010-03-11 10:21:16,514 [3: SendAsyncProcessor-Producer] MinaProducer                   DEBUG Writing body : hello3
2010-03-11 10:21:16,514 [amel thread 26: MinaThreadPool] ExecutorFilter                 DEBUG Exiting since queue is empty for /127.0.0.1:3374
2010-03-11 10:21:16,514 [amel thread 25: MinaThreadPool] ExecutorFilter                 DEBUG Exiting since queue is empty for localhost/127.0.0.1:6202
2010-03-11 10:21:16,514 [amel thread 27: MinaThreadPool] ExecutorFilter                 DEBUG Exiting since queue is empty for localhost/127.0.0.1:6202
2010-03-11 10:21:16,514 [4: SendAsyncProcessor-Producer] MinaProducer                   DEBUG Writing body : hello1
2010-03-11 10:21:16,514 [SocketConnectorIoProcessor-0.2] ExecutorFilter                 DEBUG Launching thread for localhost/127.0.0.1:6202
2010-03-11 10:21:16,514 [3: SendAsyncProcessor-Producer] MinaProducer                   DEBUG Waiting for response
2010-03-11 10:21:16,530 [2: SendAsyncProcessor-Producer] MinaProducer                   DEBUG Waiting for response
2010-03-11 10:21:16,530 [4: SendAsyncProcessor-Producer] MinaProducer                   DEBUG Waiting for response
2010-03-11 10:21:16,530 [ SocketAcceptorIoProcessor-0.2] ExecutorFilter                 DEBUG Launching thread for /127.0.0.1:3374
2010-03-11 10:21:16,530 [amel thread 27: MinaThreadPool] ExecutorFilter                 DEBUG Exiting since queue is empty for localhost/127.0.0.1:6202
2010-03-11 10:21:16,530 [amel thread 26: MinaThreadPool] MinaConsumer                   DEBUG Received body: hello2
2010-03-11 10:21:21,530 [amel thread 26: MinaThreadPool] MinaConsumer                   DEBUG Writing body: Bye 1hello2
2010-03-11 10:21:21,530 [SocketConnectorIoProcessor-0.2] ExecutorFilter                 DEBUG Launching thread for localhost/127.0.0.1:6202
2010-03-11 10:21:21,530 [amel thread 27: MinaThreadPool] MinaProducer                   DEBUG Message received: Bye 1hello2
2010-03-11 10:21:21,530 [amel thread 27: MinaThreadPool] ExecutorFilter                 DEBUG Exiting since queue is empty for localhost/127.0.0.1:6202
2010-03-11 10:21:21,530 [amel thread 26: MinaThreadPool] MinaConsumer                   DEBUG Received body: hello3
2010-03-11 10:21:21,530 [:6202?sync=true&amp;amp;textline=true]] SendProcessor                  DEBUG Async reply received now routing the Exchange: Exchange[Message: Bye 1hello2]
2010-03-11 10:21:21,530 [:6202?sync=true&amp;amp;textline=true]] SendProcessor                  DEBUG Async reply received now routing the Exchange: Exchange[Message: Bye 1hello2]
2010-03-11 10:21:21,530 [:6202?sync=true&amp;amp;textline=true]] SendProcessor                  DEBUG Async reply received now routing the Exchange: Exchange[Message: Bye 1hello2]
2010-03-11 10:21:21,546 [:6202?sync=true&amp;amp;textline=true]] DefaultManagementAgent         DEBUG Registered MBean with objectname: org.apache.camel:context=tamlft0spj1/cameltest,type=producers,name=Producer(0x16321e6)
2010-03-11 10:21:21,546 [:6202?sync=true&amp;amp;textline=true]] ProcessorEndpoint$1            DEBUG Starting producer: Producer[log://+++ reply++++]
2010-03-11 10:21:21,546 [:6202?sync=true&amp;amp;textline=true]] ProducerCache                  DEBUG Adding to producer cache with key: Endpoint[log://+++ reply++++] for producer: Producer[log://+++ reply++++]
2010-03-11 10:21:21,546 [:6202?sync=true&amp;amp;textline=true]] +++ reply++++                  INFO  Exchange[BodyType:String, Body:Bye 1hello2]
2010-03-11 10:21:21,546 [:6202?sync=true&amp;amp;textline=true]] GenericFileOnCompletion        DEBUG Done processing file: GenericFile[C:\test\test\response\Copy (2) of New Text Document (3).txt] using exchange: Exchange[Message: Bye 1hello2]
2010-03-11 10:21:21,546 [:6202?sync=true&amp;amp;textline=true]] +++ reply++++                  INFO  Exchange[BodyType:String, Body:Bye 1hello2]
2010-03-11 10:21:21,546 [:6202?sync=true&amp;amp;textline=true]] GenericFileOnCompletion        DEBUG Done processing file: GenericFile[C:\test\test\response\Copy of New Text Document (3).txt] using exchange: Exchange[Message: Bye 1hello2]
2010-03-11 10:21:21,546 [:6202?sync=true&amp;amp;textline=true]] FileUtil                       DEBUG Tried 1 to delete file: C:\test\test\response\Copy (2) of New Text Document (3).txt.camelLock with result: true
2010-03-11 10:21:21,561 [:6202?sync=true&amp;amp;textline=true]] +++ reply++++                  INFO  Exchange[BodyType:String, Body:Bye 1hello2]
2010-03-11 10:21:21,561 [:6202?sync=true&amp;amp;textline=true]] GenericFileOnCompletion        DEBUG Done processing file: GenericFile[C:\test\test\response\New Text Document (3).txt] using exchange: Exchange[Message: Bye 1hello2]
2010-03-11 10:21:21,561 [:6202?sync=true&amp;amp;textline=true]] FileUtil                       DEBUG Tried 1 to delete file: C:\test\test\response\Copy of New Text Document (3).txt.camelLock with result: true
2010-03-11 10:21:21,561 [:6202?sync=true&amp;amp;textline=true]] nericFileRenameProcessStrategy DEBUG Renaming file: GenericFile[C:\test\test\response\Copy (2) of New Text Document (3).txt] to: GenericFile[C:\test\test\response\.camel\Copy (2) of New Text Document (3).txt]
2010-03-11 10:21:21,561 [:6202?sync=true&amp;amp;textline=true]] FileUtil                       DEBUG Tried 1 to delete file: C:\test\test\response\New Text Document (3).txt.camelLock with result: true
2010-03-11 10:21:21,561 [:6202?sync=true&amp;amp;textline=true]] nericFileRenameProcessStrategy DEBUG Renaming file: GenericFile[C:\test\test\response\Copy of New Text Document (3).txt] to: GenericFile[C:\test\test\response\.camel\Copy of New Text Document (3).txt]
2010-03-11 10:21:21,561 [:6202?sync=true&amp;amp;textline=true]] nericFileRenameProcessStrategy DEBUG Renaming file: GenericFile[C:\test\test\response\New Text Document (3).txt] to: GenericFile[C:\test\test\response\.camel\New Text Document (3).txt]
2010-03-11 10:21:21,561 [:6202?sync=true&amp;amp;textline=true]] FileUtil                       DEBUG Tried 1 to rename file: C:\test\test\response\Copy (2) of New Text Document (3).txt to: C:\test\test\response\.camel\Copy (2) of New Text Document (3).txt with result: true
2010-03-11 10:21:21,561 [:6202?sync=true&amp;amp;textline=true]] FileUtil                       DEBUG Tried 1 to rename file: C:\test\test\response\Copy of New Text Document (3).txt to: C:\test\test\response\.camel\Copy of New Text Document (3).txt with result: true
2010-03-11 10:21:21,577 [:6202?sync=true&amp;amp;textline=true]] FileUtil                       DEBUG Tried 1 to rename file: C:\test\test\response\New Text Document (3).txt to: C:\test\test\response\.camel\New Text Document (3).txt with result: true
2010-03-11 10:21:26,530 [amel thread 26: MinaThreadPool] MinaConsumer                   DEBUG Writing body: Bye 1hello3
2010-03-11 10:21:26,530 [amel thread 26: MinaThreadPool] MinaConsumer                   DEBUG Received body: hello1
2010-03-11 10:21:26,530 [SocketConnectorIoProcessor-0.2] ExecutorFilter                 DEBUG Launching thread for localhost/127.0.0.1:6202
2010-03-11 10:21:26,530 [amel thread 27: MinaThreadPool] MinaProducer                   DEBUG Message received: Bye 1hello3
2010-03-11 10:21:26,530 [amel thread 27: MinaThreadPool] ExecutorFilter                 DEBUG Exiting since queue is empty for localhost/127.0.0.1:6202
2010-03-11 10:21:31,531 [amel thread 26: MinaThreadPool] MinaConsumer                   DEBUG Writing body: Bye 1hello1
2010-03-11 10:21:31,531 [SocketConnectorIoProcessor-0.2] ExecutorFilter                 DEBUG Launching thread for localhost/127.0.0.1:6202
2010-03-11 10:21:31,531 [amel thread 26: MinaThreadPool] ExecutorFilter                 DEBUG Exiting since queue is empty for /127.0.0.1:3374
2010-03-11 10:21:31,531 [amel thread 27: MinaThreadPool] MinaProducer                   DEBUG Message received: Bye 1hello1
2010-03-11 10:21:31,531 [amel thread 27: MinaThreadPool] ExecutorFilter                 DEBUG Exiting since queue is empty for localhost/127.0.0.1:6202</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.SendAsyncProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="2566" opendate="2010-03-22 08:58:41" fixdate="2010-03-22 12:22:05" resolution="Fixed">
		<buginformation>
			<summary>camel-http component should set Transfer-Encoding as chunked header for response message when checkChunked is true</summary>
			<description>so that the client side which send request will know this is a chunked message.
It&amp;amp;apos;s important when the response http headers is more than 4096 and we want to use chunked response message</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.component.http.DefaultHttpBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="2575" opendate="2010-03-26 03:00:20" fixdate="2010-03-29 03:00:09" resolution="Fixed">
		<buginformation>
			<summary>CXFRS Routing in 2.2.0 does not behave like in 2.0.0</summary>
			<description>CXFRS Routing in Camel 2.0.0 works  well with these endPoints:
&amp;lt;cxf:rsServer id="restRouter" address="/restRouter/"	
      serviceClass="com.project.service.impl.ServiceManagerImpl"   /&amp;gt;
     &amp;lt;cxf:rsClient id="restEndpoint" address="http://localhost:8080/services/rest"
      serviceClass="com.project.service.impl.ServiceManagerImpl" /&amp;gt;
In Camel 2.2.0, Routing fails with error causing the CXF Client to invoke a 404 not found Rest Service which is &amp;amp;apos;http://localhost:8080/services/rest/restRouter/Path&amp;amp;apos;.
The address of cxf:rsClient is being appended by the cxf:rsServer&amp;amp;apos;s address</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.DefaultCxfRsBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsRouterTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2621" opendate="2010-04-07 08:45:06" fixdate="2010-04-07 08:47:21" resolution="Fixed">
		<buginformation>
			<summary>File consumer - Polling from network share on Windows may regard files as not a file</summary>
			<description>
file.isFile()


May return false on Windows if consuming from a network share etc. So we should just regard anything that is not a directory as a file.</description>
			<version>2.0.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2622" opendate="2010-04-07 09:45:06" fixdate="2010-04-07 10:40:57" resolution="Fixed">
		<buginformation>
			<summary>Invocation of hasNext() on org.apache.camel.util.ObjectHelper.createIterator(...).new Iterator&lt;Node&gt;() {...} return different results</summary>
			<description>
                    public boolean hasNext() {
                        // empty string should not be regarded as having next
                        return ++idx == 0 &amp;amp;&amp;amp; ObjectHelper.isNotEmpty(s);
                    }

                    public String next() {
                        return s;
                    }


This is incorrect. Should be:

                    public boolean hasNext() {
                        // empty string should not be regarded as having next
                        return idx+1 == 0 &amp;amp;&amp;amp; ObjectHelper.isNotEmpty(s);
                    }

                    public String next() {
						idx++;
                        return s;
                    }

</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.impl.CustomProducerServicePoolTest.java</file>
			<file type="M">org.apache.camel.converter.ObjectHelperTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2629" opendate="2010-04-11 07:09:04" fixdate="2010-04-11 07:10:40" resolution="Fixed">
		<buginformation>
			<summary>Aggregator - Completion by batch consumer should trigger completion for the batch group if multiple correlation keys was used</summary>
			<description>Yeah its really an odd use case if you use multiple correlation keys for the same batch consumer, but its still possible to do.</description>
			<version>2.3.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileConcurrentAggregateBatchConsumerTest.java</file>
			<file type="M">org.apache.camel.processor.aggregate.AggregateProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="2633" opendate="2010-04-12 07:11:08" fixdate="2010-04-12 13:44:44" resolution="Fixed">
		<buginformation>
			<summary>camel-http - Endpoint options should not change the http component configured options</summary>
			<description>If a http endpoint is using httpBindingRef option to use a special binding, then it would change the binding on the http component, which means than any new http endpoints created thereafter will use what binding that aforementioned endpoint was using.</description>
			<version>2.0.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http4.HttpComponent.java</file>
			<file type="M">org.apache.camel.component.http.HttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="2637" opendate="2010-04-12 17:25:26" fixdate="2010-04-13 11:11:22" resolution="Fixed">
		<buginformation>
			<summary>ErrorHandler - errorHandlerRef should use mandatory lookup to fail if id is not found in Registry</summary>
			<description>To fail if end user have mistyped an id</description>
			<version>2.0.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.config.SpringErrorHandlerConfigFallbackTest.java</file>
			<file type="M">org.apache.camel.spring.handler.ErrorHandlerDefinitionParser.java</file>
			<file type="M">org.apache.camel.spring.handler.CamelNamespaceHandler.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilderRef.java</file>
		</fixedFiles>
	</bug>
	<bug id="2640" opendate="2010-04-13 15:15:01" fixdate="2010-04-14 08:22:59" resolution="Fixed">
		<buginformation>
			<summary>file component - Fix recursive and noop not picking up files with similar name in sibling folders</summary>
			<description>See nabble
http://old.nabble.com/File-consumer-with-noop%3Dtrue-recursive%3Dtrue-ts28229501.html</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileOnCompletion.java</file>
			<file type="M">org.apache.camel.spring.processor.idempotent.FileConsumerIdempotentTest.java</file>
			<file type="M">org.apache.camel.component.file.stress.FileAsyncStressTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2649" opendate="2010-04-15 10:58:00" fixdate="2010-04-15 11:47:12" resolution="Fixed">
		<buginformation>
			<summary>FactoryBeans for ProducerTemplate and ConsumerTemplate should be singleton to avoid</summary>
			<description>You want the ProducerTemplate with the assigned id to be a singleton scoped instance, so its shared.
Currently it creates a new instance which it should not.</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.CamelProducerTemplateFactoryBean.java</file>
			<file type="M">org.apache.camel.spring.remoting.CamelProxyFactoryBean.java</file>
			<file type="M">org.apache.camel.spring.CamelConsumerTemplateFactoryBean.java</file>
			<file type="M">org.apache.camel.spring.config.ConsumerTemplateAlreadyExistTest.java</file>
			<file type="M">org.apache.camel.spring.config.ProducerTemplateAlreadyExistTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2638" opendate="2010-04-12 19:26:21" fixdate="2010-04-21 01:53:06" resolution="Fixed">
		<buginformation>
			<summary>Restlet component is URL encoding the POST message body.  It should encode it based on content-type request header.</summary>
			<description>I attempted to POST a JSON document to couchdb via restlet.  The post fails with and "Invalid JSON format" error from couchdb.  This is because the POST data was being URL encoded which substitutes %XX sequences for all the curly braces.  I believe the encoding should be done based on the content-type header, or possibly not at all for POST requests.  </description>
			<version>2.1.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.DefaultRestletBinding.java</file>
			<file type="M">org.apache.camel.component.restlet.RestletRouteBuilderTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2662" opendate="2010-04-21 05:11:18" fixdate="2010-04-21 06:09:31" resolution="Fixed">
		<buginformation>
			<summary>ftp - exception thrown from begin should remove the file from in progress so the file can be polled on subsequent calls</summary>
			<description>The SFTP component can throw an exception in its begin logic, which causes Camel to not remove the file from its internal in progress cache.
See nabble
http://old.nabble.com/SFTP-rename-problems-ts28254146.html</description>
			<version>2.0.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2665" opendate="2010-04-22 06:50:48" fixdate="2010-04-22 14:30:24" resolution="Fixed">
		<buginformation>
			<summary>Policy should handle lifecycle of wrapped processor, otherwise it will not be automatic started on startup</summary>
			<description>If you use policy to wrap a Processor, then the wrapped Processor is not automatic started/stopped as lifecycle cannot see this wrapped processor.
And to prevent end users from remembering to do this themselves we should let a WrapProcessor handle this for us.</description>
			<version>2.0.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.AggregateDefinition.java</file>
			<file type="M">org.apache.camel.processor.SplitterStreamCacheTest.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.model.PipelineDefinition.java</file>
			<file type="M">org.apache.camel.component.jms.tx.XMLQueueToQueueTransactionTest.java</file>
			<file type="M">org.apache.camel.model.CatchDefinition.java</file>
			<file type="M">org.apache.camel.model.PolicyDefinition.java</file>
			<file type="M">org.apache.camel.processor.aggregate.AggregateProcessor.java</file>
			<file type="M">org.apache.camel.model.SplitDefinition.java</file>
			<file type="M">org.apache.camel.model.TryDefinition.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.model.InterceptFromDefinition.java</file>
			<file type="M">org.apache.camel.model.SamplingDefinition.java</file>
			<file type="M">org.apache.camel.model.FinallyDefinition.java</file>
			<file type="M">org.apache.camel.model.IdempotentConsumerDefinition.java</file>
			<file type="M">org.apache.camel.model.InterceptSendToEndpointDefinition.java</file>
			<file type="M">org.apache.camel.model.ThreadsDefinition.java</file>
			<file type="M">org.apache.camel.model.DelayDefinition.java</file>
			<file type="M">org.apache.camel.model.MulticastDefinition.java</file>
			<file type="M">org.apache.camel.model.ResequenceDefinition.java</file>
			<file type="M">org.apache.camel.model.OnExceptionDefinition.java</file>
			<file type="M">org.apache.camel.model.TransactedDefinition.java</file>
			<file type="M">org.apache.camel.model.OnCompletionDefinition.java</file>
			<file type="M">org.apache.camel.model.OtherwiseDefinition.java</file>
			<file type="M">org.apache.camel.component.jms.tx.XMLQueueToProcessorTransactionTest.java</file>
			<file type="M">org.apache.camel.model.LoopDefinition.java</file>
			<file type="M">org.apache.camel.model.InterceptDefinition.java</file>
			<file type="M">org.apache.camel.model.ExpressionNode.java</file>
			<file type="M">org.apache.camel.model.ToDefinition.java</file>
			<file type="M">org.apache.camel.model.ThrottleDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="1919" opendate="2009-08-18 06:36:58" fixdate="2010-04-27 14:53:35" resolution="Fixed">
		<buginformation>
			<summary>Include route builder as template for other routes to improve route reuse</summary>
			<description>It should be possible to include another route builder as a kind of template to improve route reuse.
The existing method addRoutes should either be change to support this properly or we add a new method.
However it does looks as if we could just tailor addRoutes method.
What needs also is to expose this in the Spring XML as well.</description>
			<version>1.6.1</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.RouteBuilder.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilderAddRoutesOnlyInterceptTest.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilderAddRoutesTest.java</file>
			<file type="M">org.apache.camel.spring.processor.SpringTestHelper.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2677</link>
			<link type="Duplicate" description="duplicates">1780</link>
		</links>
	</bug>
	<bug id="2678" opendate="2010-04-27 09:36:44" fixdate="2010-04-28 09:08:37" resolution="Fixed">
		<buginformation>
			<summary>Removing entries from FileIdempotentRepository don&amp;apos;t get persisted</summary>
			<description>Removing an entry (file name) programatically from a file idempotent repository has only effect on the cache and does not get persisted on the file repository. 
There are some situations in which one may need to rerun a file through a workflow and it makes neccessary to remove the file from the idempotent repository. A specific problem arises when upon a server restart, the file is not picked up by the workflow because the remove was not persisted/spooled on the disk.</description>
			<version>2.0.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.idempotent.FileIdempotentRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="2639" opendate="2010-04-13 06:21:58" fixdate="2010-04-29 11:55:59" resolution="Fixed">
		<buginformation>
			<summary>Some examples does not run with ANT</summary>
			<description>See nabble
http://old.nabble.com/camel-example-etl-and-ant-won%27t-run-ts28213644.html</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.aggregate.AggregateProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="2698" opendate="2010-05-06 09:07:46" fixdate="2010-05-06 09:18:28" resolution="Fixed">
		<buginformation>
			<summary>camel-netty - NettyProducer should detect write failures as its async operation</summary>
			<description>It should do as MinaHelper
See nabble
http://old.nabble.com/Recovery-From-Netty-Connection-Drop-ts28467631.html</description>
			<version>2.3.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.NettyProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2700" opendate="2010-05-06 13:29:30" fixdate="2010-05-06 13:47:08" resolution="Fixed">
		<buginformation>
			<summary>cxfbean component should ignore the wsdlLocation in the POJO</summary>
			<description>cxfbean component should ignore the wsdlLocation in the annotation in the POJO when starting the service. It should be using the JAXWS bean to create the service. Came across this bug when I (mistakenly) set the wsdlLocation to the http one published by the service, which of course wasn&amp;amp;apos;t up yet and I got the exception below. Fix for this coming soon.
For Googlers out there, this ticket may fix this error message you may be getting:

Caused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: cxfbean://jaxwsBean due to: Failed to create service.
    at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:437)
    at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:46)
    at org.apache.camel.model.RouteDefinition.resolveEndpoint(RouteDefinition.java:154)
    at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:109)
    at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:115)
    at org.apache.camel.model.SendDefinition.resolveEndpoint(SendDefinition.java:63)
    at org.apache.camel.model.SendDefinition.createProcessor(SendDefinition.java:57)
    at org.apache.camel.model.ToDefinition.createProcessor(ToDefinition.java:87)
    at org.apache.camel.model.ProcessorDefinition.makeProcessor(ProcessorDefinition.java:286)
    at org.apache.camel.model.ProcessorDefinition.addRoutes(ProcessorDefinition.java:114)
    at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:640)
    ... 32 more
Caused by: org.apache.cxf.service.factory.ServiceConstructionException: Failed to create service.
    at org.apache.cxf.wsdl11.WSDLServiceFactory.&amp;lt;init&amp;gt;(WSDLServiceFactory.java:93)
    at org.apache.cxf.service.factory.ReflectionServiceFactoryBean.buildServiceFromWSDL(ReflectionServiceFactoryBean.java:396)
    at org.apache.cxf.service.factory.ReflectionServiceFactoryBean.initializeServiceModel(ReflectionServiceFactoryBean.java:521)
    at org.apache.cxf.service.factory.ReflectionServiceFactoryBean.create(ReflectionServiceFactoryBean.java:271)
    at org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean.create(JaxWsServiceFactoryBean.java:177)
    at org.apache.cxf.frontend.AbstractWSDLBasedEndpointFactory.createEndpoint(AbstractWSDLBasedEndpointFactory.java:100)
    at org.apache.cxf.frontend.ServerFactoryBean.create(ServerFactoryBean.java:105)
    at org.apache.cxf.jaxws.JaxWsServerFactoryBean.create(JaxWsServerFactoryBean.java:167)
    at org.apache.camel.component.cxf.cxfbean.CxfBeanEndpoint.createServer(CxfBeanEndpoint.java:104)
    at org.apache.camel.component.cxf.cxfbean.CxfBeanEndpoint.init(CxfBeanEndpoint.java:86)
    at org.apache.camel.component.cxf.cxfbean.CxfBeanComponent.createEndpoint(CxfBeanComponent.java:48)
    at org.apache.camel.impl.DefaultComponent.createEndpoint(DefaultComponent.java:78)
    at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:416)
    ... 42 more
Caused by: javax.wsdl.WSDLException: WSDLException: faultCode=PARSER_ERROR: java.lang.IllegalArgumentException: InputSource must have a ByteStream or CharacterStream
    at org.apache.cxf.wsdl11.WSDLManagerImpl.loadDefinition(WSDLManagerImpl.java:226)
    at org.apache.cxf.wsdl11.WSDLManagerImpl.getDefinition(WSDLManagerImpl.java:179)
    at org.apache.cxf.wsdl11.WSDLServiceFactory.&amp;lt;init&amp;gt;(WSDLServiceFactory.java:91)
    ... 54 more
Caused by: java.lang.IllegalArgumentException: InputSource must have a ByteStream or CharacterStream
    at org.apache.cxf.staxutils.StaxUtils.createXMLStreamReader(StaxUtils.java:983)
    at org.apache.cxf.wsdl11.WSDLManagerImpl.loadDefinition(WSDLManagerImpl.java:217)
    ... 56 more 

</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.cxfbean.CxfBeanEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="2694" opendate="2010-05-05 13:06:43" fixdate="2010-05-07 07:15:35" resolution="Fixed">
		<buginformation>
			<summary>HttpEntityConverter should not create a InputStreamEntity by using the GZIPHelper.toGZIPInputStream()</summary>
			<description>GZIPHelper.toGZIPInputStream() is used for uncompress the zip date and not for compress the data.</description>
			<version>1.6.0</version>
			<fixedVersion>1.6.3, 2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.helper.GZIPHelper.java</file>
			<file type="M">org.apache.camel.component.jetty.HttpConverterTest.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.http.helper.GZIPHelperTest.java</file>
			<file type="M">org.apache.camel.component.http.DefaultHttpBinding.java</file>
			<file type="M">org.apache.camel.component.http.HttpConverter.java</file>
			<file type="M">org.apache.camel.component.http.CamelServlet.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.osgi.test.MyTypeConverter.java</file>
			<file type="M">org.apache.camel.component.http.RequestEntityConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2663" opendate="2010-04-21 10:21:23" fixdate="2010-05-07 07:18:32" resolution="Fixed">
		<buginformation>
			<summary>DefaultPackageScanClassResolver can&amp;apos;t read entries in an eclipse rcp app because it can&amp;apos;t handle bundleresource - protocol</summary>
			<description>scenario:
I have an eclipse rcp based app and use the apache camel libs within my plugin, i.e. the libs are one classpath of the plugin. I use a route using camel-mail to process some mailqueues.
CamelContext context = new DefaultCamelContext();
context.addRoutes(new RouteBuilder() {
    public void configure()	{
        from("imaps://mailserver?username=user&amp;amp;password=password&amp;amp;consumer.delay=5000&amp;amp;delete=false&amp;amp;unseen=true")
            .to("log: new mail");
   }});
   context.start();
When I start my app all seems to be ok. But in my log I get a lot of error messages regarding the loading of converters. If I ask my context to find a converter f.i. to converty to byte[] form inputstream (as I did see in another mail example reagding attachments) I get null because the context can&amp;amp;apos;t find one.
I debugged  deeper into the camel code and it seems that the DefaultPackageScanClassResolver can&amp;amp;apos;t load from urls starting with bundleresource like "bundleresource://109.fwk32380043:4/org/apache/camel/component/file/"
using camel-osgi didn&amp;amp;apos;t worked because all camel libs are loaded as inner libs of my single plugin and not as plugins. (loading as plugins didn&amp;amp;apos;t worked but thats another problem/bug)
LOG Messages:
2010-04-21 11:15:34,829 DEBUG org.apache.camel.impl.converter.DefaultTypeConverter loadTypeConverters - Loading type converters ...
2010-04-21 11:15:34,829 DEBUG org.apache.camel.impl.DefaultPackageScanClassResolver findAnnotated - Searching for annotations of org.apache.camel.Converter in packages: [org.apache.camel.component.file, org.apache.camel.component.bean, org.apache.camel.converter, org.apache.camel.component.mail, org.apache.camel.component.spring.integration.converter]
2010-04-21 11:15:34,829 DEBUG org.apache.camel.impl.DefaultPackageScanClassResolver getClassLoaders - The thread context class loader: org.eclipse.core.runtime.internal.adaptor.ContextFinder@1a76eff  is used to load the class
2010-04-21 11:15:34,829 DEBUG org.apache.camel.impl.DefaultPackageScanClassResolver find - Searching for: annotated with @Converter in package: org/apache/camel/component/file using classloader: org.eclipse.core.runtime.internal.adaptor.ContextFinder
2010-04-21 11:15:39,954 DEBUG org.apache.camel.impl.DefaultPackageScanClassResolver getResources - Getting resource URL for package: org/apache/camel/component/file with classloader: org.eclipse.core.runtime.internal.adaptor.ContextFinder@1a76eff
2010-04-21 11:16:44,970 DEBUG org.apache.camel.impl.DefaultPackageScanClassResolver find - URL from classloader: bundleresource://109.fwk32380043:4/org/apache/camel/component/file/
2010-04-21 11:17:01,642 DEBUG org.apache.camel.impl.DefaultPackageScanClassResolver find - Decoded urlPath: /org/apache/camel/component/file/ with protocol: bundleresource
2010-04-21 11:23:59,814 DEBUG org.apache.camel.impl.DefaultPackageScanClassResolver find - isLocalFileSystem: false
2010-04-21 11:24:00,470 DEBUG org.apache.camel.impl.DefaultPackageScanClassResolver find - Scanning for classes in [/org/apache/camel/component/file/] matching criteria: annotated with @Converter
2010-04-21 11:24:16,079 DEBUG org.apache.camel.impl.DefaultPackageScanClassResolver find - Loading from jar using http/https: /org/apache/camel/component/file/
2010-04-21 11:24:26,626 DEBUG org.apache.camel.impl.DefaultPackageScanClassResolver find - Cannot read entries in url: bundleresource://109.fwk32380043:4/org/apache/camel/component/file/
java.net.MalformedURLException: no protocol: /org/apache/camel/component/file/
	at java.net.URL.&amp;lt;init&amp;gt;(URL.java:567)
	at java.net.URL.&amp;lt;init&amp;gt;(URL.java:464)
	at java.net.URL.&amp;lt;init&amp;gt;(URL.java:413)
	at org.apache.camel.impl.DefaultPackageScanClassResolver.find(DefaultPackageScanClassResolver.java:264)
	at org.apache.camel.impl.DefaultPackageScanClassResolver.find(DefaultPackageScanClassResolver.java:180)
	at org.apache.camel.impl.DefaultPackageScanClassResolver.findAnnotated(DefaultPackageScanClassResolver.java:100)
	at org.apache.camel.impl.converter.AnnotationTypeConverterLoader.load(AnnotationTypeConverterLoader.java:63)
	at org.apache.camel.impl.converter.DefaultTypeConverter.loadTypeConverters(DefaultTypeConverter.java:361)
	at org.apache.camel.impl.converter.DefaultTypeConverter.doStart(DefaultTypeConverter.java:384)
	at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:53)
	at org.apache.camel.util.ServiceHelper.startService(ServiceHelper.java:49)
	at org.apache.camel.impl.DefaultCamelContext.startServices(DefaultCamelContext.java:1174)
	at org.apache.camel.impl.DefaultCamelContext.addService(DefaultCamelContext.java:644)
	at org.apache.camel.impl.DefaultCamelContext.getTypeConverter(DefaultCamelContext.java:691)
	at org.apache.camel.util.CamelContextHelper.convertTo(CamelContextHelper.java:68)</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultPackageScanClassResolver.java</file>
			<file type="M">org.apache.camel.component.eclipse.EclipsePackageScanClassResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="2708" opendate="2010-05-11 05:55:26" fixdate="2010-05-11 09:17:28" resolution="Fixed">
		<buginformation>
			<summary>File name lost when it starts with the same characters as the relative directory on the endpoint</summary>
			<description>When polling file from a directory using a relative file URI, the file name gets lost when it starts with the same characters as the directory name.
E.g. a directory &amp;amp;apos;orders&amp;amp;apos; containing &amp;amp;apos;orders-1719.xml&amp;amp;apos; and &amp;amp;apos;orders-1819.xml&amp;amp;apos;

from("file:orders").process(new Processor() {
  public void process(Exchange exchange) {
    // there&amp;amp;apos;s no file name on the message here (exchange.getIn().getHeader(Exchange.FILE_NAME) returns null)
  }
});

</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.stress.FileAsyncStressReadLockNoneTest.java</file>
			<file type="M">org.apache.camel.component.file.stress.FileAsyncStressTest.java</file>
			<file type="M">org.apache.camel.component.file.stress.FileAsyncStressReadLockRenameTest.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.stress.FileAsyncStressReadLockLockFileTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2692" opendate="2010-05-05 04:57:40" fixdate="2010-05-12 07:02:18" resolution="Fixed">
		<buginformation>
			<summary>Multithreading bug: getBody sporadically returns null</summary>
			<description>Note that the only workaround for this bug is to remove the parallelProcessing() call in the builder.
I have a simple route that processes a file by splitting on a tag and processing the DOM of each split message. The problem is that getBody is randomly returning null but ONLY when using the parallelProcessing feature of split. For some runs of the same XML file, the error does not occur at all (the file is about 2MB of data), others it will happen once or twice. I am currently using the latest 2.3-SNAPSHOT. 
Also note, that after detecting the null, I tried calling getBody(String.class) - this also may return null. Sometimes it does return the proper XML. 
Route configuration that reproduces the problem (my input XML is about 2MB with about 500 article tags): 
        public void configure() throws Exception { 
          from("file:/inbox") 
            .split(new XPathBuilder("//article")) 
              .parallelProcessing()                     // remove this line getBody below never returns null 
              .process(new Processor() { 
                public void process(Exchange exchange) throws Exception { 
                  Message inMessage = exchange.getIn(); 
                  org.w3c.dom.Document domDocument = inMessage.getBody(org.w3c.dom.Document.class); 
                  if (domDocument == null) 
{ 
                    log("Null body"); 
                  }
 else 
{ 
                    // process DOM here 
                  }
 
                } 
              }) 
            .end() 
        } 
      }); </description>
			<version>1.6.2</version>
			<fixedVersion>1.6.3, 2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.jaxp.XmlConverter.java</file>
			<file type="M">org.apache.camel.builder.xml.XPathTest.java</file>
			<file type="M">org.apache.camel.converter.jaxp.XmlConverterTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2722" opendate="2010-05-14 02:23:19" fixdate="2010-05-15 00:22:12" resolution="Fixed">
		<buginformation>
			<summary>ManagedRoute should be unregister when the RouteDefinition is removed</summary>
			<description>Here is the mailing thread which discusses about it.
http://old.nabble.com/Dynamically-removing-routes-tp28548051p28548051.html</description>
			<version>2.1.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.ManagedRouteShutdownAndStartTest.java</file>
			<file type="M">org.apache.camel.management.DefaultManagementLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.impl.RouteService.java</file>
		</fixedFiles>
	</bug>
	<bug id="2725" opendate="2010-05-15 08:05:40" fixdate="2010-05-15 08:58:28" resolution="Fixed">
		<buginformation>
			<summary>String to Source type converter is not found in TypeConverterRegistry</summary>
			<description>This causes a problem when you need to convert a String payload to a javax.xml.transformation.Source such as when using the XSTL component.
</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.jaxp.DomConverter.java</file>
			<file type="M">org.apache.camel.component.cxf.converter.MyCxfCustomerConverter.java</file>
			<file type="M">org.apache.camel.converter.jaxp.XmlConverterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.util.CxfUtils.java</file>
			<file type="M">org.apache.camel.converter.stream.StreamCacheConverterTest.java</file>
			<file type="M">org.apache.camel.processor.cache.CacheBasedXPathReplacer.java</file>
			<file type="M">org.apache.camel.management.DefaultManagementLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.converter.jaxp.XmlConverter.java</file>
			<file type="M">org.apache.camel.processor.ExceptionHandlerStreamCacheTest.java</file>
			<file type="M">org.apache.camel.converter.jaxp.DomConverterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfPayload.java</file>
		</fixedFiles>
	</bug>
	<bug id="2732" opendate="2010-05-18 15:12:06" fixdate="2010-05-19 01:02:55" resolution="Fixed">
		<buginformation>
			<summary>SMPP component should set the final status header for delivery notifications</summary>
			<description>The camel-smpp comonent should set the final status that is provided by the delivery receipt from the SMSC.
Currently the status header is not set, but can easily be added by making a call to smscDeliveryReceipt.getFinalStatus() and setting the header CamelSmppStatus on the camel message (as documented on the site http://camel.apache.org/smpp.html.
Patch provided. </description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.smpp.SmppBindingTest.java</file>
			<file type="M">org.apache.camel.component.smpp.SmppBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="2744" opendate="2010-05-20 16:37:08" fixdate="2010-05-21 05:58:32" resolution="Fixed">
		<buginformation>
			<summary>AggregationStrategy returning null causes NPE</summary>
			<description>When the AggregationStrategy&amp;amp;apos;s aggregate method returns null, the AggregateProcessor throws an NPE. While this is a result of user error, I think it would be easy to provide a more useful error indicating what the true problem is. This is the (not very helpful) error the user sees:

ERROR | Caused by: [org.apache.camel.RuntimeCamelException - java.lang.NullPointerException]
org.apache.camel.RuntimeCamelException: java.lang.NullPointerException
	at org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException(ObjectHelper.java:1117)
	at org.apache.camel.component.jms.EndpointMessageListener.onMessage(EndpointMessageListener.java:104)
	at org.springframework.jms.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:543)
	at org.springframework.jms.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:482)
	at org.springframework.jms.listener.AbstractMessageListenerContainer.doExecuteListener(AbstractMessageListenerContainer.java:451)
	at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.doReceiveAndExecute(AbstractPollingMessageListenerContainer.java:323)
	at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:261)
	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:982)
	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.executeOngoingLoop(DefaultMessageListenerContainer.java:974)
	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:876)
	at java.lang.Thread.run(Thread.java:619)
Caused by: java.lang.NullPointerException
	at org.apache.camel.processor.aggregate.AggregateProcessor.doAggregation(AggregateProcessor.java:227)
	at org.apache.camel.processor.aggregate.AggregateProcessor.process(AggregateProcessor.java:182)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:67)
	at org.apache.camel.processor.DelegateProcessor.processNext(DelegateProcessor.java:53)
	at org.apache.camel.processor.DelegateProcessor.proceed(DelegateProcessor.java:82)
	at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:97)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:67)
	at org.apache.camel.processor.RedeliveryErrorHandler.processExchange(RedeliveryErrorHandler.java:185)
	at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:151)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:89)
	at org.apache.camel.processor.DefaultErrorHandler.process(DefaultErrorHandler.java:49)
	at org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:228)
	at org.apache.camel.processor.UnitOfWorkProcessor.processNext(UnitOfWorkProcessor.java:70)
	at org.apache.camel.processor.DelegateProcessor.process(DelegateProcessor.java:48)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:67)
	at org.apache.camel.component.jms.EndpointMessageListener.onMessage(EndpointMessageListener.java:84)
	... 9 more

</description>
			<version>2.3.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.aggregate.AggregateProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="2741" opendate="2010-05-20 02:31:39" fixdate="2010-05-21 06:16:41" resolution="Fixed">
		<buginformation>
			<summary>GZIP/ZIP marshal/unmarshal leaves input file open</summary>
			<description>Gzip/zip marshal/unmarshal leaves input files open, relying on the garbage collector to close the file. The cause sporadic file deletion exceptions in the following route:
          from("file:incoming?delete=true")
            .marshal().gzip()
            .to("file:outgoing?fileName=$
{file:name}
.gz");
</description>
			<version>2.3.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultPackageScanClassResolver.java</file>
			<file type="M">org.apache.camel.component.file.FileOperations.java</file>
			<file type="M">org.apache.camel.processor.idempotent.FileIdempotentRepository.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileProducer.java</file>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.converter.IOConverter.java</file>
			<file type="M">org.apache.camel.converter.NIOConverter.java</file>
			<file type="M">org.apache.camel.component.file.strategy.FileLockExclusiveReadLockStrategy.java</file>
			<file type="M">org.apache.camel.impl.ZipDataFormat.java</file>
			<file type="M">org.apache.camel.impl.DefaultFactoryFinder.java</file>
			<file type="M">org.apache.camel.impl.converter.AnnotationTypeConverterLoader.java</file>
			<file type="M">org.apache.camel.impl.GzipDataFormat.java</file>
			<file type="M">org.apache.camel.util.IOHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="2636" opendate="2010-04-12 15:17:53" fixdate="2010-05-21 06:30:05" resolution="Fixed">
		<buginformation>
			<summary>IOException: Bad file descriptor and FileNotFoundException</summary>
			<description>When I try to stream BINARY (pdf) file using camel-http I get the java.io.IOException: Bad file descriptor
The pdf isn&amp;amp;apos;t recieved succesfully by reciever (0kb)
This seems to be caused by a bug in java (on linux systems), closing inputstream twice causes problems. It seemed to me this is exactly what is happening, see also link:
http://256.com/gray/docs/misc/java_bad_file_descriptor_close_bug.shtml
I fixed this by (checking out apache camel-core and camel-http 2.2.0):
In FileInputStreamCache.java:
In method close() wrapped getInputStream().close() in if:
if (stream != null &amp;amp;&amp;amp; stream instanceof FileInputStream &amp;amp;&amp;amp; ((FileInputStream) stream).getChannel().isOpen()) {
getInputStream().close() ;
}
In method reset() also:
if (stream != null &amp;amp;&amp;amp; stream instanceof FileInputStream &amp;amp;&amp;amp; ((FileInputStream) stream).getChannel().isOpen()) {
getInputStream().close() ;
}
Second I needed to fix a filenotfoundexception, the tempfile created by camel was deleted to early.
I changed CachedOutputStream.java

Reimplemented constructor:
public CachedOutputStream(Exchange exchange) {
        String hold = exchange.getContext().getProperties().get(THRESHOLD);
        String dir = exchange.getContext().getProperties().get(TEMP_DIR);
        if (hold != null) 
{
            this.threshold = exchange.getContext().getTypeConverter().convertTo(Long.class, hold);
        }
        if (dir != null) 
{
            this.outputDir = exchange.getContext().getTypeConverter().convertTo(File.class, dir);
        }

        // add on completion so we can cleanup after the exchange is done such
        // as deleting temporary files
        exchange.addOnCompletion(new SynchronizationAdapter() {
            @Override
            public void onDone(Exchange exchange) {
                try {
                    // close the stream and FileInputStreamCache
                    // close();
                    // for (FileInputStreamCache cache : fileInputStreamCaches)
                    // 
{
                    // cache.close();
                    // }
                    // cleanup temporary file
                    if (tempFile != null) {
                        System.err.println("####################################################");
                        System.err.println("DISABLED tempFile.delete:89");
                        System.err.println("####################################################");
                        // boolean deleted = tempFile.delete();
                        // if (!deleted) 
{
                        // LOG.warn("Cannot delete temporary cache file: " +
                        // tempFile);
                        // }
 else if (LOG.isTraceEnabled()) 
{
                        // LOG.trace("Deleted temporary cache file: " +
                        // tempFile);
                        // }
                        tempFile = null;
                    }
                } catch (Exception e) 
{
                    LOG.warn("Error deleting temporary cache file: " + tempFile, e);
                }
            }
            @Override
            public String toString() 
{
                return "OnCompletion[CachedOutputStream]";
            }
        });
    }
Reimplemented close():
public void close() throws IOException {
        System.err.println("####################################################");
        System.err.println("outputStream.close:119 -&amp;gt; delete tempFile");
        System.err.println("####################################################");
        new Exception().printStackTrace();
        currentStream.close();
        boolean deleted = tempFile.delete();
        if (!deleted) 
{
            LOG.warn("Cannot delete temporary cache file: " + tempFile);
        }
 else if (LOG.isTraceEnabled()) 
{
            LOG.trace("Deleted temporary cache file: " + tempFile);
        }
    }</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStreamTest.java</file>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStream.java</file>
			<file type="M">org.apache.camel.converter.stream.FileInputStreamCache.java</file>
		</fixedFiles>
	</bug>
	<bug id="2739" opendate="2010-05-19 13:05:31" fixdate="2010-05-21 07:13:00" resolution="Fixed">
		<buginformation>
			<summary>Problem with Spring NamespaceHandler class org.apache.camel.spring.handler.CamelNamespaceHandler </summary>
			<description>I contributed spring Namespace Handler from my custom eclipse plug-in as follows:
&amp;lt;extension point="org.springframework.ide.eclipse.beans.core.namespaces"&amp;gt;
		&amp;lt;namespace name="Camel Spring Namespace Handler extension"
			namespaceHandler="org.apache.camel.spring.handler.CamelNamespaceHandler"
			uri="http://camel.apache.org/schema/spring"&amp;gt;
		&amp;lt;/namespace&amp;gt;
&amp;lt;/extension&amp;gt;
After this, I create spring.xml file using some camel elements and I validated using spring validator . Now whenever I edit the spring.xml file and save it I am getting following error message in error log.
org.springframework.beans.factory.BeanDefinitionStoreException: Unexpected exception parsing XML document from file [C:/workspace locations/New Folder (10)/config/spring.xml]; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;template&amp;amp;apos;: Not implemented
at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:420)
at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:342)
at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$2.loadBeanDefinitions(BeansConfig.java:326)
at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:310)
at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$3.call(BeansConfig.java:358)
at org.springframework.ide.eclipse.beans.core.internal.model.BeansConfig$3.call(BeansConfig.java:1)
at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:269)
at java.util.concurrent.FutureTask.run(FutureTask.java:123)
at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:417)
at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:269)
at java.util.concurrent.FutureTask.run(FutureTask.java:123)
at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:651)
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:676)
at java.lang.Thread.run(Thread.java:595)
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;template&amp;amp;apos;: Not implemented
at org.springframework.ide.eclipse.beans.core.DefaultBeanDefinitionRegistry.removeBeanDefinition(DefaultBeanDefinitionRegistry.java:189)
at org.apache.camel.spring.handler.CamelNamespaceHandler.autoRegisterBeanDefinition(CamelNamespaceHandler.java:411)
at org.apache.camel.spring.handler.CamelNamespaceHandler.registerTemplates(CamelNamespaceHandler.java:364)
at org.apache.camel.spring.handler.CamelNamespaceHandler$CamelContextBeanDefinitionParser.doParse(CamelNamespaceHandler.java:272)
at org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser.parseInternal(AbstractSingleBeanDefinitionParser.java:84)
at org.springframework.beans.factory.xml.AbstractBeanDefinitionParser.parse(AbstractBeanDefinitionParser.java:56)
at org.springframework.beans.factory.xml.NamespaceHandlerSupport.parse(NamespaceHandlerSupport.java:69)
at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1297)
at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1287)
at org.apache.camel.component.cxf.transport.spring.AbstractCamelContextBeanDefinitionParser.doParse(AbstractCamelContextBeanDefinitionParser.java:55)
at org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser.parseInternal(AbstractSingleBeanDefinitionParser.java:84)
at org.springframework.beans.factory.xml.AbstractBeanDefinitionParser.parse(AbstractBeanDefinitionParser.java:56)
at org.springframework.beans.factory.xml.NamespaceHandlerSupport.parse(NamespaceHandlerSupport.java:69)
at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1297)
at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1287)
at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:135)
at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:92)
at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:507)
at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:398)
There seems to problem with NamespaceHandler class. </description>
			<version>2.1.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.handler.CamelNamespaceHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="2745" opendate="2010-05-21 06:59:31" fixdate="2010-05-21 07:26:50" resolution="Fixed">
		<buginformation>
			<summary>ExpressionDefinition toString  print the expression and expression value at the same time</summary>
			<description>When I running the test which need to call the ExpressionDefinition toString method, I found the expression is

    simple{bodyAs(java.lang.String.class)bodyAs[java.lang.String]}


We need to avoid adding the expression when the ExpressionDefinition has the expression value.</description>
			<version>2.0.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.language.ExpressionDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="2742" opendate="2010-05-20 12:52:19" fixdate="2010-05-21 14:19:14" resolution="Fixed">
		<buginformation>
			<summary>camel-jms - Sending to WebSphereMQ must use specific setBooleanProperty methods to set JMS properties</summary>
			<description>This code in JMSBinding

                // must encode to safe JMS header name before setting property on jmsMessage
                String key = jmsKeyFormatStrategy.encodeKey(headerName);
                jmsMessage.setObjectProperty(key, value);


Should detect the value type and use the jmsMessage.setBooleanProperty() and so on. Otherwise IBM thrown an exception.
See nabble
http://old.nabble.com/jmsbinding-problem-ts28620489.html</description>
			<version>2.2.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsMessageHelper.java</file>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="2751" opendate="2010-05-25 18:58:50" fixdate="2010-05-26 02:21:54" resolution="Fixed">
		<buginformation>
			<summary>Timer Component is not Restartable</summary>
			<description>When the TimerComponent is stopped, it cancels all of the Timer instances it has created, which is good. However, TimerEndpoint keeps a local reference to the Timer instance, so if the TimerComponent is restarted, the TimerEndpoint will throw an exception as its timer is no longer usable as it has been canceled.
This patch provides a unit test, TimerRestartTest, and an update to TimerComponent that fixes this issue. The TimerComponent fix is to keep a list of all TimerEndpoints that have a reference to a Timer instance created by the TimerComponent. When TimerComponent.doStop is called, those TimerEndpoint references to the now canceled Timer instances are cleared.</description>
			<version>2.2.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.timer.TimerEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="2750" opendate="2010-05-25 14:26:28" fixdate="2010-05-26 09:16:03" resolution="Fixed">
		<buginformation>
			<summary>org.apache.camel.component.bean.BeanInfo not working properly with mocked Interfaces</summary>
			<description>The BeanInfo-Class shows the same behaviour as ClassUtils-Class from Spring 3.0.x (see Spring Issue 7066, https://jira.springsource.org/browse/SPR-7066).
When working with mock objects created by mockito using an interface the getSuperclass()-Method returns java.lang.Object and the method to called on the mock can&amp;amp;apos;t be found. 
While looking around for a solution I found the path applied in Spring (see https://fisheye.springsource.org/browse/spring-framework/trunk/org.springframework.core/src/main/java/org/springframework/util/ClassUtils.java?content-type=text/vnd.viewcvs-markup&amp;amp;r1=3227&amp;amp;r2=3228).
In method 
public static Class&amp;lt;?&amp;gt; getUserClass(Class&amp;lt;?&amp;gt; clazz) 
the code
return (clazz != null &amp;amp;&amp;amp; clazz.getName().contains(CGLIB_CLASS_SEPARATOR) ?  clazz.getSuperclass() : clazz);
is replaced by 
if (clazz != null &amp;amp;&amp;amp; clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {
    Class&amp;lt;?&amp;gt; superClass = clazz.getSuperclass();
    if (superClass != null &amp;amp;&amp;amp; !Object.class.equals(superClass)) 
{
         return superClass;
    }
}
return clazz;
While waiting for a fix in BeanInfo class a workaround is to mock the concrete class not the interface, but this makes the test code more complicated if several classes implement the same interface.
A Wor</description>
			<version>2.2.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
		</fixedFiles>
	</bug>
	<bug id="2758" opendate="2010-05-27 05:23:53" fixdate="2010-05-27 06:09:41" resolution="Fixed">
		<buginformation>
			<summary>OnCompletion - Should use pipes and filters to ensure IN is OUT from last step</summary>
			<description>OnCompletion will route the Exchange directly as is which means if you have set an OUT the first step in the onCompletion route may not use this OUT but the IN instead.
And also add option useOriginalBody so you can do work based on the original input instead.</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.OnCompletionProcessor.java</file>
			<file type="M">org.apache.camel.model.OnCompletionDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="2755" opendate="2010-05-26 21:59:41" fixdate="2010-05-27 06:26:26" resolution="Fixed">
		<buginformation>
			<summary>VM endpoints with same name do not communicate if args don&amp;apos;t match</summary>
			<description>If you send to a VM endpoint from one route and consume from the same endpoint in another route, but include an argument on only one of the routes, Camel sees them as two different routes.  Therefore, the messages are never consumed.  For example:
&amp;lt;camelContext id="sendNotifyContext"
	xmlns="http://camel.apache.org/schema/spring"
	errorHandlerRef="errorHandler"&amp;gt;
      &amp;lt;route id="sendToNotify"&amp;gt;
            &amp;lt;from uri="..." /&amp;gt;
            ....
&amp;lt;to uri="vm:myNotify" /&amp;gt;
      &amp;lt;/route&amp;gt;
&amp;lt;/camelContext&amp;gt;
&amp;lt;camelContext id="receiveNotifyContext"
	xmlns="http://camel.apache.org/schema/spring"
	errorHandlerRef="errorHandler"&amp;gt;
      &amp;lt;route id="receiveNotify"&amp;gt;
&amp;lt;from uri="vm:myNotify?size=2500" /&amp;gt;
            ....
            &amp;lt;to uri="..." /&amp;gt;
      &amp;lt;/route&amp;gt;
&amp;lt;/camelContext&amp;gt;
The producer appears to send to vm:myNotify while the consumer is listening to a separate endpoint named vm:myNotify?size=2500, so the messages build up and are never received.</description>
			<version>2.2.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.seda.SedaComponent.java</file>
			<file type="M">org.apache.camel.component.vm.VmComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="2760" opendate="2010-05-27 13:19:52" fixdate="2010-05-27 13:31:03" resolution="Fixed">
		<buginformation>
			<summary>@Consume should run in an unit of work</summary>
			<description></description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.CamelPostProcessorHelperTest.java</file>
			<file type="M">org.apache.camel.impl.CamelPostProcessorHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="2762" opendate="2010-05-27 16:07:47" fixdate="2010-05-28 07:39:27" resolution="Fixed">
		<buginformation>
			<summary>Default Tracer configuration eats Mina ByteBuffer responses</summary>
			<description>It appears that the only way to get UDP responses out of Camel Mina without binary ( &amp;gt; 7 bit) getting garbled by internal conversions is to reply with a Mina ByteBuffer.
Unfortunately, if you have Trace on, the DefaultTraceFormatter ends up calling MinaConverter.toByteArray, which "consumes" the ByteBuffer, setting it to empty, which means no reply goes out. 

27/05/10 07:02:41:DEBUG:org.apache.camel.component.mina.MinaConsumer:Writing body: DirectBuffer[pos=11 lim=11 cap=16: empty]


I&amp;amp;apos;m not sure how to fix this one cleanly, so I don&amp;amp;apos;t have a patch.  I might also be doing something wrong, if so I&amp;amp;apos;m all ears. 
Here&amp;amp;apos;s a trace:

	  at org.apache.camel.component.mina.MinaConverter.toByteArray(MinaConverter.java:44)
	  at org.apache.camel.component.mina.MinaConverter.toString(MinaConverter.java:49)
	  at sun.reflect.GeneratedMethodAccessor228.invoke(Unknown Source:-1)
	  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	  at java.lang.reflect.Method.invoke(Method.java:597)
	  at org.apache.camel.util.ObjectHelper.invokeMethod(ObjectHelper.java:736)
	  at org.apache.camel.impl.converter.StaticMethodTypeConverter.convertTo(StaticMethodTypeConverter.java:50)
	  at org.apache.camel.impl.converter.DefaultTypeConverter.doConvertTo(DefaultTypeConverter.java:159)
	  at org.apache.camel.impl.converter.DefaultTypeConverter.convertTo(DefaultTypeConverter.java:85)
	  at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:74)
	  at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:48)
	  at org.apache.camel.util.MessageHelper.extractBodyAsString(MessageHelper.java:63)
	  at org.apache.camel.processor.interceptor.DefaultTraceFormatter.format(DefaultTraceFormatter.java:75)
	  at org.apache.camel.processor.interceptor.TraceInterceptor.format(TraceInterceptor.java:231)


Thanks!</description>
			<version>2.2.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina.MinaConverterTest.java</file>
			<file type="M">org.apache.camel.component.mina.MinaConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2763" opendate="2010-05-28 03:40:35" fixdate="2010-05-28 08:16:06" resolution="Fixed">
		<buginformation>
			<summary>MailBinding can&amp;apos;t handle the subject header with NO_ASCII code rightly.</summary>
			<description>Here is the mail thread which discusses about it.</description>
			<version>1.4.0</version>
			<fixedVersion>1.6.3, 2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailRouteTest.java</file>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="2778" opendate="2010-06-02 00:42:54" fixdate="2010-06-02 08:36:52" resolution="Fixed">
		<buginformation>
			<summary>Escaped characters in http4 URLs do not work</summary>
			<description>There is a bug in http4 HttpProducer that is unescaping URL query and path components too early. Patch fix attached.</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.helper.HttpProducerHelper.java</file>
			<file type="M">org.apache.camel.component.jetty.HttpClientRouteTest.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.http4.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.http4.helper.HttpProducerHelper.java</file>
			<file type="M">org.apache.camel.component.http4.HttpPathTest.java</file>
			<file type="M">org.apache.camel.component.http4.HttpQueryTest.java</file>
			<file type="M">org.apache.camel.component.http4.handler.BasicValidationHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="2772" opendate="2010-06-01 00:55:21" fixdate="2010-06-02 10:10:34" resolution="Fixed">
		<buginformation>
			<summary>camel-jetty can&amp;apos;t deal with multiform data rightly</summary>
			<description>You can&amp;amp;apos;t get the inputStream from the attachment when camel-jetty handle the request of MultiPartForm.
Here is the mail thread[1] which discusses about it.
[1] http://old.nabble.com/Unsupported-data-type-exception-with-Jetty-component-tp28730373p28731758.html</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http4.DefaultHttpBinding.java</file>
			<file type="M">org.apache.camel.component.http.DefaultHttpBinding.java</file>
			<file type="M">org.apache.camel.component.jetty.MultiPartFormTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2776" opendate="2010-06-01 20:17:08" fixdate="2010-06-07 01:44:34" resolution="Fixed">
		<buginformation>
			<summary>Cached stream file deletion causing file not found errors</summary>
			<description>Cached streams larger than the threshold (64K by default) are almost impossible to work with since when a cached stream is closed, the cached file is deleted. This occurs as a side effect of converting the associated body to string which can occur frequently if tracing is turned on. The net result is file not found errors shown below. The only workaround is to increase the threshold to a large value to keep the body in memory.
It seems that if stream caching is to be useful, the cached files should be kept in a map and cleaned up and the end of the route, rather than upon close.
Work around (set threshold to 10M):
    camelContext.getProperties().put(CachedOutputStream.THRESHOLD, "10000000");
Error without work around:
16:09:49.278 [main] ERROR o.a.c.c.t.TimerConsumer - Error processing exchange. Exchange[Message: [Body is instance of java.io.InputStream]]. Caused by: [org.apache.camel.RuntimeCamelException - java.io.FileNotFoundException: C:\Users\ROLAND~1\AppData\Local\Temp\camel-tmp-594543\cos3643004935230268170.tmp (The system cannot find the file specified)]
org.apache.camel.RuntimeCamelException: java.io.FileNotFoundException: C:\Users\ROLAND~1\AppData\Local\Temp\camel-tmp-594543\cos3643004935230268170.tmp (The system cannot find the file specified)
	at org.apache.camel.converter.stream.FileInputStreamCache.reset(FileInputStreamCache.java:65)
	at org.apache.camel.util.MessageHelper.resetStreamCache(MessageHelper.java:106)
	at org.apache.camel.processor.RedeliveryErrorHandler.deliverToFailureProcessor(RedeliveryErrorHandler.java:344)
	at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:111)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:89)
	at org.apache.camel.processor.DefaultErrorHandler.process(DefaultErrorHandler.java:49)
	at org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:228)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:75)
	at org.apache.camel.processor.UnitOfWorkProcessor.processNext(UnitOfWorkProcessor.java:80)
	at org.apache.camel.processor.DelegateProcessor.process(DelegateProcessor.java:48)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:67)
	at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:44)
	at org.apache.camel.processor.SendProcessor$1.doInProducer(SendProcessor.java:106)
	at org.apache.camel.processor.SendProcessor$1.doInProducer(SendProcessor.java:104)
	at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:189)
	at org.apache.camel.processor.SendProcessor.doProcess(SendProcessor.java:103)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:87)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:67)
	at org.apache.camel.processor.DelegateProcessor.processNext(DelegateProcessor.java:53)
	at org.apache.camel.processor.DelegateProcessor.proceed(DelegateProcessor.java:82)
	at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:173)
	at org.apache.camel.processor.interceptor.StreamCachingInterceptor.process(StreamCachingInterceptor.java:52)
	at org.apache.camel.processor.interceptor.StreamCachingInterceptor.process(StreamCachingInterceptor.java:52)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:67)
	at org.apache.camel.processor.RedeliveryErrorHandler.processExchange(RedeliveryErrorHandler.java:185)
	at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:151)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:89)
	at org.apache.camel.processor.DefaultErrorHandler.process(DefaultErrorHandler.java:49)
	at org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:228)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:75)
	at org.apache.camel.processor.UnitOfWorkProcessor.processNext(UnitOfWorkProcessor.java:70)
	at org.apache.camel.processor.DelegateProcessor.process(DelegateProcessor.java:48)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:67)
	at org.apache.camel.component.timer.TimerConsumer.sendTimerExchange(TimerConsumer.java:102)
	at org.apache.camel.component.timer.TimerConsumer$1.run(TimerConsumer.java:49)
	at java.util.TimerThread.mainLoop(Timer.java:512)
	at java.util.TimerThread.run(Timer.java:462)
Caused by: java.io.FileNotFoundException: C:\Users\ROLAND~1\AppData\Local\Temp\camel-tmp-594543\cos3643004935230268170.tmp (The system cannot find the file specified)
	at java.io.FileInputStream.open(Native Method)
	at java.io.FileInputStream.&amp;lt;init&amp;gt;(FileInputStream.java:106)
	at org.apache.camel.converter.stream.FileInputStreamCache.reset(FileInputStreamCache.java:63)
	... 36 common frames omitted</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStream.java</file>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStreamTest.java</file>
			<file type="M">org.apache.camel.converter.stream.FileInputStreamCache.java</file>
			<file type="M">org.apache.camel.processor.SplitterStreamCacheTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2496" opendate="2010-02-24 15:38:16" fixdate="2010-06-07 01:45:15" resolution="Fixed">
		<buginformation>
			<summary>StreamCache/Splitter race condition</summary>
			<description>Attached patch introduces a test that shows the following symptom:
org.apache.camel.RuntimeCamelException: java.io.FileNotFoundException: /var/folders/vC/vCA487MkHEeSaIu9LmlkrU+++TI/Tmp/camel-tmp-627613/cos3755307044377901165.tmp (No such file or directory)
org.apache.camel.RuntimeCamelException: java.io.FileNotFoundException: /var/folders/vC/vCA487MkHEeSaIu9LmlkrU+++TI/Tmp/camel-tmp-627613/cos3755307044377901165.tmp (No such file or directory)
	at org.apache.camel.converter.stream.FileInputStreamCache.reset(FileInputStreamCache.java:52)
	at org.apache.camel.converter.stream.StreamCacheConverter$StreamSourceCache.reset(StreamCacheConverter.java:126)
	at org.apache.camel.util.MessageHelper.resetStreamCache(MessageHelper.java:105)
	at org.apache.camel.builder.xml.XPathBuilder.getDocument(XPathBuilder.java:548)
	at org.apache.camel.builder.xml.XPathBuilder.evaluateAs(XPathBuilder.java:428)
	at org.apache.camel.builder.xml.XPathBuilder.evaluate(XPathBuilder.java:118)
	at org.apache.camel.processor.Splitter.createProcessorExchangePairs(Splitter.java:72)
	at org.apache.camel.processor.MulticastProcessor.process(MulticastProcessor.java:155)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:80)
	at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:189)
	at org.apache.camel.processor.DeadLetterChannel.process(DeadLetterChannel.java:133)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:68)
	at org.apache.camel.processor.interceptor.StreamCachingInterceptor.proceed(StreamCachingInterceptor.java:87)
	at org.apache.camel.processor.interceptor.StreamCachingInterceptor.process(StreamCachingInterceptor.java:82)
	at org.apache.camel.processor.UnitOfWorkProcessor.process(UnitOfWorkProcessor.java:52)
	at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:72)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:637)
I believe it must be a race condition when several threads are passing through the splitter, in the above case I&amp;amp;apos;m using a seda queue with 5 threads.  Am logging this now as I&amp;amp;apos;m not sure what time I&amp;amp;apos;ll have to investigate further this week.</description>
			<version>1.6.1</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStream.java</file>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStreamTest.java</file>
			<file type="M">org.apache.camel.converter.stream.FileInputStreamCache.java</file>
			<file type="M">org.apache.camel.processor.SplitterStreamCacheTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2642" opendate="2010-04-14 09:26:59" fixdate="2010-06-07 11:39:08" resolution="Fixed">
		<buginformation>
			<summary>Inconsistency between IntrospectionSupport.getProperties() and IntrospectionSupport.getProperty()</summary>
			<description>IntrospectionSupport.getProperties() and IntrospectionSupport.getProperty() work in an inconsistency way:

ExampleBean bean = new ExampleBean();
Date date = new Date(0);
bean.setDate(date);

assertSame(date, IntrospectionSupport.getProperty(bean, "date")); // succeed

Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;();
IntrospectionSupport.getProperties(bean, map, null);
assertSame(date, map.get("date")); // fails

</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
			<file type="M">org.apache.camel.util.IntrospectionSupport.java</file>
			<file type="M">org.apache.camel.util.IntrospectionSupportTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2798" opendate="2010-06-08 08:33:48" fixdate="2010-06-09 11:09:26" resolution="Fixed">
		<buginformation>
			<summary>Aggregation raises NullPointerException if last file in batch is not to be aggregated.</summary>
			<description>When trying to aggregate files from a directory, it seems that camel-core raises a NullPointerException if the last file of the batch is a single file. That is it doesn&amp;amp;apos;t match the correlationExpression with any other files and therefore should just pass through. If such a file is the first file or in the middle of the files (alphabetically) this issue is not present.
See:
http://old.nabble.com/Aggregator-problem-with-files-(Camel-2.3)-td28778641.html#a28780522</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.aggregate.AggregateProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="2773" opendate="2010-06-01 06:33:40" fixdate="2010-06-11 15:02:16" resolution="Fixed">
		<buginformation>
			<summary>Bindy - No @Section causes a null key being generated which causes a NumberFormatException</summary>
			<description>See nabble
http://old.nabble.com/Bindy-CSV-not-Marshaling-ts28719942.html</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.bindy.BindyKeyValuePairFactory.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.CommonBindyTest.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyAbstractFactory.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.fix.BindySimpleKeyValuePairMarshallDslTest.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindySimpleCsvUnmarshallBadIntegerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2806" opendate="2010-06-12 05:39:03" fixdate="2010-06-12 05:42:23" resolution="Fixed">
		<buginformation>
			<summary>camel-jetty  can&amp;apos;t config the temp directory for the multi part form support rightly</summary>
			<description>You will get a ClassCastException if you try to set the temp directory from the camel property.</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.MultiPartFormTest.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="2811" opendate="2010-06-14 15:28:54" fixdate="2010-06-15 11:50:06" resolution="Fixed">
		<buginformation>
			<summary>CamelContexts seems to not correctly create their own instance of an imported routeContext.</summary>
			<description>Issue: http://old.nabble.com/Direct-route-not-shared-across-contexts--td28766143.html
When two CamelContexts import the same routeContext they should instantiate their own route based on the definition in the routeContext. But something is not working correctly. One example is having a directqueue of the same name in each route-instance. Camel crashed with the exception:
org.apache.camel.RuntimeCamelException: java.lang.IllegalStateException: Endpoint direct://foo only allows 1 active consumer but you attempted to start a 2nd consumer.
	at org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException(ObjectHelper.java:1126)
	at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:103) ...
This is demonstrated in the sample file attached to this issue.
Obviously this makes other things than the direct-endpoints malfunction. But this should be enough to show the problem.</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.RandomLoadBalanceTest.java</file>
			<file type="M">org.apache.camel.model.FromDefinition.java</file>
			<file type="M">org.apache.camel.model.StartingRoutesErrorReportedTest.java</file>
			<file type="M">org.apache.camel.spring.config.XmlConfigTestSupport.java</file>
			<file type="M">org.apache.camel.model.SendDefinition.java</file>
			<file type="M">org.apache.camel.processor.DualPipelineTest.java</file>
			<file type="M">org.apache.camel.processor.RandomLoadBalanceJavaDSLBuilderTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2821" opendate="2010-06-16 04:14:55" fixdate="2010-06-16 04:17:05" resolution="Fixed">
		<buginformation>
			<summary>camel-ftp - SFTP in fileExists should handle exception being thrown with id code stating no such file</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/camel-ftp-cannot-create-directory-using-sftp-tp479092p479092.html</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.SftpOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="2817" opendate="2010-06-15 22:17:11" fixdate="2010-06-16 04:49:16" resolution="Fixed">
		<buginformation>
			<summary>renames (to .processed) are sometimes done even if the download failed.</summary>
			<description>I have an ftp consumer endpoint URI like: 
ftp://conaxTest@localhost:2121/autreq/ok?passiveMode=true&amp;amp;amp;password=conaxTest&amp;amp;move=.processed&amp;amp;delay=5000
From my ftp server logs, I can see files being downloaded, and then renamed...

[org.apache.ftpserver.command.impl.RETR:pool-2-thread-56] - &amp;lt;File downloaded /autreq/ok/vp006331.emm&amp;gt;
[org.apache.ftpserver.command.impl.RETR:pool-2-thread-56] - &amp;lt;File downloaded /autreq/ok/vp006332.emm&amp;gt;
[org.apache.ftpserver.impl.DefaultFtpHandler:pool-2-thread-57] - &amp;lt;Session idle, closing&amp;gt;
[org.apache.ftpserver.command.impl.RNTO:pool-2-thread-56] - &amp;lt;File rename from "/autreq/ok/vp006331.emm" to "/autreq/ok/.processed/vp006331.emm"&amp;gt;
[org.apache.ftpserver.command.impl.RNTO:pool-2-thread-54] - &amp;lt;File rename from "/autreq/ok/vp006332.emm" to "/autreq/ok/.processed/vp006332.emm"&amp;gt;
[org.apache.ftpserver.command.impl.RNTO:pool-2-thread-54] - &amp;lt;File rename from "/autreq/ok/vp006333.emm" to "/autreq/ok/.processed/vp006333.emm"&amp;gt;
Note, that vp006333.emm is renamed, but was never downloaded.  There&amp;amp;apos;s no other mention of the file in my logs.  On the camel ftp consumer side, I see that camel attempted to download the file, but ended up with a null...

[is.vf.conan.conax.FileParser:Camel thread 7: seda://updateOk] - &amp;lt;handling: GenericFile[vp006331.emm]&amp;gt;
[is.vf.conan.ConanCore:Camel thread 7: seda://updateOk] - &amp;lt;updating operation txid:006331 with the results: OK&amp;gt;
[is.vf.conan.conax.FileParser:Camel thread 7: seda://updateOk] - &amp;lt;handling: GenericFile[vp006332.emm]&amp;gt;
[is.vf.conan.ConanCore:Camel thread 7: seda://updateOk] - &amp;lt;updating operation txid:006332 with the results: OK&amp;gt;
[is.vf.conan.conax.FileParser:Camel thread 7: seda://updateOk] - &amp;lt;handling: GenericFile[vp006333.emm]&amp;gt;
[is.vf.conan.conax.FileParser:Camel thread 7: seda://updateOk] - &amp;lt;Requested parse of an empty file!&amp;gt;
The "requested parse of an empty file" is logged when ex.getIn().getBody(String.class) is empty or blank for the file object.
I had a look through the bugs fixed for 2.3.0, but I don&amp;amp;apos;t see anything that would be related to this at all.</description>
			<version>2.1.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2805" opendate="2010-06-10 14:19:42" fixdate="2010-06-16 08:45:24" resolution="Fixed">
		<buginformation>
			<summary>It is impossible to put # sign in SQL statement in camel-sql</summary>
			<description>SqlProducer implementation turns all # characters into ? making it impossible to have # in the SQL statement.</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sql.SqlRouteTest.java</file>
			<file type="M">org.apache.camel.component.sql.SqlComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="2825" opendate="2010-06-17 07:16:29" fixdate="2010-06-17 07:42:15" resolution="Fixed">
		<buginformation>
			<summary>onException - continued should not log exhausted just as handled does neither</summary>
			<description>Continued is in fact just like handled by will not break out but continue routing as if the exception didnt occur. So we should not log the exception by default.</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.UnitOfWorkProcessor.java</file>
			<file type="D">org.apache.camel.processor.async.AsyncEndpointFailedAfterOnExceptionTest.java</file>
			<file type="M">org.apache.camel.processor.RedeliveryErrorHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="2824" opendate="2010-06-16 19:43:30" fixdate="2010-06-18 05:36:52" resolution="Fixed">
		<buginformation>
			<summary>Deadlock in org.apache.camel.util.DefaultTimeoutMap</summary>
			<description>After running a camel route with a camel Aggregator for a while, I get a deadlock in  org.apache.camel.util.DefaultTimeoutMap. A full processdump is attached to this bug.
I have also tried to recreate this as failing testcase, but without any luck so far. </description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.aggregator.AggregateTimeoutOnlyTest.java</file>
			<file type="M">org.apache.camel.util.TimeoutMap.java</file>
			<file type="M">org.apache.camel.util.DefaultTimeoutMap.java</file>
			<file type="M">org.apache.camel.processor.aggregate.AggregateProcessor.java</file>
			<file type="M">org.apache.camel.processor.aggregator.AggregateFromWireTapTest.java</file>
			<file type="M">org.apache.camel.util.DefaultTimeoutMapTest.java</file>
			<file type="M">org.apache.camel.processor.aggregator.AggregatorTest.java</file>
			<file type="M">org.apache.camel.management.JmxNotificationEventNotifier.java</file>
		</fixedFiles>
	</bug>
	<bug id="2829" opendate="2010-06-18 12:41:02" fixdate="2010-06-22 04:36:10" resolution="Fixed">
		<buginformation>
			<summary>"Unconnected sockets not implemented" exception in camel-ftp when using ftps</summary>
			<description>When using ftps with a secure data channel, camel-ftp cannot recover from a lost connection. This is due to a bug/flaw in the SFTPClient class in commons-net. Once a secure data channel has been established, SFTPClient replaces the connection factory with one that does not provide support for creating "unconnected sockets".
While waiting for a fix from the commons-net team (should they chosse to create one), a work-around in camel-ftp is to always create a new instance of SFTPClient for every connect attempt.
Attached are patches containing an attempt to implement the mentioned work-around. The classes, FtpsOperations, FtpsEndpoint and FtpOperations are involved.</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileProducer.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileConverter.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileProducer.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="2843" opendate="2010-06-23 11:25:20" fixdate="2010-06-23 11:33:17" resolution="Fixed">
		<buginformation>
			<summary>camel-groovy - setting header causes exchange to lose message details</summary>
			<description>See SMX4-417
This is the ticket to fix this issue.</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelperTest.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="is depended upon by">417</link>
		</links>
	</bug>
	<bug id="2851" opendate="2010-06-24 14:23:24" fixdate="2010-06-25 09:07:00" resolution="Fixed">
		<buginformation>
			<summary>typo: ManagedBrowsableEndpoint qeue should be queue</summary>
			<description>
    @ManagedOperation(description = "Current number of Exchanges in Queue")
    public long qeueSize() {
        return endpoint.getExchanges().size();
    }


Should be 

    @ManagedOperation(description = "Current number of Exchanges in Queue")
    public long queueSize() {
        return endpoint.getExchanges().size();
    }

</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.ManagedBrowseableEndpointTest.java</file>
			<file type="M">org.apache.camel.management.mbean.ManagedBrowsableEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="2867" opendate="2010-06-28 07:03:17" fixdate="2010-06-28 07:04:45" resolution="Fixed">
		<buginformation>
			<summary>convertBodyTo should handle null bodies</summary>
			<description>If the body is null and you use convertBodyTo you will get a no type converter exception due body is null. Instead it should accept the null body and continue routing.</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.ConvertBodyTest.java</file>
			<file type="M">org.apache.camel.processor.DelegateProcessor.java</file>
			<file type="M">org.apache.camel.processor.ConvertBodyProcessor.java</file>
			<file type="M">org.apache.camel.processor.ChoiceProcessor.java</file>
			<file type="M">org.apache.camel.processor.DelegateAsyncProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="2854" opendate="2010-06-24 23:47:08" fixdate="2010-06-29 09:20:11" resolution="Fixed">
		<buginformation>
			<summary>No consumers available on "direct://xyz" endpoint</summary>
			<description>The following warning in log4j log shows up with no predictable reason:
2010-06-24 14:07:01,090  WARN [DefaultMessageListenerContainer-7:DirectProducer.java:42] No consumers available on endpoint: Endpoint[direct://UserCancelJobRequest] to process: Exchange[JmsMessage: RunnerBase
{locationToRunId=&amp;amp;apos;DV02YcABTE43HTRPATEGCBFk0m0&amp;amp;apos;, jobrun_id=1234, requestOrigId=&amp;amp;apos;null&amp;amp;apos;, secretKey=&amp;amp;apos;null&amp;amp;apos;, replyToQueueOrTopic=&amp;amp;apos;null&amp;amp;apos;, corrolationId=&amp;amp;apos;null&amp;amp;apos;, requestCreationTime=Thu Jun 24 14:07:01 PDT 2010}
]
The endpoint [direct://UserCancelJobRequest] could be a number of different endpoints in our application and all of them are of "direct:" type.  When this happens, all messages that run through that endpoint will fail, and it will never recover unless the application is restarted.
Also, if I restart the application and use that route immediately, that warning will not occur and the request will finish successfully.  It seems to happen to routes that have not been used for a while after startup.
When this happens, I can find the exact Camel endpoint/route/processor in JConsole, and nothing seems to be wrong.  How can a "direct:" endpoint runs out of consumer?  Isn&amp;amp;apos;t the thread that product this warning THE thread to process the message?
We recently upgraded from 5.2 to 5.3.2 and this starts to show up randomly. It is a show stopper!
--Michael</description>
			<version>2.2.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.TransformToTest.java</file>
			<file type="M">org.apache.camel.processor.PipelineMEPTest.java</file>
			<file type="M">org.apache.camel.component.bean.BeanInPipelineTest.java</file>
			<file type="M">org.apache.camel.issues.CoarseGrainedProcessorDefinitionIssueTest.java</file>
			<file type="M">org.apache.camel.spring.example.PojoDualCamelContextConsumerTest.java</file>
			<file type="M">org.apache.camel.processor.intercept.InterceptSendToEndpointTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultProducerTemplateTest.java</file>
			<file type="M">org.apache.camel.component.direct.DirectEndpoint.java</file>
			<file type="M">org.apache.camel.processor.ValidationWithHandlePipelineTest.java</file>
			<file type="M">org.apache.camel.component.direct.DirectConsumer.java</file>
			<file type="M">org.apache.camel.component.direct.DirectComponent.java</file>
			<file type="M">org.apache.camel.spring.config.ProducerTemplateMaximumCacheSizeTest.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="depends upon">2873</link>
		</links>
	</bug>
	<bug id="2881" opendate="2010-06-30 09:40:28" fixdate="2010-06-30 10:00:50" resolution="Fixed">
		<buginformation>
			<summary>jms consumer should handle markRollbackOnly</summary>
			<description>If using markRollbackOnly to dente the route should rollback the Spring DMLC does not rollback despite its status has been told so. We are forced to thrown runtime exceptions.</description>
			<version>2.2.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.tx.JmsToJmsTransactedTest.java</file>
			<file type="M">org.apache.camel.component.jms.EndpointMessageListener.java</file>
			<file type="M">org.apache.camel.spring.spi.TransactionErrorHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="2858" opendate="2010-06-25 11:06:01" fixdate="2010-06-30 15:18:40" resolution="Fixed">
		<buginformation>
			<summary>useOriginalBody() still appears in fluent API; should be useOriginalMessage()</summary>
			<description>The org.apache.camel.model.OnExceptionDefinition class defines useOriginalBody() in the fluent API. This should actually be useOriginalMessage(), in accordance with CAMEL-1820.</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.OnExceptionDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="2860" opendate="2010-06-25 11:53:34" fixdate="2010-07-01 08:07:48" resolution="Fixed">
		<buginformation>
			<summary>camel-ftp - Should use absolute paths, eg the leading / should always be included</summary>
			<description>FTP Servers expect clients to use absolute paths, so camel-ftp clients should not clip any leading /
We could consider adding a flag to preserve the old behavior to have people if they rely on the old behavior be able to switch that flag on.</description>
			<version>2.0.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileConfiguration.java</file>
			<file type="M">org.apache.camel.util.FileUtilTest.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileConfiguration.java</file>
			<file type="M">org.apache.camel.util.FileUtil.java</file>
			<file type="M">org.apache.camel.component.file.remote.UriConfigurationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2893" opendate="2010-07-01 17:24:32" fixdate="2010-07-01 17:27:01" resolution="Fixed">
		<buginformation>
			<summary>(FromDefintion|ToDefinition).getUriOrRef tend to return null when they should return a URI</summary>
			<description>looks like a simple logic bug to me. Have a fix locally - just checking it works...</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.FromDefinition.java</file>
			<file type="M">org.apache.camel.view.GraphSupport.java</file>
			<file type="M">org.apache.camel.model.SendDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="2897" opendate="2010-07-02 08:22:01" fixdate="2010-07-02 08:26:36" resolution="Fixed">
		<buginformation>
			<summary>Splitting file using tokenizer should close the Scanner to avoid files not being able to be moved thereafter</summary>
			<description></description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.Splitter.java</file>
			<file type="M">org.apache.camel.issues.FileSplitStreamingWithChoiceTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2899" opendate="2010-07-02 11:49:32" fixdate="2010-07-06 08:22:20" resolution="Fixed">
		<buginformation>
			<summary>out of heap space if remote FTP site has too many files to pick up</summary>
			<description>2010-07-02 11:38:07,439 FATAL [org.apache.camel.component.file.remote.FtpConsumer:CamelThread 10]   - &amp;lt;Consumer Consumer[my_ftp_URI_here caused by: Java heap space&amp;gt;
java.lang.OutOfMemoryError: Java heap space
My remote FTP server has ~60k 100 byte files, and the camel endpoint consumer falls over and doesn&amp;amp;apos;t start again.  I can use JMX to stop/start the consumer, (it still has status "started") and it will log in to the remote server again, but then fall over with the out of heap space.
I can work around this by increasing the heap, or by moving some of the files aside,  but I don&amp;amp;apos;t think camel should care how many files there are, or at least, I think it should deal with it more gracefully.</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2909" opendate="2010-07-05 14:11:36" fixdate="2010-07-06 09:01:35" resolution="Fixed">
		<buginformation>
			<summary>Oracle AQ does not support the JMSReplyTo property and therefore throws a "JMS-102: Feature not supported" exception when the JMS provider tries to get it.</summary>
			<description>Oracle AQ does not support the JMSReplyTo property and therefore throws a "JMS-102: Feature not supported" exception when the JMS provider tries to get it.</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
			<file type="M">org.apache.camel.component.jms.EndpointMessageListener.java</file>
		</fixedFiles>
	</bug>
	<bug id="2912" opendate="2010-07-06 13:32:24" fixdate="2010-07-06 15:27:01" resolution="Fixed">
		<buginformation>
			<summary>SFTP throws ResolveEndpointFailedException when "ftpClient.connectionTimeout" option is provided</summary>
			<description>Currently, SFTP throws an ResolveEndpointFailed exception if the option "ftpClient.connectionTimeout" is provided as a part of the URI. This could be fixed by calling the Session.connect(int timeout) method of JSCH. Some investigation reveals that this method eventually calls Socket.setSoTimeout(int timeout), which implies that the time unit of the timeout is milliseconds.
http://grepcode.com/file/repo1.maven.org/maven2/com.jcraft/jsch/0.1.42/com/jcraft/jsch/Session.java#Session.connect%28int%29
Example:
sftp://user@host/dir?password=secret&amp;amp;ftpClient.connectionTimeout=30000&amp;amp;disconnect=true&amp;amp;passiveMode=true
ResolveEndpointFailedException:
[...]
There are 1 parameters that couldn&amp;amp;apos;t be set on the endpoint. Check the uri if the parameters are spelt correctly and that they are properties of the endpoint. Unknown parameters=[
{ftpClient.connectionTimeout=30000}
] </description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileConfiguration.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpOperations.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpOperations.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpsEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="2716" opendate="2010-05-12 19:14:26" fixdate="2010-07-08 15:22:46" resolution="Fixed">
		<buginformation>
			<summary>Incomplete cleanup of jmx mbeans after context stop</summary>
			<description>There is a fair amount of cleanup on context stop, but it is incomplete. Most of it has to do with JMX and if one creates and starts a new CamelContext she may end up with managed objects pointing nowhere or have duplicates or other minor side-effects. One of the nasty side effects is that we are pretty much forced to use "&amp;lt;forkMode&amp;gt;pertest&amp;lt;/forkMode&amp;gt;" in our surefire plugin configuration, ensuring a clean slate for every test.
For long running apps in which you may have multiple CamelContext running at various times during the lifetime of the application we must properly cleanup when stopping the context. I have a series of patches fixing that which I hope to finish before 2.3. Once we&amp;amp;apos;re comfortable and tested with multiple jdk implementations and versions, I&amp;amp;apos;d change the forkMode to "once". In my local copy this reduces the test time in core from 40+ mins to under 15 mins. Since interactions between tests is still possible and might lead us on a wild-goose we could add another profile that uses the safer yet time consuming "pertest" forkMode.</description>
			<version>2.2.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.TestSupport.java</file>
			<file type="M">org.apache.camel.builder.BuilderWithScopesTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContextAutoStartupTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContextTest.java</file>
			<file type="M">org.apache.camel.management.ManagedRouteStopAndStartCleanupTest.java</file>
			<file type="M">org.apache.camel.component.direct.DirectNoMultipleConsumersTest.java</file>
			<file type="M">org.apache.camel.management.MultiInstanceProcessorTest.java</file>
			<file type="M">org.apache.camel.management.JmxInstrumentationUsingPlatformMBSTest.java</file>
			<file type="M">org.apache.camel.management.JmxInstrumentationWithConnectorTest.java</file>
			<file type="M">org.apache.camel.management.JmxInstrumentationUsingDefaultsTest.java</file>
			<file type="M">org.apache.camel.management.JmxInstrumentationCustomMBeanTest.java</file>
			<file type="M">org.apache.camel.management.JmxInstrumentationUsingPropertiesTest.java</file>
			<file type="M">org.apache.camel.management.JmxInstrumentationDisableOnCamelContextTest.java</file>
			<file type="M">org.apache.camel.processor.ResequencerTest.java</file>
			<file type="M">org.apache.camel.management.JmxInstrumentationDisableTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.management.DefaultManagementLifecycleStrategy.java</file>
			<file type="M">org.apache.camel.management.ManagedManagementStrategy.java</file>
			<file type="M">org.apache.camel.management.ManagedDualCamelContextTest.java</file>
			<file type="M">org.apache.camel.management.ManagedUnregisterCamelContextTest.java</file>
			<file type="M">org.apache.camel.component.file.stress.FileAsyncStressTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultNodeIdFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="2935" opendate="2010-07-10 10:01:35" fixdate="2010-07-10 20:56:48" resolution="Fixed">
		<buginformation>
			<summary>Broken failure reporting via DefaultProucerTemplate.asyncCallback and Synchronization.onFailure</summary>
			<description>The recent change in ProducerCache.send
ProducerCache.java
    public void send(Endpoint endpoint, Exchange exchange) {
        try {
            sendExchange(endpoint, null, null, exchange);
            // RECENT CHANGE HERE:
            // ensure that CamelExecutionException is always thrown
            if (exchange.getException() != null) {
                exchange.setException(wrapCamelExecutionException(exchange, exchange.getException()));
            }
        } catch (Exception e) {
            throw wrapCamelExecutionException(exchange, e);
        }
    }


that throws a CamelExecutionException if exchange.getException is not null, makes it impossible for DefaultProducerTemplate.asyncCallback to report failures (other than fault messages) asynchronously via Synchronization.onFailure
DefaultProducerTemplate.java
    public Future&amp;lt;Exchange&amp;gt; asyncCallback(final Endpoint endpoint, final Exchange exchange, final Synchronization onCompletion) {
        Callable&amp;lt;Exchange&amp;gt; task = new Callable&amp;lt;Exchange&amp;gt;() {
            public Exchange call() throws Exception {

                // FIXME: exception is thrown in Camel 2.4 where a normal return with answer.getException != null was done in Camel 2.3
                Exchange answer = send(endpoint, exchange);

                if (answer.isFailed()) {
                    onCompletion.onFailure(answer);
                } else {
                    // ...
                }
                return answer;
            }
        };
        // ...
    }


This was working in Camel 2.3 (but unfortunately there wasn&amp;amp;apos;t any test case for it). I attached a patch for DefaultProducerTemplateAsyncTest that demonstrates the problem. I didn&amp;amp;apos;t commit a fix yet because I&amp;amp;apos;m unsure at the moment about the best way to fix that. Of course I tried a naive fix in the DefaultProducerTemplate.asyncCallback methods which causes the test (in the patch) to pass but I&amp;amp;apos;d like to hear other opinions before I continue.</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultProducerTemplateAsyncTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultConsumerTemplateTest.java</file>
			<file type="M">org.apache.camel.ProducerTemplate.java</file>
			<file type="M">org.apache.camel.impl.DefaultProducerTemplateTest.java</file>
			<file type="M">org.apache.camel.component.jetty.HttpAuthMethodPriorityTest.java</file>
			<file type="M">org.apache.camel.impl.ProducerCache.java</file>
			<file type="M">org.apache.camel.processor.BeanInvocationThrowsExceptionTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultProducerTemplate.java</file>
			<file type="M">org.apache.camel.impl.DefaultMessage.java</file>
			<file type="M">org.apache.camel.issues.Issue3Test.java</file>
		</fixedFiles>
	</bug>
	<bug id="2937" opendate="2010-07-11 16:26:41" fixdate="2010-07-11 16:36:37" resolution="Fixed">
		<buginformation>
			<summary>StreamProducer does not close stream in camel-stream</summary>
			<description>Since the stream could be System.out or System.err, the producer does not close the stream ever. It should close all streams with the noted exceptions.</description>
			<version>2.3.0</version>
			<fixedVersion>2.4.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.printer.PrinterPrintTest.java</file>
			<file type="M">org.apache.camel.component.stream.StreamConsumer.java</file>
			<file type="M">org.apache.camel.component.stream.StreamProducer.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">6152</link>
		</links>
	</bug>
	<bug id="2942" opendate="2010-07-13 17:18:30" fixdate="2010-07-14 01:41:34" resolution="Fixed">
		<buginformation>
			<summary>CamelHttpTransportServlet.destroy causes java.lang.IllegalArgumentException: Cannot find the deployed servlet</summary>
			<description>CamelHttpTransportServlet.destroy removes the servlet from a static map named CAMEL_SERVLET_MAP prior to stopping its associated Spring application context.  If that context defines a route using a servletEndpoint, the route is shutdown AFTER the servlet is removed from the map.  The shutdown code then looks for the servlet in the map by calling CamelHttpTransportServlet.getCamelServlet.  The servlet can&amp;amp;apos;t be found, and the ensuing exception is logged (copied below).
It seems to me that CamelHttpTransportServlet.destroy should be defined like this:
    public void destroy() {
        // Removal was here
        if (applicationContext != null) 
{
            applicationContext.stop();
        }
        // Moved the removal to here
        CAMEL_SERVLET_MAP.remove(servletName);
    }
so that the servlet is removed from the map after the context is stopped.
I know for sure that removal of the servlet from the map before the context is stopped causes this problem when my route is shutdown.  I DON&amp;amp;apos;T know for sure that my overall configuration is correct, though I think it is valid.
If the above change is not obviously correct, or if there are further questions, please let me know, and I&amp;amp;apos;ll work up a sample that demonstrates the problem to help answer any questions.

2010-07-13 09:06:23,918 [Camel Thread 0 - ShutdownTask] WARN  org.apache.camel.impl.DefaultShutdownStrategy at org.apache.camel.impl.DefaultShutdownStrategy.shutdownNow(DefaultShutdownStrategy.java:219)
         Error occurred while shutting down route: Consumer[/relay]. This exception will be ignored.
java.lang.IllegalArgumentException: Cannot find the deployed servlet, please configure the ServletComponent or configure a org.apache.camel.component.servlet.CamelHttpTransportServlet servlet in web.xml 
	at org.apache.camel.component.servlet.ServletComponent.getCamelServlet(ServletComponent.java:55)
	at org.apache.camel.component.servlet.ServletComponent.disconnect(ServletComponent.java:116)
	at org.apache.camel.component.http.HttpEndpoint.disconnect(HttpEndpoint.java:152)
	at org.apache.camel.component.http.HttpConsumer.doStop(HttpConsumer.java:56)
	at org.apache.camel.impl.ServiceSupport.stop(ServiceSupport.java:86)
	at org.apache.camel.impl.ServiceSupport.stop(ServiceSupport.java:107)
	at org.apache.camel.util.ServiceHelper.stopService(ServiceHelper.java:100)
	at org.apache.camel.impl.DefaultShutdownStrategy.shutdownNow(DefaultShutdownStrategy.java:217)
	at org.apache.camel.impl.DefaultShutdownStrategy$ShutdownTask.run(DefaultShutdownStrategy.java:413)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)
	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)
	at java.util.concurrent.FutureTask.run(FutureTask.java:138)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:637)
</description>
			<version>2.3.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.servlet.CamelHttpTransportServlet.java</file>
		</fixedFiles>
	</bug>
	<bug id="2922" opendate="2010-07-08 05:13:50" fixdate="2010-07-14 04:36:16" resolution="Fixed">
		<buginformation>
			<summary>XMPPConsumer does not remove the message which causes OOME with XMPP</summary>
			<description></description>
			<version>2.1.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xmpp.XmppConsumer.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppComponent.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppGroupChatProducer.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppPrivateChatProducer.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="2944" opendate="2010-07-14 07:03:19" fixdate="2010-07-14 08:35:07" resolution="Fixed">
		<buginformation>
			<summary>StreamCache - File spooled stream cache does not work well on Windows due not closing file resource</summary>
			<description>Windows is pesky about deleting files which may have an open stream hanging. While other OS is capable of that.
SplitterStreamCacheTest fails on windows due this issue.
The logic in CachedOutputStream should better leverage the Synchronization to be able to close the streams at the end.
Also various DOM converters will automatic closes input streams when converting to DOM. The only reliable mechanism is Camels synchronization which is invoked when the Exchange is done. And thus the time where we can cleanup.</description>
			<version>2.3.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStream.java</file>
			<file type="M">org.apache.camel.converter.stream.FileInputStreamCache.java</file>
			<file type="M">org.apache.camel.impl.converter.DefaultTypeConverter.java</file>
			<file type="M">org.apache.camel.management.EventNotifierRedeliveryEventsTest.java</file>
			<file type="M">org.apache.camel.converter.stream.FileInputStreamCacheTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2949" opendate="2010-07-14 17:43:39" fixdate="2010-07-15 03:03:05" resolution="Fixed">
		<buginformation>
			<summary>Attachment DataHander.getName() returns the name of the temporary storage file, not the MIME part name</summary>
			<description>When multipart file uploads are converted to message attachments in the DefaultHttpBinding class, the DataHandler that is created for the attachment returns the name of the temporary file created by Jetty, not the value of the name from the Content-Disposition header.  It would be useful to have the actual attachment name instead of the temporary filename in the DataHandler object for easier downstream processing.</description>
			<version>2.3.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http4.DefaultHttpBinding.java</file>
			<file type="M">org.apache.camel.component.http.helper.CamelFileDataSource.java</file>
			<file type="M">org.apache.camel.component.jetty.MultiPartFormTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2952" opendate="2010-07-15 13:19:17" fixdate="2010-07-17 09:46:48" resolution="Fixed">
		<buginformation>
			<summary>camel-ftp - Support polling from MVS file system</summary>
			<description>The MVS file system requires to change directory to starting path and use CD to traverse file path instead of using listFile(path) as currently done in camel-ftp.
This means we should walk the path using code like:
0. remember path
1. cd path
2. list files()
3. loop files
4. if dir then goto 1
5. if file add file
6. when done cd back to "remember path"
</description>
			<version>2.3.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpOperations.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpRecursiveNoopTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumerMultipleDirectoriesTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="2958" opendate="2010-07-16 10:25:01" fixdate="2010-07-17 12:16:29" resolution="Fixed">
		<buginformation>
			<summary>java.util.ConcurrentModificationException in Method org.apache.camel.util.CaseInsensitiveMap.putAll()</summary>
			<description>Every now and then I&amp;amp;apos;m facing the ConcurrentModificationException. It very hard to reproduce. This is my stack trace:
Failed delivery for exchangeId: ba969718-9044-4261-bc57-ca10aafb0a03. Exhausted after delivery attempt: 1 caught: java.util.ConcurrentModificationException
java.util.ConcurrentModificationException: null
        at java.util.HashMap$HashIterator.nextEntry(HashMap.java:793) [na:1.6.0_20]
        at java.util.HashMap$KeyIterator.next(HashMap.java:828) [na:1.6.0_20]
        at org.apache.camel.util.CaseInsensitiveMap.putAll(CaseInsensitiveMap.java:86) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.impl.MessageSupport.copyFrom(MessageSupport.java:142) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.impl.DefaultMessage.copyFrom(DefaultMessage.java:52) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.util.ExchangeHelper.copyResults(ExchangeHelper.java:199) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.processor.Pipeline.process(Pipeline.java:114) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.processor.DelegateProcessor.processNext(DelegateProcessor.java:53) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.processor.ChoiceProcessor.process(ChoiceProcessor.java:51) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:67) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.processor.DelegateProcessor.processNext(DelegateProcessor.java:53) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.processor.DelegateProcessor.proceed(DelegateProcessor.java:82) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:97) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:67) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.processor.RedeliveryErrorHandler.processExchange(RedeliveryErrorHandler.java:185) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.processor.RedeliveryErrorHandler.processErrorHandler(RedeliveryErrorHandler.java:151) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:89) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.processor.DefaultErrorHandler.process(DefaultErrorHandler.java:49) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.processor.DefaultChannel.process(DefaultChannel.java:228) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.processor.Pipeline.process(Pipeline.java:75) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.processor.UnitOfWorkProcessor.processNext(UnitOfWorkProcessor.java:70) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.processor.DelegateProcessor.process(DelegateProcessor.java:48) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:67) [camel-core-2.3.0.jar:2.3.0]
        at org.apache.camel.component.http.CamelServlet.service(CamelServlet.java:71) [camel-http-2.3.0.jar:2.3.0]
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:831) [javaee.jar:9.1]
...
Looks like CaseInsensitiveMap isn&amp;amp;apos;t enough thread save. But I have no idea what other thread is modifies the map. Most of the time everything is ok.</description>
			<version>2.3.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.CaseInsensitiveMap.java</file>
			<file type="M">org.apache.camel.util.CaseInsensitiveMapTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2962" opendate="2010-07-19 08:32:45" fixdate="2010-07-19 09:12:42" resolution="Fixed">
		<buginformation>
			<summary>camel-jms - disableReplyTo is not used in JmsProducer</summary>
			<description>The JmsProducer does not check the disableReplyTo option when sending the message.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2979" opendate="2010-07-21 09:07:59" fixdate="2010-07-22 15:00:59" resolution="Fixed">
		<buginformation>
			<summary>FtpComponent: If login fails and disconnect=true another connection is opened.</summary>
			<description>In a route such as below a second connection to the ftp server is opened if the login fails.
&amp;lt;route&amp;gt; 
        &amp;lt;from uri="ftp:localhost/inbox/?username=usr&amp;amp;password=pwd&amp;amp;disconnect=true&amp;amp;consumer.delay=60s&amp;amp;maximumReconnectAttempts=0" /&amp;gt; 
        &amp;lt;to uri="file:test_data" /&amp;gt; 
&amp;lt;/route&amp;gt; 
Further description: http://camel.465427.n5.nabble.com/FTP-Try-login-once-and-disconnect-if-failure-td1692660.html#a1692660
</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2986" opendate="2010-07-22 19:19:11" fixdate="2010-07-22 19:27:14" resolution="Fixed">
		<buginformation>
			<summary>IllegalStateException in CamelContinuationServlet under heavy load</summary>
			<description>Reason is a race between continuation.suspend() and continuation.resume(). It can occur that continuation.resume() is executed before continuation.suspend() leading to an IllegalStateException thrown by Jetty:

java.lang.IllegalStateException: DISPATCHED,initial
    at org.eclipse.jetty.server.AsyncContinuation.dispatch(AsyncContinuation.java:364)
    at org.eclipse.jetty.server.AsyncContinuation.resume(AsyncContinuation.java:769)
    at org.apache.camel.component.jetty.CamelContinuationServlet$1.done(CamelContinuationServlet.java:85)
    at org.apache.camel.management.InstrumentationProcessor$1.done(InstrumentationProcessor.java:78)
    at org.apache.camel.processor.UnitOfWorkProcessor$1.done(UnitOfWorkProcessor.java:104)
    at org.apache.camel.processor.DefaultChannel$1.done(DefaultChannel.java:262)
    at org.apache.camel.processor.RedeliveryErrorHandler$1.done(RedeliveryErrorHandler.java:302)
    at org.apache.camel.management.InstrumentationProcessor$1.done(InstrumentationProcessor.java:78)
    at org.apache.camel.management.InstrumentationProcessor$1.done(InstrumentationProcessor.java:78)


This is the case when an async completion callback is faster than the thread that is concurrently executing the if (continuation.isInitial()) block. 
I&amp;amp;apos;ll commit a fix soon that also follows the recommendations in http://wiki.eclipse.org/Jetty/Feature/Continuations to always call continuation.suspend() before registering the continuation with a callback handler.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.CamelContinuationServlet.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="2994" opendate="2010-07-26 11:21:48" fixdate="2010-07-26 13:29:07" resolution="Fixed">
		<buginformation>
			<summary>camel-cxf - CxfClientCallback is invoked twice when only one was expected</summary>
			<description>Run the test CXFWsdlOnlyTest
Because CXF invokes the CxfClientCallback 2 times there is a race condition with 2 threads wanting to complete routing the Exchange.
You can then end up with errors such as

&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;
2010-07-26 13:22:13,305 [default-workqueue-1                ] INFO  Logger                         - Exchange[Message: [Body is instance of java.io.InputStream]]
Exception in thread "default-workqueue-1" java.util.NoSuchElementException
	at java.util.AbstractList$Itr.next(AbstractList.java:350)
	at org.apache.camel.processor.Pipeline$1.done(Pipeline.java:153)
	at org.apache.camel.processor.DefaultChannel$1.done(DefaultChannel.java:262)
	at org.apache.camel.processor.RedeliveryErrorHandler$1.done(RedeliveryErrorHandler.java:302)
	at org.apache.camel.management.InstrumentationProcessor$1.done(InstrumentationProcessor.java:78)
	at org.apache.camel.management.InstrumentationProcessor$1.done(InstrumentationProcessor.java:78)
	at org.apache.camel.component.cxf.CxfClientCallback.handleException(CxfClientCallback.java:77)
	at org.apache.cxf.interceptor.ClientOutFaultObserver.onMessage(ClientOutFaultObserver.java:55)
	at org.apache.cxf.transport.http.HTTPConduit$WrappedOutputStream$1.run(HTTPConduit.java:2144)
	at org.apache.cxf.workqueue.AutomaticWorkQueueImpl$2.run(AutomaticWorkQueueImpl.java:253)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:637)
2010-07-26 13:22:13,305 [default-workqueue-2                ] INFO  Logger                         - Exchange[Message: [Body is instance of java.io.InputStream]]
Exception in thread "default-workqueue-2" java.util.NoSuchElementException
	at java.util.AbstractList$Itr.next(AbstractList.java:350)
	at org.apache.camel.processor.Pipeline$1.done(Pipeline.java:153)
	at org.apache.camel.processor.DefaultChannel$1.done(DefaultChannel.java:262)
	at org.apache.camel.processor.RedeliveryErrorHandler$1.done(RedeliveryErrorHandler.java:302)
	at org.apache.camel.management.InstrumentationProcessor$1.done(InstrumentationProcessor.java:78)
	at org.apache.camel.management.InstrumentationProcessor$1.done(InstrumentationProcessor.java:78)
	at org.apache.camel.component.cxf.CxfClientCallback.handleException(CxfClientCallback.java:77)
	at org.apache.cxf.interceptor.ClientOutFaultObserver.onMessage(ClientOutFaultObserver.java:55)
	at org.apache.cxf.transport.http.HTTPConduit$WrappedOutputStream$1.run(HTTPConduit.java:2144)
	at org.apache.cxf.workqueue.AutomaticWorkQueueImpl$2.run(AutomaticWorkQueueImpl.java:253)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:637)


CXF should only invoke the org.apache.cxf.endpoint.ClientCallback one time as we have only registered this once.</description>
			<version>2.5.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.GreeterImplWithSleep.java</file>
			<file type="M">org.apache.camel.component.cxf.interceptors.RawMessageContentRedirectInterceptor.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfClientCallback.java</file>
			<file type="M">org.apache.camel.component.cxf.CXFWsdlOnlyTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="2978" opendate="2010-07-20 22:46:40" fixdate="2010-07-26 13:33:44" resolution="Fixed">
		<buginformation>
			<summary>java.net.SocketException: Too many open files with Apache Camel(Netty TCP) 2.4.0.</summary>
			<description>I&amp;amp;apos;ve got a unit test that works fine with Apache Camel 2.3.0, but as soon as I upgraded to 2.4.0 it consistently started to fail.
It performs a number of concurrent requests using this url:
netty:tcp://localhost:2048?sync=true
In both the client and server side of the unit test.
There&amp;amp;apos;s also a sister test which does the same thing with Netty directly and that works in isolation, so it would appear something has been broken in the transition to 2.4.0.  Previously this code was also using a beta version of Netty, but even updating that specific dependency has made no difference.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.ClientPipelineFactory.java</file>
			<file type="M">org.apache.camel.component.netty.NettyEndpoint.java</file>
			<file type="M">org.apache.camel.component.netty.NettyComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="2972" opendate="2010-07-20 11:46:40" fixdate="2010-07-27 16:09:18" resolution="Fixed">
		<buginformation>
			<summary>onException not working correctly when using routeContext</summary>
			<description>When using a routeContext, the last (in the xml-file) defined route-scoped &amp;lt;onException&amp;gt; configuration is shared by the other routes in the context.
http://camel.465427.n5.nabble.com/possible-onException-bug-when-using-routeContext-td1616244.html#a1616244</description>
			<version>2.3.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategy.java</file>
			<file type="M">org.apache.camel.processor.RecipientListProcessor.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
			<file type="M">org.apache.camel.impl.DefaultUnitOfWork.java</file>
			<file type="M">org.apache.camel.core.xml.AbstractCamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.processor.Splitter.java</file>
			<file type="M">org.apache.camel.FailedToCreateConsumerException.java</file>
		</fixedFiles>
	</bug>
	<bug id="2995" opendate="2010-07-26 14:21:25" fixdate="2010-07-29 09:59:11" resolution="Fixed">
		<buginformation>
			<summary>charset parser should cater for quotes, both single and double quotes</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/issue-with-encoding-when-using-HTTP-component-td2227887.html#a2227887
I bet many systems may report charset in different ways such as

Content-Type:text/xml;charset="utf-8" 
Content-Type:text/xml;charset=&amp;amp;apos;utf-8&amp;amp;apos; 
Content-Type:text/xml;charset=utf-8 


We should ensure that we support all ways of setting this. And there may also be spaces between so we should trim and whatnot.
The code in 2.4 may have been improved. Just creating a ticket to be sure.</description>
			<version>2.3.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina.MinaProducer.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.converter.IOConverter.java</file>
			<file type="M">org.apache.camel.converter.IOConverterTest.java</file>
			<file type="M">org.apache.camel.dataformat.xstream.XStreamDataFormat.java</file>
			<file type="M">org.apache.camel.component.netty.handlers.ServerChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty.NettyProducer.java</file>
			<file type="M">org.apache.camel.processor.ConvertBodyProcessor.java</file>
			<file type="M">org.apache.camel.component.mina.MinaConsumer.java</file>
			<file type="M">org.apache.camel.component.http4.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="3011" opendate="2010-07-29 10:03:58" fixdate="2010-07-29 10:10:18" resolution="Fixed">
		<buginformation>
			<summary>Using multiple CamelContext with quartz scheduler so keep track of the individual camel contexts</summary>
			<description>The default will by default only register the first CamelContext. Which is used in non statefull jobs to lookup endpoints etc.
Instead the camel-quartz component should keep track of all the different camel contexts and use the id of the context on the job so it can lookup the context.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.quartz.QuartzTwoCamelContextRestartTest.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzConstants.java</file>
			<file type="M">org.apache.camel.component.quartz.StatefulCamelJob.java</file>
			<file type="M">org.apache.camel.component.quartz.CamelJob.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzOneCamelContextRestartTest.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzEndpoint.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="3015" opendate="2010-07-30 09:21:09" fixdate="2010-07-30 09:46:49" resolution="Fixed">
		<buginformation>
			<summary>MailConsumer - Use OnCompletion for commit/rollback</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Mail-component-velocity-and-NullpointerException-td2256742.html#a2259340
This ensure the mail message is kept and we can do commit/rollback without impact of mail message being lost during the routing</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="3008" opendate="2010-07-29 04:03:16" fixdate="2010-07-30 15:11:15" resolution="Fixed">
		<buginformation>
			<summary>Starting CamelContext with autoStartup=false should startup JMX connector</summary>
			<description>I recall some user saying something about JMX appears to not be loaded if he has autoStartup=false on the CamelContext.
It should only be the routes which are not started. The other stuff should start.
You may need to use JMX to start the routes there after </description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.spring.config.CamelContextFactoryBeanTest.java</file>
			<file type="M">org.apache.camel.spring.config.CamelContextAutoStartupTest.java</file>
			<file type="M">org.apache.camel.impl.GracefulShutdownNoAutoStartOrderClashTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContextAutoStartupTest.java</file>
			<file type="M">org.apache.camel.management.DefaultManagementAgent.java</file>
			<file type="M">org.apache.camel.impl.RouteService.java</file>
			<file type="M">org.apache.camel.processor.RouteServicesStartupOrderTest.java</file>
			<file type="M">org.apache.camel.impl.ServiceSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="3022" opendate="2010-08-03 13:52:03" fixdate="2010-08-03 14:12:56" resolution="Fixed">
		<buginformation>
			<summary>camel-cxf consumer should support take the fault message</summary>
			<description>CxfConsumer will try to cast the fault message body to a Throwable, if  the fault message body is any other message, it will cause some trouble like this.

java.lang.ClassCastException: javax.xml.transform.dom.DOMSource cannot be cast to java.lang.Throwable
at org.apache.camel.component.cxf.CxfConsumer$1.invoke(CxfConsumer.java:99)
at org.apache.cxf.interceptor.ServiceInvokerInterceptor$1.run(ServiceInvokerInterceptor.java:58)
at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)
at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)
at java.util.concurrent.FutureTask.run(FutureTask.java:138)
at org.apache.cxf.workqueue.SynchronousExecutor.execute(SynchronousExecutor.java:37)
at org.apache.cxf.interceptor.ServiceInvokerInterceptor.handleMessage(ServiceInvokerInterceptor.java:106)
at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:243)
at org.apache.cxf.transport.ChainInitiationObserver.onMessage(ChainInitiationObserver.java:110)
at org.apache.cxf.transport.http_jetty.JettyHTTPDestination.serviceRequest(JettyHTTPDestination.java:312)
at org.apache.cxf.transport.http_jetty.JettyHTTPDestination.doService(JettyHTTPDestination.java:276)
at org.apache.cxf.transport.http_jetty.JettyHTTPHandler.handle(JettyHTTPHandler.java:70)
at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:765)
at org.mortbay.jetty.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:230)
at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)
at org.mortbay.jetty.Server.handle(Server.java:322)
at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:542)
at org.mortbay.jetty.HttpConnection$RequestHandler.content(HttpConnection.java:938)
at org.mortbay.jetty.HttpParser.parseNext(HttpParser.java:755)
at org.mortbay.jetty.HttpParser.parseAvailable(HttpParser.java:218)
at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:404)
at org.mortbay.io.nio.SelectChannelEndPoint.run(SelectChannelEndPoint.java:409)
at org.mortbay.thread.QueuedThreadPool$PoolThread.run(QueuedThreadPool.java:582)

</description>
			<version>2.0.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="3007" opendate="2010-07-29 04:01:07" fixdate="2010-08-04 12:29:36" resolution="Fixed">
		<buginformation>
			<summary>Adding route from XML should honor its autoStartup flag</summary>
			<description>If a route is adding after CamelContext has been started, then it&amp;amp;apos;s autoStartup flag should be honored. In case the flag is autoStartup=false, the route should not be auto started.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.CamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.model.RouteDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="2980" opendate="2010-07-21 14:55:03" fixdate="2010-08-05 12:35:59" resolution="Fixed">
		<buginformation>
			<summary>camel-jpa doesn&amp;apos;t use EntityManager.merge(entity) in the right way</summary>
			<description>The EntityManager.merge(entity) method returns the merged entity. The exchange in message body should be updated with the merged entity (what camel-jpa currently not do).
I running into this problem, because after saving an entity in the database, the id field was still null. So, we don&amp;amp;apos;t know, which entity in the database is the corresponding to this entity... 
Have a look in the process method of JpaProducer and the Java doc from the EntityManager.
Christian</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jpa.JpaUsePersistTest.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="3036" opendate="2010-08-09 10:23:08" fixdate="2010-08-09 11:42:18" resolution="Fixed">
		<buginformation>
			<summary>camel-web seems a bit borked viewing an endpoint in tomcat</summary>
			<description>e.g. try "mvn tomcat:run" then try navigate to an endpoint to try send a message to it.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.web.model.EndpointLink.java</file>
			<file type="M">org.apache.camel.web.resources.EndpointsResource.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="depends upon">3035</link>
		</links>
	</bug>
	<bug id="3044" opendate="2010-08-11 11:52:07" fixdate="2010-08-11 12:28:50" resolution="Fixed">
		<buginformation>
			<summary>LoggingErrorHandler interfere with onException</summary>
			<description>Looks like if you have an onException to catch and handle an exception, the logging error handler may interfere and cause the message to be logged as well, which causes the onException to kick in due the logging action is also a route process. (possible endless loop)</description>
			<version>2.3.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.LoggingErrorHandlerBuilder.java</file>
			<file type="D">org.apache.camel.impl.ShutdownRouteGracefulWithTimerTest.java</file>
			<file type="M">org.apache.camel.processor.LoggingErrorHandler.java</file>
			<file type="M">org.apache.camel.processor.RedeliveryErrorHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="3040" opendate="2010-08-11 03:33:24" fixdate="2010-08-11 14:18:04" resolution="Fixed">
		<buginformation>
			<summary>The OSGiIntegrationSpringTest&amp;apos;s setup method is called twice</summary>
			<description>After checking the @Before annotation&amp;amp;apos;s java doc, you will find that the methods which are annotated with @Before will be called even it&amp;amp;apos;s in the superclasses.</description>
			<version>2.3.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.itest.osgi.OSGiIntegrationTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.OSGiIntegrationSpringTestSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="3045" opendate="2010-08-11 12:38:12" fixdate="2010-08-11 14:28:10" resolution="Fixed">
		<buginformation>
			<summary>Flatpack component : unable to set the delimiter parameter in spring config file</summary>
			<description>It&amp;amp;apos;s not possible to set the delimiter parameter in spring configuration file or I don&amp;amp;apos;t find the way to do it !
For example : 
&amp;lt;route id="routeA"&amp;gt;
   &amp;lt;from uri="file:src/test/resources/csv?move=done/&amp;amp;fileName=testfileRouteA.csv" /&amp;gt;
   &amp;lt;to uri="flatpack:delim:META-INF/Delimited.pzmap.xml?delimiter=;" /&amp;gt;
&amp;lt;/route&amp;gt;
I get the following error :
Exception in thread "main" org.apache.camel.RuntimeCamelException: org.apache.camel.FailedToCreateRouteException: Failed to create route routeA at: &amp;gt;&amp;gt;&amp;gt; To[flatpack:delim:META-INF/Delimited.pzmap.xml?ignoreFirstRecord=false&amp;amp;splitRows=true&amp;amp;delimiter=;] &amp;lt;&amp;lt;&amp;lt; in route: Route[[From[file:src/test/resources/csv?move=done/&amp;amp;fileName=... because of Failed to resolve endpoint: flatpack://delim:META-INF/Delimited.pzmap.xml?delimiter=%3B&amp;amp;ignoreFirstRecord=false&amp;amp;splitRows=true due to: Could not find a suitable setter for property: delimiter as there isn&amp;amp;apos;t a setter method with same type: java.lang.String nor type conversion possible: No type converter available to convert from type: java.lang.String to the required type: char with value ;
	at org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException(ObjectHelper.java:1126)
	at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:103)
	at org.apache.camel.spring.CamelContextFactoryBean.onApplicationEvent(CamelContextFactoryBean.java:231)
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:97)
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:303)
	at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:911)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:428)
	at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:139)
	at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:93)
	at org.apache.camel.spring.Main.createDefaultApplicationContext(Main.java:219)
	at org.apache.camel.spring.Main.doStart(Main.java:173)
	at org.apache.camel.impl.ServiceSupport.start(ServiceSupport.java:56)
	at org.apache.camel.impl.MainSupport.run(MainSupport.java:114)
	at org.apache.camel.impl.MainSupport.run(MainSupport.java:291)
	at org.apache.camel.spring.Main.main(Main.java:97)
If it&amp;amp;apos;s a bug, to solve it, it&amp;amp;apos;s just necessary to change the class org.apache.camel.component.flatpack.DelimitedEndpoint as below :

change the flied definition like this (and getter/setter to):
    private String delimiter = ",";
    private String textQualifier = "\"";


and the the method createParser like this :
    public Parser createParser(Exchange exchange) throws InvalidPayloadException, IOException 
Unknown macro: {        Reader bodyReader = ExchangeHelper.getMandatoryInBody(exchange, Reader.class);        Resource resource = getResource();        if (delimiter == null || delimiter.equals(""))        	delimiter = ",";                if (textQualifier == null || textQualifier.equals(""))        	textQualifier = """;        if (resource == null) {
            return getParserFactory().newDelimitedParser(bodyReader, delimiter.charAt(0), textQualifier.charAt(0));
        } else {
            return getParserFactory().newDelimitedParser(new InputStreamReader(resource.getInputStream()), bodyReader, delimiter.charAt(0), textQualifier.charAt(0), ignoreFirstRecord);
        }    } 

</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.ConverterTest.java</file>
			<file type="M">org.apache.camel.converter.ObjectConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="3050" opendate="2010-08-12 13:30:15" fixdate="2010-08-12 13:51:59" resolution="Fixed">
		<buginformation>
			<summary>RouteBuilderRef should work out of the box with Spring 3 and dependency injection</summary>
			<description>Spring 3 changed internally how dependency resolution works. Its now worse as we have to play tricks in the Camel namespace handler to tell Camel the various pieces you can ref, should depend on Camel. Otherwise the dependency resolution in Spring is not working properly.
This used to work like a charm in Spring 2.5.6.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.handler.CamelNamespaceHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="3049" opendate="2010-08-12 11:15:38" fixdate="2010-08-13 09:05:17" resolution="Fixed">
		<buginformation>
			<summary>Using custom global interceptor can cause routes to not entirely warmup</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Camel-2-4-InterceptStrategy-error-tp2473088p2473088.html</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.InterceptorToAsyncProcessorBridge.java</file>
		</fixedFiles>
	</bug>
	<bug id="3060" opendate="2010-08-18 13:52:41" fixdate="2010-08-19 03:47:20" resolution="Fixed">
		<buginformation>
			<summary>Out of Heap memory issues with Camel-File processing large files</summary>
			<description>Camel-File component throws heap memory issue when processing csv file which is about 45MB with 218k Lines. 
http://camel.465427.n5.nabble.com/Java-heap-space-issue-with-reading-large-CSV-file-tt2638903.html#a2638903</description>
			<version>2.3.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFileMessage.java</file>
		</fixedFiles>
	</bug>
	<bug id="3047" opendate="2010-08-11 22:33:45" fixdate="2010-08-19 09:43:32" resolution="Fixed">
		<buginformation>
			<summary>JettyHttpComponent.doStop() shuts down all servers in the VM, not just those associated with the component</summary>
			<description>We are running several bundles in Karaf with separate Camel contexts, each of which uses the camel-jetty component to expose services over HTTP.  Each bundle has an assigned port and may listen on multiple URIs.  We noticed that when we updated or shut down one of these bundles, all of the Jetty servers in the other bundles would stop listening on their respective ports.
The problem is that the map of ConnectorRef objects in JettyHttpComponent is static, and therefore shared across the entire VM.  Changing this from static to an instance variable fixed the issue for us.  </description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.SpringJettyNoConnectionTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.OSGiIntegrationTestSupport.java</file>
			<file type="M">org.apache.camel.component.jetty.SpringJettyNoConnectionRedeliveryTest.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="3069" opendate="2010-08-23 15:28:16" fixdate="2010-08-23 17:22:07" resolution="Fixed">
		<buginformation>
			<summary>JMX statistics is incomplete for processors</summary>
			<description>The statistics for routes is correct. However for processors the stats is wrong. For example ExchangesCompleted appears to be doubled.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.management.mbean.ManagedPerformanceCounter.java</file>
		</fixedFiles>
	</bug>
	<bug id="3077" opendate="2010-08-25 03:22:51" fixdate="2010-08-25 11:52:31" resolution="Fixed">
		<buginformation>
			<summary>Cache Component needs to check for null values during GET operations</summary>
			<description>EhCache often has a bit of lag time when invalidating expired cache elements, first setting the Element value to null and then removing the key. If you are hitting a cache rapidly one often will run across a key that is present in the cache that still has a null element entry.
The logic for successfully key retrieval just needs to be slightly tweaked to check for null values.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.cache.CacheBasedXPathReplacer.java</file>
			<file type="M">org.apache.camel.component.cache.CacheProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="3078" opendate="2010-08-25 03:29:07" fixdate="2010-08-25 12:10:29" resolution="Fixed">
		<buginformation>
			<summary>Cache Component configuration requires MemoryStoreEvictionPolicy instance, will not accept parameter as part of URI</summary>
			<description>In Spring, if one attempts to specify a cache endpoint as:
&amp;lt;endpoint id="myCache" uri="cache://MyCache?memoryStoreEvictionPolicy=MemoryStoreEvictionPolicy.FIFO"/&amp;gt;
an exception will be thrown that the String "MemoryStoreEvictionPolicy.FIFO" was not a proper Java Object and no TypeConverter is available. This can be worked-around by manually creating a type converter that performs:
    String policyName = evictionPolicy.replace("MemoryStoreEvictionPolicy.", "");
    return MemoryStoreEvictionPolicy.fromString(policyName);
Or one could just try to create a new instance from reflection. Above way is a bit more manageable however, since EhCache is taking care of the conversion for you.
</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cache.CacheConfiguration.java</file>
			<file type="M">org.apache.camel.component.cache.CacheConsumerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3079" opendate="2010-08-25 15:26:15" fixdate="2010-08-25 15:46:28" resolution="Fixed">
		<buginformation>
			<summary>job rescheduling and clustering does not work properly </summary>
			<description>Currently stateful cron jobs are identified by their group name, job name and the cron expression. This prevents an easy rescheduling of cron jobs. For instance, stopping a camel context, rescheduling the cron job by editing the cron expressing and restart will end up in an exception. This will happen because the rescheduled job will be added as an additional job. The already existing job will produce an exception because the corresponding endpoint doesn&amp;amp;apos;t exist anymore. The previous solution deleting all triggers on shutdown doesn&amp;amp;apos;t work in a cluster scenario. 
I suggest to identify cron jobs only by their group and job name. On startup it will check if a trigger already exists and check if the cron expression has changed. If so it will be rescheduled.
Also the current explicit resuming of stateful jobs will produce an exception during startup, because the scheduler automatically finds and resumes stored triggers. </description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.quartz.QuartzEndpoint.java</file>
			<file type="M">org.apache.camel.component.quartz.CamelJob.java</file>
			<file type="M">org.apache.camel.component.quartz.StatefulCamelJob.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="3081" opendate="2010-08-25 15:45:27" fixdate="2010-08-26 08:03:32" resolution="Fixed">
		<buginformation>
			<summary>netty timeout exception</summary>
			<description>eventhough message was received by netty procuder, it thows a timeout exception after 30 secs. here is the route and log. as this is a basic functionality I think this is critical priority.
		from("netty:tcp://localhost:6205?textline=true&amp;amp;sync=true").process(new Processor() {
		    int i=0;
			public void process(Exchange exchange) throws Exception 
{
		        String body = exchange.getIn().getBody(String.class);
				Thread.sleep(5000);
		        exchange.getOut().setBody("Bye 1" + body);
		       // if(i++%2==1) throw new IOException("custom exception");
		    }
		});
		from("file:///test/test/response")
		.convertBodyTo(String.class)
		.threads(1)
		.to(ExchangePattern.InOut,"netty:tcp://localhost:6205?textline=true&amp;amp;sync=true")
		.to("log:+++ reply++++");
2010-08-25 11:33:29,963 [1 - file:///test/test/response] FileConsumer                   DEBUG Total 1 files to consume
2010-08-25 11:33:29,963 [1 - file:///test/test/response] FileConsumer                   DEBUG About to process file: GenericFile[C:\test\test\response\hello1.txt] using exchange: Exchange[GenericFileMessage with file: GenericFile[C:\test\test\response\hello1.txt]]
2010-08-25 11:33:31,510 [      Camel Thread 6 - Threads] SendProcessor                  DEBUG &amp;gt;&amp;gt;&amp;gt;&amp;gt; Endpoint[tcp://localhost:6205] Exchange[GenericFileMessage with body: hello1]
2010-08-25 11:33:31,682 [      Camel Thread 6 - Threads] NettyProducer                  DEBUG Creating connector to address: localhost:6205
2010-08-25 11:33:31,682 [      Camel Thread 6 - Threads] NettyProducer                  DEBUG Writing body: hello1
2010-08-25 11:33:31,697 [    New I/O client worker #1-1] NettyProducer                  DEBUG Operation complete org.jboss.netty.channel.DefaultChannelFuture@944dbd
2010-08-25 11:33:31,697 [    New I/O server worker #1-1] ServerChannelHandler           DEBUG Incoming message: hello1
2010-08-25 11:33:36,697 [    New I/O server worker #1-1] ServerChannelHandler           DEBUG Writing body: Bye 1hello1
2010-08-25 11:33:36,697 [    New I/O client worker #1-1] ClientChannelHandler           DEBUG Message received: Bye 1hello1
2010-08-25 11:33:36,697 [    New I/O client worker #1-1] SendProcessor                  DEBUG &amp;gt;&amp;gt;&amp;gt;&amp;gt; Endpoint[log://+++ reply++++] Exchange[GenericFileMessage with body: Bye 1hello1]
2010-08-25 11:33:36,713 [    New I/O client worker #1-1] +++ reply++++                  INFO  Exchange[ExchangePattern:InOut, BodyType:String, Body:Bye 1hello1]
2010-08-25 11:33:36,713 [    New I/O client worker #1-1] GenericFileOnCompletion        DEBUG Done processing file: GenericFile[C:\test\test\response\hello1.txt] using exchange: Exchange[GenericFileMessage with body: Bye 1hello1]
2010-08-25 11:33:36,713 [    New I/O client worker #1-1] FileUtil                       DEBUG Tried 1 to delete file: C:\test\test\response\hello1.txt.camelLock with result: true
2010-08-25 11:33:36,713 [    New I/O client worker #1-1] nericFileRenameProcessStrategy DEBUG Renaming file: GenericFile[C:\test\test\response\hello1.txt] to: GenericFile[C:\test\test\response\.camel\hello1.txt]
2010-08-25 11:33:36,713 [    New I/O client worker #1-1] FileUtil                       DEBUG Tried 1 to rename file: C:\test\test\response\hello1.txt to: C:\test\test\response\.camel\hello1.txt with result: true
2010-08-25 11:34:06,886 [         Hashed wheel timer #1] DefaultErrorHandler            DEBUG Failed delivery for exchangeId: f5eb372d-a214-4418-a60f-62c0557768d2. On delivery attempt: 0 caught: org.apache.camel.ExchangeTimedOutException: The OUT message was not received within: 30000 millis. Exchange[GenericFileMessage with body: Bye 1hello1]
2010-08-25 11:34:06,886 [         Hashed wheel timer #1] DefaultErrorHandler            ERROR Failed delivery for exchangeId: f5eb372d-a214-4418-a60f-62c0557768d2. Exhausted after delivery attempt: 1 caught: org.apache.camel.ExchangeTimedOutException: The OUT message was not received within: 30000 millis. Exchange[GenericFileMessage with body: Bye 1hello1]
org.apache.camel.ExchangeTimedOutException: The OUT message was not received within: 30000 millis. Exchange[GenericFileMessage with body: Bye 1hello1]</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.NettyInOutWithForcedNoResponseTest.java</file>
			<file type="M">org.apache.camel.component.netty.DefaultClientPipelineFactory.java</file>
			<file type="D">org.apache.camel.component.netty.NettyExchangeTimeoutTest.java</file>
			<file type="M">org.apache.camel.component.netty.handlers.ClientChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty.NettyCustomPipelineFactorySynchTest.java</file>
			<file type="M">org.apache.camel.component.netty.NettyConfiguration.java</file>
			<file type="M">org.apache.camel.component.netty.NettyComponentWithConfigurationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3082" opendate="2010-08-26 07:00:15" fixdate="2010-08-26 12:10:01" resolution="Fixed">
		<buginformation>
			<summary>BeanConveter didn&amp;apos;t try to covert the bean invocation argument rightly</summary>
			<description>Here is the mail thread about it.
http://camel.465427.n5.nabble.com/Bug-in-the-BeanConverter-class-td2653552.html#a2653552</description>
			<version>2.0.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">3299</link>
		</links>
	</bug>
	<bug id="3084" opendate="2010-08-26 12:11:43" fixdate="2010-08-26 12:20:52" resolution="Fixed">
		<buginformation>
			<summary>camel-jms - requestTimeout with 0 or negative value should mean no timeout</summary>
			<description>This only affects the refactored camel-jms component.</description>
			<version>2.5.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.reply.CorrelationMap.java</file>
		</fixedFiles>
	</bug>
	<bug id="3091" opendate="2010-08-31 01:58:16" fixdate="2010-08-31 13:46:07" resolution="Fixed">
		<buginformation>
			<summary>QuartzEndpoint does not set the job name properly</summary>
			<description>Looks like the job.name argument is not se properly on the endpoint and defaults to the uri path.
Another nastier issue (for which I should have probably created a separate issue) is that the uri gets messed up if it does not have the double slashes after the scheme (as in "quartz:&amp;lt;uri&amp;gt;" vs "quartz://&amp;lt;uri&amp;gt;") and the @cron argument contains &amp;amp;apos;?&amp;amp;apos;. The workaround (arguably) is to start the uri with "quartz://...".
See nabble thread. Many thanks to SK for reporting this.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.URISupport.java</file>
			<file type="M">org.apache.camel.util.URISupportTest.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzEndpointConfigureTest.java</file>
			<file type="M">org.apache.camel.processor.SplitParallelTimeoutTest.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzEndpoint.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="3093" opendate="2010-08-31 19:35:11" fixdate="2010-08-31 20:47:49" resolution="Fixed">
		<buginformation>
			<summary>camel-smpp shoud honor the configured encoding</summary>
			<description>Currently camel-smpp doesn&amp;amp;apos;t honor the encoding option by creating the consumer/producer.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.smpp.SmppProducerTest.java</file>
			<file type="M">org.apache.camel.component.smpp.SmppProducer.java</file>
			<file type="M">org.apache.camel.component.smpp.SmppBinding.java</file>
			<file type="M">org.apache.camel.component.smpp.SmppBindingTest.java</file>
			<file type="M">org.apache.camel.component.smpp.SmppConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.smpp.SmppConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="3107" opendate="2010-09-06 19:06:51" fixdate="2010-09-06 19:10:36" resolution="Fixed">
		<buginformation>
			<summary>SmppBinding set the destination address npi instead of the source address npi</summary>
			<description>See discussion on the user@list</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.smpp.SmppBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="3113" opendate="2010-09-10 01:17:57" fixdate="2010-09-10 02:08:39" resolution="Fixed">
		<buginformation>
			<summary>@QueryParam doesn&amp;apos;t work for CxfBeans</summary>
			<description>Charle report an issue[1], after tracing the code I found the DefaultCxfBeanBinding doesn&amp;amp;apos;t put the http query string into the cxf message.
So the @QueryParam will not take effect on the resource beans.
[1]http://camel.465427.n5.nabble.com/camel-cxfbean-JAX-Rs-QueryParam-td2827252.html#a2827252</description>
			<version>2.2.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBean.java</file>
			<file type="M">org.apache.camel.component.cxf.feature.AbstractDataFormatFeature.java</file>
			<file type="M">org.apache.camel.component.cxf.cxfbean.DefaultCxfBeanBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.testbean.CustomerService.java</file>
			<file type="M">org.apache.camel.component.cxf.cxfbean.CxfBeanTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3118" opendate="2010-09-11 14:51:09" fixdate="2010-09-13 04:30:58" resolution="Fixed">
		<buginformation>
			<summary>camel-spring causes wrong initialization-order of dependent beans</summary>
			<description>Attached is a patch with a test that demonstrates the problem. The test uses a custom RouteBuilder (SampleIninitalizingRouteBuilder) and another bean (SampleIninitalizingBean) that both implement InitializingBean. When the beans&amp;amp;apos; afterPropertiesSet() methods are called, these beans add their names to a shared list. When the SampleIninitalizingRouteBuilder.configure() method is called then "configured" is added to the shared list.

package  org.apache.camel.spring.issues

// imports omitted ...

public class SampleInitializingBean implements InitializingBean {
    private String name;
    private List&amp;lt;String&amp;gt; entries;

    public void setName(String name) {
        this.name = name;
    }

    public void setEntries(List&amp;lt;String&amp;gt; entries) {
        this.entries = entries;
    }

    public void afterPropertiesSet() {
        entries.add(name);
    }
}

public class SampleInitializingRouteBuilder extends RouteBuilder implements InitializingBean {
    private String name;
    private List&amp;lt;String&amp;gt; entries;

    public void setName(String name) {
        this.name = name;
    }

    public void setEntries(List&amp;lt;String&amp;gt; entries) {
        this.entries = entries;
    }

    public void afterPropertiesSet() {
        entries.add(name);
    }

    @Override
    public void configure() throws Exception {
        entries.add("configured");
    }
}


These beans are wired as follows:

    &amp;lt;bean id="entries1" class="java.util.ArrayList"/&amp;gt;

    &amp;lt;bean id="sampleBean1"
          class="org.apache.camel.spring.issues.SampleInitializingBean"&amp;gt;
        &amp;lt;property name="name" value="test1a"/&amp;gt;
        &amp;lt;property name="entries" ref="entries1"/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean id="sampleRouteBuilder1"
          class="org.apache.camel.spring.issues.SampleInitializingRouteBuilder" depends-on="sampleBean1"&amp;gt;
        &amp;lt;property name="name" value="test1b"/&amp;gt;
        &amp;lt;property name="entries" ref="entries1"/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;camelContext xmlns="http://camel.apache.org/schema/spring"&amp;gt;
        &amp;lt;routeBuilder ref="sampleRouteBuilder1"/&amp;gt;
    &amp;lt;/camelContext&amp;gt;


Note the depends-on attribute on the sampleRouteBuilder1 bean: it should ensure that sampleBean1 is being initialized before sampleRouteBuilder1 and the camelContext. 
Actual behaviour, however, is that the beans are initialized in the following order:

sampleRouteBuilder1
camelContext
sampleBean1

which is definitely wrong. The shared list contains the entries

test1b
configured
test1a

This differs from the expected order

test1a
test1b
configured

which cannot be observed. After some debugging, it seems the problem is related to the CamelBeanPostProcessor.postProcessBeforeInitialization() method. It does a lookup of the camelContext (i.e. applicationContext.getBean(camelId))) before the application context finished initialization of dependent beans. The problem is that this lookup already triggers a SampleInitializingRouteBuilder.configure() method call.
Even worse, this behaviour depends on the declaration order of the beans in the application context XML file. When the camelContext bean is moved to the top, the bean initialization are done in the correct order.
To demonstrate that this is not a Spring-related problem, the attached test also contains another bean (SampleRouteBuilderContainer) that plays the role of the camelContext but does nothing else than calling configure() on the injected route builder within (afterPropertiesSet()). In this case, the bean initialization occur in the expected, correct order.
I didn&amp;amp;apos;t find a solution to this problem so far and need to dig in further (hope to find some time next week for that). If any of the committers (who are more familiar with camel-spring than I am) have already an idea how to solve that, I appreciate any hints.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.handler.CamelNamespaceHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="3121" opendate="2010-09-14 11:39:12" fixdate="2010-09-14 12:00:54" resolution="Fixed">
		<buginformation>
			<summary>Splitter EIP - The sub exchanges should not contains on completions from original Exchange</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Camel-calling-commit-too-early-when-using-split-seda-file-endpoint-tp2830894p2830894.html</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.Splitter.java</file>
			<file type="M">org.apache.camel.processor.SplitterStreamingUoWIssueTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3108" opendate="2010-09-07 08:50:58" fixdate="2010-09-14 14:19:10" resolution="Fixed">
		<buginformation>
			<summary>ConsumerTemplate return body should complete UoW beforehand</summary>
			<description>Issue is discussed here: http://camel.465427.n5.nabble.com/ConsumerTemplate-not-finishing-td2642233.html#a2642233</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.impl.DefaultExchange.java</file>
			<file type="M">org.apache.camel.impl.DefaultConsumerTemplate.java</file>
			<file type="M">org.apache.camel.impl.DefaultUnitOfWork.java</file>
		</fixedFiles>
	</bug>
	<bug id="3128" opendate="2010-09-16 13:41:23" fixdate="2010-09-16 14:13:16" resolution="Fixed">
		<buginformation>
			<summary>Using $ in endpoint uri causes thread name parser to fail</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/How-to-specify-route-to-folder-with-in-actual-name-tp2839895p2839895.html</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultExecutorServiceStrategyTest.java</file>
			<file type="M">org.apache.camel.util.concurrent.ExecutorServiceHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="3130" opendate="2010-09-16 16:33:12" fixdate="2010-09-16 17:28:41" resolution="Fixed">
		<buginformation>
			<summary>Ref component causes consumer parameters to be cleared, such as delay and initialDelay</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/The-delay-option-seems-not-to-be-working-in-CAMEL-Java-DSL-mode-tp2840369p2840369.html</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultComponent.java</file>
			<file type="M">org.apache.camel.component.xslt.XsltOutputStringTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3124" opendate="2010-09-14 13:59:43" fixdate="2010-09-17 11:27:06" resolution="Fixed">
		<buginformation>
			<summary>polling of feeds in FeedEntryPollingConsumer is broken.</summary>
			<description>The FeedEntryPollingConsumer class implements the poll() method for the &amp;amp;apos;splitEntries&amp;amp;apos; mode of the RssEndpoint is broken.
You can think of two ways that polling feeds could work:
1) A feed is created, then one item is processed, then the delay, then process another item. This way the feed is kept between calls to poll().
2) A feed is created, then all the items are processed, the feed is cleared, and then the delay.
But the way it presently works:
A feed is created, one items is processed, and the feed is cleared, then the delay, and again the feed is created and the next item is cleared.
This is clearly wrong. Feed entries can be missed, because the index of the next item to process is stored over polls but the list isn&amp;amp;apos;t. Also this creates a big network overhead when polling very active feeds such as twitter search...
This is easy to fix. In the below code:

public void poll() throws Exception {
        Object feed = createFeed();
        populateList(feed);   

        while (hasNextEntry()) {
            Object entry = list.get(entryIndex--);

            boolean valid = true;
            if (entryFilter != null) {
                valid = entryFilter.isValidEntry(endpoint, feed, entry);
            }
            if (valid) {
                Exchange exchange = endpoint.createExchange(feed, entry);
                getProcessor().process(exchange);
                // return and wait for the next poll to continue from last time (this consumer is stateful)
                return;
            }
        }


The return (at line 56 of org.apache.camel.component.feed.FeedEntryPollingConsumer) should be deleted.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.feed.FeedEntryPollingConsumer.java</file>
			<file type="M">org.apache.camel.component.atom.AtomEntryPollingConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="3114" opendate="2010-09-10 10:53:24" fixdate="2010-09-19 07:59:19" resolution="Fixed">
		<buginformation>
			<summary>url encoding goes wrong in org.apache.camel.component.rss.RssComponent#afterConfiguration</summary>
			<description>The method org.apache.camel.component.rss.RssComponent#afterConfiguration creates the Url that will be used to fetch the rss feed. We find that with some url&amp;amp;apos;s url encoding goes wrong.
consider this url: http://api.flickr.com/services/feeds/photos_public.gne?id=23353282@N05&amp;amp;tags=lowlands&amp;amp;lang=en-us&amp;amp;format=rss_200
AfterConfiguration() calls org.apache.camel.util.URISupport#createRemainingURI This method first calls org.apache.camel.util.URISupport#createQueryString, which is a method that will iterate over a map of request parameters, escape each param name and value using java.net.URLEncoder#encode, and put them together with all the &amp;amp; and = stuff to form the query string.
Then it calls org.apache.camel.util.URISupport#createURIWithQuery Which is a method that takes a URI (the base url) and the constructed query string, and simply creates a new URI with that, returning the toString() output from that.
So this is what the output of this procedure looks like: http://api.flickr.com/services/feeds/photos_public.gne?format=rss_200&amp;amp;id=23353282%2540N05&amp;amp;lang=en-us&amp;amp;tags=lowlands
1 the @ sign was escaped by org.apache.camel.util.URISupport#createQueryString, creating a query string like: id=23353282%40N05&amp;amp;tags=lowlands&amp;amp;lang=en-us&amp;amp;format=rss_200 (which is good)
2 the URI constructor then finds the % in %40 and escapes that again! creating a url like: http://api.flickr.com/services/feeds/photos_public.gne?format=rss_200&amp;amp;id=23353282%2540N05&amp;amp;lang=en-us&amp;amp;tags=lowlands 
Which predictably fails...
I did some tests with the URI constructor, and it seems it only escapes % chars, everything else is left alone.
I attach a groovy script that demonstrates the problem
regards,
Ernst Bunders</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rss.RssComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="3136" opendate="2010-09-19 13:18:14" fixdate="2010-09-19 15:47:29" resolution="Fixed">
		<buginformation>
			<summary>cxfbean creates another instance of the class instead of directly using the referenced bean</summary>
			<description>... this makes it impossible to inject properties to the @WebService class
&amp;lt;camelContext&amp;gt;
        &amp;lt;route&amp;gt;
            &amp;lt;from uri="...." /&amp;gt;
            &amp;lt;to uri="cxfbean:handler" /&amp;gt;
        &amp;lt;/route&amp;gt;
&amp;lt;/camelContext&amp;gt;
&amp;lt;bean id="handler" class="a.b.c.Handler"&amp;gt;
        &amp;lt;property name="prop1" value="5" /&amp;gt;
&amp;lt;/bean&amp;gt;
when "handler" is created by Spring, its &amp;amp;apos;prop1&amp;amp;apos; is set to &amp;amp;apos;5&amp;amp;apos;
when the cxfbean:handler is triggered, the &amp;amp;apos;prop1&amp;amp;apos; is null, because CXF created another instance of Handler instead of using the one created by Spring</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.cxfbean.CxfBeanEndpoint.java</file>
			<file type="M">org.apache.camel.wsdl_first.PersonImplWithWsdl.java</file>
		</fixedFiles>
	</bug>
	<bug id="3137" opendate="2010-09-20 07:01:00" fixdate="2010-09-20 07:21:03" resolution="Fixed">
		<buginformation>
			<summary>ftp login anonymous should send empty string as password instead of null parameter</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/anonymous-FTP-login-fails-tp2846235p2846235.html</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="3141" opendate="2010-09-21 12:31:10" fixdate="2010-09-21 14:17:44" resolution="Fixed">
		<buginformation>
			<summary>Route autoStartup configurable through Property</summary>
			<description>Using Camel 2.4 I want to make the usage of a certain route configurable through properties. 

&amp;lt;camelContext id="camel" trace="true"
	xmlns="http://camel.apache.org/schema/spring"&amp;gt;
	
	&amp;lt;route id="configurable_1" autoStartup="{{startup_1}}"&amp;gt;
		&amp;lt;from uri="direct:start_1"/&amp;gt;
		&amp;lt;to uri="mock:end_1"/&amp;gt;
	&amp;lt;/route&amp;gt;
		
	&amp;lt;route id="configurable_2" autoStartup="{{startup_2}}"&amp;gt;
		&amp;lt;from uri="direct:start_2"/&amp;gt;
		&amp;lt;to uri="mock:end_2"/&amp;gt;
	&amp;lt;/route&amp;gt;

&amp;lt;/camelContext&amp;gt;


But if I do use the PropertyPlaceholder on the CamelContext like below it works. 

&amp;lt;camelContext id="camel" trace="true" autoStartup="{{startup_context}}"


So is this a bug or should this work this way?</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.model.RouteDefinitionHelper.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaConsumer.java</file>
			<file type="M">org.apache.camel.spring.scan.DefaultPackageScanClassResolverTest.java</file>
			<file type="M">org.apache.camel.core.xml.AbstractCamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.model.RouteDefinition.java</file>
			<file type="M">org.apache.camel.impl.ActiveMQUuidGeneratorTest.java</file>
			<file type="M">org.apache.camel.util.CamelContextHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="3144" opendate="2010-09-21 19:59:32" fixdate="2010-09-22 06:22:40" resolution="Fixed">
		<buginformation>
			<summary>camel-ftp: fileExist=Fail not honored when producer works in FTP root path</summary>
			<description>when using a route with ftp producer such as :
 &amp;lt;to uri="ftp://user@host/?fileExist=Fail&amp;amp;fileName=test&amp;amp;password=mypass" /&amp;gt;
The route will not correctly fail if the fileName already exists.
It will work in any sub-directory:
 &amp;lt;to uri="ftp://user@host/mydir?fileExist=Fail&amp;amp;fileName=test&amp;amp;password=mypass" /&amp;gt;
The root cause of the bug is an incorrect test in org.apache.camel.util.FileUtil.onlyPath() in component camel-core.
This method returns null when the parameter string is "/". It should return "/".
The attached patch fixes the issue.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFile.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFile.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpOperations.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpOperations.java</file>
			<file type="M">org.apache.camel.util.FileUtilTest.java</file>
			<file type="M">org.apache.camel.util.FileUtil.java</file>
		</fixedFiles>
	</bug>
	<bug id="2743" opendate="2010-05-20 13:46:50" fixdate="2010-09-22 08:33:00" resolution="Fixed">
		<buginformation>
			<summary>HttpProducer should not sending the Http headers with low case</summary>
			<description>Here is the mail thread which discusses about it.
http://old.nabble.com/camel-http-converts-headers-to-lower-case-tp28620717p28620717.html</description>
			<version>2.0.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.DefaultHttpBinding.java</file>
			<file type="M">org.apache.camel.component.jetty.DefaultJettyHttpBinding.java</file>
			<file type="M">org.apache.camel.component.http4.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="3143" opendate="2010-09-21 19:40:01" fixdate="2010-09-22 09:40:42" resolution="Fixed">
		<buginformation>
			<summary>OsgiDefaultCamelContext.getTypeConverterRegistry() returns null </summary>
			<description>The showed up when using dozer as shown in http://camel.apache.org/dozer-type-conversion.html, whose DozerTypeConverterLoader tries to get the type converter registry using: {{
{TypeConverterRegistry registry = camelContext.getTypeConverterRegistry();}
}}
Plausible error:
OsgiDefaultCamelContext.java
   @Override
    protected TypeConverter createTypeConverter() {
        return new OsgiTypeConverter(bundleContext, getInjector());
    }


DefaultCamelContext.java
public TypeConverterRegistry getTypeConverterRegistry() {
        if (typeConverterRegistry == null) {
            // init type converter as its lazy
            if (typeConverter == null) {
                getTypeConverter();
            }
            // type converter is usually the default one that also is the registry
            if (typeConverter instanceof DefaultTypeConverter) {
                typeConverterRegistry = (DefaultTypeConverter) typeConverter;
            }
        }
        return typeConverterRegistry;
    }


Error:
getTypeConverter() returns an OsgiTypeConverter 
OsgiTypeConverter does not inherit from DefaultTypeConverter, thus the instanceof returns false
=&amp;gt; null is returned
Solution:
Lots of different ways to do this, and it&amp;amp;apos;s getting late here. In this case, maybe it&amp;amp;apos;s OsgiDefaultCamelContext&amp;amp;apos;s responsibility to also override getTypeConverterRegistry with something along the lines of:

@Override
public TypeConverterRegistry getTypeConverterRegistry() {
        if (typeConverterRegistry == null) {
            // init type converter as its lazy
            if (typeConverter == null) {
                getTypeConverter();
            }
            // type converter is usually the default one that also is the registry
            if (typeConverter instanceof OsgiDefaultTypeConverter) {
                typeConverterRegistry = ((OsgiDefaultTypeConverter) typeConverter).getRegistry();
            }
        }
        return typeConverterRegistry;
    }


We&amp;amp;apos;ve employed an (ugly) workaround in a local version of DozerTypeConverterLoader.java:

        TypeConverter typeConverter = camelContext.getTypeConverter();
        DefaultTypeConverter registry = null;
        if (typeConverter instanceof DefaultTypeConverter) {
            registry = (DefaultTypeConverter)typeConverter;
        } else if (typeConverter instanceof OsgiTypeConverter) {
            OsgiTypeConverter osgiTypeConverter = (OsgiTypeConverter)typeConverter;
            registry = osgiTypeConverter.getRegistry();
        }

</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.converter.dozer.model.Address.java</file>
			<file type="M">org.apache.camel.converter.dozer.DozerTypeConverterTest.java</file>
			<file type="M">org.apache.camel.core.osgi.OsgiTypeConverter.java</file>
			<file type="M">org.apache.camel.converter.dozer.model.Customer.java</file>
			<file type="M">org.apache.camel.converter.dozer.DozerTypeConverterLoader.java</file>
			<file type="M">org.apache.camel.converter.dozer.SpringDozerTypeConverterTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3158" opendate="2010-09-25 12:18:09" fixdate="2010-09-26 06:06:21" resolution="Fixed">
		<buginformation>
			<summary>PollingConsumerSupport.start() do not get called</summary>
			<description>I have a subclass of PollingConsumerSupport and create it in a subclass of DefaultPollingEndpoint. The problem is that DefaultPollingEndpoint wraps PollingConsumer into DefaultScheduledPollConsumer and the latter does not call PollingConsumerSupport.start:
DefaultScheduledPollConsumer.java:
    @Override
    protected void doStart() throws Exception 
{
        pollingConsumer = getEndpoint().createPollingConsumer();
        super.doStart();
    }</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultScheduledPollConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="3170" opendate="2010-09-28 11:54:26" fixdate="2010-09-28 12:01:27" resolution="Fixed">
		<buginformation>
			<summary>camel-ftp - Setting password and username using UserInfo on uri does not work</summary>
			<description>You should be able to set ftp endpoint uri as:

"ftp://scott@localhost:" + getPort() + "/deletefile?password=tiger&amp;amp;binary=false&amp;amp;delete=true"


And when using password and username in the userinfo part of the uri:

"ftp://tiger:scott@localhost:" + getPort() + "/deletefile?binary=false&amp;amp;delete=true"


The latter didn&amp;amp;apos;t work</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileConfiguration.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpToBinarySampleTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.FromFtpDeleteFileTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3174" opendate="2010-09-29 06:38:12" fixdate="2010-09-29 09:46:02" resolution="Fixed">
		<buginformation>
			<summary>camel-ftp - Change dir before retrieving file</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/How-to-change-directory-while-using-sftp-component-tp2806817p2806817.html</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.sftp.SftpServerTestSupport.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpSimpleConsumeAbsoluteTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpOperations.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpOperations.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumer.java</file>
			<file type="M">org.apache.camel.util.FileUtil.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpConsumer.java</file>
			<file type="M">org.apache.camel.util.FileUtilTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.sftp.SftpSimpleConsumeAbsoluteTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFile.java</file>
			<file type="M">org.apache.camel.component.file.FileOperations.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileOperations.java</file>
			<file type="M">org.apache.camel.component.file.strategy.GenericFileDeleteProcessStrategyTest.java</file>
			<file type="M">org.apache.camel.component.file.GenericFile.java</file>
		</fixedFiles>
	</bug>
	<bug id="3185" opendate="2010-10-01 08:24:36" fixdate="2010-10-01 08:35:07" resolution="Fixed">
		<buginformation>
			<summary>restlet producer - Should set status code</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Restlet-HTTP-status-and-message-tp3047023p3047023.html</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.DefaultRestletBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="3187" opendate="2010-10-01 12:51:56" fixdate="2010-10-01 13:16:32" resolution="Fixed">
		<buginformation>
			<summary>PublishEventNotifier - Should not emit events during startup/shutdown and not spawn new events when processing event</summary>
			<description>When an event is being send to an endpoint using PublishEventNotifier it may create new events, and so forth. This causes a flood of events.
Also further complications occur during start/shutdown of Camel when you send events to routes, which are then being graceful shutdown. Therefore this event notifier should only publish if camel is fully started and running.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.util.EventHelper.java</file>
			<file type="M">org.apache.camel.management.PublishEventNotifierTest.java</file>
			<file type="M">org.apache.camel.management.PublishEventNotifier.java</file>
		</fixedFiles>
	</bug>
	<bug id="3188" opendate="2010-10-01 20:21:02" fixdate="2010-10-02 15:16:43" resolution="Fixed">
		<buginformation>
			<summary>Concurrent consumers on seda endpoint can cause content routing to mismatch</summary>
			<description>When consuming concurrently from a seda endpoint, when the route contains a content router based on the header, it will randomly route through the wrong choice.
In my specific case, I was consuming from an activemq queue, which would receive messages with a header that would then determine which route it would follow. It would randomly send messages down the wrong path. When I turned on tracing, it would behave itself. It also behaved itself when I limited it to only a single consumer. I was, however, able to duplicate it with the unit test below. Due to the concurrency issue, the test can occasionally pass, but run it a couple times and it should fail. It&amp;amp;apos;ll either receive 2 messages when it should have only gotten 1, or it will get no messages when it should have gotten 1.
ConcurrencyTest.java
import org.apache.camel.EndpointInject;
import org.apache.camel.Produce;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.test.CamelTestSupport;

public class ConcurrencyTest extends CamelTestSupport {

	@EndpointInject(uri = "mock:result")
	protected MockEndpoint resultEndpoint;
	
	@EndpointInject(uri = "mock:otherResult")
	protected MockEndpoint otherResultEndpoint;

	@Produce(uri = "seda:start")
	protected ProducerTemplate template;

	public void testSendMatchingMessage() throws Exception {
		String expectedBody = "&amp;lt;matched/&amp;gt;";
		
		resultEndpoint.expectedBodiesReceived(expectedBody);
		otherResultEndpoint.expectedBodiesReceived(expectedBody);

		template.sendBodyAndHeader(expectedBody, "myDirection", "send");
		template.sendBodyAndHeader(expectedBody, "myDirection", "received");

		resultEndpoint.assertIsSatisfied();
	}

	@Override
    protected RouteBuilder createRouteBuilder() {
        return new RouteBuilder() {
            public void configure() {
                from("seda:start?concurrentConsumers=10")
//                from("seda:start?concurrentConsumers=1")
                	.choice()
                		.when(header("myDirection").isEqualTo("send")).to("mock:result")
                		.when(header("myDirection").isEqualTo("received")).to("mock:otherResult");
            }
        };
    }
}

</description>
			<version>2.3.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.BinaryPredicate.java</file>
			<file type="M">org.apache.camel.processor.ChoiceProcessor.java</file>
			<file type="M">org.apache.camel.builder.BinaryPredicateSupport.java</file>
			<file type="M">org.apache.camel.builder.PredicateBuilderTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3193" opendate="2010-10-04 06:24:15" fixdate="2010-10-05 12:54:48" resolution="Fixed">
		<buginformation>
			<summary>request/reply over JMS using temporary queues - if connection lost the temporary queue is not re-created which causes the producer to not work anymore</summary>
			<description>To recreate the problem you need a route with a jms inout endpoint that is configured to use a temporary destination for replies. Till now I was only able to show the problem with tibco ems.

Start broker
Start the jms consumer that replies to the request
Start the route
Send a request/reoply exchange (should work)
Stop the broker
Wait long enough for the client to do a full reconnect (I used connectionFactory.setReconnAttemptCount(1) on the client so I do not have to wait so long)
Start the broker -&amp;gt; The jms component will do a full new connect
Send a request/reoply exchange -&amp;gt; Now a InvalidDestination Exception happens

The client route will not work anymore until a restart as it creates the temporary destination only once and it is invalid now.
</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.reply.TemporaryQueueReplyManager.java</file>
		</fixedFiles>
	</bug>
	<bug id="3199" opendate="2010-10-05 15:57:34" fixdate="2010-10-06 03:55:02" resolution="Fixed">
		<buginformation>
			<summary>Allow : and , inside quoted names for addresses</summary>
			<description>"Snell, Tracy" &amp;lt;tjs@juicelabs.com&amp;gt; breaks with the current address parsing.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailMultipleRecipientsTest.java</file>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="3198" opendate="2010-10-05 15:29:01" fixdate="2010-10-07 06:02:02" resolution="Fixed">
		<buginformation>
			<summary> DefaultCamelContext throws NPE in getRoute(String id)</summary>
			<description> DefaultCamelContext throws NPE in getRoute(String id) if no routes are deployed.
This happens because the "route LinkedHashSet" is not initialized.
Fix:
 don&amp;amp;apos;t do Lazy init of route  or add this to getRoute(String id):
 if (routes == null) 
{
	routes = new LinkedHashSet&amp;lt;Route&amp;gt;();
 }
 
</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContextTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3201" opendate="2010-10-06 12:59:02" fixdate="2010-10-07 06:07:02" resolution="Fixed">
		<buginformation>
			<summary>The CxfConsumer&amp;apos;s getContinuation method might throw NPE</summary>
			<description>Hello
When trying the latest CAMEL 2.5.0 SNAPSHOT, I got a NPE:

java.lang.NullPointerException
       at org.apache.camel.component.cxf.CxfConsumer$1.getContinuation(CxfConsumer.java:129)
       at org.apache.camel.component.cxf.CxfConsumer$1.invoke(CxfConsumer.java:65)
       at org.apache.cxf.interceptor.ServiceInvokerInterceptor$1.run(ServiceInvokerInterceptor.java:58)
       at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)
       at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)
...

</description>
			<version>2.5.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="3203" opendate="2010-10-06 14:48:07" fixdate="2010-10-07 15:17:29" resolution="Fixed">
		<buginformation>
			<summary>Quartz routes are not started if quartz component is referenced after context was started</summary>
			<description>Quartz routes are not active if added after camel context was already started.
Here is an elaborate description of the problem and a sample project that reproduces it: http://anydoby.com/jblog/en/java/1955
Sorry, no patch this time because I may not know enough about the internals of QuartzComponent, hesitate to offer anything but a boolean flag somewhere.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.quartz.QuartzComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="3216" opendate="2010-10-11 15:25:12" fixdate="2010-10-11 15:57:59" resolution="Fixed">
		<buginformation>
			<summary>ScheduledPollConsumer should avoid runnable thread to die to ensure its kept being scheduled</summary>
			<description>scheduled consumers such as file / ftp uses ScheduledPollConsumer to poll. If a throwable is thrown then the thread may die due it throws that to the JDK.
We should avoid this and ensure to catch all exceptions, otherwise the thread may die, and the JDK will not re-schedule a new thread.
This cause it to stop polling.
See
http://fusesource.com/forums/thread.jspa?threadID=2320&amp;amp;tstart=0</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.ScheduledPollConsumer.java</file>
			<file type="M">org.apache.camel.component.file.FileConsumerPollStrategyRollbackThrowExceptionTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3219" opendate="2010-10-12 05:23:29" fixdate="2010-10-12 05:54:36" resolution="Fixed">
		<buginformation>
			<summary>Bindy should not trim separate in case end users use tab separators or the likes</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Big-problem-with-csv-tab-separator-file-and-bindy-data-format-tp3207520p3207520.html</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindySimpleCsvMarshallTest.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindySimpleCsvUnmarshallPositionModifiedTest.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindySimpleCsvMarshallPositionModifiedTest.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindyPojoSimpleCsvMarshallTest.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindyCsvDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindySimpleCsvUnmarshallTest.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.kvp.BindyKeyValuePairDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.fixed.BindyFixedLengthDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="3220" opendate="2010-10-12 06:43:10" fixdate="2010-10-12 07:14:35" resolution="Fixed">
		<buginformation>
			<summary>Threads - Should allow using 0 in core pool size</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/ThreadPoolExecutor-configuration-tp3207845p3207845.html</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.ThreadsZeroInCoreAndMaxPoolTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultExecutorServiceStrategy.java</file>
			<file type="M">org.apache.camel.model.ThreadsDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="3231" opendate="2010-10-13 14:34:23" fixdate="2010-10-14 19:39:36" resolution="Fixed">
		<buginformation>
			<summary>JMX MBeans not registered for initiators</summary>
			<description>registering the Initiator before it has been started will not register the sessions mbeans with JMX. So the acceptors are ther, but no initiators.</description>
			<version>2.5.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.quickfixj.QuickfixjEngine.java</file>
			<file type="M">org.apache.camel.component.quickfixj.QuickfixjEngineTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3223" opendate="2010-10-12 14:41:54" fixdate="2010-10-14 20:09:20" resolution="Fixed">
		<buginformation>
			<summary>GenericFileProducer.writeFile method creates instance of un-used InputStream</summary>
			<description>org.apache.camel.component.file.GenericFileProducer
Method: writeFile
This method has the following statement:
InputStream payload = exchange.getIn().getBody(InputStream.class);
This internally results in calling a TypeConverter to convert an object into InputStream type. However this InputStream has not been used and is eventually closed in the finally block. 
In the same method calling method storeFile on FileOperations (boolean success = operations.storeFile(fileName, exchange) also opens an InputStream on the same message.</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFileProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="3249" opendate="2010-10-18 23:19:41" fixdate="2010-10-21 17:52:45" resolution="Fixed">
		<buginformation>
			<summary>HawtDB file grows indefinitely over time</summary>
			<description>When using an aggregator with the HawtDB persistent store, the file grows indefinitely until it fills the volume on which it&amp;amp;apos;s stored. This prevents the persistence from being used in any kind of long-running production deployment.</description>
			<version>2.3.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.hawtdb.HawtDBGrowIssueTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3276" opendate="2010-10-25 15:05:42" fixdate="2010-10-26 06:35:05" resolution="Fixed">
		<buginformation>
			<summary>Multicast with pipeline may cause wrong aggregated exchange</summary>
			<description>This is a problem when using 2 set of nested pipeline and doing a transform as the first processor in that pipeline

                from("direct:start").multicast(new SumAggregateBean())
                    .pipeline().transform(bean(IncreaseOne.class)).bean(new IncreaseTwo()).to("log:foo").end()
                    .pipeline().transform(bean(IncreaseOne.class)).bean(new IncreaseTwo()).to("log:bar").end()
                .end()
                .to("mock:result");


</description>
			<version>2.4.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.camel.component.jdbc.JdbcPreserveHeadersTest.java</file>
			<file type="M">org.apache.camel.component.seda.SedaWaitForTaskCompleteTest.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
			<file type="M">org.apache.camel.converter.crypto.HMACAccumulatorTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultProducerTemplateAsyncTest.java</file>
			<file type="M">org.apache.camel.component.amqp.AMQPRouteTest.java</file>
			<file type="M">org.apache.camel.component.vm.VmWaitForTaskCompleteTest.java</file>
			<file type="M">org.apache.camel.converter.crypto.CryptoDataFormatTest.java</file>
			<file type="M">org.apache.camel.component.crypto.SignatureTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="3277" opendate="2010-10-25 19:46:50" fixdate="2010-10-26 06:42:29" resolution="Fixed">
		<buginformation>
			<summary>Threading issue which lets converter loading abort</summary>
			<description>The type converter loading is not threadsafe and fails sometimes. That will end up with around 17 type converters loaded only which will probably let your camel routes fail with conversion errors like:

07:04:31,112 | ERROR | qtp25205731-2783 | DefaultErrorHandler | rg.apache.camel.processor.Logger 248 | 68 - org.apache.camel.camel-core - 2.4.0.fuse-00-00 | Failed delivery for exchangeId: 53e23457-5551-4487-9fc4-87dd33687f0b. Exhausted after delivery attempt: 1 caught: java.lang.ClassCastException: org.apache.camel.converter.stream.InputStreamCache cannot be cast to org.w3c.dom.Node
java.lang.ClassCastException: org.apache.camel.converter.stream.InputStreamCache cannot be cast to org.w3c.dom.Node
at com.sun.org.apache.xpath.internal.jaxp.XPathExpressionImpl.eval(XPathExpressionImpl.java:116)[:1.6.0_17]
at com.sun.org.apache.xpath.internal.jaxp.XPathExpressionImpl.eval(XPathExpressionImpl.java:98)[:1.6.0_17]
at com.sun.org.apache.xpath.internal.jaxp.XPathExpressionImpl.evaluate(XPathExpressionImpl.java:180)[:1.6.0_17]
at org.apache.camel.builder.xml.XPathBuilder.doInEvaluateAs(XPathBuilder.java:598)[68:org.apache.camel.camel-core:2.4.0.fuse-00-00]
at org.apache.camel.builder.xml.XPathBuilder.evaluateAs(XPathBuilder.java:570)[68:org.apache.camel.camel-core:2.4.0.fuse-00-00]
at org.apache.camel.builder.xml.XPathBuilder.matches(XPathBuilder.java:122)[68:org.apache.camel.camel-core:2.4.0.fuse-00-00]


Tracking the issue down showed that several type converter loaders share the same registry object and fail to load all converters every once a while. That can be fixed by making the load method synchronized...see attached patch.</description>
			<version>2.4.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.osgi.Activator.java</file>
		</fixedFiles>
	</bug>
	<bug id="3281" opendate="2010-10-27 06:28:17" fixdate="2010-10-27 11:38:23" resolution="Fixed">
		<buginformation>
			<summary>RouteBuilder - Let if fail if end user is configuring onException etc after routes</summary>
			<description>All such cross cutting concerns must be defined before routes.
We should throw an exception if end user has configured them after routes, which is currently not supported in the DSL.</description>
			<version>2.4.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina.MinaTcpWithIoOutProcessorExceptionTest.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilder.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilderAddRoutesTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3286" opendate="2010-10-28 04:20:52" fixdate="2010-10-29 07:57:21" resolution="Fixed">
		<buginformation>
			<summary>camel-jms - Setting TaskExecutor should support both Spring 2.5 and 3.0</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/camel-2-4-with-spring-2-5-6-TaskExecutor-issue-tp3237897p3237897.html
We need to use reflection when invoking setTaskExecutor on the spring JMS stuff.
Because at compile time it would be linked to the Spring 3.0 method signature.
And in Spring 2.5 the method signature is different.
Using reflection should allow us to support both cases. And this is only done on startup so no runtime overhead.</description>
			<version>2.4.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsConfiguration.java</file>
			<file type="M">org.apache.camel.component.jms.reply.TemporaryQueueReplyManager.java</file>
			<file type="M">org.apache.camel.component.jms.CamelJmsTestHelper.java</file>
			<file type="M">org.apache.camel.component.jms.JmsConsumer.java</file>
			<file type="M">org.apache.camel.component.jms.JmsEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.JmsRequestReplyProcessRepliesConcurrentUsingThreadsTest.java</file>
			<file type="M">org.apache.camel.component.jms.reply.PersistentQueueReplyManager.java</file>
			<file type="M">org.apache.camel.component.jms.JmsComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="3269" opendate="2010-10-23 16:18:12" fixdate="2010-11-01 05:58:10" resolution="Fixed">
		<buginformation>
			<summary>CXF CamelTransport and "Can&amp;apos;t find input stream in message"</summary>
			<description>When using a JaxWS proxy with camel transport, to a route with only one processor, CXF fail with the message "Can&amp;amp;apos;t find input stream in message".
CamelConduit call CxfMessageHelper.getCxfInMessage which is looking for an Out part in the exchange. If the processor of the route doesn&amp;amp;apos;t use the Out message, or doesn&amp;amp;apos;t copy the in part to the out part (like the Pipeline processor), the call to the JaxWS proxy fail with "Can&amp;amp;apos;t find input stream in message"</description>
			<version>2.4.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.util.CxfMessageHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="3299" opendate="2010-11-02 00:12:36" fixdate="2010-11-02 03:18:36" resolution="Fixed">
		<buginformation>
			<summary>BeanInvocation handling LinkedHashMap cannot be converted to java.util.Map</summary>
			<description>I&amp;amp;apos;m calling a Camel proxy and passing it a single argument of type LinkedHashMap.
On the service side I&amp;amp;apos;m waiting for a java.util.Map, so the converter BeanInvocation -&amp;gt; java.util.Map is called.
Finally it comes to BeanConverter:convertTo with type=java.util.Map and value class=BeanInvocation
then it goes to
            // maybe from is already the type we want
            if (from.isAssignableFrom(type)) 
{
                return body;
            }
where from=LinkedHashMap
and... the condition is false!
The LinkedHashMap is not assignable from java.util.Map,
but java.util.Map is assignable from LinkedHashMap and, I guess, that is what we want.
Please fix?

if (from.isAssignableFrom(type)) {
+ if (type.isAssignableFrom(from)) {

</description>
			<version>2.4.0</version>
			<fixedVersion>2.5.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">3082</link>
		</links>
	</bug>
	<bug id="2452" opendate="2010-02-06 13:56:38" fixdate="2010-11-03 22:04:04" resolution="Fixed">
		<buginformation>
			<summary>HttpHeaderFilterStrategy dosn&amp;apos;t filters out &amp;apos;Cache-Control&amp;apos;, &amp;apos;Connection&amp;apos;, &amp;apos;Pragma&amp;apos;, &amp;apos;Trailer&amp;apos;, &amp;apos;Transfer-Encoding&amp;apos;, &amp;apos;Upgrade&amp;apos;, &amp;apos;Via&amp;apos; and &amp;apos;Warning&amp;apos; in method applyFilterToCamelHeaders</summary>
			<description>HttpHeaderFilterStrategy uses the HTTP headers with upper case characters on the beginning (e. g. &amp;amp;apos;Transfer-Encoding&amp;amp;apos; instead of &amp;amp;apos;transfer-encoding&amp;amp;apos;).</description>
			<version>2.1.0</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.HttpHeaderFilterStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="3302" opendate="2010-11-02 12:02:50" fixdate="2010-11-04 07:50:59" resolution="Fixed">
		<buginformation>
			<summary>OsgiPackageScanClassResolver should have Non-OSGi classloader check fallback</summary>
			<description>This is necessary when use JBI packaging for servicemix-camel ServiceUnit  so that we get chance to use SU classloader to scan packages in the ServiceUnit</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.core.osgi.CamelMockBundle.java</file>
			<file type="M">org.apache.camel.core.osgi.OsgiPackageScanClassResolver.java</file>
			<file type="M">org.apache.camel.core.osgi.OsgiPackageScanClassResolverTest.java</file>
		</fixedFiles>
		<links>
			<link type="Regression" description="breaks">3442</link>
		</links>
	</bug>
	<bug id="3314" opendate="2010-11-05 13:29:34" fixdate="2010-11-05 14:03:11" resolution="Fixed">
		<buginformation>
			<summary>Property resolve in EIP does not work when in a sub route.</summary>
			<description>The 2.5 feature: "The EIP now supports property placeholders in the String based options (a few spots in Java DSL where its not possible). For example: 
&amp;lt;convertBodyTo type="String" charset="foo.myCharset"/&amp;gt;" does not work correctly when ie nested in a &amp;lt;choice&amp;gt; tag.
See discussion: http://camel.465427.n5.nabble.com/Camel-2-5-Propertyplaceholders-and-Spring-DSL-still-not-working-td3251608.html#a3251608
Example route:
This works: 
&amp;lt;route&amp;gt; 
        &amp;lt;from uri="direct:in" /&amp;gt; 
        &amp;lt;convertBodyTo type="String" charset="charset.external" /&amp;gt;	
        &amp;lt;log message="Charset: charset.external" /&amp;gt; 
        &amp;lt;to uri="mock:out" /&amp;gt; 
&amp;lt;/route&amp;gt; 
This fails: 
&amp;lt;route&amp;gt; 
        &amp;lt;from uri="direct:in" /&amp;gt; 
        &amp;lt;choice&amp;gt; 
                &amp;lt;when&amp;gt; 
                        &amp;lt;constant&amp;gt;true&amp;lt;/constant&amp;gt; 
                        &amp;lt;convertBodyTo type="String" charset="charset.external" /&amp;gt;	
                &amp;lt;/when&amp;gt; 
        &amp;lt;/choice&amp;gt; 
        &amp;lt;to uri="mock:out" /&amp;gt; 
&amp;lt;/route&amp;gt; </description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="3319" opendate="2010-11-07 04:23:55" fixdate="2010-11-08 00:24:35" resolution="Fixed">
		<buginformation>
			<summary>cxfEndpoint of camel-cxf doesn&amp;apos;t support  the shcemaLocation element</summary>
			<description>Here is the mail thread[1] which discusses about it.
[1]http://camel.465427.n5.nabble.com/camel-cxf-exception-when-parsing-cxf-schemaLocation-element-td3253254.html#a3253254</description>
			<version>2.0.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsSpringEndpointTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfRsClientFactoryBeanDefinitionParser.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfRsClientFactoryBeanTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfRsServerFactoryBeanDefinitionParser.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfRsServerFactoryBeanTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.NamespaceHandler.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSpringRouterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBeanTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBean.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBeanWithBusTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3321" opendate="2010-11-08 11:29:11" fixdate="2010-11-08 23:29:19" resolution="Fixed">
		<buginformation>
			<summary>SmppBinding raises NullPointerException when an SMSC insert the Short Message Data inside the message_payload field</summary>
			<description>When an SMSC sends the DeliverSm with the short message data inside the message_payload field (in the OptionalParameter) the method
createSmppMessage(DeliverSm deliverSm) in the SmppBinding class raises a nullPointerException at the following line:
else {
            smppMessage.setBody(String.valueOf(new String(deliverSm.getShortMessage(),  
this happen because deliverySm.getShortMessage return null
</description>
			<version>2.4.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.smpp.SmppBindingTest.java</file>
			<file type="M">org.apache.camel.component.smpp.SmppBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="3237" opendate="2010-10-15 16:01:15" fixdate="2010-11-11 11:58:51" resolution="Fixed">
		<buginformation>
			<summary>XmppEndPoint - setting login to false when creating an account results in no action</summary>
			<description>
XmppEndPoint myXmppEndPoint = new XmppEndPoint();
(...)
myXmppEndPoint.setCreateAccount(true);
myXmppEndPoint .setLogin(false);
(...)


This will result in "no action" in xmpp server, if setLogin true the account is created and the user stays online.
I believe it&amp;amp;apos;s because of the logic used in createConnection() method of XmppEndPoint that could be changed to:

if (!connection.isAuthenticated()) {
            if (user != null) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug("Logging in to XMPP as user: " + user + " on connection: " + getConnectionMessage(connection));
                }
                if (password == null) {
                    LOG.warn("No password configured for user: " + user + " on connection: " + getConnectionMessage(connection));
                }

                if (createAccount) {
                    AccountManager accountManager = new AccountManager(connection);
                    accountManager.createAccount(user, password);
                }
                if(login){
                	if (resource != null) {
                		connection.login(user, password, resource);
                	} else {
                		connection.login(user, password);
                	}
                }
            } else {
                if (LOG.isDebugEnabled()) {
                    LOG.debug("Logging in anonymously to XMPP on connection: "  + getConnectionMessage(connection));
                }
                connection.loginAnonymously();
            }


</description>
			<version>2.4.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xmpp.XmppEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="3328" opendate="2010-11-11 14:25:35" fixdate="2010-11-11 17:15:20" resolution="Fixed">
		<buginformation>
			<summary>NPE on Request-Reply InOut (Test attached)</summary>
			<description>simply request reply with ActiveMQ 5.4.1 using a queue is failing in v2.5 instead is running in v.2.4

 
import static org.junit.Assert.assertTrue;

import org.apache.activemq.ActiveMQConnectionFactory;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.ExchangePattern;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.jms.JmsComponent;
import org.apache.camel.impl.DefaultCamelContext;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class RequestReplyFailureTest
{
	private Endpoint			endpoint;
	private Producer			producer;
	private DefaultCamelContext	camel;

	@Before
	public void before() throws Exception
	{
		String brokerUrl = "tcp://localhost:61616";
		camel = new DefaultCamelContext();
		camel.addComponent("jms", JmsComponent.jmsComponentAutoAcknowledge(new ActiveMQConnectionFactory(brokerUrl)));

		final String url = "jms:queue:test";
		endpoint = camel.getEndpoint(url);

		camel.addRoutes(new RouteBuilder()
		{
			@Override
			public void configure() throws Exception
			{
				from(url).process(new Processor()
				{
					@Override
					public void process(Exchange exchange) throws Exception
					{
						// simply set &amp;amp;apos;pong&amp;amp;apos; as response
						exchange.getOut().setBody("pong");
					}
				});
			}
		});

		System.out.println(camel.getVersion());
		camel.start();

		producer = endpoint.createProducer();
	}

	@After
	public void after() throws Exception
	{
		camel.stop();
	}

	/**
	 * @throws Exception
	 */
	@Test
	public void testInOut() throws Exception
	{
		Exchange exchange = endpoint.createExchange(ExchangePattern.InOut);
		exchange.getIn().setBody("ping");
		producer.process(exchange);

		assertTrue("pong".equals(exchange.getOut().getBody()));
	}

 </description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="3334" opendate="2010-11-12 08:48:47" fixdate="2010-11-12 09:32:54" resolution="Fixed">
		<buginformation>
			<summary>BeanShell Expressions Don&amp;apos;t Work</summary>
			<description>BeanShell 2.0b5 has the JSR-223 integration, but it implements Compilable, when in fact it throws an exception if you call compile.
Camel calls compile for any language that implements Compilable, therefore you get an exception every time your route has BeanShell in it.
I notice the BeanShell tests are commented-out in camel-script.
Also, the Camel Wiki page for BeanShell is stupendously vague on actual usage.</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.script.BeanShellScriptRouteTest.java</file>
			<file type="M">org.apache.camel.builder.script.ScriptBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="3335" opendate="2010-11-12 09:12:54" fixdate="2010-11-12 10:07:55" resolution="Fixed">
		<buginformation>
			<summary>NPE occurs without @Entity annotation</summary>
			<description>Here is code from the org.apache.camel.component.jpa.JpaConsumer class
protected String getEntityName(Class&amp;lt;?&amp;gt; clazz) {
    Entity entity = clazz.getAnnotation(Entity.class);
    // Check if the property name has been defined for Entity annotation
    if (!entity.name().equals("")) 
{ // line 307
        return entity.name();
    }
 else 
{
        return null;
    }

}
When trying to consume entities from jpa endpoint exception occurs
java.lang.NullPointerException
	at org.apache.camel.component.jpa.JpaConsumer.getEntityName(JpaConsumer.java:307)
	at org.apache.camel.component.jpa.JpaConsumer.createQueryFactory(JpaConsumer.java:287)
	at org.apache.camel.component.jpa.JpaConsumer.getQueryFactory(JpaConsumer.java:196)
	at org.apache.camel.component.jpa.JpaConsumer$1.doInJpa(JpaConsumer.java:83)
	at org.apache.camel.component.jpa.JpaTemplateTransactionStrategy$1$1.doInJpa(JpaTemplateTransactionStrategy.java:82)
	at org.springframework.orm.jpa.JpaTemplate.execute(JpaTemplate.java:183)
	at org.springframework.orm.jpa.JpaTemplate.execute(JpaTemplate.java:146)
	at org.apache.camel.component.jpa.JpaTemplateTransactionStrategy$1.doInTransaction(JpaTemplateTransactionStrategy.java:80)
	at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:130)
	at org.apache.camel.component.jpa.JpaTemplateTransactionStrategy.execute(JpaTemplateTransactionStrategy.java:78)
	at org.apache.camel.component.jpa.JpaConsumer.poll(JpaConsumer.java:79)
	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:98)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441)
	at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:317)
	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:150)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$101(ScheduledThreadPoolExecutor.java:98)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.runPeriodic(ScheduledThreadPoolExecutor.java:181)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:205)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:619)
This is because there is no @Entity annotation and persistence is configured by means of orm.xml.
To fix the problem change line 307 to
if (entity != null &amp;amp;&amp;amp; !entity.name().equals(""))</description>
			<version>2.4.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jpa.JpaConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="3333" opendate="2010-11-12 08:30:47" fixdate="2010-11-13 13:44:05" resolution="Fixed">
		<buginformation>
			<summary>Nested multicast in splitter EIP and issue with UseOriginalAggregationStrategy</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Multicast-inside-splitter-tp3261288p3261288.html</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.Splitter.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="3343" opendate="2010-11-17 21:16:22" fixdate="2010-11-18 08:37:14" resolution="Fixed">
		<buginformation>
			<summary>CxfRsInvoker produces NullpointerException when no ContinuationProvider is set in the InMessage</summary>
			<description>In my usage of CXF-RS with Camel through the camel-cxf component I ran into a NullpointerException, the specific case is described in some detail on StackOverflow: http://stackoverflow.com/questions/4198461/why-do-i-get-a-nullpointerexception-when-invoking-the-cxf-rs-endpoint-of-a-camel 
Specifically I run into a NullpointerException:

Caused by: java.lang.NullPointerException
        at org.apache.camel.component.cxf.jaxrs.CxfRsInvoker.getContinuation(CxfRsInvoker.java:63)
        at org.apache.camel.component.cxf.jaxrs.CxfRsInvoker.performInvocation(CxfRsInvoker.java:52)
        at org.apache.cxf.service.invoker.AbstractInvoker.invoke(AbstractInvoker.java:89)
        ... 33 more


I was assuming I was misconfiguring something but didn&amp;amp;apos;t find any alternative way so I started digging in the camel-cxf source code.
I found that such a "getContinuation" method also exists for the org.apache.camel.component.cxf.CxfConsumer as well as for the CxfRsInvoker (where it was failing for me). However in the case of the CxfConsumer there is a guard on the ContinuationProvider so that if it is null, then null is returned:

return provider == null ? null : provider.getContinuation();


CxfRsInvoker does not have this guard, but it does have code to deal with a "null" Continuation at the calling site (line 52, in performInvocation). Therefore I assumed this was a bug and patched the guard into the CxfRsInvoker as well.
My program now seems to work correctly. I assume this is a bug.
For completeness sake, this is what getContinuation now looks like for me:

    private Continuation getContinuation(Exchange cxfExchange) {
        ContinuationProvider provider = 
            (ContinuationProvider)cxfExchange.getInMessage().get(ContinuationProvider.class.getName());
        return provider == null ? null : provider.getContinuation();
    }

</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsInvoker.java</file>
		</fixedFiles>
	</bug>
	<bug id="3306" opendate="2010-11-03 16:33:38" fixdate="2010-11-18 08:41:02" resolution="Fixed">
		<buginformation>
			<summary>Transfer-Encoding chunking implementation leaves a loop hole for error</summary>
			<description>The description of this issue is at [1].
[1] http://camel.465427.n5.nabble.com/CXF-http-conduit-AllowChunking-does-not-work-td3247495.html#a3248727</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfHeaderFilterStrategy.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducerProtocalHeaderTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3341" opendate="2010-11-17 12:01:27" fixdate="2010-11-18 08:46:10" resolution="Fixed">
		<buginformation>
			<summary>ProxyHelper and JMS component - need to start producer or fails with NPE</summary>
			<description>
I&amp;amp;apos;ve a very simple unit test (based on http://camel.apache.org/using-camelproxy.html) that works fine when using endpoint uri "direct:start" but fails with the following exception when using "activemq:somequeue"
java.lang.NullPointerException
	at org.apache.camel.component.jms.JmsProducer.processInOut(JmsProducer.java:140)
	at org.apache.camel.component.jms.JmsProducer.process(JmsProducer.java:90)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:91)
	at org.apache.camel.impl.DefaultAsyncProducer.process(DefaultAsyncProducer.java:37)
	at org.apache.camel.component.bean.CamelInvocationHandler.invoke(CamelInvocationHandler.java:65)
	at $Proxy7.sayWordTo(Unknown Source)
	at net.earcam.cdosgi.remoteserviceadmin.CamelProxyTest.simpleArgTest(CamelProxyTest.java:93)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:49)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)
Looks like the problem is simply that the producer isn&amp;amp;apos;t started so never creates a UuidGenerator (needed for the JMS Reply-To)
org.apache.camel.component.bean.ProxyHelper - lines 45 - 51, needs to start producer (for JmsProducer)
    /**

Creates a Proxy which sends PojoExchange to the endpoint.
     */
    @SuppressWarnings("unchecked")
    public static &amp;lt;T&amp;gt; T createProxy(Endpoint endpoint, ClassLoader cl, Class[] interfaces, MethodInfoCache methodCache) throws Exception 
{
        return (T) createProxyObject(endpoint, endpoint.createProducer(), cl, interfaces, methodCache);
    }

As a workaround, simply create the producer, start it and use the overloaded method createProxy that takes a producer parameter.</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.ProxyHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="3344" opendate="2010-11-18 05:48:39" fixdate="2010-11-18 10:11:34" resolution="Fixed">
		<buginformation>
			<summary>RedeliveryPolicy does not honor MaximumRedeliveryDelay</summary>
			<description>When using exponential retry back-off with a maximumRedeliveryDelay, the delay is not honored.
The bug is in RedeliveryPolicy.java&amp;amp;apos;s calculateRedeliveryDelay method:
        if (maximumRedeliveryDelay &amp;gt; 0 &amp;amp;&amp;amp; redeliveryDelay &amp;gt; maximumRedeliveryDelay) 
{
            redeliveryDelayResult = maximumRedeliveryDelay;
        }

redeliveryDelay is the initial delay and never increases, so the max is never applied. It needs to compare against redeliveryDelayResult instead.</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.RedeliveryPolicy.java</file>
		</fixedFiles>
	</bug>
	<bug id="3349" opendate="2010-11-19 22:32:35" fixdate="2010-11-19 22:57:34" resolution="Fixed">
		<buginformation>
			<summary>Race condition found in CxfRsEndpoint while getting the endpoint binding under load and performing sync and async invocation</summary>
			<description>The CxfRsEndpoint&amp;amp;apos;s getBinding method is not thread safe. At a customer site, I ran into an issue at startup if 2 threads raced to perform sync and async invocation, the code for getBinding (given below) would react in the following way.

Thread 1 would proceed to create a binding object
Thread 2 would mean while still find the  binding to be null and proceed to create a new binding
Meanwhile thread one would have its binding and set the Atomic boolean for binding initialized and proceed to set the HeaderStrategy.
Thread 2 meanwhile would overwrite the original binding object and find that Atomic boolean already set and would have no way to associate a HeaderFilterStrategy object since the flag is up.
In the absence of a HeaderFilterStrategy, copying of ProtocolHeaders etc will throw exceptions on every following request/invocation.

--------------------------------------------------
    public CxfRsBinding getBinding() {
        if (binding == null) {
            binding = new DefaultCxfRsBinding();
            if (LOG.isDebugEnabled()) 
{
                LOG.debug("Create default CXF Binding " + binding);
            }
        } 
        if (!bindingInitialized.getAndSet(true) &amp;amp;&amp;amp; binding instanceof HeaderFilterStrategyAware) 
{
            ((HeaderFilterStrategyAware)binding).setHeaderFilterStrategy(getHeaderFilterStrategy());
        }

        return binding;
    }
------------------------------------------------</description>
			<version>2.2.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="3348" opendate="2010-11-19 22:02:04" fixdate="2010-11-22 10:39:01" resolution="Fixed">
		<buginformation>
			<summary>DefaultShutdownStrategy and ShutdownAware (SedaConsumer) losing exchange</summary>
			<description>There&amp;amp;apos;s a problem when we shutdown the camel context with a seda endpoint.
In the SedaConsumer, the exchange is removed from the queue and then, later, is added to the InflightRepository as shown in the following code (I put comments where it is done):

public void run() {
        BlockingQueue&amp;lt;Exchange&amp;gt; queue = endpoint.getQueue();
        while (queue != null &amp;amp;&amp;amp; isRunAllowed()) {
            final Exchange exchange;
            try {
                exchange = queue.poll(1000, TimeUnit.MILLISECONDS); // The exchange is removed here from the queue
            } catch (InterruptedException e) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped()));
                }
                continue;
            }
            if (exchange != null) {
                if (isRunAllowed()) {
                    try {
                        sendToConsumers(exchange); // Call to sendToConsumers detailed below

                        if (exchange.getException() != null) {
                            getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException());
                        }
                    } catch (Exception e) {
                        getExceptionHandler().handleException("Error processing exchange", exchange, e);
                    }
                } else {
                    if (LOG.isWarnEnabled()) {
                        LOG.warn("This consumer is stopped during polling an exchange, so putting it back on the seda queue: " + exchange);
                    }
                    try {
                        queue.put(exchange);
                    } catch (InterruptedException e) {
                        if (LOG.isDebugEnabled()) {
                            LOG.debug("Sleep interrupted, are we stopping? " + (isStopping() || isStopped()));
                        }
                        continue;
                    }
                }
            }
        }
    }

    protected void sendToConsumers(Exchange exchange) throws Exception {
        int size = endpoint.getConsumers().size();

        if (size &amp;gt; 1) {

            if (LOG.isDebugEnabled()) {
                LOG.debug("Multicasting to " + endpoint.getConsumers().size() + " consumers for Exchange: " + exchange);
            }
           
            MulticastProcessor mp = endpoint.getConumserMulticastProcessor();

            AsyncProcessorHelper.process(mp, exchange, new AsyncCallback() {
                public void done(boolean doneSync) {
                }
            });
        } else {
            AsyncProcessorHelper.process(processor, exchange, new AsyncCallback() { // This line will create the UnitOfWork (in UnitOfWorkProcessor) which will put the exchange in the InflightRepository
                public void done(boolean doneSync) {

                }
            });
        }
    }


If the shutdown occurs between these two actions, the DefaultShutdownStrategy will shutdown the route even if there is a message in progress. And the message will be lost.
Here is the code of ShutdownTask in DefaultShutdownStrategy which cause the shutdown even if there is some messages still in progress. (I put comments in it to show the state of the seda queue and InflightRepository if it is called between the queue.poll() and the InflightRepository.add())

for (Consumer consumer : order.getInputs()) {
                        int inflight = context.getInflightRepository().size(consumer.getEndpoint()); // check the number of inflight exchanges which is 0 because the UnitOfWork is not created

                        if (consumer instanceof ShutdownAware) {
                            inflight += ((ShutdownAware) consumer).getPendingExchangesSize(); // check the number of exchange in the seda queue which is 0 because the message is already removed
                        }
                        if (inflight &amp;gt; 0) {
                            size += inflight;
                            if (LOG.isDebugEnabled()) {
                                LOG.debug(inflight + " inflight and pending exchanges for consumer: " + consumer);
                            }
                        }
                    }


You can reproduce it by putting a breakpoint in the method 

protected void sendToConsumers(Exchange exchange)

 in SedaConsumer and calling stop() on the CamelContext while the thread is suspended by the breakpoint.
We caught the problem in a unit test where we were testing the shutdown and when our test server was under heavy load.</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.ibatis.IBatisPollingConsumer.java</file>
			<file type="M">org.apache.camel.component.seda.SedaProducer.java</file>
			<file type="M">org.apache.camel.component.seda.SedaConsumer.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
			<file type="M">org.apache.camel.component.direct.DirectConsumer.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaConsumer.java</file>
			<file type="M">org.apache.camel.component.mail.MailConsumer.java</file>
			<file type="M">org.apache.camel.spi.ShutdownAware.java</file>
			<file type="M">org.apache.camel.impl.DefaultShutdownStrategy.java</file>
			<file type="M">org.apache.camel.processor.ShutdownDeferTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3355" opendate="2010-11-23 09:15:04" fixdate="2010-11-23 12:00:55" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentModifictionException on UoW done, when under heavy load</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Errors-when-under-load-tp3276259p3276259.html</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.UnitOfWorkHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="3356" opendate="2010-11-23 20:39:12" fixdate="2010-11-24 05:16:02" resolution="Fixed">
		<buginformation>
			<summary>Hard coded locale in Bindy DatePatternFormat</summary>
			<description>As reported by a user from the community (http://camel.465427.n5.nabble.com/Bindy-Dateformat-Parsing-exception-td3276981.html), the locale of SimpeDateFormat in bindy&amp;amp;apos;s DatePatternFormat class is hard coded to FRANCE.</description>
			<version>2.6.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.bindy.FormatFactory.java</file>
			<file type="M">org.apache.camel.model.dataformat.BindyDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyKeyValuePairFactory.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.format.LongPatternFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.format.IntegerPatternFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.format.DatePatternFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.format.FloatPatternFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.format.NumberPatternFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindyCsvDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.format.DoublePatternFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyFixedLengthFactory.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyAbstractFactory.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.kvp.BindyKeyValuePairDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.format.ShortPatternFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyCsvFactory.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.format.BytePatternFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="3352" opendate="2010-11-22 13:58:06" fixdate="2010-11-24 14:05:40" resolution="Fixed">
		<buginformation>
			<summary>Multicast with UseLatestAggregationStrategy fails to propagated exceptions which has been handled by onException</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Multicast-Behaviour-with-Exceptions-tp3270272p3270272.html</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
			<file type="M">org.apache.camel.model.SplitDefinition.java</file>
			<file type="M">org.apache.camel.model.RecipientListDefinition.java</file>
			<file type="M">org.apache.camel.processor.PipelineHelper.java</file>
			<file type="M">org.apache.camel.model.MulticastDefinition.java</file>
			<file type="M">org.apache.camel.processor.aggregate.UseLatestAggregationStrategy.java</file>
			<file type="M">org.apache.camel.processor.Pipeline.java</file>
			<file type="M">org.apache.camel.impl.InterceptSendToEndpoint.java</file>
			<file type="M">org.apache.camel.processor.RoutingSlip.java</file>
		</fixedFiles>
	</bug>
	<bug id="3373" opendate="2010-11-28 13:23:00" fixdate="2010-11-28 13:24:53" resolution="Fixed">
		<buginformation>
			<summary>markRollbackOnlyLast should remove caused exception to avoid it affecting outer transaction</summary>
			<description>The markRollbackOnlyLast() should remove any caused exception because it should not affect outer transactions.
</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.interceptor.MixedTransactionPropagationTest.java</file>
			<file type="M">org.apache.camel.spring.spi.TransactionErrorHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="3377" opendate="2010-11-29 09:40:03" fixdate="2010-11-29 10:29:58" resolution="Fixed">
		<buginformation>
			<summary>spring-integration - Should have better configuration validation</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Integration-camel-and-spring-integration-tp3284105p3284105.html</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelTargetAdapter.java</file>
			<file type="M">org.apache.camel.component.spring.integration.HelloWorldService.java</file>
			<file type="D">org.apache.camel.component.spring.integration.adapter.config.CamelSourceAdpaterParser.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.AbstractCamelAdapter.java</file>
			<file type="D">org.apache.camel.component.spring.integration.SpringIntegrationHelper.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationOneWayConsumerTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.config.CamelTargetAdapterParser.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationComponent.java</file>
			<file type="M">org.apache.camel.component.spring.integration.converter.SpringIntegrationConverter.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationProducer.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationChannelConverterTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationConsumer.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.config.NamespaceHandler.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationBinding.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelSourceAdapter.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationEndpoint.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationTwoWayConsumerTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationMessage.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.config.AbstractCamelContextBeanDefinitionParaser.java</file>
		</fixedFiles>
	</bug>
	<bug id="3388" opendate="2010-12-04 22:32:09" fixdate="2010-12-05 10:46:00" resolution="Fixed">
		<buginformation>
			<summary>@OutHeaders in bean binding issue with InOnly MEP</summary>
			<description>When you invoke a bean with a method signature like this in Camel 2.5.0/HEAD, the in and out message both are null (the "Hello!" value just disappears):


    public String doTest(@Body Object body, @Headers Map headers, @OutHeaders Map outHeaders) {
        return "Hello!";
    }


The same thing without the headers works OK:


    public String doTest(@Body Object body) {
        return "Hello!";
    }


See camel-core/src/test/java/org/apache/camel/component/bean/BeanWithHeadersAndBodyInject3Test.java</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanWithHeadersAndBodyInject3Test.java</file>
			<file type="M">org.apache.camel.builder.ExpressionBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="3389" opendate="2010-12-05 09:04:35" fixdate="2010-12-05 10:57:32" resolution="Fixed">
		<buginformation>
			<summary>PackageHelper - issue with version numbers which contains non decimal</summary>
			<description>See more here
http://fusesource.com/forums/thread.jspa?threadID=2447&amp;amp;tstart=0</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.PackageHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="3394" opendate="2010-12-06 12:59:58" fixdate="2010-12-06 14:20:58" resolution="Fixed">
		<buginformation>
			<summary>Splitter and Multicast EIP marks exchange as exhausted to early if exception was thrown from an evaluation</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Cannot-handle-Exception-thrown-from-Splitter-Expression-tp3286043p3286043.html</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="3395" opendate="2010-12-06 15:02:27" fixdate="2010-12-06 15:29:08" resolution="Fixed">
		<buginformation>
			<summary>Splitter - Exchange.CORRELATION_ID should point back to parent Exchange id</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Splitted-exchange-has-incorrect-correlation-ID-tp3289354p3289354.html</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.Splitter.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="3271" opendate="2010-10-24 08:02:37" fixdate="2010-12-06 20:29:36" resolution="Fixed">
		<buginformation>
			<summary>packageScan does not work with camel-blueprint</summary>
			<description>Using the following xml code does not activate the Java Camel routes that can be found in the given package;
&amp;lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"&amp;gt;
	&amp;lt;camelContext xmlns="http://camel.apache.org/schema/blueprint"&amp;gt;
		&amp;lt;packageScan&amp;gt;
			&amp;lt;package&amp;gt;eu.schuring.camel.blueprint.route&amp;lt;/package&amp;gt;
		&amp;lt;/packageScan&amp;gt;
	&amp;lt;/camelContext&amp;gt;
&amp;lt;/blueprint&amp;gt;
Attached is a usecase that should output messages from both a native blueprint DSL route and a Java DSL route activated by the xml section above. I&amp;amp;apos;ve attached both the bundle and a source jar.</description>
			<version>2.4.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.blueprint.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.OSGiBlueprintTestSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="3295" opendate="2010-10-30 05:02:36" fixdate="2010-12-07 14:57:38" resolution="Fixed">
		<buginformation>
			<summary>camel-blueprint - Dependency Injection seems not working</summary>
			<description>This is just a placeholder - things like this should work.

&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
           xmlns:cm="http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.0.0"
           xmlns:ext="http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0
            http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd"&amp;gt;


    &amp;lt;camelContext xmlns="http://camel.apache.org/schema/blueprint" id="camelBlueprint"&amp;gt;
        &amp;lt;route&amp;gt;
            &amp;lt;from uri="jms:queue"/&amp;gt;
            &amp;lt;to uri="mock:result"/&amp;gt;
        &amp;lt;/route&amp;gt;
    &amp;lt;/camelContext&amp;gt;

    &amp;lt;bean id="jms" class="org.apache.camel.component.jms.JmsComponent"&amp;gt;
        &amp;lt;property name="connectionFactory" ref="jmsConnectionPool"/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;reference id="jmsConnectionPool" interface="javax.jms.ConnectionFactory"/&amp;gt;

&amp;lt;/blueprint&amp;gt;


Currently the jmsConnectionPool is not at all passed to the JmsComponent.
The usage of JmsTemplate as debated on the mailinglists I think is of a (currently) much lesser concern.
Especially comparing a little to the ProducerCode in the servicemix-jms components.</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.blueprint.BlueprintComponentResolver.java</file>
			<file type="M">org.apache.camel.blueprint.BlueprintContainerRegistry.java</file>
			<file type="M">org.apache.camel.blueprint.handler.CamelNamespaceHandler.java</file>
			<file type="M">org.apache.camel.blueprint.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.OSGiBlueprintTestSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="3390" opendate="2010-12-05 09:40:53" fixdate="2010-12-07 16:35:04" resolution="Fixed">
		<buginformation>
			<summary>routeBuilder ref not working in camel 2.5.0</summary>
			<description> I amended the camel-example-osgi project so as to use the Java RouteBuilder, the MyRouteBuilder class in that project
I changed the blueprint.xml file to the following
	&amp;lt;bean id="routeBuilder" class="org.apache.camel.example.osgi.MyRouteBuilder" /&amp;gt;
	&amp;lt;camelContext xmlns="http://camel.apache.org/schema/blueprint"&amp;gt;
			&amp;lt;routeBuilder ref="routeBuilder"/&amp;gt;
	&amp;lt;/camelContext&amp;gt;
However nothing happens, no error message is displayed either.
If I leave the example in its original state, in other words using the xml-based dsl, then it works.
Maybe this is somehow related to the fact that packageScan does not work???
Regards 
Ivanhoe
</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.itest.osgi.blueprint.OSGiBlueprintTestSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="3351" opendate="2010-11-21 13:54:04" fixdate="2010-12-08 06:54:35" resolution="Fixed">
		<buginformation>
			<summary>camel-irc component silently fails on nick collision</summary>
			<description>When the camel-irc component connects to an irc server and there&amp;amp;apos;s a nick collision it silently fails. Also note there is no camel-irc component in Jira.</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.irc.IrcConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.irc.IrcConfiguration.java</file>
			<file type="M">org.apache.camel.component.irc.IrcEndpoint.java</file>
			<file type="M">org.apache.camel.component.irc.IrcConsumer.java</file>
			<file type="M">org.apache.camel.component.irc.IrcComponent.java</file>
			<file type="M">org.apache.camel.component.irc.IrcProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="3403" opendate="2010-12-08 07:44:26" fixdate="2010-12-08 08:16:10" resolution="Fixed">
		<buginformation>
			<summary>InterceptSendToEndpoint should check for if stop DSL has been used</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/InterceptSendToEndpoint-Http-Component-tp3296620p3296620.html</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mock.MockEndpoint.java</file>
			<file type="M">org.apache.camel.spi.ManagementAware.java</file>
			<file type="M">org.apache.camel.processor.PipelineHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="3186" opendate="2010-10-01 12:42:08" fixdate="2010-12-08 13:28:02" resolution="Fixed">
		<buginformation>
			<summary>@EndpointInject not working in bean created by blueprint</summary>
			<description>I am attaching a small test project that uses blueprint to create a camel context and a bean named Producer.  This project builds an OSGi bundle that I am deploying in FUSE ESB 4.3.0-fuse-01-00.  The Producer bean has an @EndpointInject annotation on a ProducerTemplate:
	@EndpointInject(ref = "testEndpoint")
	private ProducerTemplate testEndpoint;
The Producer bean&amp;amp;apos;s init method sets a timer that tries to call testEndpoint.sendBody() once per second.  This throws a null pointer exception because the testEndpoint did not get injected:
07:35:31,826 | WARN  | Producer         | Producer                         | org.aaron.camel.Producer           51 | 118 - org.aaron.camel - 1.0.0.SNAPSHOT | send exception
java.lang.NullPointerException
        at org.aaron.camel.Producer.timerPop(Producer.java:48)[118:org.aaron.camel:1.0.0.SNAPSHOT]
        at org.aaron.camel.Producer.access$000(Producer.java:11)[118:org.aaron.camel:1.0.0.SNAPSHOT]
        at org.aaron.camel.Producer$1.run(Producer.java:29)[118:org.aaron.camel:1.0.0.SNAPSHOT]
        at java.util.TimerThread.mainLoop(Timer.java:512)[:1.6.0_21]
        at java.util.TimerThread.run(Timer.java:462)[:1.6.0_21]
This same test works perfectly if I use Spring DM to create the camel context and Producer bean.</description>
			<version>2.4.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.CamelBeanPostProcessor.java</file>
			<file type="M">org.apache.camel.core.xml.AbstractCamelFactoryBean.java</file>
			<file type="M">org.apache.camel.blueprint.BlueprintContainerRegistry.java</file>
			<file type="M">org.apache.camel.blueprint.handler.CamelNamespaceHandler.java</file>
			<file type="M">org.apache.camel.core.xml.AbstractCamelEndpointFactoryBean.java</file>
			<file type="M">org.apache.camel.core.xml.AbstractCamelThreadPoolFactoryBean.java</file>
			<file type="M">org.apache.camel.core.xml.AbstractCamelProducerTemplateFactoryBean.java</file>
			<file type="M">org.apache.camel.core.xml.AbstractCamelConsumerTemplateFactoryBean.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.OSGiBlueprintTestSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="3419" opendate="2010-12-09 12:00:28" fixdate="2010-12-09 13:10:28" resolution="Fixed">
		<buginformation>
			<summary>timestamp property in JpaTraceEventMessage does not specify a temporal type</summary>
			<description>The timestamp property in the JpaTraceEventMessage does not specify a temporal type. This results in an exception using EclipseLink 2.1.0 (and maybe using other JPA frameworks, too). 
Using the annotation  @Temporal(TemporalType.TIMESTAMP) on timestamp should solve this issue.</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.interceptor.jpa.JpaTraceEventMessage.java</file>
		</fixedFiles>
	</bug>
	<bug id="3428" opendate="2010-12-14 21:05:44" fixdate="2010-12-15 00:05:20" resolution="Fixed">
		<buginformation>
			<summary>DefaultCamelContext.getEndpoint(String name, Class&lt;T&gt; endpointType) throws Nullpointer for unknown endpoint</summary>
			<description>The method getEndpoint throws an NullPointerException when it&amp;amp;apos;s called with an unknown endpoint name:
java.lang.NullPointerException
	at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:480)
	at org.apache.camel.impl.DefaultCamelContextTest.testGetEndPointByTypeUnknown(DefaultCamelContextTest.java:95)
The patch is attached.</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.processor.DeadLetterChannelBuilderWithInvalidDeadLetterUriTest.java</file>
			<file type="M">org.apache.camel.NoSuchEndpointException.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContextTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3426" opendate="2010-12-14 14:02:32" fixdate="2010-12-15 07:38:32" resolution="Fixed">
		<buginformation>
			<summary>CxfProducer doesn&amp;apos;t callback.done when the operation is oneway.</summary>
			<description>There is a mail thread[1] describes the whole story.
[1]http://camel.465427.n5.nabble.com/file-to-oneway-cxf-service-scenario-does-not-work-with-camel-2-5-0-td3303263.html</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.itest.greeter.GreeterImpl.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="3430" opendate="2010-12-15 08:05:50" fixdate="2010-12-15 08:39:32" resolution="Fixed">
		<buginformation>
			<summary>InterceptSendToEndpoint has issues with interception http endpoints which has multiple parameters</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/interceptSendToEndpoint-with-dynamic-endpoint-tp3301978p3301978.html
The issue is when any endpoints have parameters which may be re-ordered when the endpoint is normalized.</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.management.JmxInstrumentationCustomMBeanTest.java</file>
		</fixedFiles>
		<links>
			<link type="Required" description="requires">3434</link>
		</links>
	</bug>
	<bug id="3433" opendate="2010-12-15 09:17:30" fixdate="2010-12-15 16:29:05" resolution="Fixed">
		<buginformation>
			<summary>Undefined header results in Nullpointer when expression is evaluated</summary>
			<description>If you define a filter for a header that is not defined like
from("p:a").filter(header("header").in("value")).to("p:b");
it results in a NullPointerException:


2010-12-15 10:07:45,920 [main] ERROR DefaultErrorHandler            - 
Failed delivery for exchangeId: 0215-1237-1292404064936-0-2. 
Exhausted after delivery attempt: 1 caught: java.lang.NullPointerException
	at org.apache.camel.builder.ExpressionBuilder$40.evaluate(ExpressionBuilder.java:955)
	at org.apache.camel.impl.ExpressionAdapter.evaluate(ExpressionAdapter.java:36)
	at org.apache.camel.builder.BinaryPredicateSupport.matches(BinaryPredicateSupport.java:54)
	at org.apache.camel.builder.PredicateBuilder$5.matches(PredicateBuilder.java:127)
	at org.apache.camel.processor.FilterProcessor.process(FilterProcessor.java:46)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:70)
	at org.apache.camel.processor.DelegateAsyncProcessor.processNext(DelegateAsyncProcessor.java:98)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:89)


This test reproduces the problem:


public void testExpressionForUndefinedHeader(){
    Expression type = ExpressionBuilder.headerExpression("header");
    Expression expression = ExpressionBuilder.constantExpression("value");
    Expression convertToExpression = ExpressionBuilder.convertToExpression(expression, type);
    convertToExpression.evaluate(exchange, Object.class);
}

</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.PredicateBuilderTest.java</file>
			<file type="M">org.apache.camel.builder.ExpressionBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="3425" opendate="2010-12-14 10:36:25" fixdate="2010-12-17 15:27:04" resolution="Fixed">
		<buginformation>
			<summary>CamelContext is started twice when using camel-blueprint</summary>
			<description>For example if you run the testRouteWithAllComponents test in CamelBlueprintTest in tests/camel-itest-osgi you will see a lot of logging. But notice


[RMI TCP Connection(1)-10.0.1.2] INFO org.apache.camel.core.osgi.OsgiDefaultCamelContext - Apache Camel 2.6-SNAPSHOT (CamelContext: 67-camel-2) is starting
[RMI TCP Connection(1)-10.0.1.2] INFO org.apache.camel.core.osgi.OsgiDefaultCamelContext - Apache Camel 2.6-SNAPSHOT (CamelContext: 67-camel-2) started in 0.147 seconds


Then blueprint does something


[Blueprint Extender: 3] INFO org.apache.camel.blueprint.BlueprintCamelContext - Apache Camel 2.6-SNAPSHOT (CamelContext: 4-camel-5) is starting
[Blueprint Extender: 3] INFO org.apache.camel.blueprint.BlueprintCamelContext - Apache Camel 2.6-SNAPSHOT (CamelContext: 4-camel-5) started in 0.071 seconds


And likewise both CamelContext&amp;amp;apos;s is shutdown when the test completes. There are logging events for that as well.
Pay attention to the name of the 1st CamelContext 67-camel-2. This is the correct name as its based on the bundle id, our end user Camel application is given. This ensures that the CamelContext from his application has a name which is unique and refers to the bundle id as well.
Now if you look at the 2nd CamelContext being started its given another name 4-camel-5. That id is most likely using a shared bundle id with a low number. For example camel-blueprint or camel-core bundle, or something like that. 
In essence camel-blueprint should only create one CamelContext and it should use the 67-camel-2 as the name of the CamelContext (eg. include the bundle id of the end user application).</description>
			<version>2.6.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.itest.osgi.blueprint.AbstractIntegrationTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.blueprint.BlueprintCamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="3442" opendate="2010-12-18 18:56:40" fixdate="2010-12-19 09:18:54" resolution="Fixed">
		<buginformation>
			<summary>JBI ClassLoading issue in SMX 4.x in OsgiPackageScanClassResolver</summary>
			<description>CAMEL-3302 introduced a fallback when using JBI in Apache ServiceMix 4.x.
However it may lead to an issue with ConcurrentModificationException when traversing the list of classloaders.


            for (ClassLoader classLoader : super.getClassLoaders()) {
                if (!isOsgiClassloader(classLoader)) {
                    find(test, packageName, classLoader, classes);
                }
            }  


The for loop is line 62 which causes the exception.
Issue reported here
http://camel.465427.n5.nabble.com/ServiceMix-4-Fuse-4-3-0-fuse-03-00-Problems-running-JBI-example-examples-camel-td3309088.html
</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultPackageScanClassResolver.java</file>
			<file type="M">org.apache.camel.spring.scan.DefaultPackageScanClassResolverTest.java</file>
			<file type="M">org.apache.camel.core.osgi.OsgiPackageScanClassResolver.java</file>
			<file type="M">org.apache.camel.spi.PackageScanClassResolver.java</file>
		</fixedFiles>
		<links>
			<link type="Regression" description="is broken by">3302</link>
		</links>
	</bug>
	<bug id="3446" opendate="2010-12-20 10:50:24" fixdate="2010-12-20 14:13:37" resolution="Fixed">
		<buginformation>
			<summary>NPE in camel-printer when not setting media size or omitting sides attribute</summary>
			<description>When specifying a camel-printer configuration that does not include config properties for sides or mediaSize, the camel route will fail to start up with a NullPointerException. E.g. this route


from("file://target/incoming?delete=true")
	.to("lpr://localhost/default");


will raise an NPE at route startup time.
</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.printer.PrinterPrintTest.java</file>
			<file type="M">org.apache.camel.component.printer.PrinterConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="3448" opendate="2010-12-20 14:56:28" fixdate="2010-12-20 18:48:40" resolution="Fixed">
		<buginformation>
			<summary>Route scoped onException may pick onException from another route if they are the same class type</summary>
			<description>If you have a clash with route scoped onException and have the exact same class, then the key in the map isn&amp;amp;apos;t catering for this. And thus a 2nd route could override the 1st route onException definition.
For example:
from X route A
  onException IOException
from Y route B
  onException IOException
The map should contain 2 entries, but unfortunately it only contain 1. This only happens when its an exact type match.</description>
			<version>2.0.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cdi.internal.CamelExtension.java</file>
			<file type="M">org.apache.camel.processor.exceptionpolicy.DefaultExceptionPolicyStrategy.java</file>
			<file type="M">org.apache.camel.processor.onexception.RouteScopedOnExceptionSameTypeTest.java</file>
			<file type="M">org.apache.camel.processor.ErrorHandlerSupport.java</file>
			<file type="M">org.apache.camel.processor.exceptionpolicy.ExceptionPolicyKey.java</file>
		</fixedFiles>
	</bug>
	<bug id="3458" opendate="2010-12-23 16:19:16" fixdate="2010-12-23 16:24:34" resolution="Fixed">
		<buginformation>
			<summary>Bindy should support clipping fields if they exceed maximum length allowed when using fixed length</summary>
			<description>Adding a new option to bindy annotation



    /**
     * Indicates to clip data in the field if it exceeds the allowed length when using fixed length.
     */
    boolean clip() default false;


Then if enabled it will clip the data so it can fit the length.
Also now Camel throws an exception if the data is too long and you have clip set as false.</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.bindy.BindyKeyValuePairFactory.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.fix.BindySimpleKeyValuePairWithoutSectionMarshallDslTest.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyFixedLengthFactory.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyAbstractFactory.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.annotation.DataField.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyCsvFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="3353" opendate="2010-11-22 19:25:01" fixdate="2010-12-27 08:59:23" resolution="Fixed">
		<buginformation>
			<summary>CxfRsInvoker silently swallows exceptions</summary>
			<description>If you have a route with a CXF consuming endpoint in the beginning and any component afterwards that can produce Exceptions that are not RuntimeCamelExceptions or WebApplicationException then the CxfRsInvoker will swallow the exception and return a HTTP 204 (all fine but no content to return) response.
For example in the following route:

 from("cxfrs://bean://fooServer")
            .convertBodyTo(Foo.class)
            .to("bean-validator://x")
            .to("jms:queue:foos").inOnly();


The bean validator component can throw BeanValidationException when the Foo instance has errors. This exception will be ignored by the CxfRsInvoker.
This causes important exceptions to become invisible by default which seems wrong to me. The docs and Camel in Action additionally talk about how the DefaultErrorHandler has a strategy of returning exceptions to the caller and this is also not happening here.
My local fix is a patched version of camel-cxf that converts any unknown exception (i.e. not CamelRuntimeException or WebApplicationException) to a WebApplicationException with the original exception as a constructor parameter. This is then effectively an HTTP 500 Exception and will be returned as such to the caller.
However my knowledge of camel and camel-cxf is not sufficient to ascertain whether this is the right approach, it seems to me that the CamelRuntimeException should also be treated this way since in the current code that will also be swallowed (as far as I can tell).</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsInvoker.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsConsumerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3479" opendate="2011-01-03 13:01:08" fixdate="2011-01-03 13:36:21" resolution="Fixed">
		<buginformation>
			<summary>CamelContinuationServlet - May produce NPE under heavy load</summary>
			<description>CAMEL-2986 fixes some issue with the CamelContinationServlet.
However under extreme load and under some circumstances you can still get a NPE.
The Jetty guides for writing and using continuation at
http://wiki.eclipse.org/Jetty/Feature/Continuations
Shows a different style for suspend/resume than we currently have implemented. 
I think it&amp;amp;apos;s best practice that we refactor the code in camel-jetty to be aligned with the Jetty guide.
I will follow the Suspend Resume Pattern style listed on the Jetty guide.</description>
			<version>2.4.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.CamelContinuationServlet.java</file>
		</fixedFiles>
	</bug>
	<bug id="3473" opendate="2010-12-29 14:33:08" fixdate="2011-01-04 14:17:33" resolution="Fixed">
		<buginformation>
			<summary>register several cacheEnpoint with different name</summary>
			<description>When you declare in camel context
&amp;lt;camel:endpoint id="cache1" uri="cache:cache1" /&amp;gt;
&amp;lt;camel:endpoint id="cache2" uri="cache:cache2" /&amp;gt;
&amp;lt;camel:endpoint id="cache3" uri="cache:cache3" /&amp;gt;
CamelCacheProducer produce systematically  in same cache because in CacheComponent, CacheConfiguration is modified by method createEndpoint
CamelCacheProducer.java


public void process(Exchange exchange) throws Exception {
        if (LOG.isTraceEnabled()) {
            LOG.trace("Cache Name: " + config.getCacheName());
        }

        if (cacheManager.cacheExists(config.getCacheName())) {
            if (LOG.isTraceEnabled()) {
                LOG.trace("Found an existing cache: " + config.getCacheName());
                LOG.trace("Cache " + config.getCacheName() + " currently contains "
                        + cacheManager.getCache(config.getCacheName()).getSize() + " elements");
            }
            cache = cacheManager.getCache(config.getCacheName());
        } else {
            cache = new Cache(config.getCacheName(),
                    config.getMaxElementsInMemory(),
                    config.getMemoryStoreEvictionPolicy(),
                    config.isOverflowToDisk(),
                    config.getDiskStorePath(),
                    config.isEternal(),
                    config.getTimeToLiveSeconds(),
                    config.getTimeToIdleSeconds(),
                    config.isDiskPersistent(),
                    config.getDiskExpiryThreadIntervalSeconds(),
                    null);
            cacheManager.addCache(cache);
            if (LOG.isDebugEnabled()) {
                LOG.debug("Added a new cache: " + cache.getName());
            }
        }

        String key = exchange.getIn().getHeader(CacheConstants.CACHE_KEY, String.class);
        String operation = exchange.getIn().getHeader(CacheConstants.CACHE_OPERATION, String.class);

        if (operation == null) {
            throw new CacheException("Operation not specified in the message header [" + CacheConstants.CACHE_KEY + "]");
        }
        if ((key == null) &amp;amp;&amp;amp; (!operation.equalsIgnoreCase(CacheConstants.CACHE_OPERATION_DELETEALL))) {
            throw new CacheException("Cache Key is not specified in message header header or endpoint URL.");
        }

        performCacheOperation(exchange, operation, key);
    }


CacheComponent.java


   public class CacheComponent extends DefaultComponent {
    private CacheConfiguration config;
    private CacheManagerFactory cacheManagerFactory = new CacheManagerFactory();
    
    public CacheComponent() {
        config = new CacheConfiguration();
    }

    public CacheComponent(CamelContext context) {
        super(context);
        config = new CacheConfiguration();
    }

    @Override
    @SuppressWarnings("unchecked")
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        config.parseURI(new URI(uri));
        
        CacheEndpoint cacheEndpoint = new CacheEndpoint(uri, this, config, cacheManagerFactory);
        setProperties(cacheEndpoint.getConfig(), parameters);
        return cacheEndpoint;
    }

    public CacheManagerFactory getCacheManagerFactory() {
        return cacheManagerFactory;
    }

    public void setCacheManagerFactory(CacheManagerFactory cacheManagerFactory) {
        this.cacheManagerFactory = cacheManagerFactory;
    }

    @Override
    protected void doStart() throws Exception {
        super.doStart();
        ServiceHelper.startService(cacheManagerFactory);
    }

    @Override
    protected void doStop() throws Exception {
        ServiceHelper.stopService(cacheManagerFactory);
        super.doStop();
    }
}


The resolution could be in CacheComponent
CacheComponent.java

    @Override
    @SuppressWarnings("unchecked")
    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {
        CacheConfiguration   config = new CacheConfiguration();
        config.parseURI(new URI(uri));
        
        CacheEndpoint cacheEndpoint = new CacheEndpoint(uri, this, config, cacheManagerFactory);
        setProperties(cacheEndpoint.getConfig(), parameters);
        return cacheEndpoint;
    }

 </description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cache.CacheConfiguration.java</file>
			<file type="M">org.apache.camel.component.cache.CacheComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="3483" opendate="2011-01-03 22:53:23" fixdate="2011-01-04 21:54:09" resolution="Fixed">
		<buginformation>
			<summary>csv unmarshal and maybe other components uses default encoding </summary>
			<description>See discussion in Nabble: http://camel.465427.n5.nabble.com/csv-unmarshal-uses-default-encoding-td3325474.html</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.castor.AbstractCastorDataFormat.java</file>
			<file type="M">org.apache.camel.component.flatpack.FlatpackDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.csv.CsvDataFormat.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">4989</link>
		</links>
	</bug>
	<bug id="3493" opendate="2011-01-05 01:09:05" fixdate="2011-01-05 06:39:09" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentModificationException in DefaultCamelContext.removeRouteDefinitions()</summary>
			<description>I get the following exception in DefaultCamelContext.removeRouteDefinitions().  We are removing route definitions from multiple threads.  I see synchronization in various other methods, but not this one. 
Caused by: java.util.ConcurrentModificationException
	at java.util.AbstractList$Itr.checkForComodification(AbstractList.java:372)
	at java.util.AbstractList$Itr.next(AbstractList.java:343)
	at java.util.AbstractCollection.removeAll(AbstractCollection.java:336)
	at org.apache.camel.impl.DefaultCamelContext.removeRouteDefinitions(DefaultCamelContext.java:588)</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="3489" opendate="2011-01-04 19:32:53" fixdate="2011-01-05 09:30:51" resolution="Fixed">
		<buginformation>
			<summary> BindyCsvDataFormat broken for pipe delimited files</summary>
			<description>Attempting to unmarshall a pipe delimited CSV file into a POJO using Bindy causese the first and last character the the line processed to be dropped.  It appears that the BindyCsvDataFormat class removes the first and the last character from the line read from the CSV if the seperator is &amp;gt; 1 characters in length (see below or line 162-165 in BindyCsvDataFormat).  For pipe delimited files, you need to specify | as the seperator, as | is not evaluated correctly as a java regex by the split fuction.  This leads to the first and last character for the line being parsed being dropped.  From the comments it appears a "fix" was added to remove the first and last character of the line when the seperator contains quotes or double quotes.  Making this determination using the length of the seperator, rather than evaluating using a regex seems to be a poor solution that breaks other CSV delimiters.
See Attached for an code example.
</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindyCsvDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindyDoubleQuotesCsvUnmarshallTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3133" opendate="2010-09-17 12:49:39" fixdate="2011-01-06 09:24:54" resolution="Fixed">
		<buginformation>
			<summary>Camel soap dataformat does not work correctly if a method has no input or no output</summary>
			<description>Currently the camel soap dataformat can not handle exachanges for a soap method that has no input or no output. This is a known limitation but we should support this.</description>
			<version>2.4.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.soap.name.ServiceInterfaceStrategyTest.java</file>
			<file type="M">org.apache.camel.dataformat.soap.name.MethodInfo.java</file>
			<file type="M">org.apache.camel.dataformat.soap.SoapCxfClientTest.java</file>
			<file type="M">org.apache.camel.dataformat.soap.SoapClientTest.java</file>
			<file type="M">org.apache.camel.dataformat.soap.name.ServiceInterfaceStrategy.java</file>
			<file type="M">org.apache.camel.dataformat.soap.CustomerServiceImpl.java</file>
			<file type="M">org.apache.camel.dataformat.soap.SoapJaxbDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="3498" opendate="2011-01-05 09:38:56" fixdate="2011-01-06 15:55:45" resolution="Fixed">
		<buginformation>
			<summary>Splitter Component: Setting &amp;apos;streaming = "true"&amp;apos; breaks error handling</summary>
			<description>Setting &amp;amp;apos;streaming = "true"&amp;amp;apos; breaks error handling:
If an exception is thrown in a processor, the exception in the subExchange is copied to the original exchange in MulticastProcessor line 554. In Splitter line 140 the original exchange is copied, including the exception that was thrown while processing the previous exchange. This prevents all subsequent exchanges from being processed successfully.</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.Splitter.java</file>
			<file type="M">org.apache.camel.processor.SplitterNoStopOnExceptionTest.java</file>
			<file type="M">org.apache.camel.processor.SplitterNoAggregationStrategyTest.java</file>
			<file type="M">org.apache.camel.processor.SplitterParallelNoStopOnExceptionTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3497" opendate="2011-01-05 09:21:34" fixdate="2011-01-08 17:29:57" resolution="Fixed">
		<buginformation>
			<summary>Splitter Component: Setting &amp;apos;streaming="true" parallelProcessing="true"&amp;apos; consumes large amounts &gt; of heap space for big original messages</summary>
			<description>Setting &amp;amp;apos;streaming="true" parallelProcessing="true"&amp;amp;apos; consumes large amounts of heap space for big original messages. E.g. 1024m of heap is not enough to process an 80Mb with 500&amp;amp;apos;000 lines, splitting it line by line.
The problem seems to be the ArrayList in MulticastProcessor line 224. It contains a Future&amp;lt;Exchange&amp;gt; object for every token delivered by the java.util.Scanner. The list is only cleared (going out of scope) after all Future objects have been completed.</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
			<file type="M">org.apache.camel.component.seda.SedaEndpoint.java</file>
			<file type="M">org.apache.camel.spi.ExecutorServiceStrategy.java</file>
			<file type="M">org.apache.camel.util.concurrent.ExecutorServiceHelper.java</file>
			<file type="M">org.apache.camel.util.concurrent.SubmitOrderedCompletionService.java</file>
			<file type="M">org.apache.camel.processor.async.AsyncEndpointRecipientListParallel3Test.java</file>
			<file type="M">org.apache.camel.util.concurrent.SubmitOrderedCompletionServiceTest.java</file>
			<file type="M">org.apache.camel.processor.RecipientList.java</file>
			<file type="M">org.apache.camel.util.ServiceHelper.java</file>
			<file type="M">org.apache.camel.processor.SplitterParallelBigFileTest.java</file>
			<file type="M">org.apache.camel.processor.Splitter.java</file>
			<file type="M">org.apache.camel.processor.RecipientListProcessor.java</file>
			<file type="M">org.apache.camel.processor.interceptor.DefaultTraceFormatter.java</file>
		</fixedFiles>
	</bug>
	<bug id="3304" opendate="2010-11-03 09:55:15" fixdate="2011-01-09 15:06:44" resolution="Invalid">
		<buginformation>
			<summary>camel-web-console feature for Apache Karaf</summary>
			<description>We need a feature for installing camel-web into Apache Karaf. It can be a bit of pain doing this the osgi way so we should provide such a feature.
Look at the AMQ web console feature how it may be done.</description>
			<version>2.6.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.camel.util.ExchangeBuilder.java</file>
			<file type="D">org.apache.camel.util.ExchangeBuilderTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">3519</link>
			<link type="Duplicate" description="duplicates">3150</link>
			<link type="dependent" description="is depended upon by">3292</link>
		</links>
	</bug>
	<bug id="3524" opendate="2011-01-10 14:34:35" fixdate="2011-01-10 15:27:37" resolution="Fixed">
		<buginformation>
			<summary>camel-jetty - Add option to set jetty continuation timeout</summary>
			<description>By default Jetty uses 30 sec timeout for continuations.
We should allow end users to configure a value of choice, in case their system may take longer time to process an exchange.</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyHttpEndpoint.java</file>
			<file type="M">org.apache.camel.component.jetty.CamelContinuationServlet.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">3245</link>
		</links>
	</bug>
	<bug id="3245" opendate="2010-10-17 18:36:51" fixdate="2011-01-10 15:57:23" resolution="Duplicate">
		<buginformation>
			<summary>Make Jetty continuation timeout configurable</summary>
			<description></description>
			<version>2.4.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyHttpEndpoint.java</file>
			<file type="M">org.apache.camel.component.jetty.CamelContinuationServlet.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">3524</link>
		</links>
	</bug>
	<bug id="3528" opendate="2011-01-11 16:44:56" fixdate="2011-01-11 17:45:53" resolution="Fixed">
		<buginformation>
			<summary>HybridSourceDataBinding not thread safe...</summary>
			<description>
The HybridSourceDataBinding in camel-cxf is not thread safe.  The readers/writers in CXF hold state (like schemas and properties) and  must be created when needed.    
</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsSuspendResumeTest.java</file>
			<file type="M">org.apache.camel.component.jms.CamelJmsTestHelper.java</file>
			<file type="M">org.apache.camel.component.cxf.HybridSourceDataBinding.java</file>
			<file type="M">org.apache.camel.maven.HtmlToPdfMojo.java</file>
		</fixedFiles>
	</bug>
	<bug id="3537" opendate="2011-01-13 08:12:15" fixdate="2011-01-13 08:20:38" resolution="Fixed">
		<buginformation>
			<summary>camel-snmp - Does not support tcp protocol</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/camel-snmp-2-5-problems-tp3339373p3339373.html</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.snmp.SnmpEndpoint.java</file>
			<file type="M">org.apache.camel.component.snmp.SnmpTrapConsumer.java</file>
			<file type="M">org.apache.camel.component.snmp.SnmpOIDPoller.java</file>
		</fixedFiles>
	</bug>
	<bug id="3540" opendate="2011-01-13 15:53:34" fixdate="2011-01-13 16:59:41" resolution="Fixed">
		<buginformation>
			<summary>Jt400DataQueueConsumer incorrectly implements timeout semantics (jt400 component)</summary>
			<description>Jt400DataQueueConsumer implementation of receive(long) passes the timeout argument directly to com.ibm.as400.access.DataQueue.read(int), not performing unit conversion. However, Jt400DataQueueConsumer.receive(long) accepts milliseconds, whereas DataQueue.read(int) accepts seconds as the time unit.
Also, invoking Jt400DataQueueConsumer.receive() results in a call to DataQueue.read(), which is not a blocking call; on the contrary, it will not wait for entries.
Code snippet below.
Jt400DataQueueConsumer.java

        DataQueue queue = endpoint.getDataQueue();
        try {
            DataQueueEntry entry;
            if (timeout &amp;gt;= 0) {
                entry = queue.read((int)timeout);
            } else {
                entry = queue.read();
            }


Note that the submitted patch floors the timeout value when converting to seconds, but different rounding might be desired, which should be specified in the class documentation.</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jt400.Jt400DataQueueConsumer.java</file>
			<file type="M">org.apache.camel.impl.PollingConsumerSupport.java</file>
			<file type="M">org.apache.camel.component.jt400.Jt400DataQueueProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="3535" opendate="2011-01-12 20:43:57" fixdate="2011-01-14 10:37:32" resolution="Fixed">
		<buginformation>
			<summary>Aggregation fails to call onComplete for exchanges if the aggregation is after a bean or process.</summary>
			<description>When creating a route that contains an aggregation, if that aggregation is preceded by a bean or process, it will fail to call AggregateOnCompletion.onComplete(). I&amp;amp;apos;ve attached a unit test that can show you the behavior. Trace level loggging will need to be enabled to see the difference. With the call to the bean, it won&amp;amp;apos;t show the following log entry:

TRACE org.apache.camel.processor.aggregate.AggregateProcessor - Aggregated exchange onComplete: Exchange[Message: ab]

If you remove the bean call, it&amp;amp;apos;ll start calling onComplete() again.
What I&amp;amp;apos;ve noticed is that if this call is not made, it ends up in a memory leak since the inProgressCompleteExchanges HashSet in AggregateProcessor never has any exchange ID&amp;amp;apos;s removed.</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.aggregator.BeanBeforeAggregateIssueTest.java</file>
			<file type="M">org.apache.camel.processor.aggregate.AggregateProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="is depended upon by">3317</link>
		</links>
	</bug>
	<bug id="3543" opendate="2011-01-14 14:25:58" fixdate="2011-01-15 07:47:58" resolution="Fixed">
		<buginformation>
			<summary>Loading routes using loadRouteDefinition from CamelContext lacks some logic from camel-core-xml</summary>
			<description>We have shared logic in camel-core-xml to use when build / loading routes from XML using JAXB. The routes must be prepared before they are usable for creating the runtime processors.
The logic should be moved into camel-core in the model package so we have it centralized and its more easy to reuse
See nabble
http://camel.465427.n5.nabble.com/Loading-routes-from-XML-files-with-Camel-2-4-0-tp3340082p3340082.html</description>
			<version>2.6.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.model.RouteDefinitionHelper.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilder.java</file>
			<file type="M">org.apache.camel.core.xml.AbstractCamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.model.RouteDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="3545" opendate="2011-01-15 14:29:46" fixdate="2011-01-15 16:26:22" resolution="Fixed">
		<buginformation>
			<summary>MethodCallExpression doesn&amp;apos;t validate whether the method exists for all cases</summary>
			<description>I tried to refactor
org.apache.camel.model.language.MethodCallExpression.java

    public Expression createExpression(CamelContext camelContext) {
        Expression answer;

        if (beanType != null) {            
            instance = ObjectHelper.newInstance(beanType);
            return new BeanExpression(instance, getMethod(), parameterType); // &amp;lt;--
        } else if (instance != null) {
            return new BeanExpression(instance, getMethod(), parameterType); // &amp;lt;--
        } else {
            String ref = beanName();
            // if its a ref then check that the ref exists
            BeanHolder holder = new RegistryBean(camelContext, ref);
            // get the bean which will check that it exists
            instance = holder.getBean();
            answer = new BeanExpression(ref, getMethod(), parameterType);
        }

        // validate method
        validateHasMethod(camelContext, instance, getMethod(), parameterType);

        return answer;
    }


to
org.apache.camel.model.language.MethodCallExpression.java

    public Expression createExpression(CamelContext camelContext) {
        Expression answer;

        if (beanType != null) {            
            instance = ObjectHelper.newInstance(beanType);
            answer = new BeanExpression(instance, getMethod(), parameterType); // &amp;lt;--
        } else if (instance != null) {
            answer = new BeanExpression(instance, getMethod(), parameterType); // &amp;lt;--
        } else {
            String ref = beanName();
            // if its a ref then check that the ref exists
            BeanHolder holder = new RegistryBean(camelContext, ref);
            // get the bean which will check that it exists
            instance = holder.getBean();
            answer = new BeanExpression(ref, getMethod(), parameterType);
        }

        // validate method
        validateHasMethod(camelContext, instance, getMethod(), parameterType);

        return answer;
    }


so that the created BeanExpression is also validate if you provide the bean type or an instance. With this change, some tests in org.apache.camel.language.SimpleTest fails.
I&amp;amp;apos;m not sure whether the tests are faulty or if it&amp;amp;apos;s a bug.
Also not sure whether this should fixed in 2.6. </description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanWithMethodHeaderTest.java</file>
			<file type="M">org.apache.camel.component.bean.MethodNotFoundException.java</file>
			<file type="M">org.apache.camel.language.BeanLanguageInvalidOGNLTest.java</file>
			<file type="M">org.apache.camel.model.language.MethodCallExpression.java</file>
		</fixedFiles>
	</bug>
	<bug id="3559" opendate="2011-01-18 14:31:47" fixdate="2011-01-18 15:07:26" resolution="Fixed">
		<buginformation>
			<summary>Aggregator - The completionFromBatchConsumer option dont aggregate the last incoming exchange</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Last-Aggregated-Exchange-lost-Aggregator-with-a-Batch-Consumer-and-persistent-AggregationRepository-tp3346214p3346214.html</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.aggregate.AggregateProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="3560" opendate="2011-01-19 11:05:18" fixdate="2011-01-19 11:19:20" resolution="Fixed">
		<buginformation>
			<summary>Detect uncaught exceptions in UoWProcessor to ensure UoW is done even for those uncaught exceptions</summary>
			<description>The Camel routing engines will handle this in 99.9% of the cases, but when you shutdown a Spring AC then Spring may stop beans in whatever order and this can cause those beans to fail operating during a graceful shutdown. And in worst case exceptions is thrown in situations where they are not normally done.
To cater for that and other situations the UoWProcessor should detect this and act accordingly.
This ensure the in flight registry will be tracked and we are not stuck with a missing inflight message, causing Camel to wait for the 300 sec timeout to shutdown.
For example just try hitting ctrl + c in that camel-example-management and you can see such an example.</description>
			<version>2.5.0</version>
			<fixedVersion>2.6.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanProcessor.java</file>
			<file type="M">org.apache.camel.processor.UnitOfWorkProcessor.java</file>
			<file type="M">org.apache.camel.component.jms.EndpointMessageListener.java</file>
		</fixedFiles>
	</bug>
	<bug id="3438" opendate="2010-12-17 17:35:25" fixdate="2011-02-05 03:50:36" resolution="Fixed">
		<buginformation>
			<summary>JAXBDataFormatter should using Spring ApplicationContext&amp;apos;s classLoader explicitly</summary>
			<description>JAXBDataFormatter now using JAXBContext.newInstance(path) to create JAXBContext,
but this will using Thread&amp;amp;apos;s context classLoader.
this may causing un-expected class or resource not found exceptions;</description>
			<version>2.4.0</version>
			<fixedVersion>2.7.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.jaxb.JaxbDataFormat.java</file>
			<file type="M">org.apache.camel.example.DataFormatTest.java</file>
			<file type="M">org.apache.camel.processor.DefaultChannel.java</file>
			<file type="M">org.apache.camel.processor.MarshalProcessor.java</file>
			<file type="M">org.apache.camel.processor.UnmarshalProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Required" description="requires">3441</link>
		</links>
	</bug>
	<bug id="3361" opendate="2010-11-24 09:16:01" fixdate="2011-02-05 14:32:52" resolution="Duplicate">
		<buginformation>
			<summary>Upgrade SpringIntegration to 2.0.0.RELEASE</summary>
			<description>Spring Integration 2.0 just became GA. The camel-spring-integration component should be upgraded. I think it is best to do this in Camel 3.0 since Spring Integration 2.0 requires Spring 3.0.</description>
			<version>2.6.0</version>
			<fixedVersion>2.7.0</fixedVersion>
			<type>Task</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelTargetAdapter.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelSourceAdapterTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.converter.SpringIntegrationConverter.java</file>
			<file type="M">org.apache.camel.itest.karaf.AbstractFeatureTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationOneWayConsumerTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationProducer.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.ConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationConsumer.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationBinding.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelSourceAdapter.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationEndpoint.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationTwoWayConsumerTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationMessage.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelTargetAdapterTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">3630</link>
		</links>
	</bug>
	<bug id="3630" opendate="2011-02-05 12:32:29" fixdate="2011-02-11 14:39:17" resolution="Fixed">
		<buginformation>
			<summary>Upgrade to Spring Integration 2.0.x</summary>
			<description>As part of the Spring 3.0x upgrade, we can upgrade to SI 2.x as it requires Spring 3.0</description>
			<version>2.6.0</version>
			<fixedVersion>2.7.0</fixedVersion>
			<type>Task</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelTargetAdapter.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelSourceAdapterTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.converter.SpringIntegrationConverter.java</file>
			<file type="M">org.apache.camel.itest.karaf.AbstractFeatureTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationOneWayConsumerTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationProducer.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.ConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationConsumer.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationBinding.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelSourceAdapter.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationEndpoint.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationTwoWayConsumerTest.java</file>
			<file type="M">org.apache.camel.component.spring.integration.SpringIntegrationMessage.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelTargetAdapterTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">3361</link>
		</links>
	</bug>
	<bug id="3673" opendate="2011-02-16 13:55:15" fixdate="2011-02-17 06:55:54" resolution="Duplicate">
		<buginformation>
			<summary>Property placeholders do not work with camel-blueprint </summary>
			<description>if I have a route that looks like: 


&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:cm="http://aries.apache.org/blueprint/xmlns/blueprint-cm/v1.0.0" xmlns:ext="http://aries.apache.org/blueprint/xmlns/blueprint-ext/v1.0.0"
  xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0 
                      http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd"&amp;gt;

  &amp;lt;cm:property-placeholder persistent-id="camel.blueprint" /&amp;gt;

  &amp;lt;camelContext id="camel" trace="false" xmlns="http://camel.apache.org/schema/blueprint"&amp;gt;

    &amp;lt;route&amp;gt;
      &amp;lt;from uri="file://${directory.in}/" /&amp;gt;
      &amp;lt;to uri="file://${directory.out}/" /&amp;gt;
    &amp;lt;/route&amp;gt;
  &amp;lt;/camelContext&amp;gt;
&amp;lt;/blueprint&amp;gt;


The placeholders aren&amp;amp;apos;t replaced by the actual value. </description>
			<version>2.6.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jasypt.JasyptPropertiesParserTest.java</file>
			<file type="M">org.apache.camel.core.xml.AbstractCamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.component.jasypt.JasyptPropertiesParser.java</file>
			<file type="M">org.apache.camel.component.properties.PropertiesParser.java</file>
			<file type="M">org.apache.camel.component.properties.DefaultPropertiesParser.java</file>
			<file type="M">org.apache.camel.blueprint.CamelContextFactoryBean.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">3674</link>
		</links>
	</bug>
	<bug id="3674" opendate="2011-02-16 14:49:22" fixdate="2011-02-26 09:27:04" resolution="Fixed">
		<buginformation>
			<summary>Camel properties component - to leverage Blueprint properties</summary>
			<description>The Camel properties component, should be able to ref to blueprint properties "stuff".
We can add a new scheme blueprint you can specify in the location url, or re-use the ref which would refer to the blueprint "stuff".
We may need some logic from camel-blueprint or whatever to type converter or help lookup and bridge the two of them.
Just creating this ticket so we will look into this, sometime.</description>
			<version>2.6.0</version>
			<fixedVersion>2.7.0</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jasypt.JasyptPropertiesParserTest.java</file>
			<file type="M">org.apache.camel.core.xml.AbstractCamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.component.jasypt.JasyptPropertiesParser.java</file>
			<file type="M">org.apache.camel.component.properties.PropertiesParser.java</file>
			<file type="M">org.apache.camel.component.properties.DefaultPropertiesParser.java</file>
			<file type="M">org.apache.camel.blueprint.CamelContextFactoryBean.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">3673</link>
		</links>
	</bug>
	<bug id="3800" opendate="2011-03-23 10:07:48" fixdate="2011-04-10 21:30:29" resolution="Fixed">
		<buginformation>
			<summary>Introduce a message header to let SqlProducer update the query string in the runtime</summary>
			<description>Current we can only define a sql query in the SqlEndpoint URI, we need to a way to change the query per exchange.
An new camel header for this query could help use to do that.</description>
			<version>2.7.0</version>
			<fixedVersion>2.8.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sql.SqlRouteTest.java</file>
			<file type="M">org.apache.camel.component.sql.SqlProducer.java</file>
			<file type="M">org.apache.camel.component.sql.SqlConstants.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">3801</link>
			<link type="Reference" description="is related to">3907</link>
		</links>
	</bug>
	<bug id="3801" opendate="2011-03-23 11:07:04" fixdate="2011-04-10 21:59:51" resolution="Duplicate">
		<buginformation>
			<summary>Allow to send the Query as a Body + Header Message in exchange to the SQL component</summary>
			<description>The existing SQL component requires that the query is attached to the endpoint and parameters provided as a List when we would like to replace the # symbol by those values. 
The JDBC component adopts a different philosophy as the query can be build in a processor, bean or setBody and send to the JDBC endpoint.
Using the following syntax could be much more flexible to setup dynamically queries :


&amp;lt;route id="insert-from-file"&amp;gt;
           &amp;lt;from uri="file://target/datainsert?moveFailed=failed"/&amp;gt;
           &amp;lt;setBody&amp;gt;
               &amp;lt;simple&amp;gt;INSERT INTO REPORT.T_INCIDENT (INCIDENT_REF,
                   INCIDENT_DATE,GIVEN_NAME,FAMILY_NAME,SUMMARY,DETAILS,EMAIL,PHONE)
                   VALUES (&amp;amp;apos;${body}&amp;amp;apos;,&amp;amp;apos;2011-03-21&amp;amp;apos;,&amp;amp;apos;Charles&amp;amp;apos;,&amp;amp;apos;Moulliard&amp;amp;apos;,&amp;amp;apos;Incident&amp;amp;apos;,
                   &amp;amp;apos;This is a report incident for webinar-001&amp;amp;apos;,
                   &amp;amp;apos;cmoulliard@fusesource.com&amp;amp;apos;,&amp;amp;apos;+111 10 20 300&amp;amp;apos;)
               &amp;lt;/simple&amp;gt;
           &amp;lt;/setBody&amp;gt;
           &amp;lt;to uri="sql"/&amp;gt;
       &amp;lt;/route&amp;gt;


</description>
			<version>2.7.0</version>
			<fixedVersion>2.8.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sql.SqlRouteTest.java</file>
			<file type="M">org.apache.camel.component.sql.SqlProducer.java</file>
			<file type="M">org.apache.camel.component.sql.SqlConstants.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">3800</link>
			<link type="Duplicate" description="is duplicated by">3907</link>
		</links>
	</bug>
	<bug id="3531" opendate="2011-01-12 05:17:11" fixdate="2011-04-24 17:00:43" resolution="Fixed">
		<buginformation>
			<summary>scala - xpath not working together with choice/when</summary>
			<description>When using the Scala DSL, xpath expressions inside when() do not work as expected. As an example:


     "direct:a" ==&amp;gt; {
     choice {
        when (xpath("//hello")) to ("mock:english")
        when (xpath("//hallo")) {
          to ("mock:dutch")
          to ("mock:german")
        } 
        otherwise to ("mock:french")
      }
    }

// Send messages
"direct:a" ! ("&amp;lt;hello/&amp;gt;", "&amp;lt;hallo/&amp;gt;", "&amp;lt;hellos/&amp;gt;")


Here we should receive 1 message in each of the mocks. For whatever reason, all 3 messages go to mock:english. Similar routes work as expected with the Java DSL. </description>
			<version>2.5.0</version>
			<fixedVersion>2.7.3, 2.8.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.converter.ObjectHelperTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3901" opendate="2011-04-26 09:17:55" fixdate="2011-06-02 07:01:13" resolution="Duplicate">
		<buginformation>
			<summary>Create a separate component for camel transport for cxf</summary>
			<description>The camel-cxf component curently contains too many unrelated functions. It contains:

camel transport for cxf
cxf component
cxfbean component
cxfrs componet
converters

So this causes the code of the component to depend on each other and suck in much too many dependencies. Besides this there are some package dependency cycles in the code which could easily be solved.
A first step is to separate the camel transport for cxf from the rest of the code. It is independent of all other code and can be pulled into a new component. 
Some advantages are: 

The camel transport for cxf needs very few dependencies so it is a vey light weight aproach to combine cxf and camel
The new component nicely shows how to bridge between cxd and camel without the overhead of the other components
We can let the camel-cxf component depdend on the camel transport for cxf so for people using maven no changes are needed

I will attach a patch where I simply deleted anything that is not relevant for camel transport for cxf from the camel-cxf project. This is of course not yet the solution but it shows how small the new component will be and is a good start for doing the split.
I would be very interested about opinions from other developers about the split.
Christian
</description>
			<version>2.7.1</version>
			<fixedVersion>2.8.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.itest.greeter.CamelGreeterConsumerTest.java</file>
			<file type="M">org.apache.camel.itest.greeter.CxfToJmsInOutTest.java</file>
			<file type="M">org.apache.camel.itest.greeter.CamelGreeterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.common.message.CxfConstants.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducerHeaderTest.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.CxfBeanDestination.java</file>
			<file type="M">org.apache.camel.loanbroker.webservice.version.LoanBroker.java</file>
			<file type="M">org.apache.camel.example.cxf.jaxrs.CamelRouterBuilder.java</file>
			<file type="M">org.apache.camel.itest.greeter.FilePrepareRequest.java</file>
			<file type="M">org.apache.camel.itest.security.MyProcessor.java</file>
			<file type="M">org.apache.camel.itest.greeter.PrepareRequest.java</file>
			<file type="M">org.apache.camel.itest.greeter.JmsPrepareResponse.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.CxfBeanTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.SpringBusFactoryBean.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfNonWrapperTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfMixedModeRouterTest.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelTransportFactory.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfPayLoadSoapHeaderTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfPayLoadMessageXmlBindingRouterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.util.CxfUtils.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomRouterPayloadModeTest.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomRouterPayloadMode12Test.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfTimeoutTest.java</file>
			<file type="D">org.apache.camel.component.cxf.jaxrs.testbean.Customer.java</file>
			<file type="M">org.apache.camel.component.cxf.blueprint.EndpointDefinitionParser.java</file>
			<file type="M">org.apache.camel.component.cxf.ServiceClassRefTest.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.CxfBeanWithWsdlLocationInBeanAndIoCTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBeanTest.java</file>
			<file type="M">org.apache.camel.component.cxf.soap.headers.HeaderTesterWithInsertionImpl.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.JaxWSCamelConduitTest.java</file>
			<file type="D">org.apache.camel.wsdl_first.PersonImpl.java</file>
			<file type="M">org.apache.camel.component.cxf.HelloImpl.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducerTest.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducer.java</file>
			<file type="M">org.apache.camel.component.cxf.DefaultSEI.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfCustomizedExceptionTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfPayLoadMessageRouterAddressOverrideTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumerPayLoadFaultMessageTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CXFWsdlOnlyPayloadModeMultiPartNoSpringTest.java</file>
			<file type="M">org.apache.camel.component.cxf.feature.MessageDataFormatFeature.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfWsdlFirstTest.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomDisabledProducerPayloadModeTest.java</file>
			<file type="M">org.apache.camel.component.cxf.blueprint.CxfNamespaceHandler.java</file>
			<file type="M">org.apache.camel.component.cxf.util.DataInInterceptor.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfPayload.java</file>
			<file type="M">org.apache.camel.component.cxf.feature.PayLoadDataFormatFeature.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomDisabledConsumerPayloadModeTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfBlueprintEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBindingTest.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.util.CxfMessageHelper.java</file>
			<file type="M">org.apache.camel.component.cxf.multipart.MultiPartInvokeImpl.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelDestinationTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumerResponseTest.java</file>
			<file type="M">org.apache.camel.component.cxf.multipart.CXFMultiPartTest.java</file>
			<file type="M">org.apache.camel.component.cxf.converter.CxfPayloadConverterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBeansRouterTest.java</file>
			<file type="D">org.apache.camel.component.cxf.util.CxfMessageHelper.java</file>
			<file type="M">org.apache.camel.component.cxf.soap.headers.HeaderTesterImpl.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfRsClientFactoryBeanDefinitionParser.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.DefaultCxfBeanBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumerTest.java</file>
			<file type="M">org.apache.camel.component.cxf.soap.headers.CustomHeaderFilter.java</file>
			<file type="M">org.apache.camel.component.cxf.LoggingInterceptorInMessageModeTest.java</file>
			<file type="M">org.apache.camel.component.cxf.converter.CxfPayloadConverter.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.CxfBeanEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducer.java</file>
			<file type="D">org.apache.camel.component.cxf.CxfConstants.java</file>
			<file type="M">org.apache.camel.component.cxf.blueprint.RsClientDefinitionParser.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBean.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumerPayloadTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfJavaOnlyPayloadModeTest.java</file>
			<file type="D">org.apache.camel.wsdl_first.PersonImplWithWsdl.java</file>
			<file type="M">org.apache.camel.wsdl_first.JaxwsTestHandler.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducerSoapFaultTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBeanDefinitionParser.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.DefaultCxfRsBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.SpringBusFactoryBeanTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfRsServerFactoryBeanDefinitionParser.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.MyProcessor.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomProducerPayloadModeTest.java</file>
			<file type="D">org.apache.camel.component.cxf.util.CxfHeaderHelper.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfHeaderFilterStrategy.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsSpringEndpointTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSimpleRouterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsHeaderFilterStrategy.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.CxfBeanTransportFactory.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelJBIClientProxyTest.java</file>
			<file type="M">org.apache.camel.component.cxf.util.CxfMessageHelperTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfDispatchTestSupport.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfDispatchPayloadTest.java</file>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsConsumerTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducerRouterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.AbstractCxfBeanDefinitionParser.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumerPayloadFaultTest.java</file>
			<file type="D">org.apache.camel.component.cxf.jaxrs.testbean.Product.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelDestination.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomConsumerTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfComponent.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomConsumerPayloadModeTest.java</file>
			<file type="M">org.apache.camel.component.cxf.wsa.WSAddressingTest.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.CxfBeanComponent.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumerPayLoadMarshalFaultTest.java</file>
			<file type="M">org.apache.camel.component.cxf.WSDLServiceConfiguration.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfDispatchMessageTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSpringEndpoint.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelConduit.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducerOperationTest.java</file>
			<file type="M">org.apache.camel.component.cxf.TestCamel1145Route.java</file>
			<file type="M">org.apache.camel.component.cxf.HybridSourceDataBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSpringCustomizedExceptionTest.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsComponent.java</file>
			<file type="M">org.apache.camel.component.cxf.util.SplitterWithXqureyTest.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.CxfBeanWithWsdlLocationInBeanTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumer.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.CxfBeanBinding.java</file>
			<file type="D">org.apache.camel.component.cxf.jaxrs.testbean.CustomerService.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomPOJOProducerTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducerContextTest.java</file>
			<file type="M">org.apache.camel.component.cxf.converter.MyCxfCustomerConverter.java</file>
			<file type="M">org.apache.camel.component.cxf.soap.headers.CxfMessageHeadersRelayTest.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.spring.AbstractCamelContextBeanDefinitionParser.java</file>
			<file type="M">org.apache.camel.component.cxf.util.CxfUtilsTest.java</file>
			<file type="D">org.apache.camel.component.cxf.jaxrs.testbean.Order.java</file>
			<file type="M">org.apache.camel.component.cxf.util.CxfEndpointUtils.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducerTest.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelEndpointSpringConfigureTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumerProviderTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfPayLoadMessageRouterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducerProtocalHeaderTest.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.ProxyProcessor.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.spring.CamelConduitDefinitionParser.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.JbiServiceProcessor.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelTransportTestSupport.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.spring.NamespaceHandler.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.spring.CamelDestinationDefinitionParser.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelConduitTest.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelTransportConstants.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2389</link>
		</links>
	</bug>
	<bug id="2389" opendate="2010-01-22 03:00:10" fixdate="2011-06-02 07:01:55" resolution="Fixed">
		<buginformation>
			<summary>Split camel transport for cxf out of camel-cxf module</summary>
			<description>As camel-transport for cxf independents from the cxf-rs and cxf component, we need to put it into other module to avoid unnecessary third party dependency.</description>
			<version>2.7.1</version>
			<fixedVersion>2.8.0</fixedVersion>
			<type>Task</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.itest.greeter.CamelGreeterConsumerTest.java</file>
			<file type="M">org.apache.camel.itest.greeter.CxfToJmsInOutTest.java</file>
			<file type="M">org.apache.camel.itest.greeter.CamelGreeterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.common.message.CxfConstants.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducerHeaderTest.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.CxfBeanDestination.java</file>
			<file type="M">org.apache.camel.loanbroker.webservice.version.LoanBroker.java</file>
			<file type="M">org.apache.camel.example.cxf.jaxrs.CamelRouterBuilder.java</file>
			<file type="M">org.apache.camel.itest.greeter.FilePrepareRequest.java</file>
			<file type="M">org.apache.camel.itest.security.MyProcessor.java</file>
			<file type="M">org.apache.camel.itest.greeter.PrepareRequest.java</file>
			<file type="M">org.apache.camel.itest.greeter.JmsPrepareResponse.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.CxfBeanTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.SpringBusFactoryBean.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfNonWrapperTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfMixedModeRouterTest.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelTransportFactory.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfPayLoadSoapHeaderTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfPayLoadMessageXmlBindingRouterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.util.CxfUtils.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomRouterPayloadModeTest.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomRouterPayloadMode12Test.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfTimeoutTest.java</file>
			<file type="D">org.apache.camel.component.cxf.jaxrs.testbean.Customer.java</file>
			<file type="M">org.apache.camel.component.cxf.blueprint.EndpointDefinitionParser.java</file>
			<file type="M">org.apache.camel.component.cxf.ServiceClassRefTest.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.CxfBeanWithWsdlLocationInBeanAndIoCTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBeanTest.java</file>
			<file type="M">org.apache.camel.component.cxf.soap.headers.HeaderTesterWithInsertionImpl.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.JaxWSCamelConduitTest.java</file>
			<file type="D">org.apache.camel.wsdl_first.PersonImpl.java</file>
			<file type="M">org.apache.camel.component.cxf.HelloImpl.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducerTest.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducer.java</file>
			<file type="M">org.apache.camel.component.cxf.DefaultSEI.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfCustomizedExceptionTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfPayLoadMessageRouterAddressOverrideTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumerPayLoadFaultMessageTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CXFWsdlOnlyPayloadModeMultiPartNoSpringTest.java</file>
			<file type="M">org.apache.camel.component.cxf.feature.MessageDataFormatFeature.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfWsdlFirstTest.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomDisabledProducerPayloadModeTest.java</file>
			<file type="M">org.apache.camel.component.cxf.blueprint.CxfNamespaceHandler.java</file>
			<file type="M">org.apache.camel.component.cxf.util.DataInInterceptor.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfPayload.java</file>
			<file type="M">org.apache.camel.component.cxf.feature.PayLoadDataFormatFeature.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomDisabledConsumerPayloadModeTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfBlueprintEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBindingTest.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.util.CxfMessageHelper.java</file>
			<file type="M">org.apache.camel.component.cxf.multipart.MultiPartInvokeImpl.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelDestinationTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumerResponseTest.java</file>
			<file type="M">org.apache.camel.component.cxf.multipart.CXFMultiPartTest.java</file>
			<file type="M">org.apache.camel.component.cxf.converter.CxfPayloadConverterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBeansRouterTest.java</file>
			<file type="D">org.apache.camel.component.cxf.util.CxfMessageHelper.java</file>
			<file type="M">org.apache.camel.component.cxf.soap.headers.HeaderTesterImpl.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfRsClientFactoryBeanDefinitionParser.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.DefaultCxfBeanBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumerTest.java</file>
			<file type="M">org.apache.camel.component.cxf.soap.headers.CustomHeaderFilter.java</file>
			<file type="M">org.apache.camel.component.cxf.LoggingInterceptorInMessageModeTest.java</file>
			<file type="M">org.apache.camel.component.cxf.converter.CxfPayloadConverter.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.CxfBeanEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducer.java</file>
			<file type="D">org.apache.camel.component.cxf.CxfConstants.java</file>
			<file type="M">org.apache.camel.component.cxf.blueprint.RsClientDefinitionParser.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBean.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumerPayloadTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfJavaOnlyPayloadModeTest.java</file>
			<file type="D">org.apache.camel.wsdl_first.PersonImplWithWsdl.java</file>
			<file type="M">org.apache.camel.wsdl_first.JaxwsTestHandler.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducerSoapFaultTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfEndpointBeanDefinitionParser.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.DefaultCxfRsBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.SpringBusFactoryBeanTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.CxfRsServerFactoryBeanDefinitionParser.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.MyProcessor.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomProducerPayloadModeTest.java</file>
			<file type="D">org.apache.camel.component.cxf.util.CxfHeaderHelper.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfHeaderFilterStrategy.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsSpringEndpointTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSimpleRouterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsHeaderFilterStrategy.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.CxfBeanTransportFactory.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelJBIClientProxyTest.java</file>
			<file type="M">org.apache.camel.component.cxf.util.CxfMessageHelperTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfDispatchTestSupport.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfDispatchPayloadTest.java</file>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsConsumerTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducerRouterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.AbstractCxfBeanDefinitionParser.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumerPayloadFaultTest.java</file>
			<file type="D">org.apache.camel.component.cxf.jaxrs.testbean.Product.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelDestination.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomConsumerTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfComponent.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomConsumerPayloadModeTest.java</file>
			<file type="M">org.apache.camel.component.cxf.wsa.WSAddressingTest.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.CxfBeanComponent.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumerPayLoadMarshalFaultTest.java</file>
			<file type="M">org.apache.camel.component.cxf.WSDLServiceConfiguration.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfDispatchMessageTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSpringEndpoint.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelConduit.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducerOperationTest.java</file>
			<file type="M">org.apache.camel.component.cxf.TestCamel1145Route.java</file>
			<file type="M">org.apache.camel.component.cxf.HybridSourceDataBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfSpringCustomizedExceptionTest.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsComponent.java</file>
			<file type="M">org.apache.camel.component.cxf.util.SplitterWithXqureyTest.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.CxfBeanWithWsdlLocationInBeanTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumer.java</file>
			<file type="D">org.apache.camel.component.cxf.cxfbean.CxfBeanBinding.java</file>
			<file type="D">org.apache.camel.component.cxf.jaxrs.testbean.CustomerService.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomPOJOProducerTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducerContextTest.java</file>
			<file type="M">org.apache.camel.component.cxf.converter.MyCxfCustomerConverter.java</file>
			<file type="M">org.apache.camel.component.cxf.soap.headers.CxfMessageHeadersRelayTest.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.spring.AbstractCamelContextBeanDefinitionParser.java</file>
			<file type="M">org.apache.camel.component.cxf.util.CxfUtilsTest.java</file>
			<file type="D">org.apache.camel.component.cxf.jaxrs.testbean.Order.java</file>
			<file type="M">org.apache.camel.component.cxf.util.CxfEndpointUtils.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducerTest.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelEndpointSpringConfigureTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumerProviderTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfPayLoadMessageRouterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducerProtocalHeaderTest.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.ProxyProcessor.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.spring.CamelConduitDefinitionParser.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.JbiServiceProcessor.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelTransportTestSupport.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.spring.NamespaceHandler.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.spring.CamelDestinationDefinitionParser.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelConduitTest.java</file>
			<file type="D">org.apache.camel.component.cxf.transport.CamelTransportConstants.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">3901</link>
		</links>
	</bug>
	<bug id="3752" opendate="2011-03-04 11:47:51" fixdate="2011-06-04 11:44:17" resolution="Duplicate">
		<buginformation>
			<summary>ExchangeBuilder</summary>
			<description>We should add an ExchangeBuilder so you can use the builder pattern to create an Exchange and set message body, headers etc.
Something along the lines like this. Maybe there is a shorter and nicer API to do it:


Exchange exchange = ExchangeBuilder(context).withBody("Hello World).andHeader("foo", 123).build("activemq:queue:foo");

</description>
			<version>2.6.0</version>
			<fixedVersion>3.0.0</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.camel.util.ExchangeBuilder.java</file>
			<file type="D">org.apache.camel.util.ExchangeBuilderTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">3104</link>
		</links>
	</bug>
	<bug id="4284" opendate="2011-07-29 20:19:40" fixdate="2011-07-31 11:17:52" resolution="Duplicate">
		<buginformation>
			<summary>missing documentation in binary distribution tarballs</summary>
			<description>The documentation in the 2.8.0 binary distribution tarballs (both apache-camel-2.8.0.tar.gz and apache-camel-2.8.0.zip) is missing. The documentation file in doc/manual/camel-manual-2.8.0.html contains the following error message:


&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;Download of http://camel.apache.org/book-in-one-page.html failed&amp;lt;/body&amp;gt;

</description>
			<version>2.8.0</version>
			<fixedVersion>2.9.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.maven.HtmlToPdfMojo.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">3774</link>
		</links>
	</bug>
	<bug id="4483" opendate="2011-09-24 08:55:13" fixdate="2011-09-24 08:58:53" resolution="Duplicate">
		<buginformation>
			<summary>Global exception not invoked in case of Exception fired while iterating through File Splitter</summary>
			<description>Hi All, 
I have written a file route which picks up xml files from a specified location. This file is passed to a splitter (actually an Expression written by me) which returns a custom made Iterator and returns to Camel. When camel is iterating through my iterator, if I throw RuntimeException, it is not getting caught in global exception and hence i am not able to log the error. In actual, my entire code is a test class attached with this mail. Anyone can run it directly. There is one strange behavior also noticed by me. If i throw RuntimeException from the Expression written by me, it is properly caught by the global exception. You can find both the occurance of RuntimeException in the code (the commented one is working properly). 
Any help will be appreciated.
For the source code, check the issue created in forum:
http://camel.465427.n5.nabble.com/Global-exception-not-invoked-in-case-of-Exception-fired-while-iterating-through-File-Splitter-tc4826097.html</description>
			<version>2.8.1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.Splitter.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">4482</link>
		</links>
	</bug>
	<bug id="4482" opendate="2011-09-24 07:49:45" fixdate="2011-09-24 09:49:30" resolution="Fixed">
		<buginformation>
			<summary>Using custom expression in Splitter EIP which throws exception, is not triggering onException</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Global-exception-not-invoked-in-case-of-Exception-fired-while-iterating-through-File-Splitter-td4826097.html
We should detect exceptions occurred during evaluation of the expression, and then cause the splitter EIP to fail asap.</description>
			<version>2.8.1</version>
			<fixedVersion>2.8.2, 2.9.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.Splitter.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">4483</link>
		</links>
	</bug>
	<bug id="4456" opendate="2011-09-16 08:20:17" fixdate="2011-10-24 14:33:44" resolution="Duplicate">
		<buginformation>
			<summary>camel-mail - Add option to control if mail folder should be closed after poll</summary>
			<description>It should be possible to control if the mail folder should be closed after a poll or not.
For example if people is routing mails over SEDA or other async endpoints, then we should not close the mail folder before the mail message is being processed async.
We have a similar option on mina,netty etc. named disconnect. So the option could be named like that as well.</description>
			<version>2.8.0</version>
			<fixedVersion>2.9.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailConfiguration.java</file>
			<file type="M">org.apache.camel.component.mail.MailConsumer.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">4225</link>
		</links>
	</bug>
	<bug id="4225" opendate="2011-07-13 16:16:43" fixdate="2011-10-30 10:55:01" resolution="Fixed">
		<buginformation>
			<summary>camel-mail: add disconnect option</summary>
			<description>A perpetually open connection to an email server can cause problems under various circumstances.  There should therefore be a "disconnect" option (default: false) that causes the connection to be closed after each action taken  mail read from a folder, a message flagged for deletion, a message sent, etc.</description>
			<version>2.8.0</version>
			<fixedVersion>2.8.3, 2.9.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailConfiguration.java</file>
			<file type="M">org.apache.camel.component.mail.MailConsumer.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">4456</link>
		</links>
	</bug>
	<bug id="2740" opendate="2010-05-19 18:22:08" fixdate="2011-11-09 14:36:30" resolution="Fixed">
		<buginformation>
			<summary>Using static queue as a reply queue in InOut pattern causes memory leak</summary>
			<description>I am running JBoss, ActiveMQ and Camel for my application.   In the InOut pattern,  I am using a predefined static queue as a reply queue.   After running for a while,  the memory usage of JBoss keeps growing and growing until it hits outOfMemory error and app server is totally hung.   I monitor the thread in jconsole,  I can see the jms connection/session keeps growing and growing.   
But once I switch to use temp queue for InOut pattern,  this problem goes away.
</description>
			<version>2.2.0</version>
			<fixedVersion>2.7.5, 2.8.3, 2.9.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.reply.MessageSelectorCreator.java</file>
			<file type="M">org.apache.camel.component.jms.reply.PersistentQueueReplyHandler.java</file>
			<file type="M">org.apache.camel.component.jms.reply.PersistentQueueReplyManager.java</file>
			<file type="M">org.apache.camel.support.DefaultTimeoutMap.java</file>
			<file type="M">org.apache.camel.component.jms.reply.CorrelationTimeoutMap.java</file>
			<file type="M">org.apache.camel.processor.routingslip.RoutingSlipTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="3774" opendate="2011-03-10 00:42:49" fixdate="2012-01-05 13:11:44" resolution="Fixed">
		<buginformation>
			<summary>camel-manual generation fails during release process</summary>
			<description>It works during a regular mvn install, but it fails during release:prepare. The bug is somewhere in the maven-html-to-pdf plugin. I hope a mock release using mvn -X will reveal the problem, but would take a frustrating amount of time. For now the available info is the output:


[INFO] [INFO] [html-to-pdf:compile {execution: default}]
[INFO] [INFO] Downloading: http://camel.apache.org/book-in-one-page.html
[INFO] ERROR:  &amp;amp;apos;NOT_FOUND_ERR: An attempt is made to reference a node in a context where it does not exist.&amp;amp;apos;
[INFO] [ERROR] Download or validation of &amp;amp;apos;http://camel.apache.org/book-in-one-page.html&amp;amp;apos; failed: org.apache.camel.CamelException: Failed to convert the HTML to tidy Markup
[INFO] [INFO] Stored dummy file: /w1/apache/release/camel270/tooling/camel-manual/target/site/manual/camel-manual-2.7.0.html since download of http://camel.apache.org/book-in-one-page.html failed.


The error points to a DOM related issue, but since the downloaded manual gets overwritten with the dummy file, I have no idea if the download got interrupted, or in what way the source gets corrupted.</description>
			<version>2.6.0</version>
			<fixedVersion>2.7.5, 2.8.4, 2.9.1, 2.10.0</fixedVersion>
			<type>Task</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.maven.HtmlToPdfMojo.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">4284</link>
		</links>
	</bug>
	<bug id="4882" opendate="2012-01-11 01:10:51" fixdate="2012-01-11 04:21:47" resolution="Fixed">
		<buginformation>
			<summary>Timed out Exchanges should be removed from seda queues</summary>
			<description>When the SedaProducer times out and stops waiting for an Exchange to be processed it should remove it from the queue as well. Same applies to the vm: component.</description>
			<version>2.9.0</version>
			<fixedVersion>2.7.5, 2.8.4, 2.9.1, 2.10.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.seda.SedaProducer.java</file>
			<file type="M">org.apache.camel.component.seda.SedaTimeoutDisabledTest.java</file>
			<file type="M">org.apache.camel.component.seda.SedaTimeoutTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">4901</link>
		</links>
	</bug>
	<bug id="4901" opendate="2012-01-16 07:52:24" fixdate="2012-01-16 08:02:57" resolution="Duplicate">
		<buginformation>
			<summary>SEDA/VM component doesn&amp;apos;t remove the exchange from the producer BlockingQueue if the consumer timeout</summary>
			<description>The fix has been made on trunk (Camel 2.9.1), but I raise this Jira to track it and merge it to 2.8.x branch.</description>
			<version>2.8.3</version>
			<fixedVersion>2.8.4, 2.9.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.seda.SedaProducer.java</file>
			<file type="M">org.apache.camel.component.seda.SedaTimeoutDisabledTest.java</file>
			<file type="M">org.apache.camel.component.seda.SedaTimeoutTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">4882</link>
		</links>
	</bug>
	<bug id="5025" opendate="2012-02-21 14:58:01" fixdate="2012-02-21 15:08:59" resolution="Duplicate">
		<buginformation>
			<summary>The ErrorHandler doesn&amp;apos;t work when Splitter working in Streaming model.</summary>
			<description>When the Splitter working in Streaming model, the error handle does work if the exception is throw from body iterator.


errorHandler(deadLetterChannel("mock:error"));
from("direct:start").
	split(body()).						
		streaming().
		to("mock:end").
	end();


Here is the mail thread[1] which discusses about it.
[1]http://camel.465427.n5.nabble.com/Streaming-splitter-ignores-exception-handling-tt5501036.html#a5501601 </description>
			<version>2.6.0</version>
			<fixedVersion>2.8.5, 2.9.1, 2.10.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">5024</link>
		</links>
	</bug>
	<bug id="5024" opendate="2012-02-21 13:22:54" fixdate="2012-02-22 03:39:05" resolution="Fixed">
		<buginformation>
			<summary>Streaming splitter ignores exception handling</summary>
			<description>If an exception occurs on the next() call of an Iterator in a streaming splitter, the exception is never propagated to the exception or the error handler. This will lead to improper route termination, and inifite rollback/retry cycles.
I attached the minimal test case demonstrating the issue.</description>
			<version>2.8.3</version>
			<fixedVersion>2.8.5, 2.9.1, 2.10.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">5025</link>
			<link type="Reference" description="is related to">5818</link>
			<link type="Regression" description="breaks">5681</link>
		</links>
	</bug>
	<bug id="5255" opendate="2012-05-08 23:15:16" fixdate="2012-05-10 02:40:49" resolution="Fixed">
		<buginformation>
			<summary>Add all SNMPv1 TRAP PDU information to message body for camel-snmp component</summary>
			<description>The attached patch captures additional information available in an SNMPv1 TRAP PDU (enterprise trap ID, agent-addr, generic trap ID, specific trap ID, and system uptime) to the camel-snmp message body.</description>
			<version>2.10.0</version>
			<fixedVersion>2.10.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.snmp.SnmpConverters.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">5251</link>
		</links>
	</bug>
	<bug id="5251" opendate="2012-05-07 23:56:47" fixdate="2012-05-10 07:04:14" resolution="Duplicate">
		<buginformation>
			<summary>camel-snmp component does correctly read SNMPv1 type PDUs from snmp4j</summary>
			<description>SnmpConverters.java of the camel-snmp component inspects the PDU using getVariableBindings().  This method does not contain any information for PDUs representing SNMPv1 messages. The javadoc for org.snmp4j.PDUv1 indicates that unique accessors are provided for PDU instances of this type.  Because of this SnmpConverters.java needs to check if the PDU provided by snmp4j represents an SNMPv1 message and if so use the special accessors to construct the message.
Here is a test case as posted from the user forum. Note that for SNMPv1 type messages the body is empty (Body:&amp;lt;snmp&amp;gt;&amp;lt;/snmp&amp;gt;).
I&amp;amp;apos;m starting to create some simple use cases with Camel and SNMP
traps, and I&amp;amp;apos;m running into some issues (this might just be because I
don&amp;amp;apos;t understand properly what&amp;amp;apos;s going on). My current problem is that
when I create a route for SNMP traps and send SNMP v1 traps to it,
Camel seems to lose information from the trap such as the originating
IP address of the trap.
Here&amp;amp;apos;s what I&amp;amp;apos;m doing: I first generate my camel project with the maven command:
mvn archetype:generate -DarchetypeGroupId=org.apache.camel.archetypes
-DarchetypeArtifactId=camel-archetype-spring -DarchetypeVersion=2.9.2
-DgroupId=camel-snmp-test -DartifactId=camel-snmp-test
And modify the camel-context.xml file to contain the route:
&amp;lt;camel:route&amp;gt;
    &amp;lt;camel:from uri="snmp://0.0.0.0:1162?type=TRAP"/&amp;gt;
    &amp;lt;camel:to uri="log://foo?showAll=true"/&amp;gt;
&amp;lt;/camel:route&amp;gt;
then run the project with:
mvn camel:run
I then generate a trap with the net-snmp command snmptrap and the syntax:
snmptrap -v 1 -c public 127.0.0.1:1162
SNMPv2-MIB::authenticationFailure 1.2.3.4 0 coldStart.0 10
This gives me a log message of:
[PTransportMapping_0.0.0.0/1162] foo                            INFO
Exchange[Id:ID-addict-33083-1335950429878-0-18,
ExchangePattern:InOnly,
Properties:
{CamelToEndpoint=log://foo?showAll=true,
CamelCreatedTimestamp=Wed May 02 10:28:25 WEST 2012}
,
Headers:
{breadcrumbId=ID-addict--33083-1335950429878-0-17}
,
BodyType:String, Body:&amp;lt;snmp&amp;gt;&amp;lt;/snmp&amp;gt;, Out: null]
I&amp;amp;apos;d expect to see the enterprise-oid
(SNMPv2-MIB::authenticationFailure), agent (1.2.3.4), trap-type (0),
specific-type (coldStart.0), and uptime (10 seconds), it would be nice
to see the IP that the PDU came from as well because not all traps
include a useful agent address.
Interestingly, with SNMP v2 traps I get some of this information in
the body (although no sender IP address):
snmptrap -v 2c -c public localhost:1162 &amp;amp;apos;&amp;amp;apos;
SNMPv2-MIB::authenticationFailure SNMPv2-MIB::sysLocation.0 s "just
here"
[PTransportMapping_0.0.0.0/1162] foo                            INFO
Exchange[Id:ID-addict-33083-1335950429878-0-20,
ExchangePattern:InOnly,
Properties:
{CamelToEndpoint=log://foo?showAll=true,
CamelCreatedTimestamp=Wed May 02 11:33:49 WEST 2012}
,
Headers:
{breadcrumbId=ID-addict-33083-1335950429878-0-19}
,
BodyType:String,
Body:&amp;lt;snmp&amp;gt;&amp;lt;entry&amp;gt;&amp;lt;oid&amp;gt;1.3.6.1.2.1.1.3.0&amp;lt;/oid&amp;gt;&amp;lt;value&amp;gt;11 days,
23:15:58.58&amp;lt;/value&amp;gt;&amp;lt;/entry&amp;gt;&amp;lt;entry&amp;gt;&amp;lt;oid&amp;gt;1.3.6.1.6.3.1.1.4.1.0&amp;lt;/oid&amp;gt;&amp;lt;value&amp;gt;1.3.6.1.6.3.1.1.5.5&amp;lt;/value&amp;gt;&amp;lt;/entry&amp;gt;&amp;lt;entry&amp;gt;&amp;lt;oid&amp;gt;1.3.6.1.2.1.1.6.0&amp;lt;/oid&amp;gt;&amp;lt;value&amp;gt;just
here&amp;lt;/value&amp;gt;&amp;lt;/entry&amp;gt;&amp;lt;/snmp&amp;gt;, Out: null]</description>
			<version>2.9.2</version>
			<fixedVersion>2.10.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.snmp.SnmpConverters.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">5255</link>
		</links>
	</bug>
	<bug id="4847" opendate="2012-01-01 21:37:56" fixdate="2012-06-02 12:17:49" resolution="Duplicate">
		<buginformation>
			<summary>Upgrade org.ops4j.pax.exam 1.2.4 -&gt; 2.3.0</summary>
			<description>Pax Exam 2.3.0 is releases. At present we use 1.2.4. We should consider to upgrade to this version.
They fixed 104 issues since 1.2.4 was released.
Query: project = PAXEXAM AND fixVersion &amp;gt; &amp;amp;apos;1.2.4&amp;amp;apos; AND fixVersion &amp;lt;= &amp;amp;apos;2.3.0&amp;amp;apos;</description>
			<version>2.9.0</version>
			<fixedVersion>2.10.0</fixedVersion>
			<type>Task</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.itest.osgi.zookeeper.ZookeeperOSGiTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.jclouds.BlobStoreRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.shiro.ShiroAuthenticationTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.hl7.HL7MLLPCodec2Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.jms.JmsTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.BlueprintExplicitPropertiesRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprintManagedNamePatternFixedTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.hdfs.HdfsBlueprintRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.aws.AwsTestSupport.java</file>
			<file type="M">org.apache.camel.itest.osgi.xstream.XstreamBlueprintRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.bean.validator.BeanValidatorTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.cache.CacheTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprintTcclTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelMultiVersionBlueprintTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.script.GroovyScriptOsgiTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.krati.KratiBlueprintRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprint8Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.cache.replication.CacheReplicationTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.hdfs.HdfsRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.cache.CacheRoutesManagementTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.mail.MailRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.http.HttpTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.freemarker.FreemarkerFileTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.util.jsse.JsseUtilTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.netty.NettyTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.hl7.HL7DataFormatTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.hawtdb.HawtDBAggregateRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.cxf.CxfProxyExampleTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.http4.Http4Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.mina.MinaTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.jetty.OSGiMulitJettyCamelContextsTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.velocity.VelocityBlueprintTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.freemarker.FreemarkerTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.jasypt.JasyptTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.zookeeper.ZookeeperOSGiTestSupport.java</file>
			<file type="M">org.apache.camel.itest.osgi.velocity.VelocityFileTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.jpa.JpaBlueprintRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.leveldb.LevelDBAggregateRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.OSGiBlueprintHelloWorldTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.rss.RssPollingConsumerTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprint4Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.jclouds.BlobStoreBlueprintRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.jaxb.JaxbFallbackConverterTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.hl7.HL7MLLPCodecTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprint5Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.jpa.JpaRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.restlet.example.RestletDomainServiceTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.groovy.GroovyTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.core.xslt.XsltBlueprintRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.stream.StreamTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprint7Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.script.RubyOsgiTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.jaxb.JaxbFallbackConverterSpringTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.cxf.blueprint.CxfBlueprintRouterTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.BlueprintPropertiesRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.quartz.QuartzCronRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.OSGiIntegrationTestSupport.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprint2Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.hazelcast.HazelcastTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.http.HttpTypeConverterTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.krati.KratiRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.protobuf.ProtobufRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.cache.CacheManagerFactoryRefTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.sql.SqlRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.syslog.SyslogTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.AbstractIntegrationTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprintTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprint3Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.beanio.BeanIODataFormatSimpleTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprint6Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.jaxb.JaxbDataFormatTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.mybatis.MyBatisTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.cxf.blueprint.CxfBeanBlueprintRouterTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.dozer.DozerTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.cxf.blueprint.CxfRsBlueprintRouterTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.servlet.ServletComponentTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.velocity.VelocityTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.core.management.OSGiIntegrationManagedCamelContextTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.servlet.ServletServicesTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.ftp.FtpTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.jsch.ScpTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.ftp.FtpConsumeTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.sql.SqlBlueprintRoute.java</file>
			<file type="M">org.apache.camel.itest.osgi.restlet.RestletTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.ahc.AhcTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.cxf.CxfBeanSpringRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.exec.ExecTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">5239</link>
		</links>
	</bug>
	<bug id="5239" opendate="2012-05-02 07:59:14" fixdate="2012-06-04 17:44:46" resolution="Fixed">
		<buginformation>
			<summary>Moving camel-itest-osgi to Pax-Exam 2.x</summary>
			<description>As the pax-exam 2.3 is released for a long time, we should consider to upgrade out osgi integration tests to 2.x.</description>
			<version>2.9.0</version>
			<fixedVersion>2.10.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.itest.osgi.zookeeper.ZookeeperOSGiTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.jclouds.BlobStoreRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.shiro.ShiroAuthenticationTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.hl7.HL7MLLPCodec2Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.jms.JmsTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.BlueprintExplicitPropertiesRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprintManagedNamePatternFixedTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.hdfs.HdfsBlueprintRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.aws.AwsTestSupport.java</file>
			<file type="M">org.apache.camel.itest.osgi.xstream.XstreamBlueprintRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.bean.validator.BeanValidatorTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.cache.CacheTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprintTcclTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelMultiVersionBlueprintTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.script.GroovyScriptOsgiTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.krati.KratiBlueprintRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprint8Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.cache.replication.CacheReplicationTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.hdfs.HdfsRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.cache.CacheRoutesManagementTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.mail.MailRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.http.HttpTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.freemarker.FreemarkerFileTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.util.jsse.JsseUtilTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.netty.NettyTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.hl7.HL7DataFormatTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.hawtdb.HawtDBAggregateRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.cxf.CxfProxyExampleTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.http4.Http4Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.mina.MinaTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.jetty.OSGiMulitJettyCamelContextsTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.velocity.VelocityBlueprintTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.freemarker.FreemarkerTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.jasypt.JasyptTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.zookeeper.ZookeeperOSGiTestSupport.java</file>
			<file type="M">org.apache.camel.itest.osgi.velocity.VelocityFileTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.jpa.JpaBlueprintRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.leveldb.LevelDBAggregateRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.OSGiBlueprintHelloWorldTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.rss.RssPollingConsumerTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprint4Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.jclouds.BlobStoreBlueprintRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.jaxb.JaxbFallbackConverterTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.hl7.HL7MLLPCodecTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprint5Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.jpa.JpaRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.restlet.example.RestletDomainServiceTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.groovy.GroovyTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.core.xslt.XsltBlueprintRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.stream.StreamTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprint7Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.script.RubyOsgiTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.jaxb.JaxbFallbackConverterSpringTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.cxf.blueprint.CxfBlueprintRouterTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.BlueprintPropertiesRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.quartz.QuartzCronRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.OSGiIntegrationTestSupport.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprint2Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.hazelcast.HazelcastTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.http.HttpTypeConverterTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.krati.KratiRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.protobuf.ProtobufRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.cache.CacheManagerFactoryRefTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.sql.SqlRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.syslog.SyslogTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.AbstractIntegrationTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprintTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprint3Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.beanio.BeanIODataFormatSimpleTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.blueprint.CamelBlueprint6Test.java</file>
			<file type="M">org.apache.camel.itest.osgi.jaxb.JaxbDataFormatTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.mybatis.MyBatisTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.cxf.blueprint.CxfBeanBlueprintRouterTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.dozer.DozerTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.cxf.blueprint.CxfRsBlueprintRouterTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.servlet.ServletComponentTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.velocity.VelocityTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.core.management.OSGiIntegrationManagedCamelContextTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.servlet.ServletServicesTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.ftp.FtpTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.jsch.ScpTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.ftp.FtpConsumeTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.sql.SqlBlueprintRoute.java</file>
			<file type="M">org.apache.camel.itest.osgi.restlet.RestletTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.ahc.AhcTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.cxf.CxfBeanSpringRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.exec.ExecTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">4847</link>
		</links>
	</bug>
	<bug id="3104" opendate="2010-09-04 11:38:25" fixdate="2012-09-07 06:22:51" resolution="Fixed">
		<buginformation>
			<summary>ExchangeBuilder to create messages using fluent builder style</summary>
			<description>So you from the Java API using a fluent builder style, can create an Exchange to send, for example with the ProducerTemplate.
Currently you can use a inlined Processor to do that but its a bit ugly and verbose.

Exchange exchange = ExchangeBuilder("activemq:queue:foo").withBody("Hello World").andHeader("JMSReplyTo", "bar").andHeader("foo", 123).create();
template.send(exchange);


The trick is the Exchange has to be created by the producer and hence we need to know the endpoint uri where to send it.</description>
			<version>2.6.0</version>
			<fixedVersion>2.11.0</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.camel.util.ExchangeBuilder.java</file>
			<file type="D">org.apache.camel.util.ExchangeBuilderTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">3752</link>
		</links>
	</bug>
	<bug id="4515" opendate="2011-10-05 04:17:57" fixdate="2013-04-27 06:48:39" resolution="Fixed">
		<buginformation>
			<summary>Spring-WS should populate Camel Header with the SOAP Header</summary>
			<description>Currently the Camel-Spring-WS component does not support the setting of SOAP Headers and has issues getting them. The current issue getting the SOAP Headers when receiving a message is that the resulting header key includes the namespace.
Change the component so that a Camel header "CamelSpringWebserviceSoapHeader" can be populated with an intended SOAP Header for a request, and that this Header is also populated from the SOAP Header on a response.</description>
			<version>2.8.1</version>
			<fixedVersion>2.11.1, 2.12.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.spring.ws.SpringWebserviceConsumer.java</file>
			<file type="M">org.apache.camel.component.spring.ws.SpringWebserviceConstants.java</file>
			<file type="M">org.apache.camel.component.spring.ws.SpringWebserviceProducer.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">5669</link>
		</links>
	</bug>
	<bug id="6541" opendate="2013-07-11 16:51:51" fixdate="2013-07-11 21:01:55" resolution="Fixed">
		<buginformation>
			<summary>DefaultUnitOfWork&amp;apos;s headers for the original message are the same object as the in message headers</summary>
			<description>For jms messages, the useOriginalMessage does not work when headers are changed during the route because the DefaultUnitOfWork&amp;amp;apos;s headers are the same object as the in message&amp;amp;apos;s headers.
In DefaultUnitOfWork, this.originalInMessage.setHeaders(exchange.getIn().getHeaders()); should be changed to create a copy of the headers instead of directly assigning.
Maybe changed to this.originalInMessage.setHeaders((Map&amp;lt;String,Object&amp;gt;) new CaseInsensitiveMap(exchange.getIn().getHeaders()));</description>
			<version>2.8.6</version>
			<fixedVersion>2.10.7, 2.11.2, 2.12.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultUnitOfWork.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">6558</link>
		</links>
	</bug>
	<bug id="6558" opendate="2013-07-17 14:06:11" fixdate="2013-07-18 08:25:54" resolution="Duplicate">
		<buginformation>
			<summary>UnitOfWork.getOriginalInMessage does not restore headers</summary>
			<description>I noticed the map of headers is not restored to its original state when restoring the original message. I can&amp;amp;apos;t imagine this is by design...
Debugging shows the same instance of Map is being used so the "original" message is actually being mutated during the route execution.


exchange.getIn().getHeaders() == exchange.getUnitOfWork().getOriginalInMessage().getHeaders();


Looking into the code of DefaultUnitOfWork it is of note that the incoming message is a JMSMessage (specifically a TibjmsTextMessage)</description>
			<version>2.11.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultUnitOfWork.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">6541</link>
		</links>
	</bug>
	<bug id="5669" opendate="2012-09-30 10:03:03" fixdate="2013-08-16 18:45:37" resolution="Duplicate">
		<buginformation>
			<summary>spring-ws - Adding custom soap headers</summary>
			<description>Look into how it can be possible to add custom soap headers to using spring-ws.
See nabble
http://camel.465427.n5.nabble.com/Adding-custom-soap-header-in-camel-spring-ws-tp5719609.html</description>
			<version>2.8.1</version>
			<fixedVersion>2.11.1</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.spring.ws.SpringWebserviceConsumer.java</file>
			<file type="M">org.apache.camel.component.spring.ws.SpringWebserviceConstants.java</file>
			<file type="M">org.apache.camel.component.spring.ws.SpringWebserviceProducer.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">4515</link>
		</links>
	</bug>
	<bug id="5376" opendate="2012-06-18 12:38:35" fixdate="2013-08-26 18:02:36" resolution="Fixed">
		<buginformation>
			<summary>Mail component does not work as expected (Email Deletion is partially broken et Disconnect does not work well)</summary>
			<description>The way disconnect is implemented causes issues with some other options of the consumer. For instance "disconnect" option is not compatible with "delete" option.
The delete action is done in completion action (processCommit: line 185). On line 305, processCommit method checks if folder is open, but "disconnect" option force folder at null value at the end of poll method (Line 149).
I guess disconnect method should be called on completion after any other completion actions occured: It is not possible to make completion actions if connection to mail server is closed.
The result of the usage of disconnect option and delete option is a NullPointerException on test: "if (!folder.isOpen())" statement on line 308.
Issue should be always reproductible.
I let you fix the priority of the issue, but it is an annoying issue even if there is a workaround by disabling disconnect option ...</description>
			<version>2.9.5</version>
			<fixedVersion>2.11.2, 2.12.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailConsumer.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">6703</link>
		</links>
	</bug>
	<bug id="6703" opendate="2013-09-03 13:13:50" fixdate="2013-09-04 09:06:43" resolution="Duplicate">
		<buginformation>
			<summary>camel-mail - Folder is not open</summary>
			<description>I think I&amp;amp;apos;ve found a bug in camel-mail source (MailConsumer.java)
If you define a mail endpoint which has closeFolder option to true you may encounter a folder is not open exception.
In fact, the delete action occured during processBatch which is set as an exchange&amp;amp;apos;s onCompletion. OnCompletion is executed in a new thread and right after that, we have the finally of the try-catch clause which is executed in a concurrent thread.
Therefore, we can then have a folder that is open at the beginning of the processCommit but becoming closed during the search for an email with the uid because the finally is executed.
Am I wrong or is it a real bug?
I&amp;amp;apos;ve attached MailConsumer.java that should fix this bug.
Cheers!</description>
			<version>2.10.6</version>
			<fixedVersion>2.11.2, 2.12.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailConsumer.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">5376</link>
		</links>
	</bug>
	<bug id="6769" opendate="2013-09-19 08:59:22" fixdate="2013-09-28 10:37:58" resolution="Fixed">
		<buginformation>
			<summary>JndiRegistry - Implement the methods that return empty set</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Proper-way-to-initialize-Transaction-management-for-Camel-in-an-Application-Server-tp5739760.html
We should implement the methods that return empty set. So it would work in the situation from the link</description>
			<version>2.12.0</version>
			<fixedVersion>2.11.3, 2.12.2, 2.13.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.JndiRegistry.java</file>
			<file type="M">org.apache.camel.spi.Registry.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">6798</link>
			<link type="Duplicate" description="is duplicated by">6387</link>
			<link type="Reference" description="is related to">6785</link>
		</links>
	</bug>
	<bug id="6798" opendate="2013-09-29 09:41:40" fixdate="2013-09-29 09:56:37" resolution="Duplicate">
		<buginformation>
			<summary>JPAComponent: unable to find EntityManagerFactory in JNDIRegistry</summary>
			<description>When using a JNDIRegistry in a Camel context to make a JPA EntityManagerFactory available to a JPAComponent (required when running Camel in a Java EE container), the JPAComponent is unable to find it due do this line:
            Map&amp;lt;String, EntityManagerFactory&amp;gt; map = getCamelContext().getRegistry().findByTypeWithName(EntityManagerFactory.class);
since the method findByTypeWithName in JNDIRegistry is unimplemented (returns a null map).
This forces to fallback to a SimpleRegistry or to a Spring registry, thus making impossible to use the JAVA EE container JNDI registry.
Proposted solution: At present, JNDI does not allow lookups based on a class.
My suggestion is to lookup the EntityManagerFactory by a standard name, such as when looking for the default persistence unit name (and eventually adding a property for the JPA URL in order to use a custom name).</description>
			<version>2.12.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.JndiRegistry.java</file>
			<file type="M">org.apache.camel.spi.Registry.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">6769</link>
		</links>
	</bug>
	<bug id="6387" opendate="2013-05-22 23:11:27" fixdate="2013-09-30 13:07:16" resolution="Duplicate">
		<buginformation>
			<summary>Implement JndiRegistry.findByTypeWithName() and findByType() using javax.naming.Context.list("")</summary>
			<description>Implement JndiRegistry.findByTypeWithName() and findByType() using javax.naming.Context.list("").</description>
			<version>2.11.0</version>
			<fixedVersion></fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.JndiRegistry.java</file>
			<file type="M">org.apache.camel.spi.Registry.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">6769</link>
		</links>
	</bug>
	<bug id="6912" opendate="2013-10-29 18:39:47" fixdate="2013-10-31 14:26:13" resolution="Duplicate">
		<buginformation>
			<summary>seda producer doesn&amp;apos;t allow errohandlers to work properly</summary>
			<description>I&amp;amp;apos;m building my route like this:
//context.setTracing(true);
errorHandler(loggingErrorHandler("whatever").level(LoggingLevel.ERROR));
from("direct:start").log("start:
$
{body}").to("seda:seda1?size=2&amp;amp;blockWhenFull=false").log("after: ${body}
");
When I run it and send it 3 messages the first 2 log ok (both "start" and
"after"), but the 3rd message (which fills the seda queue and throws a
"Queue full" exception) only shows up in a "start" log message, no
exception is shown or delivered to my test code, and the route just shuts
down with no ERROR log.
However if I uncomment "context.setTracing(true)", then the 3rd message
triggers my error handler and its "whatever" log message, along with a
stack trace, etc.
My understanding is that the "errorHandler(...)" call sets the error
handler for the entire context.  So why doesn&amp;amp;apos;t it get triggered unless I
turn on tracing?
I&amp;amp;apos;ve attached the entire junit-4 test.
package xp;
import static org.junit.Assert.*;
import org.apache.camel.CamelContext;
import org.apache.camel.LoggingLevel;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.builder.ExchangeBuilder;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultCamelContext;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
public class ErrHandlingCamel
{
    private CamelContext context;
    private ProducerTemplate template;
    @Before
    public void setUp() throws Exception
    {
        context = new DefaultCamelContext();
        template = context.createProducerTemplate();
        context.addRoutes(new RouteBuilder()
        {
            public void configure() throws Exception
            {
                // seda test, queue is full after 2 messages,
                {
                    //context.setTracing(true);
                    errorHandler(loggingErrorHandler("whatever").level(LoggingLevel.ERROR));
                    from("direct:start").log("start: $
{body}").to("seda:seda1?size=2&amp;amp;blockWhenFull=false").log("after: ${body}
");
                }
            }
        });
        context.start();
    }
    @After
    public void tearDown() throws Exception
    {
        template.stop();
        context.stop();
    }

    @Test
    public void testErrHandling() throws Exception
    {
        try
        {
            for (int i = 0; i &amp;lt; 3; i++)
                template.send("direct:start", ExchangeBuilder.anExchange(context).withBody("msg" + i).build());
        }
        catch (Exception ex)
        {
            System.err.println("test failed! caught exception:" + ex);
            ex.printStackTrace(System.err);
            fail();
        }
    }
}</description>
			<version>2.12.1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.seda.SedaErrorTest.java</file>
			<file type="M">org.apache.camel.processor.SendProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">6918</link>
		</links>
	</bug>
	<bug id="6918" opendate="2013-10-31 14:20:09" fixdate="2013-11-04 22:27:38" resolution="Fixed">
		<buginformation>
			<summary>Error handler for SEDA producer doesn&amp;apos;t work</summary>
			<description>Exceptions thrown by seda producer bypass exception handling and bubble up to original caller. 
</description>
			<version>2.12.1</version>
			<fixedVersion>2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.seda.SedaErrorTest.java</file>
			<file type="M">org.apache.camel.processor.SendProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">6912</link>
		</links>
	</bug>
	<bug id="7058" opendate="2013-12-10 14:49:05" fixdate="2013-12-10 14:58:18" resolution="Fixed">
		<buginformation>
			<summary>camel-sql - Setting SQL_ROW_COUNT header is not updated if the header already exists</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/bug-sql-SQL-Component-cannot-change-SQL-ROW-COUNT-header-value-tp5744350.html</description>
			<version>2.12.2</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sql.SqlProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7062" opendate="2013-12-12 10:42:39" fixdate="2013-12-12 13:23:42" resolution="Fixed">
		<buginformation>
			<summary>Tracer, BacklogTracer and BacklogDebugger should stop/shutdown when Camel does that</summary>
			<description>This ensures we cleanup resources nicely.
Also the backlog tracer should remove processor definitions when a route is removed to not keep reference to defintions which are no longer in use.
See nabble
http://camel.465427.n5.nabble.com/BacklogTracer-memory-leak-tp5744561.html</description>
			<version>2.12.0</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.interceptor.DefaultChannel.java</file>
			<file type="M">org.apache.camel.processor.interceptor.BacklogTracer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7061" opendate="2013-12-11 16:32:31" fixdate="2013-12-12 13:39:05" resolution="Fixed">
		<buginformation>
			<summary>DefaultCxfRsBinding only uses Exchange.getOut()</summary>
			<description>When org.apache.camel.component.cxf.jaxrs.DefaultCxfRsBinding is populating the response from an org.apache.camel.Exchange then only the exchange.getOut().getBody() is used.
In the SOAP case org.apache.camel.component.cxf.DefaultCxfBinding the response is either uses  exchange.getOut().getBody() or exchange.getIn().getBody()
See also Discussion for more details.</description>
			<version>2.12.2</version>
			<fixedVersion>2.11.3, 2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.DefaultCxfRsBinding.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">7198</link>
		</links>
	</bug>
	<bug id="7057" opendate="2013-12-10 14:27:45" fixdate="2013-12-14 09:29:03" resolution="Fixed">
		<buginformation>
			<summary>Issue with password having double &amp;&amp;</summary>
			<description>there is an issue with handling password with double &amp;amp;&amp;amp; even when wrapping it into RAW() constraint 
For instance the use of URI 
http://hostname/script.php?authMethod=Basic&amp;amp;authPassword=RAW(pa&amp;amp;&amp;amp;word)&amp;amp;authUsername=usr
throws the exception: 
org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: http://hostname/script.php?authMethod=Basic&amp;amp;authPassword=RAW(pa&amp;amp;&amp;amp;word)&amp;amp;authUsername=usr due to: Invalid uri syntax: Double &amp;amp;&amp;amp; marker found. Check the uri and remove the duplicate &amp;amp; marker. </description>
			<version>2.12.2</version>
			<fixedVersion>2.11.3, 2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="7055" opendate="2013-12-10 07:37:33" fixdate="2013-12-14 10:06:50" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException at FileInputStreamCache.&lt;init&gt;(FileInputStreamCache.java:52) in connection with DataFormat.marshal</summary>
			<description>Stack Trace:


Caused by: java.lang.NullPointerException
	at org.apache.camel.converter.stream.FileInputStreamCache.&amp;lt;init&amp;gt;(FileInputStreamCache.java:52)
	at org.apache.camel.converter.stream.CachedOutputStream.newStreamCache(CachedOutputStream.java:199)
	at org.apache.camel.processor.MarshalProcessor.process(MarshalProcessor.java:79)


Error occurs, if streamCache is true and the stream is put into the file system because the spool threashold is reached. 
The following is happening:
The Marshall Processor handels over to the DataFromat.marshal method a CachedOutputStream instance. In the marschal method data are written into the output stream, when the spool threshold is reached the data are streamed into the file system. Finally the output stream is closed and the CachedOutputStream instance deletes the cached file during closing. The next processor tries to read the FileInputStreamCache and gets the NullPointerException.
Currently this problem can occur in the following DataFormat classes (because they close the stream, which is actually correct):
GzipDataFormat
CryptoDataFormat
PGPDataFormat
SerializationDataFormat
XMLSecurityDataFormat
ZipDataFormat
My proposal is not to delete the cached file during closing the output stream. The cached file shall only be closed on the onCompletion event of the route. See attached patch.
</description>
			<version>2.11.2</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStream.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8134</link>
		</links>
	</bug>
	<bug id="7073" opendate="2013-12-16 15:42:35" fixdate="2013-12-17 02:59:16" resolution="Fixed">
		<buginformation>
			<summary>camel-restlet - request headers are sent in response</summary>
			<description>The fix applied in CAMEL-6879 causes the request headers to be sent back in the response.
DefaultRestletBinding copies the request headers in &amp;amp;apos;org.restlet.http.headers&amp;amp;apos; header to the response headers in &amp;amp;apos;org.restlet.http.headers&amp;amp;apos;.
This causes problems for things like Content-Type header which is a valid request and response header and so the response is sent with the request content-type. Eg, POST requests that should receive JSON in response and send using content-type application/x-www-form-urlencoded will be sent back a response with the same content-type which doesn&amp;amp;apos;t make sense.</description>
			<version>2.12.2</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.DefaultRestletBinding.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">6879</link>
		</links>
	</bug>
	<bug id="7087" opendate="2013-12-20 12:16:45" fixdate="2013-12-20 17:28:20" resolution="Fixed">
		<buginformation>
			<summary>StreamCache does not reset at the end of the pipeline</summary>
			<description>The StreamCache does not reset at the end of the pipeline.
The following routes will not work as expected:
   from("direct:c").noStreamCaching().to("direct:d").to("mock:c");
   from("direct:d").streamCaching().process(new TestProcessor());
(the test processor is a processor that reads the InputMessage)
If another processor is added after the TestProcessor that does nothing, the routes will work as expected.
This case is a bit synthetic, but in real life a route that starts with a InOut CXF endpoint, has an endpoint that generates a Stream and then writes the message content to an in only endpoint (file, FTP, log, etc.) will also fail, even if stream caching is enabled.</description>
			<version>2.12.2</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.CamelInternalProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="7096" opendate="2013-12-26 14:56:59" fixdate="2013-12-26 15:08:48" resolution="Fixed">
		<buginformation>
			<summary>The ObjectHelper#createIterator utility should properly adhere the java.util.Iterator contract</summary>
			<description>According to the java.util.Iterator#next() contract the implementation should throw NoSuchElementException if the iteration has no more elements. However this is currently not the case by the different anonymous class implemetations of this interface through ObjectHelper#createIterator().
The side effect of this is that currently this could end up with IndexOutOfBoundsException and what not if one would iterate over the Node(s) of a DOM NodeList. Another example is that calling next() on the Iterator returned for an empty String repeatedly doesn&amp;amp;apos;t throw  any NoSuchElementException although it&amp;amp;apos;s hasNext() method returns false!
We should better provide guards for the condition when there&amp;amp;apos;s no more elements available in which case a NoSuchElementException should be thrown.</description>
			<version>2.12.2</version>
			<fixedVersion>2.11.3, 2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.util.ObjectHelperTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7102" opendate="2014-01-02 02:02:28" fixdate="2014-01-03 04:43:33" resolution="Fixed">
		<buginformation>
			<summary>Broken JUnit classes for testing authentication in camel-jcr</summary>
			<description>The following JUnit tests that are supposed to test authentication with the camel-jcr component are currently broken and disabled (annotated @Ignore):

AuthTokenLoginFailureTest
JcrAuthTokenWithLoginTest

Testing authentication in camel-jcr (i.e. connection URI parsing) is essential and should be fixed.</description>
			<version>2.12.2</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jcr.AuthTokenLoginFailureTest.java</file>
			<file type="M">org.apache.camel.component.jcr.JcrAuthTokenWithLoginTest.java</file>
			<file type="M">org.apache.camel.component.jcr.JcrAuthTestBase.java</file>
			<file type="M">org.apache.camel.component.jcr.JcrRouteTestSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="7100" opendate="2013-12-27 14:14:33" fixdate="2014-01-03 07:25:59" resolution="Fixed">
		<buginformation>
			<summary>CLONE - Camel Splitter eat up exceptions recorded by the underlying Scanner</summary>
			<description>See http://camel.465427.n5.nabble.com/Trouble-with-split-tokenize-on-linux-td5721677.html for details</description>
			<version>2.9.4</version>
			<fixedVersion>2.11.3, 2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.Splitter.java</file>
			<file type="M">org.apache.camel.processor.SplitterWithScannerIoExceptionTest.java</file>
			<file type="M">org.apache.camel.util.IOHelper.java</file>
			<file type="M">org.apache.camel.util.GroupIterator.java</file>
		</fixedFiles>
		<links>
			<link type="Cloners" description="is a clone of">5767</link>
		</links>
	</bug>
	<bug id="7052" opendate="2013-12-09 21:25:32" fixdate="2014-01-04 13:27:43" resolution="Fixed">
		<buginformation>
			<summary>PGPDataFormat: Unable to encrypt using subkey</summary>
			<description>Generate a keyring with a DSA key for signing and an Elgamal key for encryption, using the password "secret":

&amp;gt;gpg --gen-key
gpg (GnuPG) 2.0.17; Copyright (C) 2011 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
Your selection? 2
DSA keys may be between 1024 and 3072 bits long.
What keysize do you want? (2048) 2048
Requested keysize is 2048 bits
Please specify how long the key should be valid.
         0 = key does not expire
      &amp;lt;n&amp;gt;  = key expires in n days
      &amp;lt;n&amp;gt;w = key expires in n weeks
      &amp;lt;n&amp;gt;m = key expires in n months
      &amp;lt;n&amp;gt;y = key expires in n years
Key is valid for? (0) 0
Key does not expire at all
Is this correct? (y/N) y

GnuPG needs to construct a user ID to identify your key.

Real name: Testing
Email address: testing@foo.com
Comment:
You selected this USER-ID:
    "Testing &amp;lt;testing@foo.com&amp;gt;"

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O
You need a Passphrase to protect your secret key.

We need to generate a lot of random bytes. It is a good idea to perform
some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.
gpg: WARNING: some OpenPGP programs can&amp;amp;apos;t handle a DSA key with this digest size
We need to generate a lot of random bytes. It is a good idea to perform
some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.
gpg: key C49B82A0 marked as ultimately trusted
public and secret key created and signed.

gpg: checking the trustdb
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u
pub   2048D/C49B82A0 2013-12-09
      Key fingerprint = AB15 5E15 768E E6FE 96AB  2423 6488 CEA7 C49B 82A0
uid                  Testing &amp;lt;testing@foo.com&amp;gt;
sub   2048g/361D9AA1 2013-12-09

List the keys to make sure they look OK:

&amp;gt;gpg --list-keys
pubring.gpg
---------------
pub   2048D/C49B82A0 2013-12-09
uid                  Testing &amp;lt;testing@foo.com&amp;gt;
sub   2048g/361D9AA1 2013-12-09

Export to a file and then check the contents of the file:

&amp;gt;gpg --export &amp;gt; pubring.pgp

&amp;gt;gpg pubring.pgp
pub  2048D/C49B82A0 2013-12-09 Testing &amp;lt;testing@foo.com&amp;gt;
sub  2048g/361D9AA1 2013-12-09

We now have a keyring that contains a primary DSA key for signing, and an Elgamal subkey for encryption. The subkey does not have a user ID associated with it, because the user ID is associated with the corresponding primary / master key.
The latest code in PGPDataFormatUtil.findPublicKeys(InputStream, List&amp;lt;String&amp;gt;, boolean) cannot handle this scenario, because it expects the subkey to also have a user ID. Only the first key in a keychain (which is the primary / master key) will have a user ID. The subkeys don&amp;amp;apos;t have user IDs directly associated with them, and so they are not recognized as usable by Camel, when in fact they are usable.
See this discussion for more info on how primary keys and subkeys are represented in the BouncyCastle model, and how this relates to user IDs:
http://bouncy-castle.1462172.n4.nabble.com/How-to-find-PGP-subkeys-td1465289.html</description>
			<version>2.12.2</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.crypto.PGPDataFormatUtil.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">7106</link>
		</links>
	</bug>
	<bug id="7111" opendate="2014-01-07 08:42:40" fixdate="2014-01-07 09:17:59" resolution="Fixed">
		<buginformation>
			<summary>Multicast EIP with only one child processor does not call aggregate strategy</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/multicast-aggregation-tp5745571.html</description>
			<version>2.12.2</version>
			<fixedVersion>2.11.3, 2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.MulticastDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="7116" opendate="2014-01-09 11:31:28" fixdate="2014-01-10 09:04:57" resolution="Fixed">
		<buginformation>
			<summary>JettyHttpProducer.doStop does not stop client thread pool</summary>
			<description>Case:
CamelContext with one route :
from("direct:a")
 .routingSlip(generateHttpUrl())
Where generateHttpUrl() returns  for example:
"jetty:http://someurl.com:666/some?httpClientMinThreads=128&amp;amp;"
When CamelContext is closing, JettyHttpProducer.doStop is not called.
Result:

When JettyHttpProducer.client is closing, its thread pool is not closed and the threads are non-deamon threads (subject to another JIRA),  so application cannot be shutdown.

</description>
			<version>2.12.2</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyHttpProducer.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">7117</link>
		</links>
	</bug>
	<bug id="7120" opendate="2014-01-09 22:46:31" fixdate="2014-01-10 09:29:40" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException on BindyFixedLengthFactory.unbind()</summary>
			<description>The Camel Bindy component throws a NullPointerException on unbind when you&amp;amp;apos;ve specified a header, but no footer. It looks like there was a simple copy/paste error in the marshal method. When generating the models, it checks the headerRow for null and then adds the headerRow. It then checks the headerRow (not the footerRow) for null and then adds the footerRow. Later down the chain, the BindyFixedLengthFactory throws a null exception when it tries to call getName() on the model Class.</description>
			<version>2.12.0</version>
			<fixedVersion>2.11.4, 2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.bindy.fixed.BindyFixedLengthDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="7107" opendate="2014-01-06 13:14:17" fixdate="2014-01-10 10:55:56" resolution="Fixed">
		<buginformation>
			<summary>camel-sjms NullPointerException in case of connection loss</summary>
			<description>When connection to a broker (HornetQ) is destroyed due to networking issues or broker internal issues or restarts the getProducers().borrowObject() returns null which is not handled properly.</description>
			<version>2.13.0</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sjms.producer.InOnlyProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7142" opendate="2014-01-17 20:08:12" fixdate="2014-01-18 12:15:35" resolution="Fixed">
		<buginformation>
			<summary>CsvDataFormat unmarshal overwrites delimiter in static CSVStrategy strategies</summary>
			<description>The unmarshal function in CsvDataFormat contains the following line:


strategy.setDelimiter(config.getDelimiter());


This can cause problems when multiple CsvDataFormats are used which rely on the default CSVStrategy or one of the other static CSVStrategy objects.
Here is sample code to demonstrate the problem:


final CsvDataFormat csv = new CsvDataFormat();
final CsvDataFormat tsv = new CsvDataFormat();
tsv.setDelimiter("\t");

context.addRoutes(new RouteBuilder() {
    @Override
    public void configure() throws Exception {
        from("file:///tmp/?include=.*.csv")
                .unmarshal(csv)
                .process(new MyProcessor());
        from("file:///tmp/?include=.*.tsv")
                .unmarshal(tsv)
                .process(new MyProcessor());
    }
});


Running the code above with several files with 2 lines, 9 columns per line and comma or tab delimiters returns the following (the exact values may be different from run to run):


File: 0.tsv, lines: 2
  Line 1 columns: 9
  Line 2 columns: 9
File: 0.csv, lines: 2
  Line 1 columns: 1
  Line 2 columns: 1
File: 1.csv, lines: 2
  Line 1 columns: 2
  Line 2 columns: 1
File: 1.tsv, lines: 2
  Line 1 columns: 9
  Line 2 columns: 9


These should all show 9 columns.
Adding the following lines corrects the problem, because each DataFormat has its own CSVStrategy:


csv.setStrategy(new CSVStrategy(&amp;amp;apos;,&amp;amp;apos;, &amp;amp;apos;"&amp;amp;apos;, &amp;amp;apos;#&amp;amp;apos;));
tsv.setStrategy(new CSVStrategy(&amp;amp;apos;\t&amp;amp;apos;, &amp;amp;apos;"&amp;amp;apos;, &amp;amp;apos;#&amp;amp;apos;));


The suggested fix would be for the CsvDataFormat to have its own copy of its CSVStrategy instead of using what amounts to a pointer to another CSVStrategy. Perhaps setStrategy should be changed to do that. This is tedious because CSVStrategy has no copy constructor and has many properties, but would be a defensive way to do it.
Note also that the example at http://camel.apache.org/csv.html under "Unmarshalling with a pipe as delimiter" actually alters the CSVStrategy.DEFAULT_STRATEGY, so any subsequent CsvDataFormat objects created would have a pipe as the delimiter.</description>
			<version>2.12.2</version>
			<fixedVersion>2.11.4, 2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.csv.CsvDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.csv.CsvUnmarshalTwoCsvDataFormatConcurrentTest.java</file>
			<file type="D">org.apache.camel.dataformat.csv.CsvUnmarshalTwoCsvDataFormatTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7132" opendate="2014-01-13 23:21:33" fixdate="2014-01-28 13:20:02" resolution="Fixed">
		<buginformation>
			<summary>QuartzComponent with custom Scheduler and multiple contexts requires JMX to be enabled</summary>
			<description>If you have a custom Scheduler set on the QuartzComponent and multiple camel contexts per scheduler, then you must have JMX enabled for it work right.  Ideally, it should not require JMX to be enabled to work correctly.  Specifically, QuartzComponent.onCamelContextStarted(CamelContext, boolean) will make a map key that depends on the context&amp;amp;apos;s managementName, which is not set if JMX is not enabled.  Without a managementName, all contexts with quartz routes end up with a key named CamelQuartzCamelContext - null, and then when the CamelJob executes it will retrieve the wrong context.
Note we worked around this by injecting a custom LifecycleStrategy that sets the managementName in onContextStart().  But ideally we shouldn&amp;amp;apos;t have to do that.</description>
			<version>2.11.2</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.quartz2.QuartzComponent.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzComponent.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzEndpoint.java</file>
			<file type="M">org.apache.camel.component.quartz2.QuartzEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="7069" opendate="2013-12-13 19:08:59" fixdate="2014-01-29 11:38:08" resolution="Fixed">
		<buginformation>
			<summary>Sending an empty soap body message to a generic provider camel-cxf consumer results in NPE</summary>
			<description>In some cases, CXFPayload is instantiated with a null body and this is causing an NPE later in the processing.
Caused by: java.lang.NullPointerException
	at org.apache.camel.component.cxf.CxfPayload$1.size(CxfPayload.java:105)
	at org.apache.camel.component.cxf.converter.NodeListWrapper.getLength(NodeListWrapper.java:33)
	at org.apache.camel.converter.jaxp.DomConverter.toString(DomConverter.java:69)
	at org.apache.camel.converter.jaxp.DomConverter.toByteArray(DomConverter.java:142)
	at org.apache.camel.converter.jaxp.DomConverter.toInputStream(DomConverter.java:137)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
What is not sure is how we should fix it.
CXFPayload is not checking whether the body is null when it is instantiated. In that case, some methods will lead to NPE but some are not (like getBodySources() or getHeaders()). And there are some test cases passing a null body.
So I think, we should either 
1. change CXFPayload to automatically creates an empty body (i.e., an empty List&amp;lt;Source&amp;gt;) when the body passed to the constructor is null, or
2. add this null-&amp;gt;empty handling in DefaultCXFBinding.getPayloadBodyElements when extracting the body and pass an empty list to the CXFPayload constructor in this case, or
3. just throws a specific exception instead of NPE in this particular case.
In any case, we need to clarify what is the correct usage of CXFPayload.
</description>
			<version>2.12.2</version>
			<fixedVersion>2.11.4, 2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBindingTest.java</file>
			<file type="M">org.apache.camel.component.cxf.converter.CxfPayloadConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="7143" opendate="2014-01-20 17:49:35" fixdate="2014-01-31 16:24:43" resolution="Fixed">
		<buginformation>
			<summary>camel-groovy - Evaluation returns 1st result only</summary>
			<description>Seems like we have another issue reported which we couldn&amp;amp;apos;t reproduce.
But maybe this time we can.
Issue at SO
http://stackoverflow.com/questions/21221085/strange-behaiour-with-camel-groovy-spring-dsl
</description>
			<version>2.11.2</version>
			<fixedVersion>2.11.4, 2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.script.ScriptLanguage.java</file>
			<file type="M">org.apache.camel.builder.script.ScriptBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">6988</link>
		</links>
	</bug>
	<bug id="7161" opendate="2014-02-03 09:37:44" fixdate="2014-02-03 09:39:35" resolution="Fixed">
		<buginformation>
			<summary>camel-dozer - Can cause dead-lock in init when using spring</summary>
			<description>When using spring with dozer, and we call init in the ctr, then spring can cause a dead lock when it does its getBean stuff.


   java.lang.Thread.State: BLOCKED (on object monitor)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:182)
	- waiting to lock &amp;lt;0x00000007d7c4ca38&amp;gt; (a java.util.concurrent.ConcurrentHashMap)
	at org.springframework.beans.factory.support.AbstractBeanFactory.isTypeMatch(AbstractBeanFactory.java:468)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doGetBeanNamesForType(DefaultListableBeanFactory.java:356)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:334)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:434)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:428)
	at org.springframework.context.support.AbstractApplicationContext.getBeansOfType(AbstractApplicationContext.java:1182)
	at org.springframework.beans.factory.BeanFactoryUtils.beansOfTypeIncludingAncestors(BeanFactoryUtils.java:228)
	at org.apache.camel.spring.spi.ApplicationContextRegistry.findByTypeWithName(ApplicationContextRegistry.java:85)
	at org.apache.camel.impl.PropertyPlaceholderDelegateRegistry.findByTypeWithName(PropertyPlaceholderDelegateRegistry.java:70)
	at org.apache.camel.converter.dozer.DozerTypeConverterLoader.lookupDozerBeanMapperConfigurations(DozerTypeConverterLoader.java:228)
	at org.apache.camel.converter.dozer.DozerTypeConverterLoader.init(DozerTypeConverterLoader.java:155)


We should defer init to a bit later, and turn the loader into a service so init is done like the others with start|stop methods.</description>
			<version>2.12.2</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.dozer.DozerTypeConverterLoader.java</file>
		</fixedFiles>
	</bug>
	<bug id="7160" opendate="2014-02-03 09:25:38" fixdate="2014-02-03 13:55:28" resolution="Fixed">
		<buginformation>
			<summary>Throttling has problems with rate changes</summary>
			<description>When using the throttler with the header expression for controlling the rate, changing the rate does not work reliably. 
Some more information can be found in the following mail thread:
http://camel.465427.n5.nabble.com/Problems-with-dynamic-throttling-td5746613.html</description>
			<version>2.12.2</version>
			<fixedVersion>2.11.4, 2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.Throttler.java</file>
			<file type="M">org.apache.camel.processor.ThrottlerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7159" opendate="2014-01-31 16:00:58" fixdate="2014-02-03 14:12:17" resolution="Fixed">
		<buginformation>
			<summary>camel-bindy not picking up @Link annotation items</summary>
			<description>It works fine (like in the tests) when you provide bindy with a Map&amp;lt;String, Object&amp;gt; of model objects corresponding to the @Linked-ed classes. We should do better though and try to figure this out for users.</description>
			<version>2.12.2</version>
			<fixedVersion>2.11.4, 2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindyCsvDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="7139" opendate="2014-01-17 16:47:11" fixdate="2014-02-03 14:17:23" resolution="Fixed">
		<buginformation>
			<summary>Problem with MvelExpression class visibility between camel bundles</summary>
			<description>http://camel.465427.n5.nabble.com/Problem-with-camel-routes-running-in-apache-karaf-2-3-3-td5745929.html
I am having problems with with class visibility between osgi bundles when using camel 2.12 and 2.13-SNAPSHOT. I have created a showcase to reproduce the problem based on camel example projects. I have tested the created solution in camel 2.10 and problem does not exist.
I have created a sample application which is able to reproduce the problem. Please pick it up from my forked repo:
https://github.com/andrzej-majewski/camel/tree/MvelExpression-class-visibility
The problem occurs when

camel-example-osgi-domain - project containing only domain classes required by different osgi projects ex.( org.apache.camel.example.osgi.domain.MyPojo )
camel-example-osgi-mvel -  example project which has dependency on camel-example-osgi-domain

Now camel-example-osgi-mvel has following camel context.


&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;   
&amp;lt;beans xmlns="http://www.springframework.org/schema/beans"  
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
       xmlns:camel="http://camel.apache.org/schema/spring"  
       xsi:schemaLocation="   
         http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd  
         http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd"&amp;gt;  
  
    
  &amp;lt;camelContext xmlns="http://camel.apache.org/schema/spring"&amp;gt;  
  
    &amp;lt;route&amp;gt;  
      &amp;lt;from uri="timer://mytestTrigger?fixedRate=true&amp;amp;amp;period=10000"/&amp;gt;  
      &amp;lt;to uri="myTestFactory"/&amp;gt;  
    &amp;lt;/route&amp;gt;  
    &amp;lt;route id="mvelTest"&amp;gt;  
      &amp;lt;from uri="seda://myMvelTest?concurrentConsumers=2"/&amp;gt;  
      &amp;lt;choice&amp;gt;  
      &amp;lt;when&amp;gt;  
        &amp;lt;mvel&amp;gt;request.body instanceof org.apache.camel.example.osgi.MyPojo&amp;lt;/mvel&amp;gt;  
      &amp;lt;to uri="log:MvelRouter"/&amp;gt;  
      &amp;lt;/when&amp;gt;            
      &amp;lt;/choice&amp;gt;  
    &amp;lt;/route&amp;gt;  
          
  &amp;lt;/camelContext&amp;gt;  
  
  &amp;lt;bean id="myTestFactory" class="org.apache.camel.example.osgi.MyTestFactory"&amp;gt;  
    &amp;lt;property name="numberOfMessages" value="2"/&amp;gt;  
  &amp;lt;/bean&amp;gt;  
  
&amp;lt;/beans&amp;gt;


When I deploy both feature to karaf and place a message on seda://myMvelTest queue I get following exception in karaf.


ERROR | eda://myMvelTest | DefaultErrorHandler              | rg.apache.camel.util.CamelLogger  215 | 73 - org.apache.camel.camel-core - 2.13.0.SNAPSHOT | Failed delivery for (MessageId: ID-localhost-51000-1389691121739-1-56 on ExchangeId: ID-localhost-51000-1389691121739-1-85). Exhausted after delivery attempt: 1 caught: org.apache.camel.ExpressionEvaluationException: [Error: could not access: org; in class: org.apache.camel.language.mvel.RootObject]
[Near : {... est.body instanceof org.apache.camel.example.osgi. ....}]
                                 ^
[Line: 1, Column: 25]
 
Message History
---------------------------------------------------------------------------------------------------------------------------------------
RouteId              ProcessorId          Processor                                                                        Elapsed (ms)
[mvelTest          ] [mvelTest          ] [seda://myMvelTest?concurrentConsumers=2                                       ] [        14]
[mvelTest          ] [choice2           ] [when[mvel{Mvel[request.body instanceof org.apache.camel.example.osgi.MyPojo]}]] [         0]
 
Exchange
---------------------------------------------------------------------------------------------------------------------------------------
Exchange[
        Id                  ID-localhost-51000-1389691121739-1-85
        ExchangePattern     InOut
        Headers             {breadcrumbId=ID-localhost-51000-1389691121739-1-56, CamelRedelivered=false, CamelRedeliveryCounter=0}
        BodyType            org.apache.camel.example.osgi.MyPojo
        Body                org.apache.camel.example.osgi.MyPojo@21093d9e
]
 
Stacktrace
---------------------------------------------------------------------------------------------------------------------------------------
org.apache.camel.ExpressionEvaluationException: [Error: could not access: org; in class: org.apache.camel.language.mvel.RootObject]
[Near : {... est.body instanceof org.apache.camel.example.osgi. ....}]
                                 ^
[Line: 1, Column: 25]
        at org.apache.camel.language.mvel.MvelExpression.evaluate(MvelExpression.java:60)[103:org.apache.camel.camel-mvel:2.13.0.SNAPSHOT]
        at org.apache.camel.support.ExpressionSupport.matches(ExpressionSupport.java:32)[73:org.apache.camel.camel-core:2.13.0.SNAPSHOT]
        at org.apache.camel.processor.ChoiceProcessor.process(ChoiceProcessor.java:90)[73:org.apache.camel.camel-core:2.13.0.SNAPSHOT]
        at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)[73:org.apache.camel.camel-core:2.13.0.SNAPSHOT]
        at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)[73:org.apache.camel.camel-core:2.13.0.SNAPSHOT]
        at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.13.0.SNAPSHOT]
        at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.13.0.SNAPSHOT]
        at org.apache.camel.component.seda.SedaConsumer.sendToConsumers(SedaConsumer.java:291)[73:org.apache.camel.camel-core:2.13.0.SNAPSHOT]
        at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:200)[73:org.apache.camel.camel-core:2.13.0.SNAPSHOT]
        at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:147)[73:org.apache.camel.camel-core:2.13.0.SNAPSHOT]
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895)[:1.6.0_65]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918)[:1.6.0_65]
        at java.lang.Thread.run(Thread.java:695)[:1.6.0_65]
Caused by: [Error: could not access: org; in class: org.apache.camel.language.mvel.RootObject]
[Near : {... est.body instanceof org.apache.camel.example.osgi. ....}]
                                 ^
[Line: 1, Column: 25]
        at org.mvel2.optimizers.impl.refl.ReflectiveAccessorOptimizer.getBeanProperty(ReflectiveAccessorOptimizer.java:683)[102:org.mvel2:2.1.7.Final]
        at org.mvel2.optimizers.impl.refl.ReflectiveAccessorOptimizer.compileGetChain(ReflectiveAccessorOptimizer.java:337)[102:org.mvel2:2.1.7.Final]
        at org.mvel2.optimizers.impl.refl.ReflectiveAccessorOptimizer.optimizeAccessor(ReflectiveAccessorOptimizer.java:140)[102:org.mvel2:2.1.7.Final]
        at org.mvel2.optimizers.dynamic.DynamicOptimizer.optimizeAccessor(DynamicOptimizer.java:67)[102:org.mvel2:2.1.7.Final]
        at org.mvel2.ast.ASTNode.optimize(ASTNode.java:159)[102:org.mvel2:2.1.7.Final]
        at org.mvel2.ast.ASTNode.getReducedValueAccelerated(ASTNode.java:115)[102:org.mvel2:2.1.7.Final]
        at org.mvel2.ast.Instance.getReducedValueAccelerated(Instance.java:21)[102:org.mvel2:2.1.7.Final]
        at org.mvel2.compiler.ExecutableAccessor.getValue(ExecutableAccessor.java:42)[102:org.mvel2:2.1.7.Final]
        at org.mvel2.MVEL.executeExpression(MVEL.java:954)[102:org.mvel2:2.1.7.Final]
        at org.apache.camel.language.mvel.MvelExpression.evaluate(MvelExpression.java:57)[103:org.apache.camel.camel-mvel:2.13.0.SNAPSHOT]

</description>
			<version>2.12.2</version>
			<fixedVersion>2.11.4, 2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.language.mvel.MvelExpression.java</file>
		</fixedFiles>
	</bug>
	<bug id="7163" opendate="2014-02-03 19:11:38" fixdate="2014-02-03 19:15:09" resolution="Fixed">
		<buginformation>
			<summary>BacklogDebugger - Should not change body/header type to string</summary>
			<description>When using the backlog debugger then updating the body/headers would currently force those to become string type.
We should preserve existing type, and allow end users to specify a new type. And also make it possible to remove body/headers as well.</description>
			<version>2.12.2</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.BacklogDebuggerTest.java</file>
			<file type="M">org.apache.camel.management.mbean.ManagedBacklogDebugger.java</file>
			<file type="M">org.apache.camel.api.management.mbean.ManagedBacklogDebuggerMBean.java</file>
			<file type="M">org.apache.camel.processor.interceptor.BacklogDebugger.java</file>
		</fixedFiles>
	</bug>
	<bug id="7172" opendate="2014-02-05 09:11:39" fixdate="2014-02-05 10:09:31" resolution="Fixed">
		<buginformation>
			<summary>camel-netty - Some options in netty configuration do not support # lookup</summary>
			<description>For example passphrase does not support passphrase=#myPassword, to lookup a bean with that id that produces the password to use.
There is a few others as well.</description>
			<version>2.12.2</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultComponentTest.java</file>
			<file type="M">org.apache.camel.component.netty.NettyConfiguration.java</file>
			<file type="M">org.apache.camel.impl.DefaultComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="7173" opendate="2014-02-05 09:55:03" fixdate="2014-02-05 10:44:54" resolution="Fixed">
		<buginformation>
			<summary>Default value on jmxAgent createConnector should be &amp;apos;false&amp;apos;</summary>
			<description>The defalult value is set to true. Should have been false
see http://camel.465427.n5.nabble.com/disabeling-loadStatistics-td5746709.html</description>
			<version>2.12.2</version>
			<fixedVersion>2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.core.xml.CamelJMXAgentDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="7167" opendate="2014-02-04 13:10:00" fixdate="2014-02-05 11:57:02" resolution="Fixed">
		<buginformation>
			<summary>AbstractListAggregationStrategy : at the end of the split, the body is not replaced by the agregated list</summary>
			<description>Using a class that extends AbstractListAggregationStrategy to rebuild a List after the completion of the split cause the body not to be replaced by the agregated list at the end of the split.
In other words (AbstractListAggregationStrategy.onCompletion(Exchange exchange) is never called.
Here is what I do :
from(HANDLE_A_LIST)//
            .split(body(), new ListAggregationStrategy())// body is an arrayList of String
            .to("log:foo")//
            .end()// end split
            // the body is a string instead of a List
            .end()// end route
class ListAggregationStrategy extends AbstractListAggregationStrategy&amp;lt;String&amp;gt;
    {
        @Override
        public String getValue(Exchange exchange)
        {
            return exchange.getIn().getBody();
        }
    }
As workaround, I use .setBody(property(Exchange.GROUPED_EXCHANGE)) after the end of the split.</description>
			<version>2.12.1</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="7146" opendate="2014-01-22 08:32:29" fixdate="2014-02-06 09:51:40" resolution="Fixed">
		<buginformation>
			<summary>NPE in Aggregator when completionSize = 1</summary>
			<description>A Camel aggregator with persistence repository cannot have a completionSize of 1. If this is configured, every message produces a NPE with the attached stacktrace. 
I have also attached a small example project that shows the Exception. As soon as the completionSize is &amp;gt; 1, it runs fine.
This is just a minor flaw, since I cannot think about a really useful case with completionSize 1, but it worked with earlier versions of Camel. 
As an alternative (if completionSize 1 should not be used), Camel could throw an error during Context startup when completionSize &amp;lt; 2.</description>
			<version>2.12.2</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spi.AggregationRepository.java</file>
			<file type="M">org.apache.camel.processor.aggregate.AggregateProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="7112" opendate="2014-01-07 16:47:14" fixdate="2014-02-06 16:42:25" resolution="Fixed">
		<buginformation>
			<summary>A single call of consumerTemplate.receiveBody consumes more than one messages from a SEDA queue</summary>
			<description>When using consumer template&amp;amp;apos;s receiveBody on a SEDA queue that has multiple exchanges, a single call of receiveBody consumed more than one messages from the queue.  This happens for both receiveBody and receiveBodyNoWait.
I will attach a test project that can produce this issue.</description>
			<version>2.12.2</version>
			<fixedVersion>2.11.4, 2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.seda.SedaEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="7125" opendate="2014-01-10 16:57:28" fixdate="2014-02-07 09:38:02" resolution="Fixed">
		<buginformation>
			<summary>tokenizeXml fails when attributes have a / in them</summary>
			<description>tokenizeXml does not work or produce value xml output when attributes contain a /.
The test below will fail under 2.12.2


import org.apache.camel.EndpointInject;
import org.apache.camel.Produce;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.test.junit4.CamelTestSupport;
import org.junit.Test;

public class CamelTokenizeXmlTest extends CamelTestSupport {

  @EndpointInject(uri = "mock:result")
  protected MockEndpoint resultEndpoint;
  @Produce(uri = "direct:start")
  protected ProducerTemplate template;

  @Test
  public void testXmlWithSlash() throws Exception {
    String message = "&amp;lt;parent&amp;gt;&amp;lt;child attr=&amp;amp;apos;/&amp;amp;apos; /&amp;gt;&amp;lt;/parent&amp;gt;";
    resultEndpoint.expectedBodiesReceived("&amp;lt;child attr=&amp;amp;apos;/&amp;amp;apos; /&amp;gt;");
    template.sendBody(message);
    resultEndpoint.assertIsSatisfied();
  }

  @Override
  protected RouteBuilder createRouteBuilder() {
    return new RouteBuilder() {
      @Override
      public void configure() {
        from("direct:start").split().tokenizeXML("child").to("mock:result");
      }
    };
  }
}

</description>
			<version>2.12.2</version>
			<fixedVersion>2.11.4, 2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.SplitTokenizerTest.java</file>
			<file type="M">org.apache.camel.support.TokenXMLExpressionIterator.java</file>
		</fixedFiles>
	</bug>
	<bug id="6565" opendate="2013-07-21 18:51:46" fixdate="2014-02-07 21:26:53" resolution="Duplicate">
		<buginformation>
			<summary>Component for Apache Kafka</summary>
			<description>I have written a component for Apache Kafka. 
If someone makes a blank wiki page I will edit it for documentation.
Kafka uses Apache license obviously. The other dependencies are https://github.com/sgroschupf/zkclient and https://github.com/codahale/metrics which are both Apache also.</description>
			<version>2.13.0</version>
			<fixedVersion>2.13.0</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.kafka.KafkaEndpoint.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaConstants.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaConsumer.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaComponent.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaConsumerTest.java</file>
			<file type="M">org.apache.camel.component.kafka.SimplePartitioner.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaComponentTest.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaConsumerIT.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaProducer.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaEndpointTest.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaProducerTest.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaProducerIT.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">7092</link>
			<link type="Duplicate" description="is duplicated by">7092</link>
		</links>
	</bug>
	<bug id="7182" opendate="2014-02-08 08:03:33" fixdate="2014-02-08 08:32:02" resolution="Fixed">
		<buginformation>
			<summary>camel-guice - PostConstruct do not throw checked exception</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/GuiceCamelContext-checked-exception-issue-with-Glassfish4-tp5746869.html</description>
			<version>2.12.0</version>
			<fixedVersion>2.11.4, 2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.guice.GuiceCamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="7185" opendate="2014-02-10 10:39:15" fixdate="2014-02-10 12:05:28" resolution="Fixed">
		<buginformation>
			<summary>APT - Should check inherited class/interface for UriParam when scanning</summary>
			<description>For example generation of the file component does not check the super class which has all the options, and therefore we only detect a few options.


&amp;lt;html&amp;gt;
&amp;lt;header&amp;gt;
&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;/header&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;file endpoint&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;File endpoint.&amp;lt;/p&amp;gt;
&amp;lt;table class=&amp;amp;apos;table&amp;amp;apos;&amp;gt;
  &amp;lt;tr&amp;gt;
    &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
    &amp;lt;th&amp;gt;Type&amp;lt;/th&amp;gt;
    &amp;lt;th&amp;gt;Description&amp;lt;/th&amp;gt;
  &amp;lt;/tr&amp;gt;
  &amp;lt;tr&amp;gt;
    &amp;lt;td&amp;gt;copyAndDeleteOnRenameFail&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;boolean&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;/tr&amp;gt;
  &amp;lt;tr&amp;gt;
    &amp;lt;td&amp;gt;forceWrites&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;boolean&amp;lt;/td&amp;gt;
    &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;h2&amp;gt;file consumer&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;File consumer.&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

</description>
			<version>2.12.0</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.tools.apt.EndpointAnnotationProcessor.java</file>
			<file type="M">org.apache.camel.tools.apt.util.Strings.java</file>
		</fixedFiles>
	</bug>
	<bug id="7192" opendate="2014-02-11 12:06:30" fixdate="2014-02-12 09:59:17" resolution="Fixed">
		<buginformation>
			<summary>PGPDataFormat: Sub-Key not supported for signing and correct selection of encryption/signing key via KeyFlag</summary>
			<description>A PGP key ring with version 4 keys typically consists of a primary key which has sub-keys. There is a use-case where the primary key has only the usage flag (KeyFlag) "certify" and one sub-key is makred with the usage flag "signing" and the other sub-key is marked with usage flag"encryption".  In this case the PGPDataFormat does not use the correct sub-key for signing and encryption.
In the patch I enabled the usage of sub-keys for the signing process and I introduced the usage flag (KeyFlag) for finding the correct keys for signing and encryption.
</description>
			<version>2.12.2</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.crypto.PGPDataFormat.java</file>
			<file type="M">org.apache.camel.converter.crypto.PGPDataFormatUtil.java</file>
			<file type="M">org.apache.camel.converter.crypto.PGPDataFormatTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7200" opendate="2014-02-12 16:20:41" fixdate="2014-02-12 16:35:45" resolution="Fixed">
		<buginformation>
			<summary>getComponentDocumentation do not work in OSGi</summary>
			<description>This API returns null in OSGi, eg Karaf.</description>
			<version>2.12.0</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="7179" opendate="2014-02-07 16:47:11" fixdate="2014-02-14 18:04:17" resolution="Duplicate">
		<buginformation>
			<summary>CxfRsEndpoint has no features property</summary>
			<description></description>
			<version>2.12.2</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsSpringEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducerTest.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsEndpoint.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">7194</link>
		</links>
	</bug>
	<bug id="7210" opendate="2014-02-16 13:53:19" fixdate="2014-02-16 14:13:48" resolution="Fixed">
		<buginformation>
			<summary>getComponentDocumentation does not work if component name has dash in name</summary>
			<description>For example if component is direct-vm we cannot load the component docs. Also the ftp components has special location.</description>
			<version>2.12.0</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.component.file.FileComponent.java</file>
			<file type="M">org.apache.camel.component.dataformat.DataFormatComponent.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpComponent.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpComponent.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileComponent.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpsEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpEndpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpsComponent.java</file>
			<file type="M">org.apache.camel.impl.UriEndpointComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="7155" opendate="2014-01-28 15:04:49" fixdate="2014-02-17 08:08:42" resolution="Fixed">
		<buginformation>
			<summary>Incorrect implementation of the method StringHelper.hasStartToken()</summary>
			<description>From the semantic point of view the method hasStartToken() should return false in case of an expression without language specified, i.e. starting with "${". 
However, it is correct to return true in current usage of hasStartToken() in camel-core, i.e. checking if an expression is in simple language, since if the expression does not contain the language token, then it is a simple expression.
The method calls for checking of simple language should be replaced with a newly created method isSimpleLanguage(String expression) that would check if the language is a simple expression, i.e. hasStartToken(expression, "simple") || expression.indexOf("${") &amp;gt;= 0.</description>
			<version>2.12.2</version>
			<fixedVersion>2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.StringHelperTest.java</file>
			<file type="M">org.apache.camel.util.StringHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="7219" opendate="2014-02-18 16:43:51" fixdate="2014-02-18 17:36:02" resolution="Fixed">
		<buginformation>
			<summary>Language endpoint with constant cannot load from classpath</summary>
			<description>A route as


                from("direct:start")
                    .to("language:constant:resource:classpath:org/apache/camel/component/language/hello.txt")
                    .to("mock:result");


does not work as expected.</description>
			<version>2.12.2</version>
			<fixedVersion>2.11.5, 2.12.3, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.language.LanguageComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="7092" opendate="2013-12-23 03:44:21" fixdate="2014-02-20 02:05:47" resolution="Fixed">
		<buginformation>
			<summary>Add camel-kafka component</summary>
			<description>See thread request pull from github fork:
http://camel.465427.n5.nabble.com/camel-pull-request-Added-Apache-Kafka-component-td5745174.html</description>
			<version>2.13.0</version>
			<fixedVersion>2.13.0</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.kafka.KafkaEndpoint.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaConstants.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaConsumer.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaComponent.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaConsumerTest.java</file>
			<file type="M">org.apache.camel.component.kafka.SimplePartitioner.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaComponentTest.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaConsumerIT.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaProducer.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaEndpointTest.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaProducerTest.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaProducerIT.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">6565</link>
			<link type="Duplicate" description="is duplicated by">6565</link>
			<link type="Reference" description="relates to">7288</link>
		</links>
	</bug>
	<bug id="7230" opendate="2014-02-20 16:45:45" fixdate="2014-02-20 20:51:38" resolution="Fixed">
		<buginformation>
			<summary>SJMS does not respect QoS settings (ttl/persistence) for sending to queues</summary>
			<description>Reproduced here:
https://github.com/christian-posta/camel-sandbox/blob/master/camel-2.12.2-issues/src/test/java/posta/SjmsTestFromMailingList.java</description>
			<version>2.12.2</version>
			<fixedVersion>2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sjms.support.JmsTestSupport.java</file>
			<file type="M">org.apache.camel.component.sjms.producer.InOnlyProducer.java</file>
			<file type="M">org.apache.camel.component.sjms.producer.InOutProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7239" opendate="2014-02-24 04:45:58" fixdate="2014-02-24 07:16:43" resolution="Fixed">
		<buginformation>
			<summary>Address the SchemaFactory thread safe issue.</summary>
			<description>SchemaFactory is not thread safe, we need to do addition work in ValidatorProcessor to avoid the threads issue.</description>
			<version>2.11.3</version>
			<fixedVersion>2.11.5, 2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.validator.ValidatorRouteTest.java</file>
			<file type="M">org.apache.camel.processor.validation.ValidatingProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="7244" opendate="2014-02-26 15:45:08" fixdate="2014-02-27 07:26:05" resolution="Fixed">
		<buginformation>
			<summary>PGPDataFormat: verification with subkey restricted by User ID does not work</summary>
			<description>If you verify a PGP signature with a subkey which should have a certain User ID, then you run into an error.
Reason: The implementation has not taken into account that the subkey has no User ID on its own. One must consider the User ID of its master/primary key. </description>
			<version>2.13.0</version>
			<fixedVersion>2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.crypto.PGPDataFormat.java</file>
			<file type="M">org.apache.camel.converter.crypto.PGPDataFormatUtil.java</file>
			<file type="M">org.apache.camel.converter.crypto.PGPKeyAccessDataFormat.java</file>
			<file type="M">org.apache.camel.converter.crypto.DefaultPGPPublicKeyAccessor.java</file>
			<file type="M">org.apache.camel.converter.crypto.PGPPublicKeyAccessor.java</file>
			<file type="M">org.apache.camel.converter.crypto.PGPDataFormatTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7254" opendate="2014-02-27 17:57:52" fixdate="2014-02-28 02:44:39" resolution="Fixed">
		<buginformation>
			<summary>MailComponent &amp;apos;peek&amp;apos; doesn&amp;apos;t work due to programming error</summary>
			<description>The MailComponent peek setting doesn&amp;amp;apos;t work due to the following line:


    private void peekMessage(Message mail) {
        // this only applies to IMAP messages which has a setPeek method
        if (mail.getClass().getName().startsWith("IMAP")) {
            try {
                LOG.trace("Calling setPeek(true) on mail message {}", mail);
                IntrospectionSupport.setProperty(mail, "peek", true);
            } catch (Throwable e) {
                // ignore
                LOG.trace("Error setting peak property to true on: " + mail + ". This exception is ignored.", e);
            }
        }
    }


The line that checks the class name for IMAP should be using getSimpleName. Otherwise it&amp;amp;apos;s checking the package name instead.
This effectively means that rollback of processing in camel mail is not supported.</description>
			<version>2.12.2</version>
			<fixedVersion>2.11.5, 2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7251" opendate="2014-02-27 14:10:40" fixdate="2014-02-28 03:47:23" resolution="Fixed">
		<buginformation>
			<summary>SqlProducer call twice the getResultSet on the PreparedStatement =&gt; This cause issue with HSQLDB (NPE)</summary>
			<description>The SqlProducer class use the following lines of code :
ResultSet rs = ps.getResultSet();
                        SqlOutputType outputType = getEndpoint().getOutputType();
                        log.trace("Got result list from query: {}, outputType={}", rs, outputType);
                        if (outputType == SqlOutputType.SelectList) 
{
                            List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; data = getEndpoint().queryForList(ps.getResultSet());
                           .................................
                        }
 else if (outputType == SqlOutputType.SelectOne) 
{
                            Object data = getEndpoint().queryForObject(ps.getResultSet());
                            .................................
                        }
 else 
{
                            throw new IllegalArgumentException("Invalid outputType=" + outputType);
                        }

The problem is that the ResultSet is retrieved at the start, and then only used for the log. Later, when the result set is required, a new call to getResultSet is done. It is an issue with HSQL DB (tested with version 2.3.0 and 2.3.2 of HSQL DB), which in this case return null for the second call.
As the ResultSet is already available in a variable "rs", I would recommand to use this variable to replace the two last call to ps.getResultSet().
Thanks</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sql.SqlProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7241" opendate="2014-02-25 22:50:38" fixdate="2014-02-28 07:36:44" resolution="Fixed">
		<buginformation>
			<summary>ByteBuffer to String conversion uses buffer capacity not limit</summary>
			<description>Camel&amp;amp;apos;s conversion logic for ByteBuffer&amp;amp;apos;s to String&amp;amp;apos;s has a bug where camel uses a ByteBuffers capacity() instead of it&amp;amp;apos;s limit().
If you allocate a large byte buffer and only partially fill it with data, and use camel to convert this into a string, camel tries to convert all the bytes, even the non-used ones.
This unit test reproduces this bug.


    @Test
    public void testByteBufferToStringConversion()
    {
        String str = "123456789";
        ByteBuffer buffer = ByteBuffer.allocate( 16 );
        buffer.put( str.getBytes() );

        Exchange exchange = new DefaultExchange( context() );
        exchange.getIn().setBody( buffer );
        assertEquals( str, exchange.getIn().getBody( String.class ) );
    }

</description>
			<version>2.12.3</version>
			<fixedVersion>2.11.5, 2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.NIOConverter.java</file>
			<file type="M">org.apache.camel.converter.NIOConverterTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7258" opendate="2014-02-28 12:59:19" fixdate="2014-02-28 19:29:28" resolution="Fixed">
		<buginformation>
			<summary>org.apache.camel.model.dataformat.XmlJsonDataFormat settings assignments are misplaced.</summary>
			<description>"elementName" value is assigned to "encoding" field, "arrayName" is assigned to "elementName" field when using XmlJsonDataFormat(Map&amp;lt;String, String&amp;gt; options) constructor.</description>
			<version>2.12.2</version>
			<fixedVersion>2.11.5, 2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.xmljson.XmlJsonDataFormatTest.java</file>
			<file type="M">org.apache.camel.model.dataformat.XmlJsonDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="7229" opendate="2014-02-20 14:44:52" fixdate="2014-03-03 10:06:28" resolution="Fixed">
		<buginformation>
			<summary>[cxfrs] Producer override bean bus</summary>
			<description>Bean configuration:
org.apache.cxf.jaxrs.client.JAXRSClientFactoryBean cf_cCXFRS_1 = new org.apache.cxf.jaxrs.client.JAXRSClientFactoryBean();
cf_cCXFRS_1.setBus(customBus);
Route:
.to("cxfrs://bean://cCXFRS_1")
But at
org.apache.camel.component.cxf.jaxrs.CxfRsProducer.invokeHttpClient(Exchange)
cfb.setBus(((CxfRsEndpoint)getEndpoint()).getBus());</description>
			<version>2.12.1</version>
			<fixedVersion>2.11.5, 2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsConsumer.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducer.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducerClientFactoryCache2Test.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">5579</link>
		</links>
	</bug>
	<bug id="7262" opendate="2014-03-03 11:58:56" fixdate="2014-03-04 06:15:01" resolution="Fixed">
		<buginformation>
			<summary>IAE with calling String.replaceAll via simple expression in Karaf</summary>
			<description>I have a Camel route along which I do something like this:


&amp;lt;setHeader headerName="CamelHttpPath"&amp;gt;
  &amp;lt;simple&amp;gt;/resource/${headers.RESOURCE_ID.replaceAll("/", "%2F")}&amp;lt;/simple&amp;gt;
&amp;lt;/setHeader&amp;gt;


The header RESOURCE_ID is a String. I have JUnit test set up for the route and it passes OK. But when I deploy my bundle to Karaf I get the following exception:


org.apache.camel.language.bean.RuntimeBeanExpressionException: Failed to invoke method: .replaceAll("/", "%2F") on null due to: org.apache.camel.language.bean.RuntimeBeanExpressionException: Failed to invoke method: replaceAll("/", "%2F") on null due to: java.lang.IllegalArgumentException: name must be specified and not empty
	at org.apache.camel.language.bean.BeanExpression.evaluate(BeanExpression.java:117)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.language.bean.BeanExpression.evaluate(BeanExpression.java:132)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.model.language.ExpressionDefinition.evaluate(ExpressionDefinition.java:121)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.model.language.ExpressionDefinition.evaluate(ExpressionDefinition.java:113)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.builder.ExpressionBuilder$KeyedOgnlExpressionAdapter.evaluate(ExpressionBuilder.java:1814)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.support.ExpressionAdapter.evaluate(ExpressionAdapter.java:36)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.builder.ExpressionBuilder$58.evaluate(ExpressionBuilder.java:1381)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.support.ExpressionAdapter.evaluate(ExpressionAdapter.java:36)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.builder.SimpleBuilder.evaluate(SimpleBuilder.java:83)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.builder.ProcessorBuilder$4.process(ProcessorBuilder.java:103)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:163)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:118)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:51)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:110)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:163)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.MulticastProcessor.doProcessSequential(MulticastProcessor.java:573)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.MulticastProcessor.doProcessSequential(MulticastProcessor.java:506)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.MulticastProcessor.process(MulticastProcessor.java:215)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:163)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:118)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.MulticastProcessor.doProcessSequential(MulticastProcessor.java:573)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.MulticastProcessor.doProcessSequential(MulticastProcessor.java:506)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.MulticastProcessor.process(MulticastProcessor.java:215)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.Splitter.process(Splitter.java:98)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:163)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.MulticastProcessor.doProcessSequential(MulticastProcessor.java:573)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.MulticastProcessor.doProcessSequential(MulticastProcessor.java:506)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.MulticastProcessor.process(MulticastProcessor.java:215)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:163)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:118)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.MulticastProcessor.doProcessSequential(MulticastProcessor.java:573)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.MulticastProcessor.doProcessSequential(MulticastProcessor.java:506)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.MulticastProcessor.process(MulticastProcessor.java:215)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.Splitter.process(Splitter.java:98)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:163)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:51)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:110)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:163)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.FilterProcessor.process(FilterProcessor.java:58)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:163)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:118)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.component.file.GenericFileConsumer.processExchange(GenericFileConsumer.java:401)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.component.file.GenericFileConsumer.processBatch(GenericFileConsumer.java:201)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:165)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:187)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:114)[73:org.apache.camel.camel-core:2.12.2]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)[:1.7.0_51]
	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:304)[:1.7.0_51]
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:178)[:1.7.0_51]
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)[:1.7.0_51]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)[:1.7.0_51]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)[:1.7.0_51]
	at java.lang.Thread.run(Thread.java:744)[:1.7.0_51]
Caused by: org.apache.camel.language.bean.RuntimeBeanExpressionException: Failed to invoke method: replaceAll("/", "%2F") on null due to: java.lang.IllegalArgumentException: name must be specified and not empty
	at org.apache.camel.language.bean.BeanExpression$OgnlInvokeProcessor.process(BeanExpression.java:285)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.language.bean.BeanExpression.evaluate(BeanExpression.java:114)[73:org.apache.camel.camel-core:2.12.2]
	... 90 more
Caused by: java.lang.IllegalArgumentException: name must be specified and not empty
	at org.apache.camel.util.ObjectHelper.notEmpty(ObjectHelper.java:331)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.core.osgi.OsgiClassResolver.doLoadClass(OsgiClassResolver.java:87)[76:org.apache.camel.camel-spring:2.12.2]
	at org.apache.camel.core.osgi.OsgiClassResolver.resolveClass(OsgiClassResolver.java:47)[76:org.apache.camel.camel-spring:2.12.2]
	at org.apache.camel.component.bean.BeanHelper.isAssignableToExpectedType(BeanHelper.java:121)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.component.bean.MethodInfo$2.evaluateParameterValue(MethodInfo.java:515)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.component.bean.MethodInfo$2.evaluate(MethodInfo.java:472)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.component.bean.MethodInfo.createMethodInvocation(MethodInfo.java:239)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.component.bean.BeanInfo.createInvocation(BeanInfo.java:278)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.component.bean.BeanInfo.createInvocation(BeanInfo.java:180)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.component.bean.BeanProcessor.process(BeanProcessor.java:148)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:105)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.component.bean.BeanProcessor.process(BeanProcessor.java:67)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.language.bean.BeanExpression$InvokeProcessor.process(BeanExpression.java:189)[73:org.apache.camel.camel-core:2.12.2]
	at org.apache.camel.language.bean.BeanExpression$OgnlInvokeProcessor.process(BeanExpression.java:281)[73:org.apache.camel.camel-core:2.12.2]
	... 91 more


The notable difference seems to be that the JUnit test uses DefaultClassResolver instead of OsgiClassResolver which is used in Karaf.</description>
			<version>2.12.2</version>
			<fixedVersion>2.11.5, 2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.language.simple.SimpleTest.java</file>
			<file type="M">org.apache.camel.core.osgi.OsgiClassResolver.java</file>
			<file type="M">org.apache.camel.util.ObjectHelperTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">7294</link>
		</links>
	</bug>
	<bug id="7147" opendate="2014-01-22 16:46:50" fixdate="2014-03-05 03:07:08" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException when chaining CXF/Jackson REST services in a Camel route</summary>
			<description>When chaining multiple REST service calls in a single camel route, using Jackson as the JSON provider for CXF, the JacksonJsonProvider appears to lose its thread local context between invocations, resulting in an NPE. The NPE doesn&amp;amp;apos;t always occur at the same point. Sometimes one or both additional services are successfully called before the thead local context disappears, but other times neither service is called and an NPE is thrown as soon as the initial service is invoked.
See attached zip archive for reproducer (service2 and service3 are deployed on JBoss AS 7.3.0).
See camel-users thread for background:
http://camel.465427.n5.nabble.com/Questions-about-cxfrs-td5746294.html
Lib versions:
Camel: 2.12.0
Jackson: 1.9.10
CXF: 2.7.0
Full stacktrace:
11:40:51,678 | INFO  | tp1806392083-718 | LoggingInInterceptor             | 150 - org.apache.cxf.cxf-api - 2.7.0.redhat-610139 | Inbound Message
----------------------------
ID: 15
Address: http://localhost:8182/service1/service1path
Encoding: ISO-8859-1
Http-Method: POST
Content-Type: application/json
Headers: 
{Accept=[*/*], accept-encoding=[gzip,deflate,sdch], Accept-Language=[en-US,en;q=0.8], connection=[keep-alive], Content-Length=[23], content-type=[application/json], Host=[localhost:8182], Origin=[chrome-extension://fhjcajmcbmldlhcimfajhfbgofnpcjmb], User-Agent=[Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36]}
Payload: 
{"id":1,"name":"Fred"}

--------------------------------------
11:40:51,679 | WARN  | tp1806392083-718 | PhaseInterceptorChain            | 150 - org.apache.cxf.cxf-api - 2.7.0.redhat-610139 | Interceptor for 
{http://jackson.blueprint.camel.mycompany.com/}
ServiceOne has thrown exception, unwinding now
java.lang.NullPointerException
	at org.apache.cxf.jaxrs.impl.tl.ThreadLocalProviders.getContextResolver(ThreadLocalProviders.java:50)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.codehaus.jackson.jaxrs.JacksonJsonProvider.locateMapper(JacksonJsonProvider.java:633)[245:jackson-jaxrs:1.9.10]
	at org.codehaus.jackson.jaxrs.JacksonJsonProvider.readFrom(JacksonJsonProvider.java:413)[245:jackson-jaxrs:1.9.10]
	at org.apache.cxf.jaxrs.utils.JAXRSUtils.readFromMessageBodyReader(JAXRSUtils.java:1280)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.utils.JAXRSUtils.readFromMessageBody(JAXRSUtils.java:1231)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.utils.JAXRSUtils.processParameter(JAXRSUtils.java:782)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.utils.JAXRSUtils.processParameters(JAXRSUtils.java:741)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.interceptor.JAXRSInInterceptor.processRequest(JAXRSInInterceptor.java:263)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.interceptor.JAXRSInInterceptor.handleMessage(JAXRSInInterceptor.java:103)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:272)[150:org.apache.cxf.cxf-api:2.7.0.redhat-610139]
	at org.apache.cxf.transport.ChainInitiationObserver.onMessage(ChainInitiationObserver.java:121)[150:org.apache.cxf.cxf-api:2.7.0.redhat-610139]
	at org.apache.cxf.transport.http_jetty.JettyHTTPDestination.serviceRequest(JettyHTTPDestination.java:355)[176:org.apache.cxf.cxf-rt-transports-http-jetty:2.7.0.redhat-610139]
	at org.apache.cxf.transport.http_jetty.JettyHTTPDestination.doService(JettyHTTPDestination.java:319)[176:org.apache.cxf.cxf-rt-transports-http-jetty:2.7.0.redhat-610139]
	at org.apache.cxf.transport.http_jetty.JettyHTTPHandler.handle(JettyHTTPHandler.java:72)[176:org.apache.cxf.cxf-rt-transports-http-jetty:2.7.0.redhat-610139]
	at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1077)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1013)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:135)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:255)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:116)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.Server.handle(Server.java:368)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.AbstractHttpConnection.handleRequest(AbstractHttpConnection.java:488)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.AbstractHttpConnection.content(AbstractHttpConnection.java:943)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.AbstractHttpConnection$RequestHandler.content(AbstractHttpConnection.java:1004)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:861)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:240)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.AsyncHttpConnection.handle(AsyncHttpConnection.java:82)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:628)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:52)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:608)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:543)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at java.lang.Thread.run(Thread.java:744)[:1.7.0_45]
11:40:51,681 | WARN  | tp1806392083-718 | PhaseInterceptorChain            | 150 - org.apache.cxf.cxf-api - 2.7.0.redhat-610139 | Exception in handleFault on interceptor org.apache.cxf.binding.xml.interceptor.XMLFaultOutInterceptor@7ba1c840
org.apache.cxf.interceptor.Fault
	at org.apache.cxf.interceptor.AbstractFaultChainInitiatorObserver.onMessage(AbstractFaultChainInitiatorObserver.java:76)[150:org.apache.cxf.cxf-api:2.7.0.redhat-610139]
	at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:333)[150:org.apache.cxf.cxf-api:2.7.0.redhat-610139]
	at org.apache.cxf.transport.ChainInitiationObserver.onMessage(ChainInitiationObserver.java:121)[150:org.apache.cxf.cxf-api:2.7.0.redhat-610139]
	at org.apache.cxf.transport.http_jetty.JettyHTTPDestination.serviceRequest(JettyHTTPDestination.java:355)[176:org.apache.cxf.cxf-rt-transports-http-jetty:2.7.0.redhat-610139]
	at org.apache.cxf.transport.http_jetty.JettyHTTPDestination.doService(JettyHTTPDestination.java:319)[176:org.apache.cxf.cxf-rt-transports-http-jetty:2.7.0.redhat-610139]
	at org.apache.cxf.transport.http_jetty.JettyHTTPHandler.handle(JettyHTTPHandler.java:72)[176:org.apache.cxf.cxf-rt-transports-http-jetty:2.7.0.redhat-610139]
	at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1077)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1013)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:135)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:255)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:116)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.Server.handle(Server.java:368)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.AbstractHttpConnection.handleRequest(AbstractHttpConnection.java:488)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.AbstractHttpConnection.content(AbstractHttpConnection.java:943)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.AbstractHttpConnection$RequestHandler.content(AbstractHttpConnection.java:1004)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:861)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:240)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.AsyncHttpConnection.handle(AsyncHttpConnection.java:82)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:628)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:52)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:608)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:543)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at java.lang.Thread.run(Thread.java:744)[:1.7.0_45]
Caused by: java.lang.NullPointerException
	at org.apache.cxf.jaxrs.impl.tl.ThreadLocalProviders.getContextResolver(ThreadLocalProviders.java:50)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.codehaus.jackson.jaxrs.JacksonJsonProvider.locateMapper(JacksonJsonProvider.java:633)[245:jackson-jaxrs:1.9.10]
	at org.codehaus.jackson.jaxrs.JacksonJsonProvider.readFrom(JacksonJsonProvider.java:413)[245:jackson-jaxrs:1.9.10]
	at org.apache.cxf.jaxrs.utils.JAXRSUtils.readFromMessageBodyReader(JAXRSUtils.java:1280)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.utils.JAXRSUtils.readFromMessageBody(JAXRSUtils.java:1231)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.utils.JAXRSUtils.processParameter(JAXRSUtils.java:782)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.utils.JAXRSUtils.processParameters(JAXRSUtils.java:741)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.interceptor.JAXRSInInterceptor.processRequest(JAXRSInInterceptor.java:263)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.interceptor.JAXRSInInterceptor.handleMessage(JAXRSInInterceptor.java:103)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:272)[150:org.apache.cxf.cxf-api:2.7.0.redhat-610139]
	... 21 more
11:40:51,682 | ERROR | tp1806392083-718 | tractFaultChainInitiatorObserver | 150 - org.apache.cxf.cxf-api - 2.7.0.redhat-610139 | Error occurred during error handling, give up!
org.apache.cxf.interceptor.Fault
	at org.apache.cxf.interceptor.AbstractFaultChainInitiatorObserver.onMessage(AbstractFaultChainInitiatorObserver.java:76)[150:org.apache.cxf.cxf-api:2.7.0.redhat-610139]
	at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:333)[150:org.apache.cxf.cxf-api:2.7.0.redhat-610139]
	at org.apache.cxf.transport.ChainInitiationObserver.onMessage(ChainInitiationObserver.java:121)[150:org.apache.cxf.cxf-api:2.7.0.redhat-610139]
	at org.apache.cxf.transport.http_jetty.JettyHTTPDestination.serviceRequest(JettyHTTPDestination.java:355)[176:org.apache.cxf.cxf-rt-transports-http-jetty:2.7.0.redhat-610139]
	at org.apache.cxf.transport.http_jetty.JettyHTTPDestination.doService(JettyHTTPDestination.java:319)[176:org.apache.cxf.cxf-rt-transports-http-jetty:2.7.0.redhat-610139]
	at org.apache.cxf.transport.http_jetty.JettyHTTPHandler.handle(JettyHTTPHandler.java:72)[176:org.apache.cxf.cxf-rt-transports-http-jetty:2.7.0.redhat-610139]
	at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1077)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1013)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:135)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:255)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:116)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.Server.handle(Server.java:368)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.AbstractHttpConnection.handleRequest(AbstractHttpConnection.java:488)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.AbstractHttpConnection.content(AbstractHttpConnection.java:943)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.AbstractHttpConnection$RequestHandler.content(AbstractHttpConnection.java:1004)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:861)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:240)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.AsyncHttpConnection.handle(AsyncHttpConnection.java:82)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:628)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:52)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:608)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:543)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at java.lang.Thread.run(Thread.java:744)[:1.7.0_45]
Caused by: java.lang.NullPointerException
	at org.apache.cxf.jaxrs.impl.tl.ThreadLocalProviders.getContextResolver(ThreadLocalProviders.java:50)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.codehaus.jackson.jaxrs.JacksonJsonProvider.locateMapper(JacksonJsonProvider.java:633)[245:jackson-jaxrs:1.9.10]
	at org.codehaus.jackson.jaxrs.JacksonJsonProvider.readFrom(JacksonJsonProvider.java:413)[245:jackson-jaxrs:1.9.10]
	at org.apache.cxf.jaxrs.utils.JAXRSUtils.readFromMessageBodyReader(JAXRSUtils.java:1280)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.utils.JAXRSUtils.readFromMessageBody(JAXRSUtils.java:1231)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.utils.JAXRSUtils.processParameter(JAXRSUtils.java:782)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.utils.JAXRSUtils.processParameters(JAXRSUtils.java:741)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.interceptor.JAXRSInInterceptor.processRequest(JAXRSInInterceptor.java:263)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.interceptor.JAXRSInInterceptor.handleMessage(JAXRSInInterceptor.java:103)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:272)[150:org.apache.cxf.cxf-api:2.7.0.redhat-610139]
	... 21 more
11:40:51,683 | WARN  | tp1806392083-718 | AbstractHttpConnection           | 93 - org.eclipse.jetty.aggregate.jetty-all-server - 8.1.9.v20130131 | /service1/service1path
java.lang.RuntimeException: org.apache.cxf.interceptor.Fault
	at org.apache.cxf.interceptor.AbstractFaultChainInitiatorObserver.onMessage(AbstractFaultChainInitiatorObserver.java:116)[150:org.apache.cxf.cxf-api:2.7.0.redhat-610139]
	at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:333)[150:org.apache.cxf.cxf-api:2.7.0.redhat-610139]
	at org.apache.cxf.transport.ChainInitiationObserver.onMessage(ChainInitiationObserver.java:121)[150:org.apache.cxf.cxf-api:2.7.0.redhat-610139]
	at org.apache.cxf.transport.http_jetty.JettyHTTPDestination.serviceRequest(JettyHTTPDestination.java:355)[176:org.apache.cxf.cxf-rt-transports-http-jetty:2.7.0.redhat-610139]
	at org.apache.cxf.transport.http_jetty.JettyHTTPDestination.doService(JettyHTTPDestination.java:319)[176:org.apache.cxf.cxf-rt-transports-http-jetty:2.7.0.redhat-610139]
	at org.apache.cxf.transport.http_jetty.JettyHTTPHandler.handle(JettyHTTPHandler.java:72)[176:org.apache.cxf.cxf-rt-transports-http-jetty:2.7.0.redhat-610139]
	at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1077)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1013)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:135)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:255)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:116)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.Server.handle(Server.java:368)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.AbstractHttpConnection.handleRequest(AbstractHttpConnection.java:488)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.AbstractHttpConnection.content(AbstractHttpConnection.java:943)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.AbstractHttpConnection$RequestHandler.content(AbstractHttpConnection.java:1004)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:861)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:240)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.server.AsyncHttpConnection.handle(AsyncHttpConnection.java:82)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:628)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:52)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:608)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:543)[93:org.eclipse.jetty.aggregate.jetty-all-server:8.1.9.v20130131]
	at java.lang.Thread.run(Thread.java:744)[:1.7.0_45]
Caused by: org.apache.cxf.interceptor.Fault
	at org.apache.cxf.interceptor.AbstractFaultChainInitiatorObserver.onMessage(AbstractFaultChainInitiatorObserver.java:76)[150:org.apache.cxf.cxf-api:2.7.0.redhat-610139]
	... 22 more
Caused by: java.lang.NullPointerException
	at org.apache.cxf.jaxrs.impl.tl.ThreadLocalProviders.getContextResolver(ThreadLocalProviders.java:50)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.codehaus.jackson.jaxrs.JacksonJsonProvider.locateMapper(JacksonJsonProvider.java:633)[245:jackson-jaxrs:1.9.10]
	at org.codehaus.jackson.jaxrs.JacksonJsonProvider.readFrom(JacksonJsonProvider.java:413)[245:jackson-jaxrs:1.9.10]
	at org.apache.cxf.jaxrs.utils.JAXRSUtils.readFromMessageBodyReader(JAXRSUtils.java:1280)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.utils.JAXRSUtils.readFromMessageBody(JAXRSUtils.java:1231)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.utils.JAXRSUtils.processParameter(JAXRSUtils.java:782)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.utils.JAXRSUtils.processParameters(JAXRSUtils.java:741)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.interceptor.JAXRSInInterceptor.processRequest(JAXRSInInterceptor.java:263)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.jaxrs.interceptor.JAXRSInInterceptor.handleMessage(JAXRSInInterceptor.java:103)[166:org.apache.cxf.cxf-rt-frontend-jaxrs:2.7.0.redhat-610139]
	at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:272)[150:org.apache.cxf.cxf-api:2.7.0.redhat-610139]
	... 21 more</description>
			<version>2.12.0</version>
			<fixedVersion>2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.test.cxf.blueprint.CxfEndpointBeansTest.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="depends upon">5542</link>
		</links>
	</bug>
	<bug id="7194" opendate="2014-02-12 10:31:03" fixdate="2014-03-05 03:07:43" resolution="Fixed">
		<buginformation>
			<summary>[cxfrs] Bus features aren&amp;apos;t initialized</summary>
			<description>
CxfRsEndpoint doesn&amp;amp;apos;t support custom feture support like
org.apache.camel.component.cxf.CxfEndpoint.setFeatures(List&amp;lt;AbstractFeature&amp;gt;)
org.apache.camel.component.cxf.jaxrs.CxfRsEndpoint.createJAXRSClientFactoryBean() can&amp;amp;apos;t be used for additional configuration because org.apache.camel.component.cxf.jaxrs.CxfRsProducer.ClientFactoryBeanCache used
in case bus was initialized with required features they aren&amp;amp;apos;t initialized for WebClient

</description>
			<version>2.12.2</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsSpringEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducerTest.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsEndpoint.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">7179</link>
		</links>
	</bug>
	<bug id="7253" opendate="2014-02-27 15:26:22" fixdate="2014-03-05 03:08:12" resolution="Fixed">
		<buginformation>
			<summary>PGPDataFormat: NullPointerException if decryptor gets body with invalid format</summary>
			<description>if the PGPDataFormat gets an invalid format during the decryption process a NullPointerException is thrown.
The attached patch throws an IllegalArgumentException instead and improves further error situations if a wrong formated input is provided.</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.crypto.PGPKeyAccessDataFormat.java</file>
			<file type="M">org.apache.camel.converter.crypto.PGPDataFormatTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7256" opendate="2014-02-27 22:00:04" fixdate="2014-03-05 03:08:40" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException at DefaultCxfRsBinding</summary>
			<description>In case if message.isFault() is true, but no Exception set:


Caused by: java.lang.NullPointerException
        at org.apache.camel.component.cxf.jaxrs.DefaultCxfRsBinding.populateCxfRsResponseFromExchange(DefaultCxfRsBinding.java:76)[202:org.apache.camel.camel-cxf:2.12.1]
        at org.apache.camel.component.cxf.jaxrs.CxfRsInvoker.returnResponse(CxfRsInvoker.java:166)[202:org.apache.camel.camel-cxf:2.12.1]
        at org.apache.camel.component.cxf.jaxrs.CxfRsInvoker.asyncInvoke(CxfRsInvoker.java:107)[202:org.apache.camel.camel-cxf:2.12.1]
        at org.apache.camel.component.cxf.jaxrs.CxfRsInvoker.performInvocation(CxfRsInvoker.java:57)[202:org.apache.camel.camel-cxf:2.12.1]
        at org.apache.cxf.service.invoker.AbstractInvoker.invoke(AbstractInvoker.java:96)[158:org.apache.cxf.cxf-api:2.7.6]
        ... 23 more

</description>
			<version>2.12.1</version>
			<fixedVersion>2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsConsumerTest.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.DefaultCxfRsBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="7275" opendate="2014-03-06 09:59:35" fixdate="2014-03-06 16:00:13" resolution="Fixed">
		<buginformation>
			<summary>Using doTry .. doCatch with recipient list should not trigger error handler during recipient list work</summary>
			<description>When you have a route like this


                from("direct:start")
                    .doTry()
                        .recipientList(constant("direct:foo")).end()
                    .doCatch(Exception.class)
                        .to("mock:catch")
                        .transform().constant("doCatch")
                    .end()
                    .to("mock:result");


Then if an exception was thrown it should be catch by doCatch
A similar route with to instead works as expected.</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.processor.TryProcessor.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="7277" opendate="2014-03-07 03:08:53" fixdate="2014-03-07 10:53:44" resolution="Fixed">
		<buginformation>
			<summary>camel-ssh should close the session when execution is finished.</summary>
			<description>Here is the complain from the stackoverfow </description>
			<version>2.11.4</version>
			<fixedVersion>2.11.5, 2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.ssh.SshEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="7279" opendate="2014-03-07 16:42:52" fixdate="2014-03-07 16:50:34" resolution="Fixed">
		<buginformation>
			<summary>Yammer now uses bearer token for auth</summary>
			<description>... which means camel-yammer cannot connect to the yammer API currently.</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.yammer.ScribeApiRequestor.java</file>
		</fixedFiles>
	</bug>
	<bug id="7276" opendate="2014-03-06 13:41:37" fixdate="2014-03-09 07:33:27" resolution="Fixed">
		<buginformation>
			<summary>camel-quartz - use of management name to provide default scheduler name breaks context isolation</summary>
			<description>When using the camel-quartz component in an unmanged context with multiple camel contexts, for example in a JUnit test case, causes the scheduler to be created with the instance name "DefaultQuartzScheduler" which is then shared across all camel context&amp;amp;apos;s within the same jvm.
This is in contradiction of the previous behaviour that uses `getCamelContext.getName()` which isolates the scheduler by denoting that the default instance is specific to the camel context.


package org.apache.camel.component.quartz;

import org.apache.camel.CamelContext;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.management.JmxSystemPropertyKeys;
import org.junit.Test;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;

import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotSame;

/**
 * Test regression of camel-context isolation of default scheduler instance introduced in CAMEL-7034.
 */
public class QuartzComponentCamelContextSchedulerIsolationTest {

  @Test
  public void testSchedulerIsolation_unmanaged() throws Exception {
    disableJMX();
    testSchedulerIsolation();
  }

  @Test
  public void testSchedulerIsolation_managed() throws Exception {
    enableJMX();
    testSchedulerIsolation();
  }

  private void testSchedulerIsolation() throws Exception {
    CamelContext context = createCamelContext();
    context.start();

    CamelContext anotherContext = createCamelContext();
    assertNotEquals(anotherContext.getName(), context.getName());
    assertNotEquals(anotherContext, context);

    assertNotSame(getDefaultScheduler(context), getDefaultScheduler(anotherContext));
  }

  /**
   * Create a new camel context instance.
   */
  private DefaultCamelContext createCamelContext() {
    return new DefaultCamelContext();
  }

  /**
   * Get the quartz component for the provided camel context.
   */
  private QuartzComponent getQuartzComponent(CamelContext context) {
    return context.getComponent("quartz", QuartzComponent.class);
  }

  /**
   * Get the default scheduler for the provided camel context.
   */
  private Scheduler getDefaultScheduler(CamelContext context) throws SchedulerException {
    return getQuartzComponent(context).getFactory().getScheduler();
  }

  /**
   * Disables the JMX agent.
   */
  private void disableJMX() {
    System.setProperty(JmxSystemPropertyKeys.DISABLED, "true");
  }

  /**
   * Enables the JMX agent.
   */
  private void enableJMX() {
    System.setProperty(JmxSystemPropertyKeys.DISABLED, "false");
  }

}

</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.quartz.QuartzComponent.java</file>
			<file type="M">org.apache.camel.component.quartz2.QuartzPropertiesTest.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzPropertiesTest.java</file>
			<file type="M">org.apache.camel.component.quartz2.QuartzComponent.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">7034</link>
		</links>
	</bug>
	<bug id="7286" opendate="2014-03-12 01:25:49" fixdate="2014-03-12 02:51:08" resolution="Fixed">
		<buginformation>
			<summary>amazonSNSEndpoint option is ignored</summary>
			<description>I just got an user complain that the amazonSNSEndpoint option of aws-sns was ignored. </description>
			<version>2.11.4</version>
			<fixedVersion>2.11.5, 2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.aws.sdb.SdbEndpoint.java</file>
			<file type="M">org.apache.camel.component.aws.ddb.DdbEndpoint.java</file>
			<file type="M">org.apache.camel.component.aws.ses.SesEndpoint.java</file>
			<file type="M">org.apache.camel.component.aws.sqs.SqsEndpoint.java</file>
			<file type="M">org.apache.camel.component.aws.s3.S3Endpoint.java</file>
			<file type="M">org.apache.camel.component.aws.cw.CwEndpoint.java</file>
			<file type="M">org.apache.camel.component.aws.sns.SnsEndpoint.java</file>
			<file type="M">org.apache.camel.component.aws.sns.AmazonSNSClientMock.java</file>
			<file type="M">org.apache.camel.component.aws.sns.SnsComponentConfigurationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7287" opendate="2014-03-12 07:28:47" fixdate="2014-03-13 09:11:00" resolution="Fixed">
		<buginformation>
			<summary>SJMS: Cannot connect to durable topic because "noLocal" is hardcoded to "true"</summary>
			<description>See this thread: http://camel.465427.n5.nabble.com/SJMS-issue-with-noLocal-td5748632.html</description>
			<version>2.11.3</version>
			<fixedVersion>2.11.5, 2.12.4, 2.13.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sjms.jms.JmsObjectFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="7298" opendate="2014-03-16 20:58:07" fixdate="2014-03-18 06:19:30" resolution="Fixed">
		<buginformation>
			<summary>Simple Language - Binary Expression Equality Fails</summary>
			<description>When writing the following code, the expression 

${headers.true} == ${headers.true}

 evaluates to false - rather than the expected true.


    &amp;lt;camelContext trace="false" xmlns="http://camel.apache.org/schema/blueprint"&amp;gt;
        &amp;lt;route&amp;gt;
            &amp;lt;from uri="direct:entry"/&amp;gt;

            &amp;lt;setHeader headerName="true"&amp;gt;
                &amp;lt;constant&amp;gt;true&amp;lt;/constant&amp;gt;
            &amp;lt;/setHeader&amp;gt;

            &amp;lt;setBody&amp;gt;
                &amp;lt;simple resultType="java.lang.Boolean"&amp;gt;${headers.true} == ${headers.true}&amp;lt;/simple&amp;gt;
            &amp;lt;/setBody&amp;gt;

            &amp;lt;log message="The expression evaluated to :: ${body}" /&amp;gt;

        &amp;lt;/route&amp;gt;
    &amp;lt;/camelContext&amp;gt;




[                          main] route1                         INFO  The expression evaluated to :: false


Edit: I have tried debugging this, and it seems that the "==" token is being treated as a LiteralExpression - rather than an being a Binary Operator? I&amp;amp;apos;m imaging therefore that the `false` is purely from coercing a String to the java.lang.Boolean resultType?</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.language.simple.SimpleLanguage.java</file>
			<file type="M">org.apache.camel.language.simple.SimpleParserPredicateTest.java</file>
			<file type="M">org.apache.camel.builder.SimpleBuilder.java</file>
			<file type="M">org.apache.camel.language.simple.SimplePredicateParser.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">7428</link>
		</links>
	</bug>
	<bug id="7303" opendate="2014-03-17 13:41:00" fixdate="2014-03-18 08:39:24" resolution="Fixed">
		<buginformation>
			<summary>Simple Language - Header access surrounded with quotes</summary>
			<description>Quotes within header access are not currently handled in the same way as the inbuilt headerAs function or the body accessor notation - perhaps these should be aligned?
For instance with the following route


    &amp;lt;camelContext trace="false" xmlns="http://camel.apache.org/schema/blueprint"&amp;gt;
        &amp;lt;route&amp;gt;
            &amp;lt;from uri="direct:entry"/&amp;gt;

            &amp;lt;setHeader headerName="some key"&amp;gt;
                &amp;lt;constant&amp;gt;hello world&amp;lt;/constant&amp;gt;
            &amp;lt;/setHeader&amp;gt;

            &amp;lt;setBody&amp;gt;
                &amp;lt;simple&amp;gt;${headers[&amp;amp;apos;some key&amp;amp;apos;]}&amp;lt;/simple&amp;gt;
            &amp;lt;/setBody&amp;gt;

            &amp;lt;log message="The expression evaluated to :: ${body}" /&amp;gt;

        &amp;lt;/route&amp;gt;
    &amp;lt;/camelContext&amp;gt;


Outcome :

[                          main] route1                         INFO  The expression evaluated to :: 

Expected :

[                          main] route1                         INFO  The expression evaluated to :: hello world

For reference, the current notation works within other parts of the language and are handled as expected

${body[&amp;amp;apos;some key&amp;amp;apos;]}


${headerAs(&amp;amp;apos;some key&amp;amp;apos;, java.lang.Boolean}

I think the fix might be to use StringHelper.removeQuotes on line #269 within SimpleFunctionExpression.java possibly, such as

remainder = StringHelper.removeQuotes(remainder.substring(1, remainder.length() - 1));

</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.language.simple.SimpleTest.java</file>
			<file type="M">org.apache.camel.language.simple.ast.SimpleFunctionExpression.java</file>
		</fixedFiles>
	</bug>
	<bug id="7304" opendate="2014-03-17 21:06:52" fixdate="2014-03-18 10:04:58" resolution="Fixed">
		<buginformation>
			<summary>InterceptSendToEndpoint does not work where uri needs to be normalized</summary>
			<description>interceptSendToEndpoint("sftp://hostname:22/testDirectory?privateKeyFile=/user/.ssh.id_rsa") is not intercepted because uri passed to InterceptSendToEndpointDefinition is not normalized.
As a result InterceptSendToEndpointDefinition createProcessor() method fails to match EndpointHelper.matchEndpoint(routeContext.getCamelContext(), uri, getUri()) and InterceptSendToEndpoint is not created.</description>
			<version>2.10.4</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.InterceptSendToEndpointDefinition.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">3434</link>
		</links>
	</bug>
	<bug id="7310" opendate="2014-03-19 09:02:54" fixdate="2014-03-19 09:05:52" resolution="Fixed">
		<buginformation>
			<summary>Restlet - Need to run in sync mode due bug in restlet</summary>
			<description>There is a NPE bug in restlet when the restlet client timeout
https://github.com/restlet/restlet-framework-java/issues/871
This causes camel restlet producer to not have its callback called, which can lead to Camel hanging.
We need to force sync mode until restlet fixes their NPE bug</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.RestletProducerTimeoutTest.java</file>
			<file type="M">org.apache.camel.component.restlet.RestletProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7311" opendate="2014-03-19 09:44:24" fixdate="2014-03-19 09:48:41" resolution="Fixed">
		<buginformation>
			<summary>camel-mail - Should not fetch attachments if mapMailMessage=false</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Polling-Email-Component-Runtime-Error-tp5749047.html</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailMessage.java</file>
			<file type="M">org.apache.camel.component.mail.MailEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="7320" opendate="2014-03-22 11:08:53" fixdate="2014-03-23 12:46:50" resolution="Fixed">
		<buginformation>
			<summary>PGP Data Format: EOFException: Unexpected end of ZIP input stream</summary>
			<description>If you call the PGP Data Format unmarshaller with a PGP message containing a PGP Encrypted Data packet and a Singature packet then you get the following exception
java.io.EOFException: Unexpected end of ZIP input stream
	at org.bouncycastle.openpgp.PGPCompressedData$1.fill(Unknown Source)
	at java.util.zip.InflaterInputStream.read(InflaterInputStream.java:158)
	at org.bouncycastle.bcpg.BCPGInputStream.read(Unknown Source)
	at org.bouncycastle.bcpg.BCPGInputStream$PartialInputStream.read(Unknown Source)
	at org.bouncycastle.bcpg.BCPGInputStream.read(Unknown Source)
	at org.bouncycastle.util.io.Streams.readFully(Unknown Source)
	at org.bouncycastle.bcpg.BCPGInputStream.readFully(Unknown Source)
	at org.bouncycastle.bcpg.BCPGInputStream.readFully(Unknown Source)
	at org.bouncycastle.bcpg.MPInteger.&amp;lt;init&amp;gt;(Unknown Source)
	at org.bouncycastle.bcpg.SignaturePacket.&amp;lt;init&amp;gt;(Unknown Source)
	at org.bouncycastle.bcpg.BCPGInputStream.readPacket(Unknown Source)
	at org.bouncycastle.openpgp.PGPSignature.&amp;lt;init&amp;gt;(Unknown Source)
	at org.bouncycastle.openpgp.PGPObjectFactory.nextObject(Unknown Source)
	at org.apache.camel.converter.crypto.PGPKeyAccessDataFormat.verifySignature(PGPKeyAccessDataFormat.java:474)
	at org.apache.camel.converter.crypto.PGPKeyAccessDataFormat.unmarshal(PGPKeyAccessDataFormat.java:405)
The provided patch is for 2.13 and 2.14. The patch must be adapted for 2.12.
The problem also occurs with the other compression algorithms ZLIB and BZIP2.
Regards Franz</description>
			<version>2.12.3</version>
			<fixedVersion>2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.crypto.PGPKeyAccessDataFormat.java</file>
			<file type="M">org.apache.camel.converter.crypto.PGPDataFormatTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7323" opendate="2014-03-24 07:19:32" fixdate="2014-03-24 07:29:52" resolution="Fixed">
		<buginformation>
			<summary>createRouteStatisticEndpointJson - Returns invalid json if no routes</summary>
			<description>If there is no routes, we have an extra } which should not be there


{
  "routes": {
    }
  }
}


Parse error on line 5:
... {            }}}
-------------------^
Expecting &amp;amp;apos;EOF&amp;amp;apos;</description>
			<version>2.13.0</version>
			<fixedVersion>2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.management.ManagedCamelContextTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7308" opendate="2014-03-18 11:45:46" fixdate="2014-03-24 10:42:03" resolution="Fixed">
		<buginformation>
			<summary>Timer component : timer should use StartupListener to be initialized before first fire</summary>
			<description>CAMEL-5542 creates a regression for our routes when migrating from ServiceMix 4.4 to ServiceMix 4.5.
The secondary route in which we use this timer populates a cache, which must be initialized before other primary routes in the bundle can use it, otherwise requests sent to these other routes will generate errors.
In our ServiceMix installation with all the other bundles, the bundle with the timer can take from 1 second to 30 seconds to start-up, depending on the machine speed and the number of other bundles which are installed/started at the same time. 
It is therefore very difficult to estimate the time to define for the "delay" variable. If set too low, the first fire will be ignored and the other primary routes will generate errors until the timer second fire. If set too high, the other primary routes will generate errors until the timer first fire. 
Normally the timer period is set to refresh the cache every several minutes, which leaves a large window where requests end with an error in case the cache failed to initialize.
Here is a patch with a StartupListener which effectively reduces the window of errors to a fraction of a second.
Also, it would help to debug these kind of problems if a "debug" log is added when the first timer fire is ignored.</description>
			<version>2.10.7</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.timer.TimerConsumer.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">5542</link>
		</links>
	</bug>
	<bug id="7321" opendate="2014-03-23 01:32:55" fixdate="2014-03-25 07:43:00" resolution="Fixed">
		<buginformation>
			<summary>JcrConsumer freezes in some environments</summary>
			<description>In January Willem Jiang reported that the JUnit test JcrConsumerTest fails in his environment. This could not be reproduced in other environments at that time. Willem Jiang applied the following fix to the pom.xml in order make the test pass:
camel-jcr/pom.xml

[...]
  &amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
     &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;maven-surefire-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;configuration&amp;gt;
          &amp;lt;forkMode&amp;gt;pertest&amp;lt;/forkMode&amp;gt;
        &amp;lt;/configuration&amp;gt;
     &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
  &amp;lt;/build&amp;gt;
[...]


This made all tests run in separate processes, but was also an indicator for potential multi-threading issues in JcrConsumer. I was recently able to reproduce the problem by running Maven within Eclipse. The problem is indeed a synchronization issue and should be addressed with this ticket.</description>
			<version>2.13.0</version>
			<fixedVersion>2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jcr.JcrConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7296" opendate="2014-03-14 08:06:20" fixdate="2014-03-28 08:25:23" resolution="Fixed">
		<buginformation>
			<summary>camel-hbase component have some bugs on Consumer side</summary>
			<description>After I tried a little bit, I think there are 2 problems on Consumer side:

Returned value is null
if we specified family and qualifier options in URI, then all returned values will be null.  I did some investigation, and I found the problem is caused by the equals method of HBaseCell class. In poll() method of HBaseConsumer, the resultRow will apply rowModel first before insert the resultCell, see below code:


             ....
              HBaseData data = new HBaseData();
                HBaseRow resultRow = new HBaseRow();
                resultRow.apply(rowModel);       //the existing HBaseCell in rowModel will be insert into resultRow
                byte[] row = result.getRow();
                resultRow.setId(endpoint.getCamelContext().getTypeConverter().convertTo(rowModel.getRowType(), row));

                List&amp;lt;KeyValue&amp;gt; keyValues = result.list();
                if (keyValues != null) {
                    for (KeyValue keyValue : keyValues) {
                        String qualifier = new String(keyValue.getQualifier());
                        String family = new String(keyValue.getFamily());
                        HBaseCell resultCell = new HBaseCell();
                        resultCell.setFamily(family);
                        resultCell.setQualifier(qualifier);
                        resultCell.setValue(endpoint.getCamelContext().getTypeConverter().convertTo(String.class, keyValue.getValue()));
                        resultRow.getCells().add(resultCell); //will fail to insert if some cell with same Family and Qualifier exists
                    }
                    ...
              }


that means we can&amp;amp;apos;t specify family and qualifier option when consuming.
remove option
the default value of remove option is true, that mean, after scan the table, all scanned row will be removed. I think it&amp;amp;apos;s not we expect, so user may have to add option remove=false to stop that. however this option doesn&amp;amp;apos;t describe on website http://camel.apache.org/hbase.html .

Besides these problem, I think some descriptions on http://camel.apache.org/hbase.html are not correct, for example the demos and Header Options. please have a check.</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.hbase.HBaseConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7337" opendate="2014-04-02 05:29:22" fixdate="2014-04-02 11:05:15" resolution="Fixed">
		<buginformation>
			<summary>PGPDataFormat unmarshal doesn&amp;apos;t close the stream correctly</summary>
			<description>The PGPDataFormat does not close some streams during unmarshaling.</description>
			<version>2.13.0</version>
			<fixedVersion>2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.crypto.PGPKeyAccessDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="7341" opendate="2014-04-03 07:11:37" fixdate="2014-04-04 04:16:07" resolution="Fixed">
		<buginformation>
			<summary>CXFRS: InInterceptor defined in Spring is ignored</summary>
			<description>A CXF InInterceptor added to the rsServer via Spring is not added to the interceptor chain and therefore is not executed.


&amp;lt;cxf:rsServer id="service" address="/exampleService"
              serviceClass="com.example.service.ExampleService"
              loggingFeatureEnabled="true"
              xmlns:cxf="http://camel.apache.org/schema/cxf"&amp;gt;
    &amp;lt;cxf:providers&amp;gt;
        &amp;lt;bean class="com.fasterxml.jackson.jaxrs.json.JacksonJaxbJsonProvider"/&amp;gt;
    &amp;lt;/cxf:providers&amp;gt;
    &amp;lt;cxf:inInterceptors&amp;gt;
        &amp;lt;bean class="com.example.service.ExampleInInterceptor"/&amp;gt;
    &amp;lt;/cxf:inInterceptors&amp;gt;
&amp;lt;/cxf:rsServer&amp;gt;




public class ExampleInInterceptor extends AbstractPhaseInterceptor&amp;lt;Message&amp;gt; {
    public ExampleInInterceptor() {
        super(Phase.RECEIVE);
    }

    @Override
    public void handleMessage(Message message) throws Fault {
        ...
    }
}


The same configuration works with Camel Version 2.12.2.</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsSpringEndpointTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7347" opendate="2014-04-07 09:01:12" fixdate="2014-04-07 09:15:20" resolution="Fixed">
		<buginformation>
			<summary>camel-netty - Should return 404 instead of 503 if context-path did not match a route</summary>
			<description>We should return 404 instead as the service is there but the resource requested was not found.</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpTwoRoutesMatchOnUriPrefixTest.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpTwoRoutesStopOneRouteTest.java</file>
			<file type="M">org.apache.camel.component.netty.http.handlers.HttpServerMultiplexChannelHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="7344" opendate="2014-04-04 22:06:36" fixdate="2014-04-07 13:12:51" resolution="Fixed">
		<buginformation>
			<summary>Some endpoints configured using beans may result in NPE under DEBUG mode</summary>
			<description>CAMEL-6130 seems to have introduced this issue or more precisely speaking, it has made this issue visible.
DefaultEndpoint&amp;amp;apos;s toString() method seems to require its endpoint string value to be set. If it&amp;amp;apos;s not set, the toString method throws an exception. A fully built endpoint always has its endpoint string value set, thus there is no issue. However, an endpoint being manually set up may not have its endpoint string value set from the beginning (e.g., when its super class uses the DefaultEndpoint&amp;amp;apos;s default constructor to instantiate using a bean based instantiation).
The debug log statement introduced in CAMEL-6130 invokes this toString method during the endpoint setup.
That means, a spring based CXF endpoint may result in the following exception under the debug mode.
SLF4J: Failed toString() invocation on an object of type [org.apache.camel.component.cxf.CxfSpringEndpoint]
java.lang.IllegalArgumentException: endpointUri is not specified and org.apache.camel.component.cxf.CxfSpringEndpoint does not implement createEndpointUri() to create a default value
at org.apache.camel.impl.DefaultEndpoint.getEndpointUri(DefaultEndpoint.java:154)
at org.apache.camel.impl.DefaultEndpoint.toString(DefaultEndpoint.java:139)
at org.slf4j.helpers.MessageFormatter.safeObjectAppend(MessageFormatter.java:304)
at org.slf4j.helpers.MessageFormatter.deeplyAppendParameter(MessageFormatter.java:276)
at org.slf4j.helpers.MessageFormatter.arrayFormat(MessageFormatter.java:230)
at org.slf4j.impl.Log4jLoggerAdapter.debug(Log4jLoggerAdapter.java:271)
at org.apache.camel.util.IntrospectionSupport.setProperty(IntrospectionSupport.java:528)
at org.apache.camel.util.IntrospectionSupport.setProperty(IntrospectionSupport.java:570)
at org.apache.camel.util.IntrospectionSupport.setProperties(IntrospectionSupport.java:454)
at org.apache.camel.util.EndpointHelper.setProperties(EndpointHelper.java:249)
at org.apache.camel.component.cxf.CxfEndpoint.setCamelContext(CxfEndpoint.java:840)
I  wonder whether we really need DefaultEndpoint&amp;amp;apos;s getEndpointUri() to throw an exception when it&amp;amp;apos;s endpoint string value is not set. But if we keep this rule, we must catch the exception in its toString() method so that we won&amp;amp;apos;t throw the above exception when the toString() method is called during the endpoint setup
I would propose to add the exception catching in the toString method. If we decide to change the getEndpointUri() method to not throw the exception (that change will likely require the NPE check at the users of this method), we can make that change and remove the exception catch from the toString method
This issue affects camel 2.11.0 and later versions.</description>
			<version>2.11.4</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultEndpoint.java</file>
			<file type="M">org.apache.camel.impl.DefaultEndpointTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7353" opendate="2014-04-08 21:13:04" fixdate="2014-04-09 09:05:49" resolution="Fixed">
		<buginformation>
			<summary>Configuring an http4 endpoint with hostname starting with "http" leads to an URISyntaxException</summary>
			<description>Trying to configure an endpoint like


http4://http.org


where the hostname starts with the characters "http" leads to an URISyntaxException "Expected scheme-specific part at index http4:"
This behaviour is caused by the following lines in camel-http4&amp;amp;apos;s HttpComponent (around line 211):


        // need to set scheme on address uri depending on if its secure or not
        String addressUri = remaining.startsWith("http") ? remaining : null;


In our case, the hostname is not prefixed with http:// or https:// which leads to the mentioned exception.
The code in question was introduced within CAMEL-6880. I&amp;amp;apos;m not shure why the variable remaining is checked for a protocol prefix as it already comes without one. Setting


        String addressUri == null;


would solve the problem and does not break any test. </description>
			<version>2.11.4</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http4.HttpEndpointURLTest.java</file>
			<file type="M">org.apache.camel.component.http4.HttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="7349" opendate="2014-04-07 11:34:02" fixdate="2014-04-10 07:10:33" resolution="Duplicate">
		<buginformation>
			<summary>JaxbDataFormat should not parse the Schema over and over again</summary>
			<description>Currently the createMarshaller and createUnmarshaller methods parse the javax.xml.validation.Schema from scratch, which is a severe overhead considering that a Schema instance is threadsafe and it is  encuraged to re-use it as much as possible 
(see http://xerces.apache.org/xerces2-j/javadocs/api/javax/xml/validation/Schema.html) 
I extended the DataFormat and cached the parsed Schema and did a small benchmark:
JaxbDataFormat: 3:18
AltJaxbDataFormat: 0:35
</description>
			<version>2.12.3</version>
			<fixedVersion></fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.jaxb.JaxbDataFormat.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">7350</link>
		</links>
	</bug>
	<bug id="7351" opendate="2014-04-08 14:06:00" fixdate="2014-04-10 07:33:00" resolution="Fixed">
		<buginformation>
			<summary>NPE in CamelInternalProcessor</summary>
			<description>Using Trace mode in Hawtio throws NPE when route uses &amp;lt;onException&amp;gt; to handle a business exception. Trace mode is successful (no NPE) when the route does not throw a business exception (i.e. route is successful).
I suspect that the value of routeDefinition in BacklogTracerAdvice is null when &amp;lt;onException&amp;gt; handles an exception.
CamelInternalProcessor$BacklogTracerAdvice

public BacklogTracerAdvice
(
    Queue&amp;lt;DefaultBacklogTracerEventMessage&amp;gt; queue, 
    BacklogTracer backlogTracer,
    ProcessorDefinition&amp;lt;?&amp;gt; processorDefinition, 
    ProcessorDefinition&amp;lt;?&amp;gt; routeDefinition, 
    boolean first
)




org.apache.camel.processor.CamelInternalProcessor
522		String routeId = routeDefinition.getId();




2014-04-08 09:15:24,036 ERROR {qtp1100200721-83}    [o.a.c.p.FatalFallbackErrorHandler]  \--&amp;gt; New exception on exchangeId: ID-RICHAOSU-ULX1310-54949-1396894883751-56-12
java.lang.NullPointerException
    at o.a.c.p.CamelInternalProcessor$BacklogTracerAdvice.before(CamelInternalProcessor.java:522)
    at o.a.c.p.CamelInternalProcessor.process(CamelInternalProcessor.java:139)
    at o.a.c.p.FatalFallbackErrorHandler.process(FatalFallbackErrorHandler.java:42)
    at o.a.c.p.RedeliveryErrorHandler.deliverToFailureProcessor(RedeliveryErrorHandler.java:839)
    at o.a.c.p.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:337)
    at o.a.c.p.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
    at o.a.c.p.Pipeline.process(Pipeline.java:118)
    at o.a.c.p.Pipeline.process(Pipeline.java:80)
    at o.a.c.p.ChoiceProcessor.process(ChoiceProcessor.java:111)
...

</description>
			<version>2.12.2</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cache.CacheComponent.java</file>
			<file type="M">org.apache.camel.processor.interceptor.DefaultBacklogTracerEventMessage.java</file>
			<file type="M">org.apache.camel.processor.CamelInternalProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="7359" opendate="2014-04-11 00:39:49" fixdate="2014-04-11 12:46:14" resolution="Fixed">
		<buginformation>
			<summary>Simple Language - Additional after text after inbuilt function call is ignored</summary>
			<description>The following Simple expression is valid and runs OK - however it may have been appropriate to report an error to the developer.


            &amp;lt;setBody&amp;gt;
                &amp;lt;simple&amp;gt;${bodyAs(java.lang.String) Additional text ignored...}&amp;lt;/simple&amp;gt;
            &amp;lt;/setBody&amp;gt;


The above seems a somewhat contrived example; However this is a more &amp;amp;apos;realistic&amp;amp;apos; scenario in which the behaviour is not unexpected -


            &amp;lt;setBody&amp;gt;
                &amp;lt;simple&amp;gt;${bodyAs(java.lang.String).toUpperCase()}&amp;lt;/simple&amp;gt;
            &amp;lt;/setBody&amp;gt;


The above simple expression will simply set the body to be of type java.lang.String, however will not invoke the subsequent toUpperCase() call - likewise no error is reported to the developer.
Camel has the same issue when using the function of headerAs and mandatoryBodyAs.</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.language.simple.SimpleTest.java</file>
			<file type="M">org.apache.camel.language.simple.ast.SimpleFunctionExpression.java</file>
		</fixedFiles>
	</bug>
	<bug id="7350" opendate="2014-04-07 11:34:59" fixdate="2014-04-15 03:18:27" resolution="Duplicate">
		<buginformation>
			<summary>JaxbDataFormat should not parse the Schema over and over again</summary>
			<description>Currently the createMarshaller and createUnmarshaller methods parse the javax.xml.validation.Schema from scratch, which is a severe overhead considering that a Schema instance is threadsafe and it is  encuraged to re-use it as much as possible 
(see http://xerces.apache.org/xerces2-j/javadocs/api/javax/xml/validation/Schema.html) 
I extended the DataFormat and cached the parsed Schema and did a small benchmark that parsed an input document 64000 times:
JaxbDataFormat: 3:18
AltJaxbDataFormat: 0:35</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.jaxb.JaxbDataFormat.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">7349</link>
		</links>
	</bug>
	<bug id="7338" opendate="2014-04-02 16:14:36" fixdate="2014-04-15 03:21:11" resolution="Fixed">
		<buginformation>
			<summary>CxfClientCallback should not populate camel exchange OUT message if no response comes back to cxf producer and camel exchange pattern is InOnly</summary>
			<description>I have a following camel route:


String destination = "cxf:http://localhost:9090/test?dataFormat=MESSAGE";

    from("jms:queue:dslSource")
        .onException(java.net.ConnectException.class, Exception.class)
            .maximumRedeliveries(3)
            .maximumRedeliveryDelay(3000)
            .retryAttemptedLogLevel(LoggingLevel.INFO)
            .log(LoggingLevel.WARN, "Failed to send message ${body}") 
            .log(LoggingLevel.WARN, "Sending message to the error queue: ${body}")          // body is null here
            .to("jms:queue:dslError")
            .end()
        .log(LoggingLevel.INFO, "Sending message ...")
        .setHeader("bridgeDestination", constant(destination))
        .to(destination)
        .log(LoggingLevel.INFO, "received back: ${body}")
        .routeId("example-dsl");


If an exception is thrown, for instance, a ConnectionException due to unavailability of the backend web service, the onException() route will be executed. The first log endpoint:


.log(LoggingLevel.WARN, "Failed to send message ${body}") 


prints out camel exchange IN message body without any problem. However, the second log endpoint:


.log(LoggingLevel.WARN, "Sending message to the error queue: ${body}")


only prints out a "null".
The reason is that when an exception is thrown, the CxfClientCallback.handleException() is called:


public void handleException(Map&amp;lt;String, Object&amp;gt; ctx, Throwable ex) {
    ....
        if (!boi.getOperationInfo().isOneWay()) {
            // copy the InMessage header to OutMessage header                 
            camelExchange.getOut().getHeaders().putAll(camelExchange.getIn().getHeaders());
            binding.populateExchangeFromCxfResponse(camelExchange, cxfExchange, ctx);
            camelAsyncCallback.done(false);
        }
...


and this line always populates camel exchange OUT message regardless whether there is a CXF response back or not:


camelExchange.getOut().getHeaders().putAll(camelExchange.getIn().getHeaders());


Therefore, the second log endpoint within onException() block has it&amp;amp;apos;s camel exchange IN message been overwritten and replaced with OUT message from previous endpoint&amp;amp;apos;s although it is a message of NULL body.</description>
			<version>2.10.4</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfProducer.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfClientCallback.java</file>
		</fixedFiles>
	</bug>
	<bug id="7141" opendate="2014-01-17 17:20:36" fixdate="2014-04-15 03:21:55" resolution="Fixed">
		<buginformation>
			<summary>Custom HeaderFilterStrategy does not work when set it on either component or endpoint uri</summary>
			<description>Setting custom HeaderFilterStrategy on either NettyHttpComponent or NettyHttpEndpoint uri does not work. The only way to get it to work is to create a NettyHttpBinding bean and set the custom HeaderFilterStrategy as a property of the NettyHttpBinding bean and then set the custom NettyHttpBinding bean onto either NettyHttpComponent and NettyHttpEndpoint uri.
The reason it does not work was that when applying the custom HeaderFilterStrategy, it is not set on NettyHttpBinding object as the NettyHttpBinding object always uses default HeaderFilterStrategy. 
I have attached the patch file. It might not be necessary to modify NettyHttpComponent class but I thought it&amp;amp;apos;d be better to initialize configuration, nettyBinding and headerFilterStrategy in their getter method only when needed rather than in constructor of the NettyHttpComponent.</description>
			<version>2.12.2</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.http.DefaultNettyHttpBinding.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpEndpoint.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="7369" opendate="2014-04-15 09:02:53" fixdate="2014-04-15 20:10:48" resolution="Fixed">
		<buginformation>
			<summary>camel-mongodb - The readPreference option doesnt work</summary>
			<description>See http://camel.465427.n5.nabble.com/About-a-bug-of-the-camel-mongodb-component-td5750234.html</description>
			<version>2.13.0</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mongodb.MongoDbReadPreferenceOptionTest.java</file>
			<file type="M">org.apache.camel.component.mongodb.MongoDbTailableCursorConsumerTest.java</file>
			<file type="M">org.apache.camel.component.mongodb.AbstractMongoDbTest.java</file>
			<file type="M">org.apache.camel.component.mongodb.MongoDbEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="7363" opendate="2014-04-14 05:49:44" fixdate="2014-04-16 06:39:38" resolution="Fixed">
		<buginformation>
			<summary>camel headers are not preserverd in camel-ahc component</summary>
			<description>The documentation of the camel-ahc component states:
... All headers from the IN message will be copied to the OUT message, so headers are preserved during routing. Additionally Camel will add the HTTP response headers as well to the OUT message headers.
However this is not true. Camel headers are not copied from the in to the out message.
I have looked up other components doing http requests (http4 and cxf) and these components do copy the headers from the in to the out message.</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.ahc.DefaultAhcBinding.java</file>
			<file type="M">org.apache.camel.component.ahc.AhcProduceGetHeadersTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7379" opendate="2014-04-20 14:35:39" fixdate="2014-04-23 13:37:18" resolution="Fixed">
		<buginformation>
			<summary>allChannels should not be static variable for the NettyProducer</summary>
			<description>A user complained that other netty channels would be closed if he just shutdown one of netty producer.  We should not  store the all channels into a static variable. 
http://camel.465427.n5.nabble.com/NettyProducer-stop-will-close-all-channels-belong-to-other-NettyProducer-tp5750374.html </description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.NettyProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7391" opendate="2014-04-24 13:42:29" fixdate="2014-04-24 13:45:01" resolution="Fixed">
		<buginformation>
			<summary>camel-netty - NettyProduce should use timer from component instead of creating new timer per producer</summary>
			<description>We should use the shared timer, instead of creating a new timer per producer.</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.NettyProducer.java</file>
			<file type="M">org.apache.camel.component.netty.NettyClientBossPoolBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="7271" opendate="2014-03-05 00:00:19" fixdate="2014-04-28 05:39:33" resolution="Fixed">
		<buginformation>
			<summary>AbstractListGroupedExchangeAggregationStrategy produces failed exchange if first received exchange fails</summary>
			<description>If the first exchange received by a (concrete implementation of) AggregationStrategy  contains an exception, then the result of the aggregation will also contain that exception, and so will not continue routing without error. This makes the first received exchange have an effect that subsequent exchanges do not have.
The specific use case multicasts to GroupedExchangeAggregationStrategy. The MulticastProcessor.doDone function uses ExchangeHelper.copyResults to copy the aggregated result to the original exchange. The copyResults method copies the exception as well, thereby propagating the error.
 The attached unit test has 3 tests, testAFail, testBFail, and testAllGood. All three of these should pass, but testAFail does not.
What is happening is that AbstractListAggregationStrategy is directly storing its values on and returning the first exchange:
    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        List&amp;lt;V&amp;gt; list;
        if (oldExchange == null) 
{
            list = getList(newExchange);
        }
 else 
{
            list = getList(oldExchange);
        }

        if (newExchange != null) {
            V value = getValue(newExchange);
            if (value != null) 
{
                list.add(value);
            }
        }
        return oldExchange != null ? oldExchange : newExchange;
    }
The pre-CAMEL-5579 version of GroupedExchangeAggregationStrategy created a fresh exchange to store and return the aggregated exchanges:
    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        List&amp;lt;Exchange&amp;gt; list;
        Exchange answer = oldExchange;
        if (oldExchange == null) 
{
            answer = new DefaultExchange(newExchange);
            list = new ArrayList&amp;lt;Exchange&amp;gt;();
            answer.setProperty(Exchange.GROUPED_EXCHANGE, list);
        }
 else 
{
            list = oldExchange.getProperty(Exchange.GROUPED_EXCHANGE, List.class);
        }

        if (newExchange != null) 
{
            list.add(newExchange);
        }
        return answer;
    }</description>
			<version>2.11.3</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.aggregate.GroupedExchangeAggregationStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="7399" opendate="2014-04-28 22:16:42" fixdate="2014-05-02 04:00:46" resolution="Fixed">
		<buginformation>
			<summary>Camel Salesforce integration tests fail with ClassNotFoundException</summary>
			<description>An upgrade to XStream version has broken the alias cache manipulation in XmlRestProcessor. Earlier versions of XStream used to only throw a ClassNotFoundException when CachingMapper.realClass call failed to find a mapped class, but recent versions now add the exception to its cache. This makes it imperative that the cache be flushed when no real class is found. As a result, the cache lookup optimization now only avoids flushing in case the alias mapping hasn&amp;amp;apos;t changed, which still works for repeated invocation of the same endpoint which requires using an XML alias for Salesforce&amp;amp;apos;s RESTish API. </description>
			<version>2.13.0</version>
			<fixedVersion>2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.salesforce.internal.processor.XmlRestProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="7398" opendate="2014-04-28 19:30:30" fixdate="2014-05-04 08:19:27" resolution="Fixed">
		<buginformation>
			<summary>Salesforce recently changed their login API to use new OAuth fields, which breaks the camel-salesforce component</summary>
			<description>Salesforce added new fields to the login API response. These fields should be added to the LoginToken DTO. </description>
			<version>2.13.0</version>
			<fixedVersion>2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.salesforce.internal.dto.LoginToken.java</file>
		</fixedFiles>
	</bug>
	<bug id="7306" opendate="2014-03-18 10:14:36" fixdate="2014-05-04 08:25:13" resolution="Fixed">
		<buginformation>
			<summary>Camel:Kafka NPE when trying to consume messages from kafka server</summary>
			<description>I&amp;amp;apos;ve installed and configured zookeeper and kafka servers using apache quick start guide on ubuntu running in vmware.
Launch producer for already created topic "page_visits" and try to consume messages and nothing happens.
Trying to debug KafkaEndpoint i can see that server doesn&amp;amp;apos;t send me any key (KafkaConstants.KEY) so here:
message.setHeader(KafkaConstants.KEY, new String(mm.key()));
 i got NPE and it silently fails.</description>
			<version>2.13.1</version>
			<fixedVersion>2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.kafka.KafkaEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="7409" opendate="2014-05-05 02:24:16" fixdate="2014-05-05 03:24:23" resolution="Fixed">
		<buginformation>
			<summary>Camel ZipIterator should not eat the IOException</summary>
			<description>If there are some thing wrong with the Zip file which is split by ZipIterator, we cannot find any warning or exception from the camel route. We should not let ZipIterator eat up the exception without do anything.</description>
			<version>2.13.0</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.zipfile.ZipIterator.java</file>
			<file type="M">org.apache.camel.dataformat.zipfile.ZipSplitterRouteIssueTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7411" opendate="2014-05-05 11:39:53" fixdate="2014-05-06 07:56:44" resolution="Fixed">
		<buginformation>
			<summary>EventDrivenPollingConsumer can lose exchanges when the internal queue is full</summary>
			<description>The exchange processing in the EventDrivenPollingConsumer can lose exchanges when the internal queue is bounded and full.
The implementation:

public void process(Exchange exchange) throws Exception {
    queue.offer(exchange);
}


The reason is that BlockingQueue.offer(...) is non-blocking and returns a boolean which indicates whether the element was added.
However, the return value is ignored causing the exchange to get lost if it could not be added.
A potential workaround is to use an unbounded BlockingQueue (e.g. LinkedBlockingQueue).</description>
			<version>2.13.0</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.EventDrivenPollingConsumer.java</file>
			<file type="M">org.apache.camel.impl.DefaultEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="7424" opendate="2014-05-08 08:16:40" fixdate="2014-05-08 09:41:41" resolution="Fixed">
		<buginformation>
			<summary>StaxSource doesn&amp;apos;t produce correct SAX events with default namespace</summary>
			<description>See full description here: CXF-5733</description>
			<version>2.12.3</version>
			<fixedVersion>2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.jaxp.StaxSource.java</file>
		</fixedFiles>
	</bug>
	<bug id="7426" opendate="2014-05-09 08:32:55" fixdate="2014-05-09 11:46:36" resolution="Fixed">
		<buginformation>
			<summary>camel-http component should skip reading the form body if it is bridgeEndpoint</summary>
			<description>When the camel http related component gets the post request of from, it always parsers the request body to get the from parameter. This feature could cause some trouble when the camel route proxy the request to other endpoint.</description>
			<version>2.11.4</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http4.CamelServlet.java</file>
			<file type="M">org.apache.camel.component.http4.DefaultHttpBinding.java</file>
			<file type="M">org.apache.camel.component.http4.HttpMessage.java</file>
			<file type="M">org.apache.camel.component.http.HttpMessage.java</file>
			<file type="M">org.apache.camel.component.http.DefaultHttpBinding.java</file>
			<file type="M">org.apache.camel.component.jetty.HttpProxyRouteTest.java</file>
			<file type="M">org.apache.camel.component.jetty.CamelContinuationServlet.java</file>
			<file type="M">org.apache.camel.component.http.CamelServlet.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">7427</link>
		</links>
	</bug>
	<bug id="7427" opendate="2014-05-09 08:34:46" fixdate="2014-05-09 11:46:59" resolution="Fixed">
		<buginformation>
			<summary>camel-netty-http component should skip reading the form body if it is bridgeEndpoint</summary>
			<description>We need to fix the same issue of CAMEL-7426 in camel-netty-http</description>
			<version>2.13.0</version>
			<fixedVersion>2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.http.DefaultNettyHttpBinding.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpBridgeRouteUsingHttpClientTest.java</file>
			<file type="M">org.apache.camel.component.netty.http.handlers.HttpServerChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpComponent.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">7426</link>
		</links>
	</bug>
	<bug id="7428" opendate="2014-05-09 09:19:57" fixdate="2014-05-11 09:23:02" resolution="Duplicate">
		<buginformation>
			<summary>Simple Language - Operators are not evaluated for setting body or headers</summary>
			<description>Operators are not evaluated if using simple for setting bodies or headers:


from("direct:simple")
    .setHeader("myHeader").simple("true == true", Boolean.class)
    .log("header = [${header.myHeader}]")
    .setBody(simple("true == true", Boolean.class))
    .log("body = [${body}]");


Output is as follows:


INFO  header = [false]
INFO  body = [false]


The outcome should be true in both cases.
Also, see http://stackoverflow.com/questions/23523409/camel-how-to-set-boolean-header-parameter-using-simple-comparison/23560989#23560989</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.1, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.language.simple.SimpleLanguage.java</file>
			<file type="M">org.apache.camel.language.simple.SimpleParserPredicateTest.java</file>
			<file type="M">org.apache.camel.builder.SimpleBuilder.java</file>
			<file type="M">org.apache.camel.language.simple.SimplePredicateParser.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">7298</link>
		</links>
	</bug>
	<bug id="7431" opendate="2014-05-12 13:09:11" fixdate="2014-05-13 14:26:14" resolution="Fixed">
		<buginformation>
			<summary>Impossible to use an existing javax.mail.Session with DefaultJavaMailSender</summary>
			<description>When using DefaultJavaMailSender with an existing javax.mail.Session instance (i.e. retrieved from JNDI) it is not possible to leave host and port unconfigured.
My JavaMailSender is configured as follows:
    @Bean
    public JavaMailSender mailSender() 
{
        JavaMailSender jms = new DefaultJavaMailSender();
        jms.setSession(mailSession);
        jms.setProtocol("smtp");
        return jms;
    }

mailSession is a preconfigured Session instance retrieved from JNDI registry. I do not know about it&amp;amp;apos;s configuration.
When calling the send() method, it tries to connect using the connect(host, port, username, password) method passing the (unconfigured) host and port which defaults to localhost:0 and then fails.
In case the session is supplied, it should call connect() instead.</description>
			<version>2.13.0</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.DefaultJavaMailSender.java</file>
		</fixedFiles>
	</bug>
	<bug id="7449" opendate="2014-05-20 12:36:32" fixdate="2014-05-22 03:13:59" resolution="Fixed">
		<buginformation>
			<summary>Camel Subscribing to messages published by non-camel producers</summary>
			<description>I have come across an issue with Camel 2.13 when subscribing to a qpid messages published by a non-camel producers. The error happens with both Qpid C++ producer and also a python producer. 
An Null pointer exception is thrown in the JmsBinding.extractHeadersFromJMS on line 173. 
map.put("JMSXUserID", jmsMessage.getStringProperty("JMSXUserID")); 
JMSXUserID has not been set by the publisher as it is a non-JMS publisher. 
java.lang.NullPointerException
at java.lang.String.&amp;lt;init&amp;gt;(String.java:593)
at org.apache.qpid.client.message.AMQMessageDelegate_0_10.getStringProperty(AMQMessageDelegate_0_10.java:735)
at org.apache.qpid.client.message.AbstractJMSMessage.getStringProperty(AbstractJMSMessage.java.225)
at org.apache.camel.component.jms.JmsBinding.extractHeadersFromJms(JmsBinding.java:173)
at org.apache.camel.component.jms.JmsMessage.populateInitialHeaders(JmsMessage.java:222)
Full stack trace not show as it is on a different system
I can see a change was made to JmsBinding.java in Camel 2.12.2 to fix a ActiveMQ issue. This is what has caused the issue. The system is being upgraded from Camel 2.9.2 to Camel 2.13.1 and this issue has been experienced.</description>
			<version>2.13.0</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsMessageHelper.java</file>
			<file type="M">org.apache.camel.component.jms.JmsBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="7459" opendate="2014-05-22 19:36:09" fixdate="2014-05-23 07:00:15" resolution="Fixed">
		<buginformation>
			<summary>parseQuery Drops Char When Last Parameter is RAW with value ending in &amp;apos;)&amp;apos;</summary>
			<description>org.apache.camel.util.URISupport
When processing RAW parameters as part of parseQuery a look ahead to the next char is needed in order to determine the end of the RAW value.  The logic to prevent a StringIndexOutOfBoundsException drops the last char when evaluating for next char when the current char (i) is the second to last char of the string.
This becomes an issue when the RAW value ends in &amp;amp;apos;)&amp;amp;apos; 
Consider:
uri = "foo=RAW(ba(r))"
uri.length() = 14
i = 12
uri.charAt(12) = &amp;amp;apos;)&amp;amp;apos;
uri.charAt(13) = &amp;amp;apos;)&amp;amp;apos;
(i &amp;lt; uri.legnth() - 2) = 12 &amp;lt; (14 - 2) = 12 &amp;lt; 12 = false
thus next = "\u0000"
The RAW value now ends satisfying the requirements and the char at index 13 is never read.  The resulting parameter is "foo=RAW(ba(r)".
The logic to prevent the index exception should be "(i &amp;lt;= uri.legnth() -2)" or "(i &amp;lt; uri.legnth() - 1)"</description>
			<version>2.11.0</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.URISupport.java</file>
			<file type="M">org.apache.camel.issues.EndpointWithRawUriParameterTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7451" opendate="2014-05-21 06:43:31" fixdate="2014-05-23 07:05:07" resolution="Fixed">
		<buginformation>
			<summary>FTP consumer sometimes throws NullPointerException</summary>
			<description>I have an exception from a ftp consumer only for few files.

It happens on few files (2 or 3). Remote directory contains many files
(many thousand)


These few files have the same ownership and permissions of the others
and are not empty


I stopped the application that create the files, to avoid any possible
lock (anyway, I can modify them without problems)


I tried to copy and rename the files, removing the old one, (to create
a completely new one) without success


Looking at the source code in
FtpChangedExclusiveReadLockStrategy.java, the error happens getting the
timestamp of the file:


for (FTPFile f : files) {
    if (f.getName().equals(file.getFileNameOnly())) {
        newLastModified = f.getTimestamp().getTimeInMillis();
        newLength = f.getSize();
    }
}




Nothing useful in the logs of the ftp server

Follow a trace log and the exception regarding one of those files:


2014-05-19 16:21:32,298 TRACE FtpChangedExclusiveReadLockStrategy -
Waiting for exclusive read lock to file:
RemoteFile[/dwrg1/moved/DWRG1_2014-03-30T01h30Z.xml]
2014-05-19 16:21:32,298 TRACE FtpChangedExclusiveReadLockStrategy -
Waiting for exclusive read lock to file:
RemoteFile[/dwrg1/moved/DWRG1_2014-03-30T01h30Z.xml]
2014-05-19 16:21:32,298 TRACE FtpChangedExclusiveReadLockStrategy -
Waiting for exclusive read lock to file:
RemoteFile[/dwrg1/moved/DWRG1_2014-03-30T01h30Z.xml]
2014-05-19 16:21:32,299 TRACE FtpChangedExclusiveReadLockStrategy -
Using fast exists to update file information for
RemoteFile[/dwrg1/moved/DWRG1_2014-03-30T01h30Z.xml]
2014-05-19 16:21:32,299 TRACE FtpChangedExclusiveReadLockStrategy -
Using fast exists to update file information for
RemoteFile[/dwrg1/moved/DWRG1_2014-03-30T01h30Z.xml]
2014-05-19 16:21:32,640 TRACE FtpChangedExclusiveReadLockStrategy - List
files /dwrg1/moved/DWRG1_2014-03-30T01h30Z.xml found 1 files
2014-05-19 16:21:32,640 TRACE FtpChangedExclusiveReadLockStrategy - List
files /dwrg1/moved/DWRG1_2014-03-30T01h30Z.xml found 1 files
2014-05-19 16:21:32,650 WARN  FtpConsumer -
Endpoint[ftp://xxxx@yy.yy.yy.yy//dwrg1/moved?delay=60000&amp;amp;disconnect=true&amp;amp;fastExistsCheck=true&amp;amp;idempotent=true&amp;amp;idempotentKey=%24%7Bfile%3Aname%7D-%24%7Bfile%3Amodified%7D-%24%7Bfile%3Asize%7D&amp;amp;idempotentRepository=%23fileStore&amp;amp;include=DWRG1.*%5C.xml&amp;amp;maxMessagesPerPoll=10&amp;amp;noop=true&amp;amp;password=xxxxxx&amp;amp;readLock=changed&amp;amp;sortBy=file%3Amodified] cannot begin processing file: RemoteFile[/dwrg1/moved/DWRG1_2014-03-30T01h30Z.xml] due to: null. Caused by: [java.lang.NullPointerException - null]
java.lang.NullPointerException
        at
org.apache.camel.component.file.remote.strategy.FtpChangedExclusiveReadLockStrategy.acquireExclusiveReadLock(FtpChangedExclusiveReadLockStrategy.java:83)
        at
org.apache.camel.component.file.strategy.GenericFileProcessStrategySupport.begin(GenericFileProcessStrategySupport.java:49)
        at
org.apache.camel.component.file.strategy.GenericFileRenameProcessStrategy.begin(GenericFileRenameProcessStrategy.java:35)
        at
org.apache.camel.component.file.GenericFileConsumer.processExchange(GenericFileConsumer.java:326)
        at
org.apache.camel.component.file.remote.RemoteFileConsumer.processExchange(RemoteFileConsumer.java:99)
        at
org.apache.camel.component.file.GenericFileConsumer.processBatch(GenericFileConsumer.java:201)
        at
org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:165)
        at
org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:187)
        at
org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:114)
        at java.util.concurrent.Executors
$RunnableAdapter.call(Executors.java:471)
        at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:304)
        at java.util.concurrent.ScheduledThreadPoolExecutor
$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:178)
        at java.util.concurrent.ScheduledThreadPoolExecutor
$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
        at
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
        at java.util.concurrent.ThreadPoolExecutor
$Worker.run(ThreadPoolExecutor.java:615)
        at java.lang.Thread.run(Thread.java:745)

</description>
			<version>2.13.0</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.strategy.FtpChangedExclusiveReadLockStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="7462" opendate="2014-05-23 08:42:28" fixdate="2014-05-23 11:16:57" resolution="Fixed">
		<buginformation>
			<summary>camel-netty-http doesn&amp;apos;t use "Expect: 100-continue" correctly</summary>
			<description>Camel-netty-http component, when sending HTTP request with:

Expect: 100-continue


header, always sends the HTTP body with first request and treats:

HTTP/1.1 100 Continue


as final response.
Additionally org.apache.camel.component.netty.http.handlers.HttpServerChannelHandler sends HTTP/1.1 100 Continue partial response after the same partial response was send by org.jboss.netty.handler.codec.http.HttpChunkAggregator#messageReceived
Attached: wireshark session dump.</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.http.handlers.HttpClientChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty.http.handlers.HttpServerChannelHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="7415" opendate="2014-05-06 06:51:59" fixdate="2014-05-24 09:44:28" resolution="Fixed">
		<buginformation>
			<summary>lazyLoad with CSV blows up on last line</summary>
			<description>


CsvDataFormat csv = new CsvDataFormat() 
csv.setDelimiter(&amp;amp;apos; &amp;amp;apos;) 
csv.setSkipFirstLine(false) 
csv.setLazyLoad(true) 

CamelContext camelContext = new DefaultCamelContext() 
camelContext.addRoutes(new RouteBuilder() { 
def void configure() { 
from(&amp;amp;apos;direct:start&amp;amp;apos;) 
.unmarshal(csv) 
.split(body()).streaming() 
.log(&amp;amp;apos;row: ${body}&amp;amp;apos;) 
} 
}) 
camelContext.start() 

ProducerTemplate t = camelContext.createProducerTemplate() 
t.sendBody(&amp;amp;apos;direct:start&amp;amp;apos;, new File(&amp;amp;apos;/Users/timbo/data/test.txt&amp;amp;apos;)) 

camelContext.stop() 



Here is the exception when camel try to access the last line of the file.



java.lang.IllegalStateException: java.io.IOException: Stream closed 
at 
org.apache.camel.dataformat.csv.CsvIterator.next(CsvIterator.java:61) 
at 
org.apache.camel.processor.Splitter$SplitterIterable$1.next(Splitter.java:170) 
at 
org.apache.camel.processor.Splitter$SplitterIterable$1.next(Splitter.java:146) 
at 
org.apache.camel.processor.MulticastProcessor.doProcessSequential(MulticastProcessor.java:502) 

</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.csv.CsvUnmarshalStreamTest.java</file>
			<file type="M">org.apache.camel.processor.UnmarshalProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="7457" opendate="2014-05-22 14:22:51" fixdate="2014-05-26 07:56:17" resolution="Fixed">
		<buginformation>
			<summary>[camel-cxf] cxfrs: SimpleConsumer does not honur Accept header</summary>
			<description>Content negotiation does not work correctly.
I create service class and spring xml as follows.
CustomerService.java

@Path("/customer")
public class CustomerService {
    
    @GET
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    public Customers getCustomers() {
        return null;
    }
}




    &amp;lt;cxf:rsServer xmlns:cxf="http://camel.apache.org/schema/cxf"
                  id="rsServer"
                  address="http://localhost:9999/rsServer"
                  loggingFeatureEnabled="true"
                  loggingSizeLimit="200"&amp;gt; 
        &amp;lt;cxf:serviceBeans&amp;gt;
            &amp;lt;ref bean="CustomerService" /&amp;gt;
        &amp;lt;/cxf:serviceBeans&amp;gt;
        &amp;lt;cxf:providers&amp;gt;
            &amp;lt;ref bean="jettisonProvider" /&amp;gt;
        &amp;lt;/cxf:providers&amp;gt;
    &amp;lt;/cxf:rsServer&amp;gt;

        
    &amp;lt;!-- provider --&amp;gt;
    &amp;lt;bean id="jettisonProvider" class="org.apache.cxf.jaxrs.provider.json.JSONProvider" /&amp;gt;
            
    &amp;lt;!-- interface --&amp;gt;    
    &amp;lt;bean id="CustomerService" class="com.buildria.camel.cxf.negotiation.CustomerService" /&amp;gt;
    &amp;lt;!-- Concrete class --&amp;gt;
    &amp;lt;bean id="CustomerServiceImpl" class="com.buildria.camel.cxf.negotiation.CustomerServiceImpl" /&amp;gt;
    
    &amp;lt;camelContext xmlns="http://camel.apache.org/schema/spring"&amp;gt;
 
        &amp;lt;route&amp;gt; 
            &amp;lt;!-- (1) SimpleConsumer BindingStyle --&amp;gt;
            &amp;lt;from uri="cxfrs://bean://rsServer?bindingStyle=SimpleConsumer" /&amp;gt;
            &amp;lt;!-- (2) Default BindingStyle --&amp;gt;
            &amp;lt;!-- &amp;lt;from uri="cxfrs://bean://rsServer" /&amp;gt;--&amp;gt;
            
            &amp;lt;choice&amp;gt;
                &amp;lt;when&amp;gt;
                    &amp;lt;simple&amp;gt;$simple{headers.operationName} == &amp;amp;apos;getCustomers&amp;amp;apos;&amp;lt;/simple&amp;gt;
                    &amp;lt;bean ref="CustomerServiceImpl" method="getCustomers" /&amp;gt;
                &amp;lt;/when&amp;gt;
                &amp;lt;otherwise&amp;gt;
                    &amp;lt;setHeader headerName="CamelHttpResponseCode"&amp;gt;
                        &amp;lt;constant&amp;gt;404&amp;lt;/constant&amp;gt;
                    &amp;lt;/setHeader&amp;gt;
                &amp;lt;/otherwise&amp;gt;
            &amp;lt;/choice&amp;gt;
        &amp;lt;/route&amp;gt;
    &amp;lt;/camelContext&amp;gt;


A) I tested it with curl command like this.

$ curl  -H "Accept: application/json"  http://localhost:9999/rsServer/customer/ 
{"customers":{"customers":{"address":"Japan","name":"Ken"}}}sogabe@emilia ~/src/camel/camel-rest-cxfrs [2.10.6] 2014/05/22  23:15:56 
$ LANG=C curl  -H "Accept: application/json"  http://localhost:9999/rsServer/customer/ -v
* Hostname was NOT found in DNS cache
*   Trying ::1...
* connect to ::1 port 9999 failed: Connection refused
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 9999 (#0)
&amp;gt; GET /rsServer/customer/ HTTP/1.1
&amp;gt; User-Agent: curl/7.36.0
&amp;gt; Host: localhost:9999
&amp;gt; Accept: application/json
&amp;gt; 
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Accept: application/json
&amp;lt; breadcrumbId: ID-emilia-46343-1400768103395-0-7
&amp;lt; Content-Type: application/json
&amp;lt; Date: Thu, 22 May 2014 14:16:12 GMT
&amp;lt; Host: localhost:9999
&amp;lt; User-Agent: curl/7.36.0
&amp;lt; Transfer-Encoding: chunked
* Server Jetty(8.1.14.v20131031) is not blacklisted
&amp;lt; Server: Jetty(8.1.14.v20131031)
&amp;lt; 
* Connection #0 to host localhost left intact
{"customers":{"customers":{"address":"Japan","name":"Ken"}}}


I got a reponse as a JSON format. It&amp;amp;apos;s OK!
B) But if "Content-Type: application/xml"  specified,

$ LANG=C curl  -H "Accept: application/json"  -H "Content-Type: application/xml" http://localhost:9999/rsServer/customer/ -v
* Hostname was NOT found in DNS cache
*   Trying ::1...
* connect to ::1 port 9999 failed: Connection refused
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 9999 (#0)
&amp;gt; GET /rsServer/customer/ HTTP/1.1
&amp;gt; User-Agent: curl/7.36.0
&amp;gt; Host: localhost:9999
&amp;gt; Accept: application/json
&amp;gt; Content-Type: application/xml
&amp;gt; 
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Accept: application/json
&amp;lt; breadcrumbId: ID-emilia-46343-1400768103395-0-9
&amp;lt; Content-Type: application/xml
&amp;lt; Date: Thu, 22 May 2014 14:19:17 GMT
&amp;lt; Host: localhost:9999
&amp;lt; User-Agent: curl/7.36.0
&amp;lt; Transfer-Encoding: chunked
* Server Jetty(8.1.14.v20131031) is not blacklisted
&amp;lt; Server: Jetty(8.1.14.v20131031)
&amp;lt; 
* Connection #0 to host localhost left intact
&amp;lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&amp;gt;&amp;lt;customers&amp;gt;&amp;lt;customers&amp;gt;&amp;lt;address&amp;gt;Japan&amp;lt;/address&amp;gt;&amp;lt;name&amp;gt;Ken&amp;lt;/name&amp;gt;&amp;lt;/customers&amp;gt;&amp;lt;/customers&amp;gt;


I got a response as a xml format. It should be JSON format.
C) replace SimpleConsumer with Default style.
( (2) in spring.xml)

 $ LANG=C curl  -H "Accept: application/json"  -H "Content-Type: application/xml" http://localhost:9999/rsServer/customer/ -v
* Hostname was NOT found in DNS cache
*   Trying ::1...
* connect to ::1 port 9999 failed: Connection refused
*   Trying 127.0.0.1...
* Connected to localhost (127.0.0.1) port 9999 (#0)
&amp;gt; GET /rsServer/customer/ HTTP/1.1
&amp;gt; User-Agent: curl/7.36.0
&amp;gt; Host: localhost:9999
&amp;gt; Accept: application/json
&amp;gt; Content-Type: application/xml
&amp;gt; 
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Content-Type: application/json
&amp;lt; Date: Thu, 22 May 2014 14:27:19 GMT
&amp;lt; Transfer-Encoding: chunked
* Server Jetty(8.1.14.v20131031) is not blacklisted
&amp;lt; Server: Jetty(8.1.14.v20131031)
&amp;lt; 
* Connection #0 to host localhost left intact
{"customers":{"customers":{"address":"Japan","name":"Ken"}}}



It&amp;amp;apos;s OK without bindingStyle option.</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsHeaderFilterStrategyTest.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsHeaderFilterStrategy.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">7465</link>
		</links>
	</bug>
	<bug id="7450" opendate="2014-05-20 16:29:10" fixdate="2014-05-28 14:50:03" resolution="Fixed">
		<buginformation>
			<summary>CsvDataFormat unable to setup header when useMaps="true"</summary>
			<description>Hi all,
 seems that it is impossible to setup the header of a csv when using a map.
It is always used the first line of the CSV file.
Using this configuration in conjunction with my patch I&amp;amp;apos;m currently able to do so (also having the skipFirstLine flag working with useMaps="true")
Configuration:
https://github.com/ccancellieri/camel_poc/blob/master/src/main/resources/META-INF/spring/camel-context.xml</description>
			<version>2.13.0</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.csv.CsvUnmarshalMapLineTest.java</file>
			<file type="M">org.apache.camel.dataformat.csv.CsvDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="7472" opendate="2014-05-28 20:08:05" fixdate="2014-05-28 20:42:51" resolution="Fixed">
		<buginformation>
			<summary>camel-netty - SingleUDPNettyServerBootstrapFactory should wait synchronously for the outcome of joining a UDP multicast group so that we know if the attempt was successful or not</summary>
			<description>In terms of Netty we need to wait until joining the multicast group is done so that starting the NettyConsumer succeeds or fails accordingly. Then we know exactly if and what failed while trying to join the multicast group.</description>
			<version>2.12.0</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.NettyUDPMulticastAsyncTest.java</file>
			<file type="M">org.apache.camel.component.netty.SingleUDPNettyServerBootstrapFactory.java</file>
			<file type="M">org.apache.camel.component.netty.NettyUDPAsyncTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">6563</link>
		</links>
	</bug>
	<bug id="7478" opendate="2014-06-04 17:42:22" fixdate="2014-06-06 01:29:36" resolution="Fixed">
		<buginformation>
			<summary>Simple Language - Length of array properties is not correctly evaluated</summary>
			<description>If the exchange body is an array, then body.length returns correctly the length of the array. However, if the array is a property of an object, then not the correct value is returned:
MyClass.java

public class MyClass {
    public Object[] getMyArray() {
        return new Object[]{"Hallo", "World", "!"};
    }
}


Accessing the property myArray with Simple:


&amp;lt;setHeader headerName="mySimpleHeader"&amp;gt;
    &amp;lt;simple&amp;gt;body.myArray.length&amp;lt;/simple&amp;gt;
&amp;lt;/setHeader&amp;gt;
&amp;lt;log message="mySimpleHeader = ${header.mySimpleHeader}" /&amp;gt;


Java:


final ProducerTemplate template = main.getCamelTemplate();
template.sendBody("direct:start", new MyClass());


Log:

[main] route1 INFO  mySimpleHeader = 1


The return value should be 3 instead of 1.</description>
			<version>2.13.1</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.language.simple.SimpleTest.java</file>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
			<file type="M">org.apache.camel.language.bean.BeanExpression.java</file>
		</fixedFiles>
	</bug>
	<bug id="7483" opendate="2014-06-06 10:19:36" fixdate="2014-06-06 12:03:07" resolution="Fixed">
		<buginformation>
			<summary>SmppConfiguration has wrong value setDataCoding</summary>
			<description>// SmppConfiguration has wrong value setDataCoding
public void setDataCoding(byte dataCoding) 
{
        this.alphabet = dataCoding;
    }</description>
			<version>2.13.1</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.smpp.SmppConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="7471" opendate="2014-05-28 14:01:45" fixdate="2014-06-10 06:59:45" resolution="Fixed">
		<buginformation>
			<summary>SOAP with attachments not mapped correctly from CXF to Camel for CXF_MESSAGE</summary>
			<description>SOAP with attachments messages are not mapped correctly from CXF to Camel and back if using CXF_MESSAGE message format. 
We are having following simple camel route:


&amp;lt;route&amp;gt;
    &amp;lt;from uri="cxf:bean:Endpoint1" /&amp;gt;
    &amp;lt;to uri="cxf:bean:Endpoint2" /&amp;gt;
&amp;lt;/route&amp;gt;


So mapping between CXF Endpoint 1 and Camel creates attachments in Camel exchange and sets the Camel IN message as a soap message. However, it&amp;amp;apos;s missing a bit of removing the attachments from the message as they are already added to the Camel Exchange.
Mapping from Camel and CXF Endpoint 2 maps Camel IN message (Soap with attachments) to CXF and then adds the attachments from Camel exchange which results in a messed up soap message that appears to contain twice as many attachments and it has messed up MIME boundaries as well as some of them are from the input message and some of them are generated during the last mapping.
As a workaround we have added a Camel processor that clears the attachments from the IN Message in Camel .</description>
			<version>2.10.4</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="7497" opendate="2014-06-11 09:09:08" fixdate="2014-06-11 13:12:01" resolution="Fixed">
		<buginformation>
			<summary>Duplicate classes </summary>
			<description>It looks like there are duplicate classes between the camel-test and camel-test-spring artifacts:


[WARNING] Rule 0: org.apache.maven.plugins.enforcer.BanDuplicateClasses failed with message:
Duplicate classes found:

  Found in:
    org.apache.camel:camel-test:jar:2.13.1:test
    org.apache.camel:camel-test-spring:jar:2.13.1:test
  Duplicate classes:
    org/apache/camel/test/junit4/CamelTestSupport$1.class
    org/apache/camel/test/junit4/CamelTestSupport$4.class
    org/apache/camel/test/junit4/CamelTestSupport$2.class
    org/apache/camel/test/junit4/CamelTestSupport$DebugBreakpoint.class
    org/apache/camel/test/junit4/LanguageTestSupport.class
    org/apache/camel/test/junit4/CamelTestSupport.class
    org/apache/camel/test/junit4/TestSupport.class
    org/apache/camel/test/junit4/ExchangeTestSupport.class
    org/apache/camel/test/junit4/CamelTestSupport$3.class

</description>
			<version>2.13.1</version>
			<fixedVersion>2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.camel.test.junit4.CamelSpringTestSupport.java</file>
			<file type="D">org.apache.camel.test.junit4.CamelSpringJUnit4ClassRunner.java</file>
		</fixedFiles>
	</bug>
	<bug id="7502" opendate="2014-06-12 05:48:36" fixdate="2014-06-13 02:52:20" resolution="Fixed">
		<buginformation>
			<summary>camel-elastichsearch - starts up an instance even though IP specified</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/camel-elasticsearch-component-starts-up-an-instance-even-though-IP-specified-tp5751825.html
</description>
			<version>2.13.1</version>
			<fixedVersion>2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.elasticsearch.ElasticsearchEndpoint.java</file>
			<file type="M">org.apache.camel.component.elasticsearch.ElasticsearchConfigurationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7506" opendate="2014-06-13 06:26:22" fixdate="2014-06-13 06:30:50" resolution="Fixed">
		<buginformation>
			<summary>[NettyHttp] Remove headerFilterStrategy option after resolving</summary>
			<description>In Camel Netty HTTP component, we don&amp;amp;apos;t remove headerFilterStrategy option from the parameters, so it is propagated as a query parameter.
When I create producer URL like this - netty-http:http://host.com?headerFilterStrategy=#headerFilterStrategy&amp;amp;foo=bar I expect only foo=bar to be send as a query to to endpoint (while headerFilterStrategy=#headerFilterStrategy should be resolved from the registry and removed from the parameters). This is how it works in Jetty component for example.</description>
			<version>2.13.1</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="7513" opendate="2014-06-16 15:51:57" fixdate="2014-06-16 18:39:30" resolution="Fixed">
		<buginformation>
			<summary>Using JPA entities as the argument in Aggregator using POJO</summary>
			<description>I have an Aggregator POJO with this method :
public Map&amp;lt;Hoteles, List&amp;lt;EventoPrecio&amp;gt;&amp;gt; agregaEventoPrecio(Map&amp;lt;Hoteles, List&amp;lt;EventoPrecio&amp;gt;&amp;gt; lista, EventoPrecio evento) 
With this route :
from("timer://tesipro?fixedRate=true&amp;amp;period=60000").
beanRef("uploadARIService", "getEventosPrecio").
aggregate(constant(true), AggregationStrategies.bean(AgregadorEventos.class, "agregaEventoPrecio")).
completionSize(100).
log("Ejecucion de Quartz ");
And I get this error :
Error occurred during starting Camel: CamelContext(249-camel-9) due Parameter annotations at index 1 is not supported on method: public java.util.HashMap com.tesipro.conectores.interfaces.tesiproconpush.camel.AgregadorEventos.agregaEventoPrecio(java.util.HashMap,com.tesipro.conectores.domain.EventoPrecio)          
It seems the problem is that annotations are not supported in the aggregator arguments nor in the argument class.
https://github.com/apache/camel/blob/3f4f8e9ddcc8de32cca084927a10c5b3bceef7f9/camel-core/src/main/java/org/apache/camel/processor/aggregate/AggregationStrategyBeanInfo.java#L67</description>
			<version>2.13.1</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.aggregator.AggregationStrategyBeanAdapterAllowNullTest.java</file>
			<file type="M">org.apache.camel.processor.aggregate.AggregationStrategyBeanInfo.java</file>
		</fixedFiles>
	</bug>
	<bug id="7518" opendate="2014-06-17 18:38:18" fixdate="2014-06-17 18:41:23" resolution="Fixed">
		<buginformation>
			<summary>FileUtil.renameFile - should return true if file was renamed using copy/delete approach</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Bug-in-org-apache-camel-util-FileUtil-renameFile-introduced-in-2-13-0-tp5752450.html
Regression introduced by CAMEL-6458</description>
			<version>2.13.0</version>
			<fixedVersion>2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.FileUtil.java</file>
		</fixedFiles>
	</bug>
	<bug id="7429" opendate="2014-05-09 10:48:46" fixdate="2014-06-19 07:18:04" resolution="Fixed">
		<buginformation>
			<summary>Camel Properties Component concatenation issue </summary>
			<description>Hi,
Suppose you have a properties file of this type


#PROPERTIES CONCATENATION
prop1=file:
prop2=dirname
concat.property={{prop1}}{{prop2}}

#PROPERTIES WITHOUT CONCATENATION
property.complete=file:dirname


and you want to use the property concat.property. Using Camel 2.10.3 loading this property doesn&amp;amp;apos;t create any kind of problem. When I upgrade to Camel 2.12.3 I get an exception, that you can reproduce with the following informations.
In DefaultPropertiesParser class of org.apache.camel.component.properties package, I found a strange behaviour relative to that specific kind of property.  When I execute a test like the following, (the first try to use concatenated property and the second try to use property without concatenation):
PropertiesComponentConcatenatePropertiesTest.java

import org.apache.camel.CamelContext;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;

public class PropertiesComponentConcatenatePropertiesTest extends ContextTestSupport {
    
    @Override
    protected CamelContext createCamelContext() throws Exception {
        CamelContext context = super.createCamelContext();
        context.addComponent("properties", new PropertiesComponent("classpath:org/apache/camel/component/properties/concatenation.properties"));
        return context;
    }
    
    @Override
    protected void setUp() throws Exception {
        System.setProperty("environment", "junit");
        super.setUp();
    }
    
    @Override
    protected void tearDown() throws Exception {
        System.clearProperty("environment");
        super.tearDown();
    }
    
    public void testConcatPropertiesComponentDefault() throws Exception {
        context.addRoutes(new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from("direct:start").setBody(simple("${properties:concat.property}"))
                .to("mock:result");
            }
        });
        context.start();

        getMockEndpoint("mock:result").expectedBodiesReceived("file:dirname");

        template.sendBody("direct:start", "Test");

        assertMockEndpointsSatisfied();
    }
    
    public void testWithoutConcatPropertiesComponentDefault() throws Exception {
        context.addRoutes(new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from("direct:start").setBody(simple("${properties:property.complete}"))
                .to("mock:result");
            }
        });
        context.start();

        getMockEndpoint("mock:result").expectedBodiesReceived("file:dirname");

        template.sendBody("direct:start", "Test");

        assertMockEndpointsSatisfied();
    }
}


The first test return the following exception:


org.apache.camel.CamelExecutionException: Exception occurred during execution on the exchange: Exchange[Message: Test]
	at org.apache.camel.util.ObjectHelper.wrapCamelExecutionException(ObjectHelper.java:1379)
	at org.apache.camel.util.ExchangeHelper.extractResultBody(ExchangeHelper.java:622)
	at org.apache.camel.impl.DefaultProducerTemplate.extractResultBody(DefaultProducerTemplate.java:467)
	at org.apache.camel.impl.DefaultProducerTemplate.extractResultBody(DefaultProducerTemplate.java:463)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:139)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:144)
	at org.apache.camel.component.properties.PropertiesComponentConcatenatePropertiesTest.testConcatPropertiesComponentDefault(PropertiesComponentConcatenatePropertiesTest.java:56)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at junit.framework.TestCase.runTest(TestCase.java:176)
	at junit.framework.TestCase.runBare(TestCase.java:141)
	at org.apache.camel.TestSupport.runBare(TestSupport.java:58)
	at junit.framework.TestResult$1.protect(TestResult.java:122)
	at junit.framework.TestResult.runProtected(TestResult.java:142)
	at junit.framework.TestResult.run(TestResult.java:125)
	at junit.framework.TestCase.run(TestCase.java:129)
	at junit.framework.TestSuite.runTest(TestSuite.java:255)
	at junit.framework.TestSuite.run(TestSuite.java:250)
	at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:84)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)
Caused by: org.apache.camel.RuntimeCamelException: java.lang.IllegalArgumentException: Expecting }} but found end of string from text: prop1}}{{prop2
	at org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException(ObjectHelper.java:1363)
	at org.apache.camel.builder.ExpressionBuilder$78.evaluate(ExpressionBuilder.java:1784)
	at org.apache.camel.support.ExpressionAdapter.evaluate(ExpressionAdapter.java:36)
	at org.apache.camel.builder.SimpleBuilder.evaluate(SimpleBuilder.java:83)
	at org.apache.camel.processor.SetBodyProcessor.process(SetBodyProcessor.java:46)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:118)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:51)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.processor.UnitOfWorkProducer.process(UnitOfWorkProducer.java:73)
	at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:378)
	at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:1)
	at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:242)
	at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:346)
	at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:184)
	at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:124)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:137)
	... 22 more
Caused by: java.lang.IllegalArgumentException: Expecting }} but found end of string from text: prop1}}{{prop2
	at org.apache.camel.component.properties.DefaultPropertiesParser.doParseUri(DefaultPropertiesParser.java:90)
	at org.apache.camel.component.properties.DefaultPropertiesParser.parseUri(DefaultPropertiesParser.java:51)
	at org.apache.camel.component.properties.DefaultPropertiesParser.parseUri(DefaultPropertiesParser.java:38)
	at org.apache.camel.component.properties.DefaultPropertiesParser.createPlaceholderPart(DefaultPropertiesParser.java:189)
	at org.apache.camel.component.properties.DefaultPropertiesParser.doParseUri(DefaultPropertiesParser.java:105)
	at org.apache.camel.component.properties.DefaultPropertiesParser.parseUri(DefaultPropertiesParser.java:51)
	at org.apache.camel.component.properties.PropertiesComponent.parseUri(PropertiesComponent.java:158)
	at org.apache.camel.component.properties.PropertiesComponent.parseUri(PropertiesComponent.java:117)
	at org.apache.camel.builder.ExpressionBuilder$78.evaluate(ExpressionBuilder.java:1781)
	... 40 more


It seems that DefaultPropertiesParser doesn&amp;amp;apos;t like concatenation of properties. I&amp;amp;apos;ve forked Camel project on GitHub and I&amp;amp;apos;ve added the unit test posted above. Here is the link: https://github.com/ancosen/camel
Investigating the history of the particular class I found that the problem should arise from:
CAMEL-5328 supports resolution of nested properties in PropertiesComponent
Here is the link of the commit:
https://github.com/apache/camel/commit/83f4b0f485521967d05de4e65025c4558a75ff3c
Thanks.
Bye</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.properties.DefaultPropertiesParser.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">7189</link>
			<link type="Reference" description="relates to">7693</link>
		</links>
	</bug>
	<bug id="7524" opendate="2014-06-20 08:01:07" fixdate="2014-06-20 15:10:00" resolution="Fixed">
		<buginformation>
			<summary>CxfProducer created from wsdl detected as provider</summary>
			<description>In custom bus extension following code used to detect web provider:


JaxWsServiceFactoryBean factory =...;
                JaxWsImplementorInfo jaxWsImplementorInfo = jaxwsfactory.getJaxWsImplementorInfo();
                isProvider = null != jaxWsImplementorInfo &amp;amp;&amp;amp; jaxWsImplementorInfo.isWebServiceProvider();


But org.apache.camel.component.cxf.WSDLServiceFactoryBean used setServiceClass(Provider.class); which cause 


org.apache.cxf.jaxws.support.JaxWsImplementorInfo.isWebServiceProvider() {
        return Provider.class.isAssignableFrom(implementorClass);
    }


return true always.
I can&amp;amp;apos;t set ServiceClass for CxfEndpoint because another case will executed.
I propose to override service class for this case</description>
			<version>2.13.1</version>
			<fixedVersion>2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.WSDLServiceFactoryBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="7541" opendate="2014-06-26 03:13:22" fixdate="2014-06-26 14:02:59" resolution="Fixed">
		<buginformation>
			<summary>RedisIdempotentRepository doesn&amp;apos;t work out of box</summary>
			<description>IdempotentRepository need to use contains to check if the message is already there before adding the message. RedisIdempotentRepository doesn&amp;amp;apos;t do that, so RedisComponentSpringIntegrationTest is failed.</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.redis.processor.idempotent.RedisIdempotentRepository.java</file>
			<file type="M">org.apache.camel.component.redis.RedisComponentSpringIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7544" opendate="2014-06-26 12:49:07" fixdate="2014-06-26 14:08:25" resolution="Fixed">
		<buginformation>
			<summary>XML DSL with customId attribute cannot be read by Camel</summary>
			<description>The XSD allows to specify customId="true" id="foo" in the route elements. But when reading the route using spring you get a parse error in spring.


Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;fromFile&amp;amp;apos;: Error setting property values; nested exception is org.springframework.beans.NotWritablePropertyException: Invalid property &amp;amp;apos;customId&amp;amp;apos; of bean class [org.apache.camel.spring.CamelEndpointFactoryBean]: Bean property &amp;amp;apos;customId&amp;amp;apos; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1453)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1158)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:519)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:458)
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:296)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:223)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:293)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:194)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:610)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:932)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:479)
	at org.springframework.context.support.FileSystemXmlApplicationContext.&amp;lt;init&amp;gt;(FileSystemXmlApplicationContext.java:140)
	at org.springframework.context.support.FileSystemXmlApplicationContext.&amp;lt;init&amp;gt;(FileSystemXmlApplicationContext.java:94)
	at org.apache.camel.spring.Main.createDefaultApplicationContext(Main.java:176)
	at org.apache.camel.spring.Main.doStart(Main.java:140)
	at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:61)
	at org.apache.camel.main.MainSupport.run(MainSupport.java:148)
	at org.apache.camel.main.MainSupport.run(MainSupport.java:352)
	at org.apache.camel.spring.Main.main(Main.java:73)
	... 6 more
Caused by: org.springframework.beans.NotWritablePropertyException: Invalid property &amp;amp;apos;customId&amp;amp;apos; of bean class [org.apache.camel.spring.CamelEndpointFactoryBean]: Bean property &amp;amp;apos;customId&amp;amp;apos; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?
	at org.springframework.beans.BeanWrapperImpl.setPropertyValue(BeanWrapperImpl.java:1043)
	at org.springframework.beans.BeanWrapperImpl.setPropertyValue(BeanWrapperImpl.java:903)
	at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:75)
	at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:57)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1450)
	... 24 more
[ERROR] *************************************

</description>
			<version>2.13.1</version>
			<fixedVersion>2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.core.xml.AbstractCamelFactoryBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="7545" opendate="2014-06-26 14:28:42" fixdate="2014-06-26 15:05:02" resolution="Fixed">
		<buginformation>
			<summary>Having multiple camelContext in same blueprint bundle may only register the 1st in the OSGi service registry</summary>
			<description>But its correct in JMX etc.
But the osgi service registry is used by the Camel Karaf commands so they can only see the 1st CamelContext
</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.core.osgi.OsgiCamelContextPublisher.java</file>
		</fixedFiles>
	</bug>
	<bug id="7546" opendate="2014-06-26 16:18:26" fixdate="2014-06-26 18:08:52" resolution="Fixed">
		<buginformation>
			<summary>Avoid clash of CamelContext managementName in OSGi</summary>
			<description>There can be a potential clash in OSGi when there are 2+ camelContext in the same bundle, as they will by default reuse the same managementName in the mbean naming, where it uses the symbolic name of the OSGi bundle.
We should detect this clash and use the counter to make it unique.
This is part of CAMEL-6972
</description>
			<version>2.13.0</version>
			<fixedVersion>2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.core.osgi.OsgiCamelContextPublisher.java</file>
			<file type="M">org.apache.camel.core.osgi.OsgiManagementNameStrategy.java</file>
			<file type="M">org.apache.camel.core.osgi.OsgiCamelContextNameStrategy.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">6972</link>
		</links>
	</bug>
	<bug id="7407" opendate="2014-05-02 10:00:08" fixdate="2014-06-26 20:13:18" resolution="Fixed">
		<buginformation>
			<summary>FTP route considers files as in progress after error in poll</summary>
			<description>When an error occurs in the middle of polling (e.g. read timeout on ftp server), all files that have been read up to that point are stored in the inProgressRepospitory (last line GenericFileConsumer.isValidFile()). Due to the error, those files are not passed on to the ftp route, but remain in the inProgressRepository. The effect is that those files are never picked up unless we clear the inProgressRepository somehow (e.g. by restarting). When polling fails, files should not be allowed to remain in the inProgressRepository</description>
			<version>2.13.0</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7432" opendate="2014-05-12 14:13:12" fixdate="2014-06-26 20:13:26" resolution="Fixed">
		<buginformation>
			<summary>camel-mybatis - issues calling Oracle Stored procedure with multiple resultsets</summary>
			<description>I am using camel-mybatis (version 2.12.0) component in Fuse 6.1 environment to invoke an oracle SP with 2 resultsets. The request is a HashMap and once mybatis maps the resultsets to java beans, the List is again saved in the original HashMap itself. 
Here is the snippet of SqlMap:
&amp;lt;select
    id="searchUsers"
    parameterType="java.util.HashMap"       
    statementType="CALLABLE"&amp;gt;
    {call ORACLE.SP_NAME_1(
        #
{userId,mode=IN,jdbcType=VARCHAR}
,
#
{maxResultsCount,mode=IN,jdbcType=DECIMAL}
,
#
{view,mode=IN,jdbcType=VARCHAR}
,
#
{statusInfo,mode=OUT,jdbcType=CURSOR,resultMap=statusInfoRowMap}
,
#
{memberInfo,mode=OUT,jdbcType=CURSOR,resultMap=claimInfoRowMap}
)}
And here is how I invoke the mybatis component:
&amp;lt;setBody&amp;gt;
    &amp;lt;groovy&amp;gt;
[
    userId:&amp;amp;apos;ID-1234&amp;amp;apos;,
    maxResultsCount:20,
    view:&amp;amp;apos;MEMBER&amp;amp;apos;,
]
   &amp;lt;/groovy&amp;gt;
&amp;lt;/setBody&amp;gt;
&amp;lt;to uri="mybatis:searchUsers?statementType=SelectOne" /&amp;gt;
Since there are no result object (all the results are stored in the original requested HashMap itself), MyBatisProducer is setting null to exchange OUT message. The original body which contains the results from stored procedure is lost.
The Question is: is this the expected behaviour? mybatis component already stores the result in exchange header, so why to update the body as well?
The workaround I had to do was - to store the original body to a header, invoke mybatis and reset body from the header (which has the stored procedure result now) : 
&amp;lt;setBody&amp;gt;
            &amp;lt;groovy&amp;gt;
                [
             userId:&amp;amp;apos;ID1234&amp;amp;apos;,
             maxResultsCount:20,
             view:&amp;amp;apos;MEMBER&amp;amp;apos;
          ]
        &amp;lt;/groovy&amp;gt;
    &amp;lt;/setBody&amp;gt;
    &amp;lt;setHeader headerName="originalRequest"&amp;gt;
        &amp;lt;simple&amp;gt;$
{body}
&amp;lt;/simple&amp;gt;
    &amp;lt;/setHeader&amp;gt;
    &amp;lt;to uri="mybatis:searchUsers?statementType=SelectOne" /&amp;gt;
    &amp;lt;setBody&amp;gt;
        &amp;lt;simple&amp;gt;$
{in.headers.originalRequest}
&amp;lt;/simple&amp;gt;
    &amp;lt;/setBody&amp;gt;
    &amp;lt;log message="status: $
{body.statusInfo}
" /&amp;gt;</description>
			<version>2.12.0</version>
			<fixedVersion>2.12.4, 2.13.2, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mybatis.MyBatisProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7560" opendate="2014-06-30 18:27:22" fixdate="2014-07-02 07:37:33" resolution="Fixed">
		<buginformation>
			<summary>camel-test - AdviceWith transacted does not work</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Problem-with-adviceWith-on-2-13-x-tp5752421.html
The work-around when using transacted is to set isUseAdvice return false.</description>
			<version>2.13.1</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.AdviceWithTasks.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinitionHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="7562" opendate="2014-06-30 19:25:51" fixdate="2014-07-02 07:37:43" resolution="Fixed">
		<buginformation>
			<summary>camel-test - AdviceWith in CBR may add twice</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Camel-AdviceWith-issues-tp5752786.html
When using advice-with for a CBR it may add to the when clauses 2 times.</description>
			<version>2.13.1</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ProcessorDefinitionHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="7418" opendate="2014-05-06 22:59:39" fixdate="2014-07-02 18:57:32" resolution="Fixed">
		<buginformation>
			<summary>org.apache.camel.impl.JndiRegistry.findByTypeWithName</summary>
			<description>I guess this line isn&amp;amp;apos;t correct:
if (type.isInstance(pair.getClass()) || type.getName().equals(pair.getClassName()))
The variable "pair.getClass()" always returns "javax.naming.NameClassPair" or its subclasses and the method "isInstance" works only with Instances, but doesnt Classes.
 I think the correct code should be:
if (type.isAssignableFrom(Class.forName(pair.getClassName())))
I&amp;amp;apos;ve tried to test a transacted route, but i couldnt because the error: 
Failed to create route route1 at: &amp;gt;&amp;gt;&amp;gt; Transacted[] &amp;lt;&amp;lt;&amp;lt; in route: Route(route1)[[From[direct:start]] -&amp;gt; [Transacted[]]] because of No bean could be found in the registry of type: PlatformTransactionManager</description>
			<version>2.13.0</version>
			<fixedVersion>2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.JndiRegistry.java</file>
		</fixedFiles>
	</bug>
	<bug id="7571" opendate="2014-07-03 05:53:18" fixdate="2014-07-03 06:10:22" resolution="Fixed">
		<buginformation>
			<summary>Potential NPE in rabbitmq producer if header has null value and DEBUG logging enabled</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Bug-in-RabbitMQProducer-tp5753248.html</description>
			<version>2.13.1</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7572" opendate="2014-07-03 06:23:22" fixdate="2014-07-03 11:16:56" resolution="Fixed">
		<buginformation>
			<summary>Using custom id in CBR will output id duplicated when dumping route as XML using JMX</summary>
			<description>If setting a custom id on a CBR then the dump route as xml JMX operation will include the id duplicated in the otherwise tag


&amp;lt;routes xmlns="http://camel.apache.org/schema/spring"&amp;gt;
    &amp;lt;route id="route1"&amp;gt;
        &amp;lt;from uri="file:src/data?noop=true"/&amp;gt;
        &amp;lt;to uri="activemq:personnel.records" customId="true" id="amq"/&amp;gt;
    &amp;lt;/route&amp;gt;
    &amp;lt;route id="route2"&amp;gt;
        &amp;lt;from uri="activemq:personnel.records"/&amp;gt;
        &amp;lt;choice customId="true" id="myChoice"&amp;gt;
            &amp;lt;when id="when1"&amp;gt;
                &amp;lt;xpath&amp;gt;/person/city = &amp;amp;apos;London&amp;amp;apos;&amp;lt;/xpath&amp;gt;
                &amp;lt;to uri="file:target/messages/uk" id="to1"/&amp;gt;
            &amp;lt;/when&amp;gt;
            &amp;lt;otherwise customId="true" id="myChoice"&amp;gt;
                &amp;lt;to uri="file:target/messages/others" id="to2"/&amp;gt;
            &amp;lt;/otherwise&amp;gt;
        &amp;lt;/choice&amp;gt;
    &amp;lt;/route&amp;gt;
&amp;lt;/routes&amp;gt;


</description>
			<version>2.13.1</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.RouteDefinitionHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="7570" opendate="2014-07-03 03:15:44" fixdate="2014-07-03 11:31:01" resolution="Fixed">
		<buginformation>
			<summary>enrich doesn&amp;apos;t send out ExchangeSendingEvent nor ExchangeSentEvent </summary>
			<description>When using enrich DSL, camel doesn&amp;amp;apos;t send out ExchangeSendingEvent nor ExchangeSentEvent  for management.
You can find more information about it here</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.Enricher.java</file>
		</fixedFiles>
	</bug>
	<bug id="7557" opendate="2014-06-30 09:21:07" fixdate="2014-07-04 11:53:30" resolution="Fixed">
		<buginformation>
			<summary>CxfRsProducer does not copy headers between Camel and CXF messages in a proxy mode</summary>
			<description></description>
			<version>2.12.3</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducer.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7577" opendate="2014-07-04 12:16:20" fixdate="2014-07-04 12:19:25" resolution="Fixed">
		<buginformation>
			<summary>camel-zipfile - ZipIterator should be closable</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/File-component-does-not-delete-file-tp5753140p5753207.html
The ZipIterator should be Closable so the splitter eip closes it correctly.</description>
			<version>2.13.1</version>
			<fixedVersion>2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.zipfile.ZipIterator.java</file>
		</fixedFiles>
	</bug>
	<bug id="7578" opendate="2014-07-04 12:44:12" fixdate="2014-07-06 09:10:00" resolution="Fixed">
		<buginformation>
			<summary>camel-bindy - pattern attribute should not be ignored if locale is not set</summary>
			<description>This code doesn&amp;amp;apos;t pad field mandant with "0" if locale is not set: 


@CsvRecord(separator = ",")
public class Unity {
    @DataField(pos = 1, pattern = "000")
    public float mandant;


Route:


final BindyCsvDataFormat bindy = new BindyCsvDataFormat(Unity.class);
from("direct:start")
    .marshal(bindy)
    .log("${body}");


Testing with:


final Unity unity = new Unity();
unity.mandant = 50f;
final ProducerTemplate template = context.createProducerTemplate();


This prints:

50.0
Only when setting the locale, pattern is not ignored:


bindy.setLocale(Locale.US.getISO3Country());


This prints:

050</description>
			<version>2.13.1</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.bindy.FormatFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="7587" opendate="2014-07-09 14:08:49" fixdate="2014-07-10 05:57:23" resolution="Fixed">
		<buginformation>
			<summary>MessageHistory stores passwords in plain text</summary>
			<description>The MessageHistory feature currently keeps passwords in plain text in case they are part of the URI. 
MessageHelper.doDumpMessageHistoryStacktrace() does some sanitizing, but only for the from node - other nodes/processors are currently not sanitized. 
In order to prevent handling sensitive information in the message history in general, I would suggest to sanitize the URI already when storing a MessageHistory item. </description>
			<version>2.13.2</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.MessageHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="7593" opendate="2014-07-11 09:04:19" fixdate="2014-07-11 09:06:40" resolution="Fixed">
		<buginformation>
			<summary>camel-netty-http consumer uses a fixed 1mb chunked frame size</summary>
			<description>The option to configure the setting was only exposed on the shared netty http server config. We should also expose it for the non shared out of the box netty http consumer.
People today will run into this problem
When sending an HTTP request bigger than 1MB, netty HTTP throws an exception - org.jboss.netty.handler.codec.frame.TooLongFrameException: HTTP content length exceeded 1048576 bytes .</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpConfiguration.java</file>
			<file type="M">org.apache.camel.component.netty.http.HttpServerPipelineFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="7595" opendate="2014-07-11 09:56:17" fixdate="2014-07-11 10:12:41" resolution="Fixed">
		<buginformation>
			<summary>camel-jdbc - Overrides with old headers when used the 2nd time in a route</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/I-m-having-problems-with-the-jdbc-component-header-CamelJdbcUpdateCount-tp5753590p5753603.html</description>
			<version>2.13.2</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jdbc.JdbcProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7586" opendate="2014-07-08 15:29:04" fixdate="2014-07-20 08:00:38" resolution="Fixed">
		<buginformation>
			<summary>NotCompliantMBeanException : Attribute MessageHistory has more than one getter</summary>
			<description>Hello, I wasn&amp;amp;apos;t able to subscribe on the mailing list, so I&amp;amp;apos;m posting my issue directly here.
In my project I need to use some ManagedCamelContextMBean, which I am trying to access through JMX.newMBeanProxy
However, it is not working as I&amp;amp;apos;m getting a NotCompliantMBeanException because the attribute MessageHistory is said to have more than one getter.
I checked the source code of newMBeanProxy, then the JMX 1.4 specification, and then Camel&amp;amp;apos;s source code, and it appears that ManagedCamelContextMBean is indeed not respecting the standard MBean.
The problem is that two methods are defined in ManagedCamelContextMBean : isMessageHistory() and getMessageHistory()
Since the return type is boolean, isMessageHistory is considered to be a getter, which makes two getter according to the JMX specification and is blocking the newMBeanProxy() method.</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.api.management.mbean.ManagedCamelContextMBean.java</file>
			<file type="M">org.apache.camel.management.mbean.ManagedCamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="7617" opendate="2014-07-21 09:55:48" fixdate="2014-07-21 10:39:09" resolution="Fixed">
		<buginformation>
			<summary>JavadocApiMethodGenerator has problems extracting method signatures from JavaDoc</summary>
			<description>The bug occurs during the build of Camel master branch:

[ERROR] Failed to execute goal org.apache.camel:camel-api-component-maven-plugin:2.14-SNAPSHOT:fromApis (generate-test-component-classes) on project camel-linkedin: Error generating source for org.apache.camel.component.linkedin.api.CommentsResource: java.lang.%20java.lang.String -&amp;gt; [Help 1]

</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.maven.JavadocApiMethodGeneratorMojo.java</file>
		</fixedFiles>
	</bug>
	<bug id="7456" opendate="2014-05-22 11:24:42" fixdate="2014-07-22 07:15:54" resolution="Fixed">
		<buginformation>
			<summary>Camel PropertiesComponent ignores custom parser in Blueprint</summary>
			<description>I have implemented a custom PropertiesParser which allows me to use system property placeholders in propertyPrefix and propertySuffix.
In my use case the propertyPrefix is defined as "${container.stage}.", where container.stage is a jvm option defined at container creation. The value is one of dev, test and prod.
This works fine in Java DSL world (SCR bundle), but custom parser is ignored in Blueprint. Here is sample of my blueprint xml:


 &amp;lt;cm:property-placeholder id="integration" persistent-id="org.apache.camel.sample.temp" placeholder-prefix="[[" placeholder-suffix="]]"&amp;gt;
    &amp;lt;cm:default-properties&amp;gt;
        &amp;lt;cm:property name="example" value="this value is the default"/&amp;gt;
        &amp;lt;cm:property name="dev.example" value="this value is used in development environment"/&amp;gt;
        &amp;lt;cm:property name="test.example" value="this value is used in test environment"/&amp;gt;
        &amp;lt;cm:property name="prod.example" value="this value is used in production environment"/&amp;gt;
    &amp;lt;/cm:default-properties&amp;gt;
&amp;lt;/cm:property-placeholder&amp;gt;

&amp;lt;bean id="parser" class="org.apache.camel.sample.MyCustomPropertiesParser"/&amp;gt;

&amp;lt;!-- Load properties for current container stage --&amp;gt;
&amp;lt;bean id="properties" class="org.apache.camel.component.properties.PropertiesComponent"&amp;gt;
    &amp;lt;property name="propertiesParser" ref="parser"/&amp;gt;
    &amp;lt;property name="propertyPrefix" value="${container.stage}."/&amp;gt;
    &amp;lt;property name="fallbackToUnaugmentedProperty" value="true"/&amp;gt;
    &amp;lt;property name="location" value="blueprint:integration,classpath:properties/temp.properties"/&amp;gt;&amp;lt;/bean&amp;gt;

&amp;lt;camelContext id="temp" xmlns="http://camel.apache.org/schema/blueprint"&amp;gt;
    &amp;lt;route id="exampleRoute"&amp;gt;
        &amp;lt;from uri="timer:foo?period=5000"/&amp;gt;
        &amp;lt;transform&amp;gt;
            &amp;lt;simple&amp;gt;{{example}}&amp;lt;/simple&amp;gt;
        &amp;lt;/transform&amp;gt;
        &amp;lt;to uri="log:something"/&amp;gt;
    &amp;lt;/route&amp;gt;
&amp;lt;/camelContext&amp;gt;


The reason it did not work was because by default, it uses blueprint property resolver (useBlueprintPropertyResolver="true") to bridge PropertiesComponent to blueprint in order to support looking up property placeholders from the Blueprint Property Placeholder Service. Then it always creates a BlueprintPropertiesParser object and set it to PropertiesComponent. 
The customer Property Parser I created was only set into the BlueprintPropertiesParser object as a delegate Property Parser. Therefore, it was always the method parseUri() from the BlueprintPropertiesParser object got invoked. The same method from your custom parser was ignored. 
For more detail, please take a look at org.apache.camel.blueprint.CamelContextFactoryBean.initPropertyPlaceholder() function.
The only workaround is to add the attribute useBlueprintPropertyResolver="false" to &amp;lt;camelContext&amp;gt; element to disable default blueprint property resolver. However, I will have to change PropertiesComponent&amp;amp;apos;s "location" property to remove blueprint "blueprint:integration" from the comma separated value list:


 &amp;lt;property name="location" value="classpath:properties/temp.properties"/&amp;gt; 


Because once I set it to false, I will no longer be able to lookup from blueprint property service.</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.properties.PropertiesComponent.java</file>
			<file type="M">org.apache.camel.component.properties.PropertiesComponentTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7622" opendate="2014-07-21 17:32:10" fixdate="2014-07-22 09:16:54" resolution="Fixed">
		<buginformation>
			<summary>advice-with - No outputs found matching id when upgrading from 2.13 to 2.14</summary>
			<description>I have the following route defined with the Java DSL: 
from("direct:localMemberLookup").routeId("localMemberLookup") 
        .process(new MemberLookupToSqlParametersProcessor()).id("sqlParams") 
        .recipientList(simple("sql:sql.memberLookup")).delimiter("false") 
        .to("log:output") 
        .process(new MemberLookupProcessor()) 
        // do more processing 
        .to("log:output"); 
I&amp;amp;apos;m testing it with a test that looks as follows: 
@EndpointInject(uri = "mock:lookupHeaders") 
MockEndpoint lookupHeaders; 
@EndpointInject(uri = "mock:searchResult") 
MockEndpoint searchResult; 
@EndpointInject(uri = "mock:lookupResult") 
MockEndpoint lookupResult; 
@Autowired 
CamelContext camelContext; 
@Before 
public void before() throws Exception { 
        ModelCamelContext context = (ModelCamelContext) camelContext; 
        context.setTracing(true); 
        RouteDefinition searchRoute = context.getRouteDefinition("memberSearchRequest"); 
        searchRoute.to(searchResult); 
        RouteDefinition lookupRoute = context.getRouteDefinition("localMemberLookup"); 
        lookupRoute.adviceWith(context, new AdviceWithRouteBuilder() { 
                @Override 
                public void configure() throws Exception 
{ 
                        weaveById("sqlParams").after().to(lookupHeaders); 
                }
 
        }); 
        lookupRoute.to(lookupResult); 
        context.start(); 
} 
With Camel 2.13.1, this works fine. However, with 2.14-SNAPSHOT, I get the following error: 
java.lang.IllegalArgumentException: There are no outputs which matches: sqlParams in the route 
Mailing list thread: http://camel.465427.n5.nabble.com/weaveById-works-with-2-13-1-not-with-2-14-SNAPSHOT-td5753809.html</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.AdviceWithTasks.java</file>
		</fixedFiles>
	</bug>
	<bug id="7582" opendate="2014-07-05 10:31:07" fixdate="2014-07-23 08:18:44" resolution="Fixed">
		<buginformation>
			<summary>Python scripts with multiple statements return null</summary>
			<description>As reported here: 
http://camel.465427.n5.nabble.com/Return-Value-from-Python-Script-Not-In-Message-Body-tt5724056.html#none
It seems that when calling python script that has more than a single statement  the return value from the script is null. Here is a simple example in groovy that  shows this:


package com.im.examples

import org.apache.camel.*
import org.apache.camel.impl.*
import org.apache.camel.builder.*

String script = URLEncoder.encode(&amp;amp;apos;"Hello world!"&amp;amp;apos;, "UTF-8") // this works - script returns "Hello world!"
//String script = URLEncoder.encode(&amp;amp;apos;bar = "baz"; "Hello world!"&amp;amp;apos;, "UTF-8") // this fails - script returns null

CamelContext camelContext = new DefaultCamelContext()
camelContext.addRoutes(new RouteBuilder() {
        def void configure() {
            from("direct:python")
            .to("language:python:" + script)
        }
    }
)

camelContext.start()

ProducerTemplate t = camelContext.createProducerTemplate()
def result = t.requestBody(&amp;amp;apos;direct:python&amp;amp;apos;, &amp;amp;apos;foo&amp;amp;apos;)
println result

camelContext.stop()


</description>
			<version>2.13.0</version>
			<fixedVersion>2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.script.ScriptBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="7598" opendate="2014-07-14 12:58:57" fixdate="2014-07-24 13:23:07" resolution="Fixed">
		<buginformation>
			<summary>Camel does not clear the jpa session after each processed message batch</summary>
			<description>We are using apache camel to poll from a database. As we want processed rows only to be updated we have disabled consumeDelete on the JPA endpoint. 
During testing we found a large memory leak: all polled entities are kept in the session cache (we are using hibernate as persistence provider). 
The issue seems to be in the JpaConsumer. In method poll() it calls enitityManager.joinTransaction() at the beginning and entitiyManager.flush() at the end of the method but it never calls  entityManager.clear(). As camel is reusing the underlying session during each poll() this causes the first level entity cache to grow indefinitely. </description>
			<version>2.12.3</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jpa.JpaConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7636" opendate="2014-07-24 15:02:09" fixdate="2014-07-25 07:44:59" resolution="Fixed">
		<buginformation>
			<summary>camel-jms - Reply manager during timeout must use a catch to ensure onEviction can return correclty</summary>
			<description>Got a tidbit of a problem
&amp;lt;raul&amp;gt;	 2014-07-24 02:12:02,250 | WARN  | CorrelationTimeoutMap | 123 - org.apache.camel.camel-core - 2.13.1 | Exception happened during eviction of entry ID org.apache.camel.component.jms.reply.TemporaryQueueReplyHandler@7f3a3f81, won&amp;amp;apos;t evict and will continue trying: java.lang.NullPointerException
This could lead to endless retry if processing the timeout keeps causing the same exception.</description>
			<version>2.12.3</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.reply.CorrelationTimeoutMap.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">7635</link>
		</links>
	</bug>
	<bug id="7630" opendate="2014-07-23 15:29:17" fixdate="2014-07-25 12:12:27" resolution="Fixed">
		<buginformation>
			<summary>BlueprintPropertiesParser doesn&amp;apos;t handle the Blueprint Encryption: EncryptionOperationNotPossibleException</summary>
			<description>When using encryption feature which provides by Karaf, BlueprintPropertiesParser has more than one PropertyPlaceholder. It just throw the EncryptionOperationNotPossibleException out if the property is not encrypted. </description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.blueprint.BlueprintPropertiesParser.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">10038</link>
		</links>
	</bug>
	<bug id="7642" opendate="2014-07-28 14:44:12" fixdate="2014-07-28 15:14:46" resolution="Fixed">
		<buginformation>
			<summary>Netty consumer should return error on invalid request</summary>
			<description>f you send the corrupted request to the Netty consumer...
&amp;gt; header1: value1
&amp;gt; GET /some/resource HTTP/1.1
&amp;gt; header2: value2
...Netty will hang on the open connection, instead of returning error immediately.</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.http.handlers.HttpServerMultiplexChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty.http.handlers.HttpServerChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty.handlers.ClientChannelHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="7650" opendate="2014-07-31 07:19:50" fixdate="2014-07-31 07:22:13" resolution="Fixed">
		<buginformation>
			<summary>camel-restlet - Return 405 if method not allowed instead of 404</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Camel-Restlet-2-13-1-Consumer-Questions-tp5754698.html</description>
			<version>2.13.2</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.MethodBasedRouter.java</file>
			<file type="M">org.apache.camel.component.restlet.RestletMultiMethodsEndpointTest.java</file>
			<file type="M">org.apache.camel.component.restlet.RestletRouteBuilderTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7564" opendate="2014-07-01 15:45:36" fixdate="2014-08-02 16:50:55" resolution="Duplicate">
		<buginformation>
			<summary>RabbitMQ Component: Consumer with many channels per connection.</summary>
			<description>Consumer RabbitMQ Component 
To minimize number of connections (TCP/IP) in production servers and have more consumer threads, we need a list of channels per connection instead just one.
Like: 
Collection&amp;lt;Channel&amp;gt; channels;</description>
			<version>2.13.1</version>
			<fixedVersion>2.14.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQConsumer.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQLoadIntTest.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQEndpoint.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">7556</link>
		</links>
	</bug>
	<bug id="7653" opendate="2014-07-31 09:45:36" fixdate="2014-08-04 07:26:39" resolution="Fixed">
		<buginformation>
			<summary>camel-sql endpoint oracle failure</summary>
			<description>I use the sql endpoint against oracle, however the DefaultSqlPrepareStatementStrategy uses PreparedStatement.setObject to set all the named parameters. With most jdbc drives this works fine except for oracle. Oracle throws an ORA-17004 exception stating an invalid column type. 
My route looks like this


from("{{ktn.stkbal.in")
                .routeId("KTN.StkBal")
                .onCompletion().onCompleteOnly()
                    .to("seda:generatestockbalancereport")
                .end()
                .setHeader("ts",constant(new Timestamp(new Date().getTime())))
                .split().tokenizeXML("product","stockPicture").streaming()
                    .setHeader("ean",xpath("/st:product/@ean").resultType(String.class).namespaces(KTNConstants.STOCK_NAMESPACES))
                    .setHeader("available", xpath("/st:product/st:available").resultType(Integer.class).namespaces(KTNConstants.STOCK_NAMESPACES))
                    .setHeader("blocked",xpath("/st:product/st:blocked").resultType(Integer.class).namespaces(KTNConstants.STOCK_NAMESPACES))
                    .to("sql:insert into stockbalance(ean,available,blocked,picturets) values (:#ean,:#available,:#blocked,:#ts)?dataSourceRef=hybrisDataSource");


And from our dear oracle i get


23:34:20,821 | TRACE | 2/STKBAL/inbound | faultSqlPrepareStatementStrategy | 286 - org.apache.camel.camel-sql - 2.12.0.redhat-610379 | Prepared query: insert into stockbalance(ean,available,blocked,picturets) values (?,?,?,?)
23:34:20,824 | TRACE | 2/STKBAL/inbound | faultSqlPrepareStatementStrategy | 286 - org.apache.camel.camel-sql - 2.12.0.redhat-610379 | Setting parameter #1 with value: 10000000000001
23:34:20,825 | TRACE | 2/STKBAL/inbound | faultSqlPrepareStatementStrategy | 286 - org.apache.camel.camel-sql - 2.12.0.redhat-610379 | Setting parameter #2 with value: 2
23:34:20,826 | TRACE | 2/STKBAL/inbound | faultSqlPrepareStatementStrategy | 286 - org.apache.camel.camel-sql - 2.12.0.redhat-610379 | Setting parameter #3 with value: 5
23:34:20,828 | TRACE | 2/STKBAL/inbound | faultSqlPrepareStatementStrategy | 286 - org.apache.camel.camel-sql - 2.12.0.redhat-610379 | Setting parameter #4 with value: Wed Jul 30 23:33:18 CEST 2014
23:34:20,831 | ERROR | 2/STKBAL/inbound | DefaultErrorHandler              | 142 - org.apache.camel.camel-core - 2.12.0.redhat-610379 | Failed delivery for (MessageId: ID-tst-esb-inno1-41429-1406755976005-6-7 on ExchangeId: ID-tst-esb-inno1-41429-1406755976005-6-9). Exha
usted after delivery attempt: 1 caught: org.springframework.jdbc.UncategorizedSQLException: PreparedStatementCallback; uncategorized SQLException for SQL [insert into stockbalance(ean,available,blocked,picturets) values (?,?,?,?)]; SQL state [99999]; error code [17004];
Invalid column type; nested exception is java.sql.SQLException: Invalid column type

Message History
---------------------------------------------------------------------------------------------------------------------------------------
RouteId              ProcessorId          Processor                                                                        Elapsed (ms)
[KTN.StkBal        ] [KTN.StkBal        ] [sftp://TSTKATOEN2341@&amp;lt;edited&amp;gt;/STKBAL/inbound?antExcl] [        21]
[KTN.StkBal        ] [setHeader69       ] [setHeader[ean]                                                                ] [         2]
[KTN.StkBal        ] [setHeader70       ] [setHeader[available]                                                          ] [         1]
[KTN.StkBal        ] [setHeader71       ] [setHeader[blocked]                                                            ] [         1]
[KTN.StkBal        ] [to107             ] [sql:insert into stockbalance(ean,available,blocked,picturets) values (:#ean,:#] [         9]

Stacktrace
---------------------------------------------------------------------------------------------------------------------------------------
org.springframework.jdbc.UncategorizedSQLException: PreparedStatementCallback; uncategorized SQLException for SQL [insert into stockbalance(ean,available,blocked,picturets) values (?,?,?,?)]; SQL state [99999]; error code [17004]; Invalid column type; nested exception is
 java.sql.SQLException: Invalid column type
        at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:83)[285:org.apache.servicemix.bundles.spring-jdbc:3.2.8.RELEASE_1]
        at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:80)[285:org.apache.servicemix.bundles.spring-jdbc:3.2.8.RELEASE_1]
        at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:80)[285:org.apache.servicemix.bundles.spring-jdbc:3.2.8.RELEASE_1]



As workaround i extended the DefaultSqlPrepareStatementStrategy and override populateStatement. It leverages springs ArgumentPreparedStatementSetter to do the right thing.  


    @Override
    public void populateStatement(PreparedStatement ps, Iterator&amp;lt;?&amp;gt; iterator, int expectedParams) throws SQLException {
        final Object[] args = new Object[expectedParams];
        int i = 0 ;
        while (iterator != null &amp;amp;&amp;amp; iterator.hasNext()) {
            args[i]=iterator.next();
            i++;
        }
        final ArgumentPreparedStatementSetter setter = new ArgumentPreparedStatementSetter(args);
        setter.setValues(ps);
    }

</description>
			<version>2.12.0</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sql.DefaultSqlPrepareStatementStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="7656" opendate="2014-08-04 06:41:47" fixdate="2014-08-04 16:25:34" resolution="Fixed">
		<buginformation>
			<summary>Component api - error in camel-box component in assembly phase</summary>
			<description>See this CI build and see th console output (raw) and check in the end of the build where it does the assembly of the build
https://builds.apache.org/job/Camel.trunk.notest/2124/consoleText
You get a bunch of errors like


[ERROR] Failed to execute goal org.apache.camel:camel-api-component-maven-plugin:2.14-SNAPSHOT:fromApis (generate-test-component-classes) on project camel-linkedin: Error generating source for org.apache.camel.component.linkedin.api.CommentsResource: Error loading class java.lang.String&amp;amp;nbspcomment_id, -&amp;gt; [Help 1]
org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.camel:camel-api-component-maven-plugin:2.14-SNAPSHOT:fromApis (generate-test-component-classes) on project camel-linkedin: Error generating source for org.apache.camel.component.linkedin.api.CommentsResource: Error loading class java.lang.String&amp;amp;nbspcomment_id,
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:217)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84)
	at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59)
	at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183)
	at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161)
	at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:320)
	at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156)
	at org.jvnet.hudson.maven3.launcher.Maven3Launcher.main(Maven3Launcher.java:117)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launchStandard(Launcher.java:329)
	at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:239)
	at org.jvnet.hudson.maven3.agent.Maven3Main.launch(Maven3Main.java:178)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at hudson.maven.Maven3Builder.call(Maven3Builder.java:134)
	at hudson.maven.Maven3Builder.call(Maven3Builder.java:69)
	at hudson.remoting.UserRequest.perform(UserRequest.java:118)
	at hudson.remoting.UserRequest.perform(UserRequest.java:48)
	at hudson.remoting.Request$2.run(Request.java:328)
	at hudson.remoting.InterceptingExecutorService$1.call(InterceptingExecutorService.java:72)
	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303)
	at java.util.concurrent.FutureTask.run(FutureTask.java:138)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918)
	at java.lang.Thread.run(Thread.java:662)
Caused by: org.apache.maven.plugin.MojoExecutionException: Error generating source for org.apache.camel.component.linkedin.api.CommentsResource: Error loading class java.lang.String&amp;amp;nbspcomment_id,
	at org.apache.camel.maven.ApiComponentGeneratorMojo.execute(ApiComponentGeneratorMojo.java:89)
	at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101)
	at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209)
	... 31 more
Caused by: java.lang.IllegalArgumentException: Error loading class java.lang.String&amp;amp;nbspcomment_id,
	at org.apache.camel.util.component.ApiMethodParser.forName(ApiMethodParser.java:229)
	at org.apache.camel.util.component.ApiMethodParser.parse(ApiMethodParser.java:126)
	at org.apache.camel.maven.AbstractApiMethodGeneratorMojo.execute(AbstractApiMethodGeneratorMojo.java:71)
	at org.apache.camel.maven.ApiComponentGeneratorMojo.execute(ApiComponentGeneratorMojo.java:86)
	... 33 more

</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.maven.JavadocParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="7666" opendate="2014-08-07 08:18:52" fixdate="2014-08-07 14:49:01" resolution="Fixed">
		<buginformation>
			<summary>CamelContext.addService may fail with java.util.ConcurrentModificationException</summary>
			<description>Most likely to happen only for pojo consuming where you may have a JMS listener execute concurrently and do some routing, and on initial messages then they need to register as service in CamelContext which can trigger to this ConcurrentModificationException.


2014-08-07 10:09:09,338 [sonnel.records]] WARN  EndpointMessageListener        - Execution of JMS message listener failed. Caused by: [org.apache.camel.FailedToCreateProducerException - Failed to create Producer for endpoint: Endpoint[file://target/messages/amer/finance_pickup]. Reason: java.util.ConcurrentModificationException]
org.apache.camel.FailedToCreateProducerException: Failed to create Producer for endpoint: Endpoint[file://target/messages/amer/finance_pickup]. Reason: java.util.ConcurrentModificationException
	at org.apache.camel.impl.ProducerCache.doGetProducer(ProducerCache.java:410)
	at org.apache.camel.impl.ProducerCache.acquireProducer(ProducerCache.java:123)
	at org.apache.camel.processor.RecipientListProcessor.createProcessorExchangePairs(RecipientListProcessor.java:174)
	at org.apache.camel.processor.MulticastProcessor.process(MulticastProcessor.java:219)
	at org.apache.camel.processor.RecipientList.sendToRecipientList(RecipientList.java:167)
	at org.apache.camel.component.bean.MethodInfo$1.doProceed(MethodInfo.java:286)
	at org.apache.camel.component.bean.MethodInfo$1.proceed(MethodInfo.java:252)
	at org.apache.camel.component.bean.BeanProcessor.process(BeanProcessor.java:166)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:105)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:87)
	at org.apache.camel.component.jms.EndpointMessageListener.onMessage(EndpointMessageListener.java:103)
	at org.springframework.jms.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:562)
	at org.springframework.jms.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:500)
	at org.springframework.jms.listener.AbstractMessageListenerContainer.doExecuteListener(AbstractMessageListenerContainer.java:468)
	at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.doReceiveAndExecute(AbstractPollingMessageListenerContainer.java:325)
	at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:263)
	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:1101)
	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.executeOngoingLoop(DefaultMessageListenerContainer.java:1093)
	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:990)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
	at java.lang.Thread.run(Thread.java:744)
Caused by: java.util.ConcurrentModificationException
	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:859)
	at java.util.ArrayList$Itr.next(ArrayList.java:831)
	at org.apache.camel.impl.DefaultCamelContext.doAddService(DefaultCamelContext.java:976)
	at org.apache.camel.impl.DefaultCamelContext.addService(DefaultCamelContext.java:963)
	at org.apache.camel.impl.ProducerCache.doGetProducer(ProducerCache.java:408)
	... 22 more
2014-08-07 10:09:09,345 [main           ] INFO  SpringCamelContext             - Apache Camel 2.14-SNAPSHOT (CamelContext: camel-1) started in 0.254 seconds
2014-08-07 10:09:14,347 [main           ] INFO  CamelContextTest               - ********************************************************************************
2014-08-07 10:09:14,347 [main           ] INFO  CamelContextTest               - Testing done: testCheckFiles(org.apache.camel.example.pojo_messaging.CamelContextTest)

</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="7679" opendate="2014-08-11 13:58:45" fixdate="2014-08-12 08:11:20" resolution="Fixed">
		<buginformation>
			<summary>[cxfrs] Second argument is null when consumer invoke the bean with two arguments</summary>
			<description></description>
			<version>2.13.2</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.MethodInfo.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.testbean.CustomerServiceResource.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">7682</link>
		</links>
	</bug>
	<bug id="7603" opendate="2014-07-16 07:37:45" fixdate="2014-08-13 07:43:32" resolution="Fixed">
		<buginformation>
			<summary>camel-cxfrs need to store the security context information into the message header</summary>
			<description>We need to store the security context information when generate the camel exchange from CXF request message as camel-cxf does.</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.DefaultCxfRsBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="7659" opendate="2014-08-04 11:53:55" fixdate="2014-08-13 14:22:29" resolution="Fixed">
		<buginformation>
			<summary>camel-atom filter always returns the last consumed entry from feed more than once</summary>
			<description>I have problem with camel setup to consume feeds atom://atomUri?splitEntries=true&amp;amp;filter=true&amp;amp;throttleEntries=false, feed processor does not skip last consumed entry.
The source of problem is in UpdateDateFilter class, it filters only entries older than last update and entries of same pubdate are once more
consumed.</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.atom.UpdatedDateFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="7706" opendate="2014-08-15 19:28:26" fixdate="2014-08-15 19:37:09" resolution="Fixed">
		<buginformation>
			<summary>Camel JGroups does not disconnect shared JChannel correctly</summary>
			<description>Camel JGroups component uses a JGroups JChannel object in JGroupsEndpoint, which is shared by its JGroupsProducer and JGroupsConsumer. 
However, both the producer and consumer call disconnect() independently in their doStop() methods. This can leave a producer or consumer disconnected if the other is stopped.
The channel connect/disconnect could use a shared counter to determine when the channel should be disconnected. </description>
			<version>2.13.2</version>
			<fixedVersion>2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jgroups.JGroupsProducer.java</file>
			<file type="M">org.apache.camel.component.jgroups.JGroupsEndpoint.java</file>
			<file type="M">org.apache.camel.component.jgroups.JGroupsConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7707" opendate="2014-08-16 08:48:10" fixdate="2014-08-16 09:15:26" resolution="Fixed">
		<buginformation>
			<summary>OnCompletion - Should route even if original exchange has route stop / exception handled</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Behavior-of-onCompletion-for-exception-fault-and-stop-td5754257.html</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.issues.OnCompletionIssueTest.java</file>
			<file type="M">org.apache.camel.processor.OnCompletionProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="7714" opendate="2014-08-18 07:12:26" fixdate="2014-08-18 07:50:49" resolution="Fixed">
		<buginformation>
			<summary>AdviceWith - Does not honor autoStartup option</summary>
			<description>If setting a route or camel context to autoStartup=false, and then advicing that route, then it will always be started.
We should honor the auto startup option and only start it if that option is default or true.</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.CamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContextAutoStartupTest.java</file>
			<file type="M">org.apache.camel.management.mbean.ManagedCamelContext.java</file>
			<file type="M">org.apache.camel.RuntimeConfiguration.java</file>
			<file type="M">org.apache.camel.api.management.mbean.ManagedCamelContextMBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="7718" opendate="2014-08-19 06:54:28" fixdate="2014-08-20 01:55:09" resolution="Fixed">
		<buginformation>
			<summary>Constants used in camel-infinispan component have restricted access</summary>
			<description>Constants used for setting headers in camel-infinispan are not accessible in application because class containing them  is not public. 
These constants are used in unit tests and also in example in the documentation of the component, so it seems this is minor mistake and also a bug.</description>
			<version>2.13.2</version>
			<fixedVersion>2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.infinispan.InfinispanConstants.java</file>
		</fixedFiles>
	</bug>
	<bug id="7715" opendate="2014-08-19 00:37:45" fixdate="2014-08-20 05:51:21" resolution="Fixed">
		<buginformation>
			<summary>SjmsConsumer and SjmsProducer do not remove thread pool when stop</summary>
			<description>SjmsConsumer and SjmsProducer always register a new ThreadPool on Camel context ExecutorServiceManager every time a new instance is created for an endpoint.  If consumer or producer is stopped or removed or even component is removed, thread pool still exists. </description>
			<version>2.13.2</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sjms.SjmsProducer.java</file>
			<file type="M">org.apache.camel.component.sjms.SjmsConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7730" opendate="2014-08-21 09:31:03" fixdate="2014-08-22 06:13:33" resolution="Fixed">
		<buginformation>
			<summary>URI option "command" is not working in camel-infinispan component</summary>
			<description>Documentation for the component states that "command" URI option can be used in producer for setting operations for infinispan. But is seems only the default value is working because commands REMOVE, CLEAR and GET  fail with NullPointerException:


Message History
---------------------------------------------------------------------------------------------------------------------------------------
RouteId              ProcessorId          Processor                                                                        Elapsed (ms)
[route7            ] [route7            ] [direct://commandGet                                                           ] [         3]
[route7            ] [setHeader11       ] [setHeader[CamelInfinispanKey]                                                 ] [         0]
[route7            ] [to7               ] [infinispan://localhost?cacheContainer=#container1&amp;amp;command=GET                 ] [         1]

Exchange
---------------------------------------------------------------------------------------------------------------------------------------
Exchange[
	Id                  ID-roman-ThinkPad-T430s-46536-1408612528972-0-4
	ExchangePattern     InOnly
	Headers             {breadcrumbId=ID-roman-ThinkPad-T430s-46536-1408612528972-0-3, CamelInfinispanKey=commandKey1, CamelRedelivered=false, CamelRedeliveryCounter=0}
	BodyType            null
	Body                [Body is null]
]

Stacktrace
---------------------------------------------------------------------------------------------------------------------------------------
java.lang.NullPointerException: Null values are not supported!
	at org.infinispan.CacheImpl.assertKeyValueNotNull(CacheImpl.java:187)
	at org.infinispan.CacheImpl.putInternal(CacheImpl.java:876)
	at org.infinispan.CacheImpl.put(CacheImpl.java:870)
	at org.infinispan.CacheImpl.put(CacheImpl.java:1351)
	at org.infinispan.CacheImpl.put(CacheImpl.java:215)
	at org.apache.camel.component.infinispan.InfinispanOperation$Operation$1.execute(InfinispanOperation.java:50)
	at org.apache.camel.component.infinispan.InfinispanOperation.process(InfinispanOperation.java:34)
	at org.apache.camel.component.infinispan.InfinispanProducer.process(InfinispanProducer.java:42)
	at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:110)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:118)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:51)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.processor.UnitOfWorkProducer.process(UnitOfWorkProducer.java:73)
	at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:378)
	at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:346)
	at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:242)
	at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:346)
	at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:184)
	at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:124)
	at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:110)
	at org.jboss.fuse.qa.infinispan.component.test.InfinispanComponentTest.testUriCommandOption(InfinispanComponentTest.java:158)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:264)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:153)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:124)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:200)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:153)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:103)


Looking at the code it seems there is a missing test if the operation is not specified in the URI and default operation PUT is always used( that is why there is NullPointerException). I will correct it later in the evening or tomorrow a make a pullrequest to the git.</description>
			<version>2.13.2</version>
			<fixedVersion>2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.infinispan.InfinispanProducerTest.java</file>
			<file type="M">org.apache.camel.component.infinispan.InfinispanOperation.java</file>
			<file type="M">org.apache.camel.component.infinispan.InfinispanProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7735" opendate="2014-08-22 08:24:49" fixdate="2014-08-22 08:40:52" resolution="Fixed">
		<buginformation>
			<summary>ProducerTemplate - Sending manually created Exchange causes 2x sent event notification</summary>
			<description>Only when you manually create  the exchange and pass it to the producer template send method there will be 2x sent event in the notifier.</description>
			<version>2.13.2</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.ProducerCache.java</file>
		</fixedFiles>
	</bug>
	<bug id="7736" opendate="2014-08-22 09:07:57" fixdate="2014-08-22 11:39:49" resolution="Fixed">
		<buginformation>
			<summary>Failure to create producer during routing slip or similar eip causes exchange causes error handler not to react properly</summary>
			<description>If an endpoint.createProducer throws an exception from a dynamic eip, then the exchange is kept marked as inflight, and the error handler does not react asap and as expected.
This was working in Camel 2.10.x etc.</description>
			<version>2.13.2</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.ProducerCache.java</file>
		</fixedFiles>
	</bug>
	<bug id="7731" opendate="2014-08-21 16:33:15" fixdate="2014-08-22 15:05:54" resolution="Fixed">
		<buginformation>
			<summary>DefaultBeanRowMapper broken</summary>
			<description>DefaultBeanRowMapper current version does not upper-case when it should, due to what appears to be a copy paste error (note the toLowerCase in both branches)
if (toUpper) 
{
	char upper = Character.toLowerCase(ch);
	sb.append(upper);
	// reset flag
	toUpper = false;
}
 else 
{
	char lower = Character.toLowerCase(ch);
	sb.append(lower);
}

should be

if (toUpper) {
	char upper = Character.toUpperCase(ch);
	sb.append(upper);
	// reset flag
	toUpper = false;
} else {
	char lower = Character.toLowerCase(ch);
	sb.append(lower);
}</description>
			<version>2.13.2</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jdbc.DefaultBeanRowMapper.java</file>
		</fixedFiles>
	</bug>
	<bug id="7448" opendate="2014-05-20 09:13:44" fixdate="2014-08-27 03:48:52" resolution="Fixed">
		<buginformation>
			<summary>throttle EIP - unchanged value</summary>
			<description>Throttler Documentation [1] states "If the header is absent, then the Throttler uses the old value. So that allows you to only provide a header if the  value is to be changed".
however if the expression evaluates to null (header missing from message) the Throttler throws an exception (Throttler.java:108).
The workaround is to ensure that all messages carry the value (if the value is the same no changes will take affect). Adding an option to turn this on and off (e.g. allowNullException) would make it much easier to use (as per camel-users thread [2]).
[1] http://camel.apache.org/throttler.html
[2] http://camel.465427.n5.nabble.com/throttle-EIP-unchanged-value-td5751300.html</description>
			<version>2.13.1</version>
			<fixedVersion>2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.Throttler.java</file>
			<file type="M">org.apache.camel.processor.ThrottlerNullEvalTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7751" opendate="2014-08-26 23:44:09" fixdate="2014-08-27 05:09:20" resolution="Fixed">
		<buginformation>
			<summary>Trace interceptor use add instead of remove in removeTraceHandler</summary>
			<description>Class https://github.com/apache/camel/blob/master/camel-core/src/main/java/org/apache/camel/processor/interceptor/Tracer.java implements add instead of remove in method: 
    public void removeTraceHandler(TraceEventHandler traceHandler) 
{
        this.traceHandlers.add(traceHandler);
    }</description>
			<version>2.13.2</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.interceptor.Tracer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7673" opendate="2014-08-09 07:35:34" fixdate="2014-08-27 07:01:39" resolution="Fixed">
		<buginformation>
			<summary>subscribeTopicName leaks out as a property and used as a destination for mqtt producer, causes infinite delivery</summary>
			<description>MQTT consumer sets its subscribeTopicName as a exchange property, and it will be used by MQTT producer as a destination if it exists in the route.
If you have a following route:


from("mqtt:input?subscribeTopicName=topicIn")
        .to("mqtt:output?publishTopicName=topicOut");


MQTT consumer put "topicIn" to "MQTTTopicPropertyName" exchange property, and MQTT producer uses this property to determine a destination topic to publish. Then MQTT producer ignores publishTopicName and send a message to "topicIn", so MQTT consumer consumes the message again, eventually it causes infinite delivery. We need to stop this property to be used as a destination for producer.</description>
			<version>2.12.2</version>
			<fixedVersion>2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mqtt.MQTTProducer.java</file>
			<file type="M">org.apache.camel.component.mqtt.MQTTEndpoint.java</file>
			<file type="M">org.apache.camel.component.mqtt.MQTTConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8228</link>
		</links>
	</bug>
	<bug id="7754" opendate="2014-08-27 08:37:35" fixdate="2014-08-27 10:29:11" resolution="Fixed">
		<buginformation>
			<summary>Property Trigger.timerZone is declared as constant but not implemented</summary>
			<description>Seems that we have a problem with Quartz/Quartz2 components. The doc claims that we can setup this property in the URI "trigger.timeZone" (http://camel.apache.org/quartz.html - see specifying timezone ) but quartz don&amp;amp;apos;t use it even if a constant is defined :https://www.dropbox.com/s/1wjt3slsz3jajlh/Screenshot%202014-08-27%2010.29.53.png?dl=0
We have the same issue too with quartz2 --&amp;gt; https://www.dropbox.com/s/jcxnn72bzi38qob/Screenshot%202014-08-27%2010.31.34.png?dl=0</description>
			<version>2.12.1</version>
			<fixedVersion>2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.quartz2.QuartzEndpoint.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="7757" opendate="2014-08-27 12:00:42" fixdate="2014-08-29 05:05:32" resolution="Fixed">
		<buginformation>
			<summary>camel-restlet  2.13.1  throwing EOFException  on reading ZipInputStream </summary>
			<description>Please refer to : http://camel.465427.n5.nabble.com/Came-2-13-1-Reading-ZipInputStream-EOFException-tt5755726.html</description>
			<version>2.13.1</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.DefaultRestletBinding.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">8941</link>
		</links>
	</bug>
	<bug id="7763" opendate="2014-08-29 13:58:50" fixdate="2014-08-29 14:05:35" resolution="Fixed">
		<buginformation>
			<summary>NettyServerBootstrapConfiguration should provide default SSL settings</summary>
			<description>Currently NettyServerBootstrapConfiguration doesn&amp;amp;apos;t provide default values of keyStoreFormat and securityProvider options. This is not in sync with description of these options in Netty doc (1).
For example the following configuration:


&amp;lt;bean id="httpsConfiguration" class="org.apache.camel.component.netty.http.NettySharedHttpServerBootstrapConfiguration"&amp;gt;
  &amp;lt;property name="port" value="10020"/&amp;gt;
  &amp;lt;property name="host" value="0.0.0.0"/&amp;gt;
  &amp;lt;property name="keyStoreResource" value="jsse/localhost.ks"/&amp;gt;
  &amp;lt;property name="trustStoreResource" value="jsse/localhost.ks"/&amp;gt;
  &amp;lt;property name="passphrase" value="changeit"/&amp;gt;
&amp;lt;/bean&amp;gt;	 


...won&amp;amp;apos;t work until I add keyStoreFormat and securityProvider explicitly to it:


  &amp;lt;property name="keyStoreFormat" value="JKS"/&amp;gt;
  &amp;lt;property name="securityProvider" value="SunX509"/&amp;gt;


Solution:
We should add keyStoreFormat=JKS and securityProvider=SunX509 defaults to the NettyServerBootstrapConfiguration.
(1) http://camel.apache.org/netty.html</description>
			<version>2.13.2</version>
			<fixedVersion>2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.NettyServerBootstrapConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="7762" opendate="2014-08-29 09:05:34" fixdate="2014-08-30 06:55:31" resolution="Fixed">
		<buginformation>
			<summary>Camel CxfPayload issue when using namespace with no prefix (xmlns:xmlns)</summary>
			<description>When using Camel CXF in PAYLOAD mode.If the client sends a SOAP request with body having no namespace prefix. The element which get for the Payload body has an attribute "xmlns:xmlns".
You can find more information in the stack overflow site</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfPayload.java</file>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBindingTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7768" opendate="2014-08-30 07:58:31" fixdate="2014-08-30 13:07:33" resolution="Fixed">
		<buginformation>
			<summary>Handle fault - Should convert the payload to String using type converter</summary>
			<description>We should use the type covnerters from Camel to convert the payload correctly.
As if you have a DOM object then we just do a .toString which just prints it as Document #0 etc.</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.interceptor.HandleFaultInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="7767" opendate="2014-08-30 07:48:37" fixdate="2014-08-30 13:07:39" resolution="Fixed">
		<buginformation>
			<summary>Mock - Defining assertion on message doest work if using convertTo</summary>
			<description>See
http://www.manning-sandbox.com/thread.jspa?threadID=41025&amp;amp;tstart=0
The reason is when you use a method in the fluent builder that returns a ValueBuilder then that didn&amp;amp;apos;t detect the predicate.</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.MessageHelper.java</file>
			<file type="M">org.apache.camel.processor.onexception.OnExceptionHandledTest.java</file>
			<file type="M">org.apache.camel.issues.TryCatchWithSplitIssueTest.java</file>
			<file type="M">org.apache.camel.builder.ValueBuilder.java</file>
			<file type="M">org.apache.camel.component.mock.AssertionClause.java</file>
		</fixedFiles>
	</bug>
	<bug id="7772" opendate="2014-09-01 06:37:14" fixdate="2014-09-01 06:48:11" resolution="Fixed">
		<buginformation>
			<summary>Maven plugin camel-api-component-maven-plugin cannot read empty API name for components with single proxy class</summary>
			<description>Maven has a known issue where empty parameter values are set as null value for properties and plugin configuration parameters. This throws an error with the message "Properties apiName and proxyClass are required".
The camel-api-component-maven-plugin must explicitly set the apiName to "" for this use case for single proxy class API components. </description>
			<version>2.13.2</version>
			<fixedVersion>2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.maven.ApiComponentGeneratorMojo.java</file>
		</fixedFiles>
	</bug>
	<bug id="7568" opendate="2014-07-02 14:04:54" fixdate="2014-09-01 11:06:47" resolution="Fixed">
		<buginformation>
			<summary>OnComplete does not  work on transactioned route after rollback</summary>
			<description>Example:
Route Sample

this.from("servlet:///test").routeId("CamelTestRoute") 
   .onCompletion() 
      .bean(this.logCompletionRoute) 
   .end() 
   .onException(Exception.class) 
      .log(LoggingLevel.ERROR, this.log, "Error on processing message. Sending Rollback command!") 
      .log(LoggingLevel.ERROR, this.log, "${exception.stacktrace}") 
      .rollback()
      .handled(true) 
   .end() 
   .transacted(RouteTransactionConfiguration.PROPAGATION_REQUIRED) 
   .process(new Processor() { 
                @Override 
                public void process(Exchange exchange) throws Exception { 
                    throw new Exception(); 
                }}); 


In this sample, the OnCompletion bean never is executed. But, if I remove the "rollback()" call, it is executed properly.
thanks,</description>
			<version>2.13.1</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.OnCompletionProcessor.java</file>
			<file type="M">org.apache.camel.issues.OnCompletionIssueTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7452" opendate="2014-05-21 07:02:01" fixdate="2014-09-01 20:08:50" resolution="Fixed">
		<buginformation>
			<summary>beanRef is caching instances - unwanted behavior</summary>
			<description>After upgrading from 2.11.0 to 2.13.0 the behavior of beanRef has changed(unwanted behavior). Beans only get instanted once, even if the cache option is explicitly set to "false".  
see http://camel.465427.n5.nabble.com/beanRef-is-caching-instances-in-camel-2-13-0-unwanted-behavior-td5751335.html</description>
			<version>2.13.0</version>
			<fixedVersion>2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.ConstantTypeBeanHolder.java</file>
			<file type="M">org.apache.camel.component.bean.BeanProcessor.java</file>
			<file type="M">org.apache.camel.component.bean.ConstantStaticTypeBeanHolder.java</file>
			<file type="M">org.apache.camel.model.language.MethodCallExpression.java</file>
			<file type="M">org.apache.camel.component.bean.RegistryBean.java</file>
			<file type="M">org.apache.camel.component.bean.PredicateAsBeanTest.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.component.bean.NewInstanceTest.java</file>
			<file type="M">org.apache.camel.model.BeanDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="7364" opendate="2014-04-14 12:46:20" fixdate="2014-09-02 12:11:54" resolution="Fixed">
		<buginformation>
			<summary>JpaMessageIdRepository uses EntityManager non thread-safe</summary>
			<description>In our product we have found strange behavior of JpaMessageIdRepository when change version 2.9.2 to 2.12.3.
The reason for this was that EntityManager assigned in the constructor org.apache.camel.processor.idempotent.jpa.JpaMessageIdRepository, but
EntityManager not required to be thread safe.
http://download.oracle.com/otn-pub/jcp/persistence-2.0-fr-oth-JSpec/persistence-2_0-final-spec.pdf page 286.
I think need assign the EntityManager in each method separately.</description>
			<version>2.12.3</version>
			<fixedVersion>2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.idempotent.jpa.JpaMessageIdRepository.java</file>
			<file type="M">org.apache.camel.component.jpa.AbstractJpaMethodTest.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaConstants.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaProducer.java</file>
			<file type="M">org.apache.camel.processor.idempotent.IdempotentConsumer.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaConsumer.java</file>
			<file type="M">org.apache.camel.processor.idempotent.IdempotentOnCompletion.java</file>
			<file type="M">org.apache.camel.spi.IdempotentRepository.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaEndpoint.java</file>
			<file type="M">org.apache.camel.model.rest.RestConfigurationDefinition.java</file>
			<file type="M">org.apache.camel.test.blueprint.component.rest.FromRestConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.restlet.RestletComponent.java</file>
			<file type="M">org.apache.camel.component.sparkrest.RestCamelSparkAcceptTest.java</file>
			<file type="M">org.apache.camel.component.rest.FromRestConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.sparkrest.SparkComponent.java</file>
			<file type="M">org.apache.camel.spi.RestConfiguration.java</file>
			<file type="M">org.apache.camel.test.blueprint.component.rest.FromRestUriPrefixTest.java</file>
			<file type="M">org.apache.camel.component.rest.FromRestUriPrefixTest.java</file>
			<file type="M">org.apache.camel.component.sparkrest.RestCamelSparkRequestBeanTest.java</file>
			<file type="M">org.apache.camel.component.sparkrest.RestCamelSparkSplatTest.java</file>
			<file type="M">org.apache.camel.component.restlet.RestRestletGetTest.java</file>
			<file type="M">org.apache.camel.test.blueprint.component.rest.FromRestGetTest.java</file>
			<file type="M">org.apache.camel.model.rest.VerbDefinition.java</file>
			<file type="M">org.apache.camel.component.rest.FromRestGetEndPathTest.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.component.rest.FromRestGetTest.java</file>
			<file type="M">org.apache.camel.model.RouteDefinition.java</file>
			<file type="M">org.apache.camel.management.ManagedFromRestGetTest.java</file>
			<file type="M">org.apache.camel.example.spark.MySparkRouteBuilder.java</file>
			<file type="M">org.apache.camel.component.rest.FromRestExplicitComponentTest.java</file>
			<file type="M">org.apache.camel.model.rest.RestDefinition.java</file>
			<file type="M">org.apache.camel.component.sparkrest.RestCamelSparkParamTest.java</file>
			<file type="M">org.apache.camel.test.blueprint.component.rest.FromRestGetEmbeddedRouteTest.java</file>
			<file type="M">org.apache.camel.component.rest.FromRestGetEmbeddedRouteTest.java</file>
			<file type="M">org.apache.camel.CamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.component.rest.RestComponent.java</file>
			<file type="M">org.apache.camel.blueprint.BlueprintJaxbRestTest.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilder.java</file>
			<file type="M">org.apache.camel.core.xml.AbstractCamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.blueprint.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.model.ModelCamelContext.java</file>
			<file type="M">org.apache.camel.spring.handler.CamelNamespaceHandler.java</file>
			<file type="M">org.apache.camel.component.sparkrest.RestCamelSparkComponentTest.java</file>
			<file type="M">org.apache.camel.model.rest.RestsDefinition.java</file>
			<file type="D">org.apache.camel.model.rest.PathDefinition.java</file>
			<file type="M">org.apache.camel.component.sparkrest.RestCamelSparkTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">8672</link>
			<link type="Regression" description="breaks">8003</link>
		</links>
	</bug>
	<bug id="7665" opendate="2014-08-06 18:48:59" fixdate="2014-09-07 06:46:59" resolution="Fixed">
		<buginformation>
			<summary>RabbitMq don&amp;apos;t reject messages when consumer or endpoint fail.</summary>
			<description>RabbitMQ does not execute command to reject a message when consumers or end point throws an exception or shutdown is executed by karaf.
We need execute channel.basicReject(deliveryTag, false) to send message to Dead Letter Exchange.
In current implementation the message is always acknowledged. 
Scenario:


from("rabbitmq://localhost:5672/myFailTest?"
+"routingKey=myFailTest&amp;amp;queue=myFailTest&amp;amp;exchangeType=direct"
+ "&amp;amp;vhost=test&amp;amp;durable=true&amp;amp;autoDelete=false"
+ "&amp;amp;autoAck=false&amp;amp;username=guest&amp;amp;password=guest")
.to("ftp://localhost/notExists?connectTimeout=100&amp;amp;timeout=100");


Using errorHandler(deadLetterChannel("..another queue") the message is Redelivered in same queue.</description>
			<version>2.13.2</version>
			<fixedVersion>2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQConsumer.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQConstants.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="7556" opendate="2014-06-29 13:02:44" fixdate="2014-09-07 06:59:11" resolution="Fixed">
		<buginformation>
			<summary>camel-rabbitmq: Multiple concurrent consumer threads</summary>
			<description>Allow multiple concurrent threads listening to a single queue (like the JMS endpoint)</description>
			<version>2.13.1</version>
			<fixedVersion>2.14.0</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQConsumer.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQLoadIntTest.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQEndpoint.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">7564</link>
		</links>
	</bug>
	<bug id="7795" opendate="2014-09-09 12:50:12" fixdate="2014-09-09 13:07:13" resolution="Fixed">
		<buginformation>
			<summary>Regression: MDC may lose values after when Async Routing Engine is used</summary>
			<description>CAMEL-6377 introduced some optimisations in the MDC Logging mechanism which make it lose MDC values when the async routing engine is used.
If we are using an async component such as CXF, the response or done() callback will be issued from a thread NOT managed by Camel. Therefore, we need the MDCCallback to reset ALL MDC values, not just the routeId (as was intended by the commits that caused the regression).
The situation may be salvaged by the fact that underlying MDC implementations use an InheritableThreadLocal, so the first requests after system initialisation may see correct behaviour, because the MDC values from the requesting thread is propagated to the newly initialised threads in the underlying stack&amp;amp;apos;s ThreadPool, as the coreThreads are being initialised within the context of the original threads which act like parent threads.
But after those first attempts, odd behaviour is seen and all responses from the async endpoint come back without an MDC.</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.MDCUnitOfWork.java</file>
		</fixedFiles>
		<links>
			<link type="Regression" description="is broken by">6377</link>
		</links>
	</bug>
	<bug id="7798" opendate="2014-09-09 17:17:34" fixdate="2014-09-10 13:43:36" resolution="Fixed">
		<buginformation>
			<summary>Exchange formatter configured on Log Component may lead to incoherent results</summary>
			<description>Currently configuring a custom ExchangeFormatter at the Log Component level may lead to incoherent results if there are multiple Log endpoints in the context, with different log options (e.g. showBody=true, showBody=false).
This is because the component looks up the ExchangeFormatter in the registry, sets its properties and then remembers the result for the subsequent endpoint initialisations. This is incorrect.
The correct procedure is:

Look up the ExchangeFormatter each time, obtaining a new fresh copy each time. This can be ensured by using @scope=prototype in Spring/Blueprint in the bean definition.
Set its properties, according to the current endpoint&amp;amp;apos;s properties.
Use the resulting ExchangeFormatter for that endpoint only.
Subsequent endpoint initialisations must repeat the same procedure.

</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.log.LogComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="7826" opendate="2014-09-16 03:29:08" fixdate="2014-09-16 03:39:23" resolution="Fixed">
		<buginformation>
			<summary>Olingo2 component sets incorrect value for "id" element in create entry endpoint</summary>
			<description>The serviceRoot property is not set correctly to the OData base URI when creating the EntityProviderWriteProperties, which causes the generated links in body to be incorrect. </description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.olingo2.api.impl.Olingo2AppImpl.java</file>
			<file type="M">org.apache.camel.component.olingo2.api.Olingo2AppIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7803" opendate="2014-09-11 12:53:01" fixdate="2014-09-16 13:09:13" resolution="Fixed">
		<buginformation>
			<summary>DefaultJdbcPrepareStatementStrategy Iterator fails on null value inserts</summary>
			<description>The iterator returned by createPopulateIterator in DefaultJdbcPrepareStatementStrategy incorrectly uses a next value of "null" to identify when it has run out of parameters.  This fails when the parameter map intentionally contains a name with a null value, which is the case when some columns in an insert should be set to null.  The attached pull request adds an explicit preFetch flag and relies on the done flag, avoiding the incorrect overloading of (next==null) to indicate completion.
The iterator reports "hasNext() == false" when it encounters a map value of null.  This happens when using the map header JDBC_PARAMETERS = "CamelJdbcParameters" to insert null values with a prepared statement.  The Iterator ends prematurely when it reaches a parameter name with a null value.  
For example, passing in a map where the 3rd parameter of 19 has a value of null causes the following exception to be thrown:
java.sql.SQLException: Number of parameters mismatch. Expected: 19, was:2
        at org.apache.camel.component.jdbc.DefaultJdbcPrepareStatementStrategy.populateStatement(DefaultJdbcPrepareStatementStrategy.java:137)
        at org.apache.camel.component.jdbc.JdbcProducer.doCreateAndExecuteSqlStatementWithHeaders(JdbcProducer.java:133)
        at org.apache.camel.component.jdbc.JdbcProducer.createAndExecuteSqlStatement(JdbcProducer.java:116)
        at org.apache.camel.component.jdbc.JdbcProducer.processingSqlBySettingAutoCommit(JdbcProducer.java:85)
</description>
			<version>2.13.2</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jdbc.DefaultJdbcPrepareStatementStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="7829" opendate="2014-09-16 19:45:41" fixdate="2014-09-16 20:50:43" resolution="Fixed">
		<buginformation>
			<summary>Olingo2 component should handle 200 OK responses from OData servers for PUT method</summary>
			<description>Some OData servers, like the JBoss Data Virtualization server based on OData4J library respond with HTTP 200 OK instead of 204 No Content for PUT methods. 
The component needs to be able to handle this scenario. </description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.olingo2.api.impl.Olingo2AppImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="7830" opendate="2014-09-17 02:48:06" fixdate="2014-09-17 05:10:06" resolution="Fixed">
		<buginformation>
			<summary>RestLetHeaderFilterStrategy should filter the header of "Transfer-Encoding"</summary>
			<description>As we don&amp;amp;apos;t set the transfer_encoding protocol header for the restlet service, we need to remove the transfer_encoding header which could let the client wait forever.</description>
			<version>2.13.2</version>
			<fixedVersion>2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.RestletSetBodyTest.java</file>
			<file type="M">org.apache.camel.component.restlet.RestletHeaderFilterStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="7836" opendate="2014-09-18 15:37:13" fixdate="2014-09-21 09:24:59" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentModificationException when creating dynamic routes</summary>
			<description>There is a (small) chance of ConcurrentModificationException when creating routes dynamically.

java.util.ConcurrentModificationException
  at java.util.LinkedHashMap$LinkedHashIterator.nextEntry(LinkedHashMap.java:373)
  at java.util.LinkedHashMap$KeyIterator.next(LinkedHashMap.java:384)
  at java.util.AbstractCollection.toArray(AbstractCollection.java:124)
  at java.util.ArrayList.&amp;amp;lt;init&amp;amp;gt;(ArrayList.java:131)
  at org.apache.camel.impl.DefaultCamelContext.getRoutes(DefaultCamelContext.java:650)
  at org.apache.camel.impl.DefaultCamelContext.getRoute(DefaultCamelContext.java:655)


The cause is that if you happen to be calling getRoute at the same time you are creating a new route then the internals of new ArrayList call collection.toArray which throws the error.</description>
			<version>2.13.1</version>
			<fixedVersion>2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8673</link>
		</links>
	</bug>
	<bug id="7839" opendate="2014-09-19 10:21:11" fixdate="2014-09-22 08:02:59" resolution="Fixed">
		<buginformation>
			<summary>Xpath is not namespace aware in choice</summary>
			<description>I have a route (XML definition) containing a choice based on xpath expressions. The xpath expressions are using custom namespaces. After migration from camel 2.13.2 to camel 2.14.0 the namespaces are not registered to the XpathExpression and XPathBuilder anymore.
XPath in "setProperty" definitions referencing the same namespaces still work fine.</description>
			<version>2.14.0</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ProcessorDefinitionHelperTest.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinitionHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="7842" opendate="2014-09-20 14:02:31" fixdate="2014-09-22 08:23:45" resolution="Fixed">
		<buginformation>
			<summary>Avoid using InputStreamEntity for byte[] input</summary>
			<description>Sending byte[] input via http in some circumstances causes ugly NonRepeatableEntityException because of the internal usage of InputStreamEntity in the HttpEntityConverter which is not repeatable. The usage of ByteArrayEntity seems more resonable for this input.
A workaround is to explicitly convertbodyto string but this is taken with care because of encoding when creating string and StringEntity later on!</description>
			<version>2.14.0</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http4.HttpEntityConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="7852" opendate="2014-09-23 10:19:53" fixdate="2014-09-23 12:39:47" resolution="Fixed">
		<buginformation>
			<summary>camel-msv component cannot be resolved in OSGi</summary>
			<description>

Caused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: msv://META-INF/relexng/address-book.rng due to: No component found with scheme: msv
at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:537)

</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.itest.karaf.CamelMsvTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7856" opendate="2014-09-24 05:41:05" fixdate="2014-09-24 05:45:09" resolution="Fixed">
		<buginformation>
			<summary>camel-cxf producer HttpAPI should not send the message body when using DELETE method</summary>
			<description>Here is the discussion in stackoverflow.
</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7866" opendate="2014-09-26 15:30:19" fixdate="2014-09-26 15:53:18" resolution="Fixed">
		<buginformation>
			<summary>barcodeFormat is always QR CODE</summary>
			<description>I&amp;amp;apos;m testing the camel-barcode component with the following Spring XML.


    &amp;lt;camelContext xmlns="http://camel.apache.org/schema/spring"&amp;gt;
        &amp;lt;dataFormats&amp;gt;
            &amp;lt;barcode id="QR_CODE" width="200" height="200" imageType="JPG" barcodeFormat="QR_CODE"/&amp;gt;
            &amp;lt;barcode id="PDF_417" width="200" height="200" imageType="JPG" barcodeFormat="PDF_417"/&amp;gt;
        &amp;lt;/dataFormats&amp;gt;

        &amp;lt;route&amp;gt;
            &amp;lt;from uri="direct:QR_CODE"/&amp;gt;
            &amp;lt;marshal ref="QR_CODE"/&amp;gt;
            &amp;lt;to uri="file:target/out?fileName=qr_code.jpg"/&amp;gt;
        &amp;lt;/route&amp;gt;
    
        &amp;lt;route&amp;gt;
            &amp;lt;from uri="direct:PDF_417"/&amp;gt;
            &amp;lt;marshal ref="PDF_417"/&amp;gt;
            &amp;lt;to uri="file:target/out?fileName=pdf_417.jpg"/&amp;gt;
        &amp;lt;/route&amp;gt;    
    &amp;lt;/camelContext&amp;gt;


But pdf_417.jpg seems to be QR CODE, not PDF 417.</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.barcode.BarcodeTestBase.java</file>
			<file type="M">org.apache.camel.model.dataformat.BarcodeDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="7870" opendate="2014-09-27 10:07:13" fixdate="2014-09-27 11:17:55" resolution="Fixed">
		<buginformation>
			<summary>[camel-barcode] Writer/Reader hints should be re-optimized when setBarcodeFormat method called.</summary>
			<description>BarcodeDataFormat#setBarcodeDataFormat() should optimize writer/reader hints such like setBarcodeImageType().
see https://github.com/apache/camel/pull/284</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.barcode.BarcodeDataFormatTest.java</file>
			<file type="M">org.apache.camel.dataformat.barcode.BarcodeDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="7868" opendate="2014-09-27 08:29:33" fixdate="2014-09-27 11:18:31" resolution="Fixed">
		<buginformation>
			<summary>wrong concatenation of parameters in JettyHttpComponent</summary>
			<description>See http://camel.465427.n5.nabble.com/bug-restConfiguration-jetty-endpointProperty-td5757065.html for details.</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">7869</link>
		</links>
	</bug>
	<bug id="7869" opendate="2014-09-27 08:35:14" fixdate="2014-09-27 11:20:01" resolution="Fixed">
		<buginformation>
			<summary>endpointProperty does not work (restConfiguration - jetty)</summary>
			<description>See http://camel.465427.n5.nabble.com/bug-restConfiguration-jetty-endpointProperty-td5757065.html</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">7868</link>
		</links>
	</bug>
	<bug id="7871" opendate="2014-09-27 10:59:07" fixdate="2014-09-27 12:16:32" resolution="Fixed">
		<buginformation>
			<summary>[camel-barcode] failed to create AZTEC barcode </summary>
			<description>I&amp;amp;apos;m testing camel-barcode  to create AZTEC barcode format with the following spring xml.


    &amp;lt;camelContext trace="true" xmlns="http://camel.apache.org/schema/spring"&amp;gt;

        &amp;lt;dataFormats&amp;gt;
            &amp;lt;barcode id="AZTEC" width="200" height="200" imageType="JPG" barcodeFormat="AZTEC"/&amp;gt;
        &amp;lt;/dataFormats&amp;gt;

        &amp;lt;route&amp;gt;
            &amp;lt;from uri="direct:AZTEC"/&amp;gt;
            &amp;lt;marshal ref="AZTEC"/&amp;gt;
            &amp;lt;to uri="file:target/out?fileName=aztec.jpg"/&amp;gt;
        &amp;lt;/route&amp;gt;
    &amp;lt;/camelContext&amp;gt;


But I get the following stack trace.


Stacktrace
---------------------------------------------------------------------------------------------------------------------------------------
java.lang.ClassCastException: com.google.zxing.qrcode.decoder.ErrorCorrectionLevel cannot be cast to java.lang.Number
	at com.google.zxing.aztec.AztecWriter.encode(AztecWriter.java:41)
	at com.google.zxing.MultiFormatWriter.encode(MultiFormatWriter.java:94)
	at org.apache.camel.dataformat.barcode.BarcodeDataFormat.printImage(BarcodeDataFormat.java:231)
	at org.apache.camel.dataformat.barcode.BarcodeDataFormat.marshal(BarcodeDataFormat.java:162)
	at org.apache.camel.processor.MarshalProcessor.process(MarshalProcessor.java:81)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)
	at org.apache.camel.processor.interceptor.TraceInterceptor.process(TraceInterceptor.java:163)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:118)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:51)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.processor.UnitOfWorkProducer.process(UnitOfWorkProducer.java:74)
	at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:375)
	at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:343)
	at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:233)
	at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:343)
	at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:184)
	at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:124)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:137)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:144)
	at org.apache.camel.dataformat.barcode.BarcodeFormatTest.tesAZTEC(BarcodeFormatTest.java:61)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:72)
	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:81)
	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:216)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:82)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:60)
	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:67)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:162)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:254)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:149)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:124)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:200)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:153)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:103)

</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.barcode.BarcodeDataFormatTest.java</file>
			<file type="M">org.apache.camel.dataformat.barcode.BarcodeDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.barcode.BarcodeDataFormatCamelTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7855" opendate="2014-09-23 22:04:11" fixdate="2014-09-27 12:16:58" resolution="Fixed">
		<buginformation>
			<summary>If you suspend a JMS route that is stopped, calling resume on it does not work and reports no error</summary>
			<description>If a route that consumes from JMS is in state Stopped, and first Suspend and then Resume are called upon it, the route reports itself as being in state Started. However, it is not actually consuming anything from the endpoint.</description>
			<version>2.14.0</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7874" opendate="2014-09-27 15:38:23" fixdate="2014-09-27 20:20:39" resolution="Fixed">
		<buginformation>
			<summary>json DataFormat: The prettyPrint option does not work as expected</summary>
			<description>See http://camel.465427.n5.nabble.com/Problems-prettyPrinting-JSON-after-camel-2-14-0-upgrade-td5756738.html#a5757104 for a background.</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jackson.JacksonJsonDataFormatTest.java</file>
			<file type="M">org.apache.camel.component.jackson.SpringJacksonJsonDataFormatTest.java</file>
			<file type="M">org.apache.camel.component.jackson.JacksonMarshalTest.java</file>
			<file type="M">org.apache.camel.model.dataformat.JsonDataFormat.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">7877</link>
		</links>
	</bug>
	<bug id="7876" opendate="2014-09-27 16:24:35" fixdate="2014-09-28 03:32:17" resolution="Fixed">
		<buginformation>
			<summary>GroupIterator should respect the exchange&amp;apos;s CHARSET_NAME property.</summary>
			<description>Line 141 of GroupIterator calls toString on it&amp;amp;apos;s ByteArrayOutputStream, thereby utilising the default encoding set for the JVM.
This can cause issues when say splitting an exchange&amp;amp;apos;s body using token/groups with a different encoding from that of the JVM&amp;amp;apos;s default.</description>
			<version>2.14.0</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.GroupIterator.java</file>
			<file type="M">org.apache.camel.util.GroupIteratorTest.java</file>
			<file type="M">org.apache.camel.builder.ExpressionBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="7885" opendate="2014-10-01 07:40:08" fixdate="2014-10-01 09:19:07" resolution="Fixed">
		<buginformation>
			<summary>Timer - Restarting a timer endpoint may not trigger at expected time the first time</summary>
			<description>If you stop a timer route, and that route has an inflight exchange causing the stop route to force stop due timeout. Then that timer task is still running in the background.
And if you restart the timer route, then it will reuse the old timer instance, which may be still running, and therefore the first trigger time may not happen at the time you would expect.
For example from timer:foo?period=2s to trigger every 2s.</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.timer.TimerEndpoint.java</file>
			<file type="M">org.apache.camel.component.timer.TimerComponent.java</file>
			<file type="M">org.apache.camel.component.timer.TimerConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7867" opendate="2014-09-26 16:17:24" fixdate="2014-10-09 02:27:39" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException when using CXF endpoint to enrich</summary>
			<description>When using Spring application context file to enrich a CXF message with another CXF endpoint, I get a NullPointerException whenever a message comes in. If I route with a &amp;lt;to&amp;gt; instead of &amp;lt;enrich&amp;gt;, it works fine.
    &amp;lt;cxf:cxfEndpoint id="producerEndpoint"
                     address="/Request/"
                     serviceClass="com.service.ClassName"
                     wsdlURL="/Service.wsdl" &amp;gt;
    &amp;lt;/cxf:cxfEndpoint&amp;gt;
    &amp;lt;cxf:cxfEndpoint id="enrichEndpoint"
                     address="http://localhost:8082/Request/"
                     serviceClass="com.service.ClassName"
                     wsdlURL="/Service.wsdl"&amp;gt;
    &amp;lt;/cxf:cxfEndpoint&amp;gt;
...
    &amp;lt;camelContext xmlns="http://camel.apache.org/schema/spring"&amp;gt;
        &amp;lt;route&amp;gt;
            &amp;lt;from ref="producerEndpoint" /&amp;gt;
            &amp;lt;enrich ref="enrichEndpoint" /&amp;gt;
            &amp;lt;to ref="finalEndpoint" /&amp;gt;
        &amp;lt;/route&amp;gt;
    &amp;lt;/camelContext&amp;gt;
Stacktrace
---------------------------------------------------------------------------------------------------------------------------------------
java.lang.NullPointerException
	at org.apache.camel.component.cxf.CxfProducer.prepareRequest(CxfProducer.java:190)
	at org.apache.camel.component.cxf.CxfProducer.process(CxfProducer.java:107)
	at org.apache.camel.processor.Enricher.process(Enricher.java:114)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:118)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:105)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:87)
	at org.apache.camel.component.cxf.CxfConsumer$1.syncInvoke(CxfConsumer.java:136)
	at org.apache.camel.component.cxf.CxfConsumer$1.invoke(CxfConsumer.java:77)
	at org.apache.cxf.interceptor.ServiceInvokerInterceptor$1.run(ServiceInvokerInterceptor.java:59)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)
	at java.util.concurrent.FutureTask.run(FutureTask.java:262)
	at org.apache.cxf.interceptor.ServiceInvokerInterceptor$2.run(ServiceInvokerInterceptor.java:126)
	at org.apache.cxf.workqueue.SynchronousExecutor.execute(SynchronousExecutor.java:37)
	at org.apache.cxf.interceptor.ServiceInvokerInterceptor.handleMessage(ServiceInvokerInterceptor.java:131)
	at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:307)
	at org.apache.cxf.transport.ChainInitiationObserver.onMessage(ChainInitiationObserver.java:121)
	at org.apache.cxf.transport.http.AbstractHTTPDestination.invoke(AbstractHTTPDestination.java:243)
	at org.apache.cxf.transport.servlet.ServletController.invokeDestination(ServletController.java:223)
	at org.apache.cxf.transport.servlet.ServletController.invoke(ServletController.java:197)
	at org.apache.cxf.transport.servlet.ServletController.invoke(ServletController.java:149)
	at org.apache.cxf.transport.servlet.CXFNonSpringServlet.invoke(CXFNonSpringServlet.java:171)
	at org.apache.cxf.transport.servlet.AbstractHTTPServlet.handleRequest(AbstractHTTPServlet.java:286)
	at org.apache.cxf.transport.servlet.AbstractHTTPServlet.doPost(AbstractHTTPServlet.java:206)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:707)
	at org.apache.cxf.transport.servlet.AbstractHTTPServlet.service(AbstractHTTPServlet.java:262)
	at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:696)
	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1568)
	at org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter.doFilter(WebSocketUpgradeFilter.java:164)
	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1539)
	at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:524)
	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:143)
	at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:568)
	at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:221)
	at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1110)
	at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:453)
	at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:183)
	at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1044)
	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)
	at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:199)
	at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:109)
	at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97)
	at org.eclipse.jetty.server.Server.handle(Server.java:459)
	at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:279)
	at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:229)
	at org.eclipse.jetty.io.AbstractConnection$1.run(AbstractConnection.java:505)
	at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:594)
	at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:525)
	at java.lang.Thread.run(Thread.java:745)
[              qtp1470360717-16] PhaseInterceptorChain          WARN  Application 
{http://gl.services.csw}
CswPortService#
{http://gl.services.csw}
getRecords has thrown exception, unwinding now
org.apache.cxf.interceptor.Fault: NullPointerException
	at org.apache.camel.component.cxf.CxfConsumer$1.checkFailure(CxfConsumer.java:230)
	at org.apache.camel.component.cxf.CxfConsumer$1.setResponseBack(CxfConsumer.java:208)
	at org.apache.camel.component.cxf.CxfConsumer$1.syncInvoke(CxfConsumer.java:142)
	at org.apache.camel.component.cxf.CxfConsumer$1.invoke(CxfConsumer.java:77)
	at org.apache.cxf.interceptor.ServiceInvokerInterceptor$1.run(ServiceInvokerInterceptor.java:59)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)
	at java.util.concurrent.FutureTask.run(FutureTask.java:262)
	at org.apache.cxf.interceptor.ServiceInvokerInterceptor$2.run(ServiceInvokerInterceptor.java:126)
	at org.apache.cxf.workqueue.SynchronousExecutor.execute(SynchronousExecutor.java:37)
	at org.apache.cxf.interceptor.ServiceInvokerInterceptor.handleMessage(ServiceInvokerInterceptor.java:131)
	at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:307)
	at org.apache.cxf.transport.ChainInitiationObserver.onMessage(ChainInitiationObserver.java:121)
	at org.apache.cxf.transport.http.AbstractHTTPDestination.invoke(AbstractHTTPDestination.java:243)
	at org.apache.cxf.transport.servlet.ServletController.invokeDestination(ServletController.java:223)
	at org.apache.cxf.transport.servlet.ServletController.invoke(ServletController.java:197)
	at org.apache.cxf.transport.servlet.ServletController.invoke(ServletController.java:149)
	at org.apache.cxf.transport.servlet.CXFNonSpringServlet.invoke(CXFNonSpringServlet.java:171)
	at org.apache.cxf.transport.servlet.AbstractHTTPServlet.handleRequest(AbstractHTTPServlet.java:286)
	at org.apache.cxf.transport.servlet.AbstractHTTPServlet.doPost(AbstractHTTPServlet.java:206)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:707)
	at org.apache.cxf.transport.servlet.AbstractHTTPServlet.service(AbstractHTTPServlet.java:262)
	at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:696)
	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1568)
	at org.eclipse.jetty.websocket.server.WebSocketUpgradeFilter.doFilter(WebSocketUpgradeFilter.java:164)
	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1539)
	at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:524)
	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:143)
	at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:568)
	at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:221)
	at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1110)
	at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:453)
	at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:183)
	at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1044)
	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)
	at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:199)
	at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:109)
	at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97)
	at org.eclipse.jetty.server.Server.handle(Server.java:459)
	at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:279)
	at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:229)
	at org.eclipse.jetty.io.AbstractConnection$1.run(AbstractConnection.java:505)
	at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:594)
	at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:525)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.NullPointerException
	at org.apache.camel.component.cxf.CxfProducer.prepareRequest(CxfProducer.java:190)
	at org.apache.camel.component.cxf.CxfProducer.process(CxfProducer.java:107)
	at org.apache.camel.processor.Enricher.process(Enricher.java:114)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:118)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:105)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:87)
	at org.apache.camel.component.cxf.CxfConsumer$1.syncInvoke(CxfConsumer.java:136)
	... 41 more</description>
			<version>2.13.2</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultRouteContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="7896" opendate="2014-10-08 13:31:03" fixdate="2014-10-09 02:35:59" resolution="Fixed">
		<buginformation>
			<summary>camel-netty-http producer should close the channel when the connection header is not keep alive</summary>
			<description>If the http request connection header is "keep alive", camel http producer will not close the channel. It can cause some trouble if the response connection header is "close".  We need to close the channel if the response connection header is "close". </description>
			<version>2.13.2</version>
			<fixedVersion>2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.http.handlers.HttpClientChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty.handlers.ClientChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty.http.handlers.HttpClientChannelHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="7894" opendate="2014-10-08 04:39:28" fixdate="2014-10-09 02:38:04" resolution="Fixed">
		<buginformation>
			<summary>Encoder exception after sending a message with null body</summary>
			<description>when sending a request with a null body ( it was GET request in my case)
I got the following exception.
after investigating the issue I found that because the body is null - the request is created with type DefaultHttpRequest and not DefaultFullHttpRequest which is created when there is a body
this causes the HttpObjectEncoder to stay in a wrong state after the request is sent, because of this code:
 if (msg instanceof LastHttpContent) 
{
      state = ST_INIT;
}

so the next request will fail with the exception.
the workaround is simple - use an empty string as body
also - this did not happen in camel-netty-http
the exception:
Caused by: io.netty.handler.codec.EncoderException: java.lang.IllegalStateException: unexpected message type: DefaultFullHttpRequest at io.netty.handler.codec.MessageToMessageEncoder.write(MessageToMessageEncoder.java:107) at io.netty.channel.CombinedChannelDuplexHandler.write(CombinedChannelDuplexHandler.java:192) at io.netty.channel.AbstractChannelHandlerContext.invokeWrite(AbstractChannelHandlerContext.java:658) at io.netty.channel.AbstractChannelHandlerContext.access$2000(AbstractChannelHandlerContext.java:32) at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:939) at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:991) at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:924) at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:380) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:357) at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:116) at java.lang.Thread.run(Thread.java:745) Caused by: java.lang.IllegalStateException: unexpected message type: DefaultFullHttpRequest at io.netty.handler.codec.http.HttpObjectEncoder.encode(HttpObjectEncoder.java:63) at io.netty.handler.codec.http.HttpClientCodec$Encoder.encode(HttpClientCodec.java:106) at io.netty.handler.codec.MessageToMessageEncoder.write(MessageToMessageEncoder.java:89) ... 10 more</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpBasicAuthConstraintMapperTest.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpBasicAuthCustomSecurityAuthenticatorTest.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpSimpleBasicAuthConstraintMapperTest.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpProducerSimpleGetTest.java</file>
			<file type="M">org.apache.camel.component.netty4.http.DefaultNettyHttpBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="7892" opendate="2014-10-07 14:59:36" fixdate="2014-10-09 02:40:32" resolution="Fixed">
		<buginformation>
			<summary>Unable to perform a restlet DELETE with no entity</summary>
			<description>The Restlet class
org.restlet.ext.httpclient.internal.HttpMethodCall.java
logs a warning in case a DELETE method call is performed with an entity, indicating that "The current DELETE request provides an entity that may be not supported by the Apache HTTP Client library. If you face such issues, you can still move to another HTTP client connector."
Unfortunately it seems impossible to force the Camel Restlet module to prepare a DELETE Restlet Request with no entity. In fact the class
org.apache.camel.component.restlet.DefaultRestletBinding in its method populateRestletRequestFromExchange always creates an entity. Instead it should set a null entity in case exchange.getIn().getBody() is null.
</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.DefaultRestletBinding.java</file>
			<file type="D">org.apache.camel.component.restlet.RestletProducerGetTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7886" opendate="2014-10-02 08:25:32" fixdate="2014-10-09 08:16:46" resolution="Fixed">
		<buginformation>
			<summary>Charset not correctly set from content-type</summary>
			<description>When a "Content-Type" header is explicitely set with charset attached before invoking the camel http4 component, the charset is not taken into account.
This is because ContentType.create is invoked with the complete Content-Type when in fact it expects a mediaType.
(see lines 414-416: camel-http4 version 2.14.0)
   if (contentTypeString != null) 
{
      contentType = ContentType.create(contentTypeString);
   }

For example, if header is set to "application/json; charset=UTF-8" the contentType returned by ContentType.create(contentTypeString) is null.
And therefore, further down (line 444)  charset is not extracted even though it has been specified.
</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http4.HttpProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7899" opendate="2014-10-09 01:50:19" fixdate="2014-10-09 08:19:00" resolution="Fixed">
		<buginformation>
			<summary>camel-jetty should support to define multiple http method for the rest service</summary>
			<description>Camel complains Failed to start route route3 because of Multiple consumers for the same endpoint is not allowed, when define the rest service on the same path.


 restConfiguration()
                .component("jetty")
                .host("localhost").port(8080)
                .contextPath("rest")
                .bindingMode(RestBindingMode.auto)
                .dataFormatProperty("prettyPrint", "true");
        rest("/say")
                .get("/hello").to("direct:hello")
                .get("/bye").consumes("application/json").to("direct:bye")
                .post("/bye").to("direct:bye");

        from("direct:hello")
                .transform().constant("Hello World");
        from("direct:bye")
                .transform().constant("Bye World");


Here is the discussion in the nabble.</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.http.DefaultContextPathMatcher.java</file>
			<file type="M">org.apache.camel.component.netty4.http.rest.RestNettyHttpPojoInOutTest.java</file>
			<file type="M">org.apache.camel.component.netty4.http.rest.RestPathMatchingTest.java</file>
			<file type="M">org.apache.camel.component.netty4.http.RestContextPathMatcher.java</file>
			<file type="M">org.apache.camel.component.netty4.http.handlers.HttpServerMultiplexChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty.http.RestContextPathMatcher.java</file>
			<file type="M">org.apache.camel.component.netty.http.rest.RestNettyHttpPojoInOutTest.java</file>
			<file type="M">org.apache.camel.component.netty.http.DefaultContextPathMatcher.java</file>
			<file type="M">org.apache.camel.component.netty.http.handlers.HttpServerMultiplexChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty.http.rest.RestPathMatchingTest.java</file>
			<file type="M">org.apache.camel.component.servlet.rest.RestServletPojoInOutTest.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.http.HttpServletResolveConsumerStrategy.java</file>
			<file type="M">org.apache.camel.component.jetty.rest.RestJettyPojoInOutTest.java</file>
			<file type="M">org.apache.camel.component.http.CamelServlet.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">7952</link>
		</links>
	</bug>
	<bug id="7890" opendate="2014-10-06 14:32:28" fixdate="2014-10-11 05:59:15" resolution="Fixed">
		<buginformation>
			<summary>XmlConverter.toSAXSourceFromStream does not set setNamespaceAware</summary>
			<description>XmlConverter.toSAXSourceFromStream does not set


sfactory.setNamespaceAware(true);

</description>
			<version>2.14.0</version>
			<fixedVersion>2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.jaxp.XmlConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="7900" opendate="2014-10-09 09:46:27" fixdate="2014-10-11 06:21:28" resolution="Fixed">
		<buginformation>
			<summary>hdfs2 - chunkSize not honored</summary>
			<description>camel-hdfs2 component exposes chunkSize param, but that value is not correctly used in 
https://github.com/apache/camel/blob/master/components/camel-hdfs2/src/main/java/org/apache/camel/component/hdfs2/HdfsFileType.java#L79
and the constant value:


public static final int DEFAULT_BUFFERSIZE = 4096;


always overrides it.</description>
			<version>2.14.0</version>
			<fixedVersion>2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.hdfs.HdfsFileType.java</file>
			<file type="M">org.apache.camel.component.hdfs2.HdfsFileType.java</file>
		</fixedFiles>
	</bug>
	<bug id="7888" opendate="2014-10-06 10:59:40" fixdate="2014-10-11 07:08:41" resolution="Fixed">
		<buginformation>
			<summary>HL7Decoder leaks memory</summary>
			<description>Under constant load (i.e. Mina session never idles out), the HL7Decoder leaks memory. In fact, all received messages are appended to Mina&amp;amp;apos;s IOBuffer, which leads to OOME after some time.</description>
			<version>2.12.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.hl7.HL7MLLPCodecTest.java</file>
			<file type="M">org.apache.camel.component.hl7.HL7RouteTest.java</file>
			<file type="M">org.apache.camel.component.hl7.HL7MLLPCodecLongTest.java</file>
			<file type="M">org.apache.camel.component.hl7.HL7MLLPCodecStandAndEndBytesTest.java</file>
			<file type="M">org.apache.camel.component.hl7.HL7Converter.java</file>
			<file type="M">org.apache.camel.component.hl7.HL7MLLPCodecPlainStringTest.java</file>
			<file type="M">org.apache.camel.component.hl7.HL7MLLPEncoder.java</file>
			<file type="M">org.apache.camel.component.hl7.HL7MLLPDecoder.java</file>
		</fixedFiles>
	</bug>
	<bug id="7917" opendate="2014-10-15 17:49:34" fixdate="2014-10-15 20:01:47" resolution="Fixed">
		<buginformation>
			<summary>camel-jsch unit tests are failing</summary>
			<description>A known issue in jsch 0.1.50:

org.apache.camel.CamelExecutionException: Exception occurred during execution on the exchange: Exchange[Message: Bye World]
	at org.apache.camel.util.ObjectHelper.wrapCamelExecutionException(ObjectHelper.java:1379)
	at org.apache.camel.util.ExchangeHelper.extractResultBody(ExchangeHelper.java:622)
	at org.apache.camel.impl.DefaultProducerTemplate.extractResultBody(DefaultProducerTemplate.java:467)
	at org.apache.camel.impl.DefaultProducerTemplate.extractResultBody(DefaultProducerTemplate.java:463)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBodyAndHeader(DefaultProducerTemplate.java:165)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBodyAndHeader(DefaultProducerTemplate.java:159)
	at org.apache.camel.component.jsch.ScpSimpleProduceTest.testScpSimpleSubPathProduce(ScpSimpleProduceTest.java:58)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)
Caused by: java.lang.NullPointerException
	at com.jcraft.jsch.Session.checkHost(Session.java:802)
	at com.jcraft.jsch.Session.connect(Session.java:342)
	at org.apache.camel.component.jsch.ScpOperations.createSession(ScpOperations.java:249)
	at org.apache.camel.component.jsch.ScpOperations.connect(ScpOperations.java:181)
	at org.apache.camel.component.file.remote.RemoteFileProducer.connectIfNecessary(RemoteFileProducer.java:189)
	at org.apache.camel.component.file.remote.RemoteFileProducer.recoverableConnectIfNecessary(RemoteFileProducer.java:181)
	at org.apache.camel.component.file.remote.RemoteFileProducer.preWriteCheck(RemoteFileProducer.java:113)
	at org.apache.camel.component.file.GenericFileProducer.processExchange(GenericFileProducer.java:114)
	at org.apache.camel.component.file.remote.RemoteFileProducer.process(RemoteFileProducer.java:49)
	at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.processor.UnitOfWorkProducer.process(UnitOfWorkProducer.java:73)
	at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:375)
	at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:343)
	at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:233)
	at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:343)
	at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:184)
	at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:124)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBodyAndHeader(DefaultProducerTemplate.java:163)
	... 31 more


</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jsch.ScpServerTestSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="7916" opendate="2014-10-15 11:19:43" fixdate="2014-10-17 12:12:51" resolution="Fixed">
		<buginformation>
			<summary>OsgiServiceRegistry forces name property</summary>
			<description>Several components does search the registry by calling findByTypeWithName. This method needs in OsgiServiceRegistry that every service has a name property which is not forced by spec and therefor optional. Maybe add a different "name" in those cases.</description>
			<version>2.14.0</version>
			<fixedVersion>2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.core.osgi.OsgiServiceRegistry.java</file>
		</fixedFiles>
	</bug>
	<bug id="7909" opendate="2014-10-14 01:43:01" fixdate="2014-10-20 02:14:47" resolution="Fixed">
		<buginformation>
			<summary>camel-netty-http consumer need to close the connection if the response connection header is close</summary>
			<description>Current Netty Http Consumer decided if it need to close connection by checking the request connection header. But if the response connection header is &amp;amp;apos;close&amp;amp;apos;,  the netty http consumer need to close the connection at the same time.</description>
			<version>2.13.2</version>
			<fixedVersion>2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.handlers.ServerResponseFutureListener.java</file>
			<file type="M">org.apache.camel.component.netty4.http.handlers.HttpServerChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty4.NettyProducer.java</file>
			<file type="M">org.apache.camel.component.netty4.http.DefaultNettyHttpBinding.java</file>
			<file type="M">org.apache.camel.component.netty4.NettyHelper.java</file>
			<file type="M">org.apache.camel.component.netty.http.DefaultNettyHttpBinding.java</file>
			<file type="M">org.apache.camel.component.netty.handlers.ServerResponseFutureListener.java</file>
			<file type="M">org.apache.camel.component.netty.NettyProducer.java</file>
			<file type="M">org.apache.camel.component.netty.NettyHelper.java</file>
			<file type="M">org.apache.camel.component.netty.http.handlers.HttpServerChannelHandler.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8193</link>
		</links>
	</bug>
	<bug id="7910" opendate="2014-10-14 02:19:49" fixdate="2014-10-20 02:15:36" resolution="Fixed">
		<buginformation>
			<summary>Netty {Client|Server}ChannelHandler need to pass the close and open event around</summary>
			<description>If add other handler interesting about close and open event and they are set behind the netty  
{Client|Server}ChannelHandler, they cannot not get the event as current netty  {Client|Server}
ChannelHandler  doesn&amp;amp;apos;t pass these event around.</description>
			<version>2.12.4</version>
			<fixedVersion>2.12.5, 2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.handlers.ClientChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty.handlers.ServerChannelHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="7883" opendate="2014-09-30 22:34:40" fixdate="2014-10-20 02:45:08" resolution="Fixed">
		<buginformation>
			<summary>XSD decoding bad guess in Validator</summary>
			<description>Validator component does not take imported XSD encoding into account when validating XML. That may lead to validation errors if an imported XSD is ISO-8859-1 encoded and containing non ASCII caracters, even though that XSD declares its encoding correctly in its XML prolog.</description>
			<version>2.13.2</version>
			<fixedVersion>2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.validator.ValidatorIncludeEncodingRouteTest.java</file>
			<file type="M">org.apache.camel.component.validator.DefaultLSResourceResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="7931" opendate="2014-10-20 07:06:15" fixdate="2014-10-20 08:35:51" resolution="Fixed">
		<buginformation>
			<summary>JCR need to support multi-valued property</summary>
			<description>Regarding to the issue at Camel User Forum as [[camel-jcr] The trouble about the JCR multi-valued property when using JCR_GET_BY_ID](http://camel.465427.n5.nabble.com/camel-jcr-The-trouble-about-the-JCR-multi-valued-property-when-using-JCR-GET-BY-ID-td5757029.html).  Here is the fix from https://github.com/apache/camel/pull/287.patch  from  charlee. </description>
			<version>2.13.2</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jcr.JcrGetNodeByIdTest.java</file>
			<file type="M">org.apache.camel.component.jcr.JcrProducer.java</file>
			<file type="M">org.apache.camel.component.jcr.JcrNodePathCreationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7935" opendate="2014-10-21 06:36:32" fixdate="2014-10-27 09:03:33" resolution="Fixed">
		<buginformation>
			<summary>JcloudsPayloadConverter.toPayload(InputStream) cannot deal with FileInputStreamCache</summary>
			<description>StackOverflowError if body is FileInputStreamCache.
http://camel.465427.n5.nabble.com/camel-jclouds-StackOverflowError-if-body-is-FileInputStreamCache-tp5757810.html </description>
			<version>2.13.2</version>
			<fixedVersion>2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jclouds.JcloudsPayloadConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="7966" opendate="2014-10-27 09:02:40" fixdate="2014-10-27 09:10:39" resolution="Fixed">
		<buginformation>
			<summary>Doesn&amp;apos;t set the blank or empty string to the mail recipients</summary>
			<description>Here is the user complain in the mailing list.


I recently had a production issue where there was an exception thrown when 
the CC or the BCC headers were set to "": 

com.sun.mail.smtp.SMTPAddressFailedException: 554 5.1.1 Invalid recipient address 

</description>
			<version>2.13.2</version>
			<fixedVersion>2.13.3, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="7971" opendate="2014-10-27 13:19:17" fixdate="2014-10-28 04:35:20" resolution="Fixed">
		<buginformation>
			<summary>Setting bean reference in &lt;restConfiguration&gt; fails with IllegalFormatWidthException</summary>
			<description>I am trying to set a custom HTTP binding on the netty4-http endpoint created for the REST-DSL routes. The &amp;amp;apos;#&amp;amp;apos; in the bean ref, URL encoded as %23, makes the endpoint generation fail because it is interpreted by the string formatter.


&amp;lt;restConfiguration component="netty4-http" scheme="http" host="{{rest.host}}" port="{{rest.port}}" bindingMode="json"&amp;gt;
	&amp;lt;endpointProperty key="nettyHttpBinding" value="#noStackTraceHTTPBinding"/&amp;gt;
&amp;lt;/restConfiguration&amp;gt;

&amp;lt;rest path="/base" produces="application/json"&amp;gt;
	&amp;lt;get uri="/path"&amp;gt;
		&amp;lt;to uri="direct:myroute" /&amp;gt;
	&amp;lt;/get&amp;gt;
&amp;lt;/rest&amp;gt;


This configuration results in the following template string (NettyHttpComponent.java line 279):
netty4-http:%s://%s:%s/%s?httpMethodRestrict=%s?nettyHttpBinding=%23noStackTraceHTTPBinding
The main problem is the hash mark encoded as "%23" and interpreted by the string formatter. Also, the second &amp;amp;apos;?&amp;amp;apos; in the URL probably should be a &amp;amp;apos;&amp;amp;&amp;amp;apos;.
Full stacktrace:


java.util.IllegalFormatWidthException: 23
	at java.util.Formatter$FormatSpecifier.checkText(Formatter.java:2996)[:1.7.0_60]
	at java.util.Formatter$FormatSpecifier.&amp;lt;init&amp;gt;(Formatter.java:2688)[:1.7.0_60]
	at java.util.Formatter.parse(Formatter.java:2528)[:1.7.0_60]
	at java.util.Formatter.format(Formatter.java:2469)[:1.7.0_60]
	at java.util.Formatter.format(Formatter.java:2423)[:1.7.0_60]
	at java.lang.String.format(String.java:2790)[:1.7.0_60]
	at org.apache.camel.component.netty4.http.NettyHttpComponent.createConsumer(NettyHttpComponent.java:279)
	at org.apache.camel.component.rest.RestEndpoint.createConsumer(RestEndpoint.java:167)
	at org.apache.camel.impl.EventDrivenConsumerRoute.addServices(EventDrivenConsumerRoute.java:65)
	at org.apache.camel.impl.DefaultRoute.onStartingServices(DefaultRoute.java:80)
	at org.apache.camel.impl.RouteService.warmUp(RouteService.java:134)
	at org.apache.camel.impl.DefaultCamelContext.doWarmUpRoutes(DefaultCamelContext.java:2379)
	at org.apache.camel.impl.DefaultCamelContext.safelyStartRouteServices(DefaultCamelContext.java:2309)
	at org.apache.camel.impl.DefaultCamelContext.doStartOrResumeRoutes(DefaultCamelContext.java:2091)
	at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:1951)
	at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:1777)
	at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:61)
	at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:1745)
	at org.apache.camel.blueprint.BlueprintCamelContext.start(BlueprintCamelContext.java:177)
	at org.apache.camel.blueprint.BlueprintCamelContext.maybeStart(BlueprintCamelContext.java:209)
	at org.apache.camel.blueprint.BlueprintCamelContext.serviceChanged(BlueprintCamelContext.java:147)
	at org.apache.felix.framework.util.EventDispatcher.invokeServiceListenerCallback(EventDispatcher.java:932)
	at org.apache.felix.framework.util.EventDispatcher.fireEventImmediately(EventDispatcher.java:793)
	at org.apache.felix.framework.util.EventDispatcher.fireServiceEvent(EventDispatcher.java:543)
	at org.apache.felix.framework.Felix.fireServiceEvent(Felix.java:4419)
	at org.apache.felix.framework.Felix.registerService(Felix.java:3423)
	at org.apache.felix.framework.BundleContextImpl.registerService(BundleContextImpl.java:346)
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.registerService(BlueprintContainerImpl.java:452)
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.doRun(BlueprintContainerImpl.java:387)
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.run(BlueprintContainerImpl.java:269)
	at org.apache.aries.blueprint.container.BlueprintExtender.createContainer(BlueprintExtender.java:276)
	at org.apache.aries.blueprint.container.BlueprintExtender.createContainer(BlueprintExtender.java:245)
	at org.apache.aries.blueprint.container.BlueprintExtender.modifiedBundle(BlueprintExtender.java:235)
	at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$Tracked.customizerModified(BundleHookBundleTracker.java:500)
	at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$Tracked.customizerModified(BundleHookBundleTracker.java:433)
	at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$AbstractTracked.track(BundleHookBundleTracker.java:725)
	at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$Tracked.bundleChanged(BundleHookBundleTracker.java:463)
	at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$BundleEventHook.event(BundleHookBundleTracker.java:422)
	at org.apache.felix.framework.util.SecureAction.invokeBundleEventHook(SecureAction.java:1103)
	at org.apache.felix.framework.util.EventDispatcher.createWhitelistFromHooks(EventDispatcher.java:695)
	at org.apache.felix.framework.util.EventDispatcher.fireBundleEvent(EventDispatcher.java:483)
	at org.apache.felix.framework.Felix.fireBundleEvent(Felix.java:4403)
	at org.apache.felix.framework.Felix.startBundle(Felix.java:2092)
	at org.apache.felix.framework.BundleImpl.start(BundleImpl.java:955)
	at org.apache.felix.framework.BundleImpl.start(BundleImpl.java:942)
	at org.apache.karaf.features.internal.FeaturesServiceImpl.startBundle(FeaturesServiceImpl.java:477)
	at org.apache.karaf.features.internal.FeaturesServiceImpl.installFeatures(FeaturesServiceImpl.java:435)
	at org.apache.karaf.features.internal.FeaturesServiceImpl.installFeature(FeaturesServiceImpl.java:375)
	at org.apache.karaf.features.internal.FeaturesServiceImpl.installFeature(FeaturesServiceImpl.java:364)
	at Proxy486edb88_52c2_40bf_8539_fb7a444aafe1.installFeature(Unknown Source)
	at org.apache.karaf.features.command.InstallFeatureCommand.doExecute(InstallFeatureCommand.java:67)
	at org.apache.karaf.features.command.FeaturesCommandSupport.doExecute(FeaturesCommandSupport.java:38)
	at org.apache.karaf.shell.console.AbstractAction.execute(AbstractAction.java:33)[25:org.apache.karaf.shell.console:3.0.2]
	at org.apache.karaf.shell.console.OsgiCommandSupport.execute(OsgiCommandSupport.java:39)[25:org.apache.karaf.shell.console:3.0.2]
	at org.apache.karaf.shell.commands.basic.AbstractCommand.execute(AbstractCommand.java:33)[25:org.apache.karaf.shell.console:3.0.2]
	at Proxy4496acc0_5450_4cc1_881a_14668e65e5a7.execute(Unknown Source)[:]
	at Proxy4496acc0_5450_4cc1_881a_14668e65e5a7.execute(Unknown Source)[:]
	at org.apache.felix.gogo.runtime.CommandProxy.execute(CommandProxy.java:78)[25:org.apache.karaf.shell.console:3.0.2]
	at org.apache.felix.gogo.runtime.Closure.executeCmd(Closure.java:477)[25:org.apache.karaf.shell.console:3.0.2]
	at org.apache.felix.gogo.runtime.Closure.executeStatement(Closure.java:403)[25:org.apache.karaf.shell.console:3.0.2]
	at org.apache.felix.gogo.runtime.Pipe.run(Pipe.java:108)[25:org.apache.karaf.shell.console:3.0.2]
	at org.apache.felix.gogo.runtime.Closure.execute(Closure.java:183)[25:org.apache.karaf.shell.console:3.0.2]
	at org.apache.felix.gogo.runtime.Closure.execute(Closure.java:120)[25:org.apache.karaf.shell.console:3.0.2]
	at org.apache.felix.gogo.runtime.CommandSessionImpl.execute(CommandSessionImpl.java:92)
	at org.apache.karaf.shell.console.impl.jline.ConsoleImpl.run(ConsoleImpl.java:203)
	at org.apache.karaf.shell.console.impl.jline.LocalConsoleManager$2$1$1.run(LocalConsoleManager.java:115)
	at java.security.AccessController.doPrivileged(Native Method)[:1.7.0_60]
	at org.apache.karaf.jaas.modules.JaasHelper.doAs(JaasHelper.java:57)[26:org.apache.karaf.jaas.modules:3.0.2]
	at org.apache.karaf.shell.console.impl.jline.LocalConsoleManager$2$1.run(LocalConsoleManager.java:108)[25:org.apache.karaf.shell.console:3.0.2]

</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.RestRestletGetTest.java</file>
			<file type="M">org.apache.camel.component.restlet.RestletComponent.java</file>
			<file type="M">org.apache.camel.component.jetty.rest.RestJettyGetTest.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.servlet.rest.RestServletGetTest.java</file>
			<file type="M">org.apache.camel.component.servlet.ServletComponent.java</file>
			<file type="M">org.apache.camel.component.netty.http.rest.RestNettyHttpGetTest.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.netty4.http.rest.RestNettyHttpGetTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7981" opendate="2014-10-29 06:51:17" fixdate="2014-10-29 08:14:23" resolution="Fixed">
		<buginformation>
			<summary>JMX - Routes with transacted does not enlist processor mbeans</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Not-all-processors-are-listed-in-JMX-preventing-detailed-route-statistics-profiling-tp5757634p5758257.html
Routes with &amp;lt; transacted &amp;gt; does not enlist mbeans under processor, but you have mbeans in routes / consumers etc.</description>
			<version>2.13.2</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ServiceHelper.java</file>
			<file type="M">org.apache.camel.processor.RedeliveryErrorHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="7967" opendate="2014-10-27 09:03:33" fixdate="2014-10-30 02:25:37" resolution="Fixed">
		<buginformation>
			<summary>camel-rabbitmq logging exceptions as debug</summary>
			<description>Connecting to RabbitMQ using camel-rabbitmq I&amp;amp;apos;ve noticed that no ERROR is logged if the component cannot connect, the exceptions are handled and logged as DEBUG. 
This is a bit inconvenient as logging all DEBUG messages for the component fills up our logs, in production we usually set INFO as threshold. </description>
			<version>2.14.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7973" opendate="2014-10-27 15:02:10" fixdate="2014-10-30 09:09:35" resolution="Fixed">
		<buginformation>
			<summary>CircuitBreakerLoadBalancer fails on async processors</summary>
			<description>The CircuitBreakerLoadBalancer works fine on direct synchronous processor, but it seems to not behave as expected in case of async processor.
To reproduce the error, it&amp;amp;apos;s enough to add a .threads(1) before the mock processor in the CircuitBreakerLoadBalancerTest routeBuilder configuration.
This misbehaviour seems to be related to the use of the AsyncProcessorConverterHelper to force any processor to behave like asynchronous. 
I&amp;amp;apos;m going to propose a patch with the failing test and a proposal of solution.
EDIT:
the patch contains the fix also to other unexpected behaviour of the CircuitBreaker.
The second problem addressed is that, after the opening of the circuit, the RejectedExecutionException raised by the circuit breaker is set in the Exchange, but it doesn&amp;amp;apos;t return. This cause the processor will receive the Exchange even if the circuit is open. In this case also, if the CircuitBreaker is instructed to react only to specific Exception, it will close the circuit after the following request, because the raised exception would be a RejectedExecutionException instead of the one specified in the configuration.</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.CircuitBreakerLoadBalancerTest.java</file>
			<file type="M">org.apache.camel.processor.loadbalancer.CircuitBreakerLoadBalancer.java</file>
		</fixedFiles>
		<links>
			<link type="Incorporates" description="is part of">5539</link>
		</links>
	</bug>
	<bug id="7977" opendate="2014-10-28 07:41:49" fixdate="2014-10-31 09:28:28" resolution="Fixed">
		<buginformation>
			<summary>sftp compression option is not set rightly</summary>
			<description>The setting of sftp compression should skip the space, according to the user report.


session.setConfig("compression.s2c", "zlib@openssh.com, zlib, none");
session.setConfig("compression.c2s", "zlib@openssh.com, zlib, none");

</description>
			<version>2.13.2</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.SftpOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="7989" opendate="2014-11-01 08:06:34" fixdate="2014-11-01 10:19:13" resolution="Fixed">
		<buginformation>
			<summary>FileIdempotentRepository should create the file store on startup</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Problems-configuring-FileIdempotentRepository-tp5758212.html
The file store should be created on startup so the file store is always available.</description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.FileIdempotentConsumerCreateRepoTest.java</file>
			<file type="M">org.apache.camel.processor.idempotent.FileIdempotentRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="7988" opendate="2014-11-01 08:02:50" fixdate="2014-11-01 10:19:23" resolution="Fixed">
		<buginformation>
			<summary>file consumer - Should call abort in case read lock cannot be acquired if exception was thrown</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Possible-issue-with-FileLockExclusiveReadLockStrategy-leaves-orphaned-camelLock-file-tp5758142.html
This could cause a .camelLock orphaned file to be there causing the file to not be eligible for consuming on next poll.</description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.strategy.FileLockExclusiveReadLockStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="7990" opendate="2014-11-01 14:27:44" fixdate="2014-11-01 14:56:54" resolution="Fixed">
		<buginformation>
			<summary>IdempotentConsumer - If no messageId should allow Camel error handler to react</summary>
			<description>See SO
http://stackoverflow.com/questions/26453348/camel-onexception-doesnt-catch-nomessageidexception-of-idempotentconsumer
The idempotent consumer should set the exchange on the exchange and invoke the callback, that is an internal routing engine bug in the implementation of that eip.</description>
			<version>2.14.0</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.idempotent.IdempotentConsumer.java</file>
			<file type="M">org.apache.camel.processor.IdempotentConsumerNoMessageIdTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7986" opendate="2014-10-31 14:26:28" fixdate="2014-11-01 14:57:12" resolution="Fixed">
		<buginformation>
			<summary>Route disappears with routeId set to "route1"</summary>
			<description>With below route configuration with routeId defined as route1, route2 and intentionally omitted routeId for the 3rd route, Camel will auto-generate a routeId with format as route + count for you if you didn&amp;amp;apos;t define it. This seems to cause some routes to be missed.
Route definitions:


 from("direct:start1")
     .routeId("route1")
     .log("route1: ${body}");

 from("direct:start2")
      .routeId("route2")
      .log("route2: ${body}");

 from("direct:start3") // no route id!
      .log("route3: ${body}");


Testing:


 ProducerTemplate template = context.createProducerTemplate();
 template.sendBody("direct:start1", "World!");
 template.sendBody("direct:start2", "World!");


This leads to following exception:

    Caused by: org.apache.camel.component.direct.DirectConsumerNotAvailableException: No consumers available on endpoint: Endpoint[direct://start1]
If the direct:start3 route is deleted or the ID "route1" is renamed, then everything works as expected. 
See http://stackoverflow.com/questions/26646881/route-is-not-detected-when-route-id-is-not-assigned-does-camelcontext-loses-the/26673144#26673144</description>
			<version>2.14.0</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.RouteDefinitionHelper.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="7968" opendate="2014-10-27 10:38:41" fixdate="2014-11-02 08:41:32" resolution="Fixed">
		<buginformation>
			<summary>Container has undefined concurrency behaviour</summary>
			<description>The implementation of Container.Instance is not ThreadSafe. It is also not defined what happens when multiple Containers race on the singleton.
Instead of using a Container singleton approach. It might be better to have a singleton ContainerRegistry that can handle concurrent/multiple Containers</description>
			<version>2.14.0</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spi.Container.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8000</link>
		</links>
	</bug>
	<bug id="7994" opendate="2014-11-03 21:32:05" fixdate="2014-11-04 03:06:23" resolution="Fixed">
		<buginformation>
			<summary>SJMSComponent effectively ignores setConnectionCount()</summary>
			<description>SJMSComponent effectively ignores setConnectionCount()
This is because the JmsProducer, by default, pre-populates sessions+producers on Producer.doStart(), which is called by the CamelContext in a single thread and the way the ConnectionFactoryResource is configured, it returns the most recently idle connection (So really it always returns the first connection opened). So all sessions being pre-populated by all SJMS endpoints always use the same single connection.
This patch attached makes the ConnectionFactoryResource effectively return connections in a round-robbin manor. Unit test is included.
This is important because TCP has a certain overhead per socket which makes it impossible to achieve much more than 6k~ messages a second, regardless of the CPU and IO resources available to a broker. To fully utilize a broker multiple connections must be opened.
This is also important if your ConnectionFactory represent a cluster (Like in the case of HornetQ), where subsequent connections from the factory are balanced across nodes in the cluster.</description>
			<version>2.14.0</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sjms.jms.ConnectionFactoryResource.java</file>
			<file type="M">org.apache.camel.component.sjms.SjmsProducer.java</file>
			<file type="M">org.apache.camel.component.sjms.jms.ConnectionFactoryResourceTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7992" opendate="2014-11-03 13:43:16" fixdate="2014-11-05 12:16:24" resolution="Fixed">
		<buginformation>
			<summary>Container lifecycle event method invoked outside of extension observer method invocation</summary>
			<description>camel-cdi does no longer work on wildfly-9.0


org.jboss.weld.exceptions.IllegalStateException: WELD-000143: Container lifecycle event method invoked outside of extension observer method invocation.
	at org.jboss.weld.bootstrap.events.ContainerEvent.checkWithinObserverNotification(ContainerEvent.java:61)
	at org.jboss.weld.bootstrap.events.ProcessAnnotatedTypeImpl.getAnnotatedType(ProcessAnnotatedTypeImpl.java:56)
	at org.apache.camel.cdi.internal.CamelContextConfig.configure(CamelContextConfig.java:47)
	at org.apache.camel.cdi.internal.CamelContextBean.configureCamelContext(CamelContextBean.java:131)
	at org.apache.camel.cdi.internal.CamelExtension.startConsumeBeans(CamelExtension.java:231)


To reproduce, build: https://github.com/tdiesler/wildfly-camel/tree/2.0
Cross Issue: https://issues.jboss.org/browse/WFLY-4046</description>
			<version>2.14.0</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.cdi.internal.CamelContextConfig.java</file>
			<file type="M">org.apache.camel.cdi.internal.CamelExtension.java</file>
		</fixedFiles>
	</bug>
	<bug id="7224" opendate="2014-02-19 11:44:25" fixdate="2014-11-07 03:14:06" resolution="Fixed">
		<buginformation>
			<summary>camel-smpp - fails to correctly send messages that require UCS-2 encoding</summary>
			<description>If I try to send a string without any config options or headers to indicate alphabet/data coding/encoding, it appears to be sent using an 8 bit character set even if a 16 bit UCS-2 encoding is required.
If I try to set CamelSmppAlphabet=-1 (for unknown) as a header, an invalid message is sent to the SMPP peer and it is rejected with SMPP error code 00000401
If I try to set alphabet=-1 in the endpoint config though and if I also set CamelSmppDataCoding=8 then it correctly sends a UCS-2 message.
Looking at the code (particularly the method SmppSmCommand.determineCharset()), it seems that it can ONLY send UCS-2 if alphabet == UNKNOWN_ALPHABET.  Using the value UNKNOWN_ALPHABET (-1) as a header triggers the problem with the SMPP peer so I can only set that value in the endpoint config.  This determineCharset() method should also recognise alphabet == ALPHA_UCS2</description>
			<version>2.12.2</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.smpp.SmppSmCommand.java</file>
		</fixedFiles>
	</bug>
	<bug id="8030" opendate="2014-11-11 08:11:19" fixdate="2014-11-11 08:49:21" resolution="Fixed">
		<buginformation>
			<summary>camel-netty need to release the thread pool when shutdown</summary>
			<description>CAMEL-7915 introduced a side effect that doesn&amp;amp;apos;t shutdown the thread pool when the netty producer is shutdown.
We need to clean up these thread when shutting down the Netty endpoint.</description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.NettyWorkerPoolBuilder.java</file>
			<file type="M">org.apache.camel.component.netty.NettyProducer.java</file>
			<file type="M">org.apache.camel.component.netty.NettyClientBossPoolBuilder.java</file>
			<file type="M">org.apache.camel.component.netty.NettyServerBossPoolBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8094</link>
		</links>
	</bug>
	<bug id="8033" opendate="2014-11-11 10:24:39" fixdate="2014-11-11 10:55:22" resolution="Fixed">
		<buginformation>
			<summary>Exchange Leak Caused By pollEnrich</summary>
			<description>There can be a potential issue in PollEnricher as it should use a try .. catch to deal with any runtime exceptions that may be thrown from the polling consumer api.
This is mandated by the async routine engine.</description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.PollEnricher.java</file>
		</fixedFiles>
	</bug>
	<bug id="8032" opendate="2014-11-11 10:24:18" fixdate="2014-11-11 13:13:04" resolution="Fixed">
		<buginformation>
			<summary>FileUtil leaks FileInputStream when renameFile fails due to permission issue</summary>
			<description>I have a simple camel route:


&amp;lt;camelContext xmlns="http://camel.apache.org/schema/spring"&amp;gt;
    &amp;lt;route&amp;gt;
        &amp;lt;from uri="file:C:/tmp/data/in?include=.*$&amp;amp;amp;move=C:/tmp/data/done/${file:onlyname}-${exchangeId}" /&amp;gt;
        &amp;lt;setHeader headerName="CamelFileName"&amp;gt;
            &amp;lt;simple&amp;gt;${file:onlyname}-${exchangeId}&amp;lt;/simple&amp;gt;
        &amp;lt;/setHeader&amp;gt;
        &amp;lt;to uri="file:C:/tmp/data/out" /&amp;gt;
    &amp;lt;/route&amp;gt;
&amp;lt;/camelContext&amp;gt;


If the destination folder "C:/tmp/data/done/" for the move operation does not allow writing, then the file dropped to the "C:/tmp/data/in/" folder will be repeatedly polled, processed and rolled back due to "Access is denied" exception.
Even if we fix the permission issue on the folder "C:/tmp/data/done/" to allow writing, the problem still persists and above endless cycle continues. However the reason for the issue will be a bit different now. It is caused by deletion failure to the file from "C:/tmp/data/in/" folder after successful FileUtil.renameFile() operation due to fact that something is still holding the file handle. 
The root cause is in the function FileUtil.copyFile():


public static void copyFile(File from, File to) throws IOException {
        FileChannel in = new FileInputStream(from).getChannel();
        FileChannel out = new FileOutputStream(to).getChannel();
        try {
            if (LOG.isTraceEnabled()) {
                LOG.trace("Using FileChannel to copy from: " + in + " to: " + out);
            }

            long size = in.size();
            long position = 0;
            while (position &amp;lt; size) {
                position += in.transferTo(position, BUFFER_SIZE, out);
            }
        } finally {
            IOHelper.close(in, from.getName(), LOG);
            IOHelper.close(out, to.getName(), LOG);
        }
    }


If the destination folder "C:/tmp/data/done/" for move operation is not allowed for writing, the creation of the FileOutputStream will throw an exception straight away. However, because both FileInputStream and FileOutputStream are created outside the try{}...finally{} block, the FileInputStream is never closed. It still holds handle to the file and caused FileSystem unable to delete it. Therefore caused the whole route to fail. 
The solution is quite simple, we just need to create the Input/Output streams inside try{}...finally{} loop to make sure that the Input/Output streams get closed if something happens during creating of these objects.</description>
			<version>2.12.3</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.FileUtil.java</file>
		</fixedFiles>
	</bug>
	<bug id="8035" opendate="2014-11-11 17:05:52" fixdate="2014-11-13 01:21:29" resolution="Fixed">
		<buginformation>
			<summary>CXFRS consumer should set Exchange&amp;apos;s charset name, if content type provides one</summary>
			<description>This is the JAXRS counterpart to https://issues.apache.org/jira/browse/CAMEL-6188</description>
			<version>2.10.7</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.DefaultCxfRsBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="7662" opendate="2014-08-05 08:36:05" fixdate="2014-11-17 08:01:39" resolution="Fixed">
		<buginformation>
			<summary>MQTTProducerTest fails once enables it</summary>
			<description>MQTTProducerTest fails once you enable this testcase. This is disabled here:
https://github.com/apache/camel/blob/master/components/camel-mqtt/pom.xml#L84
Although this may be a known issue as it&amp;amp;apos;s explicitly disabled, I&amp;amp;apos;m filing this anyway since I couldn&amp;amp;apos;t find any corresponding JIRA.
It fails with different error on 2.12.2 and current upstream master, but both case show the producer can&amp;amp;apos;t send messages through the MQTT producer correctly. I think there is an issue in camel-mqtt since I hit same issue in our application (https://issues.jboss.org/browse/SWITCHYARD-2221), but even if the problem is in the testcase, it still needs to be replaced with appropriate testcase to verify MQTT producer works correctly.</description>
			<version>2.12.2</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mqtt.MQTTEndpoint.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="is depended upon by">7697</link>
		</links>
	</bug>
	<bug id="8062" opendate="2014-11-19 07:01:29" fixdate="2014-11-19 07:03:46" resolution="Fixed">
		<buginformation>
			<summary>camel-rx - EndpointSubscriber does not call unsubscribe to stop the consumer</summary>
			<description>When rx is done with the subscription it does not trigger the unsubscribe callback so we can stop the consumer.</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.rx.support.EndpointSubscription.java</file>
			<file type="M">org.apache.camel.rx.support.EndpointSubscribeFunc.java</file>
		</fixedFiles>
	</bug>
	<bug id="8049" opendate="2014-11-14 12:34:28" fixdate="2014-11-19 07:36:13" resolution="Fixed">
		<buginformation>
			<summary>DefaultRestletBinding can not deal with multi-valued HTTP request parameters</summary>
			<description>Multi-valued HTTP request parameters are a common practice yet, with the provided binding, Camel Restlet component can not deal with them.
In DefaultRestletBinding, we can see the following problematic code:


public void populateRestletRequestFromExchange(Request request, Exchange exchange) {
...
     form.add(key, value.toString());
...
}


where the value is always treated as a String, even though it can be a Collection.
And similarly:


public void populateExchangeFromRestletRequest(Request request, Response response, Exchange exchange) throws Exception {
...
     for (Map.Entry&amp;lt;String, String&amp;gt; entry : form.getValuesMap().entrySet()) {
          ...
     }
...
}


where getValuesMap() effectively disregards all duplicate key names.</description>
			<version>2.14.0</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.DefaultRestletBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="8063" opendate="2014-11-19 12:28:20" fixdate="2014-11-20 09:05:07" resolution="Fixed">
		<buginformation>
			<summary>Persistent tail tracking picks random tail tracker from mongoDB collection</summary>
			<description>There is a bug the method "initialize" in "MongoDbTailTrackingManager.java": 
...
 if (trackingObj == null) 
{
            dbCol.insert(filter, WriteConcern.SAFE);
            trackingObj = dbCol.findOne();
 }
...
If no tail tracking object exists in the database, a new one will be inserted (that&amp;amp;apos;s okay), but the query "dbCol.findOne()" fetches ANY tail tracking object from the database (and not the one we&amp;amp;apos;ve just inserted). 
In my oppinition, this is a bug and should be corrected like this: 
...
DBObject filter = new BasicDBObject("persistentId", config.persistentId);
trackingObj = dbCol.findOne(filter);
 if (trackingObj == null) 
{
            dbCol.insert(filter, WriteConcern.SAFE);
            trackingObj = dbCol.findOne(filter);
 }

(not tested).
A workaround can be implemented by putting each persistent tail tracker in it&amp;amp;apos;s own collection, so I marked this issue as "minor".
More details: http://camel.465427.n5.nabble.com/MongoDB-Persistent-tail-tracking-with-concurrent-tailable-consumers-td5759131.html
Best regards,
Joerg Peschke</description>
			<version>2.13.1</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mongodb.MongoDbTailTrackingManager.java</file>
		</fixedFiles>
	</bug>
	<bug id="7922" opendate="2014-10-16 20:37:17" fixdate="2014-11-20 09:11:42" resolution="Fixed">
		<buginformation>
			<summary>MQTT endpoint misses QoS &gt; 0 messages due to startup timing issue</summary>
			<description>When the MQTT Endpoint is started the MQTT connection is immediately established, causing an immediate influx of persisted messages (put on the topic when the client was not available). 
Issue is that at this point, most likely no consumers are available yet to process these messages.
Receiving a PUBLISH message
Publish message are received without any consumers. Result : msg with QoS &amp;gt; 0 that were put on the topic while the client was not connected are never processed.

Daemon Thread [hawtdispatch-DEFAULT-3] (Suspended (breakpoint at line 815 in CallbackConnection))	
	CallbackConnection.toReceiver(PUBLISH) line: 815	
	CallbackConnection.processFrame(MQTTFrame) line: 732	
	CallbackConnection.access$1500(CallbackConnection, MQTTFrame) line: 51	
	CallbackConnection$6.onTransportCommand(Object) line: 392	
	TcpTransport.drainInbound() line: 709	
	TcpTransport$6.run() line: 588	
	NioDispatchSource$3.run() line: 209	
	SerialDispatchQueue.run() line: 100	
	SimpleThread.run() line: 77	


No consumers registered yet
Only when this finishes will Camel be able to process the messages.

Daemon Thread [localhost-startStop-1] (Suspended (breakpoint at line 164 in MQTTEndpoint))	
	owns: SpringCamelContext  (id=92)	
	owns: Object  (id=143)	
	owns: StandardContext  (id=144)	
	MQTTEndpoint.addConsumer(MQTTConsumer) line: 164	
	MQTTConsumer.doStart() line: 35	
	MQTTConsumer(ServiceSupport).start() line: 61	
	SpringCamelContext(DefaultCamelContext).startService(Service) line: 2158	
	SpringCamelContext(DefaultCamelContext).doStartOrResumeRouteConsumers(Map&amp;lt;Integer,DefaultRouteStartupOrder&amp;gt;, boolean, boolean) line: 2452	
	SpringCamelContext(DefaultCamelContext).doStartRouteConsumers(Map&amp;lt;Integer,DefaultRouteStartupOrder&amp;gt;, boolean) line: 2388	
	SpringCamelContext(DefaultCamelContext).safelyStartRouteServices(boolean, boolean, boolean, boolean, Collection&amp;lt;RouteService&amp;gt;) line: 2318	
	SpringCamelContext(DefaultCamelContext).doStartOrResumeRoutes(Map&amp;lt;String,RouteService&amp;gt;, boolean, boolean, boolean, boolean) line: 2091	
	SpringCamelContext(DefaultCamelContext).doStartCamel() line: 1951	
	SpringCamelContext(DefaultCamelContext).doStart() line: 1777	


These messages will never be picked up.
Perhaps it&amp;amp;apos;s more the responsibility of the consumer / producer to start a connection when they get attached to the endpoint ? </description>
			<version>2.14.0</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mqtt.MQTTConsumer.java</file>
			<file type="M">org.apache.camel.component.mqtt.MQTTProducer.java</file>
			<file type="M">org.apache.camel.component.mqtt.MQTTEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="8036" opendate="2014-11-12 04:33:00" fixdate="2014-11-20 09:14:44" resolution="Fixed">
		<buginformation>
			<summary>JettyComponent should not setup the security handler more than once</summary>
			<description>As we create multiple consumer for the rest component, it could introduce an issue that camel could add security handler more than once if user setup the security handler on the rest endpoint.</description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.HttpBasicAuthComponentConfiguredTest.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="8065" opendate="2014-11-20 13:42:35" fixdate="2014-11-20 16:19:51" resolution="Fixed">
		<buginformation>
			<summary>Camel won&amp;apos;t build on windows (camel-box and camel-api-component-maven-plugin)</summary>
			<description>Building camel fails on windows with the error: 
Failed to execute goal org.apache.camel:camel-api-component-maven-plugin:2.15-SNAPSHOT:fromApis (generate-test-component-classes) on project camel-box: Error generating source for com.box.boxjavalibv2.resourcemanagers.IBoxCollaborationsManager: String index out of range: 1
This is due to the plugin not escaping the windows file separator before using it in a regex. 
Patch/pull request to follow</description>
			<version>2.15.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.maven.AbstractApiMethodGeneratorMojo.java</file>
			<file type="M">org.apache.camel.maven.ApiComponentGeneratorMojo.java</file>
		</fixedFiles>
	</bug>
	<bug id="8053" opendate="2014-11-15 09:01:49" fixdate="2014-11-21 02:05:02" resolution="Fixed">
		<buginformation>
			<summary>Memory leak when adding/removing a lot of routes</summary>
			<description>Dynamically adding/removing routes to camel causes registrations in org.apache.camel.builder.ErrorHandlerBuilderRef.handlers (Map&amp;lt;RouteContext, ErrorHandlerBuilder&amp;gt;) for RouteContext instances. Those never get removed and can cause leaks if memory consuming objects are attached in the RouteContext for example constant definitions.</description>
			<version>2.14.0</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilder.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilderSupport.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilderRef.java</file>
		</fixedFiles>
	</bug>
	<bug id="8073" opendate="2014-11-21 14:59:58" fixdate="2014-11-21 15:03:33" resolution="Fixed">
		<buginformation>
			<summary>Camel may clear attachments during routing</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Camel-cleans-attachments-if-error-is-thrown-during-routing-tp5759410.html</description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.MessageSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="8087" opendate="2014-11-27 16:39:12" fixdate="2014-11-28 10:50:28" resolution="Fixed">
		<buginformation>
			<summary>missing dependency for "camel-example-restlet-jdbc" example</summary>
			<description>after "mvn clean install &amp;amp; mvn jetty:run" following exception appears and REST services doesn&amp;amp;apos;t work.


on completed in 2405 ms
2014-11-27 17:24:03.534:WARN:oejs.Holder:
java.lang.ClassNotFoundException: org.restlet.ext.spring.SpringServerServlet
        at org.codehaus.plexus.classworlds.strategy.SelfFirstStrategy.loadClass(SelfFirstStrategy.java:50)
        at org.codehaus.plexus.classworlds.realm.ClassRealm.loadClass(ClassRealm.java:244)
        at org.codehaus.plexus.classworlds.realm.ClassRealm.loadClass(ClassRealm.java:230)
        at org.eclipse.jetty.webapp.WebAppClassLoader.loadClass(WebAppClassLoader.java:430)
        at org.eclipse.jetty.webapp.WebAppClassLoader.loadClass(WebAppClassLoader.java:383)
        at org.eclipse.jetty.util.Loader.loadClass(Loader.java:100)
        at org.eclipse.jetty.util.Loader.loadClass(Loader.java:79)
        at org.eclipse.jetty.servlet.Holder.doStart(Holder.java:107)
        at org.eclipse.jetty.servlet.ServletHolder.doStart(ServletHolder.java:298)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.eclipse.jetty.servlet.ServletHandler.initialize(ServletHandler.java:791)
        at org.eclipse.jetty.servlet.ServletContextHandler.startContext(ServletContextHandler.java:265)
        at org.eclipse.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1242)
        at org.eclipse.jetty.server.handler.ContextHandler.doStart(ContextHandler.java:717)
        at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:494)
        at org.mortbay.jetty.plugin.JettyWebAppContext.doStart(JettyWebAppContext.java:298)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229)
        at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart(ContextHandlerCollection.java:172)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.eclipse.jetty.server.handler.HandlerWrapper.doStart(HandlerWrapper.java:95)
        at org.eclipse.jetty.server.Server.doStart(Server.java:282)
        at org.mortbay.jetty.plugin.JettyServer.doStart(JettyServer.java:65)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty(AbstractJettyMojo.java:520)
        at org.mortbay.jetty.plugin.AbstractJettyMojo.execute(AbstractJettyMojo.java:365)
        at org.mortbay.jetty.plugin.JettyRunMojo.execute(JettyRunMojo.java:523)
        at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101)
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209)
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84)
        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59)
        at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183)
        at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161)
        at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:319)
        at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156)
        at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537)
        at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196)
        at org.apache.maven.cli.MavenCli.main(MavenCli.java:141)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:606)
        at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290)
        at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230)
        at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409)
        at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352)
2014-11-27 17:24:03.536:WARN:/:unavailable
javax.servlet.UnavailableException: org.restlet.ext.spring.SpringServerServlet
        at org.eclipse.jetty.servlet.Holder.doStart(Holder.java:114)
        at org.eclipse.jetty.servlet.ServletHolder.doStart(ServletHolder.java:298)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.eclipse.jetty.servlet.ServletHandler.initialize(ServletHandler.java:791)
        at org.eclipse.jetty.servlet.ServletContextHandler.startContext(ServletContextHandler.java:265)
        at org.eclipse.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1242)
        at org.eclipse.jetty.server.handler.ContextHandler.doStart(ContextHandler.java:717)
        at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:494)
        at org.mortbay.jetty.plugin.JettyWebAppContext.doStart(JettyWebAppContext.java:298)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229)
        at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart(ContextHandlerCollection.java:172)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.eclipse.jetty.server.handler.HandlerWrapper.doStart(HandlerWrapper.java:95)
        at org.eclipse.jetty.server.Server.doStart(Server.java:282)
        at org.mortbay.jetty.plugin.JettyServer.doStart(JettyServer.java:65)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty(AbstractJettyMojo.java:520)
        at org.mortbay.jetty.plugin.AbstractJettyMojo.execute(AbstractJettyMojo.java:365)
        at org.mortbay.jetty.plugin.JettyRunMojo.execute(JettyRunMojo.java:523)
        at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101)
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209)
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84)
        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59)
        at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183)
        at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161)
        at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:319)
        at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156)
        at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537)
        at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196)
        at org.apache.maven.cli.MavenCli.main(MavenCli.java:141)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:606)
        at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290)
        at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230)
        at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409)
        at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352)
2014-11-27 17:24:03.538:WARN:oejuc.AbstractLifeCycle:FAILED RestletServlet: javax.servlet.UnavailableException: org.restlet.ext.spring.SpringServerServlet
javax.servlet.UnavailableException: org.restlet.ext.spring.SpringServerServlet
        at org.eclipse.jetty.servlet.Holder.doStart(Holder.java:114)
        at org.eclipse.jetty.servlet.ServletHolder.doStart(ServletHolder.java:298)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.eclipse.jetty.servlet.ServletHandler.initialize(ServletHandler.java:791)
        at org.eclipse.jetty.servlet.ServletContextHandler.startContext(ServletContextHandler.java:265)
        at org.eclipse.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1242)
        at org.eclipse.jetty.server.handler.ContextHandler.doStart(ContextHandler.java:717)
        at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:494)
        at org.mortbay.jetty.plugin.JettyWebAppContext.doStart(JettyWebAppContext.java:298)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229)
        at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart(ContextHandlerCollection.java:172)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.eclipse.jetty.server.handler.HandlerWrapper.doStart(HandlerWrapper.java:95)
        at org.eclipse.jetty.server.Server.doStart(Server.java:282)
        at org.mortbay.jetty.plugin.JettyServer.doStart(JettyServer.java:65)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty(AbstractJettyMojo.java:520)
        at org.mortbay.jetty.plugin.AbstractJettyMojo.execute(AbstractJettyMojo.java:365)
        at org.mortbay.jetty.plugin.JettyRunMojo.execute(JettyRunMojo.java:523)
        at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101)
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209)
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84)
        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59)
        at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183)
        at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161)
        at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:319)
        at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156)
        at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537)
        at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196)
        at org.apache.maven.cli.MavenCli.main(MavenCli.java:141)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:606)
        at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290)
        at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230)
        at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409)
        at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352)
2014-11-27 17:24:03.539:WARN:oejw.WebAppContext:Failed startup of context o.m.j.p.JettyWebAppContext{/,file:/home/sm/Downloads/apache-camel-2.14.0/examples/camel-example-restlet-jdbc/src/main/webapp/},file:/home/sm/Downloads/apache-camel-2.14.0/examples/camel-example-restlet-jdbc/src/main/webapp/
javax.servlet.UnavailableException: org.restlet.ext.spring.SpringServerServlet
        at org.eclipse.jetty.servlet.Holder.doStart(Holder.java:114)
        at org.eclipse.jetty.servlet.ServletHolder.doStart(ServletHolder.java:298)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.eclipse.jetty.servlet.ServletHandler.initialize(ServletHandler.java:791)
        at org.eclipse.jetty.servlet.ServletContextHandler.startContext(ServletContextHandler.java:265)
        at org.eclipse.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1242)
        at org.eclipse.jetty.server.handler.ContextHandler.doStart(ContextHandler.java:717)
        at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:494)
        at org.mortbay.jetty.plugin.JettyWebAppContext.doStart(JettyWebAppContext.java:298)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229)
        at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart(ContextHandlerCollection.java:172)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.eclipse.jetty.server.handler.HandlerCollection.doStart(HandlerCollection.java:229)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.eclipse.jetty.server.handler.HandlerWrapper.doStart(HandlerWrapper.java:95)
        at org.eclipse.jetty.server.Server.doStart(Server.java:282)
        at org.mortbay.jetty.plugin.JettyServer.doStart(JettyServer.java:65)
        at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)
        at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty(AbstractJettyMojo.java:520)
        at org.mortbay.jetty.plugin.AbstractJettyMojo.execute(AbstractJettyMojo.java:365)
        at org.mortbay.jetty.plugin.JettyRunMojo.execute(JettyRunMojo.java:523)
        at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101)
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209)
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)
        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:84)
        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:59)
        at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBuild(LifecycleStarter.java:183)
        at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:161)
        at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:319)
        at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156)
        at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537)
        at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196)
        at org.apache.maven.cli.MavenCli.main(MavenCli.java:141)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:606)
        at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:290)
        at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:230)
        at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409)
        at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:352)
2014-11-27 17:24:03.541:WARN:oejsh.RequestLogHandler:!RequestLog



Fix
add 


&amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.restlet.jee&amp;lt;/groupId&amp;gt;
          &amp;lt;artifactId&amp;gt;org.restlet.ext.spring&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;${restlet-version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;


to the pom.xml</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.RestletComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="8094" opendate="2014-11-29 22:49:27" fixdate="2014-11-30 11:13:25" resolution="Fixed">
		<buginformation>
			<summary>camel-netty: Do not use org.jboss.netty.util.internal.ExecutorUtil as it breaks the camel-netty Karaf feature</summary>
			<description></description>
			<version>2.14.0</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.NettyClientBossPoolBuilder.java</file>
			<file type="M">org.apache.camel.component.netty.NettyWorkerPoolBuilder.java</file>
			<file type="M">org.apache.camel.component.netty.NettyServerBossPoolBuilder.java</file>
			<file type="M">org.apache.camel.component.netty.NettyProducer.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">8030</link>
		</links>
	</bug>
	<bug id="7953" opendate="2014-10-24 15:51:09" fixdate="2014-11-30 14:08:11" resolution="Fixed">
		<buginformation>
			<summary>Hazelcast seda documentation is misleading about pollInterval</summary>
			<description>Actual documentation says about property pollInterval used by hazelcast seda consumer: "How frequent to poll from the SEDA queue". Unfortunately this is wrong since pollInterval is used as blocking timeout while polling a Java BlockingQueue (http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html#poll%28long,%20java.util.concurrent.TimeUnit%29) which might lead to wrong usage. Property might considered to be renamed to e.g. blockingTimeout. </description>
			<version>2.14.0</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.hazelcast.HazelcastSedaConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.hazelcast.seda.HazelcastSedaConfiguration.java</file>
			<file type="M">org.apache.camel.component.hazelcast.seda.HazelcastSedaConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7784" opendate="2014-09-05 13:17:27" fixdate="2014-11-30 14:59:38" resolution="Fixed">
		<buginformation>
			<summary>Camel : RSS - Ignores posts with identical published or updated date.</summary>
			<description>When running with a RSS feed which has multiple entries with the same date only the first one is read, the rest are ignored because of the date filter.  I have provided a rudimental fix and unit test for this issue, this hashes the entries to detect duplicates.</description>
			<version>2.13.2</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rss.UpdatedDateFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="7882" opendate="2014-09-30 11:16:04" fixdate="2014-11-30 15:30:31" resolution="Fixed">
		<buginformation>
			<summary>camel-syslog&amp;apos;s CamelSyslogTimestamp header is suddenly a GregorianCalendar</summary>
			<description>This is mostly to help others facing the same issue, as we just spent 4x3 hours figuring this out.
An app, that consumes syslog entries and forwards JMS (over OpenMQ), was upgraded from camel 2.13.0 to 2.14.0.
Afterwards many things broke upstream, which was masked by poor logging in some Glassfish servers (truncating stacktraces).
Turns out that the CamelSyslogTimestamp header was silently discarded, being a java.util.GregorianCalendar instance.
Forcing it into a java.util.Date before routing to the JMS endpoint restored service throughout the valuechain.
As I wrote; this is mostly a FYI to others .
But perhaps the documentation might reflect the lack of guaranteed conversion?</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.syslog.SyslogDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="7785" opendate="2014-09-05 16:31:37" fixdate="2014-11-30 15:51:52" resolution="Fixed">
		<buginformation>
			<summary>setUnitOfWork in DefaultExchange throws NPE when called from Splitter.java</summary>
			<description>setUnitOfWork in DefaultExchange throws NPE when called from Splitter.java, 
Line 226 of Splitter.java is: exchange.setUnitOfWork(null);
Line 372 of DefaultExchange.java checks if onCompletions !=null, in this case because Splitter.java initialized unitOfWork to null on line 376 unitOfWork.addSynchronization(onCompletion) will throw an NPE since unitOfWork is still null.
Recommendation:
Line 372 of defaultExchange.java should include a check if unitOfWork is not null:
if(onCompletions !=null &amp;amp;&amp;amp; unitOfWork != null)
Steps to reproduce:
1. Include a Split EIP in a Camel Route.
2. Specify an onPrepareRef=&amp;lt;class&amp;gt;
3. Add an onCompletion step to the exchange in &amp;lt;class&amp;gt;
4. NPE should be thrown when processing files.</description>
			<version>2.12.2</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultExchange.java</file>
		</fixedFiles>
	</bug>
	<bug id="8077" opendate="2014-11-24 02:58:41" fixdate="2014-11-30 16:02:58" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException in getRouteDefinition before context is started</summary>
			<description>Not sure if this occurs in 2.14.0. Does not occur in 2.13.3.
I am extending CamelSpringTestSupport with:
@Override
public boolean isUseAdviceWith() 
{
    return true;
}

In a @Before method I call context.getRouteDefintion("some.id")
It throws a NullPointerException:
org.apache.camel.impl.DefaultCamelContext.getRouteDefinition(DefaultCamelContext.java:1464)
If I put context.start() at the top of the @Before method, it works.
</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="8100" opendate="2014-12-01 20:08:24" fixdate="2014-12-02 14:30:03" resolution="Fixed">
		<buginformation>
			<summary>Collection should be optional for getDbStats</summary>
			<description>Collection should be optional for getDbStats on route description</description>
			<version>2.13.0</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mongodb.MongoDbEndpoint.java</file>
			<file type="M">org.apache.camel.component.mongodb.MongoDbOperation.java</file>
			<file type="M">org.apache.camel.component.mongodb.MongoDbOperationsTest.java</file>
			<file type="M">org.apache.camel.component.mongodb.MongoDbProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8106" opendate="2014-12-02 15:50:44" fixdate="2014-12-02 15:57:12" resolution="Fixed">
		<buginformation>
			<summary>XML parsing error is ignored by xtoknize XML tokenizer</summary>
			<description>XML parsing exceptions are ignored by xtokenize XML tokenizer and this is leading to the same token extracted repeated times.</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.support.XMLTokenExpressionIterator.java</file>
		</fixedFiles>
	</bug>
	<bug id="8086" opendate="2014-11-27 15:12:26" fixdate="2014-12-03 16:40:58" resolution="Fixed">
		<buginformation>
			<summary>Possible memoryleak when convertBodyTo is used in a dynamicRouter</summary>
			<description>We have implemented a while loop using a dynamicRouter.
The dynamicRouter looks like this:
&amp;lt;dynamicRouter&amp;gt;
  &amp;lt;header&amp;gt;someheadername&amp;lt;/header&amp;gt;
&amp;lt;/dynamicRouter&amp;gt;
where someheadername refers to another route using direct:routename
The route that handles direct:routename looks like this:
&amp;lt;bean ref="someref"/&amp;gt;
&amp;lt;convertBodyTo type="java.lang.String"/&amp;gt;
The someref-bean just puts some data in the body and header and would also be responsible to set the value of someheadername=null to exit the dynamicRouter.
During execution of these routes we see that heapusage increases until OOM if the dynamicRouter does not exit before OOM. The number of instances of DefaultMessage also keeps increasing.
If we remove the &amp;lt;convertBodyTo&amp;gt; from the route we do not get OOM and the number of instances of DefaultMessage is stable and low.
The same also happens if we replace &amp;lt;convertBodyTo&amp;gt; with a &amp;lt;transform&amp;gt;.</description>
			<version>2.13.2</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.sql.SqlBuilder.java</file>
			<file type="M">org.apache.camel.processor.TransformProcessor.java</file>
			<file type="M">org.apache.camel.processor.SetBodyProcessor.java</file>
			<file type="M">org.apache.camel.processor.ConvertBodyProcessor.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="8008" opendate="2014-11-07 08:26:28" fixdate="2014-12-03 18:31:55" resolution="Fixed">
		<buginformation>
			<summary>SubmitMulti and DataSm not checking CamelSmppAlphabet header</summary>
			<description>According to the documentation, the CamelSmppAlphabet header is used for SubmitSm, SubmitMulti and DataSm message types
Looking at the code, I noticed it was only used for SubmitSm and not the other two.</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.smpp.SmppDataSmCommand.java</file>
			<file type="M">org.apache.camel.component.smpp.SmppSubmitMultiCommand.java</file>
		</fixedFiles>
	</bug>
	<bug id="8081" opendate="2014-11-27 03:54:02" fixdate="2014-12-03 19:05:13" resolution="Fixed">
		<buginformation>
			<summary>Multicast Aggregator should keep processing other exchange which is not timeout</summary>
			<description>It makes sense the multicast aggregator keep processing the exchange even some exchange are timeout. 
Here is a thread in the camel user mailing list talks about it.</description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.MulticastParallelAllTimeoutAwareTest.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="8082" opendate="2014-11-27 04:00:45" fixdate="2014-12-03 19:14:03" resolution="Fixed">
		<buginformation>
			<summary>CxfRs producer should close the connection if MEP is InOnly</summary>
			<description>When using cxfRs to send a rest message in InOnly mode, Camel do not close
the javax.ws.rs.core.Response object. As we are InOnly, the reponse object is not passed through the exchange, so the caller can not close it either.
Here is the mail thread which talks about it.</description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8118" opendate="2014-12-03 13:15:56" fixdate="2014-12-04 07:21:34" resolution="Fixed">
		<buginformation>
			<summary>BigDecimalPatternFormat overwrites Locale setting</summary>
			<description>Because of this change request (https://issues.apache.org/jira/browse/CAMEL-7742) was a new feature implemented that allows pattern annotations for BigDecimal fields in CSV model classes for the Camel Bindy component.
The problem with that is, that the usage of this feature overwrites the current Locale setting of the environment. For example, if the current Locale was set to "German" and the provided pattern for the BigDecimal field requires "US" to unmarshal the numbers in the CSV file, then the method BigDecimalPatternFormat#parse(String) overwrites the Locale, but doesn&amp;amp;apos;t restore the former setting. This can cause problems for other software components that depends on the Locale setting.
The cause of the problem can be found here on line 21: Source of BigDecimalPatternFormat
A possible workaround would be storing the current locale temporarily, overwrite that setting, perform the formatting task and then restore the former locale setting.
Like in this code example:


if (getNumberFormat() != null) {
    final Locale currentLocale = Locale.getDefault();
    Locale.setDefault(super.getLocale());
    DecimalFormat df = (DecimalFormat)getNumberFormat();
    df.setParseBigDecimal(true);
    BigDecimal bd = (BigDecimal)df.parse(string.trim());
    if(super.getPrecision() != -1) {
        bd = bd.setScale(super.getPrecision(), RoundingMode.valueOf(super.getRounding()));
    }
    Locale.getDefault(); // what is the purpose of this line?
    Locale.setDefault(currentLocale); // restore the Locale setting
    return bd;
}

</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.bindy.format.BigDecimalPatternFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="7880" opendate="2014-09-29 20:30:22" fixdate="2014-12-04 08:11:29" resolution="Fixed">
		<buginformation>
			<summary>Cannot use custom DataFormats in REST DSL</summary>
			<description>See: http://camel.465427.n5.nabble.com/RestBindingProcessor-JSON-Data-Format-Config-td5757103.html
When using custom JSON data format in REST DSL, the service incorrectly rejects messages with request structure and accepts messages with response structure.
This is due to org.apache.camel.model.rest.RestBindingDefinition.createProcessor(RouteContext) looking up and configuring the same DataFormat object twice:


DataFormat json = context.resolveDataFormat(name); 
DataFormat outJson = context.resolveDataFormat(name); 

</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.rest.RestBindingDefinition.java</file>
			<file type="M">org.apache.camel.model.rest.RestConfigurationDefinition.java</file>
			<file type="M">org.apache.camel.spi.RestConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8389</link>
		</links>
	</bug>
	<bug id="8001" opendate="2014-11-06 15:01:12" fixdate="2014-12-05 03:28:01" resolution="Fixed">
		<buginformation>
			<summary>SmppUtils.isGsm0338Encodeable() called with arbitrary data</summary>
			<description>
The method SmppUtils.isGsm0338Encodeable(byte[]) expects the input data to be Latin1 encoded (or a subset of Latin1, such as ASCII)
The method SmppSmCommand.determineAlphabet(Message) prepares an argument by calling String.getBytes(charset) without checking the charset is Latin1 or compatible.
</description>
			<version>2.12.2</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.smpp.SmppSmCommand.java</file>
			<file type="M">org.apache.camel.component.smpp.SmppUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="8092" opendate="2014-11-28 18:50:25" fixdate="2014-12-05 06:13:46" resolution="Fixed">
		<buginformation>
			<summary>cxf:producer Matrix Params are missing</summary>
			<description>In cxfrs component the producer strips away the matrix param.
Steps to reproduce:
Web service proxying configuration (camel-proxy-example). 
&amp;lt;camelContext id="camel" xmlns="http://camel.apache.org/schema/spring"&amp;gt;
&amp;lt;route&amp;gt;
&amp;lt;from uri="cxfrs://bean://rsServer?bindingStyle=SimpleConsumer"/&amp;gt;  
&amp;lt;to uri="cxfrs://bean://rsClient"/&amp;gt;  
&amp;lt;/route&amp;gt;  
&amp;lt;/camelContext&amp;gt;
But we can see that the Matrix Parameters are completely stripped away in CxfRsProducer.  The SimpleConsumer as the binding style the matrix param will be sent as header params.  But shouldn&amp;amp;apos;t the matrix params part of the URL. 
ID: 15 
Address: http://localhost:8001/test/services/proxyServer/boxing;state=Current
Http-Method: GET 
Content-Type: 
Headers: 
{Accept=[application/xml], accept-encoding=[gzip, deflate], accept-language=[en-us], Authorization=[xxxx], connection=[keep-alive], Content-Length=[0], Content-Type=[null], host=[localhost:8001]}
 
-------------------------------------- 
--------------------------- 
ID: 16 
Address: http://localhost:29090/MyServer/boxing
Http-Method: GET 
Content-Type: / 
Headers: 
{Accept=[application/xml], state=[Current],  user-agent=[xxxxxx], accept-encoding=[gzip, deflate], Content-Length=[0], Authorization=[xxxxx], org.apache.cxf.request.uri=[/services/proxyServer/boxing;state=Current], host=[localhost:8001], connection=[keep-alive], accept-language=[en-us], org.apache.cxf.message.Message.PATH_INFO=[/boxing], org.apache.cxf.request.method=[GET], Content-Type=[*/*]}
 
I have came across similar issue posted in the past.  CAMEL-5405 CXF Transport loses HTTP Matrix parameters  But we are using camel 2.14.0 version. </description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8121" opendate="2014-12-04 02:33:44" fixdate="2014-12-05 06:14:59" resolution="Fixed">
		<buginformation>
			<summary>Infinite Loop Within Camel if the temp file directory is not writable</summary>
			<description>If the target &amp;amp;apos;tmp&amp;amp;apos; directory (specified by java.io.tmpdir) used by Camel, does not have proper privileges, then Camel enters infinite loop. The offending code is found in org.apache.camel.util.FileUtil.createNewTempDir().
We need to check the if the temp file is writable.</description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.FileUtil.java</file>
		</fixedFiles>
	</bug>
	<bug id="8123" opendate="2014-12-04 14:15:08" fixdate="2014-12-05 06:15:53" resolution="Fixed">
		<buginformation>
			<summary>Mina2 SSL initiates handshake backwards</summary>
			<description>The Mina2Consumer and Mina2Producer are configured backwards for SSL handshake initiation. The consumer is trying to initiate the handshake rather than the producer. You can see this by setting up a SSL enabled consuming route and telnet to the port, you will immediately get some data sent from the server to the client rather than the server waiting on the client to initiate the handshake.
The issue is Mina2Consumer:160, it is setting UseClientMode to true, it should be false. Mina2Producer line 313 needs to also change to the following:
            SslFilter filter = new SslFilter(configuration.getSslContextParameters().createSSLContext(), configuration.isAutoStartTls());
filter.setUseClientMode(true);
connector.getFilterChain().addFirst("sslFilter", filter);
As far as I can tell this has been a bug since this component was introduced.</description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina2.Mina2Producer.java</file>
			<file type="M">org.apache.camel.component.mina2.Mina2Consumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8125" opendate="2014-12-05 12:43:23" fixdate="2014-12-08 11:18:26" resolution="Fixed">
		<buginformation>
			<summary>PropertyInject gives NullPointerException</summary>
			<description>Using the annotation @PropertyInject on a field of the RouteBuilder class gives a NullPointerException
public class RouteBuilder extends SpringRouteBuilder 
{
	
	@PropertyInject("foo.bar")
	private String fooBar;
        ...
}

Using the {{ }} notation in endpoint URIs is working though.
</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinitionHelper.java</file>
			<file type="M">org.apache.camel.util.CamelContextHelper.java</file>
			<file type="M">org.apache.camel.impl.CamelPostProcessorHelper.java</file>
		</fixedFiles>
		<links>
			<link type="Cloners" description="is cloned by">8126</link>
		</links>
	</bug>
	<bug id="8134" opendate="2014-12-09 07:22:38" fixdate="2014-12-09 19:25:41" resolution="Fixed">
		<buginformation>
			<summary>We should not add synchronisation if the CachedOutputStream closedOnCompletion option is false</summary>
			<description>CachedOutputStream adds synchronization into exchange even the closedOnCompletion option is false, it could cause OOM error with the HttpProducer endpoint does "unlimited/limited" redelivery. 
Here is the discussion about this issue. </description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.1, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStreamTest.java</file>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStream.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">7055</link>
		</links>
	</bug>
	<bug id="8137" opendate="2014-12-09 17:30:54" fixdate="2014-12-10 16:32:25" resolution="Fixed">
		<buginformation>
			<summary>Simple language does not resolve overloaded method calls</summary>
			<description>I am having an issue with the Simple language. I have a property named myFile with a value of a java.nio.file.Path object. When I try to use the following expression 

 ${property.file.getFileName} 

 in order to invoke the getFileName() method I get an exception saying:

Ambiguous method invocations possible: [public sun.nio.fs.UnixPath.getFileName(), public abstract java.nio.file.Path java.nio.file.Path.getFileName()]


I am able to use SpEL if I do

#{properties[myFile].getFileName()}


It would be nice if Simple supported this as well so I wouldn&amp;amp;apos;t have to go through hoops in order to use SpEL since I can&amp;amp;apos;t use SpEL to specify parameters in a uri.</description>
			<version>2.14.0</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
		</fixedFiles>
		<links>
			<link type="Regression" description="breaks">8492</link>
		</links>
	</bug>
	<bug id="8148" opendate="2014-12-11 23:42:07" fixdate="2014-12-12 00:09:53" resolution="Fixed">
		<buginformation>
			<summary>Avoid possible NPE in Camel Box component on exceptions during initial login</summary>
			<description>There is a possible NPE that can happen on exceptions during the initial OAuth flow in Camel Box component. This is due to a listener attribute in LoginAuthFlowUI which is never set by Box.com SDK. </description>
			<version>2.14.0</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.box.internal.LoginAuthFlowUI.java</file>
			<file type="M">org.apache.camel.component.box.IBoxCollaborationsManagerIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8156" opendate="2014-12-16 13:02:17" fixdate="2014-12-17 05:02:05" resolution="Fixed">
		<buginformation>
			<summary>SNSClient should setup endpoint before creating the topic</summary>
			<description>When using camel-aws-sns endpoint, it always create the topic on the default endpoint.
Here is the mailing thread about it </description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.aws.sns.SnsEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="8153" opendate="2014-12-15 10:34:12" fixdate="2014-12-17 07:06:12" resolution="Fixed">
		<buginformation>
			<summary>Fix potential connection leak in StreamList mode</summary>
			<description>When using camel-jdbc component with newly introduced StreamList mode I&amp;amp;apos;ve faced a 100% reproducible connection leak issue.
My investigation leads me to Tomcat connection pool implementation - it has problem with returing current connection from Statement object - instead of returning pool specific proxy it returns actual JDBC connection.
There is `statement.getConnection()` line in `org.apache.camel.component.jdbc.ResultSetIterator` so in my particular scenario things work like this:
1) Camel borrows connection from Tomcat pool
2) Camel leaves JDBC connection and ResultSet intact as we use StreamList mode of camel-jdbc component
3) Route processes resultset in streaming mode and completes successfully
4) Camel tries to close connection, but due to connection pool implementation issue it closes actual JDBC connection instead of returing it to the pool
5) Actual JDBC connection is closed an connection pool is unaware of this fact thinking it&amp;amp;apos;s still open and in use by application
It would be more error prone to pass proper connection object to ResultSetIterator along with result set and not rely on statement.getConnection() call.</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jdbc.ResultSetIterator.java</file>
			<file type="M">org.apache.camel.component.jdbc.JdbcProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8146" opendate="2014-12-11 13:14:54" fixdate="2014-12-18 12:21:39" resolution="Fixed">
		<buginformation>
			<summary>Starting and stopping routes leak threads</summary>
			<description>Seems to be identical consequence as with previous issue CAMEL-5677, but perhaps due to a different cause.
Having a file or SFTP based route, trying something like:


for (int i = 0; i &amp;lt; 50; i++) {
    camelContext.startRoute(routeId);
    camelContext.stopRoute(routeId);
}


results in 50 orphan threads of this type:


"Camel (camel) thread #231 - sftp://user@host/path" #10170 daemon prio=5 os_prio=0 tid=0x00007fa4b46a5800 nid=0x10fc waiting on condition [0x00007fa452934000]
   java.lang.Thread.State: TIMED_WAITING (parking)
      at sun.misc.Unsafe.park(Native Method)
      - parking to wait for  &amp;lt;0x00000000b83dc900&amp;gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
      at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)
      at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)
      at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1093)
      at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)
      at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)
      at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)
      at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
      at java.lang.Thread.run(Thread.java:745)


Switching to suspend/resume solves the problem, however I guess the start/stop issue should be addressed.</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultScheduledPollConsumerScheduler.java</file>
			<file type="M">org.apache.camel.impl.ScheduledPollConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8160" opendate="2014-12-17 16:49:53" fixdate="2014-12-21 13:10:26" resolution="Fixed">
		<buginformation>
			<summary>Generic methods used as endpoints fail in Java 8</summary>
			<description>In Java 8 annotations are duplicated to generics&amp;amp;apos; bridge methods.  Camel, rightly, does not support bridge methods as endpoints.  However, because of this change in the language annotations such as @Consume will end up on them after compilation leaving Camel in an invalid state.
I will attach a sample project.
This ticket is from this discussion thread: http://camel.465427.n5.nabble.com/Changes-in-Java-8-generics-breaking-Camel-td5760638.html</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ReflectionHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="8168" opendate="2014-12-22 00:47:46" fixdate="2014-12-24 04:22:12" resolution="Fixed">
		<buginformation>
			<summary>Mina Does Not Unbind From Listening Port</summary>
			<description>If a bundle includes a mina consumer as the one below, when you stop the bundle, the port is not released. Therefore, when restarting the bundle, you&amp;amp;apos;ll get a port already in use bind exception.


&amp;lt;from uri="mina2:tcp://0.0.0.0:12345?sync=true"/&amp;gt;


Note that the problem does not exist if you&amp;amp;apos;re using an IP address other than 0.0.0.0. For example:


&amp;lt;from uri="mina2:tcp://{{host.name}}:12345?sync=true"/&amp;gt;

</description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina2.Mina2Consumer.java</file>
			<file type="M">org.apache.camel.component.mina.MinaTcpTest.java</file>
			<file type="M">org.apache.camel.component.mina2.Mina2TcpTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8169" opendate="2014-12-22 00:52:16" fixdate="2014-12-29 06:19:35" resolution="Fixed">
		<buginformation>
			<summary>Camel Jetty/Http4 producers should respect Content-Length/Transfer-Encoding:Chunked headers</summary>
			<description>If Camel is used the HTTP proxy, users expect that Content-Length and Transfer-Encoding: Chunked headers should be respected when incoming request is redirected using HTTP4 or Jetty producers.
If example if I send request to the following route...


from("servlet://0.0.0.0:8080").to("http4://foo.com"); 


...and this request contains Content-Length header (and doesn&amp;amp;apos;t contain Transfer-Encoding: Chunked header) then request forwarded to foo.com should not be chunked. In Fuse 6.1 Camel will chunk frowarded request.
In general client sending request to the Camel proxy gateway, should be sure that by default Camel will keep the same chunking/nonchunking behavior as specified in the original request.</description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.itest.http.HttpRouteContentLengthTest.java</file>
			<file type="M">org.apache.camel.component.http4.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpProducer.java</file>
			<file type="M">org.apache.camel.component.http4.HttpEntityConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="8189" opendate="2014-12-29 04:37:24" fixdate="2014-12-31 07:13:57" resolution="Fixed">
		<buginformation>
			<summary>camel-scr-archetype produces invalid package structure</summary>
			<description>When generating a project using the camel-archetype-scr archetype, the resulting project produces an invalid packaging structure which cannot be compiled.
This can occur due to differences between the groupId and package parameters</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">tooling.archetypes.camel-archetype-scr.src.main.resources.archetype-resources.src.main.java.internal.__className__Route.java</file>
			<file type="M">tooling.archetypes.camel-archetype-scr.src.main.resources.archetype-resources.src.test.java.__className__Test.java</file>
			<file type="M">tooling.archetypes.camel-archetype-scr.src.main.resources.archetype-resources.src.main.java.__className__.java</file>
		</fixedFiles>
	</bug>
	<bug id="8194" opendate="2014-12-30 06:29:49" fixdate="2015-01-04 07:04:49" resolution="Fixed">
		<buginformation>
			<summary>Elasticsearch component fails in an OSGi environment due to missing names.txt</summary>
			<description>

2014-12-29 22:25:12,667 | ERROR | FelixStartLevel  | BlueprintCamelContext            | 8 - org.apache.camel.camel-blueprint - 2.14.0 | Error occurred during starting Camel: CamelContext(elasticSearchProducerCamelContext) due Failed to create route log-event-sink-elasticsearch at: &amp;gt;&amp;gt;&amp;gt; Aggregate[true -&amp;gt; [To[log:xxx?level=INFO&amp;amp;groupInterval=2000], To[elasticsearch://elasticsearch?ip=127.0.0.1&amp;amp;port=9300]]] &amp;lt;&amp;lt;&amp;lt; in route: Route(log-event-sink-elasticsearch)[[From[vm:log-event-elast... because of Failed to resolve endpoint: elasticsearch://elasticsearch?ip=127.0.0.1&amp;amp;port=9300 due to: Failed to resolve config path [names.txt], tried file path [names.txt], path file [xxx/config/names.txt], and classpath
org.apache.camel.FailedToCreateRouteException: Failed to create route log-event-sink-elasticsearch at: &amp;gt;&amp;gt;&amp;gt; Aggregate[true -&amp;gt; [To[log:xxx?level=INFO&amp;amp;groupInterval=2000], To[elasticsearch://elasticsearch?ip=127.0.0.1&amp;amp;port=9300]]] &amp;lt;&amp;lt;&amp;lt; in route: Route(log-event-sink-elasticsearch)[[From[vm:log-event-elast... because of Failed to resolve endpoint: elasticsearch://elasticsearch?ip=127.0.0.1&amp;amp;port=9300 due to: Failed to resolve config path [names.txt], tried file path [names.txt], path file [xxx/config/names.txt], and classpath
   at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:945)
   at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:187)
...
Caused by: org.elasticsearch.env.FailedToResolveConfigException: Failed to resolve config path [names.txt], tried file path [names.txt], path file [xxx/config/names.txt], and classpath
   at org.elasticsearch.env.Environment.resolveConfig(Environment.java:213)
   at org.elasticsearch.node.internal.InternalSettingsPreparer.prepareSettings(InternalSettingsPreparer.java:119)
...


This can be fixed by adding a one-liner to explicitly set the classloader on the elasticsearch Settings class to the classloader of Settings.class:


            Settings settings = ImmutableSettings.settingsBuilder()
                ...
                .classLoader(Settings.class.getClassLoader());
                ...

</description>
			<version>2.14.1</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.elasticsearch.ElasticsearchEndpoint.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8816</link>
		</links>
	</bug>
	<bug id="8200" opendate="2014-12-30 13:58:45" fixdate="2015-01-04 07:07:22" resolution="Fixed">
		<buginformation>
			<summary>Race condition in JmsProducer for request/response messaging causing nondeterministic setting body to null.</summary>
			<description>In my team we have noticed that there is a race condition problem in JmsProducer class for request/response messaging. It causes that sometimes (nondeterministically) body of a response message is changed to null. It can happen when JMS response is received very fast (we use in-memory ActiveMQ with VM transport and no persistence) under heavy load.
It looks that there is a problem in JmsProducer class in processInOut(exchange, callback) method.


    protected boolean processInOut(final Exchange exchange, final AsyncCallback callback) {
        
        doSend(true, destinationName, destination, messageCreator, messageSentCallback);
        // after sending then set the OUT message id to the JMSMessageID so its identical
        setMessageId(exchange);
        // continue routing asynchronously (reply will be processed async when its received)
        return false;
    }

...
    protected void setMessageId(Exchange exchange) {
        if (exchange.hasOut()) {
            JmsMessage out = exchange.getOut(JmsMessage.class);
            try {
                if (out != null &amp;amp;&amp;amp; out.getJmsMessage() != null) {
                    out.setMessageId(out.getJmsMessage().getJMSMessageID());
                }
            } catch (JMSException e) {
                LOG.warn("Unable to retrieve JMSMessageID from outgoing JMS Message and set it into Camel&amp;amp;apos;s MessageId", e);
            }
        }
    }


The problem is caused by invoking setMessageId(...) method after doSend(...). Method doSend(...) is sending JMS request message and causes that another thread is used to handle JMS reply message. This leads to a situation that 2 different threads can operate on the same exchange (which is not synchronized at all) at the same time:
1) original thread in which processInOut(...) method was called,
2) separate thread from JMS component for handling JMS response.
In our case there it was happening sometimes that setMessageId(...) was invoked at the same time as PipelineHelper.createNextMessage(exchange) method:


    public static Exchange createNextExchange(Exchange previousExchange) {
        Exchange answer = previousExchange;
        // now lets set the input of the next exchange to the output of the
        // previous message if it is not null
        if (answer.hasOut()) {
            answer.setIn(answer.getOut());
            answer.setOut(null);
        }
        return answer;
    }


It caused that body of response message was lost (set to null).
It looks for me that calling setMessageId(...) at the end of processInOut(...) method is redundant and this logic should be executed when JMS reply message is handled.
I&amp;amp;apos;ve attached a patch where invokation of setMessageId(...) is removed.
I&amp;amp;apos;ve checked that it doesn&amp;amp;apos;t break any test for camel-jms component.</description>
			<version>2.14.0</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8185" opendate="2014-12-26 10:18:37" fixdate="2015-01-04 07:24:45" resolution="Fixed">
		<buginformation>
			<summary>camel-scr - IllegalArgumentException: argument type mismatch</summary>
			<description>When camel-scr (2.15-SNAPSHOT) is deployed and used with Apache Karaf - 2.3.0.redhat-611412
The following errors are generated when SCR got the CamelComponent or lost the Component


2014-12-26 11:13:49,453 | ERROR | r-1.0.0-thread-2 | osgi-camel-scr                   | ?                                   ? | 255 - com.redhat.gpe.training.osgi-camel-scr - 1.0.0 | [com.redhat.gpe.training.osgi.camel.BootStrap(52)] The gotCamelComponent method has thrown an exception
java.lang.IllegalArgumentException: argument type mismatch
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)[:1.7.0_51]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)[:1.7.0_51]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)[:1.7.0_51]
	at java.lang.reflect.Method.invoke(Method.java:606)[:1.7.0_51]
	at org.apache.felix.scr.impl.helper.BaseMethod.invokeMethod(BaseMethod.java:231)[82:org.apache.felix.scr:1.8.0.redhat-611412]
	at org.apache.felix.scr.impl.helper.BaseMethod.access$500(BaseMethod.java:39)[82:org.apache.felix.scr:1.8.0.redhat-611412]




2014-12-26 11:22:50,355 | ERROR | l Console Thread | osgi-camel-scr                   | ?                                   ? | 255 - com.redhat.gpe.training.osgi-camel-scr - 1.0.0 | [com.redhat.gpe.training.osgi.camel.BootStrap(52)] The lostCamelComponent method has thrown an exception
java.lang.IllegalArgumentException: argument type mismatch
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)[:1.7.0_51]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)[:1.7.0_51]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)[:1.7.0_51]
	at java.lang.reflect.Method.invoke(Method.java:606)[:1.7.0_51]
	at org.apache.felix.scr.impl.helper.BaseMethod.invokeMethod(BaseMethod.java:231)[82:org.apache.felix.scr:1.8.0.redhat-611412]
	at org.apache.felix.scr.impl.helper.BaseMethod.access$500(BaseMethod.java:39)[82:org.apache.felix.scr:1.8.0.redhat-611412]
	at org.apache.felix.scr.impl.helper.BaseMethod$Resolved.invoke(BaseMethod.java:624)[82:org.apache.felix.scr:1.8.0.redhat-611412]
	at org.apache.felix.scr.impl.helper.BaseMethod.invoke(BaseMethod.java:508)[82:org.apache.felix.scr:1.8.0.redhat-611412]
	at org.apache.felix.scr.impl.helper.BindMethod.invoke(BindMethod.java:37)[82:org.apache.felix.scr:1.8.0.redhat-611412]
	at org.apache.felix.scr.impl.manager.DependencyManager.invokeUnbindMethod(DependencyManager.java:1711)[82:org.apache.felix.scr:1.8.0.redhat-611412]


Here is the code used as example :


import org.apache.camel.CamelContext;
import org.apache.camel.RoutesBuilder;
import org.apache.camel.scr.AbstractCamelRunner;
import org.apache.camel.spi.ComponentResolver;
import org.apache.felix.scr.annotations.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;

@Component(label = BootStrap.COMPONENT_LABEL, description = BootStrap.COMPONENT_DESCRIPTION)
@Properties({
        @Property(name = "camelContextId", value = "camel-scr-exercise"),
        @Property(name = "active", value = "true")
})
@References({
        @Reference(name = "camelComponent",referenceInterface = ComponentResolver.class,
                cardinality = ReferenceCardinality.MANDATORY_MULTIPLE, policy = ReferencePolicy.DYNAMIC,
                policyOption = ReferencePolicyOption.GREEDY, bind = "gotCamelComponent", unbind = "lostCamelComponent")
})
public class BootStrap extends AbstractCamelRunner {

    public static final String COMPONENT_LABEL = "bootstrap.CamelScrExercise";
    public static final String COMPONENT_DESCRIPTION = "This is the description for camel-scr-exercise.";

    public static final Logger LOGGER = LoggerFactory.getLogger(BootStrap.class);

    @Override
    protected List&amp;lt;RoutesBuilder&amp;gt; getRouteBuilders() {
        LOGGER.info("Load Camel Routes definition");
        List&amp;lt;RoutesBuilder&amp;gt; routesBuilders = new ArrayList&amp;lt;&amp;gt;();
        routesBuilders.add(new GreeterRoute());
        return routesBuilders;
    }
}


</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.scr.AbstractCamelRunner.java</file>
		</fixedFiles>
	</bug>
	<bug id="8214" opendate="2015-01-07 13:47:58" fixdate="2015-01-07 18:51:31" resolution="Fixed">
		<buginformation>
			<summary>Support partial responses in google APIs</summary>
			<description>Would be good to support partial responses in the Google API components:
https://developers.google.com/blogger/docs/3.0/performance#partial-response</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.google.mail.GoogleMailConsumer.java</file>
			<file type="M">org.apache.camel.component.google.calendar.GoogleCalendarProducer.java</file>
			<file type="M">org.apache.camel.component.google.mail.GoogleMailProducer.java</file>
			<file type="M">org.apache.camel.component.google.calendar.GoogleCalendarConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8218" opendate="2015-01-08 02:59:16" fixdate="2015-01-08 06:52:45" resolution="Fixed">
		<buginformation>
			<summary>REST DSL with RestletComponent doesn&amp;apos;t support servelet container</summary>
			<description>"I&amp;amp;apos;m trying out the REST DSL in 2.14.1 and I&amp;amp;apos;m not able to get it to work 
with restlet within a servlet container."
Here is the mail thread about it.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.RestletComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="8217" opendate="2015-01-07 23:34:53" fixdate="2015-01-09 07:09:34" resolution="Fixed">
		<buginformation>
			<summary>camel-xmljson option typeHints does not work</summary>
			<description>Camel core&amp;amp;apos;s model fails to set the option typeHints to the data format implementation.
The data format implementation mixes up option values YES and WITH_PREFIX.</description>
			<version>2.14.1</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.xmljson.XmlJsonOptionsTest.java</file>
			<file type="M">org.apache.camel.model.dataformat.XmlJsonDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.xmljson.XmlJsonDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="8213" opendate="2015-01-07 09:31:00" fixdate="2015-01-09 08:10:39" resolution="Fixed">
		<buginformation>
			<summary>UseOriginalAggregationStrategy is suspicious to NullPointerException</summary>
			<description>The default constructor of UseOriginalAggregationStrategy sets the final field original to null.
In one corner case, the aggregate will dereference this null pointer, as no null-pointer check is made.


    public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {
        if (propagateException) {
            Exception exception = checkException(oldExchange, newExchange);
            if (exception != null) {
                original.setException(exception);
            }
        }
        return original != null ? original : oldExchange;
    }


This potential NPE should be fixed, maybe a unit test be added.</description>
			<version>2.14.1</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.aggregate.UseOriginalAggregationStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="8222" opendate="2015-01-08 20:54:40" fixdate="2015-01-12 12:47:32" resolution="Fixed">
		<buginformation>
			<summary>Jetty component setting responseHeaderSize is impossible</summary>
			<description>This is due to a "copy/paste" bug in: 
org.apache.camel.component.jetty.JettyHttpComponent at line: 691
        if (responseBufferSize != null) 
{
            answer.setResponseBufferSize(responseBufferSize);
        }
        if (responseHeaderSize != null) {
            answer.setResponseBufferSize(responseHeaderSize);
        }

needs to be:

        if (responseBufferSize != null) {
            answer.setResponseBufferSize(responseBufferSize);
        }
        if (responseHeaderSize != null) 
{
            answer.setResponseHeaderSize(responseHeaderSize);
        }

This issue seems to be also in the latest master and in other places where the header size is set.
</description>
			<version>2.14.1</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">8315</link>
		</links>
	</bug>
	<bug id="8233" opendate="2015-01-12 15:46:23" fixdate="2015-01-12 15:52:08" resolution="Fixed">
		<buginformation>
			<summary>Splitter - Option parallelAggregate is not in use when using parallel procession as well</summary>
			<description>If both options are true, then parallel aggregate runs in sequence. It was a missing place in the code that wasn&amp;amp;apos;t changed when the parallelAggregate option was added to Camel</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="8236" opendate="2015-01-13 09:01:36" fixdate="2015-01-13 11:48:05" resolution="Fixed">
		<buginformation>
			<summary>WebSphere class loader detection is too sensitive</summary>
			<description>The DefaultCamelContext attempts to detect an IBM WebSphere application server by a simple test: loader.getClass().getName().startsWith("com.ibm")
This test can introduce very subtle bugs when working with other IBM productes and I suggest to replace it by a list of known class names of WebSphere class loaders. At least, one should add an additional dot in order to avoid matching packages that only start with "com.ibm" such as any "com.ibmfoobar".</description>
			<version>2.14.1</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.WebSpherePackageScanClassResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="8193" opendate="2014-12-30 06:19:12" fixdate="2015-01-14 10:53:35" resolution="Fixed">
		<buginformation>
			<summary>Frequent BlockingOperationExceptions under load</summary>
			<description>I have a class that combines a netty4 consumer with a kafka producer, pulling messages off of a TCP socket and sticking them into kafka for further processing.  While doing some load testing, I started seeing a lot of stack traces like the following:

2014-12-29 19:55:57,517 - [WARN] - from io.netty.util.concurrent.DefaultPromise in Camel Thread #23 - NettyServerTCPWorker
An exception was thrown by org.apache.camel.component.netty4.handlers.ServerResponseFutureListener.operationComplete()
io.netty.util.concurrent.BlockingOperationException: DefaultChannelPromise@4e2727d0(uncancellable)
	at io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:390) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.DefaultChannelPromise.checkDeadLock(DefaultChannelPromise.java:157) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.util.concurrent.DefaultPromise.awaitUninterruptibly(DefaultPromise.java:283) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.DefaultChannelPromise.awaitUninterruptibly(DefaultChannelPromise.java:135) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.DefaultChannelPromise.awaitUninterruptibly(DefaultChannelPromise.java:28) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.util.concurrent.DefaultPromise.syncUninterruptibly(DefaultPromise.java:225) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.DefaultChannelPromise.syncUninterruptibly(DefaultChannelPromise.java:123) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.DefaultChannelPromise.syncUninterruptibly(DefaultChannelPromise.java:28) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at org.apache.camel.component.netty4.NettyHelper.close(NettyHelper.java:121) ~[camel-netty4-2.14.1.jar:2.14.1]
	at org.apache.camel.component.netty4.handlers.ServerResponseFutureListener.operationComplete(ServerResponseFutureListener.java:80) ~[camel-netty4-2.14.1.jar:2.14.1]
	at org.apache.camel.component.netty4.handlers.ServerResponseFutureListener.operationComplete(ServerResponseFutureListener.java:36) ~[camel-netty4-2.14.1.jar:2.14.1]
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:680) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:567) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:406) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.DefaultChannelPromise.trySuccess(DefaultChannelPromise.java:82) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.ChannelOutboundBuffer.safeSuccess(ChannelOutboundBuffer.java:523) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.ChannelOutboundBuffer.remove(ChannelOutboundBuffer.java:247) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.ChannelOutboundBuffer.removeBytes(ChannelOutboundBuffer.java:322) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.socket.nio.NioSocketChannel.doWrite(NioSocketChannel.java:301) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:745) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.flush0(AbstractNioChannel.java:315) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.AbstractChannel$AbstractUnsafe.flush(AbstractChannel.java:713) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.DefaultChannelPipeline$HeadContext.flush(DefaultChannelPipeline.java:1159) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.ChannelHandlerInvokerUtil.invokeFlushNow(ChannelHandlerInvokerUtil.java:165) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.DefaultChannelHandlerInvoker.invokeFlush(DefaultChannelHandlerInvoker.java:355) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:297) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.ChannelOutboundHandlerAdapter.flush(ChannelOutboundHandlerAdapter.java:115) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.ChannelHandlerInvokerUtil.invokeFlushNow(ChannelHandlerInvokerUtil.java:165) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.DefaultChannelHandlerInvoker$16.run(DefaultChannelHandlerInvoker.java:363) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:343) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:356) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:834) [netty-all-4.1.0.Beta3.jar:4.1.0.Beta3]
	at java.lang.Thread.run(Thread.java:745) [na:1.8.0_20]


The documentation for ChannelFuture says "Do not call await() inside ChannelHandler", due to a possible deadlock.  Per the documentation, this results in an IllegalStateException (netty3) or a BlockingOperationException (netty4+).
The javadoc for NettyHelper.close claims to close the channel asynchronously, but that method calls channel.close().syncUninterruptibly(), which blocks waiting for the channel to close and results in the exception under certain conditions. 
The attached patch resolves this issue for both the camel-netty and camel-netty4 components.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.NettyHelper.java</file>
			<file type="M">org.apache.camel.component.netty4.NettyHelper.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">7909</link>
		</links>
	</bug>
	<bug id="8253" opendate="2015-01-17 02:18:58" fixdate="2015-01-17 14:01:30" resolution="Fixed">
		<buginformation>
			<summary>CXFRS Throws IndexOutOfBoundsException for Empty Headers</summary>
			<description>Getting an IndexOutOfBoundsException when empty HTTP request headers are passed to a camelrs web method calls (See stack trace below).
The culprit appears to be related to the check on line 284 of class DefaultCxfRsBinding.java.  
More specifically here:
((List)entry.getValue()).get(0)
Internally the ArrayList class will perform a range check and if the index is greater than or equal to the size of the list the IndexOutOfBoundsException is thrown.  
So we probably want to add an additional check before this one, something like:
((List)entry.getValue()).size() == 0  before the check above, since we probably want to account for empty lists.
java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
	at java.util.ArrayList.rangeCheck(ArrayList.java:604) ~[na:1.7.0_25]
	at java.util.ArrayList.get(ArrayList.java:382) ~[na:1.7.0_25]
	at org.apache.camel.component.cxf.jaxrs.DefaultCxfRsBinding.copyProtocolHeader(DefaultCxfRsBinding.java:284) ~[camel-cxf-2.14.1.jar:2.14.1]
	at org.apache.camel.component.cxf.jaxrs.DefaultCxfRsBinding.populateExchangeFromCxfRsRequest(DefaultCxfRsBinding.java:116) ~[camel-cxf-2.14.1.jar:2.14.1]
	at org.apache.camel.component.cxf.jaxrs.CxfRsInvoker.syncInvoke(CxfRsInvoker.java:123) ~[camel-cxf-2.14.1.jar:2.14.1]
	at org.apache.camel.component.cxf.jaxrs.CxfRsInvoker.performInvocation(CxfRsInvoker.java:59) ~[camel-cxf-2.14.1.jar:2.14.1]
	at org.apache.cxf.service.invoker.AbstractInvoker.invoke(AbstractInvoker.java:97) ~[cxf-core-3.0.2.jar:3.0.2]
	at org.apache.cxf.jaxrs.JAXRSInvoker.invoke(JAXRSInvoker.java:200) [cxf-rt-frontend-jaxrs-3.0.2.jar:3.0.2]
	at org.apache.cxf.jaxrs.JAXRSInvoker.invoke(JAXRSInvoker.java:99) [cxf-rt-frontend-jaxrs-3.0.2.jar:3.0.2]
	at org.apache.cxf.interceptor.ServiceInvokerInterceptor$1.run(ServiceInvokerInterceptor.java:59) ~[cxf-core-3.0.2.jar:3.0.2]
	at org.apache.cxf.interceptor.ServiceInvokerInterceptor.handleMessage(ServiceInvokerInterceptor.java:96) ~[cxf-core-3.0.2.jar:3.0.2]
	at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:307) ~[cxf-core-3.0.2.jar:3.0.2]
	at org.apache.cxf.transport.ChainInitiationObserver.onMessage(ChainInitiationObserver.java:121) ~[cxf-core-3.0.2.jar:3.0.2]
	at org.apache.cxf.transport.http.AbstractHTTPDestination.invoke(AbstractHTTPDestination.java:243) ~[cxf-rt-transports-http-3.0.2.jar:3.0.2]
	at org.apache.cxf.transport.servlet.ServletController.invokeDestination(ServletController.java:223) ~[cxf-rt-transports-http-3.0.2.jar:3.0.2]
	at org.apache.cxf.transport.servlet.ServletController.invoke(ServletController.java:197) ~[cxf-rt-transports-http-3.0.2.jar:3.0.2]
	at org.apache.cxf.transport.servlet.ServletController.invoke(ServletController.java:149) ~[cxf-rt-transports-http-3.0.2.jar:3.0.2]
	at org.apache.cxf.transport.servlet.CXFNonSpringServlet.invoke(CXFNonSpringServlet.java:171) ~[cxf-rt-transports-http-3.0.2.jar:3.0.2]
	at org.apache.cxf.transport.servlet.AbstractHTTPServlet.handleRequest(AbstractHTTPServlet.java:290) ~[cxf-rt-transports-http-3.0.2.jar:3.0.2]
	at org.apache.cxf.transport.servlet.AbstractHTTPServlet.doGet(AbstractHTTPServlet.java:214) ~[cxf-rt-transports-http-3.0.2.jar:3.0.2]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:575) ~[geronimo-servlet_3.0_spec-1.0.jar:1.0]
	at org.apache.cxf.transport.servlet.AbstractHTTPServlet.service(AbstractHTTPServlet.java:265) ~[cxf-rt-transports-http-3.0.2.jar:3.0.2]
	at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:696) ~[jetty-servlet-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1568) ~[jetty-servlet-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:118) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:113) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter.doFilter(RememberMeAuthenticationFilter.java:139) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:154) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:50) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160) ~[spring-security-web-3.2.1.RELEASE.jar:3.2.1.RELEASE]
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:343) ~[spring-web-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:260) ~[spring-web-3.2.5.RELEASE.jar:3.2.5.RELEASE]
	at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1548) ~[jetty-servlet-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:524) ~[jetty-servlet-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:143) ~[jetty-server-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:568) ~[jetty-security-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:221) ~[jetty-server-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1110) ~[jetty-server-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:453) ~[jetty-servlet-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:183) ~[jetty-server-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1044) ~[jetty-server-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141) ~[jetty-server-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:109) ~[jetty-server-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97) ~[jetty-server-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.server.Server.handle(Server.java:459) ~[jetty-server-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:280) ~[jetty-server-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:229) ~[jetty-server-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.io.AbstractConnection$1.run(AbstractConnection.java:505) ~[jetty-io-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:607) ~[jetty-util-9.1.0.v20131115.jar:9.1.0.v20131115]
	at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:536) ~[jetty-util-9.1.0.v20131115.jar:9.1.0.v20131115]
	at java.lang.Thread.run(Thread.java:724) ~[na:1.7.0_25]
</description>
			<version>2.14.1</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.DefaultCxfRsBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.DefaultCxfRsBindingTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8295" opendate="2015-01-29 11:31:01" fixdate="2015-01-29 12:33:08" resolution="Fixed">
		<buginformation>
			<summary>Change Camel Context Name on Camel Spring Boot</summary>
			<description>Cant change the Camel Context Name fully, if the RouteBuilder ran already.
This Code is not working for the JMX MBeans
MyAppConfig.java

@Configuration
public class MyAppConfig {
 
  ...
 
  @Bean
  CamelContextConfiguration contextConfiguration() {
    return new CamelContextConfiguration() {
      @Override
      public void beforeApplicationStart(CamelContext context) {
        ((SpringCamelContext)context).setName("foo");
      }
    };
  }
}


The JMX MBeans are not updated after the RouteBuilde ran:
The Context Name Changed, but the JMX Object Name not.
"foo" != "camel-1"
</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.boot.CamelAutoConfigurationTest.java</file>
			<file type="M">org.apache.camel.spring.boot.CamelConfigurationProperties.java</file>
			<file type="M">org.apache.camel.spring.boot.CamelAutoConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="8289" opendate="2015-01-28 08:44:14" fixdate="2015-01-29 12:38:14" resolution="Fixed">
		<buginformation>
			<summary>camel-netty-http should not try to send out error message to the client if the connection is closed.</summary>
			<description>It could generate lots of annoying warning message when the client connection is closed and camel-netty-http try to send some error message there.</description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.http.handlers.HttpServerMultiplexChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty.http.handlers.HttpServerMultiplexChannelHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="8313" opendate="2015-02-04 12:55:36" fixdate="2015-02-04 13:23:17" resolution="Fixed">
		<buginformation>
			<summary>AddNamespace should not override the element&amp;apos;s namespace</summary>
			<description>I am running a web service in Cxf PAYLOAD mode and in one of the use cases I need to convert the body into Node (Element) and I am doing that by cxfpayload.getBody().get(0)
This makes the namespaces from nsMap to be copied on to the element. While doing so, if the nsMap contains a namespace prefix that is also part of the element&amp;amp;apos;s attribute, it is being overwritten in the addNamespace(Element element, Map&amp;lt;String, String&amp;gt; nsMap) method.
But when same prefix in soap Envelope and body contains different namespace values, that makes the body (XML) invalid.
Here is a sample soap request that contains same namespace prefix ns1 in soap:Envelope and soap:Body but contains different namespace values.


&amp;lt;soapenv:Envelope 
xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
xmlns:ns="http://www.example.com/location/consumerfundbalances/1/" 
xmlns:ns1="http://www.example.com/consumerfundbalances/retrievefundbalances/bi/1/"&amp;gt;
&amp;lt;soapenv:Body&amp;gt;
&amp;lt;ns1:retrieveFundBalances 
xmlns="http://www.example.com/consumerfundbalances/retrievefundbalances/bi/1/"
xmlns:ns1="http://www.example.com/location/consumerfundbalances/1/"&amp;gt;
&amp;lt;retrieveFundBalances&amp;gt;
&amp;lt;fundBalancesRequestIdentifier/&amp;gt;
&amp;lt;/retrieveFundBalances&amp;gt;
&amp;lt;/ns1:retrieveFundBalances&amp;gt;
&amp;lt;/soapenv:Body&amp;gt;
&amp;lt;/soapenv:Envelope&amp;gt;


Now when I convert the payload into DOM Node, here is output XML namespace value for prefix ns1 is being replaced with the envelope.


&amp;lt;ns1:retrieveFundBalances 
xmlns:ns1="http://www.example.com/consumerfundbalances/retrievefundbalances/bi/1/" 
xmlns="http://www.example.com/consumerfundbalances/retrievefundbalances/bi/1/" 
xmlns:ns="http://www.example.com/location/consumerfundbalances/1/"&amp;gt;
&amp;lt;retrieveFundBalances&amp;gt;
&amp;lt;fundBalancesRequestIdentifier/&amp;gt;
&amp;lt;/retrieveFundBalances&amp;gt;
&amp;lt;/ns1:retrieveFundBalances&amp;gt;

</description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfPayload.java</file>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBindingTest.java</file>
			<file type="M">org.apache.camel.component.rest.RestEndpoint.java</file>
			<file type="M">org.apache.camel.model.rest.RestDefinition.java</file>
			<file type="M">org.apache.camel.management.ManagedRestRegistryTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultRestRegistry.java</file>
			<file type="M">org.apache.camel.api.management.mbean.CamelOpenMBeanTypes.java</file>
			<file type="M">org.apache.camel.spi.RestRegistry.java</file>
			<file type="M">org.apache.camel.management.mbean.ManagedRestRegistry.java</file>
		</fixedFiles>
	</bug>
	<bug id="8272" opendate="2015-01-23 11:47:30" fixdate="2015-02-06 11:34:36" resolution="Fixed">
		<buginformation>
			<summary>Camel-box socks proxy implementation is incomplete</summary>
			<description>org.apache.camel.component.box.internal.LoginAuthFlowUI looks for http.route.socks-proxy and sets up a socks proxy for the webClient
org.apache.camel.component.box.internal.BoxClientHelper just passes the httpParams on to the underlying HttpClient but the box api uses a vanilla DefaultHttpClient which doesn&amp;amp;apos;t talk SOCKS.
The attached patch adds socks proxy support to the main restful box transactions.</description>
			<version>2.14.1</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.box.internal.BoxClientHelper.java</file>
			<file type="M">org.apache.camel.component.box.BoxConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="8190" opendate="2014-12-29 17:22:53" fixdate="2015-02-06 13:24:21" resolution="Fixed">
		<buginformation>
			<summary>Kafka producer: partition key is optional, not required by kafka client api</summary>
			<description>In order to send to kafka, one need to construct KeyedMessage. 

 
    public KeyedMessage(String topic, K key, Object partKey, V message) {
        this.topic = topic;
        this.key = key;
        this.partKey = partKey;
        this.message = message;
        class.$init$(this);
        if(topic == null) {
            throw new IllegalArgumentException("Topic cannot be null.");
        }
    }

    public KeyedMessage(String topic, V message) {
        Object var10002 = null;
        Object var10003 = null;
        this(topic, (Object)null, (Object)null, message);
    }

    public KeyedMessage(String topic, K key, V message) {


Looks like only topic is required parameter, but partition key is optional. Also, if key is provided by the user I think is makes sense to propagate it.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.kafka.KafkaProducer.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaProducerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8315" opendate="2015-02-05 07:28:06" fixdate="2015-02-09 05:32:58" resolution="Fixed">
		<buginformation>
			<summary>set Component Option "responseHeaderSize",but no effect</summary>
			<description>I set the option "responseHeaderSize" like :
JettyHttpComponent jettyHttpComponent=(JettyHttpComponent) getContext().getComponent("jetty");
jettyHttpComponent.setResponseHeaderSize(51202);
But there is no effect;then I checked the camel-jetty.jar&amp;amp;apos;s source,and found in JettyHttpComponent.createSocketConnector:
if (responseHeaderSize != null) 
{
            answer.setResponseBufferSize(responseHeaderSize);
        }</description>
			<version>2.12.1</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty8.JettyHttpComponent8.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">8222</link>
		</links>
	</bug>
	<bug id="8327" opendate="2015-02-09 16:13:52" fixdate="2015-02-10 07:29:47" resolution="Fixed">
		<buginformation>
			<summary>ContextTestSupport does not support weaveByType in test cases</summary>
			<description>Update AdviceWithTypeTest test class to contain the below. On Camel-2.13.2 and below the test case would pass, on 2.13.3 and above the test case fails.
AdviceWithTypeTest.java

    public void testUnknownType2() throws Exception {
       
        context.getRouteDefinitions().get(0).adviceWith(context, new AdviceWithRouteBuilder() {
            @Override
            public void configure() throws Exception {
                weaveByType(ChoiceDefinition.class).replace().to("mock:baz");
            }
        });
       
        getMockEndpoint("mock:baz").expectedMessageCount(1);
        template.sendBody("direct:start", "World");
        assertMockEndpointsSatisfied();
    }
 
 
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                // START SNIPPET: e5
                from("direct:start")
                    .transform(simple("Hello ${body}"))
                    .log("Got ${body}")
                    .to("mock:result")
                    .choice()
                    .when(header("foo").isEqualTo("bar"))
                       .to("mock:resultA")
                    .otherwise()
                       .to("mock:resultB");
                // END SNIPPET: e5
            }
        };
    }

</description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ProcessorDefinitionHelperTest.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinitionHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="8226" opendate="2015-01-10 18:02:16" fixdate="2015-02-10 08:30:40" resolution="Fixed">
		<buginformation>
			<summary>Deprecated feature dataSourceRef not working correctly</summary>
			<description>If several sql endpoints are defined using dataSourceRef attribute the latest one will not get dataSourceRef removed in createEndpoint causing validation exception.</description>
			<version>2.14.1</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sql.SqlEndpoint.java</file>
			<file type="M">org.apache.camel.component.sql.SqlComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="8329" opendate="2015-02-10 08:40:05" fixdate="2015-02-10 08:47:50" resolution="Fixed">
		<buginformation>
			<summary>camel-sql - May not propagate headers for operations with no resultset</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Camel-SQL-CamelSqlRetrieveGeneratedKeys-attribute-delete-all-headers-tp5762512.html
</description>
			<version>2.14.1</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sql.SqlProducer.java</file>
			<file type="M">org.apache.camel.component.sql.SqlGeneratedKeysTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8336" opendate="2015-02-11 12:44:49" fixdate="2015-02-11 17:46:26" resolution="Fixed">
		<buginformation>
			<summary>XML Signature: XAdES: Wrong value for attribute "Qualifier" of element CommitmentTypeId</summary>
			<description>If you specify in the XAdES Properties a value of the attribute
attribute "Qualifier" of the element "CommitmentTypeId" then this value is not used, instead wrongly the value of the  DataObjectFormatIdentifierQualifier is used. </description>
			<version>2.15.0</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xmlsecurity.XAdESSignaturePropertiesTest.java</file>
			<file type="M">org.apache.camel.component.xmlsecurity.api.XAdESSignatureProperties.java</file>
		</fixedFiles>
	</bug>
	<bug id="8268" opendate="2015-01-23 07:35:25" fixdate="2015-02-12 06:24:51" resolution="Fixed">
		<buginformation>
			<summary>camel-hbase - The scan method is not thread safe when using a filter list</summary>
			<description>The scan method is not thread safe when using a filter list. A concurrent call on the endpoint will produce wrong values because the same FilterList is used between threads. Cloning the passed filter list solve the problem.</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.hbase.HBaseProducerTest.java</file>
			<file type="M">org.apache.camel.component.hbase.HBaseEndpoint.java</file>
			<file type="M">org.apache.camel.component.hbase.HBaseProducer.java</file>
			<file type="M">org.apache.camel.component.hbase.mapping.HeaderMappingStrategy.java</file>
			<file type="M">org.apache.camel.component.hbase.model.HBaseRow.java</file>
			<file type="M">org.apache.camel.component.hbase.HBaseConstants.java</file>
			<file type="M">org.apache.camel.component.hbase.model.HBaseCell.java</file>
		</fixedFiles>
	</bug>
	<bug id="8338" opendate="2015-02-12 09:17:43" fixdate="2015-02-12 09:40:06" resolution="Fixed">
		<buginformation>
			<summary>ScriptBuilder relies on TCCL to discover engines</summary>
			<description>ScriptBuilder uses javax.script.ScriptEngineManager default ctor, which does 


    public ScriptEngineManager() {
        ClassLoader ctxtLoader = Thread.currentThread().getContextClassLoader();
        init(ctxtLoader);
    }


This means we can only discover script engines that are visible on the TCCL</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.script.ScriptBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="8339" opendate="2015-02-12 10:33:06" fixdate="2015-02-12 14:48:55" resolution="Fixed">
		<buginformation>
			<summary>Usage of camel-mail depends on TCCL</summary>
			<description>javax.mail.Session uses TCCL to load resources


Thread.getContextClassLoader() line: 1432 [local variables unavailable]	
Session$3.run() line: 1199	
AccessController.doPrivileged(PrivilegedAction&amp;lt;T&amp;gt;) line: not available [native method]	
Session.getContextClassLoader() line: 1194	
Session.loadAllResources(String, Class, StreamLoader) line: 1137	
Session.loadProviders(Class) line: 917	
Session.&amp;lt;init&amp;gt;(Properties, Authenticator) line: 216	
Session.getInstance(Properties, Authenticator) line: 242	
MailConfiguration.createJavaMailSender() line: 175	
MailEndpoint.createProducer() line: 71	


Both MailConfiguration &amp;amp; MailProducer seem to rely on this</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailConfiguration.java</file>
			<file type="M">org.apache.camel.component.mail.MailComponent.java</file>
			<file type="M">org.apache.camel.component.mail.MailProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8341" opendate="2015-02-12 12:44:51" fixdate="2015-02-12 15:00:00" resolution="Fixed">
		<buginformation>
			<summary>Usage of camel-rss depends on TCCL</summary>
			<description>

13:38:05,211 WARN  [org.apache.camel.component.rss.RssEntryPollingConsumer] (Camel (camel-2) thread #0 - rss://https://developer.jboss.org/blogs/feeds/posts) Consumer Consumer[rss://https://developer.jboss.org/blogs/feeds/posts?splitEntries=true] failed polling endpoint: Endpoint[rss://https://developer.jboss.org/blogs/feeds/posts?splitEntries=true]. Will try again at next poll. Caused by: [java.lang.ExceptionInInitializerError - null]: java.lang.ExceptionInInitializerError
	at com.sun.syndication.io.SyndFeedInput.build(SyndFeedInput.java:123)
	at org.apache.camel.component.rss.RssUtils.createFeed(RssUtils.java:34) [camel-rss-2.14.1.jar:2.14.1]
	at org.apache.camel.component.rss.RssEntryPollingConsumer.createFeed(RssEntryPollingConsumer.java:54) [camel-rss-2.14.1.jar:2.14.1]
	at org.apache.camel.component.feed.FeedEntryPollingConsumer.poll(FeedEntryPollingConsumer.java:47) [camel-atom-2.14.1.jar:2.14.1]
	at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:187) [camel-core-2.14.1.jar:2.14.1]
	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:114) [camel-core-2.14.1.jar:2.14.1]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [rt.jar:1.8.0_31]
	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308) [rt.jar:1.8.0_31]
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180) [rt.jar:1.8.0_31]
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294) [rt.jar:1.8.0_31]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [rt.jar:1.8.0_31]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [rt.jar:1.8.0_31]
	at java.lang.Thread.run(Thread.java:745) [rt.jar:1.8.0_31]
Caused by: java.lang.NullPointerException
	at java.util.Properties$LineReader.readLine(Properties.java:434) [rt.jar:1.8.0_31]
	at java.util.Properties.load0(Properties.java:353) [rt.jar:1.8.0_31]
	at java.util.Properties.load(Properties.java:341) [rt.jar:1.8.0_31]
	at com.sun.syndication.io.impl.PropertiesLoader.&amp;lt;init&amp;gt;(PropertiesLoader.java:74)
	at com.sun.syndication.io.impl.PropertiesLoader.getPropertiesLoader(PropertiesLoader.java:46)
	at com.sun.syndication.io.impl.PluginManager.&amp;lt;init&amp;gt;(PluginManager.java:54)
	at com.sun.syndication.io.impl.PluginManager.&amp;lt;init&amp;gt;(PluginManager.java:46)
	at com.sun.syndication.feed.synd.impl.Converters.&amp;lt;init&amp;gt;(Converters.java:40)
	at com.sun.syndication.feed.synd.SyndFeedImpl.&amp;lt;clinit&amp;gt;(SyndFeedImpl.java:59)


This is because of rome PropertiesLoader


    public static PropertiesLoader getPropertiesLoader() {
        synchronized(PropertiesLoader.class) {
            PropertiesLoader loader = (PropertiesLoader)
                clMap.get(Thread.currentThread().getContextClassLoader());
            if (loader == null) {
                try {
                    loader = new PropertiesLoader(MASTER_PLUGIN_FILE, EXTRA_PLUGIN_FILE);
                    clMap.put(Thread.currentThread().getContextClassLoader(), loader);
                }
                catch (IOException ex) {
                    throw new RuntimeException(ex);
                }
            }
            return loader;
        }
    }

</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rss.RssEntryPollingConsumer.java</file>
			<file type="M">org.apache.camel.component.rss.RssUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="8355" opendate="2015-02-14 10:30:13" fixdate="2015-02-14 13:40:40" resolution="Fixed">
		<buginformation>
			<summary>Dynamicity flag on Mongodb endpoint run a dropIndex() command on specified collection</summary>
			<description>Using "dynamicity=true" on MongoDb endpoint is running a dropIndex command on the specified collection (CamelMongoDbCollection header), for each exchange going through. </description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mongodb.MongoDbEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="8353" opendate="2015-02-14 08:12:56" fixdate="2015-02-15 08:17:52" resolution="Fixed">
		<buginformation>
			<summary>FileLockExclusiveReadLockStrategy - Should defer closing channel till release lock</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/FileLockExclusiveReadLockStrategy-doesn-t-hold-lock-and-error-on-commit-tp5762668.html
The acquire lock method closes the channel if it acquired the lock, but that would make the lock invalid. Instead the channel should remain open and only closed when the lock is released.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.component.file.strategy.MarkerFileExclusiveReadLockStrategy.java</file>
			<file type="M">org.apache.camel.component.file.strategy.FileLockExclusiveReadLockStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="8231" opendate="2015-01-12 12:23:54" fixdate="2015-02-15 08:43:41" resolution="Fixed">
		<buginformation>
			<summary>StompEndPoint does not throw exceptions in case of the underlying connection broken at the time of sending a message</summary>
			<description>At the time of  sending the message if the message broker (Apollo is used in this case) is down then no exception is raised from the send method of StompEndpoint.  The underlying connection (stomp jms connection) has the error caught and handled. Since the Stompendpoint does not use the CallBack to get notified of the underlying issue, the message sending is assumed successful. </description>
			<version>2.14.1</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.stomp.StompProducer.java</file>
			<file type="M">org.apache.camel.component.stomp.StompEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="7914" opendate="2014-10-14 18:53:33" fixdate="2015-02-15 10:33:40" resolution="Fixed">
		<buginformation>
			<summary>MQTT Endpoint disconnects on failure. Does not reconnect</summary>
			<description>When an error occurs in the Camel MQTT endpoint, the CallbackConnection onFailure callback simply disconnects the connection.
At that point there doesn&amp;amp;apos;t seem to be any mechanism to reconnect to the broker.

            public void onFailure(Throwable value) {
                connection.disconnect(new Callback&amp;lt;Void&amp;gt;() {
                    public void onSuccess(Void value) {
                    }

                    public void onFailure(Throwable e) {
                        LOG.debug("Failed to disconnect from " + configuration.getHost() + ". This exception is ignored.", e);
                    }
                });
            }

</description>
			<version>2.14.0</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mqtt.MQTTConfiguration.java</file>
			<file type="M">org.apache.camel.component.mqtt.MQTTEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="8088" opendate="2014-11-27 17:48:41" fixdate="2015-02-15 11:23:38" resolution="Fixed">
		<buginformation>
			<summary>FTP can wait indefinitely when connection timeout occurs during connect</summary>
			<description>In our production system we have seen cases where the FTP thread is waiting for a response indefinitely despite having set soTimeout on the connection. On investigation this is due to a condition that can occur where a socket is able to connect yet a firewall or the ilk then blocks further traffic.
This can be over come by setting the property ftpClient.defaultTimeout to a non-zero value.
It should be the case where if upon initial socket connection no response occurs that the socket should be deemed dead, however this is not the case.
When the following exception is thrown during initial connect to an FTP server, after the socket has connected but whilst awaiting the inital reply it can leave the RemoteFileProducer in a state where it is connected but not logged in and no attempt reconnect is attempted, if the soTimeout as set by ftpClient.defaultTimeout is set to zero then it can cause a subsequent command will wait for a reply indefinitely.

Caused by: java.io.IOException: Timed out waiting for initial connect reply
	at org.apache.commons.net.ftp.FTP._connectAction_(FTP.java:389) ~[commons-net-3.1.jar:3.1]
	at org.apache.commons.net.ftp.FTPClient._connectAction_(FTPClient.java:796) ~[commons-net-3.1.jar:3.1]
	at org.apache.commons.net.SocketClient.connect(SocketClient.java:172) ~[commons-net-3.1.jar:3.1]
	at org.apache.commons.net.SocketClient.connect(SocketClient.java:192) ~[commons-net-3.1.jar:3.1]
	at org.apache.camel.component.file.remote.FtpOperations.connect(FtpOperations.java:95) ~[camel-ftp-2.13.1.jar:2.13.1]


The RemoteFileProducer will enter this block as the loggedIn state has not yet been reached, however the existing broken socket is reused.


        // recover by re-creating operations which should most likely be able to recover
        if (!loggedIn) {
            log.debug("Trying to recover connection to: {} with a fresh client.", getEndpoint());
            setOperations(getEndpoint().createRemoteFileOperations());
            connectIfNecessary();
        }


Yet the connectIfNecessary() method will return immediately since the check condition is based on socket connection and takes no account of whether login was achieved so the &amp;amp;apos;dead&amp;amp;apos; socket is reused.


    protected void connectIfNecessary() throws GenericFileOperationFailedException {
        // This will be skipped when loggedIn = false and the socket is connected
        if (!getOperations().isConnected()) {
            log.debug("Not already connected/logged in. Connecting to: {}", getEndpoint());
            RemoteFileConfiguration config = getEndpoint().getConfiguration();
            loggedIn = getOperations().connect(config);
            if (!loggedIn) {
                return;
            }
            log.info("Connected and logged in to: " + getEndpoint());
        }
    }


A dirty test that blocks of this blocking condition:


package ftp;

import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.JndiRegistry;
import org.apache.camel.test.junit4.CamelTestSupport;
import org.apache.commons.net.ftp.FTPClient;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.mockftpserver.fake.FakeFtpServer;
import org.mockito.Mockito;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;

import javax.net.SocketFactory;

import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class FtpInitialConnectTimeoutTest extends CamelTestSupport {

  private static final int CONNECT_TIMEOUT = 11223;

  /**
   * Create the answer for the socket factory that causes a SocketTimeoutException to occur in connect.
   */
  private static class SocketAnswer implements Answer&amp;lt;Socket&amp;gt; {
    @Override
    public Socket answer(InvocationOnMock invocation) throws Throwable {
      final Socket socket = Mockito.spy(new Socket());
      final AtomicBoolean timeout = new AtomicBoolean();

      try {
        doAnswer(new Answer&amp;lt;InputStream&amp;gt;() {
          @Override
          public InputStream answer(InvocationOnMock invocation) throws Throwable {
            final InputStream stream = (InputStream) invocation.callRealMethod();

            InputStream inputStream = new InputStream() {
              @Override
              public int read() throws IOException {
                if (timeout.get()) {
                  // emulate a timeout occuring in _getReply()
                  throw new SocketTimeoutException();
                }
                return stream.read();
              }
            };

            return inputStream;
          }
        }).when(socket).getInputStream();
      } catch (IOException ignored) {
      }

      try {
        doAnswer(new Answer() {
          @Override
          public Object answer(InvocationOnMock invocation) throws Throwable {
            if ((Integer) invocation.getArguments()[0] == CONNECT_TIMEOUT) {
              // setting of connect timeout
              timeout.set(true);
            } else {
              // non-connect timeout
              timeout.set(false);
            }
            return invocation.callRealMethod();
          }
        }).when(socket).setSoTimeout(anyInt());
      } catch (SocketException e) {
        throw new RuntimeException(e);
      }
      return socket;
    }
  }

  private FakeFtpServer fakeFtpServer;

  @Override
  @Before
  public void setUp() throws Exception {
    fakeFtpServer = new FakeFtpServer();
    fakeFtpServer.setServerControlPort(0);
    fakeFtpServer.start();

    super.setUp();
  }

  @Override
  @After
  public void tearDown() throws Exception {
    super.tearDown();
    if (fakeFtpServer != null) {
      fakeFtpServer.stop();
    }
  }

  @Test
  public void testName() throws Exception {
    sendBody("direct:start", "test");
  }

  private FTPClient mockedClient() throws IOException {
    FTPClient client = new FTPClient();
    client.setSocketFactory(createSocketFactory());
    return client;
  }

  private SocketFactory createSocketFactory() throws IOException {
    SocketFactory socketFactory = mock(SocketFactory.class);
    when(socketFactory.createSocket()).thenAnswer(new SocketAnswer());
    return socketFactory;
  }

  @Override
  protected JndiRegistry createRegistry() throws Exception {
    JndiRegistry registry = super.createRegistry();
    registry.bind("mocked", mockedClient());
    return registry;
  }

  @Override
  protected RouteBuilder createRouteBuilder() throws Exception {
    return new RouteBuilder() {
      @Override
      public void configure() throws Exception {
        from("direct:start")
            .to("ftp://localhost:" + fakeFtpServer.getServerControlPort()
                + "?ftpClient=#mocked"
                + "&amp;amp;soTimeout=1234&amp;amp;"
                + "connectTimeout=" + CONNECT_TIMEOUT);
      }
    };
  }
}

</description>
			<version>2.13.3</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7739" opendate="2014-08-22 16:42:09" fixdate="2015-02-15 11:34:57" resolution="Fixed">
		<buginformation>
			<summary>camel-mail poller onCompletion Folder is not Open</summary>
			<description>I think I found a bug in Camel OncompletionProcessor code when used with a Mail poller route and onCompletion.
The error occurs when the Log level is set to DEBUG or TRACE. In that case the logger tries to call the toString() method of the DefaultExchange class which calls org.apache.camel.component.mail.MailMessage.toString().
At that stage, the POP3Folder is already closed.
A very obvious (but not elegant) solution, would be to add a try-catch block to the log instruction. 
Otherwise, I think a good solution is to change the DefaultExchange#toString method.
Here is the exception that occured:
java.lang.IllegalStateException: Folder is not Open
	at com.sun.mail.pop3.POP3Folder.checkOpen(POP3Folder.java:551)
	at com.sun.mail.pop3.POP3Folder.getProtocol(POP3Folder.java:581)
	at com.sun.mail.pop3.POP3Message.loadHeaders(POP3Message.java:606)
	at com.sun.mail.pop3.POP3Message.getHeader(POP3Message.java:383)
	at javax.mail.internet.MimeMessage.getAddressHeader(MimeMessage.java:701)
	at javax.mail.internet.MimeMessage.getFrom(MimeMessage.java:362)
	at org.apache.camel.component.mail.MailUtils.dumpMessage(MailUtils.java:106)
	at org.apache.camel.component.mail.MailMessage.toString(MailMessage.java:49)
	at java.lang.String.valueOf(String.java:2854)
	at java.lang.StringBuilder.append(StringBuilder.java:128)
	at org.apache.camel.impl.DefaultExchange.toString(DefaultExchange.java:81)
	at org.slf4j.helpers.MessageFormatter.safeObjectAppend(MessageFormatter.java:304)
	at org.slf4j.helpers.MessageFormatter.deeplyAppendParameter(MessageFormatter.java:276)
	at org.slf4j.helpers.MessageFormatter.arrayFormat(MessageFormatter.java:230)
	at ch.qos.logback.classic.spi.LoggingEvent.&amp;lt;init&amp;gt;(LoggingEvent.java:115)
	at ch.qos.logback.classic.Logger.buildLoggingEventAndAppend(Logger.java:439)
	at ch.qos.logback.classic.Logger.filterAndLog_1(Logger.java:413)
	at ch.qos.logback.classic.Logger.debug(Logger.java:506)
	at org.apache.camel.processor.OnCompletionProcessor$OnCompletionSynchronization$1.call(OnCompletionProcessor.java:178)
	at org.apache.camel.processor.OnCompletionProcessor$OnCompletionSynchronization$1.call(OnCompletionProcessor.java:176)
	at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)
	at java.util.concurrent.FutureTask.run(FutureTask.java:166)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
	at java.lang.Thread.run(Thread.java:722)</description>
			<version>2.13.0</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailMessage.java</file>
		</fixedFiles>
	</bug>
	<bug id="7488" opendate="2014-06-07 11:11:00" fixdate="2015-02-15 14:17:12" resolution="Fixed">
		<buginformation>
			<summary>PropertiesComponent gets initialized by util:constant</summary>
			<description>Using BridgePropertyPlaceholderConfigurer &amp;amp; Spring util constant namespace  to reference a static field, the Properties Component gets initialized with this constant.
camelContext.xml

&amp;lt;util:constant static-field="anypackage.CONSTANT_1"/&amp;gt;

&amp;lt;bean id="bridgePropertyPlaceHolder" class="org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer"&amp;gt;
    &amp;lt;property name="locations"&amp;gt;
      &amp;lt;list&amp;gt;
        &amp;lt;value&amp;gt;classpath:test.properties&amp;lt;/value&amp;gt;
      &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;camel:camelContext xmlns="http://camel.apache.org/schema/spring"&amp;gt;
    &amp;lt;camel:route&amp;gt;
      &amp;lt;camel:from uri="direct://ignore" /&amp;gt;
      &amp;lt;camel:setBody&amp;gt;
        &amp;lt;camel:simple&amp;gt;{{testProperty}}&amp;lt;/camel:simple&amp;gt;
      &amp;lt;/camel:setBody&amp;gt;
      &amp;lt;camel:to uri="mock://ignore" /&amp;gt;
    &amp;lt;/camel:route&amp;gt;
&amp;lt;/camel:camelContext&amp;gt;   


Will produce following Stacktrace (constant contained &amp;amp;apos;&amp;gt;&amp;gt;This will be loaded as location; but I am simply a constant&amp;lt;&amp;lt;&amp;amp;apos;):

Caused by: java.io.FileNotFoundException: Properties file &amp;gt;&amp;gt;This will be loaded as location; but I am simply a constant&amp;lt;&amp;lt; not found in classpath
	at org.apache.camel.component.properties.DefaultPropertiesResolver.loadPropertiesFromClasspath(DefaultPropertiesResolver.java:96)
	at org.apache.camel.component.properties.DefaultPropertiesResolver.resolveProperties(DefaultPropertiesResolver.java:55)
	at org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer.resolveProperties(BridgePropertyPlaceholderConfigurer.java:118)
	at org.apache.camel.component.properties.PropertiesComponent.parseUri(PropertiesComponent.java:131)
	at org.apache.camel.component.properties.PropertiesComponent.parseUri(PropertiesComponent.java:117)
	at org.apache.camel.impl.DefaultCamelContext.resolvePropertyPlaceholders(DefaultCamelContext.java:1223)
	at org.apache.camel.model.ProcessorDefinition.resolvePropertyPlaceholders(ProcessorDefinition.java:571)


My current workaround was to specify propertyPlaceholder with empty location in  camelContext ...
camelContext.xml

&amp;lt;!-- same as above --&amp;gt;
&amp;lt;camel:camelContext xmlns="http://camel.apache.org/schema/spring"&amp;gt;
    &amp;lt;!-- location and id are mandatory --&amp;gt;
    &amp;lt;camel:propertyPlaceholder id="stupidMandatoryId" location=""/&amp;gt;
    &amp;lt;camel:route&amp;gt;
      &amp;lt;camel:from uri="direct://ignore" /&amp;gt;
      &amp;lt;camel:setBody&amp;gt;
        &amp;lt;camel:simple&amp;gt;{{testProperty}}&amp;lt;/camel:simple&amp;gt;
      &amp;lt;/camel:setBody&amp;gt;
      &amp;lt;camel:to uri="mock://ignore" /&amp;gt;
    &amp;lt;/camel:route&amp;gt;
&amp;lt;/camel:camelContext&amp;gt;   

</description>
			<version>2.13.0</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.CamelContextHelper.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">7496</link>
		</links>
	</bug>
	<bug id="7821" opendate="2014-09-15 13:50:35" fixdate="2015-02-15 15:20:00" resolution="Fixed">
		<buginformation>
			<summary>BridgePropertyPlaceholderConfigurer fails to use custom PropertiesParser</summary>
			<description>A BridgePropertyPlaceholderConfigurer configured to use a custom PropertiesParser like this:


  &amp;lt;bean id="bridgePropertyPlaceholder" class="org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer"
      p:location="classpath:application.properties"
      p:parser-ref="jasyptParser" /&amp;gt;


fails to actually use the parser to parse properties.
It seems that org.apache.camel.spring.CamelContextFactoryBean#initPropertyPlaceholder, which is called from afterPropertiesSet, overwrites the custom parser with the default parser from the properties component (on line 279).</description>
			<version>2.13.2</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer.java</file>
		</fixedFiles>
	</bug>
	<bug id="7144" opendate="2014-01-21 10:31:43" fixdate="2015-02-15 16:58:29" resolution="Fixed">
		<buginformation>
			<summary>Blueprint route not shutdown when using OSGi service processor</summary>
			<description>The route description uses .toString() when shutting down. This causes the shutdown to block if a proxied OSGi service is used as processor (in XML DSL &amp;lt;process ref="osgiService/&amp;gt;) and the service is not present at the time the route is shut down.
See http://camel.465427.n5.nabble.com/Blueprint-route-not-shutdown-when-using-OSGi-service-processor-td5746114.html</description>
			<version>2.12.2</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ProcessDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="8359" opendate="2015-02-16 01:54:51" fixdate="2015-02-16 02:06:36" resolution="Fixed">
		<buginformation>
			<summary>LinkedIn consumer endpoints have to specify an empty &amp;apos;fields&amp;apos; parameter</summary>
			<description>LinkedIn consumer endpoints that take a &amp;amp;apos;fields&amp;amp;apos; parameter should not have to specify an empty value for the optional field. 
This field is handled for producer endpoints as its default value is set in LinkedInEndpoint.interceptProperties().
This field should be automatically set to null if the api method requires it in LinkedInConsumer.interceptPropertyNames(). </description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.linkedin.PeopleResourceIntegrationTest.java</file>
			<file type="M">org.apache.camel.component.linkedin.LinkedInConsumer.java</file>
			<file type="M">org.apache.camel.component.linkedin.LinkedInEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="8358" opendate="2015-02-16 00:49:27" fixdate="2015-02-16 23:27:19" resolution="Fixed">
		<buginformation>
			<summary>Avoid using Olingo2 library classes from &amp;apos;core&amp;apos; package as it has been designated internal and not part of the API exposed using OSGi headers</summary>
			<description>Olingo2 library classes in &amp;amp;apos;core&amp;amp;apos; are internal and should not be used. Even though the URI parser classes should really have been exposed through the public API. This includes a public URI parser URIInfo exposed through the api package, but its implementation URIInfoImpl is part of core and hence not exposed. 
This does not affect any public component classes in the Olingo2 component.  
See OLINGO-420. </description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.olingo2.api.impl.Olingo2AppImpl.java</file>
			<file type="M">org.apache.camel.component.olingo2.Olingo2AppIntegrationTest.java</file>
			<file type="M">org.apache.camel.component.olingo2.Olingo2Configuration.java</file>
			<file type="M">org.apache.camel.component.olingo2.api.impl.AbstractFutureCallback.java</file>
			<file type="M">org.apache.camel.component.olingo2.api.Olingo2AppIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8352" opendate="2015-02-13 22:48:25" fixdate="2015-02-18 07:20:41" resolution="Fixed">
		<buginformation>
			<summary>NettyServerBossPoolBuilder build() method is package-protected</summary>
			<description>The user documentation for camel-netty4 discusses creating worker and boss thread pools that are shared across camel-netty4 consumers.  I am trying to do this, but discovered that the NettyServerBossPoolBuilder.build() method is package-protected, and I am therefore unable to use this builder to create the shared boss pool.  Unit tests pass because the tests are within the same package, but the method needs to be public for anyone else to use.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.NettyServerBossPoolBuilder.java</file>
			<file type="M">org.apache.camel.component.netty.NettyClientBossPoolBuilder.java</file>
			<file type="M">org.apache.camel.component.netty.NettyServerBossPoolBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="8369" opendate="2015-02-17 22:27:38" fixdate="2015-02-18 08:38:32" resolution="Fixed">
		<buginformation>
			<summary>weaveAddLast does not work property when route ends with a split</summary>
			<description>When using AdviceWithRouteBuilder to modify a route definition, weaveAddLast does not work correctly when the route ends with a split.  It appears to add the additional components within the split, not afterwards.
See attached testcase.
Adding a trivial operation after the split in the original route builder fixes it.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.AdviceWithBuilder.java</file>
			<file type="M">org.apache.camel.builder.AdviceWithTasks.java</file>
			<file type="M">org.apache.camel.builder.AdviceWithRouteBuilder.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinitionHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="8382" opendate="2015-02-20 10:07:22" fixdate="2015-02-20 10:33:02" resolution="Fixed">
		<buginformation>
			<summary>dumpRoutesAsXml should resolve "from" endpoint property values as with "to" endpoint URI</summary>
			<description>We have defined our routes with property keys for all endpoints ("from" and "to"). When using the dumpRoutesAsXml operation we see that the "from uri" value is the property key, however the "to uri" has been resolved to the actual property value. 
For example, given a RouteBuilder like the following:


        from("{{route1.uri}}")
            .routeId("myRoute")
            .to("{{route2.uri}}")


dumpRoutesAsXml outputs the following:


    &amp;lt;route customId="true" id="myRoute"&amp;gt;
        &amp;lt;from uri="{{route1.uri}}"/&amp;gt;
        &amp;lt;to uri="jms:myapp.route2" id="to2"/&amp;gt;
    &amp;lt;/route&amp;gt;


where "myapp.route2" is the resolved value of "route2.uri".
Perhaps there is a good reason for this behaviour, but it appears to be inconsistent.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.properties.PropertiesComponentEndpointTest.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.model.DataFormatDefinition.java</file>
			<file type="M">org.apache.camel.model.RouteDefinitionHelper.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinitionHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="8241" opendate="2015-01-13 20:55:00" fixdate="2015-02-22 10:51:24" resolution="Fixed">
		<buginformation>
			<summary>Exec command failures using Java 8 on Unix</summary>
			<description>I&amp;amp;apos;m attaching a test case that shows an issue I&amp;amp;apos;ve been running into with the exec command since updating my environment to Java 8. It appears that I&amp;amp;apos;m running into a race condition where a stream is sometimes closed prematurely before DefaultExecutor has a chance to close it, causing DefaultExecCommandExecutor to throw and exit (even though the command did execute properly). I&amp;amp;apos;ve tested this against the updated version of commons-exec as well just to make sure this hasn&amp;amp;apos;t somehow been fixed in that library.
Please note that the attached test doesn&amp;amp;apos;t always fail; you may need to run it a few times before the error will show up.</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.exec.impl.DefaultExecCommandExecutor.java</file>
			<file type="M">org.apache.camel.component.exec.ExecDefaultExecutor.java</file>
			<file type="M">org.apache.camel.component.exec.ExecProducer.java</file>
			<file type="M">org.apache.camel.component.exec.ExecEndpointTest.java</file>
			<file type="M">org.apache.camel.component.exec.ExecEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="8395" opendate="2015-02-23 20:41:41" fixdate="2015-02-23 22:30:04" resolution="Fixed">
		<buginformation>
			<summary>Handle empty Salesforce picklist types</summary>
			<description>Salesforce inbuilt/user customizable picklist types may be empty with no values defined. This breaks sobject-picklist.vm. It should instead generate an empty Enum with no values. </description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.maven.CamelSalesforceMojo.java</file>
		</fixedFiles>
	</bug>
	<bug id="8409" opendate="2015-02-26 04:54:26" fixdate="2015-02-26 09:13:26" resolution="Fixed">
		<buginformation>
			<summary>Kafka producer: when no message key specified, use partition key</summary>
			<description>CAMEL-8190 has introduced behavior that has the potential to break existing code (hence setting to Critical priority so this can be fixed prior to 2.14.2/2.15.0 releases).  It broke my code (using 2.14.2-SNAPSHOT builds) in development and staging, and I didn&amp;amp;apos;t notice the problem until tonight.
Prior to CAMEL-8190, the value of the KafkaConstants.PARTITION_KEY header was used for both the key and partitionKey of the kafka KeyedMessage.  My downstream consumers depended on this for the correct key of the consumed message.  CAMEL-8190, changed things so the key is set only via the KafkaConstants.KEY header, and since my code didn&amp;amp;apos;t set that header, the key started coming through as null to downstream consumers.
I propose the following to fix this (will attach a patch shortly):

If both KEY and PARTITION_KEY are specified, no change from CAMEL-8190
If just one is specified, call the KeyedMessage 3-argument constructor with the value (uses the value for both key and partitionKey)
If neither are specified, pass null for both...but IMHO, a warning should be logged, as it seems unlikely that the user knowingly omitted both values.

</description>
			<version>2.14.2</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.kafka.KafkaProducer.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaProducerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8411" opendate="2015-02-26 12:30:59" fixdate="2015-02-26 12:33:23" resolution="Fixed">
		<buginformation>
			<summary>camel-netty-http - Checking for host header is invalid</summary>
			<description>See
http://camel.465427.n5.nabble.com/Camel-Netty-Http-HttpHeaders-case-sensitive-tp5763157.html
The names() should be removed as it transfers the headers to a linked hash map instead of checking directly using the netty http headers which is case insensitive.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.http.handlers.HttpServerChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty.http.handlers.HttpServerChannelHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="8401" opendate="2015-02-25 01:06:08" fixdate="2015-02-26 13:02:08" resolution="Fixed">
		<buginformation>
			<summary>CamelOverruleFileName does not work correctly for remote file endpoints</summary>
			<description>According to the docs, when using CamelOverruleFileName, the original CamelFileName should be restored after the overruling name is used once.  This is not working when using a remote file endpoint, such as FTP.
From the description of CAMEL-5269, it seems like this worked once, but it doesn&amp;amp;apos;t seem to anymore.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileProduceOverruleOnlyOnceTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8201" opendate="2014-12-31 11:00:32" fixdate="2015-02-28 09:21:53" resolution="Fixed">
		<buginformation>
			<summary>NPE with language:ruby and concurrentConsumers </summary>
			<description>See http://camel.465427.n5.nabble.com/NPE-with-language-ruby-and-concurrentConsumers-td5759703.html for details.
By running git bisect, it reports the first bad commit was:
f66375e91e2755e956c1527752c255aa2d0f8c42 is the first bad commit
commit f66375e91e2755e956c1527752c255aa2d0f8c42
Author: Willem Jiang &amp;lt;ningjiang@apache.org&amp;gt;
Date:   Fri Jul 26 16:46:50 2013 +0800
 CAMEL-6559 fixed the script builder synchronized the operation of evaluateScript issue
:040000 040000 148db9cc9e521c7951be27c1416c7218880d10cf 5f55cbb6798f9a0f8477348708360a7a09a98f5e M	components</description>
			<version>2.12.5</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.script.RubyScriptTextTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">8188</link>
		</links>
	</bug>
	<bug id="8417" opendate="2015-02-28 16:07:49" fixdate="2015-03-02 07:19:49" resolution="Fixed">
		<buginformation>
			<summary>RAW_TOKEN_START and RAW_TOKEN_END not removed when query parameter occurs multiple times</summary>
			<description>The tokens RAW_TOKEN_START ("RAW(") and RAW_TOKEN_END (")") are not removed when the parameter value is a list. The bug is in "resolveRawParameterValues" in org.apache.camel.util.UriSupport (lines 323, 324):


                String value = entry.getValue().toString();
                if (value.startsWith(RAW_TOKEN_START) &amp;amp;&amp;amp; value.endsWith(RAW_TOKEN_END)) {


This does not work when entry.getValue() contains a list.</description>
			<version>2.14.1</version>
			<fixedVersion>2.13.4, 2.14.3, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.URISupport.java</file>
			<file type="M">org.apache.camel.issues.EndpointWithRawUriParameterTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8424" opendate="2015-03-02 17:35:45" fixdate="2015-03-02 18:32:40" resolution="Fixed">
		<buginformation>
			<summary>Transaction being propagated ignoring REQUIRES_NEW when using direct component</summary>
			<description>I found that when we are using exactly same propagation policy bean in different routes used together with "direct" component, then TransactionErrorHandler always propagates current transaction even if our policy is "PROPAGATION_REQUIRES_NEW".
The failing code is:


    public TransactionErrorHandler(CamelContext camelContext, Processor output, CamelLogger logger, 
            Processor redeliveryProcessor, RedeliveryPolicy redeliveryPolicy, ExceptionPolicyStrategy exceptionPolicyStrategy,
            TransactionTemplate transactionTemplate, Predicate retryWhile, ScheduledExecutorService executorService,
            LoggingLevel rollbackLoggingLevel) {

        super(camelContext, output, logger, redeliveryProcessor, redeliveryPolicy, null, null, false, retryWhile, executorService);
        setExceptionPolicy(exceptionPolicyStrategy);
        this.transactionTemplate = transactionTemplate;
        this.rollbackLoggingLevel = rollbackLoggingLevel;
        this.transactionKey = ObjectHelper.getIdentityHashCode(transactionTemplate);
    }

    @Override
    public void process(Exchange exchange) throws Exception {
        // we have to run this synchronously as Spring Transaction does *not* support
        // using multiple threads to span a transaction
        if (exchange.getUnitOfWork().isTransactedBy(transactionKey)) {
            // already transacted by this transaction template
            // so lets just let the error handler process it
            processByErrorHandler(exchange);
        } else {
            // not yet wrapped in transaction so lets do that
            // and then have it invoke the error handler from within that transaction
            processInTransaction(exchange);
        }
    }


So then for each policy there is a hash code created, which then is used to verify whether current route is already transacted by this transaction policy.
This makes "PROPAGATION_REQUIRES_NEW" ignored when used with "direct" component.
So for example:


                from("activemq:queue:start").routeId("route1")
                        .transacted("PROPAGATION_REQUIRES_NEW")
                        .setExchangePattern(ExchangePattern.InOnly)
                        .to("activemq:queue:result1")
                        .to("direct:route2")
                        .throwException(new RuntimeException("Expected!"));

                from("direct:route2").routeId("route2")
                        .transacted("PROPAGATION_REQUIRES_NEW")
                        .setExchangePattern(ExchangePattern.InOnly)
                        .to("activemq:queue:result2");


The above route suppose to work in 2 different transactions, as our propagation is REQUIRES_NEW for both of them. But due to hash code verification and optimisation, route2 will participate in same transaction as route1 instead of new.
This is rather buggy.
Will create pull request in minutes.</description>
			<version>2.10.7</version>
			<fixedVersion>2.13.4, 2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.spi.TransactionErrorHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="8425" opendate="2015-03-02 18:27:15" fixdate="2015-03-02 18:54:12" resolution="Fixed">
		<buginformation>
			<summary>Handle invalid client id gracefully in Camel LinkedIn component</summary>
			<description>LinkedIn component uses HtmlUnit to perform a login and authorization on user&amp;amp;apos;s behalf for OAuth. LinkedIn returns an error message instead of a login page on an invalid client id, which the component should handle gracefully, instead of the missing HTML element it throws currently. c</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.linkedin.api.LinkedInOAuthRequestFilter.java</file>
			<file type="M">org.apache.camel.component.linkedin.api.AbstractResourceIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8426" opendate="2015-03-02 18:27:38" fixdate="2015-03-02 19:08:43" resolution="Fixed">
		<buginformation>
			<summary>Handle invalid client id gracefully in Camel Box component</summary>
			<description>Box component uses HtmlUnit to perform a login and authorization on user&amp;amp;apos;s behalf for OAuth. Box.com returns an error message instead of a login page on an invalid client id, which the component should handle gracefully, instead of the missing HTML element it throws currently. </description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.box.internal.LoginAuthFlowUI.java</file>
		</fixedFiles>
	</bug>
	<bug id="8356" opendate="2015-02-14 12:05:33" fixdate="2015-03-03 02:06:07" resolution="Fixed">
		<buginformation>
			<summary>IOConverter.toInputStream(file, charset) returns strange behaving stream</summary>
			<description>Calling IOConverter.toInputStream with either UTF-8 or ISO-8859-1 returns a stream that behaves strange on non-ascii-characters:

putting this stream into an InputStreamReader will return false encoded characters
a naive new BufferedReader(new InputStreamReader(new FileInputStream(file), charset)) will return the correctly encoded characters.

I will attach some unit tests for this case.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.IOConverterCharsetTest.java</file>
			<file type="M">org.apache.camel.converter.IOConverter.java</file>
			<file type="M">org.apache.camel.jsonpath.JsonPathEngine.java</file>
		</fixedFiles>
		<links>
			<link type="Blocker" description="blocks">8346</link>
		</links>
	</bug>
	<bug id="7644" opendate="2014-07-28 16:39:53" fixdate="2015-03-03 09:12:32" resolution="Fixed">
		<buginformation>
			<summary>Scala camel DSL creates numerous DefaultCamelContext instances</summary>
			<description>Since the camel DSL is invoked prior to `.addRoutesToCamelContext(CamelContext)` being invoked there is no camel context set on the delegate java RouteBuilder which causes it to create a new context when the first dsl method is invoked.
With the implementation of CAMEL-7327 introduced in 2.13.1 which stores created camel contexts in a set in `Container.Instance#CONTEXT`; this causes instances of DefaultCamelContext to be leaked, they are never removed from the static set. This is especially aparrent during unit testing.
The following test shows that an additional context is registered for the scala route builder as opposed to java. Verification of the leak can be requires profiler and capturing of heap after termination of the test case (in ParentRunner.java).


package org.apache.camel.scala.dsl.builder;

import com.google.common.collect.Sets;

import org.apache.camel.CamelContext;
import org.apache.camel.ProducerTemplate;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultCamelContext;
import org.apache.camel.spi.Container;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.lang.ref.WeakReference;
import java.util.Set;

import static org.junit.Assert.assertEquals;

public class BuggyScalaTest implements Container {

  Set&amp;lt;CamelContext&amp;gt; managed = Sets.newHashSet();

  @Before
  public void setUp() throws Exception {
    Container.Instance.set(this);
  }

  @After
  public void tearDown() throws Exception {
    Container.Instance.set(null);
  }

  @Test
  public void testNameJava() throws Exception {
    DefaultCamelContext defaultCamelContext = new DefaultCamelContext();
    defaultCamelContext.addRoutes(new RouteBuilder() {
      @Override
      public void configure() throws Exception {
        from("direct:start").log("a message");
      }
    });
    defaultCamelContext.start();

    ProducerTemplate producerTemplate = defaultCamelContext.createProducerTemplate();
    producerTemplate.start();
    producerTemplate.sendBody("direct:start", "");
    producerTemplate.stop();
    defaultCamelContext.stop();

    assertEquals(1, managed.size());
  }

  @Test
  public void testNameScala() throws Exception {
    DefaultCamelContext defaultCamelContext = new DefaultCamelContext();
    defaultCamelContext.addRoutes(new SimpleRouteBuilder());
    defaultCamelContext.start();

    ProducerTemplate producerTemplate = defaultCamelContext.createProducerTemplate();
    producerTemplate.start();
    producerTemplate.sendBody("direct:start", "");
    producerTemplate.stop();
    defaultCamelContext.stop();

    assertEquals(1, managed.size()); // will equal 2
  }

  @Override
  public void manage(CamelContext camelContext) {
    managed.add(camelContext);
  }
}




  package org.apache.camel.scala.dsl.builder

  import org.apache.camel.scala.dsl.builder.RouteBuilder

  class SimpleRouteBuilder extends RouteBuilder {
    from("direct:start").log("a message")
  }

</description>
			<version>2.13.1</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.main.Main.java</file>
			<file type="M">org.apache.camel.main.MainSupport.java</file>
			<file type="M">org.apache.camel.builder.BuilderSupport.java</file>
		</fixedFiles>
		<links>
			<link type="Required" description="is required by">8427</link>
		</links>
	</bug>
	<bug id="8346" opendate="2015-02-13 06:26:48" fixdate="2015-03-04 06:53:06" resolution="Fixed">
		<buginformation>
			<summary>JsonPathEngine skips file encoding</summary>
			<description>This occurs if one uses the camel file component with a charset parameter, e.g. file:/url?charset=UTF-8. It leads to strange effects:

testing the same utf8-file under linux (default encoding:UTF-8) and german windows (default encoding:windows-1252) leads to problems with german umlauts.
using a file in another encoding than the default (ISO-8859-1 on linux) leads also to problems with german umlauts.


Both problems can be reproduced with the attached unit test files in 2.14.1.
Problem 1 is hidden in 2.15-SNAPSHOT, because UTF-8 is hard-coded as file encoding (maybe ok, since JSON is almost never used with language specific encondings), Problem 2 also occurs in 2.15-SNAPSHOT

I can provide or help with a fix (or pull request), if these problems are classified as true defects.
</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.2, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.jsonpath.JsonPathSourceTest.java</file>
			<file type="M">org.apache.camel.converter.IOConverter.java</file>
			<file type="M">org.apache.camel.jsonpath.JsonPathEngine.java</file>
			<file type="M">org.apache.camel.converter.IOConverterCharsetTest.java</file>
		</fixedFiles>
		<links>
			<link type="Blocker" description="is blocked by">8356</link>
		</links>
	</bug>
	<bug id="8430" opendate="2015-03-03 12:18:35" fixdate="2015-03-04 07:43:59" resolution="Fixed">
		<buginformation>
			<summary>Camel HDFS2 - readSuffix option does not work</summary>
			<description>Option readSuffix does not work. It staticly uses constant HdfsConstants.DEFAULT_READ_SUFFIX.</description>
			<version>2.15.0</version>
			<fixedVersion>2.14.3, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.hdfs.HdfsConsumerTest.java</file>
			<file type="M">org.apache.camel.component.hdfs.HdfsInputStream.java</file>
			<file type="M">org.apache.camel.component.hdfs2.HdfsConsumerTest.java</file>
			<file type="M">org.apache.camel.component.hdfs2.HdfsInputStream.java</file>
		</fixedFiles>
	</bug>
	<bug id="8432" opendate="2015-03-04 00:42:25" fixdate="2015-03-04 12:37:43" resolution="Fixed">
		<buginformation>
			<summary>camel-mqtt: MQTT wildcard (&amp;apos;+&amp;apos;) subscription broken</summary>
			<description>MQTT single-level wildcards ("+" character) are broken within topic subscriptions.  This is due to URL encoding/decoding that is done on the component URI, which results in the "+" being replaced with a space.  I also tried with "%2B" instead of the "+" sign, which gave the same result.  
A search led me to CAMEL-8056, which mentions needing to override the useRawUri method to return true.  I&amp;amp;apos;m working on a patch and updated unit tests for this.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.3, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mqtt.MQTTComponent.java</file>
			<file type="M">org.apache.camel.component.mqtt.MQTTConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.mqtt.MQTTBaseTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8436" opendate="2015-03-04 14:52:14" fixdate="2015-03-04 21:04:08" resolution="Fixed">
		<buginformation>
			<summary>camel-spring-boot - Some routes not being initialized after CamelContext have been removed from CamelAutoConfiguration</summary>
			<description>In our project we have several classes that extend SpringRouteBuilder and that are annotated with @Component.
Some days ago we&amp;amp;apos;ve noticed that most of them stopped being initialized on application startup.
Found out that our issues started from this commit:
https://github.com/apache/camel/commit/6bcc0b6110a762623888ded294c78dc168a18e75
If I roll it back everything is fine again.</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.camel.spring.boot.DuplicatedRouteIdTest.java</file>
			<file type="M">org.apache.camel.spring.boot.RoutesCollector.java</file>
			<file type="M">org.apache.camel.spring.boot.CamelAutoConfiguration.java</file>
			<file type="M">org.apache.camel.spring.boot.componentroute.ComponentRoute.java</file>
		</fixedFiles>
	</bug>
	<bug id="7318" opendate="2014-03-21 09:08:05" fixdate="2015-03-05 12:43:11" resolution="Fixed">
		<buginformation>
			<summary>Concurrency on HDFS Consumer not working efficiently</summary>
			<description>If we have two HDFS consumers the files are being processed twice (once by each consumer, waiting one after the other) so the consumers are not working in parallel. If we add this the consumers will work as a team and the transfer will go faster.
This happens because there is no exception thrown (the rename method just returns true or false and everything carries on as nothing would have happened .
In order to fix this we could add in the HdfsInputStream: 49
boolean tf = info.getFileSystem().rename(new Path(ret.actualPath), new Path(ret.suffixedPath));
if (!tf) 
{
	throw new IOException("This exception is thrown because the rename did not succeded.");
	}

And also in the HdfsConsumer: 150
try 
{
     this.rwlock.writeLock().lock();
     this.istream = HdfsInputStream.createInputStream(fileStatuses[i].getPath().toString(), this.config);
}
 catch (IOException ioe) 
{
     log.info(ioe.getMessage()	+ " If the rename fails we move on to the next file.");
     continue;
}


</description>
			<version>2.11.2</version>
			<fixedVersion>2.14.3, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.hdfs.HdfsConsumerTest.java</file>
			<file type="M">org.apache.camel.component.hdfs.HdfsConsumer.java</file>
			<file type="M">org.apache.camel.component.hdfs2.HdfsConsumerTest.java</file>
			<file type="M">org.apache.camel.component.hdfs2.HdfsInputStream.java</file>
			<file type="M">org.apache.camel.component.hdfs2.integration.HdfsProducerConsumerIntegrationTest.java</file>
			<file type="M">org.apache.camel.component.hdfs2.HdfsConsumer.java</file>
			<file type="M">org.apache.camel.component.hdfs2.integration.HdfsAppendTest.java</file>
			<file type="M">org.apache.camel.component.hdfs.HdfsInputStream.java</file>
		</fixedFiles>
	</bug>
	<bug id="8434" opendate="2015-03-04 10:13:32" fixdate="2015-03-05 18:34:34" resolution="Fixed">
		<buginformation>
			<summary>Camel HDFS2 - Unable to consume an empty file</summary>
			<description>It is not possible to consume an empty file with camel HDFS2 consumer.</description>
			<version>2.14.2</version>
			<fixedVersion>2.14.3, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.hdfs2.HdfsConsumerTest.java</file>
			<file type="M">org.apache.camel.component.hdfs.HdfsConsumerTest.java</file>
			<file type="M">org.apache.camel.component.hdfs2.HdfsInputStream.java</file>
			<file type="M">org.apache.camel.component.hdfs.HdfsInputStream.java</file>
			<file type="M">org.apache.camel.component.hdfs.HdfsFileType.java</file>
			<file type="M">org.apache.camel.component.hdfs.HdfsConsumer.java</file>
			<file type="M">org.apache.camel.component.hdfs2.HdfsConsumer.java</file>
			<file type="M">org.apache.camel.component.hdfs2.HdfsFileType.java</file>
		</fixedFiles>
	</bug>
	<bug id="8453" opendate="2015-03-06 16:48:11" fixdate="2015-03-06 18:30:06" resolution="Fixed">
		<buginformation>
			<summary>camel-avro throws SAXParseException when used from spring or blueprint</summary>
			<description>Getting this exception when using avro dataformat from spring:
org.xml.sax.SAXParseException; lineNumber: 27; columnNumber: 88; cvc-complex-type.3.2.2: Attribute &amp;amp;apos;instanceClass&amp;amp;apos; is not allowed to appear in element &amp;amp;apos;avro&amp;amp;apos;.
Don&amp;amp;apos;t think this has ever worked from spring.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.3, 2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.avro.AvroMarshalAndUnmarshalSpringTest.java</file>
			<file type="M">org.apache.camel.model.dataformat.AvroDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.avro.AvroDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="8461" opendate="2015-03-09 09:36:12" fixdate="2015-03-09 10:51:37" resolution="Fixed">
		<buginformation>
			<summary>camel-netty-http does not respect client&amp;apos;s keep-alive setting</summary>
			<description>If we have the camel route which remove the all the header after the netty-http consumer, netty doesn&amp;amp;apos;t  close the connection even the client send the http header connection as closed.


&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0" default-activation="eager"&amp;gt;
  &amp;lt;camelContext xmlns="http://camel.apache.org/schema/blueprint"&amp;gt;
    &amp;lt;route&amp;gt;
      &amp;lt;from id="t1" uri="netty-http:http://localhost:9000/test"/&amp;gt;
      &amp;lt;removeHeaders pattern="*"/&amp;gt;
      &amp;lt;setBody&amp;gt;
        &amp;lt;constant&amp;gt;Hello, World!&amp;lt;/constant&amp;gt;
      &amp;lt;/setBody&amp;gt;
      &amp;lt;to uri="log:XXX?level=ERROR"/&amp;gt;
    &amp;lt;/route&amp;gt;
  &amp;lt;/camelContext&amp;gt;
&amp;lt;/blueprint&amp;gt;

</description>
			<version>2.14.2</version>
			<fixedVersion>2.14.3, 2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.http.handlers.HttpServerChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty4.http.DefaultNettyHttpBinding.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpProducerKeepAliveTest.java</file>
			<file type="M">org.apache.camel.component.netty.http.DefaultNettyHttpBinding.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpProducerKeepAliveTest.java</file>
			<file type="M">org.apache.camel.component.netty.http.handlers.HttpServerChannelHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="8462" opendate="2015-03-09 10:00:24" fixdate="2015-03-09 10:51:50" resolution="Fixed">
		<buginformation>
			<summary>HttpServerChannelHandler should not store the instance of HttpRequest</summary>
			<description>HttpServerChannelHandler is created per NettyHttpConsumer, we should not store the Request instance in it&amp;amp;apos;s field. 
BTW, we can alway access the Request Object from the MessageEvent or Context Object from the NettyHttpHandler.</description>
			<version>2.14.2</version>
			<fixedVersion>2.14.3, 2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.http.handlers.HttpServerChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty.http.handlers.HttpServerChannelHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="8455" opendate="2015-03-06 19:15:31" fixdate="2015-03-09 10:53:06" resolution="Fixed">
		<buginformation>
			<summary>camel-linkedin - update_key option should be optional in getHistoricalStatusUpdateStatistics</summary>
			<description>update_key option should be optional in getHistoricalStatusUpdateStatistics endpoint. Currently it ends with an exception if the option is not specified: org.apache.camel.RuntimeCamelException: Missing properties for getHistoricalStatusUpdateStatistics, need one or more from [end_timestamp, update_key] See the LinkedIn API docs: https://developer-programs.linkedin.com/historical-company-statistics.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.3, 2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.linkedin.CompaniesResourceIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8456" opendate="2015-03-06 20:11:20" fixdate="2015-03-09 10:53:21" resolution="Fixed">
		<buginformation>
			<summary>Remove addCompanyUpdateComment endpoint from camel-linkedin</summary>
			<description>Underlying resource 


/companies/{company-id}/updates/key={update-key}/update-comments 


does not exist. It was probably added by mistake instead of 


https://api.linkedin.com/v1/people/~/network/updates/key={update-key}/update-comments


 mentioned in the documentation https://developer-programs.linkedin.com/documents/commenting-and-liking-company-share. The resource is already mapped to linkedin://people/addUpdateComment so there is no need to add it to companies prefixed endpoints.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.3, 2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.linkedin.CompaniesResourceIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8457" opendate="2015-03-06 20:47:42" fixdate="2015-03-09 10:53:32" resolution="Fixed">
		<buginformation>
			<summary>Correct return types of some endpoints in camel-linkedin</summary>
			<description>These endpoints return wrong type:

companies/getCompanyUpdateComments - Comments/UpdateComments
companies/getUpdateComments - Comments/UpdateComments
people/getGroupMembershipSettings - GroupMemberships/GroupMembership

so it results in java.lang.ClassCastException.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.3, 2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.linkedin.PeopleResourceIntegrationTest.java</file>
			<file type="M">org.apache.camel.component.linkedin.CompaniesResourceIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8464" opendate="2015-03-09 17:57:59" fixdate="2015-03-10 02:01:07" resolution="Fixed">
		<buginformation>
			<summary>Remove likeCompanyUpdate endpoint from camel-linkedin</summary>
			<description>Similar as CAMEL-8456. The underlying resource


/companies/{company-id}/updates/key={update-key}/is-liked


doesn&amp;amp;apos;t exist. It was probably added by mistake instead of


https://api.linkedin.com/v1/people/~/network/updates/key={update-key}/is-liked


mentioned in the documentation https://developer-programs.linkedin.com/documents/commenting-and-liking-company-share. The resource is already mapped to linkedin://people/likeUpdate so there is no need to add it to companies prefixed endpoints.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.3, 2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.linkedin.CompaniesResourceIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8469" opendate="2015-03-10 12:14:14" fixdate="2015-03-10 19:24:38" resolution="Fixed">
		<buginformation>
			<summary>Several enum types should generate lower case values in camel-linkedin</summary>
			<description>Following parameters - types should generate values in lower case:

event_type - org.apache.camel.component.linkedin.api.Eventtype
category - org.apache.camel.component.linkedin.api.Category
order - org.apache.camel.component.linkedin.api.Order
role - org.apache.camel.component.linkedin.api.Role
postcategorycode - org.apache.camel.component.linkedin.api.model.PostCategoryCode

Also notice that postcategory code should contain &amp;amp;apos;job&amp;amp;apos; and &amp;amp;apos;promotion&amp;amp;apos; values - https://developer-programs.linkedin.com/documents/groups-api.
I&amp;amp;apos;ve tried to fix that with adding of


&amp;lt;bindings node="//xs:simpleType[@name=&amp;amp;apos;event-type&amp;amp;apos;]"&amp;gt;
    &amp;lt;typesafeEnumClass name="EventType" /&amp;gt;
&amp;lt;/bindings&amp;gt;


to linkedin-api-schema.xjb as well as appropriate simpleType to linkedin-api-schema.xsd, but it was without success. I still got:


Error invoking getCompanyUpdates: Invalid filter {STATUS_UPDATE}


Names of enum values are used.</description>
			<version>2.14.1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.linkedin.CompaniesResourceIntegrationTest.java</file>
			<file type="M">org.apache.camel.component.linkedin.api.PeopleResourceIntegrationTest.java</file>
			<file type="M">org.apache.camel.component.linkedin.LinkedInEndpoint.java</file>
			<file type="M">org.apache.camel.component.linkedin.api.AbstractResourceIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8479" opendate="2015-03-13 05:20:51" fixdate="2015-03-13 07:51:11" resolution="Fixed">
		<buginformation>
			<summary>TrapReceiveTest is failed within Camel 2.15.0</summary>
			<description></description>
			<version>2.15.0</version>
			<fixedVersion>2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.snmp.TrapReceiveTest.java</file>
			<file type="M">org.apache.camel.component.snmp.SnmpEndpoint.java</file>
			<file type="M">org.apache.camel.component.snmp.PollOIDTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8484" opendate="2015-03-14 06:31:55" fixdate="2015-03-14 07:16:07" resolution="Fixed">
		<buginformation>
			<summary>File language - Should support file extensions with multiple dots such as tar.gz</summary>
			<description>See SO
http://stackoverflow.com/questions/29031551/how-to-use-donefilename-property-of-camel-for-file-name-with-double-extension</description>
			<version>2.14.2</version>
			<fixedVersion>2.14.3, 2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.FileUtil.java</file>
			<file type="M">org.apache.camel.util.FileUtilTest.java</file>
			<file type="M">org.apache.camel.language.FileLanguageTest.java</file>
			<file type="M">org.apache.camel.builder.ExpressionBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="8476" opendate="2015-03-11 13:21:15" fixdate="2015-03-14 13:31:41" resolution="Fixed">
		<buginformation>
			<summary>Unexpected behavior in fault handling with doTry/doCatch</summary>
			<description>There seems to be a peculiarity with fault processing when a route consists of a single TryProcessor and the MEP for an exchange is InOut.  The TryProcessor will iterate over any number of processors defined inside of it and during each iteration it sets the out msg to the in msg and clears the out msg reference.  The end result of this is that when the route completes, the out reference is cleared and Exchange.isFailed() will return false (it checks the out message for fault status).  Heres where things get interesting, if I add a single processor after the doTry block, some logic in Pipeline kicks in that copies the in message to the out message for InOut MEPs before ending the route.
I have included a unit test which demonstrates the expected behavior and current (unexpected) behavior.  The expected behavior test fails and the unexpected behavior test passes.  Additional details can be found as comments in the unit test and the camel configuration containing the routes under test.</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultExchange.java</file>
			<file type="M">org.apache.camel.processor.TryProcessor.java</file>
			<file type="M">org.apache.camel.component.spring.integration.adapter.CamelTargetAdapter.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
			<file type="M">org.apache.camel.processor.RoutingSlip.java</file>
			<file type="M">org.apache.camel.builder.ExpressionBuilder.java</file>
			<file type="M">org.apache.camel.processor.OnCompletionProcessor.java</file>
			<file type="M">org.apache.camel.spring.processor.SpringSetFaultBodyTest.java</file>
			<file type="M">org.apache.camel.impl.InterceptSendToEndpoint.java</file>
			<file type="M">org.apache.camel.impl.DefaultExchangeHolder.java</file>
			<file type="M">org.apache.camel.component.restlet.DefaultRestletBinding.java</file>
			<file type="M">org.apache.camel.processor.interceptor.HandleFaultInterceptor.java</file>
			<file type="M">org.apache.camel.processor.PipelineHelper.java</file>
			<file type="M">org.apache.camel.component.jms.EndpointMessageListener.java</file>
			<file type="M">org.apache.camel.builder.ProcessorBuilder.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8437" opendate="2015-03-04 15:52:54" fixdate="2015-03-14 19:32:03" resolution="Fixed">
		<buginformation>
			<summary>Simple bean call doesn&amp;apos;t like parenthesis in parameter values</summary>
			<description>The simple language fails calling methods with parameters that contains ")".
First use case, direct use:


&amp;lt;route&amp;gt;
    &amp;lt;from uri="timer:foo?repeatCount=1"/&amp;gt;
    &amp;lt;setBody&amp;gt;
        &amp;lt;groovy&amp;gt;[")", 42]&amp;lt;/groovy&amp;gt;
    &amp;lt;/setBody&amp;gt;
    &amp;lt;setHeader headerName="test"&amp;gt;
        &amp;lt;simple&amp;gt;${body.contains(")")}&amp;lt;/simple&amp;gt;
    &amp;lt;/setHeader&amp;gt;
    &amp;lt;log message="Body: ${body}, contains: ${header.test}"/&amp;gt;
&amp;lt;/route&amp;gt;


It throws an error.
Second use case, with a usage of a parameter:


&amp;lt;route&amp;gt;
    &amp;lt;from uri="timer:foo?repeatCount=1"/&amp;gt;
    &amp;lt;setBody&amp;gt;
        &amp;lt;groovy&amp;gt;[")", 42]&amp;lt;/groovy&amp;gt;
    &amp;lt;/setBody&amp;gt;
    &amp;lt;setProperty propertyName="query"&amp;gt;
        &amp;lt;constant&amp;gt;)&amp;lt;/constant&amp;gt;
    &amp;lt;/setProperty&amp;gt;
    &amp;lt;setHeader headerName="test"&amp;gt;
        &amp;lt;simple&amp;gt;${body.contains(${property.query})}&amp;lt;/simple&amp;gt;
    &amp;lt;/setHeader&amp;gt;
    &amp;lt;log message="Body: ${body}, contains: ${header.test}"/&amp;gt;
&amp;lt;/route&amp;gt;


It doesn&amp;amp;apos;t throw any exception but doesn&amp;amp;apos;t work.</description>
			<version>2.13.0</version>
			<fixedVersion>2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.component.bean.MethodInfo.java</file>
			<file type="M">org.apache.camel.util.ObjectHelperTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8498" opendate="2015-03-16 21:45:04" fixdate="2015-03-17 07:05:08" resolution="Fixed">
		<buginformation>
			<summary>CamelContextFactoryBean missing setEndpoints method</summary>
			<description>The Spring JAXB model class for &amp;lt;camelContext&amp;gt; is missing a setEndpoints() method, which means you cannot add an endpoint outside the route definition using JAXB.  Interestingly, the Blueprint version of CamelContextFactoryBean has this method, so I&amp;amp;apos;m guessing it was just missed.
Impacted classes:
org.apache.camel.spring.CamelContextFactoryBean</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBeanTest.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="8492" opendate="2015-03-16 09:21:44" fixdate="2015-03-17 08:11:41" resolution="Fixed">
		<buginformation>
			<summary>BeanInfo introspection ignores overriden methods</summary>
			<description>When BeanInfo introspects class which implements a interface with one method, implemented method is filtered out and no invocation of the method is possible.
Interface


public interface RequestMessageTranslator&amp;lt;I, O&amp;gt; {

    O translate(I in);
}


Implementation


public class RequestMessageTranslatorImpl implements RequestMessageTranslator&amp;lt;String, String&amp;gt; {

    public String translate(String in) {
        return null;
    }
}


Then calling the class from route:


from(ROUTE_ID)
                .id(ROUTE_ID)
                .bean(requestMessageTranslator)


ends with:


Caused by: java.lang.IllegalStateException: No method invocation could be created, no matching method could be found on: RequestMessageTranslator@402fbbaf
	at org.apache.camel.component.bean.BeanProcessor.process(BeanProcessor.java:165)


</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
		</fixedFiles>
		<links>
			<link type="Regression" description="is broken by">8137</link>
		</links>
	</bug>
	<bug id="8505" opendate="2015-03-18 10:49:16" fixdate="2015-03-18 11:37:54" resolution="Fixed">
		<buginformation>
			<summary>Missed CamelSchematronValidationStatus header</summary>
			<description>CamelSchematronValidationStatus header missed somewhere in this method of SchematronProducer class:


    /**
     * Sets validation report and status
     *
     * @param exchange
     * @param report
     * @param status
     */
    private void setValidationReport(Exchange exchange, String report, String status) {
        // if exchange pattern is In and Out set details on the Out message.
        Map&amp;lt;String, Object&amp;gt; headers = new HashMap&amp;lt;String, Object&amp;gt;();
        headers.put(Constants.VALIDATION_STATUS, status);
        headers.put(Constants.VALIDATION_REPORT, report);
        exchange.getOut().setHeader(Constants.VALIDATION_REPORT, report);
        if (exchange.getPattern().isOutCapable()) {
            exchange.getOut().setHeaders(exchange.getIn().getHeaders());
            exchange.getOut().getHeaders().putAll(headers);
        } else {
            exchange.getIn().getHeaders().putAll(headers);
        }
    }


status variable value is SUCCESS here, but right after:


            &amp;lt;to uri="schematron:schematron/dogs.sch" /&amp;gt;


there is no such header - only CamelSchematronValidationReport present.</description>
			<version>2.14.0</version>
			<fixedVersion>2.14.3, 2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.schematron.SchematronProducer.java</file>
			<file type="M">org.apache.camel.component.schematron.SchematronProducerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8510" opendate="2015-03-19 03:49:32" fixdate="2015-03-19 06:40:50" resolution="Fixed">
		<buginformation>
			<summary>NPE will be thrown from doAppend() of PaxLoggingConsumer during load testing</summary>
			<description>this NPE is thrown sometimes using camel-paxlogging feature and paxlogging bundles.


java.lang.NullPointerException
	at org.apache.camel.component.paxlogging.PaxLoggingConsumer.doAppend(PaxLoggingConsumer.java:58)[59:org.apache.camel.camel-paxlogging:2.14.0]
	at org.ops4j.pax.logging.service.internal.PaxAppenderProxy.doAppend(PaxAppenderProxy.java:63)[4:org.ops4j.pax.logging.pax-logging-service:1.8.1]
	at org.ops4j.pax.logging.service.internal.AppenderBridgeImpl.append(AppenderBridgeImpl.java:67)[4:org.ops4j.pax.logging.pax-logging-service:1.8.1]
	at org.ops4j.pax.logging.service.internal.AppenderBridgeImpl.doAppend(AppenderBridgeImpl.java:61)[4:org.ops4j.pax.logging.pax-logging-service:1.8.1]


the executor should be validated if it&amp;amp;apos;s null before use it.</description>
			<version>2.14.2</version>
			<fixedVersion>2.14.3, 2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.paxlogging.PaxLoggingConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8515" opendate="2015-03-19 14:44:22" fixdate="2015-03-19 14:45:58" resolution="Fixed">
		<buginformation>
			<summary>Camel marshal/unmarshal - Should catch throwable in case dataformat causes an java.lang.Error</summary>
			<description>For example if crypto dataformat cannot load some class and throw 


Caused by: java.lang.NoClassDefFoundError: javax/crypto/CipherOutputStream
        at org.apache.camel.converter.crypto.CryptoDataFormat.marshal(CryptoDataFormat.java:131)
        at org.apache.camel.processor.MarshalProcessor.process(MarshalProcessor.java:81)
        at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:77)


We should detect and handle that in marshaller / unmarshaller like the rest of the routing engine does.</description>
			<version>2.14.2</version>
			<fixedVersion>2.14.3, 2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.MarshalProcessor.java</file>
			<file type="M">org.apache.camel.processor.UnmarshalProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="8520" opendate="2015-03-20 00:38:17" fixdate="2015-03-20 06:52:48" resolution="Fixed">
		<buginformation>
			<summary>Camel XMPP doesn&amp;apos;t use a DNS resolver to look at SRV records</summary>
			<description>Camel XMPP doesn&amp;amp;apos;t use a DNS resolver to look at SRV records, whereas in 2.14.1 it did.
In 2.15.0, ConnectionConfiguration calls DNSUtil.resolveXMPPDomain(serviceName) which runs this code:
DNSUtil.java

public static List&amp;lt;HostAddress&amp;gt; resolveXMPPDomain(final String domain) {
        if (dnsResolver == null) {
            List&amp;lt;HostAddress&amp;gt; addresses = new ArrayList&amp;lt;HostAddress&amp;gt;(1);
            addresses.add(new HostAddress(domain, 5222));
            return addresses;
        }
        return resolveDomain(domain, &amp;amp;apos;c&amp;amp;apos;);
    }


dnsResolver is never initialised, so it returns the service name, in my case &amp;amp;apos;jabberzac.org&amp;amp;apos;, instead of the actual XMPP server from the SRV Record, &amp;amp;apos;xmpp.jabberzac.org&amp;amp;apos;, which then causes a timeout.
The dnsResolver is meant to be instantiated in init(), which is meant to be called by SmackConfiguration, but never is.
DNSUtil.java

    /**
     * Initializes DNSUtil. This method is automatically called by SmackConfiguration, you don&amp;amp;apos;t
     * have to call it manually.
     */
    public static void init() {
        final String[] RESOLVERS = new String[] { "javax.JavaxResolver", "minidns.MiniDnsResolver",
                        "dnsjava.DNSJavaResolver" };
        for (String resolver :RESOLVERS) {
            DNSResolver availableResolver = null;
            String resolverFull = "org.jivesoftware.smack.util.dns" + resolver;
            try {
                Class&amp;lt;?&amp;gt; resolverClass = Class.forName(resolverFull);
                Method getInstanceMethod = resolverClass.getMethod("getInstance");
                availableResolver = (DNSResolver) getInstanceMethod.invoke(null);
                if (availableResolver != null) {
                    setDNSResolver(availableResolver);
                    break;
                }
            }
            catch (ClassNotFoundException|NoSuchMethodException|SecurityException|IllegalAccessException|IllegalArgumentException|InvocationTargetException e) {
                LOGGER.log(Level.FINE, "Exception on init", e);
            }
        }
    }


2.14.1 doesn&amp;amp;apos;t seem to have this problem as DNSUtil class in 2.14.1 doesn&amp;amp;apos;t have an init() function which is meant to be &amp;amp;apos;automatically called&amp;amp;apos;, it just has a static code block:


    static {
        try {
            Hashtable env = new Hashtable();
            env.put("java.naming.factory.initial", "com.sun.jndi.dns.DnsContextFactory");
            context = new InitialDirContext(env);
        }
        catch (Exception e) {
            // Ignore.
        }
    }

</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xmpp.XmppRouteTest.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppMultiUserChatTest.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppRobustConnectionTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8521" opendate="2015-03-20 07:00:34" fixdate="2015-03-20 07:02:43" resolution="Fixed">
		<buginformation>
			<summary>camel-script - Should try all classloaders before throwing IAE</summary>
			<description>Due CAMEL-8338]</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.script.ScriptBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="8519" opendate="2015-03-19 23:32:57" fixdate="2015-03-20 21:41:00" resolution="Fixed">
		<buginformation>
			<summary>Salesforce component security listener does not replace old auth header</summary>
			<description>The security listener incorrectly adds a copy of the auth header for streaming api client. Although this causes the exchange to ultimately fail, the BayeuxClient reconnects and proceeds without raising errors in Camel route. However, this ends up logging multiple warnings from the security listener and the BayeuxClient. 
Fixing the security listener to reset the auth header will optimize this process and let the BayeuxClient continue with the existing exchange. </description>
			<version>2.13.4</version>
			<fixedVersion>2.14.3, 2.15.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.salesforce.internal.client.SalesforceSecurityListener.java</file>
			<file type="M">org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="8500" opendate="2015-03-17 11:08:50" fixdate="2015-03-21 07:00:30" resolution="Fixed">
		<buginformation>
			<summary>ClassCastException when something other than PropertiesComponent is bound to "properties" JNDI name</summary>
			<description>Problem
When starting the DefaultCamelContext, Camel tries to get a PropertiesComponent object from JNDI under the name "properties" (which is hard-coded in DefaultCamelContext.lookupPropertiesComponent() resp. CamelContextHelper.lookupPropertiesComponent() in newer Camel versions).
During start we get the following Error:


org.apache.camel.NoSuchBeanException: Found bean: properties in JNDI Context: javax.naming.InitialContext@a37a18 of type: org.jnp.interfaces.NamingContext expected type was: class org.apache.camel.component.properties.PropertiesComponent
	at org.apache.camel.impl.JndiRegistry.lookupByNameAndType(JndiRegistry.java:61)
	at org.apache.camel.impl.PropertyPlaceholderDelegateRegistry.lookupByNameAndType(PropertyPlaceholderDelegateRegistry.java:63)
	at org.apache.camel.impl.DefaultCamelContext.lookupPropertiesComponent(DefaultCamelContext.java:2788)
	at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:1834)
	at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:1716)
	at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:61)
	at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:1684)
	at de.bwb.ubi.vs.automat.mbean.CamelStarter.startService(CamelStarter.java:21)
	at org.jboss.system.ServiceMBeanSupport.jbossInternalStart(ServiceMBeanSupport.java:289)
[...]
Caused by: java.lang.ClassCastException
	at java.lang.Class.cast(Class.java:2999)
	at org.apache.camel.impl.JndiRegistry.lookupByNameAndType(JndiRegistry.java:57)
	... 145 more


Reason
In our installation, some properties are bound to the name "properties/..." in the JNDI global namespace.
Proposed Solution
Camel can manage if it finds nothing under the JNDI name, the problem is just finding something different than the expected PropertiesComponent instance. Instead of calling JndiRegistry.lookupByNameAndType(String, Class)  this is where the cast fails  we should call JndiRegistry.lookupByName(String name). If an instance other than a PropertiesComponent is returned here, we should go on as if nothing was found in the JNDI lookup.
I can provide a pull request for this.</description>
			<version>2.13.4</version>
			<fixedVersion>2.14.3, 2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.CamelContextHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="7565" opendate="2014-07-01 18:18:39" fixdate="2015-03-21 11:11:37" resolution="Fixed">
		<buginformation>
			<summary>SFTP using PollEnrich with "disconnect=true" and "delete=true" does NOT delete the file</summary>
			<description>Attached are two test cases - one with a "non-pollEnrich" test (which works fine) and one with a "pollEnrich" test (which fails).
In stepping through some of the code, it appears that the "disconnect" and "delete" are on two different threads (true for both scenarios).  However, for the "non-pollEnrich" test, there seems to be a cycle that allows the timing of the two threads to NOT be an issue.  For the "pollEnrich" test, that cycle doesn&amp;amp;apos;t seem to occur.  
My uneducated guess is that both tests (code executions) are checking to see if the "from" has completed (including performing the delete) before disconnecting.  This makes sense for the "non-pollEnrich" test, but for the "pollEnrich" it should be checking to see if the "pollEnrich" is done, not the "from".
Please note that if you do not indicate "disconnect=true", file deletion occurs as expected.  This seems to be broken in 2.12.x through 2.13.1 (not sure if it goes back further or not).
I have attached two different test cases to show the different behaviors ("non-pollEnrich" vs "pollEnrich").</description>
			<version>2.13.1</version>
			<fixedVersion>2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="6015" opendate="2013-01-25 12:30:08" fixdate="2015-03-25 09:17:24" resolution="Duplicate">
		<buginformation>
			<summary>camel maven run plugin - Auto detect if spring or blueprint</summary>
			<description>It would be nice if the mvn camel:run plugin could auto detect if your run a spring or blueprint project. Today it defaults to spring because it was the first. For blueprint you need to configure it to be blueprint.
But we can detect the xml if its blueprint or spring in the namespace of the xml.</description>
			<version>1.6.1</version>
			<fixedVersion>Future</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.maven.RunMojo.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">5561</link>
		</links>
	</bug>
	<bug id="8547" opendate="2015-03-25 16:17:18" fixdate="2015-03-26 11:58:23" resolution="Fixed">
		<buginformation>
			<summary>Usage of camel-xmlbeans depends on TCCL</summary>
			<description>xmlbeans marshalling and unmarshalling does not respect the ApplicationContextClassLoader
CrossRef: https://github.com/wildfly-extras/wildfly-camel/issues/457</description>
			<version>2.15.0</version>
			<fixedVersion>2.14.3, 2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.converter.xmlbeans.XmlBeansDataFormat.java</file>
			<file type="M">org.apache.camel.converter.xmlbeans.XmlBeansConverter.java</file>
			<file type="M">org.apache.camel.converter.xmlbeans.XmlBeansConverterTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8546" opendate="2015-03-25 16:07:35" fixdate="2015-03-26 12:00:24" resolution="Fixed">
		<buginformation>
			<summary>No LanguageResolver found for language=js</summary>
			<description>
Unable to start blueprint container for bundle test.xml due to unresolved dependencies [(&amp;amp;(language=js)(objectClass=org.apache.camel.spi.LanguageResolver))]
java.util.concurrent.TimeoutException
        at org.apache.aries.blueprint.container.BlueprintContainerImpl$1.run(BlueprintContainerImpl.java:293)[10:org.apache.aries.blueprint:0.3.2]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)[:1.7.0_17]
        at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:334)[:1.7.0_17]
        at java.util.concurrent.FutureTask.run(FutureTask.java:166)[:1.7.0_17]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:178)[:1.7.0_17]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:292)[:1.7.0_17]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)[:1.7.0_17]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)[:1.7.0_17]
        at java.lang.Thread.run(Thread.java:722)[:1.7.0_17] 

This happens when we try to use script with blueprint because blueprint tries to resolve the LanguageResolver with filter language=js. However camel.osgi registered a default LanguageResolver under resolver=default which causes blueprint to wait for ever.</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.3, 2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.script.osgi.Activator.java</file>
		</fixedFiles>
	</bug>
	<bug id="8556" opendate="2015-03-26 12:56:04" fixdate="2015-03-26 14:27:48" resolution="Fixed">
		<buginformation>
			<summary>AnnotationTypeConverterLoader treats package as class</summary>
			<description>A package with an uppercase letter like 


org.wildfly.camel.test.core.subA


would be treated as class leading to 


Caused by: java.lang.NullPointerException
	at org.apache.camel.impl.converter.AnnotationTypeConverterLoader.loadConverterMethods(AnnotationTypeConverterLoader.java:262)
	at org.apache.camel.impl.converter.AnnotationTypeConverterLoader.load(AnnotationTypeConverterLoader.java:130)
	at org.apache.camel.impl.converter.BaseTypeConverterRegistry.loadTypeConverters(BaseTypeConverterRegistry.java:544)

</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.1, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.StringHelperTest.java</file>
			<file type="M">org.apache.camel.impl.osgi.Activator.java</file>
			<file type="M">org.apache.camel.util.StringHelper.java</file>
			<file type="M">org.apache.camel.impl.converter.AnnotationTypeConverterLoader.java</file>
		</fixedFiles>
	</bug>
	<bug id="8540" opendate="2015-03-24 16:31:34" fixdate="2015-03-30 12:32:43" resolution="Fixed">
		<buginformation>
			<summary>S3Consumer uses maxMessagesPerPoll incorrectly</summary>
			<description>S3Consumer sets the maximum number of keys to retrieve from S3 to the value of maxMessagesPerPoll property. According to documentation (http://camel.apache.org/batch-consumer.html), the limit can be disabled by setting the value to negative or zero. In case of S3Consumer, setting the maxMessagesPerPoll URI property will have and effect of always empty result.
S3Consumer.java

listObjectsRequest.setMaxKeys(maxMessagesPerPoll);


The consumer must set key limit only when value of maxMessagesPerPoll is greater than 0.</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.aws.s3.AmazonS3ClientMock.java</file>
		</fixedFiles>
	</bug>
	<bug id="8584" opendate="2015-04-01 11:15:11" fixdate="2015-04-02 08:13:11" resolution="Fixed">
		<buginformation>
			<summary>Circuit breaker does not honour halfOpenAfter period</summary>
			<description>The CircuitBreakerLoadBalancer will always switch to a half-open state immediately after the first rejected message instead of honouring the halfOpenAfter period.
It&amp;amp;apos;s due to the failed message count getting reset in the rejectExchange method:
https://github.com/apache/camel/blob/master/camel-core/src/main/java/org/apache/camel/processor/loadbalancer/CircuitBreakerLoadBalancer.java#L207</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.loadbalancer.CircuitBreakerLoadBalancer.java</file>
			<file type="M">org.apache.camel.processor.CircuitBreakerLoadBalancerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8585" opendate="2015-04-01 13:03:19" fixdate="2015-04-02 08:42:55" resolution="Fixed">
		<buginformation>
			<summary>The lazy load option doesn&amp;apos;t unlock the file</summary>
			<description>Hi, 
After to upgrade camel from 2.14.1 to 2.15.0, a org.apache.camel.component.file.GenericFileOperationFailedException Exception is thrown when camel move/delete the file at the end of process.
After some tests, I&amp;amp;apos;ve notice that the issue appear when the lazy load option is enabled. I think, the reader or parser used by the component Apache CSV 1.0 aren&amp;amp;apos;t closed at the end of file.
My stacktrace: 


14:30:48,960 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) org.apache.camel.component.file.GenericFileOperationFailedException: Error renaming file from C:\temp\import\source\file_20150304162756890.csv to C:\temp\import\source\error\file_20150304162756890_20150401143044944.csv

14:30:48,964 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.component.file.FileOperations.renameFile(FileOperations.java:81)

14:30:48,966 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.component.file.strategy.GenericFileProcessStrategySupport.renameFile(GenericFileProcessStrategySupport.java:113)

14:30:48,973 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.component.file.strategy.GenericFileRenameProcessStrategy.rollback(GenericFileRenameProcessStrategy.java:66)

14:30:48,976 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.component.file.GenericFileOnCompletion.processStrategyRollback(GenericFileOnCompletion.java:151)

14:30:48,977 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.component.file.GenericFileOnCompletion.onCompletion(GenericFileOnCompletion.java:86)

14:30:48,979 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.component.file.GenericFileOnCompletion.onFailure(GenericFileOnCompletion.java:58)

14:30:48,980 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.util.UnitOfWorkHelper.doneSynchronizations(UnitOfWorkHelper.java:101)

14:30:48,981 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.impl.DefaultUnitOfWork.done(DefaultUnitOfWork.java:229)

14:30:48,982 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.util.UnitOfWorkHelper.doneUow(UnitOfWorkHelper.java:65)

14:30:48,983 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.processor.CamelInternalProcessor$UnitOfWorkProcessorAdvice.after(CamelInternalProcessor.java:650)

14:30:48,984 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.processor.CamelInternalProcessor$UnitOfWorkProcessorAdvice.after(CamelInternalProcessor.java:618)

14:30:48,986 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.processor.CamelInternalProcessor$InternalCallback.done(CamelInternalProcessor.java:240)

14:30:48,987 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.impl.MDCUnitOfWork$MDCCallback.done(MDCUnitOfWork.java:231)

14:30:48,988 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.processor.Pipeline.process(Pipeline.java:106)

14:30:48,989 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)

14:30:48,991 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.component.file.GenericFileConsumer.processExchange(GenericFileConsumer.java:433)

14:30:48,992 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.component.file.GenericFileConsumer.processBatch(GenericFileConsumer.java:211)

14:30:48,993 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:175)

14:30:48,994 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:174)

14:30:48,995 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:101)

14:30:48,997 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)

14:30:48,998 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:304)

14:30:48,999 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:178)

14:30:49,000 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)

14:30:49,001 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)

14:30:49,002 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)

14:30:49,004 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at java.lang.Thread.run(Thread.java:745)

14:30:49,005 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) Caused by: java.io.IOException: Renaming file from &amp;amp;apos;C:\temp\import\source\file_20150304162756890.csv&amp;amp;apos; to &amp;amp;apos;C:\temp\import\source\error\file_20150304162756890_20150401143044944.csv&amp;amp;apos; failed: Cannot delete file &amp;amp;apos;C:\temp\import\source\file_20150304162756890.csv&amp;amp;apos; after copy succeeded

14:30:49,008 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.util.FileUtil.renameFileUsingCopy(FileUtil.java:471)

14:30:49,010 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.util.FileUtil.renameFile(FileUtil.java:443)

14:30:49,012 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	at org.apache.camel.component.file.FileOperations.renameFile(FileOperations.java:78)

14:30:49,013 INFO  [stdout] (Camel (Socle-CamelContext) thread #3 - file://C:/temp/import/source) 	... 26 more

</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.csv.CsvUnmarshalStreamSpringTest.java</file>
			<file type="M">org.apache.camel.dataformat.csv.CsvUnmarshaller.java</file>
			<file type="M">org.apache.camel.dataformat.csv.CsvUnmarshalTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8592" opendate="2015-04-02 09:50:37" fixdate="2015-04-03 02:17:01" resolution="Fixed">
		<buginformation>
			<summary>NPE in AbstractListAggregationStrategy if empty list</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/NullPointerException-on-empty-List-in-AbstractListAggregationStrategy-tp5764965.html</description>
			<version>2.15.1</version>
			<fixedVersion>2.14.3, 2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.aggregate.AbstractListAggregationStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="8597" opendate="2015-04-03 12:00:06" fixdate="2015-04-04 14:07:02" resolution="Fixed">
		<buginformation>
			<summary>Elasticsearch component ignores indexType header set from endpoint URL</summary>
			<description>When indexName and indexType is configured only by endpoint URL then indexType is ignored, resp. it is mistakenly replaced with indexName, see https://github.com/apache/camel/blob/master/components/camel-elasticsearch/src/main/java/org/apache/camel/component/elasticsearch/ElasticsearchProducer.java#L112
</description>
			<version>2.15.1</version>
			<fixedVersion>2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.elasticsearch.ElasticsearchProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8575" opendate="2015-03-31 08:23:14" fixdate="2015-04-06 20:58:16" resolution="Fixed">
		<buginformation>
			<summary>Salesforce component doesn&amp;apos;t properly retries the request when doing re-login</summary>
			<description>When the authentication token is revoked by other means then using SalesforceSession.logout(), it&amp;amp;apos;s unable (in most cases) to properly retry the original request.
The exception follows.


org.apache.camel.CamelExecutionException: Exception occurred during execution on the exchange: Exchange[Message: [Body is null]]
	at org.apache.camel.util.ObjectHelper.wrapCamelExecutionException(ObjectHelper.java:1380)
	at org.apache.camel.util.ExchangeHelper.extractResultBody(ExchangeHelper.java:623)
	at org.apache.camel.impl.DefaultProducerTemplate.extractResultBody(DefaultProducerTemplate.java:471)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:133)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:149)
	at org.apache.camel.impl.DefaultProducerTemplate.requestBody(DefaultProducerTemplate.java:301)
	at org.apache.camel.impl.DefaultProducerTemplate.requestBody(DefaultProducerTemplate.java:331)
	at org.apache.camel.component.salesforce.RestApiIntegrationTest.doTestGetGlobalObjects(RestApiIntegrationTest.java:136)
	at org.apache.camel.component.salesforce.RestApiIntegrationTest.testRetry(RestApiIntegrationTest.java:89)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:68)
Caused by: {message:&amp;amp;apos;Unexpected exception: Response not received yet&amp;amp;apos;,statusCode:0}
	at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onException(AbstractClientBase.java:135)
	at org.eclipse.jetty.client.HttpEventListenerWrapper.onException(HttpEventListenerWrapper.java:94)
	at org.eclipse.jetty.client.RedirectListener.onException(RedirectListener.java:210)
	at org.eclipse.jetty.client.AsyncHttpConnection.handle(AsyncHttpConnection.java:168)
	at org.eclipse.jetty.io.nio.SslConnection.handle(SslConnection.java:196)
	at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:696)
	at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:53)
	at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:608)
	at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:543)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.IllegalStateException: Response not received yet
	at org.eclipse.jetty.client.CachedExchange.getResponseStatus(CachedExchange.java:47)
	at org.apache.camel.component.salesforce.internal.client.AbstractClientBase$1.onResponseComplete(AbstractClientBase.java:149)
	at org.eclipse.jetty.client.HttpEventListenerWrapper.onResponseComplete(HttpEventListenerWrapper.java:123)
	at org.eclipse.jetty.client.RedirectListener.onResponseComplete(RedirectListener.java:106)
	at org.eclipse.jetty.client.HttpExchange.setStatus(HttpExchange.java:305)
	at org.eclipse.jetty.client.AbstractHttpConnection$Handler.messageComplete(AbstractHttpConnection.java:340)
	at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:904)
	at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:235)
	at org.eclipse.jetty.client.AsyncHttpConnection.handle(AsyncHttpConnection.java:135)
	... 6 more

</description>
			<version>2.14.2</version>
			<fixedVersion>2.14.3, 2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.salesforce.internal.client.AbstractClientBase.java</file>
			<file type="M">org.apache.camel.component.salesforce.RestApiIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8609" opendate="2015-04-09 18:26:19" fixdate="2015-04-09 18:37:15" resolution="Fixed">
		<buginformation>
			<summary>Remove open-jpa bundle from camel-jpa feature</summary>
			<description>The camel-jpa component uses open-jpa for testing, but it does not require the bundle in the feature, and could be used with other JPA implementations, such as Hibernate. </description>
			<version>2.14.2</version>
			<fixedVersion>2.14.3, 2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.itest.osgi.jpa.JpaBlueprintRouteTest.java</file>
			<file type="M">org.apache.camel.itest.osgi.jpa.JpaRouteTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7849" opendate="2014-09-22 17:43:14" fixdate="2015-04-10 02:14:42" resolution="Fixed">
		<buginformation>
			<summary>Decrypting properties via Jasypt outside of &lt;camelContext&gt;</summary>
			<description>
File default.properties contains an entry like: key=ENC(..)

The following Camel Spring DSL snippet decrypts the 
property value inside &amp;lt;camelContext&amp;gt; via {{key}} but does 
not decrypt it outside of the &amp;lt;camelContext&amp;gt; via ${key}:

&amp;lt;bean id="jasypt" class="org.apache.camel.component.jasypt.JasyptPropertiesParser"&amp;gt;
    &amp;lt;property name="password" value="sysenv:PROPERTIES_KEY"/&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;bean id="bridgePropertyPlaceholder" class=
  "org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer"&amp;gt;
  &amp;lt;property name="locations" &amp;gt;
  &amp;lt;list&amp;gt;
    &amp;lt;value&amp;gt;classpath:default.properties&amp;lt;/value&amp;gt;
  &amp;lt;/list&amp;gt;&amp;lt;/property&amp;gt;
  &amp;lt;property name=&amp;amp;apos;parser&amp;amp;apos; ref=&amp;amp;apos;jasypt&amp;amp;apos;/&amp;gt;
&amp;lt;/bean&amp;gt;

In order to get ${} to decrypt, first I remove all of the above. 
Then I add jasypt dependencies to pom.xml:

&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.jasypt&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jasypt&amp;lt;/artifactId&amp;gt;
  &amp;lt;classifier&amp;gt;lite&amp;lt;/classifier&amp;gt;
  &amp;lt;version&amp;gt;1.9.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

 &amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.jasypt&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;jasypt-spring3&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.9.2&amp;lt;/version&amp;gt;
 &amp;lt;/dependency&amp;gt; 

And add the following to Camel Spring DSL:

&amp;lt;bean id="environmentVariablesConfiguration"
     class="org.jasypt.encryption.pbe.config.EnvironmentStringPBEConfig"&amp;gt;
   &amp;lt;property name="algorithm" value="PBEWithMD5AndDES" /&amp;gt;
   &amp;lt;property name="passwordEnvName" value="PROPERTIES_KEY" /&amp;gt;
 &amp;lt;/bean&amp;gt;
 &amp;lt;bean id="configurationEncryptor"
     class="org.jasypt.encryption.pbe.StandardPBEStringEncryptor"&amp;gt;
   &amp;lt;property name="config" ref="environmentVariablesConfiguration" /&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id="propertyConfigurer" class=
  &amp;amp;apos;org.jasypt.spring3.properties.EncryptablePropertyPlaceholderConfigurer&amp;amp;apos;&amp;gt;
 &amp;lt;constructor-arg ref="configurationEncryptor"/&amp;gt;
   &amp;lt;property name="locations" &amp;gt;
  &amp;lt;list&amp;gt;
    &amp;lt;value&amp;gt;classpath:default.properties&amp;lt;/value&amp;gt;
  &amp;lt;/list&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id="jasypt" class=
  "org.apache.camel.component.jasypt.JasyptPropertiesParser"&amp;gt;
    &amp;lt;property name="password" value="sysenv:PROPERTIES_KEY"/&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;!-- And inside the camelContext... --&amp;gt;

&amp;lt;camelContext xmlns="http://camel.apache.org/schema/spring"&amp;gt;

&amp;lt;propertyPlaceholder id="properties"
 propertiesParserRef="jasypt" 
 location="classpath:default.properties"/&amp;gt; 

This is the only solution that I could discover. Using BridgePropertyPlaceholder 
didn&amp;amp;apos;t work. &amp;lt;propertyPlaceholder&amp;gt; must be used inside &amp;lt;camelContext&amp;gt;.

</description>
			<version>2.13.2</version>
			<fixedVersion>2.14.3, 2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jasypt.SpringJasyptBridgePropertiesTest.java</file>
			<file type="M">org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8624" opendate="2015-04-13 08:37:29" fixdate="2015-04-13 09:13:36" resolution="Fixed">
		<buginformation>
			<summary>Bean component - Potential NPE in BeanInfo</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/transformers-not-working-after-update-to-2-15-1-tp5765600.html</description>
			<version>2.15.1</version>
			<fixedVersion>2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.issues.TransformerImpl.java</file>
			<file type="M">org.apache.camel.component.bean.issues.Transformer.java</file>
			<file type="M">org.apache.camel.component.bean.issues.AbstractTransformer.java</file>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
		</fixedFiles>
	</bug>
	<bug id="8628" opendate="2015-04-13 19:14:25" fixdate="2015-04-14 05:43:55" resolution="Fixed">
		<buginformation>
			<summary>camel-dozer component fails when multiple expressions are used in a mapping</summary>
			<description>The reference to the current exchange is cleared on each invocation of ExpressionMapper in the done() method.  If a mapping file contains multiple expression mappings, the first expression clears out the exchange reference and subsequent expression mappings fail with:

java.lang.IllegalStateException: Current exchange has not been set for ExpressionMapper


Fix is to not clear the reference in ExpressionMapper.done().  We should do this in DozerProducer after all mappings in the mapping file have completed.</description>
			<version>2.15.1</version>
			<fixedVersion>2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.dozer.ExpressionMapper.java</file>
			<file type="M">org.apache.camel.component.dozer.ExpressionMappingTest.java</file>
			<file type="M">org.apache.camel.component.dozer.DozerProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8636" opendate="2015-04-15 06:38:51" fixdate="2015-04-15 07:02:10" resolution="Fixed">
		<buginformation>
			<summary>camel-kafka need to commit the last batch of messages when the auto commit is false</summary>
			<description>CAMEL-8085 introduced a new feature of commit the consumer offset in batch mode, but it doesn&amp;amp;apos;t commit the last batch of messages.</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.kafka.KafkaConsumer.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">8085</link>
		</links>
	</bug>
	<bug id="8660" opendate="2015-04-17 13:49:42" fixdate="2015-04-17 14:34:46" resolution="Fixed">
		<buginformation>
			<summary>camel-ftp - Disconnect when no messages dont call disconnect</summary>
			<description>Its due disconnect is now done as part of UoW to not disconnect before deleting files etc.
But if there is no messages then the UoW is not called as no Exchange. In that case we should disconnect if its true.
See nabble
http://camel.465427.n5.nabble.com/FTP-disconnect-problem-tp5765934.html</description>
			<version>2.15.1</version>
			<fixedVersion>2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.NewFileConsumerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8665" opendate="2015-04-18 06:17:44" fixdate="2015-04-18 07:20:08" resolution="Fixed">
		<buginformation>
			<summary>Throttler EIP - Using method call for message per sec exp fails in spring</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Throtteling-and-dynamically-changing-MaxRequestsPerPeriod-via-Bean-tp5765952.html
It works in java dsl but not in xml dsl</description>
			<version>2.14.2</version>
			<fixedVersion>2.14.3, 2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.ThrottlerTest.java</file>
			<file type="M">org.apache.camel.model.ThrottleDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="8649" opendate="2015-04-16 15:59:55" fixdate="2015-04-19 07:01:46" resolution="Fixed">
		<buginformation>
			<summary>Camel RAW() cannot handle String of  %2050</summary>
			<description>

file:inbox?fileName=data+.txt (expected "inbox/data .txt" and result is OK)
file:inbox?fileName=data%20.txt (expected "inbox/data .txt" and result is OK)
file:inbox?fileName=RAW(data+.txt) (expected "inbox/data+.txt" and result is OK)
file:inbox?fileName=RAW(data%20.txt) (expected "inbox/data%20.txt", but actually it&amp;amp;apos;s "inbox/data .txt") - I think it&amp;amp;apos;s WRONG (disobeyed RAW)
file:inbox?fileName=RAW(data%2520.txt) (expected "inbox/data%2520.txt", but actually it&amp;amp;apos;s also "inbox/data .txt") - I think it&amp;amp;apos;s WRONG (disobeyed RAW + double URL decode)
Additional info:
RAW(data%252520.txt) results in "data%20.txt" (disobeyed RAW + double URL decode - it means there is not triple URL decode in this case)
RAW(data%2B.txt) results in "data+.txt" (disobeyed RAW + single URL decode - it means there is not double URL decode in this case)
data%252B.txt results in "data%2B.txt" (single URL decode - it means there is not double URL decode in this case)

</description>
			<version>2.14.2</version>
			<fixedVersion>2.14.3, 2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.URISupport.java</file>
			<file type="M">org.apache.camel.util.UnsafeUriCharactersEncoder.java</file>
			<file type="M">org.apache.camel.util.URISupportTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8607</link>
		</links>
	</bug>
	<bug id="8626" opendate="2015-04-13 15:15:31" fixdate="2015-04-19 07:03:08" resolution="Fixed">
		<buginformation>
			<summary>Leaking exchangesInFlightKeys in ManagedRoute</summary>
			<description>Having a camel context with a single route:


        onException(Throwable.class)
                .handled(true)
                .process(handleException()); // essentially  doing exchange.setException(someConvertedException);

        from("direct:generalFlow")
                .routingSlip(property(GeneralFlowRoute.class.getName()));


started from Spring:


    &amp;lt;camelContext id="flows" xmlns="http://camel.apache.org/schema/spring"&amp;gt;
        &amp;lt;template id="template" defaultEndpoint="direct:generalFlow"/&amp;gt;
        &amp;lt;routeBuilder ref="generalFlow"/&amp;gt;
    &amp;lt;/camelContext&amp;gt;

    &amp;lt;bean id="generalFlow" class="com.blabla.GeneralFlowRoute"/&amp;gt;


During performance test both exchangesInFlightKeys  and exchangesInFlightStartTimestamps are accumulating over time.
But if the test is run in one thread with debug - nothing is accumulated.
Issue found after migration from 2.14.1 to 2.15.1</description>
			<version>2.15.1</version>
			<fixedVersion>2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.mbean.ManagedRoute.java</file>
			<file type="M">org.apache.camel.management.ManagedInflightStatisticsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8672" opendate="2015-04-20 06:12:03" fixdate="2015-04-20 06:50:20" resolution="Fixed">
		<buginformation>
			<summary>Restlet Rest Component properties are ignored</summary>
			<description>Rest properties for RestletComponent are not picked up by the component because it&amp;amp;apos;s incorrectly looking for "restle" properties instead of "restlet".


        // configure component options
        RestConfiguration config = getCamelContext().getRestConfiguration();
        if (config != null &amp;amp;&amp;amp; (config.getComponent() == null || config.getComponent().equals("restle"))) {
            // configure additional options on spark configuration
            if (config.getComponentProperties() != null &amp;amp;&amp;amp; !config.getComponentProperties().isEmpty()) {
                setProperties(this, config.getComponentProperties());
            }
        }

</description>
			<version>2.15.1</version>
			<fixedVersion>2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.RestletComponent.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">7364</link>
		</links>
	</bug>
	<bug id="8673" opendate="2015-04-20 09:12:08" fixdate="2015-04-22 00:06:50" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentModificationException when creating dynamic routes</summary>
			<description>This ticket refers to CAMEL-7836.
The fix seems to be slightly wrong. (We still geht the ConcurrentModificationException)
The cause seems to be in removeRouteCollection and addRouteCollection. See here:


void removeRouteCollection(Collection&amp;lt;Route&amp;gt; routes) {
        synchronized (routes) {
            this.routes.removeAll(routes);
        }
}


Here the code synchronizes on the routes parameter, but should be on this.routes (as it getRoutes() does). The same in addRouteCollection().</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.3, 2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">7836</link>
		</links>
	</bug>
	<bug id="8682" opendate="2015-04-22 08:46:36" fixdate="2015-04-22 09:53:41" resolution="Fixed">
		<buginformation>
			<summary>Context scoped OnException should not be stopped if a route is stopped</summary>
			<description>If you stop a route and uses context scoped error handling, then its services may be stopped when the route stops. This should not happen for context scoped as they are reused by other routes etc.
This can also happen for OnCompletion which has same scope as OnException.</description>
			<version>2.15.1</version>
			<fixedVersion>2.14.3, 2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.interceptor.DefaultChannel.java</file>
		</fixedFiles>
	</bug>
	<bug id="8674" opendate="2015-04-20 09:44:34" fixdate="2015-04-22 11:26:50" resolution="Fixed">
		<buginformation>
			<summary>Camel-Netty4 does not set remote UDP address in headers</summary>
			<description>It appears that camel-netty4 does not set CamelNettyRemoteAddress in headers of an Exchange generated by an in-only UDP endpoint.
It does set CamelNettyRemoteAddress in properties of the exchange.
CamelNettyRemoteAddress in properties is set from AddressedEnvelope#sender(). CamelNettyRemoteAddress in headers is set from ChannelHandlerContext#channel().remoteAddress().
It appears that the latter does not actually contain the remote address. Possible solutions are:
1) Change NettyEndpoint to set CamelNettyRemoteAddress in headers from the AddressedEnvelope received
2) Change NettyEndpoint to set CamelNettyRemoteAddress from properties (and to set properties of the Exchange first)</description>
			<version>2.15.1</version>
			<fixedVersion>2.14.3, 2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.NettyPayloadHelper.java</file>
			<file type="M">org.apache.camel.component.netty4.NettyUdpWithInOutUsingPlainSocketTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="7978" opendate="2014-10-28 08:24:04" fixdate="2015-04-22 14:18:39" resolution="Fixed">
		<buginformation>
			<summary>QuartzEndpoint should share the same camel context name when it working in cluster mode</summary>
			<description>It could cause some trouble when camel-quartz endpoints is  share different camel context name.
We can add an option in the QuartzEndpoint to use CamelContext Name instead of management name.</description>
			<version>2.13.2</version>
			<fixedVersion>2.15.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.quartz2.SpringQuartzPersistentStoreRestartAppChangeOptionsTest.java</file>
			<file type="M">org.apache.camel.component.quartz.SpringQuartzPersistentStoreRestartAppChangeOptionsTest.java</file>
			<file type="M">org.apache.camel.component.quartz.QuartzEndpoint.java</file>
			<file type="M">org.apache.camel.component.quartz2.QuartzHelper.java</file>
			<file type="M">org.apache.camel.component.quartz2.QuartzEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="8687" opendate="2015-04-23 06:24:09" fixdate="2015-04-23 07:54:26" resolution="Fixed">
		<buginformation>
			<summary>SyslogConverter doesn&amp;apos;t handle the structured data rightly</summary>
			<description>As there are &amp;amp;apos; &amp;amp;apos; inside the structured data, we cannot just check &amp;amp;apos; &amp;amp;apos;  for separation of the structured message.
Here is the discussion about it.
http://camel.465427.n5.nabble.com/Syslog-data-format-incorrect-parsing-of-structured-data-td5766123.html</description>
			<version>2.14.2</version>
			<fixedVersion>2.14.3, 2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.syslog.NettyRfc5425Test.java</file>
			<file type="M">org.apache.camel.component.syslog.SyslogConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="8607" opendate="2015-04-09 15:32:35" fixdate="2015-04-23 10:52:33" resolution="Fixed">
		<buginformation>
			<summary>Camel endpoint RAW password unsafe characters</summary>
			<description>I am creating a camel endpoint such as this (somehost/someport/baseurl have been replaced):
https4://somehost:someport/baseurl?authenticationPreemptive=true&amp;amp;authPassword=RAW(foo%bar)&amp;amp;authUsername=RAW(username)
This causes camel to log the entire endpoint, including the user/password:
(DefaultComponent.java:67) - Supplied URI &amp;amp;apos;https4://somehost:someport/baseurl?authenticationPreemptive=true&amp;amp;authPassword=RAW(foo%bar)&amp;amp;authUsername=RAW(username)&amp;amp;apos; contains unsafe characters, please check encoding
Consider:
-It is a security issue to log the username/password
-Specifiying RAW would allow for special characters, specifically for passwords, as indicated here : https://camel.apache.org/configuring-camel.html, but it seems that UnsafeUriCharactersEncoder is not handling them appropriately.
</description>
			<version>2.15.1</version>
			<fixedVersion>2.14.3, 2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http4.HttpEndpointURLTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultComponent.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">8649</link>
		</links>
	</bug>
	<bug id="8683" opendate="2015-04-22 10:00:19" fixdate="2015-04-23 13:52:13" resolution="Fixed">
		<buginformation>
			<summary>Using load balancer in onException adds duplicate outputs for each route defined</summary>
			<description>If using load balancer in context scoped onException then it adds duplicate outputs per route you have. So if you have 3 routes, then there is 2 x duplicates as there is 2 additional routes.</description>
			<version>2.15.1</version>
			<fixedVersion>2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.LoadBalancerDefinition.java</file>
			<file type="M">org.apache.camel.issues.AdviceWithOnExceptionAndInterceptTest.java</file>
			<file type="M">org.apache.camel.model.LoadBalanceDefinition.java</file>
			<file type="M">org.apache.camel.model.loadbalancer.CustomLoadBalancerDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="8690" opendate="2015-04-23 15:00:55" fixdate="2015-04-23 15:13:03" resolution="Fixed">
		<buginformation>
			<summary>Camel HDFS2 - ShutdownHookManager class not found when shutting down OSGi framework</summary>
			<description>During shutdown of Karaf with camel-hdfs2 installed, I&amp;amp;apos;m getting:

Exception in thread "Thread-56" java.lang.NoClassDefFoundError: org/apache/hadoop/util/ShutdownHookManager$2
	at org.apache.hadoop.util.ShutdownHookManager.getShutdownHooksInOrder(ShutdownHookManager.java:124)
	at org.apache.hadoop.util.ShutdownHookManager$1.run(ShutdownHookManager.java:52)
Caused by: java.lang.ClassNotFoundException: Unable to load class &amp;amp;apos;org.apache.hadoop.util.ShutdownHookManager$2&amp;amp;apos; because the bundle wiring for org.apache.servicemix.bundles.hadoop-client is no longer valid.
	at org.apache.felix.framework.BundleWiringImpl.findClassOrResourceByDelegation(BundleWiringImpl.java:1521)
	at org.apache.felix.framework.BundleWiringImpl.access$400(BundleWiringImpl.java:77)
	at org.apache.felix.framework.BundleWiringImpl$BundleClassLoader.loadClass(BundleWiringImpl.java:1993)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:358)
	... 2 more

</description>
			<version>2.15.1</version>
			<fixedVersion>2.15.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.camel.component.hdfs2.HdfsActivator.java</file>
		</fixedFiles>
	</bug>
	<bug id="8694" opendate="2015-04-24 05:48:24" fixdate="2015-04-24 21:30:32" resolution="Fixed">
		<buginformation>
			<summary>java.lang.NullPointerException in at org.apache.camel.component.netty4.http.NettyHttpProducer$NettyHttpProducerCallback.done</summary>
			<description>I am using camel-netty4-http 2.15.1 version and getting the following NPE in org.apache.camel.component.netty4.http.NettyHttpProducer$NettyHttpProducerCallback.done. Debugging through the code it seems like null check for response is missing.
 public void done(boolean doneSync) {
            try {
                NettyHttpMessage nettyMessage = exchange.hasOut() ? exchange.getOut(NettyHttpMessage.class) : exchange.getIn(NettyHttpMessage.class);
                if (nettyMessage != null) {
                    FullHttpResponse response = nettyMessage.getHttpResponse();
                    // Need to retain the ByteBuffer for producer to consumer
                    // TODO Remove this part of ByteBuffer right away
                    response.content().retain();  &amp;lt;-- response in null
                    if (response != null) {
java.lang.NullPointerException
	at org.apache.camel.component.netty4.http.NettyHttpProducer$NettyHttpProducerCallback.done(NettyHttpProducer.java:98)
	at org.apache.camel.component.netty4.NettyProducer.process(NettyProducer.java:181)
	at org.apache.camel.component.netty4.http.NettyHttpProducer.process(NettyHttpProducer.java:52)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:129)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:77)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:448)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.processor.ChoiceProcessor.process(ChoiceProcessor.java:111)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:77)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:448)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.component.netty4.handlers.ServerChannelHandler.processAsynchronously(ServerChannelHandler.java:134)
	at org.apache.camel.component.netty4.handlers.ServerChannelHandler.channelRead0(ServerChannelHandler.java:105)
	at org.apache.camel.component.netty4.http.handlers.HttpServerChannelHandler.channelRead0(HttpServerChannelHandler.java:202)
	at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:105)
	at org.apache.camel.component.netty4.http.handlers.HttpServerMultiplexChannelHandler.channelRead0(HttpServerMultiplexChannelHandler.java:119)
	at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:105)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
	at io.netty.channel.AbstractChannelHandlerContext.access$600(AbstractChannelHandlerContext.java:32)
	at io.netty.channel.AbstractChannelHandlerContext$7.run(AbstractChannelHandlerContext.java:329)
	at io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:36)
	at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
	at java.lang.Thread.run(Thread.java:744)</description>
			<version>2.15.1</version>
			<fixedVersion>2.14.3, 2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8707" opendate="2015-04-27 14:50:40" fixdate="2015-04-28 14:05:25" resolution="Fixed">
		<buginformation>
			<summary>camel-smpp: smpps doesn&amp;apos;t work over proxy</summary>
			<description>
We are evaluating on using apache camel + jsmpp for sending smses. 
apache camel version: 2.15.1
jsmpp version: 2.1.1
smpp works fine with proxy, but smpps with doesn&amp;amp;apos;t work. 
Route definition is as follows: 
from(direct:start)
.to(smpps://user@smschost:smscport?password=********&amp;amp;httpProxyHost=proxyhostname&amp;amp;httpProxyPort=proxyportisteredDelivery=1&amp;amp;lazySessionCreation=true)
from(smpps://user@smschost:smscport?password=********&amp;amp;httpProxyHost=proxyhostname&amp;amp;httpProxyPort=proxyportisteredDelivery=1)
.to(direct.result)
When using smpps, we are getting the following exception: 
Failed to start camel Context
java.io.IOException: SmppConnectionFactory: Unrecognized SSL message,
plaintext connection?
        at
org.apache.camel.component.smpp.SmppConnectionFactory.createConnection(SmppConnectionFactory.java:97)
        at
org.jsmpp.session.SMPPSession.connectAndBind(SMPPSession.java:221)
        at
org.jsmpp.session.SMPPSession.connectAndBind(SMPPSession.java:200)
        at
org.apache.camel.component.smpp.SmppConsumer.createSession(SmppConsumer.java:95)
        at
org.apache.camel.component.smpp.SmppConsumer.doStart(SmppConsumer.java:84)
In SmppConnectionFactory.createConnection(), for smpps, there is a HTTP
connect in SSL Socket. 
We should be tunnelling SSL through HTTP, as given below: 
https://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/samples/sockets/client/SSLSocketClientWithTunneling.java</description>
			<version>2.15.1</version>
			<fixedVersion>2.14.3, 2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.smpp.SmppConnectionFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="8713" opendate="2015-04-28 15:08:13" fixdate="2015-04-28 18:34:02" resolution="Fixed">
		<buginformation>
			<summary>ParallelAggregate option when using parallel mode does not run in parallel</summary>
			<description>See CAMEL-7521
When using parallel processing then the boss thread aggregate on the fly is a single threaded boss thread that controls the aggregation. So even if setting parallel aggregate = true, then its still only 1 boss thread.
We should have a thread pool (or allow to use the existing pool for parallel processing) for worker threads to do the aggregate work in parallel.</description>
			<version>2.15.1</version>
			<fixedVersion>2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="8715" opendate="2015-04-29 05:40:56" fixdate="2015-04-29 11:13:46" resolution="Fixed">
		<buginformation>
			<summary>camel-sql - Should close ResultSet</summary>
			<description>See SO
http://stackoverflow.com/questions/29933629/apache-camel-sql-component-is-not-closing-resultset
The Spring javadocs says

&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;NOTE:&amp;lt;/b&amp;gt; Any ResultSets opened should be closed in finally blocks
within the callback implementation. Spring will close the Statement
object after the callback returned, but this does not necessarily imply
that the ResultSet resources will be closed: the Statement objects might
get pooled by the connection pool, with 
{@code close}
 calls only
returning the object to the pool but not physically closing the resources.

</description>
			<version>2.15.1</version>
			<fixedVersion>2.14.3, 2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sql.SqlEndpoint.java</file>
			<file type="M">org.apache.camel.component.sql.SqlProducer.java</file>
			<file type="M">org.apache.camel.component.sql.SqlConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8702" opendate="2015-04-26 07:18:34" fixdate="2015-04-30 06:06:03" resolution="Fixed">
		<buginformation>
			<summary>when occurs "Connection reset by peer",netty4 client&amp;apos;s EventLoopGroup select thread won&amp;apos;t shut down</summary>
			<description>I used netty4 and netty4http as producer ,when occurs  exception "Connection reset by peer",netty4 client&amp;amp;apos;s EventLoopGroup "Selector" thread and related port won&amp;amp;apos;t shut down.I used thread dump and found ClientChannelHandler&amp;amp;apos;s method exceptionCaught just close channel,it won&amp;amp;apos;t close "Selector" thread and port, and the same to NettyProducer.NettyProducerPoolableObjectFactory.destroyObject.</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.NettyServerBootstrapConfiguration.java</file>
			<file type="M">org.apache.camel.component.netty4.NettyProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8270" opendate="2015-01-23 10:52:27" fixdate="2015-04-30 07:05:57" resolution="Fixed">
		<buginformation>
			<summary>camel-rabbitmq: exchangeName in URI must be optional, i.e. default "" exchange</summary>
			<description>Leaving out the exchangeName i.e. rabbitmq://localhost/ throws exception below.
However RabbitMQ has the default exchange "" so it&amp;amp;apos;s not required to specify amq.direct explicitly., and this makes it impossible to send to that exchange (which is different than amq.direct).
Should have been fixed by CAMEL-7031 (2.12.3) but still happens in 2.14.1 (probably regression)


Exception in thread "main" org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;camelContext&amp;amp;apos; defined in class path resource [id/ac/itb/lumen/persistence/LumenCamelConfiguration.class]: Invocation of init method failed; nested exception is org.apache.camel.FailedToCreateRouteException: Failed to create route route1 at: &amp;gt;&amp;gt;&amp;gt; To[rabbitmq://localhost/?connectionFactory=#amqpConnFactory] &amp;lt;&amp;lt;&amp;lt; in route: Route(route1)[[From[rabbitmq://localhost/amq.topic?connectio... because of Failed to resolve endpoint: rabbitmq://localhost/?connectionFactory=%23amqpConnFactory due to: No URI path as the exchangeName for the RabbitMQEndpoint, the URI is rabbitmq://localhost/?connectionFactory=%23amqpConnFactory
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1566)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:539)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:476)
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:303)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:299)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:194)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:762)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:757)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:480)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:691)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:321)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:961)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:950)
	at org.springframework.boot.SpringApplication$run.call(Unknown Source)
	at org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:45)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:108)
	at org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:120)
	at id.ac.itb.lumen.persistence.LumenPersistenceApplication.main(LumenPersistenceApplication.groovy:38)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)
Caused by: org.apache.camel.FailedToCreateRouteException: Failed to create route route1 at: &amp;gt;&amp;gt;&amp;gt; To[rabbitmq://localhost/?connectionFactory=#amqpConnFactory] &amp;lt;&amp;lt;&amp;lt; in route: Route(route1)[[From[rabbitmq://localhost/amq.topic?connectio... because of Failed to resolve endpoint: rabbitmq://localhost/?connectionFactory=%23amqpConnFactory due to: No URI path as the exchangeName for the RabbitMQEndpoint, the URI is rabbitmq://localhost/?connectionFactory=%23amqpConnFactory
	at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:945)
	at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:187)
	at org.apache.camel.impl.DefaultCamelContext.startRoute(DefaultCamelContext.java:805)
	at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:2174)
	at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:1906)
	at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:1767)
	at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:61)
	at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:1735)
	at org.apache.camel.spring.SpringCamelContext.maybeStart(SpringCamelContext.java:254)
	at org.apache.camel.spring.SpringCamelContext.afterPropertiesSet(SpringCamelContext.java:106)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1625)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1562)
	... 23 more
Caused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: rabbitmq://localhost/?connectionFactory=%23amqpConnFactory due to: No URI path as the exchangeName for the RabbitMQEndpoint, the URI is rabbitmq://localhost/?connectionFactory=%23amqpConnFactory
	at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:547)
	at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:72)
	at org.apache.camel.model.RouteDefinition.resolveEndpoint(RouteDefinition.java:202)
	at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:107)
	at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:113)
	at org.apache.camel.model.SendDefinition.resolveEndpoint(SendDefinition.java:61)
	at org.apache.camel.model.SendDefinition.createProcessor(SendDefinition.java:55)
	at org.apache.camel.model.ProcessorDefinition.makeProcessor(ProcessorDefinition.java:500)
	at org.apache.camel.model.ProcessorDefinition.addRoutes(ProcessorDefinition.java:213)
	at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:942)
	... 34 more
Caused by: java.lang.IllegalArgumentException: No URI path as the exchangeName for the RabbitMQEndpoint, the URI is rabbitmq://localhost/?connectionFactory=%23amqpConnFactory
	at org.apache.camel.component.rabbitmq.RabbitMQComponent.createEndpoint(RabbitMQComponent.java:50)
	at org.apache.camel.component.rabbitmq.RabbitMQComponent.createEndpoint(RabbitMQComponent.java:31)
	at org.apache.camel.impl.DefaultComponent.createEndpoint(DefaultComponent.java:122)
	at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:527)
	... 43 more

</description>
			<version>2.14.1</version>
			<fixedVersion>2.14.3, 2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.DefaultRestletBinding.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQEndpointTest.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQComponent.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">7678</link>
			<link type="Reference" description="relates to">7003</link>
			<link type="Reference" description="relates to">8271</link>
			<link type="Required" description="requires">7031</link>
		</links>
	</bug>
	<bug id="7678" opendate="2014-08-11 13:17:49" fixdate="2015-04-30 07:07:22" resolution="Fixed">
		<buginformation>
			<summary>Update camel-rabbitmq URI for consumers</summary>
			<description>The camel-rabbitmq requires a mandatory amqp exchange as the first parameter in the URI.  Other options are specfied after the "?.  This is appropriate for producers, but not for consumers.  Subscribers should specify the queue name as the first parameter.</description>
			<version>2.13.2</version>
			<fixedVersion>2.14.3, 2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.DefaultRestletBinding.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQEndpointTest.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQComponent.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">8270</link>
		</links>
	</bug>
	<bug id="8688" opendate="2015-04-23 12:02:10" fixdate="2015-05-04 18:00:05" resolution="Fixed">
		<buginformation>
			<summary>Removed StreamCache when doing a Wiretap</summary>
			<description>Hi,
I noticed a bug where the body (StreamCache) was already removed before the exchange reached the end (in the Wiretap route).
I added a test as an attachment.
f you run the test you can clearly see the temp file deletion followed by the closed stream exception:
Tried 1 to delete file: /var/folders/db/brq60fqj4vb8mnx_5nlz36nw0000gn/T/camel/camel-tmp-00cd1ce2-7d44-47fe-b357-008e8146f770/cos8797132745923044996.tmp with result: true
Cannot reset stream from file /var/folders/db/brq60fqj4vb8mnx_5nlz36nw0000gn/T/camel/camel-tmp-00cd1ce2-7d44-47fe-b357-008e8146f770/cos8797132745923044996.tmp
I encountered the same issue during a more complex route that does some splitting (zip file) and multicasting. This occurred on Camel 2.14.1 so it could be fixed by https://issues.apache.org/jira/browse/CAMEL-8284 but I need to test this.
Kind regards,
Geert</description>
			<version>2.15.1</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.converter.CachedCxfPayloadTest.java</file>
			<file type="M">org.apache.camel.component.cxf.converter.CachedCxfPayload.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyChannelBufferStreamCache.java</file>
			<file type="M">org.apache.camel.converter.stream.SourceCache.java</file>
			<file type="M">org.apache.camel.converter.stream.CachedOutputStream.java</file>
			<file type="M">org.apache.camel.converter.stream.ReaderCache.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyChannelBufferStreamCache.java</file>
			<file type="M">org.apache.camel.util.MessageHelperTest.java</file>
			<file type="M">org.apache.camel.converter.stream.StreamSourceCache.java</file>
			<file type="M">org.apache.camel.processor.WireTapStreamCachingTest.java</file>
			<file type="M">org.apache.camel.processor.WireTapProcessor.java</file>
			<file type="M">org.apache.camel.converter.stream.InputStreamCache.java</file>
			<file type="M">org.apache.camel.converter.stream.ByteArrayInputStreamCache.java</file>
			<file type="M">org.apache.camel.StreamCache.java</file>
			<file type="M">org.apache.camel.converter.stream.FileInputStreamCache.java</file>
		</fixedFiles>
	</bug>
	<bug id="8689" opendate="2015-04-23 12:37:25" fixdate="2015-05-04 18:54:47" resolution="Fixed">
		<buginformation>
			<summary>camel-dozer: Multiple contexts / bundles - Does not use the correct classloader</summary>
			<description>Dozer is a tough library to work with in a multi-module context, because of its use of singletons for configuration. In an OSGi environment, each bundle will have its own classloader but Dozer&amp;amp;apos;s architecture makes it impossible to cater for this scenario nicely. Unfortunately, it expects a single container-wide classloader configured in the BeanContainer singleton.
In Camel we worked around this by providing a custom DozerClassLoader implementation that is aware of the Camel Context, but what happens if we are sharing Dozer across multiple Camel Contexts? The most recently initialized context will override the container-wide classloader.
We need a solution such that the classloader can dynamically change based on the Camel Context that is using the component.</description>
			<version>2.15.1</version>
			<fixedVersion>2.14.3, 2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.dozer.DozerThreadContextClassLoader.java</file>
			<file type="M">org.apache.camel.converter.dozer.DozerTypeConverter.java</file>
			<file type="D">org.apache.camel.converter.dozer.CamelToDozerClassResolverAdapter.java</file>
			<file type="M">org.apache.camel.converter.dozer.DozerTypeConverterLoader.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8748</link>
		</links>
	</bug>
	<bug id="8737" opendate="2015-05-04 06:53:28" fixdate="2015-05-04 20:21:16" resolution="Fixed">
		<buginformation>
			<summary>camel-salesforce - Unable to generate DTOs for Filtered Lookup fields</summary>
			<description>Get the following exception:
Caused by: org.apache.maven.plugin.MojoExecutionException: Error getting SObject description for &amp;amp;apos;Account_Request__c&amp;amp;apos;: Can not deserialize instance of java.lang.String out of START_ARRAY token
 at [Source: java.io.ByteArrayInputStream@1bd8e9d9; line: 1, column: 36155] (through reference chain: org.apache.camel.component.salesforce.api.dto.SObjectDescription["fields"]&amp;gt;org.apache.camel.component.salesforce.api.dto.SObjectField["filteredLookupInfo"]&amp;gt;org.apache.camel.component.salesforce.ap
i.dto.FilteredLookupInfo["controllingFields"])
        at org.apache.camel.maven.CamelSalesforceMojo.execute(CamelSalesforceMojo.java:312)
        at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:101)
        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:209)
        ... 19 more
Caused by: org.codehaus.jackson.map.JsonMappingException: Can not deserialize instance of java.lang.String out of START_ARRAY token
 at [Source: java.io.ByteArrayInputStream@1bd8e9d9; line: 1, column: 36155] (through reference chain: org.apache.camel.component.salesforce.api.dto.SObjectDescription["fields"]&amp;gt;org.apache.camel.component.salesforce.api.dto.SObjectField["filteredLookupInfo"]&amp;gt;org.apache.camel.component.salesforce.ap
i.dto.FilteredLookupInfo["controllingFields"])
        at org.codehaus.jackson.map.JsonMappingException.from(JsonMappingException.java:163)
Any suggestions what could causing this issue?
From the looks of it, the class
public class FilteredLookupInfo extends AbstractDTOBase 
{

    private String controllingFields;
    ...
}

should be 
public class FilteredLookupInfo extends AbstractDTOBase 
{

    private List controllingFields;
}

The type in question has a child relation to another custom object.</description>
			<version>2.15.1</version>
			<fixedVersion>2.14.3, 2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.camel.component.salesforce.api.dto.ActionOverrideTypeEnum.java</file>
			<file type="M">org.apache.camel.component.salesforce.api.dto.ActionOverride.java</file>
			<file type="M">org.apache.camel.component.salesforce.api.dto.FilteredLookupInfo.java</file>
			<file type="M">org.apache.camel.component.salesforce.api.dto.PickListValue.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8269</link>
		</links>
	</bug>
	<bug id="8745" opendate="2015-05-06 06:50:48" fixdate="2015-05-06 08:05:32" resolution="Fixed">
		<buginformation>
			<summary>Swagger requires context name with quotes </summary>
			<description>

    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;ApiDeclarationServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.apache.camel.component.swagger.DefaultCamelSwaggerServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;base.path&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;rest&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;api.path&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;api-docs&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;api.version&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;1.2.3&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;api.title&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;User Services&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;api.description&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;Camel Rest Example with Swagger that provides an User REST service&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;camelId&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;"swagger-test"&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;load-on-startup&amp;gt;2&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;

</description>
			<version>2.15.1</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.swagger.DefaultCamelSwaggerServletTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8747" opendate="2015-05-06 07:58:33" fixdate="2015-05-06 08:19:57" resolution="Fixed">
		<buginformation>
			<summary>camel-rx - Should leverage UoW when subscribe or observe</summary>
			<description>See SO
http://stackoverflow.com/questions/30057358/camel-rx-is-not-deleting-objects-consumed-from-s3
The work should be done in an UoW to ensure on completions is executed.</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.rx.SendToTest.java</file>
			<file type="M">org.apache.camel.rx.support.EndpointSubscription.java</file>
			<file type="M">org.apache.camel.rx.support.ObserverSender.java</file>
		</fixedFiles>
	</bug>
	<bug id="8746" opendate="2015-05-06 07:48:11" fixdate="2015-05-07 16:24:55" resolution="Fixed">
		<buginformation>
			<summary>Jasypt with BridgePropertyPlaceholderConfigurer is not handling spring property injection with defaults anymore</summary>
			<description>After updating from 2.15.1 to 2.15.2 injecting property values handled by Jasypt via BridgePropertyPlaceholderConfigurer is not supporting default values any more.
Code like 


    @Value("${testProperty:test}")
    private String test;


is leading to NullPointerException:

org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;test&amp;amp;apos;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private java.lang.String org.apache.camel.component.jasypt.Test.test; nested exception is java.lang.NullPointerException
        at java.util.regex.Matcher.getTextLength(Matcher.java:1234)
        at java.util.regex.Matcher.reset(Matcher.java:308)
        at java.util.regex.Matcher.&amp;lt;init&amp;gt;(Matcher.java:228)
        at java.util.regex.Pattern.matcher(Pattern.java:1088)
        at org.apache.camel.component.jasypt.JasyptPropertiesParser.parseProperty(JasyptPropertiesParser.java:56)
        at org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer.resolvePlaceholder(BridgePropertyPlaceholderConfigurer.java:121)
        at org.springframework.beans.factory.config.PropertyPlaceholderConfigurer.resolvePlaceholder(PropertyPlaceholderConfigurer.java:162)</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jasypt.JasyptPropertiesParser.java</file>
			<file type="M">org.apache.camel.component.jasypt.JasyptPropertiesParserTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8718" opendate="2015-04-29 09:34:07" fixdate="2015-05-07 18:14:40" resolution="Fixed">
		<buginformation>
			<summary>Connection leak with ftp consumer and invalid credentials</summary>
			<description>In each iteration new socket connection is created, but never closed. This leads to growth of ESTABLISHED connections to FTP server.</description>
			<version>2.12.5</version>
			<fixedVersion>2.14.3, 2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpOperations.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpBadLoginConnectionLeakTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8758" opendate="2015-05-08 12:36:51" fixdate="2015-05-10 07:11:52" resolution="Fixed">
		<buginformation>
			<summary>NPE for CacheComponent</summary>
			<description>I have randomly NPE for cache component
java.lang.NullPointerException
	at org.apache.camel.component.cache.CacheProducer.performCacheOperation(CacheProducer.java:98)
	at org.apache.camel.component.cache.CacheProducer.process(CacheProducer.java:71)
	at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:113)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:72)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:118)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:80)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:105)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:87)
	at org.apache.camel.component.jms.EndpointMessageListener.onMessage(EndpointMessageListener.java:103)
	at org.springframework.jms.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:562)
	at org.springframework.jms.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:500)
	at org.springframework.jms.listener.AbstractMessageListenerContainer.doExecuteListener(AbstractMessageListenerContainer.java:468)
	at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.doReceiveAndExecute(AbstractPollingMessageListenerContainer.java:325)
	at org.springframework.jms.listener.AbstractPollingMessageListenerContainer.receiveAndExecute(AbstractPollingMessageListenerContainer.java:263)
	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.invokeListener(DefaultMessageListenerContainer.java:1101)
	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.executeOngoingLoop(DefaultMessageListenerContainer.java:1093)
	at org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker.run(DefaultMessageListenerContainer.java:990)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)</description>
			<version>2.14.2</version>
			<fixedVersion>2.14.3, 2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cache.CacheProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8765" opendate="2015-05-10 18:34:08" fixdate="2015-05-10 18:42:56" resolution="Fixed">
		<buginformation>
			<summary>JpaConsumer - May poll too soon before JPA stuff is initialized</summary>
			<description>There can be a NPE if the jpa consumer polls too soon


2015-05-10 20:35:25,605 [ction.BookOrder] WARN  JpaConsumer                    - Consumer Consumer[jpa://camelinaction.BookOrder] failed polling endpoint: Endpoint[jpa://camelinaction.BookOrder]. Will try again at next poll. Caused by: [java.lang.NullPointerException - null]
java.lang.NullPointerException
	at org.apache.camel.component.jpa.JpaConsumer$1.doInTransaction(JpaConsumer.java:97)
	at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:133)
	at org.apache.camel.component.jpa.JpaConsumer.poll(JpaConsumer.java:94)
	at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:174)
	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:101)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)

</description>
			<version>2.15.2</version>
			<fixedVersion>2.14.3, 2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jpa.JpaConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8782" opendate="2015-05-19 19:44:04" fixdate="2015-05-19 20:25:57" resolution="Fixed">
		<buginformation>
			<summary>Configuring endpoints using reference lookup may fail with matching primitive types with their Object counterpart types</summary>
			<description>Based on PR
https://github.com/apache/camel/pull/522#issuecomment-103620070
Yeah I had a look its due primtive vs object types, that causes Camel to not match the setter method.
eg the method uses a boolean type, but the returned value from the reference lookup is a java.lang.Boolen type. And therefor its not used. I will log a ticket and fix that.</description>
			<version>2.15.2</version>
			<fixedVersion>2.14.3, 2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.IntrospectionSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="8785" opendate="2015-05-21 03:16:26" fixdate="2015-05-21 06:53:45" resolution="Fixed">
		<buginformation>
			<summary>StackOverFlowError using Custom InterceptStrategy</summary>
			<description>Testing a route including camel&amp;amp;apos;s custom InterceptStrategy, http://camel.apache.org/intercept.html, got a StackOverFlowError as below,


org.apache.camel.CamelExecutionException: Exception occurred during execution on the exchange: Exchange[Message: Test]
at org.apache.camel.util.ObjectHelper.wrapCamelExecutionException(ObjectHelper.java:1379)
at org.apache.camel.impl.DefaultExchange.setException(DefaultExchange.java:283)
at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:381)
at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:346)
at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:242)
at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:346)
Caused by: java.lang.StackOverflowError
at java.lang.ThreadLocal$ThreadLocalMap.nextIndex(ThreadLocal.java:313)
at java.lang.ThreadLocal$ThreadLocalMap.expungeStaleEntry(ThreadLocal.java:563)
at java.lang.ThreadLocal$ThreadLocalMap.remove(ThreadLocal.java:461)
at java.lang.ThreadLocal$ThreadLocalMap.access$200(ThreadLocal.java:261)
at java.lang.ThreadLocal.remove(ThreadLocal.java:202)


The stack shows me StackOverFlowError on the org.apache.camel.processor.InterceptorToAsyncProcessorBridge.process() for the affected camel versions.</description>
			<version>2.14.2</version>
			<fixedVersion>2.14.3, 2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.itest.issues.IntercepFromAndStrategyTest.java</file>
			<file type="M">org.apache.camel.processor.interceptor.DefaultChannel.java</file>
		</fixedFiles>
	</bug>
	<bug id="8786" opendate="2015-05-21 06:34:04" fixdate="2015-05-21 14:21:20" resolution="Fixed">
		<buginformation>
			<summary>The ServletContext init parameters check is not right in CamelServletContextListener</summary>
			<description>CamelServletContextListener always complains, even the parameter is quite useful. 


There are 1 ServletContext init parameters, unknown to Camel. Maybe they are  used by other frameworks? [{routeBuilder-routes=com.mycompany.MyRoute}]


There is the mail thread  about it </description>
			<version>2.14.2</version>
			<fixedVersion>2.14.3, 2.15.2, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.servletlistener.CamelServletContextListener.java</file>
		</fixedFiles>
	</bug>
	<bug id="8780" opendate="2015-05-18 05:18:10" fixdate="2015-05-22 02:59:02" resolution="Fixed">
		<buginformation>
			<summary>Camel exec component have trouble to load arguments list from message header</summary>
			<description>When trying to set the following header:


            &amp;lt;setHeader headerName="CamelExecCommandArgs" &amp;gt;
                &amp;lt;simple&amp;gt;"--import" "--export"&amp;lt;/simple&amp;gt;
            &amp;lt;/setHeader&amp;gt;


We receive the following error:


org.apache.camel.TypeConversionException: Error during type conversion from type: java.lang.String to the required type: java.util.List with value "--import" "--export" due java.lang.NumberFormatException: For input string: ""--import" "--export""

</description>
			<version>2.14.2</version>
			<fixedVersion>2.14.3, 2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.exec.impl.DefaultExecCommandExecutor.java</file>
			<file type="M">org.apache.camel.language.simple.SimpleParserExpressionTest.java</file>
			<file type="M">org.apache.camel.component.snmp.SnmpConverters.java</file>
			<file type="M">org.apache.camel.component.exec.impl.DefaultExecBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="8774" opendate="2015-05-13 08:09:50" fixdate="2015-05-27 14:19:53" resolution="Fixed">
		<buginformation>
			<summary>DefaultJettyHttpBinding preserves CONTEXT_ENCODING from the request even HTTP response doesn&amp;apos;t contain the header</summary>
			<description>When Http Request is Gzip encoded (CONTENT_ENCODING is set) but the HTTP response is not ( httpExchange.getResponseHeaders().get(HttpHeaders.CONTENT_ENCODING) == null) then Exchange.CONTENT_ENCODING is present in the Camel out message.
This is because DefaultJettyHttpBinding:125 preserves all in headers.
I believe that HTTP protocol headers (except custom ones) from the in shouldn&amp;amp;apos;t be copied to the Camel out message.</description>
			<version>2.15.2</version>
			<fixedVersion>2.14.3, 2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http4.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.http4.HttpCompressionTest.java</file>
			<file type="M">org.apache.camel.component.ahc.DefaultAhcBinding.java</file>
			<file type="M">org.apache.camel.component.http.HttpProducer.java</file>
			<file type="M">org.apache.camel.component.jetty.DefaultJettyHttpBinding.java</file>
			<file type="M">org.apache.camel.util.MessageHelper.java</file>
			<file type="M">org.apache.camel.util.MessageHelperTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8798" opendate="2015-05-26 13:14:56" fixdate="2015-05-29 07:43:57" resolution="Fixed">
		<buginformation>
			<summary>weaveAddLast throwing UnsupportedOperation when route have a ChoiceDefinition</summary>
			<description>I&amp;amp;apos;m currently upgrading from Camel 2.14.1 to 2.15.2, after the upgrade some of my test are failing. 
My route is: 

from("file:input?idempotent=true&amp;amp;moveFailed=.error").routeId("MyRoute")
        .choice()
             .when(body().isEqualTo("body1"))
                 .log("body1")
             .otherwise()
                .log("notBody1")
       .end()
 

My test contains : 

camelContext.getRouteDefinition("MyRoute").adviceWith(camelContext, new AdviceWithRouteBuilder() {
            @Override
            public void configure() {
                weaveAddLast().to(mockOutput);
            }
        });


The weaveAddLast is failing with the following stackTrace: 


java.lang.UnsupportedOperationException 
        at java.util.AbstractList.add(AbstractList.java:148) 
        at org.apache.camel.builder.AdviceWithTasks$4.task(AdviceWithTasks.java:298) 
        at org.apache.camel.model.RouteDefinition.adviceWith(RouteDefinition.java:270) 


After some debug I found that when my route and with a Choice I cannot weaveAddLast the route. 
When the AdviceWithTasks task method try to add the outputs (here) the implementation of the list return by the ChoiceDefinition class does not implements the method add(int,Object) then we have the UnsupportedOperation 
The difference between 2.14.1 and 2.15.2 is that in the AdviceWithTasks the outputs list where the weaveAddLast try to find the last Processor to add the outputs is not a list returned by ChoiceDefinition but it&amp;amp;apos;s a list with the Logs processor. 
This difference is there because now in 2.15.2 the method that is going through the route to retrieve the outputs nodes have a maximum depth which is computed here
When my route have finish with a ChoiceDefinition the maximum depth computed is only 1 then I cannot have my logs in outputs an the weaveAddLast have in his list only the ChoiceDefinition. </description>
			<version>2.14.2</version>
			<fixedVersion>2.15.3, 2.16.0, 2.14.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ProcessorDefinitionHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="8812" opendate="2015-05-28 08:15:56" fixdate="2015-05-29 15:27:38" resolution="Fixed">
		<buginformation>
			<summary>Memory leak in HL7MLLPNettyDecoder</summary>
			<description>HL7MLLPNettyDecoder leaks memory because it doesn&amp;amp;apos;t release the Netty ByteBuf it uses.
Checkout http://netty.io/wiki/reference-counted-objects.html for more information about Netty ByteBuf and preventing leaks.
When I set the leak detection level to paranoid (-Dio.netty.leakDetectionLevel=paranoid) I get consistent leak reports like the one below.
I think the solution is to call buf.release() in the decode() method after it&amp;amp;apos;s done with buf. But I&amp;amp;apos;m still trying to reproduce this in a unit test.
2015-05-28 10:13:48,951 ERROR io.netty.util.ResourceLeakDetector - LEAK: ByteBuf.release() was not called before it&amp;amp;apos;s garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.
Recent access records: 5
#5:
	io.netty.buffer.AdvancedLeakAwareByteBuf.release(AdvancedLeakAwareByteBuf.java:45)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:236)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
	io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
	io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
	java.lang.Thread.run(Thread.java:745)
#4:
	io.netty.buffer.AdvancedLeakAwareByteBuf.toString(AdvancedLeakAwareByteBuf.java:697)
	org.apache.camel.component.hl7.HL7MLLPNettyDecoder.asString(HL7MLLPNettyDecoder.java:90)
	org.apache.camel.component.hl7.HL7MLLPNettyDecoder.decode(HL7MLLPNettyDecoder.java:66)
	io.netty.handler.codec.DelimiterBasedFrameDecoder.decode(DelimiterBasedFrameDecoder.java:216)
	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:315)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:229)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
	io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
	io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
	java.lang.Thread.run(Thread.java:745)
#3:
	io.netty.buffer.AdvancedLeakAwareByteBuf.slice(AdvancedLeakAwareByteBuf.java:73)
	org.apache.camel.component.hl7.HL7MLLPNettyDecoder.decode(HL7MLLPNettyDecoder.java:64)
	io.netty.handler.codec.DelimiterBasedFrameDecoder.decode(DelimiterBasedFrameDecoder.java:216)
	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:315)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:229)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
	io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
	io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
	java.lang.Thread.run(Thread.java:745)
#2:
	io.netty.buffer.AdvancedLeakAwareByteBuf.bytesBefore(AdvancedLeakAwareByteBuf.java:607)
	org.apache.camel.component.hl7.HL7MLLPNettyDecoder.decode(HL7MLLPNettyDecoder.java:62)
	io.netty.handler.codec.DelimiterBasedFrameDecoder.decode(DelimiterBasedFrameDecoder.java:216)
	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:315)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:229)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
	io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
	io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
	java.lang.Thread.run(Thread.java:745)
#1:
	io.netty.buffer.AdvancedLeakAwareByteBuf.retain(AdvancedLeakAwareByteBuf.java:709)
	io.netty.handler.codec.DelimiterBasedFrameDecoder.decode(DelimiterBasedFrameDecoder.java:277)
	org.apache.camel.component.hl7.HL7MLLPNettyDecoder.decode(HL7MLLPNettyDecoder.java:60)
	io.netty.handler.codec.DelimiterBasedFrameDecoder.decode(DelimiterBasedFrameDecoder.java:216)
	io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:315)
	io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:229)
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
	io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
	io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
	io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
	java.lang.Thread.run(Thread.java:745)
Created at:
	io.netty.buffer.UnpooledByteBufAllocator.newDirectBuffer(UnpooledByteBufAllocator.java:55)
	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:155)
	io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:146)
	io.netty.buffer.AbstractByteBufAllocator.ioBuffer(AbstractByteBufAllocator.java:107)
	io.netty.channel.AdaptiveRecvByteBufAllocator$HandleImpl.allocate(AdaptiveRecvByteBufAllocator.java:104)
	io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:117)
	io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
	io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
	io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
	io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
	java.lang.Thread.run(Thread.java:745)</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.hl7.HL7MLLPNettyDecoder.java</file>
			<file type="M">org.apache.camel.component.hl7.HL7MLLPCodecTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8816" opendate="2015-05-29 03:11:08" fixdate="2015-06-01 14:17:09" resolution="Fixed">
		<buginformation>
			<summary>Elasticsearch component fails in an OSGi environment due to missing names.txt</summary>
			<description>CAMEL-8194 just fix the setting load issue without using the local elasticsearch. When using the local elasticsearch in OSGi container, we still hit the error.</description>
			<version>2.14.3</version>
			<fixedVersion>2.14.3, 2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.elasticsearch.ElasticsearchEndpoint.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">8194</link>
		</links>
	</bug>
	<bug id="8829" opendate="2015-06-03 15:00:02" fixdate="2015-06-04 09:08:33" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentModificationException while logging</summary>
			<description>There is a route which consumes messages from CXFRS endpoint.
It publishes them into 2 SEDA endpoints:


from("direct:someCxfRsEndpoint")
   ...
   .to("seda:queue1?waitForTaskToComplete=Never&amp;amp;size=100&amp;amp;blockWhenFull=true&amp;amp;concurrentConsumers=1")
   .to("seda:queue2?waitForTaskToComplete=Never&amp;amp;size=100&amp;amp;blockWhenFull=true&amp;amp;concurrentConsumers=1")
   ...


Both the seda consumers print the message into log:


from("seda..")
   ...
   .to("log:queuelog?showAll=true&amp;amp;multiline=true")


ConcurrentModificationException is thrown during logging the message:


Error processing exchange. Exchange[Message: ...]. Caused by: [java.util.ConcurrentModificationException - null]
java.util.ConcurrentModificationException: null
        at java.util.HashMap$HashIterator.nextNode(HashMap.java:1429) ~[na:1.8.0_40]
        at java.util.HashMap$EntryIterator.next(HashMap.java:1463) ~[na:1.8.0_40]
        at java.util.HashMap$EntryIterator.next(HashMap.java:1461) ~[na:1.8.0_40]
        at java.util.AbstractMap.toString(AbstractMap.java:531) ~[na:1.8.0_40]
        at java.lang.String.valueOf(String.java:2982) ~[na:1.8.0_40]
        at java.lang.StringBuilder.append(StringBuilder.java:131) ~[na:1.8.0_40]
        at java.util.AbstractMap.toString(AbstractMap.java:536) ~[na:1.8.0_40]
        at java.lang.String.valueOf(String.java:2982) ~[na:1.8.0_40]
        at java.lang.StringBuilder.append(StringBuilder.java:131) ~[na:1.8.0_40]
        at org.apache.camel.processor.DefaultExchangeFormatter.format(DefaultExchangeFormatter.java:99) ~[camel-core-2.15.2.jar:2.15.2]
        at org.apache.camel.processor.CamelLogProcessor.process(CamelLogProcessor.java:66) ~[camel-core-2.15.2.jar:2.15.2]
        at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:109) ~[camel-core-2.15.2.jar:2.15.2]
        at org.apache.camel.processor.CamelLogProcessor.process(CamelLogProcessor.java:61) ~[camel-core-2.15.2.jar:2.15.2]
        at org.apache.camel.component.log.LogProducer.process(LogProducer.java:39) ~[camel-core-2.15.2.jar:2.15.2]
        at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:129) ~[camel-core-2.15.2.jar:2.15.2]
        at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:77) ~[camel-core-2.15.2.jar:2.15.2]
        at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:448) ~[camel-core-2.15.2.jar:2.15.2]
        at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191) ~[camel-core-2.15.2.jar:2.15.2]
        at org.apache.camel.processor.Pipeline.process(Pipeline.java:118) ~[camel-core-2.15.2.jar:2.15.2]
        at org.apache.camel.processor.Pipeline.process(Pipeline.java:80) ~[camel-core-2.15.2.jar:2.15.2]
        at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191) ~[camel-core-2.15.2.jar:2.15.2]
        at org.apache.camel.component.seda.SedaConsumer.sendToConsumers(SedaConsumer.java:291) [camel-core-2.15.2.jar:2.15.2]
        at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:200) [camel-core-2.15.2.jar:2.15.2]
        at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:147) [camel-core-2.15.2.jar:2.15.2]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_40]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_40]
        at java.lang.Thread.run(Thread.java:745) [na:1.8.0_40]


There is also another cause when it happens:


 org.eclipse.jetty.http.HttpFields -
java.util.ConcurrentModificationException: null
at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) ~[na:1.8.0_40]
at java.util.ArrayList$Itr.next(ArrayList.java:851) ~[na:1.8.0_40]
at org.eclipse.jetty.http.HttpFields.toString(HttpFields.java:585) ~[jetty-http-9.2.9.v20150224.jar:9.2.9.v20150224]
at java.util.Formatter$FormatSpecifier.printString(Formatter.java:2886) [na:1.8.0_40]
at java.util.Formatter$FormatSpecifier.print(Formatter.java:2763) [na:1.8.0_40]
at java.util.Formatter.format(Formatter.java:2520) [na:1.8.0_40]
at java.util.Formatter.format(Formatter.java:2455) [na:1.8.0_40]
at java.lang.String.format(String.java:2928) [na:1.8.0_40]
at org.eclipse.jetty.server.Response.toString(Response.java:1331) [jetty-server-9.2.9.v20150224.jar:9.2.9.v20150224]
at java.lang.String.valueOf(String.java:2982) [na:1.8.0_40]
at java.lang.StringBuilder.append(StringBuilder.java:131) [na:1.8.0_40]
at java.util.AbstractMap.toString(AbstractMap.java:536) [na:1.8.0_40]
at java.lang.String.valueOf(String.java:2982) [na:1.8.0_40]
at java.lang.StringBuilder.append(StringBuilder.java:131) [na:1.8.0_40]
at java.util.AbstractMap.toString(AbstractMap.java:536) [na:1.8.0_40]
at java.lang.String.valueOf(String.java:2982) [na:1.8.0_40]
at java.lang.StringBuilder.append(StringBuilder.java:131) [na:1.8.0_40]
at org.apache.camel.processor.DefaultExchangeFormatter.format(DefaultExchangeFormatter.java:99) [camel-core-2.15.2.jar:2.15.2]
at org.apache.camel.processor.CamelLogProcessor.process(CamelLogProcessor.java:66) [camel-core-2.15.2.jar:2.15.2]
at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:109) [camel-core-2.15.2.jar:2.15.2]
at org.apache.camel.processor.CamelLogProcessor.process(CamelLogProcessor.java:61) [camel-core-2.15.2.jar:2.15.2]
at org.apache.camel.component.log.LogProducer.process(LogProducer.java:39) [camel-core-2.15.2.jar:2.15.2]
at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:129) [camel-core-2.15.2.jar:2.15.2]
at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:77) [camel-core-2.15.2.jar:2.15.2]
at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:448) [camel-core-2.15.2.jar:2.15.2]
at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191) [camel-core-2.15.2.jar:2.15.2]
at org.apache.camel.processor.Pipeline.process(Pipeline.java:118) [camel-core-2.15.2.jar:2.15.2]
at org.apache.camel.processor.Pipeline.process(Pipeline.java:80) [camel-core-2.15.2.jar:2.15.2]
at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191) [camel-core-2.15.2.jar:2.15.2]
at org.apache.camel.component.seda.SedaConsumer.sendToConsumers(SedaConsumer.java:291) [camel-core-2.15.2.jar:2.15.2]
at org.apache.camel.component.seda.SedaConsumer.doRun(SedaConsumer.java:200) [camel-core-2.15.2.jar:2.15.2]
at org.apache.camel.component.seda.SedaConsumer.run(SedaConsumer.java:147) [camel-core-2.15.2.jar:2.15.2]
at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_40]
at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_40]
at java.lang.Thread.run(Thread.java:745) [na:1.8.0_40]

</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultExchange.java</file>
			<file type="M">org.apache.camel.impl.MessageSupport.java</file>
			<file type="M">org.apache.camel.Message.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8886</link>
		</links>
	</bug>
	<bug id="8810" opendate="2015-05-28 07:33:37" fixdate="2015-06-13 11:12:32" resolution="Fixed">
		<buginformation>
			<summary>Camel CXF may propagate wrong Content-Length headers</summary>
			<description>In some rare cases camel-cxf may propagate wrong Content-Length HTTP headers in routing scenarios.
The scenario in question is a simple camel-cxf to camel-cxf scenario with a request-reply pattern. If the called server does respond with a Content-Length (not chunked) and the server does not send any HTTP protocol header that is not filtered (like Content-Length or Content-Type) the headers from the original server response are forwarded.
If the payload returned by Camel is longer than the payload returned by the called server (which provided the Content-Length) e.g. because the proxy is working in PAYLOAD mode and the server uses shorter namespace prefixes for the SOAP envelope, the Content-Length will be too short and the calling client may cut off the message.
See the attached unit test for details.
The reason for that is that the original headers get set when copying the invocation context from the camel exchange. Normally the protocol header map will be overwritten with the map of filtered headers, so this is not an issue, however of the map of filtered headers is completely empty this will not happen. The fix is to remove the copied protocol headers in that case.
The situation will rarely occur in real life because the Server header is there most of the time, so the list of filtered protocol headers is not empty. </description>
			<version>2.14.2</version>
			<fixedVersion>2.15.3, 2.16.0, 2.14.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="8871" opendate="2015-06-15 08:19:29" fixdate="2015-06-15 09:31:41" resolution="Fixed">
		<buginformation>
			<summary>null body after exception from transform method</summary>
			<description>When an exception is thrown from a transform method I lose the content of the message body. This behaviour is unexpected because it does not happen when an exception is thrown from a bean call.
.bean(ErrorBean.class, ErrorBean.METHOD)
Vs.
.transform().method(ErrorBean.class, ErrorBean.METHOD)
I have a testcase that I will try to get attached but here are the routes:


if ("testTransformExceptionToErrorRoute".equals(getTestMethodName())) {
                    from(START)
                    .routeId("exception.test.transform")
                    .transform().method(ErrorBean.class, ErrorBean.METHOD)
                    .to(END);
                } else {
                    from(START)
                    .routeId("exception.test.bean")
                    .bean(ErrorBean.class, ErrorBean.METHOD)
                    .to(END);
                }

    public static class ErrorBean {
        private static final String METHOD = "throwException";
        public static void throwException(Exchange exchange) {
            String body = exchange.getIn().getBody(String.class);
            Assertions.assertThat(body).isEqualTo(BODY);
            throw new NullPointerException();
        }
    }

</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.ConvertBodyProcessor.java</file>
			<file type="M">org.apache.camel.processor.SetHeaderProcessor.java</file>
			<file type="M">org.apache.camel.processor.SetPropertyProcessor.java</file>
			<file type="M">org.apache.camel.processor.TransformProcessor.java</file>
			<file type="M">org.apache.camel.processor.SetBodyProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="8841" opendate="2015-06-08 07:19:25" fixdate="2015-06-15 11:12:29" resolution="Fixed">
		<buginformation>
			<summary>camel:context-inflight returns &amp;apos;Object name cannot be null&amp;apos;</summary>
			<description>
karaf&amp;gt; camel:context-inflight myCamelContext
Error executing command: Object name cannot be null 

karaf&amp;gt; log:exception-display
javax.management.RuntimeOperationsException: Object name cannot be null
        at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.isRegistered(DefaultMBeanServerInterceptor.java:569)[:1.8.0_45]
        at com.sun.jmx.mbeanserver.JmxMBeanServer.isRegistered(JmxMBeanServer.java:638)[:1.8.0_45]
        at sun.reflect.GeneratedMethodAccessor1.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)[:1.8.0_45]
        at java.lang.reflect.Method.invoke(Method.java:497)[:1.8.0_45]
        at org.apache.karaf.management.boot.KarafMBeanServerBuilder$MBeanInvocationHandler.invoke(KarafMBeanServerBuilder.java:80)[karaf-jmx-boot.jar:]
        at com.sun.proxy.$Proxy0.isRegistered(Unknown Source)[:]
        at org.apache.camel.commands.AbstractLocalCamelController.browseInflightExchanges(AbstractLocalCamelController.java:186)
        at org.apache.camel.commands.ContextInflightCommand.performContextCommand(ContextInflightCommand.java:56)
        at org.apache.camel.commands.AbstractContextCommand.executeLocal(AbstractContextCommand.java:74)
        at org.apache.camel.commands.AbstractContextCommand.execute(AbstractContextCommand.java:42)
        at org.apache.camel.karaf.commands.ContextInflight.doExecute(ContextInflight.java:40)
        at org.apache.karaf.shell.console.AbstractAction.execute(AbstractAction.java:33)[25:org.apache.karaf.shell.console:3.0.3]
        at org.apache.karaf.shell.console.OsgiCommandSupport.execute(OsgiCommandSupport.java:39)[25:org.apache.karaf.shell.console:3.0.3]
        at org.apache.karaf.shell.commands.basic.AbstractCommand.execute(AbstractCommand.java:33)[25:org.apache.karaf.shell.console:3.0.3]
        at Proxy199cb572_c6d4_4d06_851e_3f55b795651b.execute(Unknown Source)[:]
        at Proxy199cb572_c6d4_4d06_851e_3f55b795651b.execute(Unknown Source)[:]
        at org.apache.felix.gogo.runtime.CommandProxy.execute(CommandProxy.java:78)[25:org.apache.karaf.shell.console:3.0.3]
        at org.apache.felix.gogo.runtime.Closure.executeCmd(Closure.java:477)[25:org.apache.karaf.shell.console:3.0.3]
        at org.apache.felix.gogo.runtime.Closure.executeStatement(Closure.java:403)[25:org.apache.karaf.shell.console:3.0.3]
        at org.apache.felix.gogo.runtime.Pipe.run(Pipe.java:108)[25:org.apache.karaf.shell.console:3.0.3]
        at org.apache.felix.gogo.runtime.Closure.execute(Closure.java:183)[25:org.apache.karaf.shell.console:3.0.3]
        at org.apache.felix.gogo.runtime.Closure.execute(Closure.java:120)[25:org.apache.karaf.shell.console:3.0.3]
        at org.apache.felix.gogo.runtime.CommandSessionImpl.execute(CommandSessionImpl.java:92)
        at org.apache.karaf.shell.console.impl.jline.ConsoleImpl.run(ConsoleImpl.java:208)
        at org.apache.karaf.shell.ssh.ShellFactoryImpl$ShellImpl$1.runConsole(ShellFactoryImpl.java:158)[52:org.apache.karaf.shell.ssh:3.0.3]
        at org.apache.karaf.shell.ssh.ShellFactoryImpl$ShellImpl$1$1.run(ShellFactoryImpl.java:133)
        at java.security.AccessController.doPrivileged(Native Method)[:1.8.0_45]
        at org.apache.karaf.jaas.modules.JaasHelper.doAs(JaasHelper.java:57)[26:org.apache.karaf.jaas.modules:3.0.3]
        at org.apache.karaf.shell.ssh.ShellFactoryImpl$ShellImpl$1.run(ShellFactoryImpl.java:129)[52:org.apache.karaf.shell.ssh:3.0.3]
Caused by: java.lang.IllegalArgumentException: Object name cannot be null
        ... 30 more


I think when combining the object name
            Set&amp;lt;ObjectName&amp;gt; set = mBeanServer.queryNames(new ObjectName(agent.getMBeanObjectDomainName() + ":type=services,name=DefaultInflightRepository,*"), null);
The ":context=context-name" part seems missing.
The query should be something like
org.apache.camel:context=&amp;lt;context-name&amp;gt;,type=services,name=DefaultInflightRepository </description>
			<version>2.15.1</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.commands.AbstractLocalCamelController.java</file>
		</fixedFiles>
	</bug>
	<bug id="8864" opendate="2015-06-13 12:52:52" fixdate="2015-06-23 17:49:37" resolution="Fixed">
		<buginformation>
			<summary>Camel-Aggregator JDBC repository always overwrites old exchange</summary>
			<description>I&amp;amp;apos;m using FlexibleAggregationStrategy to aggregate objects into collection. I found following issue where Aggregator ends up overwriting old collection with the new one.
JdbcCamelCodec is not marshaling all of the exchange properties. 
E.g. it does not marshal exchange&amp;amp;apos;s &amp;amp;apos;CamelFlexAggrStrCollectionGuard&amp;amp;apos; property.
So next time Aggregator tries to fetch BLOB from database, oldExchange does not have above property.
So following code creates new collection for each new object, and hence overwrites the old collection.
private Collection&amp;lt;E&amp;gt; FlexibleAggregationStrategy::safeInsertIntoCollection(Exchange oldExchange, Collection&amp;lt;E&amp;gt; oldValue, E toInsert) {
        Collection&amp;lt;E&amp;gt; collection = null;
        try {
            if (oldValue == null || oldExchange.getProperty(COLLECTION_AGGR_GUARD_PROPERTY, Boolean.class) == null) {
                try {
                     collection = collectionType.newInstance();    //**EVERYTIME NEW COLLECTION as previous aggregation did not serialize COLLECTION_AGGR_GUARD_PROPERTY to database.
</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.toolbox.FlexibleAggregationStrategy.java</file>
			<file type="M">org.apache.camel.component.leveldb.LevelDBCamelCodec.java</file>
			<file type="M">org.apache.camel.processor.aggregate.cassandra.CassandraCamelCodec.java</file>
			<file type="M">org.apache.camel.Exchange.java</file>
			<file type="M">org.apache.camel.component.hawtdb.HawtDBCamelCodec.java</file>
			<file type="M">org.apache.camel.processor.aggregate.jdbc.JdbcCamelCodec.java</file>
		</fixedFiles>
	</bug>
	<bug id="8900" opendate="2015-06-24 23:15:01" fixdate="2015-06-25 03:48:21" resolution="Fixed">
		<buginformation>
			<summary>Javadoc parser in API Component Framework misses first method with void return type in JDK7</summary>
			<description>When using JDK 7 to generate Javadoc, the Javadoc parser based on javax.swing.text.html.parser.Parser fails to extract the first method if it has a void return type. For some reason the combination of the Javadoc generated by JDK7 and its Parser class gets the elements in the wrong order, causing the parser to go into the wrong state missing the first method. The next method element puts the parser back in the right state. 
The fix is to not let the parser come out of the METHOD_SUMMARY if it has not seen any methods at that point. </description>
			<version>2.14.3</version>
			<fixedVersion>2.15.3, 2.14.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.maven.JavadocParserTest.java</file>
			<file type="M">org.apache.camel.maven.JavadocParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="8901" opendate="2015-06-24 23:34:39" fixdate="2015-06-25 06:32:08" resolution="Fixed">
		<buginformation>
			<summary>NBSP characters in camel-kafka:KafkaConfiguration parameter</summary>
			<description>There are some rogue NBSP characters that prevent the kafka zookeeper.session.timeout.ms and zookeeper.sync.time.ms from being set.</description>
			<version>2.14.2</version>
			<fixedVersion>2.15.3, 2.16.0, 2.14.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.kafka.KafkaConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="8902" opendate="2015-06-25 04:01:29" fixdate="2015-06-25 06:56:18" resolution="Fixed">
		<buginformation>
			<summary>Camel Facebook - Endpoint URI must contain a parameter</summary>
			<description>Endpoint URI must contain a parametr otherwise method FacebookEndpoint#initState will not be called. This results in the following exception:


Caused by: java.lang.NullPointerException
	at java.util.Collections$UnmodifiableCollection.&amp;lt;init&amp;gt;(Collections.java:1026)[:1.8.0_45]
	at java.util.Collections$UnmodifiableList.&amp;lt;init&amp;gt;(Collections.java:1302)[:1.8.0_45]
	at java.util.Collections.unmodifiableList(Collections.java:1287)[:1.8.0_45]
	at org.apache.camel.component.facebook.FacebookEndpoint.getCandidates(FacebookEndpoint.java:186)



This behaviour is not correct because it is not possible easily change endpoint parameter values.
We should support the following usecase:
header: CamelFacebook.userId = xxxxx 


&amp;lt;to uri="facebook://user"/&amp;gt;


and not only:


&amp;lt;to uri="facebook://user?userId=xxxxx"/&amp;gt;

</description>
			<version>2.14.3</version>
			<fixedVersion>2.15.3, 2.16.0, 2.14.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.facebook.FacebookComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="8909" opendate="2015-06-27 17:39:15" fixdate="2015-06-27 17:41:58" resolution="Fixed">
		<buginformation>
			<summary>Jasypt CLI outputs help twice</summary>
			<description>Using -help results in the following output:
[janstey@bender apache-camel-2.15.2]$ java -jar lib/camel-jasypt-2.15.2.jar -help
Apache Camel Jasypt takes the following options
  -h or -help = Displays the help screen
  -c or -command &amp;lt;command&amp;gt; = Command either encrypt or decrypt
  -p or -password &amp;lt;password&amp;gt; = Password to use
  -i or -input &amp;lt;input&amp;gt; = Text to encrypt or decrypt
  -a or -algorithm &amp;lt;algorithm&amp;gt; = Optional algorithm to use
Error: Command is empty
Apache Camel Jasypt takes the following options
  -h or -help = Displays the help screen
  -c or -command &amp;lt;command&amp;gt; = Command either encrypt or decrypt
  -p or -password &amp;lt;password&amp;gt; = Password to use
  -i or -input &amp;lt;input&amp;gt; = Text to encrypt or decrypt
  -a or -algorithm &amp;lt;algorithm&amp;gt; = Optional algorithm to use</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jasypt.Main.java</file>
		</fixedFiles>
	</bug>
	<bug id="8916" opendate="2015-06-29 09:17:46" fixdate="2015-06-29 10:20:32" resolution="Fixed">
		<buginformation>
			<summary>Support autoCreate=true in ftp/ftps/sftp consumers</summary>
			<description>GenericFileEndpoint supports autoCreate option. It may be used to create necessary path for fileconsumer and producers for file/ftp/ftps/sftp endpoints.
This flag however isn&amp;amp;apos;t used for ftp/ftps/sftp consumers.</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumerThrowExceptionOnLoginFailedTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8914" opendate="2015-06-29 07:49:32" fixdate="2015-07-01 09:17:17" resolution="Fixed">
		<buginformation>
			<summary>Unable to shutdown endpoint when intercepted with interceptSendToEndpoint</summary>
			<description>I&amp;amp;apos;m facing an issue with the version of camel 2.15.2 
I have a component that create an endpoint. 
This endpoint override the shutdown and doShutdown method so we can log values at shutdown time. 
But when this endpoint is intercept with the interceptSendToEnpoint method the shutdown is not called. 
Here is an example of code to reproduce: 
the Component: 
public class CustomComponent extends DefaultComponent {
        @Override
        protected Endpoint createEndpoint(String uri, String remaining, Map&amp;lt;String, Object&amp;gt; parameters) throws Exception 
{
            return new CustomEndpoint();
        }
    }
the Endpoint: 
    public class CustomEndpoint extends DefaultEndpoint {
        @Override
        public Producer createProducer() throws Exception {
            return new DefaultProducer(this) {
                @Override
                public void process(Exchange exchange) throws Exception 
{
                    log.info(exchange.getExchangeId());
                }
            };
        }
        @Override
        public Consumer createConsumer(Processor processor) throws Exception 
{
            return null;
        }

        @Override
        public boolean isSingleton() 
{
            return false;
        }

        @Override
        public void shutdown() throws Exception 
{
            super.shutdown();
            System.out.println("SHUTDOWN");
        }

        @Override
        protected void doShutdown() throws Exception 
{
            super.doShutdown();
            System.out.println("do SHUTDOWN");
        }

        @Override
        protected String createEndpointUri() 
{
            return "myEndpoint";
        }
    }
the route: 
public class MyRoute extends RouteBuilder {
        @Override
        public void configure() {
            try 
{
                getContext().addComponent("myEndpoint", new CustomComponent());
            }
 catch (Exception e) 
{
                e.printStackTrace();
            }
            interceptSendToEndpoint("myEndpoint:producer")
                    .log("INTERCEPTED");
            from("direct:murex").routeId("Trade Repository Route")
                 .to("myEndpoint:producer");
        }
    }
When there is an interceptor the shutdown on the endpoint is not called, when there is no interceptor the shutdown is called. 
After some debugging I noticed that in the DefaultCamelContext at the shutdown time the shutdown is called on the list of endpoints, when there is an interceptor the list do not contain the CustomEnpoint but only the Interceptor, and because the interceptor does not implement ShutdownableAware the shutdown is not propagate to the underlying endpoint (here the CustomEndpoint) 
Without the interceptor the CustomEndpoint appears in the list and the shutdown method is called. </description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.InterceptSendToEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="8923" opendate="2015-07-01 08:21:52" fixdate="2015-07-01 15:20:37" resolution="Fixed">
		<buginformation>
			<summary>Kafka: Topic name lookup from message headers in the producer causes infinite loop</summary>
			<description>Refer changes done for CAMEL-7331
The change causes a critical bug.
For a camel route as follows:


from("kafka://&amp;lt;broker&amp;gt;?topic=T1")
.process(myProcessor)
.to("kafka://&amp;lt;broker&amp;gt;?topic=T2")


KafkaExchange will be created by KafkaConsumer and the topic will be set to "T1" in the header.
For the &amp;amp;apos;to&amp;amp;apos; endpoint, KafkaProducer will try to read the topic from the exchange header which is still "T1" instead of "T2" thereby causing an infinite loop.
As discussed in user-group, a different header should be used to read the topic name from message. </description>
			<version>2.15.1</version>
			<fixedVersion>2.16.0, 2.15.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.kafka.KafkaProducer.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaEndpoint.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaConfiguration.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaProducerTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">9108</link>
		</links>
	</bug>
	<bug id="8927" opendate="2015-07-02 09:42:32" fixdate="2015-07-02 09:44:55" resolution="Fixed">
		<buginformation>
			<summary>camel-ahc-ws - Do not swallow exception when connecting</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Camel-Websocket-Connection-key-not-set-tp5766728p5766730.html</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.ahc.ws.WsProducer.java</file>
			<file type="M">org.apache.camel.component.ahc.ws.WsEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="8933" opendate="2015-07-06 00:05:22" fixdate="2015-07-06 09:18:24" resolution="Fixed">
		<buginformation>
			<summary>mail consumer (imap) polls continuously (not using the default polling interval)</summary>
			<description>The mail consumer (at least IMAP) would poll email continuously unless the consumer.delay is explicitly set.  Below is the IMAP debug log.  It should stop at A6 instead of continuing indefinitely.   This does not happen with 2.14.x.
2015-07-05 20:04:02,534 [0 - imaps://imap.gmail.com:993] DEBUG MailConsumer                   - Connecting to MailStore: imaps://imap.gmail.com:993 (SSL enabled), folder=INBOX
DEBUG: getProvider() returning javax.mail.Provider[STORE,imaps,com.sun.mail.imap.IMAPSSLStore,Oracle]
DEBUG IMAPS: mail.imap.fetchsize: 16384
DEBUG IMAPS: mail.imap.ignorebodystructuresize: false
DEBUG IMAPS: mail.imap.statuscachetimeout: 1000
DEBUG IMAPS: mail.imap.appendbuffersize: -1
DEBUG IMAPS: mail.imap.minidletime: 10
DEBUG IMAPS: trying to connect to host "imap.gmail.com", port 993, isSSL true

OK Gimap ready for requests from 76.108.169.41 k7mb499616512ywc
A0 CAPABILITY
CAPABILITY IMAP4rev1 UNSELECT IDLE NAMESPACE QUOTA ID XLIST CHILDREN X-GM-EXT-1 XYZZY SASL-IR AUTH=XOAUTH2 AUTH=PLAIN AUTH=PLAIN-CLIENTTOKEN AUTH=XOAUTH
A0 OK Thats all she wrote! k7mb499616512ywc
DEBUG IMAPS: AUTH: XOAUTH2
DEBUG IMAPS: AUTH: PLAIN
DEBUG IMAPS: AUTH: PLAIN-CLIENTTOKEN
DEBUG IMAPS: AUTH: XOAUTH
DEBUG IMAPS: protocolConnect login, host=imap.gmail.com, user=test@e-bonding.com, password=&amp;lt;non-null&amp;gt;
DEBUG IMAPS: AUTHENTICATE PLAIN command trace suppressed
DEBUG IMAPS: AUTHENTICATE PLAIN command result: A1 OK test@e-bonding.com authenticated (Success)
A2 CAPABILITY
CAPABILITY IMAP4rev1 UNSELECT IDLE NAMESPACE QUOTA ID XLIST CHILDREN X-GM-EXT-1 UIDPLUS COMPRESS=DEFLATE ENABLE MOVE CONDSTORE ESEARCH UTF8=ACCEPT
A2 OK Success
2015-07-05 20:04:03,120 [0 - imaps://imap.gmail.com:993] DEBUG MailConsumer                   - Getting folder INBOX
A3 LIST "" INBOX
LIST (\HasNoChildren) "/" "INBOX"
A3 OK Success
2015-07-05 20:04:03,162 [0 - imaps://imap.gmail.com:993] DEBUG MailConsumer                   - Polling mailbox folder: imaps://imap.gmail.com:993 (SSL enabled), folder=INBOX
DEBUG IMAPS: connection available  size: 1
A4 SELECT INBOX
FLAGS (\Answered \Flagged \Draft \Deleted \Seen $NotPhishing $Phishing)
OK [PERMANENTFLAGS (\Answered \Flagged \Draft \Deleted \Seen $NotPhishing $Phishing \*)] Flags permitted.
OK [UIDVALIDITY 1] UIDs valid.
53 EXISTS
0 RECENT
OK [UIDNEXT 294] Predicted next UID.
OK [HIGHESTMODSEQ 85418]
A4 OK [READ-WRITE] INBOX selected. (Success)
A5 SEARCH UNSEEN ALL
SEARCH
A5 OK SEARCH completed (Success)
2015-07-05 20:04:03,272 [0 - imaps://imap.gmail.com:993] DEBUG MailConsumer                   - Fetching 0 messages. Total 0 messages.
2015-07-05 20:04:03,272 [0 - imaps://imap.gmail.com:993] DEBUG MailConsumer                   - Close mailbox folder INBOX from imaps://imap.gmail.com:993 (SSL enabled), folder=INBOX
A6 CLOSE
A6 OK Returned to authenticated state. (Success)
DEBUG IMAPS: added an Authenticated connection  size: 1
DEBUG IMAPS: IMAPProtocol noop
A7 NOOP
A7 OK Success
2015-07-05 20:04:03,880 [0 - imaps://imap.gmail.com:993] DEBUG MailConsumer                   - Polling mailbox folder: imaps://imap.gmail.com:993 (SSL enabled), folder=INBOX
DEBUG IMAPS: connection available  size: 1
A8 SELECT INBOX
FLAGS (\Answered \Flagged \Draft \Deleted \Seen $NotPhishing $Phishing)
OK [PERMANENTFLAGS (\Answered \Flagged \Draft \Deleted \Seen $NotPhishing $Phishing \*)] Flags permitted.
OK [UIDVALIDITY 1] UIDs valid.
53 EXISTS
0 RECENT
OK [UIDNEXT 294] Predicted next UID.
OK [HIGHESTMODSEQ 85418]
A8 OK [READ-WRITE] INBOX selected. (Success)
A9 SEARCH UNSEEN ALL
SEARCH
A9 OK SEARCH completed (Success)
2015-07-05 20:04:04,003 [0 - imaps://imap.gmail.com:993] DEBUG MailConsumer                   - Fetching 0 messages. Total 0 messages.
2015-07-05 20:04:04,004 [0 - imaps://imap.gmail.com:993] DEBUG MailConsumer                   - Close mailbox folder INBOX from imaps://imap.gmail.com:993 (SSL enabled), folder=INBOX
A10 CLOSE
A10 OK Returned to authenticated state. (Success)
DEBUG IMAPS: added an Authenticated connection  size: 1
DEBUG IMAPS: IMAPProtocol noop
A11 NOOP
A11 OK Success
2015-07-05 20:04:04,572 [0 - imaps://imap.gmail.com:993] DEBUG MailConsumer                   - Polling mailbox folder: imaps://imap.gmail.com:993 (SSL enabled), folder=INBOX
DEBUG IMAPS: connection available  size: 1
A12 SELECT INBOX
FLAGS (\Answered \Flagged \Draft \Deleted \Seen $NotPhishing $Phishing)
OK [PERMANENTFLAGS (\Answered \Flagged \Draft \Deleted \Seen $NotPhishing $Phishing \*)] Flags permitted.
OK [UIDVALIDITY 1] UIDs valid.
53 EXISTS
0 RECENT
OK [UIDNEXT 294] Predicted next UID.
OK [HIGHESTMODSEQ 85418]
A12 OK [READ-WRITE] INBOX selected. (Success)
A13 SEARCH UNSEEN ALL
SEARCH
A13 OK SEARCH completed (Success)
2015-07-05 20:04:04,665 [0 - imaps://imap.gmail.com:993] DEBUG MailConsumer                   - Fetching 0 messages. Total 0 messages.
2015-07-05 20:04:04,665 [0 - imaps://imap.gmail.com:993] DEBUG MailConsumer                   - Close mailbox folder INBOX from imaps://imap.gmail.com:993 (SSL enabled), folder=INBOX
A14 CLOSE
A14 OK Returned to authenticated state. (Success)
DEBUG IMAPS: added an Authenticated connection  size: 1
DEBUG IMAPS: IMAPProtocol noop
A15 NOOP
A15 OK Success
2015-07-05 20:04:05,232 [0 - imaps://imap.gmail.com:993] DEBUG MailConsumer                   - Polling mailbox folder: imaps://imap.gmail.com:993 (SSL enabled), folder=INBOX
DEBUG IMAPS: connection available  size: 1
A16 SELECT INBOX
FLAGS (\Answered \Flagged \Draft \Deleted \Seen $NotPhishing $Phishing)
OK [PERMANENTFLAGS (\Answered \Flagged \Draft \Deleted \Seen $NotPhishing $Phishing \*)] Flags permitted.
OK [UIDVALIDITY 1] UIDs valid.
53 EXISTS
0 RECENT
OK [UIDNEXT 294] Predicted next UID.
OK [HIGHESTMODSEQ 85418]
A16 OK [READ-WRITE] INBOX selected. (Success)
A17 SEARCH UNSEEN ALL
SEARCH
A17 OK SEARCH completed (Success)
2015-07-05 20:04:05,357 [0 - imaps://imap.gmail.com:993] DEBUG MailConsumer                   - Fetching 0 messages. Total 0 messages.
2015-07-05 20:04:05,358 [0 - imaps://imap.gmail.com:993] DEBUG MailConsumer                   - Close mailbox folder INBOX from imaps://imap.gmail.com:993 (SSL enabled), folder=INBOX
A18 CLOSE
A18 OK Returned to authenticated state. (Success)
DEBUG IMAPS: added an Authenticated connection  size: 1

</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="8885" opendate="2015-06-18 08:27:17" fixdate="2015-07-09 06:25:21" resolution="Fixed">
		<buginformation>
			<summary>ConsumeLockEntity without ConsumeDelete</summary>
			<description>I think that condition at the beginning of the lock function is wrong:


protected boolean lockEntity(Object entity, EntityManager entityManager) {
        if (!getEndpoint().isConsumeDelete() || !getEndpoint().isConsumeLockEntity()) {
            return true;
        }
...


If I wanna just select and then update entity I should set consumeDelete=false, but If so entity will  newer be locked...</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jpa.JpaConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="8768" opendate="2015-05-12 14:45:03" fixdate="2015-07-09 10:08:16" resolution="Fixed">
		<buginformation>
			<summary>hdfs2 component overwrite option is also being applied to directory filesystem path</summary>
			<description>If you need to produce files into an existing HDFS2 path, the default behavoir is overwrite the path, which will delete all existing files on HDFS.  If overwrite option is disabled, then the component will complain that the existing HDFS directory exists and will not work.  
The propose solution is to add the following if statement to ignore check if the HDFS directory exists. The overwrite option should only be used for files not directories.
code snippet in HdfsOutputStream.java and patch is attached
 if (ret.info.getFileSystem().exists(new Path(ret.actualPath))) {
                //only check of not directory
                if (!ret.info.getFileSystem().isDirectory(new Path(ret.actualPath))) {
                    if (configuration.isOverwrite()) 
{
                        ret.info.getFileSystem().delete(new Path(ret.actualPath), true);
                    }
 else 
{
                        throw new RuntimeCamelException("The file already exists");
                    }
                }
            }</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.hdfs.HdfsOutputStream.java</file>
			<file type="M">org.apache.camel.component.hdfs2.HdfsOutputStream.java</file>
		</fixedFiles>
	</bug>
	<bug id="8945" opendate="2015-07-09 11:38:32" fixdate="2015-07-09 11:46:17" resolution="Fixed">
		<buginformation>
			<summary>Loop - Should break out looping if exception happened during routing</summary>
			<description>See SO
http://stackoverflow.com/questions/31312281/apache-camel-loop-does-not-stop-on-exception
</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0, 2.14.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.LoopProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="7500" opendate="2014-06-11 17:03:58" fixdate="2015-07-10 08:48:49" resolution="Fixed">
		<buginformation>
			<summary>Concurrent modification of exchange during retry after netty TCP failure leads to futher processing of failed messages</summary>
			<description>When a exception occurs on a netty TCP channel such as ChanelClosedException then there are two invocations of the producer callback. 
If there is a redelivery handler configured this causes either two threads to be added to the scheduled thread-pool which then compete or in the more common case the first invocation adds the redelivery thread but in doing so clears the exception from the exchange such that when the subsequent callback invocation occurs it see&amp;amp;apos;s the event as a success and continues routing of the exchange.
Note this also seems to be a cause of negative inflight messages on the route.
The first callback invocation occurs in the ChannelFutureListener which is the usual case.
The second callback invocation which comes from the ClientChannelHandler registered in the DefaultClientPipelineFactory used by the NettyProducer.</description>
			<version>2.13.1</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.NettyProducer.java</file>
			<file type="M">org.apache.camel.component.netty.NettyUdpConnectedSendTest.java</file>
			<file type="M">org.apache.camel.component.netty4.handlers.ClientChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty4.NettyProducer.java</file>
			<file type="M">org.apache.camel.component.netty.handlers.ClientChannelHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="8949" opendate="2015-07-10 13:42:02" fixdate="2015-07-10 13:55:44" resolution="Fixed">
		<buginformation>
			<summary>Netty 3 component spins on receiving TCP RST</summary>
			<description>When receiving a TCP RST, Netty 3 goes into a deep recursion identified by a stack something like:


[Camel Thread #1 - NettyServerTCPWorker] WARN  org.apache.camel.component.netty.http.NettyHttpConsumer  - HttpServerChannelHandler is not found as attachment to handle exception, send 404 back to the client.
java.io.IOException: Broken pipe
	at sun.nio.ch.FileDispatcherImpl.write0(Native Method)
	at sun.nio.ch.SocketDispatcher.write(SocketDispatcher.java:47)
	at sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:93)
	at sun.nio.ch.IOUtil.write(IOUtil.java:51)
	at sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:487)
	at org.jboss.netty.channel.socket.nio.SocketSendBufferPool$UnpooledSendBuffer.transferTo(SocketSendBufferPool.java:203)
	at org.jboss.netty.channel.socket.nio.AbstractNioWorker.write0(AbstractNioWorker.java:201)
	at org.jboss.netty.channel.socket.nio.AbstractNioWorker.writeFromUserCode(AbstractNioWorker.java:146)
	at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.handleAcceptedSocket(NioServerSocketPipelineSink.java:99)
	at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.eventSunk(NioServerSocketPipelineSink.java:36)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:779)
	at org.jboss.netty.channel.Channels.write(Channels.java:725)
	at org.jboss.netty.handler.codec.oneone.OneToOneEncoder.doEncode(OneToOneEncoder.java:71)
	at org.jboss.netty.handler.codec.oneone.OneToOneEncoder.handleDownstream(OneToOneEncoder.java:59)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:591)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:582)
	at org.jboss.netty.channel.Channels.write(Channels.java:704)
	at org.jboss.netty.channel.Channels.write(Channels.java:671)
	at org.jboss.netty.channel.AbstractChannel.write(AbstractChannel.java:248)
	at org.apache.camel.component.netty.http.handlers.HttpServerMultiplexChannelHandler.exceptionCaught(HttpServerMultiplexChannelHandler.java:142)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:112)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.exceptionCaught(SimpleChannelUpstreamHandler.java:153)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:112)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
	at org.jboss.netty.handler.codec.frame.FrameDecoder.exceptionCaught(FrameDecoder.java:377)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:112)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:559)
	at org.jboss.netty.channel.Channels.fireExceptionCaught(Channels.java:525)
	at org.jboss.netty.channel.socket.nio.AbstractNioWorker.write0(AbstractNioWorker.java:291)
	at org.jboss.netty.channel.socket.nio.AbstractNioWorker.writeFromUserCode(AbstractNioWorker.java:146)
	at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.handleAcceptedSocket(NioServerSocketPipelineSink.java:99)
	at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.eventSunk(NioServerSocketPipelineSink.java:36)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:779)
	at org.jboss.netty.channel.Channels.write(Channels.java:725)
	at org.jboss.netty.handler.codec.oneone.OneToOneEncoder.doEncode(OneToOneEncoder.java:71)
	at org.jboss.netty.handler.codec.oneone.OneToOneEncoder.handleDownstream(OneToOneEncoder.java:59)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:591)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:582)
	at org.jboss.netty.channel.Channels.write(Channels.java:704)
	at org.jboss.netty.channel.Channels.write(Channels.java:671)
	at org.jboss.netty.channel.AbstractChannel.write(AbstractChannel.java:248)
	at org.apache.camel.component.netty.http.handlers.HttpServerMultiplexChannelHandler.exceptionCaught(HttpServerMultiplexChannelHandler.java:142)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:112)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.exceptionCaught(SimpleChannelUpstreamHandler.java:153)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:112)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
	at org.jboss.netty.handler.codec.frame.FrameDecoder.exceptionCaught(FrameDecoder.java:377)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:112)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:559)
	at org.jboss.netty.channel.Channels.fireExceptionCaught(Channels.java:525)
	at org.jboss.netty.channel.socket.nio.AbstractNioWorker.write0(AbstractNioWorker.java:291)
	at org.jboss.netty.channel.socket.nio.AbstractNioWorker.writeFromUserCode(AbstractNioWorker.java:146)
	at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.handleAcceptedSocket(NioServerSocketPipelineSink.java:99)
	at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.eventSunk(NioServerSocketPipelineSink.java:36)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:779)
	at org.jboss.netty.channel.Channels.write(Channels.java:725)
	at org.jboss.netty.handler.codec.oneone.OneToOneEncoder.doEncode(OneToOneEncoder.java:71)
	at org.jboss.netty.handler.codec.oneone.OneToOneEncoder.handleDownstream(OneToOneEncoder.java:59)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:591)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:582)
	at org.jboss.netty.channel.Channels.write(Channels.java:704)
	at org.jboss.netty.channel.Channels.write(Channels.java:671)
	at org.jboss.netty.channel.AbstractChannel.write(AbstractChannel.java:248)
	at org.apache.camel.component.netty.http.handlers.HttpServerMultiplexChannelHandler.exceptionCaught(HttpServerMultiplexChannelHandler.java:142)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:112)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.exceptionCaught(SimpleChannelUpstreamHandler.java:153)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:112)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
	at org.jboss.netty.handler.codec.frame.FrameDecoder.exceptionCaught(FrameDecoder.java:377)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:112)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:559)
	at org.jboss.netty.channel.Channels.fireExceptionCaught(Channels.java:525)
	at org.jboss.netty.channel.socket.nio.AbstractNioWorker.write0(AbstractNioWorker.java:291)
	at org.jboss.netty.channel.socket.nio.AbstractNioWorker.writeFromUserCode(AbstractNioWorker.java:146)
	at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.handleAcceptedSocket(NioServerSocketPipelineSink.java:99)
	at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.eventSunk(NioServerSocketPipelineSink.java:36)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:779)
	at org.jboss.netty.channel.Channels.write(Channels.java:725)
	at org.jboss.netty.handler.codec.oneone.OneToOneEncoder.doEncode(OneToOneEncoder.java:71)
	at org.jboss.netty.handler.codec.oneone.OneToOneEncoder.handleDownstream(OneToOneEncoder.java:59)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:591)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:582)
	at org.jboss.netty.channel.Channels.write(Channels.java:704)
	at org.jboss.netty.channel.Channels.write(Channels.java:671)
	at org.jboss.netty.channel.AbstractChannel.write(AbstractChannel.java:248)
	at org.apache.camel.component.netty.http.handlers.HttpServerMultiplexChannelHandler.exceptionCaught(HttpServerMultiplexChannelHandler.java:142)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:112)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.exceptionCaught(SimpleChannelUpstreamHandler.java:153)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:112)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
	at org.jboss.netty.handler.codec.frame.FrameDecoder.exceptionCaught(FrameDecoder.java:377)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:112)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:559)
	at org.jboss.netty.channel.Channels.fireExceptionCaught(Channels.java:525)
	at org.jboss.netty.channel.socket.nio.AbstractNioWorker.write0(AbstractNioWorker.java:291)
	at org.jboss.netty.channel.socket.nio.AbstractNioWorker.writeFromUserCode(AbstractNioWorker.java:146)
	at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.handleAcceptedSocket(NioServerSocketPipelineSink.java:99)
	at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.eventSunk(NioServerSocketPipelineSink.java:36)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:779)
	at org.jboss.netty.channel.Channels.write(Channels.java:725)
	at org.jboss.netty.handler.codec.oneone.OneToOneEncoder.doEncode(OneToOneEncoder.java:71)
	at org.jboss.netty.handler.codec.oneone.OneToOneEncoder.handleDownstream(OneToOneEncoder.java:59)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:591)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:582)
	at org.jboss.netty.channel.Channels.write(Channels.java:704)
	at org.jboss.netty.channel.Channels.write(Channels.java:671)
	at org.jboss.netty.channel.AbstractChannel.write(AbstractChannel.java:248)
	at org.apache.camel.component.netty.http.handlers.HttpServerMultiplexChannelHandler.exceptionCaught(HttpServerMultiplexChannelHandler.java:142)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:112)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.exceptionCaught(SimpleChannelUpstreamHandler.java:153)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:112)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)
	at org.jboss.netty.handler.codec.frame.FrameDecoder.exceptionCaught(FrameDecoder.java:377)
	at org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:112)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:559)
	at org.jboss.netty.channel.Channels.fireExceptionCaught(Channels.java:525)
	at org.jboss.netty.channel.socket.nio.AbstractNioWorker.write0(AbstractNioWorker.java:291)
	at org.jboss.netty.channel.socket.nio.AbstractNioWorker.writeFromUserCode(AbstractNioWorker.java:146)
	at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.handleAcceptedSocket(NioServerSocketPipelineSink.java:99)
	at org.jboss.netty.channel.socket.nio.NioServerSocketPipelineSink.eventSunk(NioServerSocketPipelineSink.java:36)
	at org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:779)
	at org.jboss.netty.channel.Channels.write(Channels.java:725)
	at org.jboss.netty.handler.codec.oneone.OneToOneEncoder.doEncode(OneToOneEncoder.java:71)
	at org.jboss.netty.handler.codec.oneone.OneToOneEncoder.handleDownstream(OneToOneEncoder.java:59)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:591)
	at org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:582)
	at org.jboss.netty.channel.Channels.write(Channels.java:704)
	at org.jboss.netty.channel.Channels.write(Channels.java:671)
	at org.jboss.netty.channel.AbstractChannel.write(AbstractChannel.java:248)
	at org.apache.camel.component.netty.http.handlers.HttpServerMultiplexChannelHandler.exceptionCaught(HttpServerMultiplexChannelHandler.java:142)
...


It isn&amp;amp;apos;t a problem for Netty 4 and also if you set orderedThreadPoolExecutor=true it works for Netty 3 as well.</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.http.handlers.HttpServerMultiplexChannelHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="8950" opendate="2015-07-10 14:16:04" fixdate="2015-07-10 14:19:45" resolution="Fixed">
		<buginformation>
			<summary>Injected Quartz2 scheduler doesn&amp;apos;t have access to CamelContext in jobs</summary>
			<description>Currently if you inject a scheduler the CamelContext won&amp;amp;apos;t be available for jobs to access. When the scheduler is created automatically, the context is added to the quartz scheduler context so the jobs can access it:
quartzContext.put(QuartzConstants.QUARTZ_CAMEL_CONTEXT + "-" + camelContextName, getCamelContext());</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.quartz2.QuartzComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="8951" opendate="2015-07-10 14:29:56" fixdate="2015-07-11 06:18:03" resolution="Fixed">
		<buginformation>
			<summary>RecipientList with RAW parameter do not work</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/java-net-URISyntaxException-using-recipientList-tp5769103.html</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.EndpointHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="3907" opendate="2011-04-27 15:27:59" fixdate="2015-07-12 08:23:58" resolution="Fixed">
		<buginformation>
			<summary>Component camel-sql needs the abiliity to process sql from the body of the exchange</summary>
			<description>camel sql should also support the ability to add the sql statements in the exchange body for processing.  This is linked via 3803.  </description>
			<version>2.7.0</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sql.SqlEndpoint.java</file>
			<file type="M">org.apache.camel.component.sql.SqlProducer.java</file>
			<file type="M">org.apache.camel.component.sql.SqlConstants.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">3801</link>
			<link type="Reference" description="relates to">3800</link>
			<link type="Reference" description="relates to">3803</link>
		</links>
	</bug>
	<bug id="8963" opendate="2015-07-14 05:47:46" fixdate="2015-07-14 07:58:14" resolution="Fixed">
		<buginformation>
			<summary>camel:route-suspend karaf command doesn&amp;apos;t work as expected</summary>
			<description>In previous versions of camel (2.13.2 for sure) it was possible to use camel:route-suspend command and specify route id only. In 2.15.2 its not possible anymore. For example:


karaf@root()&amp;gt; camel:route-list
 Context                           Route                                  Status
 -------                           -----                                  ------
 fi-remurex-cpty-context           fi-remurex-institution-queue           Started
karaf@root()&amp;gt; camel:route-suspend fi-remurex-institution-queue
Error executing command camel: route-suspend: argument context is required


At the same time, on &amp;lt;tab&amp;gt; key camel:route-suspend command still suggests route, but not context as second parameter. Used route id is unique, so I don&amp;amp;apos;t think its a good idea to ask for context in this case.
karaf 3.0.4, camel 2.15.2.</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.karaf.commands.RestShow.java</file>
			<file type="M">org.apache.camel.karaf.commands.AbstractRouteCommand.java</file>
			<file type="M">org.apache.camel.karaf.commands.RouteInfo.java</file>
			<file type="M">org.apache.camel.karaf.commands.RouteShow.java</file>
			<file type="M">org.apache.camel.commands.AbstractLocalCamelController.java</file>
		</fixedFiles>
	</bug>
	<bug id="8964" opendate="2015-07-14 06:59:29" fixdate="2015-07-14 07:58:34" resolution="Fixed">
		<buginformation>
			<summary>CamelContext - API for control routes may cause Route not to update it state</summary>
			<description>See CAMEL-8963
Its the Route instance that do not update it state as well. But the RouteService has the correct state. So one can be Started and the other Suspended.</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.util.ServiceHelper.java</file>
			<file type="M">org.apache.camel.impl.RouteSedaSuspendResumeTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8578" opendate="2015-03-31 09:54:32" fixdate="2015-07-14 08:38:40" resolution="Fixed">
		<buginformation>
			<summary>camel-http - May double encode uri when using HTTP_URI or HTTP_QUERY headers</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Apache-Camel-decodes-HTTP-query-params-and-httpclient-fails-with-Invalid-query-exception-tp5764794p5764843.html</description>
			<version>2.14.1</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http.helper.HttpHelperTest.java</file>
			<file type="M">org.apache.camel.component.http.helper.HttpHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="8954" opendate="2015-07-12 11:01:35" fixdate="2015-07-16 19:49:32" resolution="Fixed">
		<buginformation>
			<summary>Lock information is not handovered together with Exchange on-completion synchronizations</summary>
			<description>This applies to the file components when using common read-lock strategies:

markerFile - org.apache.camel.component.file.strategy.MarkerFileExclusiveReadLockStrategy
fileLock - org.apache.camel.component.file.strategy.FileLockExclusiveReadLockStrategy

This strategies stores lock information in the Exchange properties:

Exchange.FILE_LOCK_FILE_ACQUIRED == "CamelFileLockFileAcquired"
Exchange.FILE_LOCK_FILE_NAME == "CamelFileLockFileName"
Exchange.FILE_LOCK_EXCLUSIVE_LOCK == "CamelFileLockExclusiveLock"
Exchange.FILE_LOCK_RANDOM_ACCESS_FILE == "CamelFileLockRandomAccessFile"

Lock information is stored as scalar values and can hold information about only one single lock.
When there are two Exchanges participates in the route, share UoW, and synchronizations are handovered from one Exchange to another, information about both locks can&amp;amp;apos;t be stored in the Exchange properties and lost. Consequently when on-completion synchronizations are performed, read-lock strategies can&amp;amp;apos;t access information about all the locks and they are not released.
For example, after completing this route lock for file1.dat is not released:


from("file:data/input-a?fileName=file1.dat&amp;amp;readLock=markerFile")
    .pollEnrich("file:data/input-b?fileName=file2.dat&amp;amp;readLock=markerFile")
    .to("mock:result");

</description>
			<version>2.14.3</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFile.java</file>
			<file type="M">org.apache.camel.component.file.strategy.MarkerFileExclusiveReadLockStrategy.java</file>
			<file type="M">org.apache.camel.component.file.strategy.FileLockExclusiveReadLockStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="8643" opendate="2015-04-15 14:50:15" fixdate="2015-07-17 10:54:41" resolution="Fixed">
		<buginformation>
			<summary>Http Post from a streaming client sometimes fails to parse</summary>
			<description>When upgrading from camel 2.14.1 to 2.15.0 our http posts from clients were sometimes failing.  Traced issue to https://issues.apache.org/jira/browse/CAMEL-5806.  The linked issue added a check of InputStream.available() which on a slow or remote client the binary stream isn&amp;amp;apos;t always immediately available.  Since this is done as part of the initial setup the data is never parsed when it becomes available.</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http4.HttpBinding.java</file>
			<file type="M">org.apache.camel.component.http4.DefaultHttpBinding.java</file>
			<file type="M">org.apache.camel.component.http4.HttpEndpoint.java</file>
			<file type="M">org.apache.camel.component.http.HttpEndpoint.java</file>
			<file type="M">org.apache.camel.component.http.HttpBinding.java</file>
			<file type="M">org.apache.camel.component.http.DefaultHttpBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="8905" opendate="2015-06-25 12:13:38" fixdate="2015-07-18 07:33:39" resolution="Fixed">
		<buginformation>
			<summary>encoding problems in jsonpath</summary>
			<description>I detected three different encoding problems in jsonpath:

if jsonpath is called with an input stream which has an encoding different from the default encoding (given by Charset.defaultCharset()) then jsonpath still uses the default encoding. Error location in JsonPathEngine:
        else if (json instanceof InputStream) 
{
            InputStream is = (InputStream) json;
            return path.read(is, Charset.defaultCharset().displayName(), 
configuration);}


if jsonpath is called with a json file whose encoding is different from UTF-8, then jsonpath still parses the document with UTF-8. Error location in JsonPathEngine:
       else if (json instanceof File) 
{
            File file = (File) json;
            return path.read(file, configuration);
       }
 path.read(file, configuration) uses always UTF-8


if jsonpath is called with an URL pointing to a JSON document whose encoding is different from UTF-8, then jsonPath still parses the document with UTF-8. Error location in JsonPathEngine:
         else if (json instanceof URL) 
{
            URL url = (URL) json;
            return path.read(url, configuration);
         }
path.read(url, configuration) uses UTF-8

My solution proposal is to determine the encoding of the JSON documents automatically according to the specification RFC-4627 (https://www.ietf.org/rfc/rfc4627.txt; see chapter 3. Encoding) and then call the method path.read(jsonDocument,foundEncoding,configuration) with the found encoding. See attached patch.
Actually I can commit the patch myself. However, I would like that somebody who is more familiar with jsonpath than I does review my patch.
So please tell me if my patch can be accepted or not. I can then do the actual commit or I will discard the patch.</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.jsonpath.JsonPathEngine.java</file>
		</fixedFiles>
	</bug>
	<bug id="8984" opendate="2015-07-20 08:15:25" fixdate="2015-07-20 12:55:19" resolution="Fixed">
		<buginformation>
			<summary>BlueprintCamelContext OSGi service is not unregistered when context is stopped</summary>
			<description>org.apache.camel.core.osgi.OsgiCamelContextPublisher doesn&amp;amp;apos;t receive CamelContextStoppingEvent because org.apache.camel.util.EventHelper#doNotifyEvent() checks for started state and org.apache.camel.core.osgi.OsgiCamelContextPublisher is never started.</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.blueprint.CamelContextFactoryBean.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">3381</link>
		</links>
	</bug>
	<bug id="8978" opendate="2015-07-17 07:22:08" fixdate="2015-07-22 13:53:39" resolution="Fixed">
		<buginformation>
			<summary>Setting of SOAP headers via the Camel Header "org.apache.cxf.headers.Header.list" not working for CXF data format "PAYLOAD" </summary>
			<description>In the camel-cxf documentation https://camel.apache.org/cxf.html is described in the chapter "How to deal with the message for a camel-cxf endpoint in PAYLOAD data format" that "You can use the Header.HEADER_LIST as the key to set or get the SOAP headers".
But this only works for getting SOAP headers.
If you want to set SOAP headers via the Camel header Header.HEADER_LIST, the headers are not taken into account in the CXF-to-endpoint.
I analysed the problem and found out that 

the SOAP header list is forwarded to the CXF request context
that this header list is overwritten in CxfEndpoint.CamelCxfClientImpl by the CxfPayload.getHeaders() value.

My suggestion is that we merge the headers from the Camel header and the the CXF payload in CxfEndpoint.CamelCxfClientImpl. See the attached patch.
With the merging  we cover all different use cases:

the headers can be set in the CxfPayload
the headers can be set in the Camel header Header.list
the headers can be set in the CXFPayload and the CamelHeader Header.list.

Also the case where the list instance in the CxfPayload is the same as in the Camel header (in this case no merge is necessary) is covered. This case happens if the from-endpoint is also a CXF endpoint and the CXF payload is forwarded to the to-CXF-endpoint.
I can commit the change. However, before I do it I want to have the agreement from the CXF experts.</description>
			<version>2.14.3</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfEndpoint.java</file>
			<file type="M">org.apache.camel.component.cxf.CxfPayLoadSoapHeaderTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9013" opendate="2015-07-24 14:36:18" fixdate="2015-07-24 14:51:40" resolution="Fixed">
		<buginformation>
			<summary>Camel HTTP no longer supporting chunked transfer encoding with Tomcat</summary>
			<description>When sending a chunked POST whilst running the servlet under Tomcat, camel now fails to read the input stream and sets the body to null.
chunked-http-failure-test
This is due to camel checking the stream for available bytes introduced in CAMEL-5806. For whatever reason the CoyoteInputStream is returning 0 available bytes when handling a chunked request.


    if (len &amp;lt; 0) {
        InputStream is = request.getInputStream();
        if (is.available() == 0) {
            // no data so return null
            return null;
        }
    }

</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.servlet.ServletRestHttpBinding.java</file>
			<file type="M">org.apache.camel.component.servlet.ServletComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="9012" opendate="2015-07-24 14:17:41" fixdate="2015-07-24 17:03:54" resolution="Fixed">
		<buginformation>
			<summary>Olingo2&amp;apos;s batch process generates the invalid request</summary>
			<description>The syntax check of olingo2 lib was tighten from version 2.0.1.
As a result, the batch message generated by camel-ollingo2&amp;amp;apos;s is rejected by olingo2 version 2.0.1 and newer.
Concretely, the current message includes two extra new lines within the batch part that is rejected by the olingo2 library.
OLINGO-739
We should remove these two extra lines.</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.olingo2.api.impl.Olingo2AppImpl.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">9038</link>
		</links>
	</bug>
	<bug id="9019" opendate="2015-07-26 12:20:36" fixdate="2015-07-26 12:57:54" resolution="Fixed">
		<buginformation>
			<summary>ManagedRuntimeEndpointRegistry was not enlisted in JMX</summary>
			<description>This is not enlisted as ManagedRuntimeEndpointRegistry but as event notifier because its also that instance.</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.DefaultManagementLifecycleStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="9029" opendate="2015-07-28 14:08:56" fixdate="2015-07-28 14:13:27" resolution="Fixed">
		<buginformation>
			<summary>JGroups managed routes can be started too early</summary>
			<description>JGroupsFilters#dropNonCoordinatorViews doesn&amp;amp;apos;t filter non-view messages properly which can cause the wrong route to be started. This issue was not so easy to detect, as usually the channels used for cluster management doesn&amp;amp;apos;t send any other messages, than view ones.</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jgroups.JGroupsFilters.java</file>
		</fixedFiles>
	</bug>
	<bug id="9027" opendate="2015-07-28 08:46:42" fixdate="2015-07-29 09:08:53" resolution="Fixed">
		<buginformation>
			<summary>camel-sjms - Parse destinationName from endpointUri having colon in the name</summary>
			<description>If jndi name of a topic or a queue contains ":" (eg: /jms/test/hov.t1.dev:topic) the destination name won&amp;amp;apos;t be parsed correctly because of this code:
" destinationName = getEndpointUri().substring(getEndpointUri().lastIndexOf(":") + 1);"
inside class "SjmsEndpoint" line number 106.
</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sjms.SjmsEndpoint.java</file>
			<file type="M">org.apache.camel.component.sjms.SjmsEndpointNameOverrideTest.java</file>
			<file type="M">org.apache.camel.component.sjms.jms.DestinationNameParser.java</file>
			<file type="M">org.apache.camel.component.sjms.SjmsComponent.java</file>
			<file type="M">org.apache.camel.component.sjms.SjmsEndpointTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9032" opendate="2015-07-29 07:55:55" fixdate="2015-07-29 09:09:05" resolution="Fixed">
		<buginformation>
			<summary>Bean component - Should filter out abstract methods</summary>
			<description>If you call a method on a bean then the introspector should filter out abstract methods if there is class inheritance with abstract defined methods.
See SO
http://stackoverflow.com/questions/31671894/camel-ambiguousmethodcallexception-abstract-classes</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
		</fixedFiles>
	</bug>
	<bug id="9037" opendate="2015-07-30 08:06:04" fixdate="2015-07-31 11:01:18" resolution="Fixed">
		<buginformation>
			<summary>DefaultJmsMessageListenerContainer leaks threads</summary>
			<description>Threads created by DefaultTaskExecutorType.ThreadPool at
org.apache.camel.component.jms.DefaultJmsMessageListenerContainer.createDefaultTaskExecutor()
are never stopped, as destroy method is never called on the ThreadPoolTaskExecutor</description>
			<version>2.12.3</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.DefaultJmsMessageListenerContainer.java</file>
			<file type="M">org.apache.camel.component.jms.DefaultTaskExecutorType.java</file>
			<file type="M">org.apache.camel.component.jms.JmsConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="9035" opendate="2015-07-29 19:24:16" fixdate="2015-07-31 11:07:11" resolution="Fixed">
		<buginformation>
			<summary>unbind smpp connection bug </summary>
			<description>Suppose SMSC allowed one connection to client and due to any reason if session.unbindAndClose failed it will set session to null and dont retry to unbind. 
Connection/Session will remain open on SMSC till its TransactionTimeOut, mostly SMSc Admin set it to 5 to 10 mins. 
Following are snippet of org.apache.camel.component.smpp.SmppProducer and details are like 
1- if for any reason Camel try to unbind connection and it got failed below code print log and set session=null in both success/fail cases. 
2- After sending unbind it will try to reconnect. 
3- As SMSc allowed 1 connection which was not unbinded successfull it will not allowed second connection so reconnect will get failed. 
4- Camel call closesession on reconnection failure and will verify if session != null, as session is already null so this code will not send unbind again and apache camel will not able to get connection from SMSc until timeout happen on SMSc and this will results in 10 mins outage. 
If we change closeSession() like below 
current: 


private void  closeSession() { 
        if (session != null) { 
            session.removeSessionStateListener(this.internalSessionStateListener); 
            try { 
                Thread.sleep(1000); 
                session.unbindAndClose(); 
            } catch (Exception e) { 
              LOG.warn("Could not close session " + session); 
            } 

            session = null; 

        } 

    } 


Suggested: 


private void  closeSession() { 
        if (session != null) { 
            session.removeSessionStateListener(this.internalSessionStateListener); 
            try { 
                Thread.sleep(1000); 
                session.unbindAndClose(); 
                session = null; // if we put here then it will retry for unbind 
            } catch (Exception e) { 
              LOG.warn("Could not close session " + session); 
            } 
             session = null; // remove his line 
        } 
    } 

</description>
			<version>2.14.0</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.smpp.SmppConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9043" opendate="2015-07-31 17:58:01" fixdate="2015-08-03 10:02:53" resolution="Fixed">
		<buginformation>
			<summary>Fix camel-example-cxf-osgi/blueprint examples</summary>
			<description>Cannot deploy camel-example-cxf-osgi because of wrong Import-Package requirement. Expression for output filename is not evaluated properly in both examples.</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.example.reportincident.ReportIncidentRoutes.java</file>
		</fixedFiles>
	</bug>
	<bug id="9048" opendate="2015-08-03 12:27:58" fixdate="2015-08-05 16:01:54" resolution="Fixed">
		<buginformation>
			<summary>camel-core causes restart of karaf console if it is refreshed</summary>
			<description>Start karaf 4.0.0
feature:repo-add mvn:org.apache.cxf.karaf/apache-cxf/3.1.1/xml/features
feature:repo-add mvn:org.apache.camel.karaf/apache-camel/2.15.2/xml/features
feature:install camel-core
feature:install -v wss4j
The last feature install causes the karaf shell to restart. The refreshed bundles list shows this:
    jline/2.12.1 (Wired to org.apache.camel.camel-core/2.15.2 which is being refreshed)
    org.apache.camel.camel-core/2.15.2 (Should be wired to: org.apache.servicemix.bundles.xalan/2.7.1.7 (through [org.apache.camel.camel-core/2.15.2] osgi.wiring.package; filter:="(osgi.wiring.package=org.apache.xalan.xsltc.trax)"; resolution:=optional))
So this shows that the immediate reason is that jline was refreshed. As jline is used by the shell it also restarts.
Now it might seem strange that jline depends on camel-core. I had a similar issue in activemq-core Activator. It probed the classloaders of all bundles for well known interfaces to find extensions. I think camel-core does the same. The problem here is that jline has a dynamic import package: *. So the bundle classloader of jline is able to find any camel interface and will then have a wire to camel-core. So if then there is a refresh of camel-core it also will be refreshed.
This issue can hit all bundles that have a dynamic import package *. 
the solution is to not actually load interface classes but rather check the bundle wiring if there is a wiring to an interface package. This will then not change the wirings and so not cause these problems.
I will try to provide a fix for the problem.</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.osgi.Activator.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">3888</link>
			<link type="Regression" description="breaks">9144</link>
		</links>
	</bug>
	<bug id="9059" opendate="2015-08-06 12:58:53" fixdate="2015-08-06 13:25:27" resolution="Fixed">
		<buginformation>
			<summary>Jetty exposes its endpoint without component name</summary>
			<description>A simple route such as


        from("jetty:http://0.0.0.0:8080/ping").transform(constant("PONG\n"));


Enlists the jetty endpoint as just: http://0.0.0.0:8080/ping. But then its mistakenly the http component. It should be the full url with jetty as prefix.</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="8756" opendate="2015-05-08 10:42:38" fixdate="2015-08-07 14:17:48" resolution="Fixed">
		<buginformation>
			<summary>KafkaConsumer doesn&amp;apos;t stop consuming when suspended, preventing graceful route shutdown</summary>
			<description>Hi,
we encountered a problem when consuming events from Kafka and stopping the route while there are still events in Kafka.
Obviously, the run-method doesn&amp;amp;apos;t stop reading events from Kafka stream and so there are always events in-flight what prevents the route from being gracefully shut down.

12:30:27.611 INFO o.a.c.impl.DefaultCamelContext - Apache Camel 2.15.2 (CamelContext: camel-1) is shutting down
12:30:27.612 INFO o.a.c.i.DefaultShutdownStrategy - Starting to graceful shutdown 1 routes (timeout 300 seconds)
12:30:27.615 INFO o.a.c.i.DefaultShutdownStrategy - Waiting as there are still 1 inflight and pending exchanges to complete, timeout in 300 seconds.
12:30:28.615 INFO o.a.c.i.DefaultShutdownStrategy - Waiting as there are still 1 inflight and pending exchanges to complete, timeout in 299 seconds.
12:30:29.615 INFO o.a.c.i.DefaultShutdownStrategy - Waiting as there are still 1 inflight and pending exchanges to complete, timeout in 298 seconds.
12:30:30.616 INFO o.a.c.i.DefaultShutdownStrategy - Waiting as there are still 1 inflight and pending exchanges to complete, timeout in 297 seconds.
12:30:31.616 INFO o.a.c.i.DefaultShutdownStrategy - Waiting as there are still 1 inflight and pending exchanges to complete, timeout in 296 seconds.
12:30:32.616 INFO o.a.c.i.DefaultShutdownStrategy - Waiting as there are still 1 inflight and pending exchanges to complete, timeout in 295 seconds.
12:30:33.618 INFO o.a.c.c.kafka.KafkaConsumer - Stopping Kafka consumer
12:30:33.618 INFO k.c.ZookeeperConsumerConnector - [camelGroup1_localhorst-1431081021945-a3d9f455], ZKConsumerConnector shutting down
12:30:33.626 INFO k.c.ConsumerFetcherManager - [ConsumerFetcherManager-1431081022017] Stopping leader finder thread
12:30:33.626 INFO k.c.ConsumerFetcherManager$LeaderFinderThread - [camelGroup1_localhorst-1431081021945-a3d9f455-leader-finder-thread], Shutting down
12:30:33.626 INFO k.c.ConsumerFetcherManager$LeaderFinderThread - [camelGroup1_localhorst-1431081021945-a3d9f455-leader-finder-thread], Stopped 
12:30:33.627 INFO k.c.ConsumerFetcherManager$LeaderFinderThread - [camelGroup1_localhorst-1431081021945-a3d9f455-leader-finder-thread], Shutdown completed
12:30:33.627 INFO k.c.ConsumerFetcherManager - [ConsumerFetcherManager-1431081022017] Stopping all fetchers
12:30:33.627 INFO k.consumer.ConsumerFetcherThread - [ConsumerFetcherThread-camelGroup1_localhorst-1431081021945-a3d9f455-0-0], Shutting down
12:30:33.627 INFO k.consumer.ConsumerFetcherThread - [ConsumerFetcherThread-camelGroup1_localhorst-1431081021945-a3d9f455-0-0], Stopped 
12:30:33.627 INFO k.consumer.ConsumerFetcherThread - [ConsumerFetcherThread-camelGroup1_localhorst-1431081021945-a3d9f455-0-0], Shutdown completed
12:30:33.627 INFO k.c.ConsumerFetcherManager - [ConsumerFetcherManager-1431081022017] All connections stopped
12:30:33.662 INFO o.I0Itec.zkclient.ZkEventThread - Terminate ZkClient event thread.
12:30:33.696 INFO org.apache.zookeeper.ZooKeeper - Session: 0x14d2d359d900022 closed
12:30:33.696 INFO org.apache.zookeeper.ClientCnxn - EventThread shut down
12:30:33.696 INFO k.c.ZookeeperConsumerConnector - [camelGroup1_localhorst-1431081021945-a3d9f455], ZKConsumerConnector shutdown completed in 78 ms
12:30:33.698 INFO o.a.c.i.DefaultShutdownStrategy - Route: route1 shutdown complete, was consuming from: Endpoint[kafka://localhost:9092?groupId=camelGroup1&amp;amp;topic=mykafkatopic&amp;amp;zookeeperHost=localhost]
12:30:33.699 INFO o.a.c.i.DefaultShutdownStrategy - Graceful shutdown of 1 routes completed in 6 seconds
12:30:33.703 INFO o.a.c.impl.DefaultCamelContext - Apache Camel 2.15.2 (CamelContext: camel-1) uptime 12.510 seconds
12:30:33.703 INFO o.a.c.impl.DefaultCamelContext - Apache Camel 2.15.2 (CamelContext: camel-1) is shutdown in 6.091 seconds
12:30:33.717 ERROR o.a.c.p.DefaultErrorHandler - Failed delivery for (MessageId: ID-localhorst-33557-1431081020733-0-1656461 on ExchangeId: ID-localhorst-33557-1431081020733-0-1656462). Exhausted after delivery attempt: 1 caught: java.util.concurrent.RejectedExecutionException

Message History
---------------------------------------------------------------------------------------------------------------------------------------
RouteId              ProcessorId          Processor                                                                        Elapsed (ms)
[route1            ] [route1            ] [                                                                              ] [        14]
[route1            ] [filter1           ] [filter[{SimpleKafkaToCamelExample$1$$Lambda$1/1468303011@a38d7a3}]            ] [         1]
[route1            ] [bean1             ] [bean[SimpleKafkaToCamelExample$1$$Lambda$2/1354011814@e4ce7ae]                ] [         0]

Exchange
---------------------------------------------------------------------------------------------------------------------------------------
Exchange[
	Id                  ID-localhorst-33557-1431081020733-0-1656462
	ExchangePattern     InOnly
	Headers             {breadcrumbId=ID-localhorst-33557-1431081020733-0-1656461, CamelRedelivered=false, CamelRedeliveryCounter=0, kafka.EXCHANGE_NAME=0, kafka.TOPIC=mykafkatopic}
	BodyType            byte[]
	Body                SOMESTRING
]

Stacktrace
---------------------------------------------------------------------------------------------------------------------------------------
java.util.concurrent.RejectedExecutionException: null
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:349) ~[camel-core-2.15.2.jar:2.15.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191) [camel-core-2.15.2.jar:2.15.2]
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:118) ~[camel-core-2.15.2.jar:2.15.2]
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:80) ~[camel-core-2.15.2.jar:2.15.2]
	at org.apache.camel.processor.FilterProcessor.process(FilterProcessor.java:58) ~[camel-core-2.15.2.jar:2.15.2]
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:77) ~[camel-core-2.15.2.jar:2.15.2]
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:448) ~[camel-core-2.15.2.jar:2.15.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191) [camel-core-2.15.2.jar:2.15.2]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191) [camel-core-2.15.2.jar:2.15.2]
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:109) [camel-core-2.15.2.jar:2.15.2]
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:87) [camel-core-2.15.2.jar:2.15.2]
	at org.apache.camel.component.kafka.KafkaConsumer$AutoCommitConsumerTask.run(KafkaConsumer.java:209) [camel-kafka-2.15.2.jar:2.15.2]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [na:1.8.0_45]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [na:1.8.0_45]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_45]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_45]
	at java.lang.Thread.run(Thread.java:745) [na:1.8.0_45]
12:30:34.171 INFO k.c.ZookeeperConsumerConnector - [camelGroup1_localhorst-1431081021945-a3d9f455], stopping watcher executor thread for consumer camelGroup1_localhorst-1431081021945-a3d9f455


Regards,
 
Andr</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.support.ServiceSupport.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9049" opendate="2015-08-04 15:39:32" fixdate="2015-08-09 07:52:56" resolution="Fixed">
		<buginformation>
			<summary>Websocket Component not shutting down embedded jetty server on component shutdown</summary>
			<description>When stopping the websocket component, it has been observed that the embedded Jetty server does not completely shut down. This causes a bind error when attempting to start the component again. </description>
			<version>2.15.2</version>
			<fixedVersion>2.15.3, 2.16.0, 2.14.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.websocket.WebsocketProducer.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9065" opendate="2015-08-09 11:58:38" fixdate="2015-08-10 07:39:14" resolution="Fixed">
		<buginformation>
			<summary>Exchange created needs to be aware of its FROM endpoint. </summary>
			<description>In 2.16, DefaultRuntimeEndpointRegistry (an EventNotifier) is extended to being able to handle ExchangeCreatedEvent s. 
In its notify(EventObjet), when processing an ExchangeCreateEvent, a reference to exchange&amp;amp;apos;s from endpoint is needed in order to obtain its endpoint uri. 
DefaultRuntimeEndpointRegistry.java

} else if (extended &amp;amp;&amp;amp; event instanceof ExchangeCreatedEvent) {
            // we only capture details in extended mode
            ExchangeCreatedEvent ece = (ExchangeCreatedEvent) event;
            Endpoint endpoint = ece.getExchange().getFromEndpoint();
            String routeId = ece.getExchange().getFromRouteId();
            String uri = endpoint.getEndpointUri();
            String key = asUtilizationKey(routeId, uri);
            if (key != null) {
                inputUtilization.onHit(key);
            }


The problem is located in MongoDbEndpoint createMongoDbExchange)() 
MongoDbEndpoint.java

public Exchange createMongoDbExchange(DBObject dbObj) {
        Exchange exchange = new DefaultExchange(this.getCamelContext(), getExchangePattern()); 
        ...
    }


This Exchange constructor does not take into consideration exchange&amp;amp;apos;s from endpoint, consequently causing a NPE when processing its associated ExchangeCreatedEvent.
When constructing an exchange,  MongoDbEndpoint should use its parent &amp;amp;apos;s createExchange() which uses the proper Exchange constructors. 
MongoDbEndpoint.java

public Exchange createMongoDbExchange(DBObject dbObj) {
//        Exchange exchange = new DefaultExchange(this.getCamelContext(), getExchangePattern());
        Exchange exchange = super.createExchange();
...
}

</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.ironmq.IronMQEndpoint.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaEndpoint.java</file>
			<file type="M">org.apache.camel.component.openshift.OpenShiftEndpoint.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppEndpoint.java</file>
			<file type="M">org.apache.camel.component.mail.MailEndpoint.java</file>
			<file type="M">org.apache.camel.component.aws.sqs.SqsEndpoint.java</file>
			<file type="M">org.apache.camel.component.javaspace.JavaSpaceEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.JmsEndpoint.java</file>
			<file type="M">org.apache.camel.component.cache.CacheEndpoint.java</file>
			<file type="M">org.apache.camel.component.snmp.SnmpEndpoint.java</file>
			<file type="M">org.apache.camel.component.irc.IrcEndpoint.java</file>
			<file type="M">org.apache.camel.component.aws.s3.S3Endpoint.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileEndpoint.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="8147" opendate="2014-12-11 19:52:26" fixdate="2015-08-11 10:54:13" resolution="Duplicate">
		<buginformation>
			<summary>Using @ManagedResource on an Endpoint removes all the default JMX properties</summary>
			<description>Using @ManagedResource on an Endpoint removes all the default JMX properties. 
For example:
Camel: camelContext
Camel management name: camelContext
Endpoint uri: xxxxxxxxxxxx
Object Name: xxxxxxxxxx
Singleton: true
State: Started
Are present by default for all endpoints, as soon as you have a custom endpoint annotated with @ManagedResource these defaults are no longer present. </description>
			<version>2.14.0</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.zookeeper.ZooKeeperEndpoint.java</file>
			<file type="M">org.apache.camel.component.zookeeper.ZooKeeperManagedEndpointTest.java</file>
			<file type="M">org.apache.camel.component.jms.JmsEndpointConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.twitter.TwitterEndpointPolling.java</file>
			<file type="M">org.apache.camel.component.jms.JmsQueueEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.BrowsableQueueTest.java</file>
			<file type="M">org.apache.camel.component.jms.JmsEndpoint.java</file>
			<file type="M">org.apache.camel.component.disruptor.DisruptorEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.ManagedJmsEndpointTest.java</file>
			<file type="M">org.apache.camel.component.timer.TimerEndpoint.java</file>
			<file type="M">org.apache.camel.component.seda.SedaEndpoint.java</file>
			<file type="M">org.apache.camel.component.xslt.XsltEndpoint.java</file>
			<file type="M">org.apache.camel.management.ManagedCustomProcessorTest.java</file>
			<file type="M">org.apache.camel.management.DefaultManagementMBeanAssembler.java</file>
			<file type="M">org.apache.camel.management.MaskRequiredModelMBean.java</file>
			<file type="M">org.apache.camel.management.ManagedResourceTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">6660</link>
		</links>
	</bug>
	<bug id="6660" opendate="2013-08-22 13:24:32" fixdate="2015-08-11 13:23:00" resolution="Fixed">
		<buginformation>
			<summary>JMX - Using custom @ManagedResource and extending default components can cause some attributes to be unavailable</summary>
			<description>Related to CAMEL-6586
Its when you use a custom @ManagedResource such as in a custom component, then some of the out of the box attributes such as camelId, state, etc may be shown as Unavailable in JMX consoles.
Its the MBean assembler and JMX in general that needs to find some way of being able to mixin the custom attributes/operations with the out of the box ones. So you dont have to copy the out of the box attributes to your custom classes.</description>
			<version>2.14.0</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.zookeeper.ZooKeeperEndpoint.java</file>
			<file type="M">org.apache.camel.component.zookeeper.ZooKeeperManagedEndpointTest.java</file>
			<file type="M">org.apache.camel.component.jms.JmsEndpointConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.twitter.TwitterEndpointPolling.java</file>
			<file type="M">org.apache.camel.component.jms.JmsQueueEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.BrowsableQueueTest.java</file>
			<file type="M">org.apache.camel.component.jms.JmsEndpoint.java</file>
			<file type="M">org.apache.camel.component.disruptor.DisruptorEndpoint.java</file>
			<file type="M">org.apache.camel.component.jms.ManagedJmsEndpointTest.java</file>
			<file type="M">org.apache.camel.component.timer.TimerEndpoint.java</file>
			<file type="M">org.apache.camel.component.seda.SedaEndpoint.java</file>
			<file type="M">org.apache.camel.component.xslt.XsltEndpoint.java</file>
			<file type="M">org.apache.camel.management.ManagedCustomProcessorTest.java</file>
			<file type="M">org.apache.camel.management.DefaultManagementMBeanAssembler.java</file>
			<file type="M">org.apache.camel.management.MaskRequiredModelMBean.java</file>
			<file type="M">org.apache.camel.management.ManagedResourceTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">8147</link>
			<link type="Reference" description="relates to">6586</link>
			<link type="dependent" description="is depended upon by">9074</link>
		</links>
	</bug>
	<bug id="9087" opendate="2015-08-19 06:46:29" fixdate="2015-08-19 06:59:19" resolution="Fixed">
		<buginformation>
			<summary>camel-pgevent payload always null</summary>
			<description>(note, camel-pgevent doesn&amp;amp;apos;t seem to have a component listed in JIRA)
Having the following reproducer


@ContextName("myCdiCamelContext")
public class MyRoutes extends RouteBuilder {

    @Inject
    @Uri("pgevent://localhost:5432/postgres/foobar?user=postgres&amp;amp;pass=mysecretpassword")
    private Endpoint listenEndpoint;

    @Inject
    @Uri("pgevent://localhost:5432/postgres/foobar?user=postgres&amp;amp;pass=mysecretpassword")
    private Endpoint notifyEndpoint;

    @Inject
    @Uri("timer:foo?period=5000")
    private Endpoint timerEndpoint;

    @Inject
    @Uri("log:output")
    private Endpoint resultEndpoint;

    @Inject
    private SomeBean someBean;

    @Override
    public void configure() throws Exception {
        from(timerEndpoint)
                .transform().simple("hello")
                .to(notifyEndpoint);

        from(listenEndpoint)
            .to(resultEndpoint);
    }
}


together with


docker run --name some-postgres -p 5432:5432 -e POSTGRES_PASSWORD=mysecretpassword -d postgres


the notify payload is always null

2015-08-19 08:40:51,216 [0 - timer://foo] DEBUG SendProcessor                  - &amp;gt;&amp;gt;&amp;gt;&amp;gt; Endpoint[pgevent://localhost:5432/postgres/foobar?pass=mysecretpassword&amp;amp;user=postgres] Exchange[Message: hello]
2015-08-19 08:40:51,227 [C EventLoop (2)] DEBUG SendProcessor                  - &amp;gt;&amp;gt;&amp;gt;&amp;gt; Endpoint[log://output] Exchange[Message: null]
2015-08-19 08:40:51,228 [C EventLoop (2)] INFO  output                         - Exchange[ExchangePattern: InOnly, BodyType: null, Body: [Body is null]]
2015-08-19 08:40:56,199 [0 - timer://foo] DEBUG SendProcessor                  - &amp;gt;&amp;gt;&amp;gt;&amp;gt; Endpoint[pgevent://localhost:5432/postgres/foobar?pass=mysecretpassword&amp;amp;user=postgres] Exchange[Message: hello]
2015-08-19 08:40:56,200 [C EventLoop (2)] DEBUG SendProcessor                  - &amp;gt;&amp;gt;&amp;gt;&amp;gt; Endpoint[log://output] Exchange[Message: null]
2015-08-19 08:40:56,201 [C EventLoop (2)] INFO  output                         - Exchange[ExchangePattern: InOnly, BodyType: null, Body: [Body is null]]
2015-08-19 08:41:01,199 [0 - timer://foo] DEBUG SendProcessor                  - &amp;gt;&amp;gt;&amp;gt;&amp;gt; Endpoint[pgevent://localhost:5432/postgres/foobar?pass=mysecretpassword&amp;amp;user=postgres] Exchange[Message: hello]
2015-08-19 08:41:01,201 [C EventLoop (2)] DEBUG SendProcessor                  - &amp;gt;&amp;gt;&amp;gt;&amp;gt; Endpoint[log://output] Exchange[Message: null]
2015-08-19 08:41:01,201 [C EventLoop (2)] INFO  output                         - Exchange[ExchangePattern: InOnly, BodyType: null, Body: [Body is null]]


It seems that the camel-pgevent consumer uses 
outOnly.setOut(msg);
instead of 
outOnly.setIn(msg);
and the producer
exchange.getOut()
instead of 
exchange.getIn()</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0, 2.15.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.pgevent.PgEventEndpoint.java</file>
			<file type="M">org.apache.camel.component.pgevent.PgEventProducer.java</file>
			<file type="M">org.apache.camel.component.pgevent.PgEventConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9089" opendate="2015-08-19 13:18:20" fixdate="2015-08-21 07:38:43" resolution="Fixed">
		<buginformation>
			<summary>Ambiguous URI in Rest API</summary>
			<description>Configuration of multiple URIs for the same method in a REST service containing wildcards and fixed parts does not work. Example: 


&amp;lt;get uri="/{uuid}/meta" ...&amp;gt;
&amp;lt;get uri="/{uuid}/{channel}" ...&amp;gt;


This causes ServletRestServletResolveConsumerStrategy.java to identify 2 
consumerPath candidates (lines 70-77), which isn&amp;amp;apos;t handled afterwords (line 80). It probably should use the most specific one in this case.</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0, 2.15.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyRestServletResolveConsumerStrategy.java</file>
			<file type="M">org.apache.camel.component.servlet.ServletRestServletResolveConsumerStrategy.java</file>
			<file type="M">org.apache.camel.component.servlet.rest.RestServletGetWildcardsTest.java</file>
			<file type="M">org.apache.camel.component.netty4.http.handlers.HttpServerMultiplexChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty.http.handlers.HttpServerMultiplexChannelHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="9099" opendate="2015-08-25 07:31:57" fixdate="2015-08-25 07:55:05" resolution="Fixed">
		<buginformation>
			<summary>[camel-script] wrong detection of script engine factories</summary>
			<description>
java.lang.ClassNotFoundException: # Licensed to the Apache Software Foundation (ASF) under one or more not found by groovy-all [228]
	at org.apache.felix.framework.BundleWiringImpl.findClassOrResourceByDelegation(BundleWiringImpl.java:1556)[org.apache.felix.framework-4.4.1.jar:]
	at org.apache.felix.framework.BundleWiringImpl.access$400(BundleWiringImpl.java:77)[org.apache.felix.framework-4.4.1.jar:]
	at org.apache.felix.framework.BundleWiringImpl$BundleClassLoader.loadClass(BundleWiringImpl.java:1993)[org.apache.felix.framework-4.4.1.jar:]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)[:1.8.0_51]
	at org.apache.felix.framework.Felix.loadBundleClass(Felix.java:1853)[org.apache.felix.framework-4.4.1.jar:]
	at org.apache.felix.framework.BundleImpl.loadClass(BundleImpl.java:958)[org.apache.felix.framework-4.4.1.jar:]
	at org.apache.camel.script.osgi.Activator$BundleScriptEngineResolver.getFactory(Activator.java:229)[230:org.apache.camel.camel-script:2.15.1]
	at org.apache.camel.script.osgi.Activator$BundleScriptEngineResolver.getScriptNames(Activator.java:210)[230:org.apache.camel.camel-script:2.15.1]
	at org.apache.camel.script.osgi.Activator$BundleScriptEngineResolver.access$000(Activator.java:191)[230:org.apache.camel.camel-script:2.15.1]
	at org.apache.camel.script.osgi.Activator.getAvailableScriptNames(Activator.java:118)[230:org.apache.camel.camel-script:2.15.1]
	at org.apache.camel.script.osgi.Activator.updateAvailableScriptLanguages(Activator.java:138)[230:org.apache.camel.camel-script:2.15.1]
	at org.apache.camel.script.osgi.Activator.removedBundle(Activator.java:107)[230:org.apache.camel.camel-script:2.15.1]
	at org.apache.camel.impl.osgi.tracker.BundleTracker$Tracked.customizerRemoved(BundleTracker.java:455)[176:org.apache.camel.camel-core:2.15.1]
	at org.apache.camel.impl.osgi.tracker.AbstractTracked.untrack(AbstractTracked.java:346)[176:org.apache.camel.camel-core:2.15.1]
	at org.apache.camel.impl.osgi.tracker.BundleTracker$Tracked.bundleChanged(BundleTracker.java:413)[176:org.apache.camel.camel-core:2.15.1]
	at org.apache.felix.framework.util.EventDispatcher.invokeBundleListenerCallback(EventDispatcher.java:869)[org.apache.felix.framework-4.4.1.jar:]
	at org.apache.felix.framework.util.EventDispatcher.fireEventImmediately(EventDispatcher.java:790)[org.apache.felix.framework-4.4.1.jar:]
	at org.apache.felix.framework.util.EventDispatcher.fireBundleEvent(EventDispatcher.java:515)[org.apache.felix.framework-4.4.1.jar:]
	at org.apache.felix.framework.Felix.fireBundleEvent(Felix.java:4429)[org.apache.felix.framework-4.4.1.jar:]
	at org.apache.felix.framework.Felix.stopBundle(Felix.java:2528)[org.apache.felix.framework-4.4.1.jar:]
	at org.apache.felix.framework.Felix$RefreshHelper.stop(Felix.java:4859)[org.apache.felix.framework-4.4.1.jar:]
	at org.apache.felix.framework.Felix.refreshPackages(Felix.java:4130)[org.apache.felix.framework-4.4.1.jar:]
	at org.apache.felix.framework.FrameworkWiringImpl.run(FrameworkWiringImpl.java:178)[org.apache.felix.framework-4.4.1.jar:]
	at java.lang.Thread.run(Thread.java:745)[:1.8.0_51]

</description>
			<version>2.15.3</version>
			<fixedVersion>2.16.0, 2.15.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.script.osgi.Activator.java</file>
		</fixedFiles>
	</bug>
	<bug id="9104" opendate="2015-08-27 21:53:06" fixdate="2015-08-27 23:40:21" resolution="Fixed">
		<buginformation>
			<summary>HttpHelper concats fixed endpoint URI query parameters with CamelHttpPath header in wrong order</summary>
			<description>

.setHeader(Exchange.HTTP_PATH, constant("/my/path"))
.to("http4://myhost:80?abc=123")


leads to Camel requesting the following URL:


http://myhost:80?abc=123/my/path


instead of:


http://myhost:80/my/path?abc=123

</description>
			<version>2.14.3</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpProducerQueryParamTest.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpHelper.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpHelper.java</file>
			<file type="M">org.apache.camel.http.common.HttpHelper.java</file>
			<file type="M">org.apache.camel.component.http4.HttpPathTest.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpProducerQueryParamTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9092" opendate="2015-08-20 07:00:58" fixdate="2015-08-28 15:01:52" resolution="Fixed">
		<buginformation>
			<summary>MQTT consumer receives duplicate messages after broker restart</summary>
			<description>if clientId is specified, after ActiveMQ broker restart, camel-mqtt consumer starts to receive duplicate messages. Please see the testcase attached.</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0, 2.15.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mqtt.MQTTEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="9108" opendate="2015-09-01 20:33:52" fixdate="2015-09-04 08:28:41" resolution="Duplicate">
		<buginformation>
			<summary>Camel Kafka component builds Producer topic off of message instead of to() URI</summary>
			<description>It was noticed in camel-kafka 2.15.3 that the KafkaProducer was reading the kafka.TOPIC off of the Exchange envelope instead of reading it off of the configured KafkaEndpoint/Configuration which subsequently breaks the ability to route messages from a Kafka topic to a Kafka topic based upon a Predicate.
```
from("kafka:localhost:9092?topic=A&amp;amp;groupId=B....").to("kafka:localhost:9092?topic=B.....")
```
I&amp;amp;apos;ve created a pull request on github that addresses this issue:
https://github.com/apache/camel/pull/597</description>
			<version>2.15.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.kafka.KafkaProducer.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaEndpoint.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaConfiguration.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaProducerTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">8923</link>
		</links>
	</bug>
	<bug id="8783" opendate="2015-05-19 21:19:38" fixdate="2015-09-05 09:11:25" resolution="Fixed">
		<buginformation>
			<summary>Transacted not working correctly in scala</summary>
			<description>When I try to use transacted in a scala route, I get an error and the camel context doesn&amp;amp;apos;t start.
The error states that there is no output in route.
After some time watching at the code with different breakpoints, I noticed :
In org.apache.camel.scala.dsl.builder.RouteBuilder (l199) the transacted with URI doesn&amp;amp;apos;t call the stack.top.transacted with the URI parameter.
Even with this done, it still gives the same error : 
"Route myRoute has no output processors. You need to add outputs to the route such as to("log:foo")."
even when  my route is as simple as :
"direct:something" ==&amp;gt; 
{
  routeId("log:foo")
  transacted("SomeStrategy")
  --&amp;gt; ("log:foo")
}

After some more debug, I saw that the output list for the transacted node stays empty, so my guess is that, in the org.apache.camel.scala.dsl.SAbstractDefinition class, the line def transacted(ref: String) = wrap(target.transacted(ref)) should return something else to handle outputs.
Since I can mix java and scala routes, there are workarounds, but still, now that I&amp;amp;apos;ve gotten used to scala routes, I don&amp;amp;apos;t really want to go back to java routes 
</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0, 2.15.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.RouteDefinition.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">8784</link>
		</links>
	</bug>
	<bug id="7921" opendate="2014-10-16 11:30:49" fixdate="2015-09-09 05:26:49" resolution="Fixed">
		<buginformation>
			<summary>The soapAction HTTP header is not correctly set when running the CXF client in POJO mode using Camel</summary>
			<description>The soapAction HTTP header is not correctly set when running the CXF client in POJO mode using Camel.
The root cause seems to be that the service name from the generated service class differs from the service name in the WSDL.
For me it is unclear if this should be an issue with the cxf-codegen-plugin or with the Camel CXF component. When running the CXF client without Camel then the soapAction HTTP header is correctly set and the issue does not occur. So that&amp;amp;apos;s why I first report the bug with Camel.
Possible workarounds I found are:
1) Explicitly specifying the correct serviceName as CXF endpoint attribute.
2) Explicitly setting the soapAction header in the Camel route prior to calling the CXF endpoint.
Both workarounds are not desirable, because they are easily forgotten and CXF does not throw an exception when you do. According to the basic profile v1.0 the soapAction HTTP header must match the value in the WSDL and receiving SOAP servers may throw a SOAP Fault if it doesn&amp;amp;apos;t. Some SOAP servers do throw an exception when the soapAction HTTP header is invalid. Resulting in communication failures between some SOAP client/server combinations.
I created a test project to verify the above behaviour with the following tests:
1) CXF in PAYLOAD with Camel. =&amp;gt; OK
2) CXF in POJO mode without Camel =&amp;gt; OK
3) CXF in POJO mode with Camel =&amp;gt; NOT OK
4) CXF in POJO mode with service name set =&amp;gt; OK
5) CXF in POJO mode with soapAction set =&amp;gt; OK
I run the test project with multiple combinations of Camel and CXF. The following combinations I have tried:
1) Camel 2.12.3 and CXF 2.7.10 (Apache Servicemix 5.0.0 setup)
2) Camel 2.12.4 and CXF 2.7.11 (Apache Servicemix 5.0.5 setup)
3) Camel 2.13.2 and CXF 2.7.11 (Apache Servicemix 5.1.3 and 5.3.0 setup)
4) Camel 2.14.0 and CXF 3.0.1
In the example project the mismatch occurs between an annotation in the generated service class:


@WebService(targetNamespace = "http://finalist.nl/ai/", name = "ICamelCxfTestService")


and the definition of the service name in the WSDL:


&amp;lt;wsdl:service name="CamelCxfTestService"&amp;gt;

</description>
			<version>2.12.3</version>
			<fixedVersion>2.16.0, 2.14.4, 2.15.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="9124" opendate="2015-09-09 12:23:11" fixdate="2015-09-09 12:32:29" resolution="Fixed">
		<buginformation>
			<summary>RedeliveryPattern should support property placeholders</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Can-t-configure-delayPattern-with-property-placeholders-tp5771356.html</description>
			<version>2.15.3</version>
			<fixedVersion>2.16.0, 2.15.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.RedeliveryPolicyDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="8748" opendate="2015-05-06 13:50:06" fixdate="2015-09-11 07:31:34" resolution="Fixed">
		<buginformation>
			<summary>DozerBeanMapper cannot instantiate DozerThreadContextClassLoader </summary>
			<description>


15:26:16,518 SEVERE [org.jboss.arquillian.protocol.jmx.JMXTestRunner] (pool-2-thread-1) Failed: org.wildfly.camel.test.csv.CSVIntegrationTest.testMarshal: org.dozer.MappingException: java.lang.InstantiationException: org.apache.camel.converter.dozer.DozerThreadContextClassLoader
	at org.dozer.util.MappingUtils.throwMappingException(MappingUtils.java:82) [dozer-5.5.1.jar:]
	at org.dozer.util.ReflectionUtils.newInstance(ReflectionUtils.java:366) [dozer-5.5.1.jar:]
	at org.dozer.DozerInitializer.registerClassLoader(DozerInitializer.java:118) [dozer-5.5.1.jar:]
	at org.dozer.DozerInitializer.initialize(DozerInitializer.java:98) [dozer-5.5.1.jar:]
	at org.dozer.DozerInitializer.init(DozerInitializer.java:79) [dozer-5.5.1.jar:]
	at org.dozer.DozerInitializer.init(DozerInitializer.java:64) [dozer-5.5.1.jar:]
	at org.dozer.DozerBeanMapper.init(DozerBeanMapper.java:173) [dozer-5.5.1.jar:]
	at org.dozer.DozerBeanMapper.&amp;lt;init&amp;gt;(DozerBeanMapper.java:99) [dozer-5.5.1.jar:]
	at org.apache.camel.converter.dozer.DozerTypeConverterLoader.createDozerBeanMapper(DozerTypeConverterLoader.java:232) [camel-dozer-2.16-SNAPSHOT.jar:2.16-SNAPSHOT]
	at org.apache.camel.converter.dozer.DozerTypeConverterLoader.&amp;lt;init&amp;gt;(DozerTypeConverterLoader.java:118) [camel-dozer-2.16-SNAPSHOT.jar:2.16-SNAPSHOT]
	at org.wildfly.camel.test.csv.CSVIntegrationTest.testMarshal(CSVIntegrationTest.java:68) [csv-dataformat-tests:]
...
Caused by: java.lang.InstantiationException: org.apache.camel.converter.dozer.DozerThreadContextClassLoader
	at java.lang.Class.newInstance(Class.java:423) [rt.jar:1.8.0_31]
	at org.dozer.util.ReflectionUtils.newInstance(ReflectionUtils.java:364) [dozer-5.5.1.jar:]
	... 150 more
Caused by: java.lang.NoSuchMethodException: org.apache.camel.converter.dozer.DozerThreadContextClassLoader.&amp;lt;init&amp;gt;()
	at java.lang.Class.getConstructor0(Class.java:3074) [rt.jar:1.8.0_31]
	at java.lang.Class.newInstance(Class.java:408) [rt.jar:1.8.0_31]
	... 151 more


The org.dozer.DozerInitializer does


  private void registerClassLoader(GlobalSettings globalSettings, ClassLoader classLoader, BeanContainer beanContainer) {
    String classLoaderName = globalSettings.getClassLoaderName();
    if (!DozerConstants.DEFAULT_CLASS_LOADER_BEAN.equals(classLoaderName)) {
      DefaultClassLoader defaultClassLoader = new DefaultClassLoader(classLoader);
      Class&amp;lt;? extends DozerClassLoader&amp;gt; classLoaderType = loadBeanType(classLoaderName, defaultClassLoader, DozerClassLoader.class);
      DozerClassLoader classLoaderBean = ReflectionUtils.newInstance(classLoaderType);
      beanContainer.setClassLoader(classLoaderBean);
    }
  }

</description>
			<version>2.15.3</version>
			<fixedVersion>2.16.0, 2.15.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.dozer.DozerThreadContextClassLoader.java</file>
			<file type="M">org.apache.camel.converter.dozer.DozerTypeConverterLoader.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">9545</link>
			<link type="Reference" description="is related to">8689</link>
		</links>
	</bug>
	<bug id="9094" opendate="2015-08-20 20:29:40" fixdate="2015-09-13 15:41:03" resolution="Fixed">
		<buginformation>
			<summary>Can&amp;apos;t use custom FTPParser on OSGI</summary>
			<description>Using a custom ftp entry parser on OSGI results in an exception because of the use of Class.forName in commons-net DefaultFTPFileEntryParserFactory :


org.apache.commons.net.ftp.parser.ParserInitializationException: Unknown parser type: com.example.CustomFTPEntryParser
 
        at org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory.createFileEntryParser(DefaultFTPFileEntryParserFactory.java:166)[commons-net:commons-net:3.3]
        at org.apache.commons.net.ftp.parser.DefaultFTPFileEntryParserFactory.createFileEntryParser(DefaultFTPFileEntryParserFactory.java:202)[commons-net:commons-net:3.3]
        at org.apache.commons.net.ftp.FTPClient.initiateListParsing(FTPClient.java:3246)[commons-net:commons-net:3.3]
        at org.apache.commons.net.ftp.FTPClient.listFiles(FTPClient.java:2930)[commons-net:commons-net:3.3]
        at org.apache.commons.net.ftp.FTPClient.listFiles(FTPClient.java:2977)[commons-net:commons-net:3.3]
        at org.apache.camel.component.file.remote.FtpOperations.listFiles(FtpOperations.java:779)[org.apache.camel:camel-ftp:2.12.0.redhat-611433]
        at org.apache.camel.component.file.remote.FtpConsumer.doPollDirectory(FtpConsumer.java:91)[org.apache.camel:camel-ftp:2.12.0.redhat-611433]
        at org.apache.camel.component.file.remote.FtpConsumer.pollDirectory(FtpConsumer.java:53)[org.apache.camel:camel-ftp:2.12.0.redhat-611433]
        at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:117)[org.apache.camel:camel-core:2.12.0.redhat-611433 com.googlecode.concurrentlinkedhashmap:concurrentlinkedhashmap-lru:1.4]
        at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:187)[org.apache.camel:camel-core:2.12.0.redhat-611433 com.googlecode.concurrentlinkedhashmap:concurrentlinkedhashmap-lru:1.4]
        at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:114)[org.apache.camel:camel-core:2.12.0.redhat-611433 com.googlecode.concurrentlinkedhashmap:concurrentlinkedhashmap-lru:1.4]
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)[:1.7.0_10]
        at java.util.concurrent.FutureTask$Sync.innerRunAndReset(FutureTask.java:351)[:1.7.0_10]
        at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:178)[:1.7.0_10]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:178)[:1.7.0_10]
        at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)[:1.7.0_10]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1110)[:1.7.0_10]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:603)[:1.7.0_10]
        at java.lang.Thread.run(Thread.java:722)[:1.7.0_10]


Camel can work around this by creating a ParserFactory that is used if Camel is being used in an OSGI environment that simply extends the DefaultFTPFileEntryParserFactory and uses the Camel class resolver rather than Class.forName.</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="9139" opendate="2015-09-15 09:13:33" fixdate="2015-09-15 19:17:08" resolution="Fixed">
		<buginformation>
			<summary>Reading parameter not configurable via header in camel-facebook</summary>
			<description>The reading parameter in camel-facebook can not be configured via an exchange header as described in the documentation:
The reading option can be a reference or value of type facebook4j.Reading, or can be specified using the following reading options in either the endpoint URI or exchange header with CamelFacebook. prefix.</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.facebook.data.FacebookPropertiesHelper.java</file>
			<file type="M">org.apache.camel.component.facebook.FacebookProducer.java</file>
			<file type="M">org.apache.camel.component.facebook.data.ReadingBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="9140" opendate="2015-09-15 12:34:09" fixdate="2015-09-15 19:18:36" resolution="Fixed">
		<buginformation>
			<summary>Missing configuration properties in camel-facebook</summary>
			<description>For the new request methods that were introduced with the Facebook4j 2.x version (see CAMEL-7634) some new parameter arguments are required but were not added to the endpoint configuration (e.g. pageId for getPage) and thus endpoints for this methods fail to resolve.
For example, the following does not work: facebook://getPage?pageId=6538157161
</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.facebook.config.FacebookEndpointConfiguration.java</file>
			<file type="M">org.apache.camel.component.facebook.data.FacebookMethodsType.java</file>
			<file type="M">org.apache.camel.component.facebook.data.FacebookMethodsTypeTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="8393" opendate="2015-02-23 05:27:55" fixdate="2015-09-16 13:04:57" resolution="Fixed">
		<buginformation>
			<summary>Redelivery doesn&amp;apos;t work correctly on Dynamic Routers</summary>
			<description>When redelivery occurs for dynamic routers, the properties are being kept. So if the dynamic router uses a property to store the current state such as used in example http://camel.apache.org/dynamic-router.html , then the redelivery actually ends up skipping the endpoint that caused the exception
Here is my dynamic router class

public class Router {
	public String route(Exchange exchange) {
		Boolean invoked = exchange.getProperty("invoked", Boolean.class);
		if (invoked == null) {
			exchange.setProperty("invoked", true);
			return "mock:route";
		} else
			return null;
	}
}


Here is my unit test class

@RunWith(CamelSpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = CamelSpringDelegatingTestContextLoader.class)
public class DynamicRouterTest {

	@Produce(uri = "direct:start")
	private ProducerTemplate producerTemplate;

	@EndpointInject(uri = "mock:end")
	private MockEndpoint end;

	@EndpointInject(uri = "mock:route")
	private MockEndpoint route;

	@Configuration
	public static class JavaConfig extends SingleRouteCamelConfiguration {

		@Override
		public RouteBuilder route() {
			return new SpringRouteBuilder() {

				@Override
				public void configure() throws Exception {
					this.getContext().setTracing(true);
					from("direct:start").onException(IOException.class).maximumRedeliveries(-1).end()

					.dynamicRouter().method(Router.class).to("mock:end");
				}
			};
		}

	}

	@Test
	public void test() throws InterruptedException {
		route.whenAnyExchangeReceived(new Processor() {

			@Override
			public void process(Exchange exchange) throws Exception {
				exchange.getIn().setBody("mock route");
			}
		});
		route.expectedBodiesReceived("before");
		end.expectedBodiesReceived("mock route");

		producerTemplate.sendBody("before");
		route.assertIsSatisfied();
		end.assertIsSatisfied();
	}

	@Test
	public void test_exception() throws InterruptedException {
		route.whenExchangeReceived(1, new Processor() {

			@Override
			public void process(Exchange exchange) throws Exception {
				exchange.setException(new IOException());
			}
		});
		route.whenExchangeReceived(2, new Processor() {

			@Override
			public void process(Exchange exchange) throws Exception {
				exchange.getIn().setBody("mock route");
			}
		});

                // this bit fails
		route.expectedBodiesReceived("before", "before");

		end.expectedBodiesReceived("mock route");
		producerTemplate.sendBody("before");
		route.assertIsSatisfied();
		end.assertIsSatisfied();
	}
}


The test method runs successfully but the test_exception method which tests the redelivery does not. Fails with "java.lang.AssertionError: mock://route Received message count. Expected: &amp;lt;2&amp;gt; but was: &amp;lt;1&amp;gt;" which shows that the dynamic router only called the mock:route once.
</description>
			<version>2.14.1</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.RoutingSlip.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">8587</link>
		</links>
	</bug>
	<bug id="8587" opendate="2015-04-01 14:05:17" fixdate="2015-09-16 13:56:03" resolution="Cannot Reproduce">
		<buginformation>
			<summary>Exceptions from multicast aggregators are not propagated to the global exception handler</summary>
			<description>When a multicast aggregator throws an exception, either directly or by setting the exception to the returned exchange, the exception is just logged instead of being  propagated to the global exception handler.</description>
			<version>2.15.1</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.MulticastDefinition.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">8393</link>
		</links>
	</bug>
	<bug id="9142" opendate="2015-09-16 12:19:44" fixdate="2015-09-16 14:23:08" resolution="Fixed">
		<buginformation>
			<summary>dropped support for multiple blueprint descriptors in unit tests</summary>
			<description>Looks like update CAMEL-8948 dropped support for multiple blueprint descriptors within CamelBlueprintTestSupport file within camel-test-blueprint component. The symptom is a &amp;amp;apos;java.lang.RuntimeException: InputStream cannot be null&amp;amp;apos; for unit tests that have a getBlueprintDescriptor with multiple file references, i.e. a &amp;amp;apos;+&amp;amp;apos; concatenating two or more descriptor files.</description>
			<version>2.15.3</version>
			<fixedVersion>2.16.0, 2.15.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.test.blueprint.CamelBlueprintHelper.java</file>
			<file type="M">org.apache.camel.test.blueprint.CamelBlueprintTestSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="9143" opendate="2015-09-16 15:23:31" fixdate="2015-09-17 09:41:32" resolution="Fixed">
		<buginformation>
			<summary>Producers that implement the ServicePoolAware interface cause memory leak due to JMX references</summary>
			<description>Description
Producer instances that implement the ServicePoolAware interface will leak memory if their route is stopped, with new producers being leaked every time the route is started/stopped.
Known implementations that are affected are RemoteFileProducer (ftp, sftp) and Mina2Producer.
This is due to the behaviour that the SendProcessor which when the route is stopped it shuts down it&amp;amp;apos;s `producerCache` instance.


    protected void doStop() throws Exception {
        ServiceHelper.stopServices(producerCache, producer);
    }


this in turn calls `stopAndShutdownService(pool)` which will call stop on the SharedProducerServicePool instance which is a NOOP however it also calls shutdown which effects a stop of the global pool (this stops all the registered services and then clears the pool.


    protected void doStop() throws Exception {
        // when stopping we intend to shutdown
        ServiceHelper.stopAndShutdownService(pool);
        try {
            ServiceHelper.stopAndShutdownServices(producers.values());
        } finally {
            // ensure producers are removed, and also from JMX
            for (Producer producer : producers.values()) {
                getCamelContext().removeService(producer);
            }
        }
        producers.clear();
    }


However no call to `context.removeService(Producer) is called for the entries from the pool only those singleton instances that were in the `producers` map hence the JMX `ManagedProducer` that is created when `doGetProducer` invokes 

                getCamelContext().addService(answer, false);


 is never removed. 
Since the global pool is empty when the next request to get a producer is called a new producer is created, jmx wrapper and all, whilst the old instance remains orphaned retaining any objects that pertain to that instance.
One workaround is for the producer to call 

getEndpoint().getCamelContext().removeService(this)

 in it&amp;amp;apos;s stop method, however this is fairly obscure and it would probably be better to invoke removal of the producer when it is removed from the shared pool.
Another issue of note is that when a route is shutdown that contains a SendProcessor due to the shutdown invocation on the SharedProcessorServicePool the global pool is cleared of `everything` and remains in `Stopped` state until another route starts it (although it is still accessed and used whilst in the `Stopped` state).
Impact
For general use where there is no dynamic creation or passivation of routes this issue should be minimal, however in our use case where the routes are not static, there is a certain amount of recreation of routes as customer endpoints change and there is a need to passivate idle routes this causes a considerable memory leak (via SFTP in particular).
Test Case


package org.apache.camel.component;

import com.google.common.util.concurrent.AtomicLongMap;

import org.apache.camel.CamelContext;
import org.apache.camel.Consumer;
import org.apache.camel.Endpoint;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.Producer;
import org.apache.camel.Route;
import org.apache.camel.Service;
import org.apache.camel.ServicePoolAware;
import org.apache.camel.ServiceStatus;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultComponent;
import org.apache.camel.impl.DefaultEndpoint;
import org.apache.camel.impl.DefaultProducer;
import org.apache.camel.support.LifecycleStrategySupport;
import org.apache.camel.support.ServiceSupport;
import org.apache.camel.test.junit4.CamelTestSupport;
import org.junit.Test;

import java.util.Map;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * Test memory behaviour of producers using {@link ServicePoolAware} when using JMX.
 */
public class ServicePoolAwareLeakyTest extends CamelTestSupport {

  private static final String LEAKY_SIEVE_STABLE = "leaky://sieve-stable?plugged=true";
  private static final String LEAKY_SIEVE_TRANSIENT = "leaky://sieve-transient?plugged=true";


  private static boolean isPatchApplied() {
    return Boolean.parseBoolean(System.getProperty("patchApplied", "false"));
  }

  /**
   * Component that provides leaks producers.
   */
  private static class LeakySieveComponent extends DefaultComponent {
    @Override
    protected Endpoint createEndpoint(String uri, String remaining, Map&amp;lt;String, Object&amp;gt; parameters) throws Exception {
      boolean plugged = "true".equalsIgnoreCase((String) parameters.remove("plugged"));
      return new LeakySieveEndpoint(uri, isPatchApplied() &amp;amp;&amp;amp; plugged);
    }
  }

  /**
   * Endpoint that provides leaky producers.
   */
  private static class LeakySieveEndpoint extends DefaultEndpoint {

    private final String uri;
    private final boolean plugged;

    public LeakySieveEndpoint(String uri, boolean plugged) {
      this.uri = checkNotNull(uri, "uri must not be null");
      this.plugged = plugged;
    }

    @Override
    public Producer createProducer() throws Exception {
      return new LeakySieveProducer(this, plugged);
    }

    @Override
    public Consumer createConsumer(Processor processor) throws Exception {
      throw new UnsupportedOperationException();
    }

    @Override
    public boolean isSingleton() {
      return true;
    }

    @Override
    protected String createEndpointUri() {
      return uri;
    }
  }

  /**
   * Leaky producer - implements {@link ServicePoolAware}.
   */
  private static class LeakySieveProducer extends DefaultProducer implements ServicePoolAware {

    private final boolean plugged;

    public LeakySieveProducer(Endpoint endpoint, boolean plugged) {
      super(endpoint);
      this.plugged = plugged;
    }

    @Override
    public void process(Exchange exchange) throws Exception {
      // do nothing
    }

    @Override
    protected void doStop() throws Exception {
      super.doStop();

      //noinspection ConstantConditions
      if (plugged) {
        // need to remove self from services since we are ServicePoolAware this will not be handled for us otherwise we
        // leak memory
        getEndpoint().getCamelContext().removeService(this);
      }
    }
  }

  @Override
  protected boolean useJmx() {
    // only occurs when using JMX as the GC root for the producer is through a ManagedProducer created by the
    // context.addService() invocation
    return true;
  }

  /**
   * Returns true if verification of state should be performed during the test as opposed to at the end.
   */
  public boolean isFailFast() {
    return false;
  }

  /**
   * Returns true if during fast failure we should verify that the service pool remains in the started state.
   */
  public boolean isVerifyProducerServicePoolRemainsStarted() {
    return false;
  }

  @Override
  public boolean isUseAdviceWith() {
    return true;
  }

  @Test
  public void testForMemoryLeak() throws Exception {
    registerLeakyComponent();

    final AtomicLongMap&amp;lt;String&amp;gt; references = AtomicLongMap.create();

    // track LeakySieveProducer lifecycle
    context.addLifecycleStrategy(new LifecycleStrategySupport() {
      @Override
      public void onServiceAdd(CamelContext context, Service service, Route route) {
        if (service instanceof LeakySieveProducer) {
          references.incrementAndGet(((LeakySieveProducer) service).getEndpoint().getEndpointKey());
        }
      }

      @Override
      public void onServiceRemove(CamelContext context, Service service, Route route) {
        if (service instanceof LeakySieveProducer) {
          references.decrementAndGet(((LeakySieveProducer) service).getEndpoint().getEndpointKey());
        }
      }
    });

    context.addRoutes(new RouteBuilder() {
      @Override
      public void configure() throws Exception {
        from("direct:sieve-transient")
            .id("sieve-transient")
            .to(LEAKY_SIEVE_TRANSIENT);

        from("direct:sieve-stable")
            .id("sieve-stable")
            .to(LEAKY_SIEVE_STABLE);
      }
    });

    context.start();

    for (int i = 0; i &amp;lt; 1000; i++) {
      ServiceSupport service = (ServiceSupport) context.getProducerServicePool();
      assertEquals(ServiceStatus.Started, service.getStatus());
      if (isFailFast()) {
        assertEquals(2, context.getProducerServicePool().size());
        assertEquals(1, references.get(LEAKY_SIEVE_TRANSIENT));
        assertEquals(1, references.get(LEAKY_SIEVE_STABLE));
      }

      context.stopRoute("sieve-transient");

      if (isFailFast()) {
        assertEquals("Expected no service references to remain", 0, references.get(LEAKY_SIEVE_TRANSIENT));
      }

      if (isFailFast()) {
        // looks like we cleared more than just our route, we&amp;amp;apos;ve stopped and cleared the global ProducerServicePool
        // since SendProcessor.stop() invokes ServiceHelper.stopServices(producerCache, producer); which in turn invokes
        // ServiceHelper.stopAndShutdownService(pool);.
        //
        // Whilst stop on the SharedProducerServicePool is a NOOP shutdown is not and effects a stop of the pool.

        if (isVerifyProducerServicePoolRemainsStarted()) {
         assertEquals(ServiceStatus.Started, service.getStatus());
        }
        assertEquals("Expected one stable producer to remain pooled", 1, context.getProducerServicePool().size());
        assertEquals("Expected one stable producer to remain as service", 1, references.get(LEAKY_SIEVE_STABLE));
      }

      // Send a body to verify behaviour of send producer after another route has been stopped
      sendBody("direct:sieve-stable", "");

      if (isFailFast()) {
        // shared pool is used despite being &amp;amp;apos;Stopped&amp;amp;apos;
        if (isVerifyProducerServicePoolRemainsStarted()) {
          assertEquals(ServiceStatus.Started, service.getStatus());
        }

        assertEquals("Expected only stable producer in pool", 1, context.getProducerServicePool().size());
        assertEquals("Expected no references to transient producer", 0, references.get(LEAKY_SIEVE_TRANSIENT));
        assertEquals("Expected reference to stable producer", 1, references.get(LEAKY_SIEVE_STABLE));
      }

      context.startRoute("sieve-transient");

      // ok, back to normal
      assertEquals(ServiceStatus.Started, service.getStatus());
      if (isFailFast()) {
        assertEquals("Expected both producers in pool", 2, context.getProducerServicePool().size());
        assertEquals("Expected one transient producer as service", 1, references.get(LEAKY_SIEVE_TRANSIENT));
        assertEquals("Expected one stable producer as service", 1, references.get(LEAKY_SIEVE_STABLE));
      }
    }

    if (!isFailFast()) {
      assertEquals("Expected both producers in pool", 2, context.getProducerServicePool().size());

      // if not fixed these will equal the number of iterations in the loop + 1
      assertEquals("Expected one transient producer as service", 1, references.get(LEAKY_SIEVE_TRANSIENT));
      assertEquals("Expected one stable producer as service", 1, references.get(LEAKY_SIEVE_STABLE));
    }
  }

  private void registerLeakyComponent() {
    // register leaky component
    context.addComponent("leaky", new LeakySieveComponent());
  }
}

</description>
			<version>2.14.1</version>
			<fixedVersion>2.16.0, 2.14.4, 2.15.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.issues.ServicePoolAwareLeakyTest.java</file>
			<file type="M">org.apache.camel.impl.ProducerCache.java</file>
		</fixedFiles>
	</bug>
	<bug id="8898" opendate="2015-06-24 13:34:53" fixdate="2015-09-18 07:51:33" resolution="Fixed">
		<buginformation>
			<summary>ElementNotFoundException on LinkedIn authentication</summary>
			<description>

Caused by: com.gargoylesoftware.htmlunit.ElementNotFoundException: elementName=[form] attributeName=[name] attributeValue=[oauth2SAuthorizeForm]
	at com.gargoylesoftware.htmlunit.html.HtmlPage.getFormByName(HtmlPage.java:669)
	at org.apache.camel.component.linkedin.api.LinkedInOAuthRequestFilter.getRefreshToken(LinkedInOAuthRequestFilter.java:169)
	at org.apache.camel.component.linkedin.api.LinkedInOAuthRequestFilter.updateOAuthToken(LinkedInOAuthRequestFilter.java:279)
	at org.apache.camel.component.linkedin.api.LinkedInOAuthRequestFilter.filter(LinkedInOAuthRequestFilter.java:240)
	at org.apache.cxf.jaxrs.client.spec.ClientRequestFilterInterceptor.handleMessage(ClientRequestFilterInterceptor.java:60)


To reproduce:
1. add your credentials to src/test/resources/test-options.properties
2. run [camel-linkedin-component]$ mvn clean install -P linkedin-test</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0, 2.15.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.linkedin.api.LinkedInOAuthRequestFilter.java</file>
			<file type="M">org.apache.camel.component.linkedin.api.OAuthScope.java</file>
		</fixedFiles>
	</bug>
	<bug id="9150" opendate="2015-09-22 06:52:29" fixdate="2015-09-22 08:28:07" resolution="Fixed">
		<buginformation>
			<summary>Seda suspend/resume should not trigger start/stop logic</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Suspend-Resume-Routes-Unreliable-tp5771723.html
The doResume method is calling doStart which may setup tasks. </description>
			<version>2.15.3</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.RouteSedaSuspendResumeTest.java</file>
			<file type="M">org.apache.camel.component.routebox.seda.RouteboxSedaConsumer.java</file>
			<file type="M">org.apache.camel.component.kestrel.KestrelConsumer.java</file>
			<file type="M">org.apache.camel.component.disruptor.DisruptorConsumer.java</file>
			<file type="M">org.apache.camel.component.routebox.direct.RouteboxDirectConsumer.java</file>
			<file type="M">org.apache.camel.spi.ShutdownPrepared.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContextSuspendResumeRouteStartupOrderTest.java</file>
			<file type="M">org.apache.camel.component.seda.SedaConsumer.java</file>
			<file type="M">org.apache.camel.processor.aggregate.AggregateProcessor.java</file>
			<file type="M">org.apache.camel.impl.ScheduledBatchPollingConsumer.java</file>
			<file type="M">org.apache.camel.component.direct.DirectConsumer.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContextSuspendResumeRouteTest.java</file>
			<file type="M">org.apache.camel.impl.TwoRouteSuspendResumeTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultShutdownStrategy.java</file>
			<file type="M">org.apache.camel.processor.RedeliveryErrorHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="9151" opendate="2015-09-22 08:43:44" fixdate="2015-09-22 09:23:26" resolution="Fixed">
		<buginformation>
			<summary>Wrong statistics for subroutes</summary>
			<description>Some statistics seem to be wrong for subroutes.
MetricsStatistics.onExchangeDone method is called several times for a same exchange: first by the subroute and then by its parent route.
The problem is that context.stop() is called several times so counters is greater than 1 for the subroute instead of one.
A solution could be to reset the context into the exchange as soon as the stop method has been called:
MetricsRoutePolicy.java

private static final class MetricsStatistics {
        private final Timer responses;

        private MetricsStatistics(Timer responses) {
            this.responses = responses;
        }

        public void onExchangeBegin(Exchange exchange) {
            Timer.Context context = responses.time();
            exchange.setProperty("MetricsRoutePolicy", context);
        }

        public void onExchangeDone(Exchange exchange) {
            Timer.Context context = exchange.getProperty("MetricsRoutePolicy", Timer.Context.class);
            if (context != null) {
                context.stop();
                // BUGFIX: reset to null so that context.stop() cannot be called
                // more than once.
                exchange.setProperty("MetricsRoutePolicy", null);

            }
        }
    }

</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0, 2.15.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.metrics.routepolicy.MetricsRoutePolicy.java</file>
		</fixedFiles>
	</bug>
	<bug id="9159" opendate="2015-09-24 11:29:30" fixdate="2015-09-24 11:55:43" resolution="Fixed">
		<buginformation>
			<summary>wireTap("log: ...") leads to script engine error</summary>
			<description>For 


        // do something in camel that is transactional
        CamelContext camelctx = new DefaultCamelContext();
        camelctx.addRoutes(new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from("direct:start")
                .wireTap("log:org.wildfly.camel.test.jpa?level=WARN")
                .to("sql:update Account set balance = :#${body} where id = 3?dataSource=java:jboss/datasources/ExampleDS");
            }
        });


we get


Caused by: java.lang.IllegalArgumentException: No script engine could be created for: log
	at org.apache.camel.builder.script.ScriptBuilder.createScriptEngine(ScriptBuilder.java:334)
	at org.apache.camel.builder.script.ScriptBuilder.&amp;lt;init&amp;gt;(ScriptBuilder.java:111)
	at org.apache.camel.builder.script.ScriptBuilder.&amp;lt;init&amp;gt;(ScriptBuilder.java:90)
	at org.apache.camel.builder.script.ScriptLanguage.createExpression(ScriptLanguage.java:40)
	at org.apache.camel.model.ToDynamicDefinition.createExpression(ToDynamicDefinition.java:95)
	at org.apache.camel.model.ToDynamicDefinition.createProcessor(ToDynamicDefinition.java:70)
	at org.apache.camel.model.WireTapDefinition.createProcessor(WireTapDefinition.java:80)
	at org.apache.camel.model.ProcessorDefinition.makeProcessorImpl(ProcessorDefinition.java:534)
	at org.apache.camel.model.ProcessorDefinition.makeProcessor(ProcessorDefinition.java:495)
	at org.apache.camel.model.ProcessorDefinition.addRoutes(ProcessorDefinition.java:219)
	at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:1069)


CrossRef: https://github.com/wildfly-extras/wildfly-camel/issues/882</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ToDynamicDefinition.java</file>
			<file type="M">org.apache.camel.builder.script.ScriptBuilder.java</file>
			<file type="M">org.apache.camel.builder.script.ScriptLanguageResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="9164" opendate="2015-09-25 06:24:36" fixdate="2015-09-25 14:28:52" resolution="Fixed">
		<buginformation>
			<summary>errorHandlerRef causes NoSuchBeanException on uninstall</summary>
			<description>Specifying an errorHandlerRef on a route causes following WARN on uninstall


2015-09-25 06:16:45,058 | WARN  | l Console Thread | faultManagementLifecycleStrategy | 58 - org.apache.camel.camel-core - 2.16.0.SNAPSHOT | Could not unregister error handler: org.apache.camel.management.mbean.ManagedErrorHandler@27181de1 as ErrorHandler MBean.
org.apache.camel.NoSuchBeanException: No bean could be found in the registry for: myErrorHandler of type: org.apache.camel.builder.ErrorHandlerBuilder
	at org.apache.camel.util.CamelContextHelper.mandatoryLookup(CamelContextHelper.java:159)
	at org.apache.camel.impl.DefaultRouteContext.mandatoryLookup(DefaultRouteContext.java:151)
	at org.apache.camel.builder.ErrorHandlerBuilderRef.lookupErrorHandlerBuilder(ErrorHandlerBuilderRef.java:137)
	at org.apache.camel.management.DefaultManagementNamingStrategy.getObjectNameForErrorHandler(DefaultManagementNamingStrategy.java:168)
	at org.apache.camel.management.ManagedManagementStrategy.getManagedObjectName(ManagedManagementStrategy.java:108)
	at org.apache.camel.management.ManagedManagementStrategy.unmanageObject(ManagedManagementStrategy.java:147)
	at org.apache.camel.management.DefaultManagementLifecycleStrategy.unmanageObject(DefaultManagementLifecycleStrategy.java:844)
	at org.apache.camel.management.DefaultManagementLifecycleStrategy.onErrorHandlerRemove(DefaultManagementLifecycleStrategy.java:641)
	at org.apache.camel.impl.RouteService.stopChildService(RouteService.java:351)
	at org.apache.camel.impl.RouteService.doStop(RouteService.java:237)
	at org.apache.camel.support.ChildServiceSupport.stop(ChildServiceSupport.java:77)
	at org.apache.camel.support.ChildServiceSupport.stop(ChildServiceSupport.java:101)
	at org.apache.camel.util.ServiceHelper.stopService(ServiceHelper.java:141)
	at org.apache.camel.util.ServiceHelper.stopAndShutdownService(ServiceHelper.java:204)
	at org.apache.camel.impl.DefaultCamelContext.shutdownServices(DefaultCamelContext.java:3017)
	at org.apache.camel.impl.DefaultCamelContext.shutdownServices(DefaultCamelContext.java:3042)
	at org.apache.camel.impl.DefaultCamelContext.shutdownServices(DefaultCamelContext.java:3030)
	at org.apache.camel.impl.DefaultCamelContext.doStop(DefaultCamelContext.java:2865)
	at org.apache.camel.support.ServiceSupport.stop(ServiceSupport.java:102)
	at org.apache.camel.blueprint.BlueprintCamelContext.destroy(BlueprintCamelContext.java:122)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)[:1.7.0_79]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)[:1.7.0_79]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)[:1.7.0_79]
	at java.lang.reflect.Method.invoke(Method.java:606)[:1.7.0_79]
	at org.apache.aries.blueprint.utils.ReflectionUtils.invoke(ReflectionUtils.java:297)
	at org.apache.aries.blueprint.container.BeanRecipe.invoke(BeanRecipe.java:958)
	at org.apache.aries.blueprint.container.BeanRecipe.destroy(BeanRecipe.java:863)
	at org.apache.aries.blueprint.container.BlueprintRepository.destroy(BlueprintRepository.java:320)
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.destroyComponents(BlueprintContainerImpl.java:723)
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.tidyupComponents(BlueprintContainerImpl.java:917)
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.destroy(BlueprintContainerImpl.java:867)
	at org.apache.aries.blueprint.container.BlueprintExtender$3.run(BlueprintExtender.java:319)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)[:1.7.0_79]
	at java.util.concurrent.FutureTask.run(FutureTask.java:262)[:1.7.0_79]
	at org.apache.aries.blueprint.container.BlueprintExtender.destroyContainer(BlueprintExtender.java:340)
	at org.apache.aries.blueprint.container.BlueprintExtender.modifiedBundle(BlueprintExtender.java:236)
	at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$Tracked.customizerModified(BundleHookBundleTracker.java:500)
	at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$Tracked.customizerModified(BundleHookBundleTracker.java:433)
	at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$AbstractTracked.track(BundleHookBundleTracker.java:725)
	at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$Tracked.bundleChanged(BundleHookBundleTracker.java:463)
	at org.apache.aries.util.tracker.hook.BundleHookBundleTracker$BundleEventHook.event(BundleHookBundleTracker.java:422)
	at org.apache.felix.framework.util.SecureAction.invokeBundleEventHook(SecureAction.java:1127)
	at org.apache.felix.framework.util.EventDispatcher.createWhitelistFromHooks(EventDispatcher.java:696)
	at org.apache.felix.framework.util.EventDispatcher.fireBundleEvent(EventDispatcher.java:484)
	at org.apache.felix.framework.Felix.fireBundleEvent(Felix.java:4429)
	at org.apache.felix.framework.Felix.stopBundle(Felix.java:2528)
	at org.apache.felix.framework.Felix.uninstallBundle(Felix.java:2640)
	at org.apache.felix.framework.BundleImpl.uninstall(BundleImpl.java:1043)
	at org.apache.karaf.shell.osgi.UninstallBundle.doExecute(UninstallBundle.java:34)
	at org.apache.karaf.shell.osgi.BundlesCommand.doExecute(BundlesCommand.java:37)
	at org.apache.karaf.shell.console.OsgiCommandSupport.execute(OsgiCommandSupport.java:38)
	at org.apache.felix.gogo.commands.basic.AbstractCommand.execute(AbstractCommand.java:35)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)[:1.7.0_79]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)[:1.7.0_79]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)[:1.7.0_79]
	at java.lang.reflect.Method.invoke(Method.java:606)[:1.7.0_79]
	at org.apache.aries.proxy.impl.ProxyHandler$1.invoke(ProxyHandler.java:54)[11:org.apache.aries.proxy.impl:1.0.4]
	at org.apache.aries.proxy.impl.ProxyHandler.invoke(ProxyHandler.java:119)[11:org.apache.aries.proxy.impl:1.0.4]
	at org.apache.karaf.shell.console.commands.$BlueprintCommand2105444579.execute(Unknown Source)[17:org.apache.karaf.shell.console:2.4.2]
	at org.apache.felix.gogo.runtime.CommandProxy.execute(CommandProxy.java:78)[17:org.apache.karaf.shell.console:2.4.2]
	at org.apache.felix.gogo.runtime.Closure.executeCmd(Closure.java:477)[17:org.apache.karaf.shell.console:2.4.2]
	at org.apache.felix.gogo.runtime.Closure.executeStatement(Closure.java:403)[17:org.apache.karaf.shell.console:2.4.2]
	at org.apache.felix.gogo.runtime.Pipe.run(Pipe.java:108)[17:org.apache.karaf.shell.console:2.4.2]
	at org.apache.felix.gogo.runtime.Closure.execute(Closure.java:183)[17:org.apache.karaf.shell.console:2.4.2]
	at org.apache.felix.gogo.runtime.Closure.execute(Closure.java:120)[17:org.apache.karaf.shell.console:2.4.2]
	at org.apache.felix.gogo.runtime.CommandSessionImpl.execute(CommandSessionImpl.java:92)[17:org.apache.karaf.shell.console:2.4.2]
	at org.apache.karaf.shell.console.jline.Console.run(Console.java:195)[17:org.apache.karaf.shell.console:2.4.2]
	at java.lang.Thread.run(Thread.java:745)[:1.7.0_79]

</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.DefaultManagementNamingStrategy.java</file>
			<file type="M">org.apache.camel.builder.ErrorHandlerBuilderRef.java</file>
		</fixedFiles>
	</bug>
	<bug id="9166" opendate="2015-09-25 10:23:20" fixdate="2015-09-25 14:52:08" resolution="Fixed">
		<buginformation>
			<summary>Some functionality broken in Camel-8857</summary>
			<description>Changes in Camel-8857 cause properties prefixing to not work for Camel context ID. See notes in https://github.com/apache/camel/commit/aa59cec696c46d4f9398ae91410998bd40fabbaa.
Also, backward compatibility to 2.12.0 is removed. See note in https://github.com/apache/camel/commit/c1b33e990ae5da7ca1e0268e79acc728393fd3ae.
Camel-8857 also had ABI changes that break existing bundles (requires rebuilding them all).</description>
			<version>2.15.3</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">tooling.archetypes.camel-archetype-scr.src.main.resources.archetype-resources.src.main.java.internal.__className__Route.java</file>
			<file type="M">org.apache.camel.scr.AbstractCamelRunner.java</file>
		</fixedFiles>
	</bug>
	<bug id="9112" opendate="2015-09-03 09:27:14" fixdate="2015-09-26 08:35:46" resolution="Fixed">
		<buginformation>
			<summary>Problem upgrading to Camel 2.14.3 in Karaf 3.0.4</summary>
			<description>I am trying to upgrade to Camel 2.14.3 from 2.14.1. We are using Karaf 3.0.4 as server. 
There is a problem with this, which can be reproduced this way: 

Make a clean Karaf 3.0.4 installation


Start Karaf and install features:

   feature:repo-add camel 2.14.3 
   feature:install camel 
   feature:install camel-script 

Stop Karaf and start it again.

Now there is a warning and stacktrace in the Karaf logfile, as seen below. 
I also tried to additionally install camel-script-jruby and camel-ruby but this didn&amp;amp;apos;t help 
This warning and stacktrace is not present when using Camel 2.14.1 !! 
--------------------------------------------------------------------- 
2015-09-01 09:49:01,277 | WARN  | FelixStartLevel  | Activator                        | 94 - org.apache.camel.camel-script - 2.14.3 | Cannot create the ScriptEngineFactory: java.lang.IllegalStateException 
java.lang.IllegalStateException: Invalid ScriptEngineFactory: org.jruby.embed.jsr223.JRubyEngineFactory 
        at org.apache.camel.script.osgi.Activator$BundleScriptEngineResolver.getFactory(Activator.java:231)[94:org.apache.camel.camel-script:2.14.3] 
        at org.apache.camel.script.osgi.Activator$BundleScriptEngineResolver.getScriptNames(Activator.java:210)[94:org.apache.camel.camel-script:2.14.3] 
        at org.apache.camel.script.osgi.Activator$BundleScriptEngineResolver.access$000(Activator.java:191)[94:org.apache.camel.camel-script:2.14.3] 
        at org.apache.camel.script.osgi.Activator.getAvailableScriptNames(Activator.java:118)[94:org.apache.camel.camel-script:2.14.3] 
        at org.apache.camel.script.osgi.Activator.updateAvailableScriptLanguages(Activator.java:138)[94:org.apache.camel.camel-script:2.14.3] 
        at org.apache.camel.script.osgi.Activator.serviceChanged(Activator.java:184)[94:org.apache.camel.camel-script:2.14.3] 
        at org.apache.felix.framework.util.EventDispatcher.invokeServiceListenerCallback(EventDispatcher.java:932)[org.apache.felix.framework-4.2.1.jar:] 
        at org.apache.felix.framework.util.EventDispatcher.fireEventImmediately(EventDispatcher.java:793)[org.apache.felix.framework-4.2.1.jar:] 
        at org.apache.felix.framework.util.EventDispatcher.fireServiceEvent(EventDispatcher.java:543)[org.apache.felix.framework-4.2.1.jar:] 
        at org.apache.felix.framework.Felix.fireServiceEvent(Felix.java:4419)[org.apache.felix.framework-4.2.1.jar:] 
        at org.apache.felix.framework.Felix.registerService(Felix.java:3423)[org.apache.felix.framework-4.2.1.jar:] 
        at org.apache.felix.framework.BundleContextImpl.registerService(BundleContextImpl.java:346)[org.apache.felix.framework-4.2.1.jar:] 
        at org.apache.felix.framework.BundleContextImpl.registerService(BundleContextImpl.java:320)[org.apache.felix.framework-4.2.1.jar:] 
        at org.apache.camel.impl.osgi.Activator$BaseService.doRegister(Activator.java:456)[70:org.apache.camel.camel-core:2.14.3] 
        at org.apache.camel.impl.osgi.Activator$BaseService.doRegister(Activator.java:448)[70:org.apache.camel.camel-core:2.14.3] 
        at org.apache.camel.impl.osgi.Activator$BundleMetaLanguageResolver.register(Activator.java:238)[70:org.apache.camel.camel-core:2.14.3] 
        at org.apache.camel.impl.osgi.Activator.addingBundle(Activator.java:104)[70:org.apache.camel.camel-core:2.14.3] 
        at org.apache.camel.impl.osgi.tracker.BundleTracker$Tracked.customizerAdding(BundleTracker.java:431)[70:org.apache.camel.camel-core:2.14.3] 
        at org.apache.camel.impl.osgi.tracker.AbstractTracked.trackAdding(AbstractTracked.java:261)[70:org.apache.camel.camel-core:2.14.3] 
        at org.apache.camel.impl.osgi.tracker.AbstractTracked.track(AbstractTracked.java:234)[70:org.apache.camel.camel-core:2.14.3] 
        at org.apache.camel.impl.osgi.tracker.BundleTracker$Tracked.bundleChanged(BundleTracker.java:407)[70:org.apache.camel.camel-core:2.14.3] 
        at org.apache.felix.framework.util.EventDispatcher.invokeBundleListenerCallback(EventDispatcher.java:868)[org.apache.felix.framework-4.2.1.jar:] 
        at org.apache.felix.framework.util.EventDispatcher.fireEventImmediately(EventDispatcher.java:789)[org.apache.felix.framework-4.2.1.jar:] 
        at org.apache.felix.framework.util.EventDispatcher.fireBundleEvent(EventDispatcher.java:514)[org.apache.felix.framework-4.2.1.jar:] 
        at org.apache.felix.framework.Felix.fireBundleEvent(Felix.java:4403)[org.apache.felix.framework-4.2.1.jar:] 
        at org.apache.felix.framework.Felix.startBundle(Felix.java:2092)[org.apache.felix.framework-4.2.1.jar:] 
        at org.apache.felix.framework.Felix.setActiveStartLevel(Felix.java:1291)[org.apache.felix.framework-4.2.1.jar:] 
        at org.apache.felix.framework.FrameworkStartLevelImpl.run(FrameworkStartLevelImpl.java:304)[org.apache.felix.framework-4.2.1.jar:] 
        at java.lang.Thread.run(Thread.java:744)[:1.7.0_51] </description>
			<version>2.14.3</version>
			<fixedVersion>2.16.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.script.osgi.Activator.java</file>
			<file type="M">org.apache.camel.builder.script.ScriptLanguageResolver.java</file>
			<file type="M">org.apache.camel.itest.karaf.AbstractFeatureTest.java</file>
			<file type="M">org.apache.camel.itest.karaf.CamelScriptTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9177" opendate="2015-09-28 06:40:32" fixdate="2015-09-29 06:16:49" resolution="Fixed">
		<buginformation>
			<summary>combination of JPA-Component, loop and wiretap throws entitymanger cloesd exception</summary>
			<description>Hi,
I have found a problem regarding a wiretap and the camel-jpa component. I have a route with an async split through a wiretap. In each route, I use a jpa producer to persist an entity. The problem is, that the entitymanager was closed before the async routes can reach the end. The cause is, that the same entitymanager is used in the async routes. The main route reaches the end and closes the entitymanager.
E.g. like the following route:


&amp;lt;route id="mainRoute&amp;gt;
    &amp;lt;from uri="direct:restendpoint"/&amp;gt;
    ...
    &amp;lt;to uri="jpa:MyEntity"/&amp;gt;
    ...
    &amp;lt;loop copy="true"&amp;gt;
        ...
        &amp;lt;wireTap uri="direct:asyncroute"/&amp;gt;
    &amp;lt;/loop&amp;gt;
&amp;lt;/route&amp;gt;

&amp;lt;route id="asyncRoute"&amp;gt;
    &amp;lt;from uri="direct:asyncroute"/&amp;gt;
    ...
    &amp;lt;to uri="jpa:MyEntity"/&amp;gt;
    ...
&amp;lt;/route&amp;gt;


I think a possible fix can be to check that the entitymanager is null or closed. If null or closed, create a new entitymanager.


public final class JpaHelper {
    ...
    public static EntityManager getTargetEntityManager(Exchange exchange, ...
        ...
        if (em == null || !em.isOpen()) {
            // create a new entity manager
            em = entityManagerFactory.createEntityManager();
        ...
        }
    }
    ...
}


Another solution can be in the wiretap. There where the exchange is copied, the "CamelEntityManager" property could be removed.
Currently, my quickfix is: At the beginning of the async route I remove the entitymanager from the exchange.</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.0, 2.15.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jpa.JpaProducer.java</file>
			<file type="M">org.apache.camel.processor.idempotent.jpa.JpaMessageIdRepository.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaHelper.java</file>
			<file type="M">org.apache.camel.component.jpa.JpaCloseEntityManagerOnCompletion.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="is depended upon by">8388</link>
		</links>
	</bug>
	<bug id="9144" opendate="2015-09-17 09:21:36" fixdate="2015-10-03 07:47:52" resolution="Fixed">
		<buginformation>
			<summary>Regression with camel-jackson 2.15.3</summary>
			<description>Hi folks,
Apparently we found a regression with camel and camel-jackson in version 2.15.3.
The following code : 
restConfiguration()
                .component("servlet")
                .bindingMode(RestBindingMode.json)
                .contextPath("/adm-replication")
                .port("8181");
        rest("/replication")
                .post("/
{cus}/{contractDate}")
                .produces("application/json")
                .consumes("application/json")
                .to("mock:TestRoute");

produces the following exception by looking for the default json dataformat : 

org.apache.camel.FailedToCreateRouteException: Failed to create route route1 at: &amp;gt;&amp;gt;&amp;gt; RestBinding &amp;lt;&amp;lt;&amp;lt; in route: Route(route1)[[From[rest:post:/replication:/{cus}
/{contractD... because of JSon DataFormat json-jackson not found.
    at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:1028)
    at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:185)
    at org.apache.camel.impl.DefaultCamelContext.startRoute(DefaultCamelContext.java:841)
    at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:2911)
    at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:2634)
    at org.apache.camel.impl.DefaultCamelContext.access$000(DefaultCamelContext.java:167)
    at org.apache.camel.impl.DefaultCamelContext$2.call(DefaultCamelContext.java:2483)
    at org.apache.camel.impl.DefaultCamelContext$2.call(DefaultCamelContext.java:2479)
    at org.apache.camel.impl.DefaultCamelContext.doWithDefinedClassLoader(DefaultCamelContext.java:2502)
    at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:2479)
    at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:61)
    at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:2448)
    at org.apache.camel.blueprint.BlueprintCamelContext.start(BlueprintCamelContext.java:180)
    at org.apache.camel.test.blueprint.CamelBlueprintTestSupport.setUp(CamelBlueprintTestSupport.java:209)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
    at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)
    at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
    at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
    at org.junit.rules.RunRules.evaluate(RunRules.java:20)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
    at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
    at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
    at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:78)
    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:212)
    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:68)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)
Caused by: java.lang.IllegalArgumentException: JSon DataFormat json-jackson not found.
    at org.apache.camel.model.rest.RestBindingDefinition.createProcessor(RestBindingDefinition.java:114)
    at org.apache.camel.model.ProcessorDefinition.makeProcessor(ProcessorDefinition.java:505)
    at org.apache.camel.model.ProcessorDefinition.addRoutes(ProcessorDefinition.java:217)
    at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:1025)
    ... 43 more
This exception doesn&amp;amp;apos;t occur in 2.15.2</description>
			<version>2.15.3</version>
			<fixedVersion>2.15.4, 2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.osgi.Activator.java</file>
		</fixedFiles>
		<links>
			<link type="Regression" description="is broken by">9048</link>
		</links>
	</bug>
	<bug id="9191" opendate="2015-10-05 21:28:59" fixdate="2015-10-07 05:44:23" resolution="Fixed">
		<buginformation>
			<summary>camel-example-spring-jms ServerRoutes contains invalid URI parameter methodName</summary>
			<description>The camel-example-spring-jms org.apache.camel.example.server.ServerRoutes contains an invalid URI parameter methodName (see exception below).
Fix - change &amp;amp;apos;methodName&amp;amp;apos; to &amp;amp;apos;method&amp;amp;apos; as below
//from("jms:queue:numbers").to("bean:multiplier?methodName=multiply");
  from("jms:queue:numbers").to("bean:multiplier?method=multiply");
Tests run: 2, Failures: 0, Errors: 2, Skipped: 0, Time elapsed: 2.031 sec &amp;lt;&amp;lt;&amp;lt; FAILURE! - in org.apache.camel.example.SpringJmsClientRemotingServerTest
org.apache.camel.example.SpringJmsClientRemotingServerTest  Time elapsed: 2.03 sec  &amp;lt;&amp;lt;&amp;lt; ERROR!
org.apache.camel.RuntimeCamelException: org.apache.camel.FailedToCreateRouteException: Failed to create route route1 at: &amp;gt;&amp;gt;&amp;gt; To[bean:multiplier?methodName=multiply] &amp;lt;&amp;lt;&amp;lt; in route: Route(route1)[[From[jms:queue:numbers]] -&amp;gt; [To[bean:multipli... because of Failed to resolve endpoint: bean://multiplier?methodName=multiply due to: Failed to resolve endpoint: bean://multiplier?methodName=multiply due to: There are 1 parameters that couldn&amp;amp;apos;t be set on the endpoint. Check the uri if the parameters are spelt correctly and that they are properties of the endpoint. Unknown parameters=[
{methodName=multiply}
]
	at org.apache.camel.impl.DefaultComponent.validateParameters(DefaultComponent.java:183)
	at org.apache.camel.impl.DefaultComponent.createEndpoint(DefaultComponent.java:128)
	at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:558)
	at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:79)
	at org.apache.camel.model.RouteDefinition.resolveEndpoint(RouteDefinition.java:200)
	at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:107)
	at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:113)
	at org.apache.camel.model.SendDefinition.resolveEndpoint(SendDefinition.java:62)
	at org.apache.camel.model.SendDefinition.createProcessor(SendDefinition.java:56)
	at org.apache.camel.model.ProcessorDefinition.makeProcessor(ProcessorDefinition.java:505)
	at org.apache.camel.model.ProcessorDefinition.addRoutes(ProcessorDefinition.java:217)
	at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:1025)
	at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:185)
	at org.apache.camel.impl.DefaultCamelContext.startRoute(DefaultCamelContext.java:841)
	at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:2895)
	at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:2618)
	at org.apache.camel.impl.DefaultCamelContext.access$000(DefaultCamelContext.java:167)
	at org.apache.camel.impl.DefaultCamelContext$2.call(DefaultCamelContext.java:2467)
	at org.apache.camel.impl.DefaultCamelContext$2.call(DefaultCamelContext.java:2463)
	at org.apache.camel.impl.DefaultCamelContext.doWithDefinedClassLoader(DefaultCamelContext.java:2486)
	at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:2463)
	at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:61)
	at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:2432)
	at org.apache.camel.spring.SpringCamelContext.maybeStart(SpringCamelContext.java:255)
	at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:121)
	at org.apache.camel.spring.CamelContextFactoryBean.onApplicationEvent(CamelContextFactoryBean.java:332)
	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:151)
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:128)
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:331)
	at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:773)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:483)
	at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:139)
	at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:93)
	at org.apache.camel.example.SpringJmsClientRemotingServerTest.setupFreePort(SpringJmsClientRemotingServerTest.java:46)
org.apache.camel.example.SpringJmsClientRemotingServerTest  Time elapsed: 2.031 sec  &amp;lt;&amp;lt;&amp;lt; ERROR!
java.lang.NullPointerException: null
	at org.apache.camel.example.SpringJmsClientRemotingServerTest.stopSpring(SpringJmsClientRemotingServerTest.java:52)</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.4, 2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.example.server.ServerRoutes.java</file>
		</fixedFiles>
	</bug>
	<bug id="9195" opendate="2015-10-06 14:41:26" fixdate="2015-10-08 03:35:29" resolution="Fixed">
		<buginformation>
			<summary>Memory leak in UndertowProducer</summary>
			<description>The UndertowProducer class leaks memory over time due to the repeated creation of ByteBufferSlicePool for each HTTP client request. My understanding of this class is that instances of it should be limited and cached if possible.
Here&amp;amp;apos;s an example RouteBuilder to replicate the issue. In a short time it will result in an OutOfMemoryError.  


public class UndertowRouteBuilder extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        from("undertow:http://localhost:8080/test").to("log:undertow?showAll=true");

    	from("timer:foo?period=5000").transform(constant("hello world")).to("undertow:http://localhost:8080/test");
    }
}





org.apache.camel.CamelExecutionException: Exception occurred during execution on the exchange: Exchange[ID-worklaptop-50317-1444141557043-2-30][Message: hello world]
	at org.apache.camel.util.ObjectHelper.wrapCamelExecutionException(ObjectHelper.java:1658)
	at org.apache.camel.impl.DefaultExchange.setException(DefaultExchange.java:345)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:156)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:77)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:460)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:190)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:121)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:83)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:190)
	at org.apache.camel.component.timer.TimerConsumer.sendTimerExchange(TimerConsumer.java:165)
	at org.apache.camel.component.timer.TimerConsumer$1.run(TimerConsumer.java:73)
	at java.util.TimerThread.mainLoop(Timer.java:555)
	at java.util.TimerThread.run(Timer.java:505)
Caused by: java.lang.OutOfMemoryError: Direct buffer memory
	at java.nio.Bits.reserveMemory(Bits.java:658)
	at java.nio.DirectByteBuffer.&amp;lt;init&amp;gt;(DirectByteBuffer.java:123)
	at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)
	at org.xnio.BufferAllocator$2.allocate(BufferAllocator.java:57)
	at org.xnio.BufferAllocator$2.allocate(BufferAllocator.java:55)
	at org.xnio.ByteBufferSlicePool.allocate(ByteBufferSlicePool.java:143)
	at io.undertow.client.http.HttpRequestConduit.processWrite(HttpRequestConduit.java:98)
	at io.undertow.client.http.HttpRequestConduit.write(HttpRequestConduit.java:460)
	at io.undertow.conduits.AbstractFixedLengthStreamSinkConduit.write(AbstractFixedLengthStreamSinkConduit.java:106)
	at org.xnio.conduits.ConduitStreamSinkChannel.write(ConduitStreamSinkChannel.java:150)
	at io.undertow.channels.DetachableStreamSinkChannel.write(DetachableStreamSinkChannel.java:240)
	at org.apache.camel.component.undertow.UndertowProducer$UndertowProducerCallback.completed(UndertowProducer.java:166)
	at org.apache.camel.component.undertow.UndertowProducer$UndertowProducerCallback.completed(UndertowProducer.java:121)
	at io.undertow.client.http.HttpClientExchange.invokeReadReadyCallback(HttpClientExchange.java:190)
	at io.undertow.client.http.HttpClientConnection.initiateRequest(HttpClientConnection.java:293)
	at io.undertow.client.http.HttpClientConnection.sendRequest(HttpClientConnection.java:228)
	at org.apache.camel.component.undertow.UndertowProducer.process(UndertowProducer.java:102)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:141)
	... 10 more

</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.undertow.UndertowProducer.java</file>
			<file type="M">org.apache.camel.component.undertow.UndertowEndpoint.java</file>
			<file type="M">org.apache.camel.component.undertow.UndertowComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="9199" opendate="2015-10-07 21:14:44" fixdate="2015-10-08 05:42:08" resolution="Fixed">
		<buginformation>
			<summary>RabbitMQ Consumer threads crash when sending partially serializable objects</summary>
			<description>The RabbitMQ consumer thread crashes when sending an object that implements Serializable but contains non Serializable objects. 
I will have PR very soon to fix this and add tests.</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQInOutIntTest.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQConsumer.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="9171" opendate="2015-09-25 15:35:33" fixdate="2015-10-08 13:06:30" resolution="Fixed">
		<buginformation>
			<summary>camel-xmpp processes no messages when running in Karaf</summary>
			<description>Camel XMPP communication is not working in version 2.15.3 when running in Karaf. The feature installation works fine but no messages are processed.
I guess this is potentially based on changing the Smack version from 3 to 4. 
Based on the existing Camel Karaf tests I created a simple test which passes with Camel Version 2.14.3 and fails with Camel Version 2.15.3. The test can be found here https://github.com/achim86/karaf-xmpp (remember to start the XMPPServer before running the test as described in the readme).</description>
			<version>2.15.3</version>
			<fixedVersion>2.15.4, 2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.xmpp.XmppEndpoint.java</file>
			<file type="M">org.apache.camel.component.xmpp.XmppBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="9208" opendate="2015-10-09 18:13:34" fixdate="2015-10-09 18:30:02" resolution="Fixed">
		<buginformation>
			<summary>camel-netty4-http does not resolve nettyHttpBinding option</summary>
			<description>camel-netty4-http does not resolve or strip out the "nettyHttpBinding" endpoint option. For example, take the following route producer:
&amp;lt;to uri="netty4-http:http://www.google.com:80?nettyHttpBinding=#myHttpBinding" /&amp;gt; 
It will issue the following HTTP GET request URI:
GET http://www.google.com:80?nettyHttpBinding=%23myHttpBinding HTTP/1.1
Assigning any of the other endpoint options, results in those options being removed from the GET request URI.</description>
			<version>2.15.3</version>
			<fixedVersion>2.15.4, 2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="9205" opendate="2015-10-09 08:00:23" fixdate="2015-10-10 08:05:19" resolution="Fixed">
		<buginformation>
			<summary>REST endpoint with CORS sends invalid header value for Access-Control-Allow-Origin</summary>
			<description>I tried enabling CORS for our camel REST endpoint and it does not really work.
The Access-Control-Allow-Origin header is sent, as it should be. Unfortunately the value of the header is "*, *" which is not accepted as correct by newer browser versions.
Firefox 41.0.1 and Chrome 45.0 both reject this header value and do not allow cross domain access. It seems newer browsers only
accept a single domain name or "*" and not a list of domains. 
See http://www.w3.org/TR/cors/#access-control-allow-origin-response-header
So please change the default behavior to send only "*".
I tried setting the header value manually:
&amp;lt;restConfiguration component="servlet" bindingMode="json" contextPath="MyService/rest" port="8080" enableCORS="true"&amp;gt;           
      &amp;lt;corsHeaders key="Access-Control-Allow-Origin" value="localhost"/&amp;gt;           
&amp;lt;/restConfiguration&amp;gt;
But this results in a header value of "*, localhost" which is also not accepted.
A workaround is to set &amp;lt;corsHeaders key="Access-Control-Allow-Origin" value=""/&amp;gt;  which results in a value of "*" for some reason.</description>
			<version>2.15.0</version>
			<fixedVersion>2.15.4, 2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.swagger.RestSwaggerSupport.java</file>
			<file type="M">org.apache.camel.swagger.servlet.ServletRestApiResponseAdapter.java</file>
			<file type="M">org.apache.camel.swagger.RestApiResponseAdapter.java</file>
			<file type="M">org.apache.camel.swagger.ExchangeRestApiResponseAdapter.java</file>
		</fixedFiles>
	</bug>
	<bug id="8431" opendate="2015-03-03 20:39:39" fixdate="2015-10-11 15:33:25" resolution="Fixed">
		<buginformation>
			<summary>Consume all files in aws S3 bucket where deleteAfterRead = false</summary>
			<description>The current AWS S3Consumer class has a problem if user supply the parameter deleteAfterRead=false.  The S3Consumer will always consume the same files over and over again with the size of getMaxMessagesPerPoll(). 
After some code chasing, i think, the root cause is because the ListObjectsRequest does not has the previous marker value. Hence, i wonder if we could do something like below:

private string marker; // new line to define the marker string 
..
..
..
ListObjectsRequest listObjectsRequest = new ListObjectsRequest();
listObjectsRequest.setBucketName(bucketName);
listObjectsRequest.setPrefix(getConfiguration().getPrefix());
listObjectsRequest.setMaxKeys(maxMessagesPerPoll);
listObjectsRequest.setMarker(marker); // new line to set the marker   
ObjectListing listObjects = getAmazonS3Client().listObjects(listObjectsRequest);
marker = listObjects.getMarker(); // where marker is track          
</description>
			<version>2.14.0</version>
			<fixedVersion>2.15.4, 2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.aws.s3.S3Consumer.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">8539</link>
			<link type="Reference" description="is related to">9784</link>
		</links>
	</bug>
	<bug id="9215" opendate="2015-10-12 08:25:19" fixdate="2015-10-12 16:48:18" resolution="Fixed">
		<buginformation>
			<summary>Missing .handled(true) in Camel 2.16.0 when using wiretap and newExchangeBody</summary>
			<description>This worked in 2.15.x: 
RoutesDefinition routeDef = someRouteDef(); 
routeDef.onException(someException) 
   .wireTap(someUri) 
   .newExchange(someProcessor) 
   .end() 
   .handled(true) 
   .bean(someBean); 
But in 2.16.0 it seems like .handled(..) isn&amp;amp;apos;t available anymore.  Any 
suggestions on how to mark this as handled now? </description>
			<version>2.16.0</version>
			<fixedVersion>2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.WireTapDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="9223" opendate="2015-10-14 15:33:33" fixdate="2015-10-14 15:58:46" resolution="Fixed">
		<buginformation>
			<summary>IllegalArgumentException when reverting fields using property placeholders</summary>
			<description>When using a route like


&amp;lt;camelContext xmlns="http://camel.apache.org/schema/spring"&amp;gt;
   &amp;lt;propertyPlaceholder id="properties" location="classpath:my.properties"
       xmlns="http://camel.apache.org/schema/spring" /&amp;gt;
   &amp;lt;route&amp;gt;
 	&amp;lt;from uri="direct:start" /&amp;gt;			
  	 &amp;lt;multicast prop:stopOnException="stop"&amp;gt;
		&amp;lt;to uri="mock:a" /&amp;gt;			
		&amp;lt;to uri="mock:b" /&amp;gt;
	&amp;lt;/multicast&amp;gt;
   &amp;lt;/route&amp;gt;
&amp;lt;/camelContext&amp;gt;


The following exception is thrown:


java.lang.IllegalArgumentException: Could not find a suitable setter for property: stopOnException as there isn&amp;amp;apos;t a setter method with same type: java.lang.String nor type conversion possible: {{stop}}
	at org.apache.camel.util.IntrospectionSupport.setProperty(IntrospectionSupport.java:561)
	at org.apache.camel.util.IntrospectionSupport.setProperty(IntrospectionSupport.java:571)
	at org.apache.camel.util.IntrospectionSupport.setProperties(IntrospectionSupport.java:454)
	at org.apache.camel.model.ProcessorDefinitionHelper$1.run(ProcessorDefinitionHelper.java:623)
	at org.apache.camel.model.ProcessorDefinitionHelper$RestoreAction.run(ProcessorDefinitionHelper.java:572)
	at org.apache.camel.model.ProcessorDefinition.makeProcessor(ProcessorDefinition.java:491)
	at org.apache.camel.model.ProcessorDefinition.addRoutes(ProcessorDefinition.java:218)
	at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:1025)
	at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:185)
	at org.apache.camel.impl.DefaultCamelContext.startRoute(DefaultCamelContext.java:841)
	at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:2895)
	at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:2618)
	at org.apache.camel.impl.DefaultCamelContext.access$000(DefaultCamelContext.java:167)
	at org.apache.camel.impl.DefaultCamelContext$2.call(DefaultCamelContext.java:2467)
	at org.apache.camel.impl.DefaultCamelContext$2.call(DefaultCamelContext.java:2463)
	at org.apache.camel.impl.DefaultCamelContext.doWithDefinedClassLoader(DefaultCamelContext.java:2486)
	at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:2463)
	at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:61)
	at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:2432)
	at org.apache.camel.spring.SpringCamelContext.maybeStart(SpringCamelContext.java:255)
	at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:121)
	at org.apache.camel.spring.CamelContextFactoryBean.onApplicationEvent(CamelContextFactoryBean.java:332)
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:96)
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:334)
	at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:950)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482)
	at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:139)
	at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:83)

</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ProcessorDefinitionHelper.java</file>
			<file type="M">org.apache.camel.util.IntrospectionSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="9220" opendate="2015-10-13 21:52:17" fixdate="2015-10-15 06:00:32" resolution="Fixed">
		<buginformation>
			<summary>swagger - Model schema not including nested objects</summary>
			<description>This issue relates to the new camel-swagger-java component and not the camel-swagger component. JIRA is not yet updated for the new camel-swagger-java component.
When there are nested objects in the Api model for swagger, they are not being represented correctly in the model schema. See below for an example:
SomeRequest.java

@ApiModel
public class SomeRequest {
    @ApiModelProperty
    private List&amp;lt;SomeObject&amp;gt; someObjects;
    ...
}


SomeObject.java

@ApiModel
public class SomeObject {
    @ApiModelProperty
    private String somePropertyOne;
    @ApiModelProperty
    private String somePropertyTwo;
    ...
}


Should have a model in swagger of:


{ 
  "someObjects": [ 
    { 
      "somePropertyOne": "", 
      "somePropertyTwo": "" 
    } 
  ] 
}


But instead has:


{ 
  "someObjects": [ 
    "SomeObject" 
  ] 
}


This model is invalid and makes the swagger documentation useless as no one knows what the request model is supposed to be.
Note: this worked correctly on camel 2.15.3 with the scala based camel-swagger component.</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.swagger.RestModelConverters.java</file>
			<file type="M">org.apache.camel.swagger.RestSwaggerReader.java</file>
		</fixedFiles>
	</bug>
	<bug id="9227" opendate="2015-10-15 10:08:25" fixdate="2015-10-17 06:50:50" resolution="Fixed">
		<buginformation>
			<summary>No type converter available to convert from Bean to List</summary>
			<description>

Tests in error: 
  CSVIntegrationTest.testMarshalViaDozer:101  CamelExecution Exception occurred...

Tests run: 3, Failures: 0, Errors: 1, Skipped: 0

Caused by: org.apache.camel.NoTypeConversionAvailableException: No type converter available to convert from type: org.wildfly.camel.test.common.types.Customer to the required type: java.util.List with value org.wildfly.camel.test.common.types.Customer@42776551
	at org.apache.camel.impl.converter.BaseTypeConverterRegistry.mandatoryConvertTo(BaseTypeConverterRegistry.java:185)
	at org.apache.camel.util.ExchangeHelper.convertToMandatoryType(ExchangeHelper.java:187)
	at org.apache.camel.dataformat.csv.CsvMarshaller.getRecordValues(CsvMarshaller.java:95)
	at org.apache.camel.dataformat.csv.CsvMarshaller.marshal(CsvMarshaller.java:82)
	at org.apache.camel.dataformat.csv.CsvDataFormat.marshal(CsvDataFormat.java:82)


</description>
			<version>2.16.1</version>
			<fixedVersion>2.16.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.dozer.model.CustomerA.java</file>
			<file type="M">org.apache.camel.converter.dozer.DozerBeanMappingTest.java</file>
			<file type="M">org.apache.camel.converter.dozer.model.CustomerB.java</file>
			<file type="M">org.apache.camel.converter.dozer.DozerTypeConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">9178</link>
		</links>
	</bug>
	<bug id="9230" opendate="2015-10-16 21:52:22" fixdate="2015-10-17 07:55:18" resolution="Fixed">
		<buginformation>
			<summary>CXFRS NPE when response code not in Response.Status</summary>
			<description>When used as a producer, the CXFRS component&amp;amp;apos;s org.apache.camel.component.cxf.jaxrs.CxfRsProducer#populateCxfRsProducerException method converts the received HTTP response status code to text:
String statusText = Response.Status.fromStatusCode(responseCode).toString();
If the JAX-RS-supplied fromStatusCode method does not recognize the status code provided, it returns null, causing the CxfRsProducer to throw an NPE. 
Note that Response.Status does not encompass all response codes. I ran afoul of this when a REST service returned a 422 for a validation error.
I will attach a unit test that illustrates this problem, as a patch to the current unit tests for the class.</description>
			<version>2.15.3</version>
			<fixedVersion>2.15.4, 2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducerTest.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.testbean.CustomerService.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9233" opendate="2015-10-17 19:22:03" fixdate="2015-10-17 19:23:21" resolution="Fixed">
		<buginformation>
			<summary>ZipFileDataFormat doesn&amp;apos;t take exchange&amp;apos;s charset into account</summary>
			<description>ZIP streams are always encoded with the default UTF-8 charset, even if in the Exchange header a different charset is set. (Exchange.CHARSET_NAME)
(Please note that this is my first bugreport and -fix for the camel project, I hope i do it right)</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.1, 2.15.5, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.zipfile.ZipFileDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="9248" opendate="2015-10-23 14:19:40" fixdate="2015-10-24 08:00:16" resolution="Fixed">
		<buginformation>
			<summary>Exception is thrown when receiving a message where JMSDestination is null</summary>
			<description>The change linked below causes camel-jms throws an exception when a message is received where JMSDestination is null (when used with WebSphere MQ). 
This works as expected in 2.15.3.
The message looks like this (anonymized)
  JMSMessage class: jms_text
  JMSType:          null
  JMSDeliveryMode:  2
  JMSExpiration:    0
  JMSPriority:      5
  JMSMessageID:     ID:c3e2d840e3d4d8d44040404040404040cfbd668a5f4f4261
  JMSTimestamp:     1445609217800
  JMSCorrelationID: null
  JMSDestination:   null
  JMSReplyTo:       queue://TEST/INPUT.QUEUE?targetClient=1
  JMSRedelivered:   false
    JMSXAppID: ilities\RFHUtil\rfhutilc.exe
    JMSXDeliveryCount: 1
    JMSXUserID: MQXPLO      
    JMS_IBM_Character_Set: IBM277
    JMS_IBM_Encoding: 785
    JMS_IBM_Format: MQSTR   
    JMS_IBM_MsgType: 8
    JMS_IBM_PutApplType: 11
    JMS_IBM_PutDate: 20151023
    JMS_IBM_PutTime: 14065780
The following is a link to the troublesome patch included in 2.16.0:
https://fisheye6.atlassian.com/browse/camel-git/components/camel-jms/src/main/java/org/apache/camel/component/jms/EndpointMessageListener.java?r2=812fa060bfeac5b320624b5d6d4833ac441d42c9&amp;amp;r1=e00e0d6599b01733c270f3053e23118d35ea0881
</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jms.JmsMessageHelper.java</file>
			<file type="M">org.apache.camel.component.jms.EndpointMessageListener.java</file>
		</fixedFiles>
	</bug>
	<bug id="9101" opendate="2015-08-25 11:31:48" fixdate="2015-10-24 08:29:13" resolution="Fixed">
		<buginformation>
			<summary>RabbitMQ specific message properties are forwarded as message headers</summary>
			<description>org.apache.camel.component.rabbitmq.RabbitMQProducer#buildProperties does not remove message headers from exchange after property is set, leading to message header pollution.
so constructs like 


final Object contentType = exchange.getIn().getHeader(RabbitMQConstants.CONTENT_TYPE);
        if (contentType != null) {
            properties.contentType(contentType.toString());
        }


must be rewritten as


final Object contentType = exchange.getIn().removeHeader(RabbitMQConstants.CONTENT_TYPE);
        if (contentType != null) {
            properties.contentType(contentType.toString());
        }


I don&amp;amp;apos;t think that these are used in business logic as this is solely transport specific.</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQMessageConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="9247" opendate="2015-10-23 05:25:34" fixdate="2015-10-24 10:40:49" resolution="Fixed">
		<buginformation>
			<summary>rest-dsl with api-doc should allow multiple rest&amp;apos;s</summary>
			<description>See SO
http://stackoverflow.com/questions/33291657/how-to-have-multiple-camel-rest-dsl-definitions-with-swagger
The api-doc endpoint should merge multiple rest&amp;amp;apos;s together.</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.netty.http.BaseNettyTest.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpComponent.java</file>
			<file type="M">org.apache.camel.builder.RouteBuilder.java</file>
			<file type="M">org.apache.camel.model.rest.RestDefinition.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">9489</link>
		</links>
	</bug>
	<bug id="9243" opendate="2015-10-22 17:15:51" fixdate="2015-10-24 14:01:02" resolution="Fixed">
		<buginformation>
			<summary>Invocation of Bean fails when Bean extends and abstract which implements the actual method</summary>
			<description>The issue described here does NOT exist in 2.15.2 and only manifests in 2.15.3.
With the following definition of a Bean:


    public interface MyBaseInterface {
        @Handler
        String hello(@Body String hi);
    }

    public abstract static class MyAbstractBean implements MyBaseInterface {
        public String hello(@Body String hi) {
            return "Hello " + hi;
        }
        public String doCompute(String input) {
            fail("Should not invoke me");
            return null;
        }
    }

    public static class MyConcreteBean extends MyAbstractBean {
    }



The following test case will fail to invoke the proper method:


public class BeanHandlerMethodTest extends ContextTestSupport {

    public void testInterfaceBeanMethod() throws Exception {
        BeanInfo info = new BeanInfo(context, MyConcreteBean.class);

        Exchange exchange = new DefaultExchange(context);
        MyConcreteBean pojo = new MyConcreteBean();
        MethodInvocation mi = info.createInvocation(pojo, exchange);
        assertNotNull(mi);
        assertEquals("hello", mi.getMethod().getName());
    }


The issue is how BeanInfo.introspect determines which methods are available to be invoked.
At line 344, if the class is public, the interface methods are added to the list:


        if (Modifier.isPublic(clazz.getModifiers())) {
            // add additional interface methods
            List&amp;lt;Method&amp;gt; extraMethods = getInterfaceMethods(clazz);
            for (Method target : extraMethods) {
                for (Method source : methods) {
                    if (ObjectHelper.isOverridingMethod(source, target, false)) {
                        overrides.add(target);
                    }
                }
            }
            // remove all the overrides methods
            extraMethods.removeAll(overrides);
            methods.addAll(extraMethods);
        }


However, all the methods from the interface are "abstract".  Later, when the real implementation is encountered as the code crawls up the tree, the abstract method is not replaced:
Line 390:


        MethodInfo existingMethodInfo = overridesExistingMethod(methodInfo);
        if (existingMethodInfo != null) {
            LOG.trace("This method is already overridden in a subclass, so the method from the sub class is preferred: {}", existingMethodInfo);
            return existingMethodInfo;
        }


Finally, during the invocation, the following was added as part of 2.15.3 release:
Line 561:


        removeAllAbstractMethods(localOperationsWithBody);
        removeAllAbstractMethods(localOperationsWithNoBody);
        removeAllAbstractMethods(localOperationsWithCustomAnnotation);
        removeAllAbstractMethods(localOperationsWithHandlerAnnotation);


As a result, the abstract method is removed and not invoked.
I think the fix should be to see if the existingMethodInfo references an "abstract&amp;amp;apos; method and if it does and methodInfo does not, replace the existingMethodInfo with methodInfo in the collection.
This would preserve the preferences implied with the rest of the code while properly replacing the abstract method with their proper implementations.</description>
			<version>2.15.3</version>
			<fixedVersion>2.16.1, 2.15.5, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanHandlerMethodTest.java</file>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
		</fixedFiles>
	</bug>
	<bug id="9245" opendate="2015-10-22 17:59:21" fixdate="2015-10-25 20:47:45" resolution="Fixed">
		<buginformation>
			<summary>camel-paho - Endpoint should allow a flexible naming.</summary>
			<description>If endpoint doesn&amp;amp;apos;t match exactly paho: it fails to publish to the correct topic.
Once should be able in Spring to @Autowired two different PahoComponent pointing to different Application Context defined PahoComponent bean id&amp;amp;apos;S.
Currently if bean id is not named exactly paho it fails to publish to the correct topic and for example instead of input/1 publishes to t://input/1 when id is mypaho instead of paho
</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.paho.PahoEndpoint.java</file>
			<file type="M">org.apache.camel.component.paho.PahoComponent.java</file>
			<file type="M">org.apache.camel.component.paho.PahoComponentTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9255" opendate="2015-10-26 09:11:32" fixdate="2015-10-27 07:50:58" resolution="Fixed">
		<buginformation>
			<summary>documentType not used for XPath predicates in XML DSL</summary>
			<description>the documentType paramter is not used for XPath predicates in XML DSL. It works for XPath expression and in Java DSL</description>
			<version>2.14.3</version>
			<fixedVersion>2.16.1, 2.15.5, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.language.XPathExpression.java</file>
		</fixedFiles>
	</bug>
	<bug id="9238" opendate="2015-10-20 06:23:12" fixdate="2015-10-27 11:36:06" resolution="Fixed">
		<buginformation>
			<summary>NPE while GenericFile.changeFileName</summary>
			<description>If a relative file path is specified for the moveor moveFailed Attribute of the file2 component, a NullPointerException is thrown while processing the onCompletion commit resp. rollback strategy.
And because the processed file cannot be moved away, the processing is restarted again and so on...
Wrong code line (GenericFile.java:203 in camel-core V2.15.3):


ObjectHelper.after(newFileName, newEndpointPath + File.separatorChar);


when newFileNameand newEndpointPath are both relative paths.
Stacktrace:


java.lang.NullPointerException
	at java.io.File.&amp;lt;init&amp;gt;(File.java:277) ~[?:1.8.0_60]
	at org.apache.camel.component.file.GenericFile.changeFileName(GenericFile.java:207) ~[camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.component.file.strategy.GenericFileExpressionRenamer.renameFile(GenericFileExpressionRenamer.java:41) ~[camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.component.file.strategy.GenericFileRenameProcessStrategy.commit(GenericFileRenameProcessStrategy.java:87) ~[camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.component.file.GenericFileOnCompletion.processStrategyCommit(GenericFileOnCompletion.java:124) [camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.component.file.GenericFileOnCompletion.onCompletion(GenericFileOnCompletion.java:80) [camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.component.file.GenericFileOnCompletion.onComplete(GenericFileOnCompletion.java:54) [camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.util.UnitOfWorkHelper.doneSynchronizations(UnitOfWorkHelper.java:104) [camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.impl.DefaultUnitOfWork.done(DefaultUnitOfWork.java:229) [camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.util.UnitOfWorkHelper.doneUow(UnitOfWorkHelper.java:65) [camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.processor.CamelInternalProcessor$UnitOfWorkProcessorAdvice.after(CamelInternalProcessor.java:637) [camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.processor.CamelInternalProcessor$UnitOfWorkProcessorAdvice.after(CamelInternalProcessor.java:605) [camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.processor.CamelInternalProcessor$InternalCallback.done(CamelInternalProcessor.java:239) [camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:106) [camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:190) [camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.component.file.GenericFileConsumer.processExchange(GenericFileConsumer.java:439) [camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.component.file.GenericFileConsumer.processBatch(GenericFileConsumer.java:211) [camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.component.file.GenericFileConsumer.poll(GenericFileConsumer.java:175) [camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:174) [camel-core-2.15.3.jar:2.15.3]
	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:101) [camel-core-2.15.3.jar:2.15.3]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [?:1.8.0_60]
	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308) [?:1.8.0_60]
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180) [?:1.8.0_60]
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294) [?:1.8.0_60]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [?:1.8.0_60]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [?:1.8.0_60]

</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.1, 2.15.5, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.GenericFile.java</file>
		</fixedFiles>
	</bug>
	<bug id="9259" opendate="2015-10-27 06:13:21" fixdate="2015-10-27 11:41:40" resolution="Fixed">
		<buginformation>
			<summary>enableTrace of the Main class doesn&amp;apos;t work</summary>
			<description>The enableTrace() method of the Camel Main class doesn&amp;amp;apos;t work.
When we setup the code as such


    public static void main(String... args) throws Exception {
        Main main = new Main();
        main.enableHangupSupport();
        main.addRouteBuilder(new MyRouteBuilder());
        main.enableTrace();
        main.run(args);


and launch the Main class, than the messages reported by the route in the log are not traced at all.
If we debug, we can see that there is not CamelContext object when this method of the MainSupport class is called


    public void enableTrace() {
        this.trace = true;
        for (CamelContext context : camelContexts) { // EMPTY
            context.setTracing(true);
        }
    }


The workaround is to enable the tracing within the route definition


    public void configure() {

        getContext().setTracing(true);

</description>
			<version>2.15.3</version>
			<fixedVersion>2.16.1, 2.15.5, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.main.MainTest.java</file>
			<file type="M">org.apache.camel.main.MainSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="9257" opendate="2015-10-26 13:28:01" fixdate="2015-10-28 10:31:36" resolution="Fixed">
		<buginformation>
			<summary>route stop/start doesn&amp;apos;t work for camel-websocket producer</summary>
			<description>If you just add stopRoute()&amp;amp;startRoute() at the beginning of WebsocketProducerRouteExampleTest#testWSHttpCall(), it fails with 404 not found.


java.util.concurrent.ExecutionException"&amp;gt;java.util.concurrent.ExecutionException: java.lang.IllegalStateException: Invalid Status Code 404
        at com.ning.http.client.providers.netty.future.NettyResponseFuture.done(NettyResponseFuture.java:220)
        at com.ning.http.client.providers.netty.handler.WebSocketProtocol.handle(WebSocketProtocol.java:102)
        at com.ning.http.client.providers.netty.handler.Processor.messageReceived(Processor.java:88)
..........

</description>
			<version>2.17.0</version>
			<fixedVersion>2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.websocket.WebsocketEndpoint.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="9269" opendate="2015-10-29 08:42:34" fixdate="2015-10-29 08:59:32" resolution="Fixed">
		<buginformation>
			<summary>NotifyBuilder.fromRoute() does not work for some endpoint types</summary>
			<description>NotifyBuilder.fromRoute() does not work if the endpoint uri in the from() clause for a route does not match the actual endpoint uri the exchange was sent to. Because we also have the route id itself available in the exchange, we can use that as a fallback when the match on from endpoint uri doesn&amp;amp;apos;t work.</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.NotifyBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="9290" opendate="2015-11-04 20:21:46" fixdate="2015-11-04 20:36:20" resolution="Fixed">
		<buginformation>
			<summary>netty4 consumer in clientMode only reconnects once</summary>
			<description>Currently, when the server goes down the first time, it will reconnect fine. But if the server goes down again later, it will not attempt a reconnect.</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.ClientModeTCPNettyServerBootstrapFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="9161" opendate="2015-09-24 13:51:22" fixdate="2015-11-11 07:17:07" resolution="Fixed">
		<buginformation>
			<summary>Camel spring-boot not finding routes when using spring-cloud</summary>
			<description>On startup Camel is not registering any routes annotated with @Component. Route is found and registered in Spring just fine. Switch to version 2.15.2 and it works fine. 
No errors are thrown, and everything says it&amp;amp;apos;s started, but no routes are active or reported as being found during startup. 
Application is being run through `mvn spring-boot:run` if that makes a difference.</description>
			<version>2.15.3</version>
			<fixedVersion>2.16.1, 2.15.5, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.boot.RoutesCollector.java</file>
			<file type="D">org.apache.camel.spring.boot.parent.SpringBootWithParentContextTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">9294</link>
		</links>
	</bug>
	<bug id="9294" opendate="2015-11-05 20:20:40" fixdate="2015-11-13 14:40:52" resolution="Duplicate">
		<buginformation>
			<summary>Camel spring boot doesn&amp;apos;t pickup routes when context refresh event is not called on the root context</summary>
			<description>RoutesBuilders doesn&amp;amp;apos;t get picked-up when Spring Cloud Config is included on the classpath, I think it uses some mechanism for properties refresh, by that, application context is ignored and code bellow will not do the initialisation.
My propose would be to always initialise and log an additional information if you think there could be a problem without the root context. 
RoutesCollector.java

public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) {
 ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();
        if (applicationContext.getParent() == null) {
           // This will not get called when Spring Cloud Config is included on classpath
        } else {
            LOG.debug("Not at root context - defer adding routes");
        }
}


If you agree I&amp;amp;apos;ll attach a patch.</description>
			<version>2.16.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.boot.RoutesCollector.java</file>
			<file type="D">org.apache.camel.spring.boot.parent.SpringBootWithParentContextTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">9161</link>
		</links>
	</bug>
	<bug id="9318" opendate="2015-11-13 09:03:06" fixdate="2015-11-13 14:49:30" resolution="Fixed">
		<buginformation>
			<summary>org.apache.camel.component.twitter.TwitterEndpointEvent cannot be cast to org.apache.camel.component.direct.DirectEndpoint</summary>
			<description>There is issue with streaming endpoint and type=event.


from("twitter://streaming/user?type=event")


It is working for type=polling.
Reproducer:
Just run test for camel-twitter:


mvn test -P twitter-test


Stack trace:


java.lang.ClassCastException: org.apache.camel.component.twitter.TwitterEndpointEvent cannot be cast to org.apache.camel.component.direct.DirectEndpoint
	at org.apache.camel.component.direct.DirectConsumer.&amp;lt;init&amp;gt;(DirectConsumer.java:37)
	at org.apache.camel.component.twitter.consumer.TwitterConsumerEvent.&amp;lt;init&amp;gt;(TwitterConsumerEvent.java:32)
	at org.apache.camel.component.twitter.TwitterEndpointEvent.createConsumer(TwitterEndpointEvent.java:40)
	at org.apache.camel.impl.EventDrivenConsumerRoute.addServices(EventDrivenConsumerRoute.java:68)
	at org.apache.camel.impl.DefaultRoute.onStartingServices(DefaultRoute.java:98)
	at org.apache.camel.impl.RouteService.warmUp(RouteService.java:158)
	at org.apache.camel.impl.DefaultCamelContext.doWarmUpRoutes(DefaultCamelContext.java:3439)
	at org.apache.camel.impl.DefaultCamelContext.safelyStartRouteServices(DefaultCamelContext.java:3369)
	at org.apache.camel.impl.DefaultCamelContext.doStartOrResumeRoutes(DefaultCamelContext.java:3146)
	at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:3002)
	at org.apache.camel.impl.DefaultCamelContext.access$000(DefaultCamelContext.java:175)
	at org.apache.camel.impl.DefaultCamelContext$2.call(DefaultCamelContext.java:2798)
	at org.apache.camel.impl.DefaultCamelContext$2.call(DefaultCamelContext.java:2794)
	at org.apache.camel.impl.DefaultCamelContext.doWithDefinedClassLoader(DefaultCamelContext.java:2817)
	at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:2794)
	at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:61)
	at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:2763)
	at org.apache.camel.test.junit4.CamelTestSupport.startCamelContext(CamelTestSupport.java:544)
	at org.apache.camel.test.junit4.CamelTestSupport.doSetUp(CamelTestSupport.java:334)
	at org.apache.camel.test.junit4.CamelTestSupport.setUp(CamelTestSupport.java:238)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:264)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:153)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:124)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:200)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:153)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:103)

</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.twitter.consumer.TwitterConsumerEvent.java</file>
			<file type="M">org.apache.camel.component.twitter.consumer.TwitterConsumerDirect.java</file>
		</fixedFiles>
	</bug>
	<bug id="9321" opendate="2015-11-13 14:52:04" fixdate="2015-11-13 14:58:52" resolution="Fixed">
		<buginformation>
			<summary>Blueprint example and archetype does not work when executed with camel:run</summary>
			<description>When running mvn camel:run in the camel-example-sql-blueprint module or in a generate project with the camel-archetype-blueprint Maven archetype, the following error occurs:


[ERROR] *************************************
[ERROR] Error occurred while running main from: org.apache.camel.test.blueprint.Main
[ERROR] 
java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.apache.camel.maven.RunMojo$1.run(RunMojo.java:455)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.RuntimeException: Gave up waiting for service (objectClass=org.apache.camel.CamelContext)
	at org.apache.camel.test.blueprint.CamelBlueprintHelper.getOsgiService(CamelBlueprintHelper.java:265)
	at org.apache.camel.test.blueprint.CamelBlueprintHelper.getOsgiService(CamelBlueprintHelper.java:226)
	at org.apache.camel.test.blueprint.Main.doStart(Main.java:107)
	at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:61)
	at org.apache.camel.main.MainSupport.run(MainSupport.java:124)
	at org.apache.camel.main.MainSupport.run(MainSupport.java:353)
	at org.apache.camel.test.blueprint.Main.main(Main.java:81)
	... 6 more
[ERROR] *************************************


This is due to a missing dependency on org.apache.aries.blueprint.core.</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.maven.RunMojo.java</file>
		</fixedFiles>
	</bug>
	<bug id="8302" opendate="2015-02-01 20:14:50" fixdate="2015-11-13 15:10:49" resolution="Fixed">
		<buginformation>
			<summary>Rabbitmq shouldn&amp;apos;t require/bind queue if not specified </summary>
			<description>Current implementation is declaring both exchange and queue on any init (producer or consumer). In case of producer one don&amp;amp;apos;t need queue and may not know who going to be client. 
We can add flag skipQueueDeclare  so that it won&amp;amp;apos;t genrate uuid queue. 
i can provide PR if it helps. </description>
			<version>2.14.1</version>
			<fixedVersion>2.16.1, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQEndpoint.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQEndpointTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9311" opendate="2015-11-11 16:45:11" fixdate="2015-11-13 16:29:30" resolution="Fixed">
		<buginformation>
			<summary>Concurrency issue with the dynamic router</summary>
			<description>We have a service with two HTTP contexts:
http://0.0.0.0:9000/endpoin1/dynamic"
http://0.0.0.0:9000/endpoin2/dynamic"
Both endpoints can be called using a HTTP GET method and a dynamic router routes the message differently.
Each HTTP endpoint  has its own instance of the dynamic router bean. The dynamic router bean does not use any shared state.
When the HTTP endpoints are called sequentially the calls are handled as expected. When the HTTP endpoints are called concurrently then sometimes the the dynamic router of the 9000/endpoin1/dynamic endpoint is re-routing calls originating from 9000/endpoin2/dynamic and vice versa.
Please take a look at attached unit test case for more detail.
</description>
			<version>2.15.1</version>
			<fixedVersion>2.16.1, 2.15.5, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.RoutingSlip.java</file>
			<file type="M">org.apache.camel.processor.DynamicRouter.java</file>
		</fixedFiles>
	</bug>
	<bug id="9246" opendate="2015-10-22 18:45:29" fixdate="2015-11-16 07:45:09" resolution="Fixed">
		<buginformation>
			<summary>camel-cxf proxy with MTOM does not get attachment back when RPC/literal style WSDL used</summary>
			<description>I have a camel-cxf proxy test case with MTOM enabled. The WSDL used in the project is RPC/Literal style. However, I was unable to get attachment back via response. Please take a look at the test case for more detail.
After some debugging, it looks like that camel-cxf producer did get attachment back. However, there were two attachment related parts. One part had no attachment (empty) but had correct "Content-ID". The other part did contain entire attachment but had a rather different "Content-ID". For instance:


19:30:47,110 | INFO  | qtp565617691-367 | IMtomExample                     | 118 - org.apache.cxf.cxf-core - 3.0.4.redhat-620133 | Outbound Message
---------------------------
ID: 63
Response-Code: 200
Encoding: UTF-8
Content-Type: multipart/related; type="application/xop+xml"; boundary="uuid:f108bc3f-549a-4baa-ab00-757ff837aacf"; start="&amp;lt;root.message@cxf.apache.org&amp;gt;"; start-info="text/xml"
Headers: {accept-encoding=[gzip,deflate], breadcrumbId=[ID-jluomac-52985-1445511717614-11-8], Host=[localhost:7777], Server=[Jetty(8.1.15.v20140411)], User-Agent=[Apache-HttpClient/4.1.1 (java 1.5)]}
Payload: --uuid:f108bc3f-549a-4baa-ab00-757ff837aacf
Content-Type: application/xop+xml; charset=UTF-8; type="text/xml"
Content-Transfer-Encoding: binary
Content-ID: &amp;lt;root.message@cxf.apache.org&amp;gt;

&amp;lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;&amp;lt;soap:Body&amp;gt;&amp;lt;ns1:doMtomResponse xmlns:ns1="http://cxf.example.com/"&amp;gt;&amp;lt;parameters xmlns:ns2="http://cxf.example.com/"&amp;gt;&amp;lt;output&amp;gt;soapui-splash.png&amp;lt;/output&amp;gt;&amp;lt;dataLength&amp;gt;27186&amp;lt;/dataLength&amp;gt;&amp;lt;data&amp;gt;&amp;lt;xop:Include xmlns:xop="http://www.w3.org/2004/08/xop/include" href="cid:15839364-d75d-4cbe-a163-40838bca762a-31@cxf.apache.org"/&amp;gt;&amp;lt;/data&amp;gt;&amp;lt;/parameters&amp;gt;&amp;lt;/ns1:doMtomResponse&amp;gt;&amp;lt;/soap:Body&amp;gt;&amp;lt;/soap:Envelope&amp;gt;
--uuid:f108bc3f-549a-4baa-ab00-757ff837aacf
Content-Type: image/png
Content-Transfer-Encoding: binary
Content-ID: &amp;lt;e4b4a36a-b07a-481d-8bf8-82df5b57f40b-1@cxf.apache.org&amp;gt;
Content-Disposition: attachment;name="soapui-splash.png"

&amp;lt;-- soapui-splash.png binary attachment starts here --&amp;gt;
...
...
&amp;lt;-- soapui-splash.png binary attachment ends here --&amp;gt;

--uuid:f108bc3f-549a-4baa-ab00-757ff837aacf
Content-Type: image/png
Content-Transfer-Encoding: binary
Content-ID: &amp;lt;15839364-d75d-4cbe-a163-40838bca762a-31@cxf.apache.org&amp;gt;
Content-Disposition: attachment;name="soapui-splash.png"

&amp;lt;-- no binary attachment here. empty --&amp;gt;

--uuid:f108bc3f-549a-4baa-ab00-757ff837aacf--
--------------------------------------


And the response message returned was:


&amp;lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;
   &amp;lt;soap:Body&amp;gt;
      &amp;lt;ns1:doMtomResponse xmlns:ns1="http://cxf.example.com/"&amp;gt;
         &amp;lt;parameters xmlns:ns2="http://cxf.example.com/"&amp;gt;
            &amp;lt;output&amp;gt;soapui-splash.png&amp;lt;/output&amp;gt;
            &amp;lt;dataLength&amp;gt;27186&amp;lt;/dataLength&amp;gt;
            &amp;lt;data&amp;gt;
               &amp;lt;xop:Include href="cid:15839364-d75d-4cbe-a163-40838bca762a-31@cxf.apache.org" xmlns:xop="http://www.w3.org/2004/08/xop/include"/&amp;gt;
            &amp;lt;/data&amp;gt;
         &amp;lt;/parameters&amp;gt;
      &amp;lt;/ns1:doMtomResponse&amp;gt;
   &amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;


Because the response pointed to the "Content-ID" of 


&amp;lt;xop:Include href="cid:15839364-d75d-4cbe-a163-40838bca762a-31@cxf.apache.org" xmlns:xop="http://www.w3.org/2004/08/xop/include"/&amp;gt;


and the parts identified by the "Content-ID: &amp;lt;15839364-d75d-4cbe-a163-40838bca762a-31@cxf.apache.org&amp;gt;" was actually empty. Therefore, client can not get the attachment back.</description>
			<version>2.15.1</version>
			<fixedVersion>2.15.5, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.mtom.CxfMtomPOJOProducerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9319" opendate="2015-11-13 10:50:36" fixdate="2015-11-16 16:30:22" resolution="Fixed">
		<buginformation>
			<summary>SshClient resource leak when used from ProducerTemplate</summary>
			<description>When using ProducerTemplate for execution of an ssh command (i.e. producerTemplate.requestBody("ssh://...", String.class)), 11 threads are being created, that are never killed. Any subsequent calls create new threads, eventually this exhausts memory and thread resources on the machine.
These threads are not being killed even when explicitly stopping the ProducerTemplate.
Here is a more detailed discussion, together with profiler results and code to reproduce the issue:
http://stackoverflow.com/questions/33671567/spring-boot-camel-producertemplate-thousands-of-threads
http://camel.465427.n5.nabble.com/Spring-Boot-Camel-producerTemplate-ssh-spawning-thousands-of-threads-td5773741.html</description>
			<version>2.15.4</version>
			<fixedVersion>2.15.5, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.ssh.SshConsumer.java</file>
			<file type="M">org.apache.camel.component.ssh.SshProducer.java</file>
			<file type="M">org.apache.camel.component.ssh.SshEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="9331" opendate="2015-11-16 19:16:28" fixdate="2015-11-18 08:28:52" resolution="Fixed">
		<buginformation>
			<summary>Thread leak in Http4Endpoint, doStop() does not close() the httpClient</summary>
			<description>Thread leak in Http4Endpoint, doStop() does not close() the httpClient
Also when using a shared client connection manager the builder must be told of this so it does not close() a shared connection manager when the http client is closed.</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http4.HttpEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="9316" opendate="2015-11-12 17:10:31" fixdate="2015-11-21 09:34:38" resolution="Fixed">
		<buginformation>
			<summary>LevelDBAggregationRepository is logging warnings when exchange is already complete on first aggregation</summary>
			<description>When using an aggregator with a LevelDBAggregationRepository and you are sending events, that are already complete by themselves (i.e. the fulfill the completionPredicate and they were never really aggregated), there is a lot of warning logging like


Nov 12, 2015 6:00:57 PM org.apache.camel.component.leveldb.LevelDBAggregationRepository confirm
WARNUNG: Unable to confirm exchangeId [ID-LPNB2331-59378-1447347654170-0-939 from repository collectionNotifications: Not Found]


My guess is that calling confirm on the repository in such cases is unnecessary, but I&amp;amp;apos;m not sure, if it is easy to detect wether confirm should be called or not.</description>
			<version>2.15.3</version>
			<fixedVersion>2.15.5, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.leveldb.LevelDBAggregationRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="9202" opendate="2015-10-08 15:38:16" fixdate="2015-11-22 13:45:38" resolution="Fixed">
		<buginformation>
			<summary>Flatpack: Body reader never closed </summary>
			<description>Hello Camel team,
First of all I want to thank you for all great work you do to provide such a powerful tool as Camel. I really enjoy using it in my work. 
Currently I am working on an application that requires delimited and fixed width parsing tools and I decided to use Camel Flatpack because we already use some other Camel stuff. We use Camel 2.14.3 which is not the latest one but forks fine. During my work with Flatpack consumer I found several issues and some room for improvements and I decided to share my thoughts/findings with you. Our team have plans to migrate to the latest version of Camel in near future and we all will be happy if the new version includes fixes/improvements that I am goint to suggest.
The main issue that I found is that flatpack endpoint does not close body reader if an exception is thrown during parser creation step. As a result the related resource remains opened forever. For example in my cases when PZMAP files was missing my data file (csv file) was locked and my file consumer ended in endless loop in which it was trying to move a file to .error folder but was not able to do this because the file was opened for read.
Another problem that I noticed is that I cannot use allowShortLines and ignoreExtraColumns attributes if my parser uses inline headers from files. Flatpack simply ignores them in this case.
Finally I think that there is some  room for improvements:

It would be nice to have a possibility to provide PZMAP as a bean via JNDI context instead of having to generate a file. This feature will be very useful and content parsing should work faster because the XML will be read from memory instead of reading it from a file each time you parse some content;
It would be nice to have a possibility to provide content format as an URI attribute instead of using these ugly URI prefixes that we should use right now. With such possibility in plase URI will look the same all the time and developers won&amp;amp;apos;t need to reformat URI differently for different content types.

I attached a patch file with code fragments and comments to them that illustrate my findings/thoughts. Unformtunatelly I don&amp;amp;apos;t have enough time to provide real fixes and unit tests so please excuse me for this. 
Please let me know if something is unclear or require more details.
Looking forward for your feedback,
Mykhailo</description>
			<version>2.14.3</version>
			<fixedVersion>2.15.5, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.flatpack.FlatpackEndpoint.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">9349</link>
		</links>
	</bug>
	<bug id="9270" opendate="2015-10-29 08:42:38" fixdate="2015-11-22 14:50:10" resolution="Fixed">
		<buginformation>
			<summary>rest-dsl - CORS support doesn&amp;apos;t work with Restlet 2.3</summary>
			<description>camel-restlet has upgraded to Restlet 2.3 (nice!), but this broke rest-dsl CORS support, because Restlet 2.3 no longer supports setting CORS headers via attributes. There are now API methods for these headers and attributes are ignored with a warning.
Example of the new API method:
http://restlet.com/technical-resources/restlet-framework/javadocs/2.3/jse/api/org/restlet/Response.html#setAccessControlAllowOrigin%28java.lang.String%29</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.RestRestletCorsTest.java</file>
			<file type="M">org.apache.camel.component.restlet.DefaultRestletBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="9282" opendate="2015-11-02 06:24:45" fixdate="2015-11-22 15:02:49" resolution="Fixed">
		<buginformation>
			<summary>IndexOutOfBoundsException if SoapAction parameter is empty</summary>
			<description>After upgrade from 1.4.1, I encountered below error when receiving web service message where SoapAction is blank. Below is the trace log and error log.
13:12:39,526 TRACE [org.apache.camel.component.cxf.DefaultCxfBinding] (default-workqueue-2) Populate header from CXF header=accept-encoding value=[gzip,deflate]
13:12:46,769 TRACE [org.apache.camel.component.cxf.DefaultCxfBinding] (default-workqueue-2) Populate header from CXF header=connection value=[keep-alive]
13:12:57,869 TRACE [org.apache.camel.component.cxf.DefaultCxfBinding] (default-workqueue-2) Populate header from CXF header=content-type value=[text/xml;charset=UTF-8]
13:12:59,803 TRACE [org.apache.camel.component.cxf.DefaultCxfBinding] (default-workqueue-2) Populate header from CXF header=Host value=[localhost:8088]
13:13:00,786 TRACE [org.apache.camel.component.cxf.DefaultCxfBinding] (default-workqueue-2) Populate header from CXF header=SoapAction value=[]
13:17:21,407 WARN  [org.apache.cxf.phase.PhaseInterceptorChain] (default-workqueue-2) Interceptor for 
{http://member.ws.com}
WsMemberService#
{http://member.ws.com}
receivedMemberMessage has thrown exception, 
unwinding now: java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
		at java.util.ArrayList.rangeCheck(ArrayList.java:635) [rt.jar:1.7.0_71]
	at java.util.ArrayList.get(ArrayList.java:411) [rt.jar:1.7.0_71]
	at org.apache.camel.component.cxf.DefaultCxfBinding.propagateHeadersFromCxfToCamel(DefaultCxfBinding.java:552) [camel-cxf-2.16.0.jar:2.16.0]
	at org.apache.camel.component.cxf.DefaultCxfBinding.populateExchangeFromCxfRequest(DefaultCxfBinding.java:247) [camel-cxf-2.16.0.jar:2.16.0]
	at org.apache.camel.component.cxf.CxfConsumer$1.prepareCamelExchange(CxfConsumer.java:187) [camel-cxf-2.16.0.jar:2.16.0]
	at org.apache.camel.component.cxf.CxfConsumer$1.syncInvoke(CxfConsumer.java:132) [camel-cxf-2.16.0.jar:2.16.0]
	at org.apache.camel.component.cxf.CxfConsumer$1.invoke(CxfConsumer.java:78) [camel-cxf-2.16.0.jar:2.16.0]
	at org.apache.cxf.interceptor.ServiceInvokerInterceptor$1.run(ServiceInvokerInterceptor.java:59) [cxf-core-3.1.2.jar:3.1.2]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471) [rt.jar:1.7.0_71]
	at java.util.concurrent.FutureTask.run(FutureTask.java:262) [rt.jar:1.7.0_71]
	at org.apache.cxf.interceptor.ServiceInvokerInterceptor$2.run(ServiceInvokerInterceptor.java:126) [cxf-core-3.1.2.jar:3.1.2]
	at org.apache.cxf.workqueue.SynchronousExecutor.execute(SynchronousExecutor.java:37) [cxf-core-3.1.2.jar:3.1.2]
	at org.apache.cxf.interceptor.ServiceInvokerInterceptor.handleMessage(ServiceInvokerInterceptor.java:131) [cxf-core-3.1.2.jar:3.1.2]
	at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:308) [cxf-core-3.1.2.jar:3.1.2]
	at org.apache.cxf.phase.PhaseInterceptorChain.resume(PhaseInterceptorChain.java:278) [cxf-core-3.1.2.jar:3.1.2]
	at org.apache.cxf.interceptor.OneWayProcessorInterceptor$1.run(OneWayProcessorInterceptor.java:137) [cxf-core-3.1.2.jar:3.1.2]
	at org.apache.cxf.workqueue.AutomaticWorkQueueImpl$3.run(AutomaticWorkQueueImpl.java:428) [cxf-core-3.1.2.jar:3.1.2]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) [rt.jar:1.7.0_71]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) [rt.jar:1.7.0_71]
	at org.apache.cxf.workqueue.AutomaticWorkQueueImpl$AWQThreadFactory$1.run(AutomaticWorkQueueImpl.java:353) [cxf-core-3.1.2.jar:3.1.2]
	at java.lang.Thread.run(Thread.java:745) [rt.jar:1.7.0_71]</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="9277" opendate="2015-10-30 10:58:09" fixdate="2015-11-23 07:20:22" resolution="Fixed">
		<buginformation>
			<summary>FTP shutdown whole context on startup if throwExceptionOnConnectFailed true</summary>
			<description>I recently upgrade from camel 2.14.1 to 2.16.1 and discover following issue: Unable to catch the Exception on startup if throwExceptionOnConnectFailed=true and autoCreate=true or autoCreate not declared.
If at the time of startup, the FTP site was down or unreachable, the Exception cannot be handled by any means I currently know which are onException route and doTry-doCatch method.
Following are my FTP parameters:
&amp;amp;maximumReconnectAttempts=0&amp;amp;stepwise=false&amp;amp;disconnect=true&amp;amp;throwExceptionOnConnectFailed=true&amp;amp;consumer.bridgeErrorHandler=true"
The only workaround without compromising error log functionality is by adding parameter "autoCreate=false".
Based on Camel-FTP documentation: "
For Camel 2.16, autoCreate option is supported. When consumer starts, before polling is scheduled, there&amp;amp;apos;s additional FTP operation performed to create the directory configured for endpoint. The default value for autoCreate is true.
"
In my opinion, the exception should be able to be caught, instead shutdown the whole Camel context. And description for throwExceptionOnConnectFailed need to be updated so unaware developer does not suffer the same as I did.</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.SftpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9366" opendate="2015-11-26 11:24:41" fixdate="2015-11-26 13:26:35" resolution="Fixed">
		<buginformation>
			<summary>CXFRS "skipFaultLogging" attribute doesn&amp;apos;t work in Spring</summary>
			<description>When defining a camel-cxf cxf:rsClient bean with skipFaultLogging enabled, like this


&amp;lt;camelcxf:rsClient id="rsClient" address="http://localhost:9081/CxfRsService/rest"
    serviceClass="org.apache.camel.component.cxf.jaxrs.testbean.CustomerService"
    skipFaultLogging="true" /&amp;gt;


... the exception will still be logged. If you add the flag to the endpoint URI instead, skipFaultLogging works as expected.</description>
			<version>2.16.1</version>
			<fixedVersion>2.15.5, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.spring.CxfRsClientFactoryBeanTest.java</file>
			<file type="M">org.apache.camel.component.cxf.spring.SpringJAXRSClientFactoryBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="9340" opendate="2015-11-20 00:40:12" fixdate="2015-11-28 08:05:43" resolution="Fixed">
		<buginformation>
			<summary>FileIdempotentRepository fails to create fileStore when no path is specified</summary>
			<description>I create a FileIdempotentRepository like this:


.idempotentConsumer(fileIdempotentRepository(new File(&amp;amp;apos;ids&amp;amp;apos;))) {
    it.in.body.id
}


I get an error, and I traced it to:

Caused by: java.lang.NullPointerException: null
	at org.apache.camel.processor.idempotent.mpotentRepository.loadStore(FileIdempotentRepository.java:293) ~[camel-core-2.16.0.jar:2.16.0]
	at org.apache.camel.processor.idempotent.FileIdempotentRepository.doStart(FileIdempotentRepository.java:328) ~[camel-core-2.16.0.jar:2.16.0]


The FileIdempotentRepository is trying to create the parent directory of the file that was specified for the file store. If a path to the file is not specified, then getParentFile() returns null. Calling .mkdirs() on that bombs.
This route works the second time it runs because then the file exists. It also works if I specify my file name as "./ids" instead of "ids".</description>
			<version>2.16.0</version>
			<fixedVersion>2.15.6, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.FileIdempotentConsumerCreateRepoTest.java</file>
			<file type="M">org.apache.camel.processor.idempotent.FileIdempotentRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="9381" opendate="2015-12-01 14:20:44" fixdate="2015-12-01 15:31:00" resolution="Fixed">
		<buginformation>
			<summary>Upgrade camel-amqp to the latest qpid-jms-client</summary>
			<description>We should upgrade camel-amqp to use the latest qpid-jms-client. That would mean that we should also drop support for AMQP &amp;lt; 1.0.</description>
			<version>2.16.1</version>
			<fixedVersion>2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.amqp.AMQPRouteTest.java</file>
			<file type="M">org.apache.camel.component.amqp.AMQPComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="9386" opendate="2015-12-03 09:21:35" fixdate="2015-12-03 16:25:25" resolution="Fixed">
		<buginformation>
			<summary>Camel-git: Support credentials in clone operation</summary>
			<description>As noted here: https://github.com/oscerd/camel-git/issues/1
Currently we don&amp;amp;apos;t support credentials for the clone operation.</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.git.producer.GitProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9377" opendate="2015-11-30 09:01:57" fixdate="2015-12-12 17:39:52" resolution="Duplicate">
		<buginformation>
			<summary>[test-blueprint] support configadmin as source of initial properties for BP camel context</summary>
			<description></description>
			<version>2.16.1</version>
			<fixedVersion></fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.test.blueprint.ConfigAdminLoadConfigurationFileTest.java</file>
			<file type="M">org.apache.camel.test.blueprint.CamelBlueprintHelper.java</file>
			<file type="M">org.apache.camel.test.blueprint.ConfigAdminNoReloadLoadConfigurationFileTest.java</file>
			<file type="M">org.apache.camel.test.blueprint.Main.java</file>
			<file type="M">org.apache.camel.test.blueprint.ConfigAdminLoadConfigurationFileAndOverrideTest.java</file>
			<file type="M">org.apache.camel.test.blueprint.CamelBlueprintTestSupport.java</file>
			<file type="M">org.apache.camel.test.blueprint.ConfigAdminNoReloadLoadConfigurationFileAndOverrideTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">9313</link>
			<link type="Reference" description="is related to">10476</link>
		</links>
	</bug>
	<bug id="9313" opendate="2015-11-12 08:13:42" fixdate="2015-12-12 19:40:27" resolution="Fixed">
		<buginformation>
			<summary>CamelBlueprintTestSupport - can&amp;apos;t initialize ConfigAdmin configurations</summary>
			<description>The bugfix CAMEL-8948 seems to make older timing problems related to property-placeholders visible.
To reproduce the problem i changed the test 
org.apache.camel.test.blueprint.ConfigAdminNoReloadLoadConfigurationFileTest 
from the component camel-test-blueprint a bit, respectively the context 
"org/apache/camel/test/blueprint/configadmin-no-reload-loadfile.xml": 
I added the trace Attribute to the camelContext:


&amp;lt;camelContext xmlns="http://camel.apache.org/schema/blueprint" trace="{{tracing}}"&amp;gt; 


and added also the property to the etc/stuff.cfg 


tracing=true 


Until 2.15.2 this worked fine. From 2.15.3 on the property cannot be 
replaced any more.
But, if setting a breakpoint in CamelBlueprintTestSupport#createBundleContext at loadConfigAdminConfigurationFile() (Line 123 in 2.15.4) - the error occurs even in older versions like 2.14 - so the timing problem seems to be there for a while but did not occur because the loading of the configAdminFile seems to be faster than the event handling during service registration triggered by the code some lines above.
The issue can also be reproduced when replacing a property&amp;amp;apos;s String type 
with int in the MyCoolBean class and setting its value by using the 
placeholder like before but with an int value of course. The test run shows 
that the placeholder "${..}" will not be replaced and leads to a 
NumberfFormatException. 
The production code that is under test works fine in karaf. </description>
			<version>2.15.4</version>
			<fixedVersion>2.15.6, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.test.blueprint.ConfigAdminLoadConfigurationFileTest.java</file>
			<file type="M">org.apache.camel.test.blueprint.CamelBlueprintHelper.java</file>
			<file type="M">org.apache.camel.test.blueprint.ConfigAdminNoReloadLoadConfigurationFileTest.java</file>
			<file type="M">org.apache.camel.test.blueprint.Main.java</file>
			<file type="M">org.apache.camel.test.blueprint.ConfigAdminLoadConfigurationFileAndOverrideTest.java</file>
			<file type="M">org.apache.camel.test.blueprint.CamelBlueprintTestSupport.java</file>
			<file type="M">org.apache.camel.test.blueprint.ConfigAdminNoReloadLoadConfigurationFileAndOverrideTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">9377</link>
			<link type="Reference" description="is related to">8122</link>
			<link type="Reference" description="is related to">9636</link>
			<link type="Reference" description="is related to">10476</link>
		</links>
	</bug>
	<bug id="8708" opendate="2015-04-27 16:51:31" fixdate="2015-12-14 07:09:56" resolution="Fixed">
		<buginformation>
			<summary>SOAP unmarshalling shouldn&amp;apos;t fail for Faults that lack an optional Detail element</summary>
			<description>Camel-soap code assumes that all Faults that a Camel SOAP endpoint is receiving, are containing a Detail element. Sending a Fault without Detail will result in an NPE. Detail is optional element in SOAP Faults (see http://www.w3.org/TR/soap12-part1/#soapfault) and its absence should not generate an error.</description>
			<version>2.15.1</version>
			<fixedVersion>2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.soap12.Soap12UnMarshalTest.java</file>
			<file type="M">org.apache.camel.dataformat.soap.Soap12DataFormatAdapter.java</file>
		</fixedFiles>
	</bug>
	<bug id="9417" opendate="2015-12-11 18:15:33" fixdate="2015-12-14 07:12:05" resolution="Fixed">
		<buginformation>
			<summary>SOAP 1.2 Fault processing should use value of Reasontext to build exception message</summary>
			<description>org.apache.camel.dataformat.soap.Soap12DataFormatAdapter#createExceptionFromFault uses org.w3._2003._05.soap_envelope.Reasontext#toString to generate the exception message, but Reasontext does not have a toString implementation, so it prints values like org.w3._2003._05.soap_envelope.Reasontext@2b6afea1 and the Reasontext value is lost. Reasontext#getValue which returns a human-readable string should be used instead.</description>
			<version>2.16.1</version>
			<fixedVersion>2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.soap.Soap12DataFormatAdapter.java</file>
		</fixedFiles>
	</bug>
	<bug id="9424" opendate="2015-12-15 21:41:16" fixdate="2015-12-16 07:15:08" resolution="Fixed">
		<buginformation>
			<summary>CronScheduledRoutePolicy regression introduced with 2.16, setting both start and stop route times fails with duplicate trigger</summary>
			<description>This commit created a regression whereby if you set both a start and a stop route time on a CronScheduledRoutePolicy, like:


CronScheduledRoutePolicy policy = new CronScheduledRoutePolicy();
policy.setRouteStartTime("*/3 * * * * ?");
policy.setRouteStopTime("*/5 * * * * ?");


then adding the Quartz triggers will fail because of duplicate trigger names.
Basically, the start and stop triggers will have the same name because of this line.

org.apache.camel.FailedToCreateRouteException: Failed to create route test: Route(test)[[From[direct:start]] -&amp;gt; [To[mock:success]]] because of org.quartz.ObjectAlreadyExistsException: Unable to store Trigger with name: &amp;amp;apos;trigger-START-test&amp;amp;apos; and group: &amp;amp;apos;triggerGroup-test&amp;amp;apos;, because one already exists with this identification.

	at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:201)
	at org.apache.camel.impl.DefaultCamelContext.startRoute(DefaultCamelContext.java:949)
	at org.apache.camel.impl.DefaultCamelContext.startRouteDefinitions(DefaultCamelContext.java:3261)
	at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:2984)
	at org.apache.camel.impl.DefaultCamelContext.access$000(DefaultCamelContext.java:176)
	at org.apache.camel.impl.DefaultCamelContext$2.call(DefaultCamelContext.java:2814)
	at org.apache.camel.impl.DefaultCamelContext$2.call(DefaultCamelContext.java:2810)
	at org.apache.camel.impl.DefaultCamelContext.doWithDefinedClassLoader(DefaultCamelContext.java:2833)
	at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:2810)
	at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:61)
	at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:2779)
	at org.apache.camel.routepolicy.quartz2.CronScheduledRoutePolicyTest.testScheduledStartAndStopRoutePolicy(CronScheduledRoutePolicyTest.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
Caused by: org.apache.camel.RuntimeCamelException: org.quartz.ObjectAlreadyExistsException: Unable to store Trigger with name: &amp;amp;apos;trigger-START-test&amp;amp;apos; and group: &amp;amp;apos;triggerGroup-test&amp;amp;apos;, because one already exists with this identification.
	at org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException(ObjectHelper.java:1642)
	at org.apache.camel.routepolicy.quartz2.CronScheduledRoutePolicy.onInit(CronScheduledRoutePolicy.java:41)
	at org.apache.camel.impl.DefaultRouteContext.commit(DefaultRouteContext.java:220)
	at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:1076)
	at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:196)
	... 43 more
Caused by: org.quartz.ObjectAlreadyExistsException: Unable to store Trigger with name: &amp;amp;apos;trigger-START-test&amp;amp;apos; and group: &amp;amp;apos;triggerGroup-test&amp;amp;apos;, because one already exists with this identification.
...

</description>
			<version>2.16.0</version>
			<fixedVersion>2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.routepolicy.quartz2.CronScheduledRoutePolicy.java</file>
			<file type="M">org.apache.camel.routepolicy.quartz2.CronScheduledRoutePolicyTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9426" opendate="2015-12-16 00:15:08" fixdate="2015-12-16 08:29:50" resolution="Fixed">
		<buginformation>
			<summary>spring-boot with rest-dsl with api-doc registers multiple instances with multiple RouteBuilders</summary>
			<description>Spring-boot + swagger throws exception when there is another RouteBuilder component present:
org.apache.camel.spring.boot.CamelSpringBootInitializationException: org.apache.camel.FailedToStartRouteException: Failed to start route route4 because of Multiple consumers for the same endpoint is not allowed: Endpointhttp://0.0.0.0:10000/api-doc?httpMethodRestrict=GET
I used the same example as CAMEL-9247 but added an empty RouteBuilder component (AnotherRouter.java)
This makes it so we cannot have more than one RouteBuilder in our app.
Example here:
https://github.com/jmandawg/camel-spring-boot-swagger-problem</description>
			<version>2.16.1</version>
			<fixedVersion>2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.RouteBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="9405" opendate="2015-12-09 22:59:35" fixdate="2015-12-18 17:14:06" resolution="Fixed">
		<buginformation>
			<summary>Amazon SQS message deletion behaviour change on exception</summary>
			<description>After upgrading applications from Camel 2.15.2 to Camel 2.15.3 we noticed a change in behaviour around the handling of a message from an SQS queue when a processing stage throws an exception.
Previously the message would not be deleted, and would become available to the SQS again.
After the upgrade, messages are deleted even if an exception occurs during the processing stage.
I will attach a unit test which demonstrates the behaviour by:

including a mock process which throws an exception
asserting that there is no call to delete a message.

I believe that the commit which changed the behaviour is:
https://github.com/apache/camel/commit/bd10c49bdcdbe6181e35461c449ea61db9a13bf1
This issue may be specific to the inclusion of a seda stage.</description>
			<version>2.15.3</version>
			<fixedVersion>2.15.6, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.aws.sqs.SqsProducer.java</file>
			<file type="M">org.apache.camel.component.aws.sqs.SqsConsumer.java</file>
		</fixedFiles>
		<links>
			<link type="Regression" description="is broken by">9055</link>
		</links>
	</bug>
	<bug id="9375" opendate="2015-11-29 09:01:34" fixdate="2015-12-20 07:00:16" resolution="Fixed">
		<buginformation>
			<summary>camel-tarfile - TarSplitter includes one extra empty entry at the end</summary>
			<description>This unit test demonstrates the bug
org.apache.camel.dataformat.tarfile.TarSplitterRouteIssueTest
There is only 3 files in the tar file that it uses, but the splitter has 4 entries where the last is empty.
</description>
			<version>2.16.1</version>
			<fixedVersion>2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.tarfile.TarIterator.java</file>
			<file type="M">org.apache.camel.dataformat.tarfile.TarFileDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.tarfile.TarSplitter.java</file>
			<file type="M">org.apache.camel.dataformat.tarfile.TarSplitterRouteIssueTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">9745</link>
			<link type="Reference" description="is related to">9735</link>
		</links>
	</bug>
	<bug id="9442" opendate="2015-12-22 13:37:14" fixdate="2015-12-22 14:04:47" resolution="Fixed">
		<buginformation>
			<summary>Query string gets decoded when bridging from netty-http to http4</summary>
			<description>When using a route like this one (to forward an HTTP request to a downstream server) using the netty-http component, the query is decoded when sent to the downstream server:

  from("netty-http:http://localhost:9000/service?matchOnUriPrefix=true")
          .to ("http4://downstream:9000/service?bridgeEndpoint=true");


A request to http://localhost:9000/service?q=%3B will result in a call to http://downstream:9000/service?q=; (notice the decoded ; character). Replacing the netty-http:http: endpoint with a jetty:http: endpoint fixes the problem.
The difference is in the use of the Exchange.HTTP_QUERY and Exchange.HTTP_RAW_QUERY headers. The jetty:http: endpoint is only setting the former header (containing the raw header value), while the netty-http:http: endpoint is using both headers.
When using bridgeEndpoint, the http4 component should prefer the raw query header over the decoded header if both headers are available.</description>
			<version>2.17.0</version>
			<fixedVersion>2.15.6, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http4.handler.BasicValidationHandler.java</file>
			<file type="M">org.apache.camel.http.common.HttpHelper.java</file>
			<file type="M">org.apache.camel.component.http4.HttpBridgeEndpointTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">9640</link>
			<link type="Reference" description="is related to">9658</link>
			<link type="Reference" description="is related to">9660</link>
		</links>
	</bug>
	<bug id="9406" opendate="2015-12-10 06:03:47" fixdate="2015-12-25 09:55:36" resolution="Fixed">
		<buginformation>
			<summary>Request Reply via RabbitMQ not handling reply correctly</summary>
			<description>The reply will be a empty message.
When 
org.apache.camel.component.rabbitmq.reply.ReplyManagerSupport#processReply
calls
org.apache.camel.component.rabbitmq.RabbitMQEndpoint#setRabbitExchange
The method setRabbitExchange will get `In` message and setBody for reply message while the expected message is `Out`.</description>
			<version>2.16.1</version>
			<fixedVersion>2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rabbitmq.reply.ReplyManagerSupport.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="9468" opendate="2016-01-02 22:03:18" fixdate="2016-01-04 10:22:25" resolution="Fixed">
		<buginformation>
			<summary>Bindy fails to marshal objects in Spring Boot</summary>
			<description>When using Spring Boot or when manually registering an ObjectToList-converter with Camel, Bindy fails to marshal objects.
PR submitted with fix.</description>
			<version>2.16.1</version>
			<fixedVersion>2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.bindy.fixed.BindyFixedLengthDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="9480" opendate="2016-01-05 08:48:26" fixdate="2016-01-05 09:25:42" resolution="Fixed">
		<buginformation>
			<summary>IdempotentConsumer - If exception from repo it should be able to handle by onException</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Exception-from-idempotentConsumer-not-propagating-to-onException-tp5775779.html</description>
			<version>2.15.5</version>
			<fixedVersion>2.15.6, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.idempotent.IdempotentConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9491" opendate="2016-01-08 08:20:38" fixdate="2016-01-08 17:00:08" resolution="Fixed">
		<buginformation>
			<summary>statement.maxRows not working as expected camel jdbc </summary>
			<description>I have tested in
multiple versio*n i.e. 2.15.1,2.16.0,2.16.1 *also but still the same issue.
Camel JDBC component  statement.maxRows is not respected when query is fired repeatedly using a timer. It works fine only on the first run of the route after that the query gets all the records.</description>
			<version>2.16.1</version>
			<fixedVersion>2.15.6, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jdbc.JdbcProducer.java</file>
			<file type="M">org.apache.camel.component.jdbc.JdbcFix9491Test.java</file>
		</fixedFiles>
	</bug>
	<bug id="9281" opendate="2015-11-01 15:21:51" fixdate="2016-01-09 14:38:09" resolution="Fixed">
		<buginformation>
			<summary>Http4 component removes trailing slashes from http requests (producer)</summary>
			<description>I have created a scenario which seems to exploit a bug in the HttpHelper createURL method.
My use case:
Using http4 component in an http proxy with bridgeEndpoint true
Send a request such as http://somesite/contextpath
Request is forwarded by my proxy to a tomcat server.  Tomcat will reply with a 302 and a new Location of http://somesite/contextpath/ as this is a built in behavior of tomcat to redirect the caller to the contextpath INCLUDING the trailing slash
I have http client configured with httpClient.redirectsEnabled=false
Therefore the 302 is sent back through my proxy to the caller.
The caller then makes the call to http://somesite/contextpath/
This is where the problem occurs,  within the createUrl method:


        String path = exchange.getIn().getHeader(Exchange.HTTP_PATH, String.class);
        // NOW the HTTP_PATH is just related path, we don&amp;amp;apos;t need to trim it
        if (path != null) {
            if (path.startsWith("/")) {
                path = path.substring(1);
            }
            if (path.length() &amp;gt; 0) {
                // make sure that there is exactly one "/" between HTTP_URI and
                // HTTP_PATH
                if (!uri.endsWith("/")) {
                    uri = uri + "/";
                }
                uri = uri.concat(path);
            }
        }


When the second request is made with the trailing slash, the string "path" is / (just a single forward slash)
This hits the first conditional and results in true, which the following substring then removes this slash.
Now path.length() is not &amp;gt; 0 so the second conditional evaluates false.
And we end up with a uri returned that no longer has the trailing slash.
This is sent to Tomcat, Tomcat then promptly returns another 302 and a redirect loop is created.
I think the intent of this block of code is to combine the uri and path and make sure there isn&amp;amp;apos;t a duplicate forward slash?
So the simplest fix I can suggest would be something like


        String path = exchange.getIn().getHeader(Exchange.HTTP_PATH, String.class);
        // NOW the HTTP_PATH is just related path, we don&amp;amp;apos;t need to trim it
        if (path != null &amp;amp;&amp;amp; ! path.equals("/")) {
            if (path.startsWith("/")) {
                path = path.substring(1);
            }
            if (path.length() &amp;gt; 0) {
                // make sure that there is exactly one "/" between HTTP_URI and
                // HTTP_PATH
                if (!uri.endsWith("/")) {
                    uri = uri + "/";
                }
                uri = uri.concat(path);
            }
        }


Where we would just check for this case explicitly with:
if (path != null &amp;amp;&amp;amp; ! path.equals("/")) {
Thoughts?
I could probably put together a PR and add some test cases</description>
			<version>2.15.4</version>
			<fixedVersion>2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http4.helper.HttpHelperTest.java</file>
			<file type="M">org.apache.camel.http.common.HttpHelper.java</file>
			<file type="M">org.apache.camel.component.http.helper.HttpHelperTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9106" opendate="2015-08-30 15:01:15" fixdate="2016-01-09 14:52:11" resolution="Fixed">
		<buginformation>
			<summary>URI option mapMailMessage doesn&amp;apos;t obey peek=true option</summary>
			<description>URI option mapMailMessage=true as is the default with Mail Component fetches IMAP-messages without peek=true option. This results to faulty rollback logic since in case of an exception and rollback, messages are already marked with flag SEEN and won&amp;amp;apos;t be rolled back to UNSEEN.
Messages are marked with peek-option in processBatch-method but mapping mail messages to Camel messages happens before that method call in createExchanges-method.
I&amp;amp;apos;ve attached a patch where peek option is set to the messages already in the poll-method which resolves the issue. Unfortunately I couldn&amp;amp;apos;t write a proper jUnit test for this scenario since org.jvnet.mock_javamail.Mailbox doesn&amp;amp;apos;t seem to support marking messages as SEEN even if they have been fetched.  However, I have attached traces of faulty and fixed run with a test route (that route is also included).</description>
			<version>2.15.3</version>
			<fixedVersion>2.15.6, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9503" opendate="2016-01-12 10:06:09" fixdate="2016-01-12 10:08:27" resolution="Fixed">
		<buginformation>
			<summary>OnCompletion - restores the rollback only last in the wrong key</summary>
			<description></description>
			<version>2.16.1</version>
			<fixedVersion>2.15.6, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.OnCompletionProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="9505" opendate="2016-01-12 11:39:52" fixdate="2016-01-13 13:15:12" resolution="Fixed">
		<buginformation>
			<summary>RabbitMQConsumer don&amp;apos;t use Camel ExceptionHandler BEFORE requeing message</summary>
			<description>The use case is :
onException(NotHandledException.class)
   .handled(false)
   .log("Exception not handled");
onException(HandledException.class)
   .handled(true)
   .log("Exception handled");
from("rabbitmq://...&amp;amp;autoAck=false")
   .setHeader(RabbitMQConstants.REQUEUE, constant(true))
   .to(...);
If the route generate a NotHandledException, the message is requeue in RabbitMQ, it works fine.
If the route generate a HandledException, the message is requeue in RabbitMQ before the execution of Camel ExceptionHandler wich should handle the exception and should not propagate it. 
The message handled by Camel ExceptionHandler should not be requeue in RabbitMQ since the exception is handled.
The related code is in :
org.apache.camel.component.rabbitmq.RabbitConsumer.handleDelivery
Maybe this line :
getExceptionHandler().handleException("Error processing exchange", exchange, exchange.getException());
should be before :
if (deliveryTag != 0 &amp;amp;&amp;amp; !consumer.endpoint.isAutoAck()) {
   log.trace("Rejecting receipt [delivery_tag={}] with requeue={}", deliveryTag, isRequeueHeaderSet);
   if (isRequeueHeaderSet) 
{
      channel.basicReject(deliveryTag, true);
   }
 else 
{
      channel.basicReject(deliveryTag, false);
   }
}
</description>
			<version>2.16.1</version>
			<fixedVersion>2.15.6, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQConsumer.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQRequeueIntTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9509" opendate="2016-01-13 09:12:11" fixdate="2016-01-14 17:00:07" resolution="Fixed">
		<buginformation>
			<summary>camel-cometd is not working with camel 2.15.2</summary>
			<description>I see that the Jetty server is getting stopped as soon as it was started. See the log below:
08:59:23.229 [default] [main] DEBUG o.a.c.m.DefaultManagementAgent - Registered MBean with ObjectName: org.apache.camel:context=camel-1,type=tracer,name=BacklogDebugger 
08:59:23.233 [default] [main] DEBUG o.a.c.p.interceptor.DefaultChannel - Initialize channel for target: &amp;amp;apos;SetHeader[Exception, simple{${exception.message}}]&amp;amp;apos; 
08:59:23.257 [default] [main] DEBUG o.a.c.m.DefaultManagementAgent - Registered MBean with ObjectName: org.apache.camel:context=camel-1,type=errorhandlers,name="DefaultErrorHandlerBuilder(ref:CamelDefaultErrorHandlerBuilder)" 
08:59:23.260 [default] [main] DEBUG o.a.c.p.interceptor.DefaultChannel - Initialize channel for target: &amp;amp;apos;RecipientList[simple{activemq:DLQ.$
{exchangeProperty.Queue},bean:metoEnvironmentHealthIndicator}]&amp;amp;apos; 
08:59:23.261 [default] [main] DEBUG org.apache.camel.model.LogDefinition - The LogName is null. Falling back to create logger by using the route id cometdRoute. 
08:59:23.261 [default] [main] DEBUG o.a.c.p.interceptor.DefaultChannel - Initialize channel for target: &amp;amp;apos;Log[Sending message to Cometd]&amp;amp;apos; 
08:59:23.265 [default] [main] DEBUG o.a.camel.spring.SpringCamelContext - Using ComponentResolver: org.apache.camel.impl.DefaultComponentResolver@1e308cc to resolve component with name: cometd 
08:59:23.265 [default] [main] DEBUG o.s.b.f.s.DefaultListableBeanFactory - Returning cached instance of singleton bean &amp;amp;apos;cometd&amp;amp;apos; 
08:59:23.265 [default] [main] DEBUG o.a.c.impl.DefaultComponentResolver - Found component: cometd in registry: mydomain.service.tada_messaging.DefaultActiveMqConfiguration$1@ff6bd5 
08:59:23.265 [default] [main] DEBUG o.a.c.m.DefaultManagementAgent - Registered MBean with ObjectName: org.apache.camel:context=camel-1,type=components,name="cometd" 
08:59:23.266 [default] [main] DEBUG o.apache.camel.impl.DefaultComponent - Creating endpoint uri=[cometd://0.0.0.0:9999/cometdBroadcastChannel], path=[0.0.0.0:9999/cometdBroadcastChannel] 
08:59:23.266 [default] [main] DEBUG o.a.camel.spring.SpringCamelContext - cometd://0.0.0.0:9999/cometdBroadcastChannel converted to endpoint: Endpoint[cometd://0.0.0.0:9999/cometdBroadcastChannel] by component: mydomain.service.tada_messaging.DefaultActiveMqConfiguration$1@ff6bd5 
08:59:23.268 [default] [main] DEBUG o.a.c.p.interceptor.DefaultChannel - Initialize channel for target: &amp;amp;apos;To[cometd://0.0.0.0:9999/cometdBroadcastChannel]&amp;amp;apos; 
08:59:23.271 [default] [main] DEBUG o.a.c.m.DefaultManagementAgent - Registered MBean with ObjectName: org.apache.camel:context=camel-1,type=services,name=MetricsRoutePolicy(0x1fa486) 
08:59:23.277 [default] [main] DEBUG o.a.c.m.DefaultManagementAgent - Registered MBean with ObjectName: org.apache.camel:context=camel-1,type=services,name=MetricsRegistryService 
08:59:23.277 [default] [main] DEBUG o.s.b.f.s.DefaultListableBeanFactory - Returning cached instance of singleton bean &amp;amp;apos;metricRegistry&amp;amp;apos; 
08:59:23.294 [default] [main] INFO  o.a.camel.spring.SpringCamelContext - AllowUseOriginalMessage is enabled. If access to the original message is not needed, then its recommended to turn this option off as it may improve performance. 
08:59:23.294 [default] [main] INFO  o.a.camel.spring.SpringCamelContext - StreamCaching is not in use. If using streams then its recommended to enable stream caching. See more details at http://camel.apache.org/stream-caching.html 
08:59:23.295 [default] [main] DEBUG o.a.camel.spring.SpringCamelContext - Warming up route id: cometdRoute having autoStartup=true 
08:59:23.295 [default] [main] DEBUG org.apache.camel.impl.RouteService - Starting services on route: cometdRoute 
08:59:23.302 [default] [main] DEBUG o.a.c.component.jms.JmsQueueEndpoint - Using destinationName: MyBroadcastQueue on listenerContainer: org.apache.camel.component.jms.DefaultJmsMessageListenerContainer@1ce9dc5 
08:59:23.306 [default] [main] DEBUG o.a.c.m.DefaultManagementAgent - Registered MBean with ObjectName: org.apache.camel:context=camel-1,type=threadpools,name="JmsConsumer(0xdd070a)" 
08:59:23.306 [default] [main] DEBUG o.a.c.i.DefaultExecutorServiceManager - Created new CachedThreadPool for source: Consumer[activemq://MyBroadcastQueue] with name: JmsConsumer[MyBroadcastQueue]. -&amp;gt; java.util.concurrent.ThreadPoolExecutor@f92404[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0] 
08:59:23.307 [default] [main] DEBUG org.apache.camel.impl.RouteService - Starting child service on route: cometdRoute -&amp;gt; Pipeline[[Channel[Log(cometdRoute)[Sending message to Cometd]], Channel[sendTo(Endpoint[cometd://0.0.0.0:9999/cometdBroadcastChannel])]]] 
08:59:23.307 [default] [main] DEBUG o.a.c.processor.DefaultErrorHandler - Redelivery enabled: false on error handler: DefaultErrorHandler[EvalExpression[Simple: activemq:DLQ.${exchangeProperty.Queue}
,bean:metoEnvironmentHealthIndicator]] 
08:59:23.307 [default] [main] DEBUG o.a.camel.processor.RecipientList - RecipientList RecipientList[Simple: activemq:DLQ.$
{exchangeProperty.Queue}
,bean:metoEnvironmentHealthIndicator] using ProducerCache with default cache size 
08:59:23.307 [default] [main] DEBUG o.a.c.processor.DefaultErrorHandler - Redelivery enabled: false on error handler: DefaultErrorHandler[Instrumentation:log[Log(cometdRoute)[Sending message to Cometd]]] 
08:59:23.311 [default] [main] DEBUG o.a.c.m.DefaultManagementAgent - Registered MBean with ObjectName: org.apache.camel:context=camel-1,type=producers,name=CometdProducer(0x1908a5c) 
08:59:23.321 [default] [main] DEBUG org.eclipse.jetty.util.log - Logging to Logger[org.eclipse.jetty.util.log] via org.eclipse.jetty.util.log.Slf4jLog 
08:59:23.328 [default] [main] DEBUG o.e.jetty.util.component.Container - Container org.eclipse.jetty.server.Server@141651e + org.eclipse.jetty.server.handler.ContextHandlerCollection@55bf45 as handler 
08:59:23.329 [default] [main] DEBUG o.e.jetty.util.component.Container - Container org.eclipse.jetty.server.Server@141651e + SelectChannelConnector@0.0.0.0:9999 as connector 
08:59:23.345 [default] [main] DEBUG o.e.jetty.util.component.Container - Container org.eclipse.jetty.server.Server@141651e - org.eclipse.jetty.server.handler.ContextHandlerCollection@55bf45 as handler 
08:59:23.345 [default] [main] DEBUG o.e.jetty.util.component.Container - Container org.eclipse.jetty.server.Server@141651e + o.e.j.s.ServletContextHandler
{/,null} as handler 
08:59:23.356 [default] [main] DEBUG o.e.jetty.servlet.ServletHandler - filterNameMap={} 
08:59:23.357 [default] [main] DEBUG o.e.jetty.servlet.ServletHandler - pathFilters=null 
08:59:23.357 [default] [main] DEBUG o.e.jetty.servlet.ServletHandler - servletFilterMap=null 
08:59:23.357 [default] [main] DEBUG o.e.jetty.servlet.ServletHandler - servletPathMap={/cometd/*=org.cometd.server.CometdServlet-c5fe9b} 
08:59:23.357 [default] [main] DEBUG o.e.jetty.servlet.ServletHandler - servletNameMap={org.cometd.server.CometdServlet-c5fe9b=org.cometd.server.CometdServlet-c5fe9b} 
08:59:23.357 [default] [main] DEBUG o.e.jetty.servlet.ServletHandler - filterNameMap={} 
08:59:23.357 [default] [main] DEBUG o.e.jetty.servlet.ServletHandler - pathFilters=null 
08:59:23.357 [default] [main] DEBUG o.e.jetty.servlet.ServletHandler - servletFilterMap=null 
08:59:23.357 [default] [main] DEBUG o.e.jetty.servlet.ServletHandler - servletPathMap={/cometd/*=org.cometd.server.CometdServlet-c5fe9b, /=org.eclipse.jetty.servlet.DefaultServlet-17ca83e} 
08:59:23.357 [default] [main] DEBUG o.e.jetty.servlet.ServletHandler - servletNameMap={org.cometd.server.CometdServlet-c5fe9b=org.cometd.server.CometdServlet-c5fe9b, org.eclipse.jetty.servlet.DefaultServlet-17ca83e=org.eclipse.jetty.servlet.DefaultServlet-17ca83e} 
08:59:23.365 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - starting org.eclipse.jetty.server.Server@141651e 
08:59:23.367 [default] [main] INFO  org.eclipse.jetty.server.Server - jetty-8.1.18.v20150929 
08:59:23.381 [default] [main] DEBUG o.e.jetty.util.component.Container - Container org.eclipse.jetty.server.Server@141651e + qtp16541084{8&amp;lt;=0&amp;lt;=0/254,-1} as threadpool 
08:59:23.381 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - starting o.e.j.s.ServletContextHandler{/,null}
 
08:59:23.394 [default] [main] DEBUG o.e.jetty.util.component.Container - Container org.eclipse.jetty.servlet.ServletHandler@1aed797 + org.cometd.server.CometdServlet-c5fe9b as servlet 
08:59:23.394 [default] [main] DEBUG o.e.jetty.util.component.Container - Container org.eclipse.jetty.servlet.ServletHandler@1aed797 + org.eclipse.jetty.servlet.DefaultServlet-17ca83e as servlet 
08:59:23.394 [default] [main] DEBUG o.e.jetty.util.component.Container - Container org.eclipse.jetty.servlet.ServletHandler@1aed797 + [/cometd/*]=&amp;gt;org.cometd.server.CometdServlet-c5fe9b as servletMapping 
08:59:23.394 [default] [main] DEBUG o.e.jetty.util.component.Container - Container org.eclipse.jetty.servlet.ServletHandler@1aed797 + [/]=&amp;gt;org.eclipse.jetty.servlet.DefaultServlet-17ca83e as servletMapping 
08:59:23.394 [default] [main] DEBUG o.e.jetty.util.component.Container - Container org.eclipse.jetty.server.session.SessionHandler@1cc1503 + org.eclipse.jetty.servlet.ServletHandler@1aed797 as handler 
08:59:23.394 [default] [main] DEBUG o.e.jetty.util.component.Container - Container org.eclipse.jetty.server.session.SessionHandler@1cc1503 + org.eclipse.jetty.server.session.HashSessionManager@1778636 as sessionManager 
08:59:23.394 [default] [main] DEBUG o.e.jetty.util.component.Container - Container o.e.j.s.ServletContextHandler
{/,null} + org.eclipse.jetty.server.session.SessionHandler@1cc1503 as handler 
08:59:23.394 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - starting org.eclipse.jetty.server.session.SessionHandler@1cc1503 
08:59:23.394 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - starting org.eclipse.jetty.server.session.HashSessionManager@1778636 
08:59:23.395 [default] [main] DEBUG o.e.jetty.util.component.Container - Container org.eclipse.jetty.server.Server@141651e + org.eclipse.jetty.server.session.HashSessionIdManager@1397822 as sessionIdManager 
08:59:23.395 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - starting org.eclipse.jetty.server.session.HashSessionIdManager@1397822 
08:59:23.395 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED org.eclipse.jetty.server.session.HashSessionIdManager@1397822 
08:59:23.396 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED org.eclipse.jetty.server.session.HashSessionManager@1778636 
08:59:23.396 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - starting org.eclipse.jetty.servlet.ServletHandler@1aed797 
08:59:23.396 [default] [main] DEBUG o.e.jetty.servlet.ServletHandler - filterNameMap={} 
08:59:23.396 [default] [main] DEBUG o.e.jetty.servlet.ServletHandler - pathFilters=null 
08:59:23.396 [default] [main] DEBUG o.e.jetty.servlet.ServletHandler - servletFilterMap=null 
08:59:23.396 [default] [main] DEBUG o.e.jetty.servlet.ServletHandler - servletPathMap={/cometd/*=org.cometd.server.CometdServlet-c5fe9b, /=org.eclipse.jetty.servlet.DefaultServlet-17ca83e} 
08:59:23.396 [default] [main] DEBUG o.e.jetty.servlet.ServletHandler - servletNameMap={org.cometd.server.CometdServlet-c5fe9b=org.cometd.server.CometdServlet-c5fe9b, org.eclipse.jetty.servlet.DefaultServlet-17ca83e=org.eclipse.jetty.servlet.DefaultServlet-17ca83e} 
08:59:23.396 [default] [main] DEBUG o.e.j.server.handler.AbstractHandler - starting org.eclipse.jetty.servlet.ServletHandler@1aed797 
08:59:23.396 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED org.eclipse.jetty.servlet.ServletHandler@1aed797 
08:59:23.396 [default] [main] DEBUG o.e.j.server.handler.AbstractHandler - starting org.eclipse.jetty.server.session.SessionHandler@1cc1503 
08:59:23.396 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED org.eclipse.jetty.server.session.SessionHandler@1cc1503 
08:59:23.396 [default] [main] DEBUG o.e.j.server.handler.AbstractHandler - starting o.e.j.s.ServletContextHandler{/,null}
 
08:59:23.396 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - starting org.cometd.server.CometdServlet-c5fe9b 
08:59:23.415 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - starting org.cometd.server.BayeuxServerImpl@868937 
08:59:23.415 [default] [main] WARN  o.c.server.BayeuxServerImpl@8816951 - setDebugEnabled not implemented 
08:59:23.415 [default] [main] INFO  o.c.server.BayeuxServerImpl@8816951 - JSONCommented=true 
08:59:23.415 [default] [main] INFO  o.c.server.BayeuxServerImpl@8816951 - interval=0 
08:59:23.415 [default] [main] INFO  o.c.server.BayeuxServerImpl@8816951 - logLevel=1 
08:59:23.415 [default] [main] INFO  o.c.server.BayeuxServerImpl@8816951 - maxInterval=30000 
08:59:23.415 [default] [main] INFO  o.c.server.BayeuxServerImpl@8816951 - multiFrameInterval=1500 
08:59:23.415 [default] [main] INFO  o.c.server.BayeuxServerImpl@8816951 - timeout=240000 
08:59:23.417 [default] [main] DEBUG o.c.server.BayeuxServerImpl@8816951 - Added channel /meta 
08:59:23.418 [default] [main] DEBUG o.c.server.BayeuxServerImpl@8816951 - Added channel /meta/handshake 
08:59:23.418 [default] [main] DEBUG o.c.server.BayeuxServerImpl@8816951 - Added channel /meta/connect 
08:59:23.418 [default] [main] DEBUG o.c.server.BayeuxServerImpl@8816951 - Added channel /meta/subscribe 
08:59:23.418 [default] [main] DEBUG o.c.server.BayeuxServerImpl@8816951 - Added channel /meta/unsubscribe 
08:59:23.418 [default] [main] DEBUG o.c.server.BayeuxServerImpl@8816951 - Added channel /meta/disconnect 
08:59:23.420 [default] [main] DEBUG o.c.server.BayeuxServerImpl@8816951 - Allowed Transports: [callback-polling, long-polling] 
08:59:23.421 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED org.cometd.server.BayeuxServerImpl@868937 
08:59:23.421 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED org.cometd.server.CometdServlet-c5fe9b 
08:59:23.421 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - starting org.eclipse.jetty.servlet.DefaultServlet-17ca83e 
08:59:23.423 [default] [main] DEBUG org.eclipse.jetty.servlet.Holder - Holding class org.eclipse.jetty.servlet.DefaultServlet 
08:59:23.423 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED org.eclipse.jetty.servlet.DefaultServlet-17ca83e 
08:59:23.423 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED o.e.j.s.ServletContextHandler
{/,null} 
08:59:23.423 [default] [main] DEBUG o.e.j.server.handler.AbstractHandler - starting org.eclipse.jetty.server.Server@141651e 
08:59:23.423 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - starting qtp16541084{8&amp;lt;=0&amp;lt;=0/254,-1} 
08:59:23.424 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED qtp16541084{8&amp;lt;=7&amp;lt;=8/254,0} 
08:59:23.424 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - starting SelectChannelConnector@0.0.0.0:9999 
08:59:23.428 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - starting null/null 
08:59:23.429 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED PooledBuffers [0/1024@6144,0/1024@16384,0/1024@-]/PooledBuffers [0/1024@6144,0/1024@32768,0/1024@-] 
08:59:23.429 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - starting org.eclipse.jetty.server.nio.SelectChannelConnector$ConnectorSelectorManager@1e36e5e 
08:59:23.436 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED org.eclipse.jetty.server.nio.SelectChannelConnector$ConnectorSelectorManager@1e36e5e 
08:59:23.436 [default] [qtp16541084-30 Selector0] DEBUG org.eclipse.jetty.io.nio - Starting Thread[qtp16541084-30 Selector0,5,main] on org.eclipse.jetty.io.nio.SelectorManager$1@13b4f4c 
08:59:23.437 [default] [main] INFO  o.e.jetty.server.AbstractConnector - Started SelectChannelConnector@0.0.0.0:9999 
08:59:23.437 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED SelectChannelConnector@0.0.0.0:9999 
08:59:23.437 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STARTED org.eclipse.jetty.server.Server@141651e 
08:59:23.453 [default] [main] DEBUG o.c.server.BayeuxServerImpl@8816951 - &amp;gt;  {"id":"1","channel":"/meta/handshake"} /cometdBroadcastChannel_1ps6caf8lxivw14tib5lvs74mx 
08:59:23.453 [default] [main] DEBUG o.c.server.BayeuxServerImpl@8816951 - &amp;gt;&amp;gt; {"id":"1","channel":"/meta/handshake"} 
08:59:23.454 [default] [main] DEBUG o.c.server.BayeuxServerImpl@8816951 - &amp;lt;&amp;lt; {"id":"1","minimumVersion":"1.0","supportedConnectionTypes":["callback-polling","long-polling"],"successful":true,"channel":"/meta/handshake","clientId":"/cometdBroadcastChannel_1ps6caf8lxivw14tib5lvs74mx","version":"1.0"} 
08:59:23.454 [default] [main] DEBUG o.c.server.BayeuxServerImpl@8816951 - &amp;lt;  {"id":"1","minimumVersion":"1.0","supportedConnectionTypes":["callback-polling","long-polling"],"successful":true,"channel":"/meta/handshake","clientId":"/cometdBroadcastChannel_1ps6caf8lxivw14tib5lvs74mx","version":"1.0"} 
08:59:23.455 [default] [main] DEBUG o.c.server.BayeuxServerImpl@8816951 - &amp;gt;  {"id":"2","advice":{"interval":-1},"channel":"/meta/connect","clientId":"/cometdBroadcastChannel_1ps6caf8lxivw14tib5lvs74mx"} /cometdBroadcastChannel_1ps6caf8lxivw14tib5lvs74mx 
08:59:23.455 [default] [main] DEBUG o.c.server.BayeuxServerImpl@8816951 - &amp;gt;&amp;gt; {"id":"2","advice":{"interval":-1},"channel":"/meta/connect","clientId":"/cometdBroadcastChannel_1ps6caf8lxivw14tib5lvs74mx"} 
08:59:23.455 [default] [main] DEBUG o.c.server.BayeuxServerImpl@8816951 - &amp;lt;&amp;lt; {"id":"2","successful":true,"channel":"/meta/connect"} 
08:59:23.455 [default] [main] DEBUG o.c.server.BayeuxServerImpl@8816951 - &amp;lt;  {"id":"2","successful":true,"channel":"/meta/connect"} 
08:59:23.456 [default] [main] DEBUG o.e.jetty.util.component.Container - Container org.eclipse.jetty.server.Server@141651e - SelectChannelConnector@0.0.0.0:9999 as connector 
08:59:23.456 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - stopping SelectChannelConnector@0.0.0.0:9999 
08:59:23.456 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - stopping org.eclipse.jetty.server.nio.SelectChannelConnector$ConnectorSelectorManager@1e36e5e 
08:59:23.457 [default] [qtp16541084-30 Selector0] DEBUG org.eclipse.jetty.io.nio - Stopped Thread[qtp16541084-30 Selector0,5,main] on org.eclipse.jetty.io.nio.SelectorManager$1@13b4f4c 
08:59:23.467 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STOPPED org.eclipse.jetty.server.nio.SelectChannelConnector$ConnectorSelectorManager@1e36e5e 
08:59:23.467 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - stopping PooledBuffers [0/1024@6144,0/1024@16384,0/1024@-]/PooledBuffers [0/1024@6144,0/1024@32768,0/1024@-] 
08:59:23.467 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STOPPED null/null 
08:59:23.468 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STOPPED SelectChannelConnector@0.0.0.0:9999 
08:59:23.468 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - stopping org.eclipse.jetty.server.Server@141651e 
08:59:23.468 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - stopping o.e.j.s.ServletContextHandler{/,null}
 
08:59:23.468 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - stopping org.eclipse.jetty.server.session.SessionHandler@1cc1503 
08:59:23.468 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - stopping org.eclipse.jetty.server.session.HashSessionManager@1778636 
08:59:23.468 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STOPPED org.eclipse.jetty.server.session.HashSessionManager@1778636 
08:59:23.468 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - stopping org.eclipse.jetty.servlet.ServletHandler@1aed797 
08:59:23.468 [default] [main] DEBUG o.e.j.server.handler.AbstractHandler - stopping org.eclipse.jetty.servlet.ServletHandler@1aed797 
08:59:23.469 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - stopping org.eclipse.jetty.servlet.DefaultServlet-17ca83e 
08:59:23.469 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STOPPED org.eclipse.jetty.servlet.DefaultServlet-17ca83e 
08:59:23.469 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - stopping org.cometd.server.CometdServlet-c5fe9b 
08:59:23.469 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - stopping org.cometd.server.BayeuxServerImpl@868937 
08:59:23.469 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STOPPED org.cometd.server.BayeuxServerImpl@868937 
08:59:23.470 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STOPPED org.cometd.server.CometdServlet-c5fe9b 
08:59:23.470 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STOPPED org.eclipse.jetty.servlet.ServletHandler@1aed797 
08:59:23.470 [default] [main] DEBUG o.e.j.server.handler.AbstractHandler - stopping org.eclipse.jetty.server.session.SessionHandler@1cc1503 
08:59:23.470 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STOPPED org.eclipse.jetty.server.session.SessionHandler@1cc1503 
08:59:23.470 [default] [main] DEBUG o.e.j.server.handler.AbstractHandler - stopping o.e.j.s.ServletContextHandler
{/,null} 
08:59:23.470 [default] [main] INFO  o.e.j.server.handler.ContextHandler - stopped o.e.j.s.ServletContextHandler{/,null}
 
08:59:23.470 [default] [main] DEBUG o.e.jetty.util.component.Container - Container o.e.j.s.ServletContextHandler
{/,null} - org.eclipse.jetty.server.session.SessionHandler@1cc1503 as handler 
08:59:23.470 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STOPPED o.e.j.s.ServletContextHandler{/,null}
 
08:59:23.470 [default] [main] DEBUG o.e.j.server.handler.AbstractHandler - stopping org.eclipse.jetty.server.Server@141651e 
08:59:23.470 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - stopping org.eclipse.jetty.server.session.HashSessionIdManager@1397822 
08:59:23.470 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STOPPED org.eclipse.jetty.server.session.HashSessionIdManager@1397822 
08:59:23.470 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - stopping qtp16541084
{8&amp;lt;=8&amp;lt;=8/254,0}
 
08:59:23.527 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STOPPED qtp16541084
{8&amp;lt;=0&amp;lt;=0/254,4}
 
08:59:23.527 [default] [main] DEBUG o.e.j.u.component.AbstractLifeCycle - STOPPED org.eclipse.jetty.server.Server@141651e 
08:59:23.527 [default] [main] DEBUG o.a.c.processor.DefaultErrorHandler - Redelivery enabled: false on error handler: DefaultErrorHandler[Instrumentation:to[sendTo(Endpoint[cometd://0.0.0.0:9999/cometdBroadcastChannel])]] 
08:59:23.527 [default] [main] DEBUG org.apache.camel.impl.RouteService - Starting child service on route: cometdRoute -&amp;gt; Pipeline[[Channel[Log(cometdRoute)[Sending message to Cometd]], Channel[sendTo(Endpoint[cometd://0.0.0.0:9999/cometdBroadcastChannel])]]] 
08:59:23.527 [default] [main] DEBUG org.apache.camel.impl.RouteService - Starting child service on route: cometdRoute -&amp;gt; Log(cometdRoute)[Sending message to Cometd] 
08:59:23.534 [default] [main] DEBUG o.a.c.m.DefaultManagementAgent - Registered MBean with ObjectName: org.apache.camel:context=camel-1,type=processors,name="log2" 
08:59:23.535 [default] [main] DEBUG org.apache.camel.impl.RouteService - Starting child service on route: cometdRoute -&amp;gt; Channel[Log(cometdRoute)[Sending message to Cometd]] 
08:59:23.535 [default] [main] DEBUG org.apache.camel.impl.RouteService - Starting child service on route: cometdRoute -&amp;gt; sendTo(Endpoint[cometd://0.0.0.0:9999/cometdBroadcastChannel]) 
08:59:23.541 [default] [main] DEBUG o.a.c.m.DefaultManagementAgent - Registered MBean with ObjectName: org.apache.camel:context=camel-1,type=processors,name="to1" 
08:59:23.541 [default] [main] DEBUG org.apache.camel.impl.RouteService - Starting child service on route: cometdRoute -&amp;gt; Channel[sendTo(Endpoint[cometd://0.0.0.0:9999/cometdBroadcastChannel])] 
08:59:23.548 [default] [main] DEBUG o.a.c.m.DefaultManagementAgent - Registered MBean with ObjectName: org.apache.camel:context=camel-1,type=routes,name="cometdRoute" 
08:59:23.548 [default] [main] DEBUG o.a.c.support.TimerListenerManager - Added TimerListener: org.apache.camel.management.mbean.ManagedSuspendableRoute@18afde8 
08:59:23.549 [default] [main] DEBUG o.a.camel.spring.SpringCamelContext - Route: cometdRoute &amp;gt;&amp;gt;&amp;gt; EventDrivenConsumerRoute[Endpoint[activemq://MyBroadcastQueue] -&amp;gt; Pipeline[[Channel[Log(cometdRoute)[Sending message to Cometd]], Channel[sendTo(Endpoint[cometd://0.0.0.0:9999/cometdBroadcastChannel])]]]] 
08:59:23.549 [default] [main] DEBUG o.a.camel.spring.SpringCamelContext - Starting consumer (order: 1000) on route: cometdRoute 
08:59:23.552 [default] [main] DEBUG o.a.c.m.DefaultManagementAgent - Registered MBean with ObjectName: org.apache.camel:context=camel-1,type=consumers,name=JmsConsumer(0xdd070a) 
08:59:23.552 [default] [main] DEBUG o.a.camel.component.jms.JmsConsumer - Starting consumer: Consumer[activemq://MyBroadcastQueue] 
08:59:23.555 [default] [main] DEBUG o.a.a.thread.TaskRunnerFactory - Initialized TaskRunnerFactoryActiveMQ VMTransport: vm://localhost#2 using ExecutorService: java.util.concurrent.ThreadPoolExecutor@4a7e7f[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0] 
08:59:23.555 [default] [ActiveMQ BrokerService[localhost] Task-2] DEBUG o.a.a.thread.TaskRunnerFactory - Initialized TaskRunnerFactoryActiveMQ VMTransport: vm://localhost#3 using ExecutorService: java.util.concurrent.ThreadPoolExecutor@b6fa5d[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0] 
08:59:23.557 [default] [main] DEBUG o.a.c.c.j.DefaultJmsMessageListenerContainer - Established shared JMS Connection 
08:59:23.558 [default] [main] DEBUG o.a.c.c.j.DefaultJmsMessageListenerContainer - Resumed paused task: org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker@9cef26 
08:59:23.558 [default] [main] DEBUG o.a.c.c.j.DefaultJmsMessageListenerContainer - Resumed paused task: org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker@118d229 
08:59:23.558 [default] [main] DEBUG o.a.c.c.j.DefaultJmsMessageListenerContainer - Resumed paused task: org.springframework.jms.listener.DefaultMessageListenerContainer$AsyncMessageListenerInvoker@8da115 
08:59:23.562 [default] ActiveMQ VMTransport: vm://localhost#3-1 DEBUG o.a.a.broker.TransportConnection - Setting up new connection id: ID:EXXHSLSY4J-59436-1452675561504-3:2, address: vm://localhost#2, info: ConnectionInfo 
{commandId = 1, responseRequired = true, connectionId = ID:EXXHSLSY4J-59436-1452675561504-3:2, clientId = ID:EXXHSLSY4J-59436-1452675561504-2:1, clientIp = null, userName = null, password = *****, brokerPath = null, brokerMasterConnector = false, manageable = true, clientMaster = true, faultTolerant = false, failoverReconnect = false}
 
08:59:23.674 [default] ActiveMQ VMTransport: vm://localhost#3-1 DEBUG o.a.a.broker.region.AbstractRegion - localhost adding destination: topic://ActiveMQ.Advisory.Connection 
08:59:23.688 [default] ActiveMQ VMTransport: vm://localhost#3-1 DEBUG o.a.a.broker.region.AbstractRegion - localhost adding consumer: ID:EXXHSLSY4J-59436-1452675561504-3:2:-1:1 for destination: ActiveMQ.Advisory.TempQueue,ActiveMQ.Advisory.TempTopic 
08:59:23.698 [default] [main] DEBUG o.a.camel.component.jms.JmsConsumer - Started listener container org.apache.camel.component.jms.DefaultJmsMessageListenerContainer@1ce9dc5 on destination MyBroadcastQueue 
08:59:23.698 [default] [main] INFO  o.a.camel.spring.SpringCamelContext - Route: cometdRoute started and consuming from: Endpoint[activemq://MyBroadcastQueue] 
08:59:23.698 [default] [main] DEBUG o.a.c.m.DefaultManagementLifecycleStrategy - Load performance statistics disabled 
08:59:23.698 [default] [main] INFO  o.a.camel.spring.SpringCamelContext - Total 1 routes, of which 1 is started. 
08:59:23.699 [default] [main] INFO  o.a.camel.spring.SpringCamelContext - Apache Camel 2.15.2 (CamelContext: camel-1) started in 0.645 seconds </description>
			<version>2.15.2</version>
			<fixedVersion>2.15.6, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cometd.CometdEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="9526" opendate="2016-01-20 20:22:48" fixdate="2016-01-20 20:26:35" resolution="Fixed">
		<buginformation>
			<summary>Blueprint depends-on can no longer contain multiple bean ids</summary>
			<description>Used to be able to do something like:


    &amp;lt;bean id="id1" class="java.lang.Object"/&amp;gt;
    &amp;lt;bean id="id2" class="java.lang.Object"/&amp;gt;

    &amp;lt;camelContext xmlns="http://camel.apache.org/schema/blueprint" id="testCamelContext" depends-on="id1 id2"/&amp;gt;


Now as of 2.16 and 2.15.3 we get the following:


2016-01-20 16:44:07,541 | ERROR | rint Extender: 1 | BlueprintContainerImpl           | 12 - org.apache.aries.blueprint.core - 1.4.3 | Unable to start blueprint container for bundle camelContext.xml
org.osgi.service.blueprint.container.ComponentDefinitionException: Unresolved ref/idref to component: id1 id2
	at org.apache.aries.blueprint.container.BlueprintRepository.validate(BlueprintRepository.java:262)[12:org.apache.aries.blueprint.core:1.4.3]
	at org.apache.aries.blueprint.container.RecipeBuilder.createRepository(RecipeBuilder.java:96)[12:org.apache.aries.blueprint.core:1.4.3]
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.getRepository(BlueprintContainerImpl.java:481)[12:org.apache.aries.blueprint.core:1.4.3]
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.doRun(BlueprintContainerImpl.java:328)[12:org.apache.aries.blueprint.core:1.4.3]
	at org.apache.aries.blueprint.container.BlueprintContainerImpl.run(BlueprintContainerImpl.java:269)[12:org.apache.aries.blueprint.core:1.4.3]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)[:1.8.0_60]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)[:1.8.0_60]
	at org.apache.aries.blueprint.container.ExecutorServiceWrapper.run(ExecutorServiceWrapper.java:106)[12:org.apache.aries.blueprint.core:1.4.3]
	at org.apache.aries.blueprint.utils.threading.impl.DiscardableRunnable.run(DiscardableRunnable.java:48)[12:org.apache.aries.blueprint.core:1.4.3]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)[:1.8.0_60]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)[:1.8.0_60]
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)[:1.8.0_60]
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)[:1.8.0_60]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)[:1.8.0_60]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)[:1.8.0_60]
	at java.lang.Thread.run(Thread.java:745)[:1.8.0_60]

</description>
			<version>2.15.3</version>
			<fixedVersion>2.15.6, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.blueprint.handler.CamelNamespaceHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="9527" opendate="2016-01-24 11:14:52" fixdate="2016-01-24 11:50:47" resolution="Fixed">
		<buginformation>
			<summary>camel-netty4 - Should not log stacktrace when client has received reply</summary>
			<description>If you do request/reply over netty4 you may get a stacktace in the logs even if a message was received and the channel was closed when the server stops etc.


[l-1) thread #33 - ShutdownTask] DefaultShutdownStrategy        INFO  Route: route1 shutdown complete, was consuming from: Endpoint[direct://start]
[                          main] DefaultShutdownStrategy        INFO  Graceful shutdown of 2 routes completed in 0 seconds
]

Message History
---------------------------------------------------------------------------------------------------------------------------------------
RouteId              ProcessorId          Processor                                                                        Elapsed (ms)
[route1            ] [route1            ] [direct://start                                                                ] [     29673]
[route1            ] [to1               ] [netty4:tcp://127.0.0.1:8888?sync=true&amp;amp;decoder=#hl7decoder&amp;amp;encoder=#hl7encoder ] [     29668]
[route1            ] [process1          ] [Processor@0x484094a5                                                          ] [     28571]
[route1            ] [to2               ] [log:foo                                                                       ] [         3]
[route1            ] [to3               ] [mock:result                                                                   ] [         0]

Exchange
---------------------------------------------------------------------------------------------------------------------------------------
Exchange[
	Id                  ID-davsclaus-air-56167-1453631664458-0-2
	ExchangePattern     InOut
	Headers             {breadcrumbId=ID-davsclaus-air-56167-1453631664458-0-1, CamelRedelivered=false, CamelRedeliveryCounter=0}
	BodyType            String
QRD|20080805120000
]

Stacktrace
---------------------------------------------------------------------------------------------------------------------------------------
org.apache.camel.CamelExchangeException: No response received from remote server: 127.0.0.1:8888. Exchange[ID-davsclaus-air-56167-1453631664458-0-2][Message: MSH|^~\&amp;amp;|MYSENDER||||200701011539||ADR^A19^ADR_A19|456|P|2.4
MSA|AA|123
QRD|20080805120000
]
	at org.apache.camel.component.netty4.handlers.ClientChannelHandler.channelInactive(ClientChannelHandler.java:126)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:218)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:204)
	at io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:332)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:218)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:204)
	at io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:828)
	at io.netty.channel.AbstractChannel$AbstractUnsafe$7.run(AbstractChannel.java:625)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:358)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:357)
	at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:112)
	at java.lang.Thread.run(Thread.java:745)
[                          main] DefaultCamelContext            INFO  Apache Camel 2.17-SNAPSHOT (CamelContext: camel-1) uptime 30.572 seconds


</description>
			<version>2.16.2</version>
			<fixedVersion>2.15.6, 2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty.handlers.ClientChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty4.handlers.ClientChannelHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="9532" opendate="2016-01-25 19:01:27" fixdate="2016-01-26 08:49:35" resolution="Fixed">
		<buginformation>
			<summary>Default value given in RestOperationParamDefinition not output in swagger api</summary>
			<description>When I specify a default value in a rest param definition, the default value is not output in the swagger API. For example:


rest().put("{accountNumber}")
  .param()
    .name("type")
    .type(RestParamType.query)
    .description("The type of account to update.")
    .defaultValue("MDM")
  .endParam()
  .to("direct:foo");


Will output the following Swagger API fragment:


{
"name": "type",
"in": "query",
"description": "The type of account to update.",
"required": true,
"type": "string"
}

</description>
			<version>2.16.1</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.swagger.RestSwaggerReader.java</file>
			<file type="M">org.apache.camel.swagger.RestSwaggerReaderDayOfWeekTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9543" opendate="2016-01-28 03:19:25" fixdate="2016-01-28 03:25:29" resolution="Fixed">
		<buginformation>
			<summary>Discovering new type converters in OSGi wipes out those manually added</summary>
			<description>When adding a type converter manually like:


getContext().getTypeConverterRegistry().addTypeConverter(A.class, B.class, new ABConverter()); 


It gets removed from the type converter registry when a new type converter is discovered in a newly installed bundle. (Like when you install camel-hl7 feature in Karaf say).</description>
			<version>2.15.5</version>
			<fixedVersion>2.15.6, 2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.core.osgi.OsgiTypeConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="8742" opendate="2015-05-05 06:45:06" fixdate="2016-01-28 08:26:38" resolution="Fixed">
		<buginformation>
			<summary>RabbitMqConsumer did not retry if connection failed</summary>
			<description>Camel Rabbitmq is used to consume a queue in RabbitMQ. 
Sometimes, the Administrator would delete the queue and create a fresh queue. Or, the Camel container was started while all or some queue was not declared.
During these period, Camel will fail with the following error:

[localhost-startStop-1] 14:03:31,824 INFO  org.apache.camel.component.rabbitmq.RabbitMQConsumer - Connection failed, will start background thread to retry!
java.io.IOException
	at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:106)
	at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:102)
	at com.rabbitmq.client.impl.ChannelN.basicConsume(ChannelN.java:976)
	at com.rabbitmq.client.impl.ChannelN.basicConsume(ChannelN.java:943)
	at com.rabbitmq.client.impl.ChannelN.basicConsume(ChannelN.java:935)
	at org.apache.camel.component.rabbitmq.RabbitMQConsumer$RabbitConsumer.start(RabbitMQConsumer.java:285)
	at org.apache.camel.component.rabbitmq.RabbitMQConsumer.startConsumer(RabbitMQConsumer.java:109)
	at org.apache.camel.component.rabbitmq.RabbitMQConsumer.startConsumers(RabbitMQConsumer.java:96)
	at org.apache.camel.component.rabbitmq.RabbitMQConsumer.doStart(RabbitMQConsumer.java:119)
	at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:61)
	at org.apache.camel.impl.DefaultCamelContext.startService(DefaultCamelContext.java:2869)
	at org.apache.camel.impl.DefaultCamelContext.doStartOrResumeRouteConsumers(DefaultCamelContext.java:3163)
	at org.apache.camel.impl.DefaultCamelContext.doStartRouteConsumers(DefaultCamelContext.java:3099)
	at org.apache.camel.impl.DefaultCamelContext.safelyStartRouteServices(DefaultCamelContext.java:3029)
	at org.apache.camel.impl.DefaultCamelContext.doStartOrResumeRoutes(DefaultCamelContext.java:2797)
	at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:2653)
	at org.apache.camel.impl.DefaultCamelContext.access$000(DefaultCamelContext.java:167)
	at org.apache.camel.impl.DefaultCamelContext$2.call(DefaultCamelContext.java:2467)
	at org.apache.camel.impl.DefaultCamelContext$2.call(DefaultCamelContext.java:2463)
	at org.apache.camel.impl.DefaultCamelContext.doWithDefinedClassLoader(DefaultCamelContext.java:2486)
	at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:2463)
	at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:61)
	at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:2432)
	at org.apache.camel.spring.SpringCamelContext.maybeStart(SpringCamelContext.java:255)
	at org.apache.camel.spring.SpringCamelContext.onApplicationEvent(SpringCamelContext.java:121)
	at org.apache.camel.spring.CamelContextFactoryBean.onApplicationEvent(CamelContextFactoryBean.java:332)
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:96)
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:334)
	at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:948)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482)
	at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:389)
	at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:294)
	at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:112)
	at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4973)
	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5467)
	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)
	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:901)
	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:877)
	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:632)
	at org.apache.catalina.startup.HostConfig.deployDescriptor(HostConfig.java:670)
	at org.apache.catalina.startup.HostConfig$DeployDescriptor.run(HostConfig.java:1839)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)
	at java.util.concurrent.FutureTask.run(FutureTask.java:262)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
	at java.lang.Thread.run(Thread.java:745)
Caused by: com.rabbitmq.client.ShutdownSignalException: channel error; reason: {#method&amp;lt;channel.close&amp;gt;(reply-code=404, reply-text=NOT_FOUND - no queue &amp;amp;apos;ad_google_dfa_reporting_queue&amp;amp;apos; in vhost &amp;amp;apos;/&amp;amp;apos;, class-id=60, method-id=20), null, ""}
	at com.rabbitmq.utility.ValueOrException.getValue(ValueOrException.java:67)
	at com.rabbitmq.utility.BlockingValueOrException.uninterruptibleGetValue(BlockingValueOrException.java:33)
	at com.rabbitmq.client.impl.AMQChannel$BlockingRpcContinuation.getReply(AMQChannel.java:343)
	at com.rabbitmq.client.impl.ChannelN.basicConsume(ChannelN.java:974)
	... 43 more
Caused by: com.rabbitmq.client.ShutdownSignalException: channel error; reason: {#method&amp;lt;channel.close&amp;gt;(reply-code=404, reply-text=NOT_FOUND - no queue &amp;amp;apos;ad_google_dfa_reporting_queue&amp;amp;apos; in vhost &amp;amp;apos;/&amp;amp;apos;, class-id=60, method-id=20), null, ""}
	at com.rabbitmq.client.impl.ChannelN.asyncShutdown(ChannelN.java:474)
	at com.rabbitmq.client.impl.ChannelN.processAsync(ChannelN.java:315)
	at com.rabbitmq.client.impl.AMQChannel.handleCompleteInboundCommand(AMQChannel.java:144)
	at com.rabbitmq.client.impl.AMQChannel.handleFrame(AMQChannel.java:91)
	at com.rabbitmq.client.impl.AMQConnection$MainLoop.run(AMQConnection.java:533)


From the log, it shows retrying. But after 45 minutes, nothing happen. 
While waiting for CAMEL-8487 (which i have no idea how to configure  ), is there anything i can do for retry to work/happen sooner?</description>
			<version>2.15.1</version>
			<fixedVersion>2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQSupendResumeIntTest.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.reply.ReplyManagerSupport.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQConsumer.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQConsumerTest.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQProducer.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.reply.ReplyManager.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQReConnectionIntTest.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="8539" opendate="2015-03-24 16:23:28" fixdate="2016-01-28 13:09:28" resolution="Duplicate">
		<buginformation>
			<summary>S3 marker does not work</summary>
			<description>S3Consumer doesn&amp;amp;apos;t set marker correctly, when deleteAfterRead is set to false. Therefore, on every subsequent poll, it starts from the beginning of the list.
The reason for that is the following code in S3Consumer:
S3Consumer.java

            if (!getConfiguration().isDeleteAfterRead()) {
                // where marker is track
                marker = listObjects.getMarker();
            }


Accordingly to S3 client documentation, getMarker() return a marker previously set in request. Instead, getNextMarker() shall be used. Although, simply changing it to use getNextMarker() introduces an endless loop iterating over the same set of keys under the prefix, because when reached the end of the key set, getNextMarker() returns null, and on the next poll, the head of the list will be returned, and so on.</description>
			<version>2.15.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.aws.s3.S3Consumer.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">8431</link>
		</links>
	</bug>
	<bug id="9483" opendate="2016-01-06 09:24:20" fixdate="2016-01-31 10:11:43" resolution="Fixed">
		<buginformation>
			<summary>Deploying bundle with Camel routes packaged in KAR fails randomly</summary>
			<description>I am struggling with random deployment failures of bundles containing Camel routes, packaged in a KAR file. Deployment fails mostly because data formats cannot be found on the classpath or Camel component beans are not found in the registry.
The attached sample KAR file contains one bundle with the following blueprint deployment descriptor:


&amp;lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0" 			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 			xmlns:camel="http://camel.apache.org/schema/blueprint" 			xsi:schemaLocation="				http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
				http://camel.apache.org/schema/blueprint http://camel.apache.org/schema/blueprint/camel-blueprint-2.16.1.xsd"&amp;gt;
 
	&amp;lt;bean id="processor" class="ch.rsteppac.karissue.RestProcessor" /&amp;gt;

	&amp;lt;camelContext id="rest-api" allowUseOriginalMessage="false" xmlns="http://camel.apache.org/schema/blueprint"&amp;gt;
		&amp;lt;restConfiguration component="netty4-http" scheme="http" host="0.0.0.0" port="2016" bindingMode="json"&amp;gt;
			&amp;lt;dataFormatProperty key="prettyPrint" value="true" /&amp;gt;
		&amp;lt;/restConfiguration&amp;gt;

		&amp;lt;rest path="/say/hello" id="poc-route" produces="application/json"&amp;gt;
			&amp;lt;get uri="/{yourName}"&amp;gt;
				&amp;lt;route&amp;gt;
					&amp;lt;camel:process ref="processor" /&amp;gt;
				&amp;lt;/route&amp;gt;
			&amp;lt;/get&amp;gt;
		&amp;lt;/rest&amp;gt;
	&amp;lt;/camelContext&amp;gt;
&amp;lt;/blueprint&amp;gt;


The feature file of the KAR:


&amp;lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&amp;gt;
&amp;lt;features xmlns="http://karaf.apache.org/xmlns/features/v1.3.0" name="KAR deployment issue PoC"&amp;gt;
    &amp;lt;repository&amp;gt;mvn:org.apache.camel.karaf/apache-camel/2.16.1/xml/features&amp;lt;/repository&amp;gt;
    &amp;lt;feature name="poc-rest-service" description="Sample REST bundle to demonstrate the deployment issue in Karaf 4" version="0.0.1.SNAPSHOT"&amp;gt;
        &amp;lt;details&amp;gt;Sample REST bundle to demonstrate the deployment issue in Karaf 4&amp;lt;/details&amp;gt;
        &amp;lt;feature version="2.16.1" prerequisite="false" dependency="false"&amp;gt;camel-jackson&amp;lt;/feature&amp;gt;
        &amp;lt;feature version="2.16.1" prerequisite="false" dependency="false"&amp;gt;camel-blueprint&amp;lt;/feature&amp;gt;
        &amp;lt;feature version="2.16.1" prerequisite="false" dependency="false"&amp;gt;camel-netty4-http&amp;lt;/feature&amp;gt;
        &amp;lt;bundle&amp;gt;mvn:ch.rsteppac.kar-issue/poc-rest-service/0.0.1-SNAPSHOT&amp;lt;/bundle&amp;gt;
    &amp;lt;/feature&amp;gt;
&amp;lt;/features&amp;gt;


On my development machine (OSX) deploying the sample KAR file succeeds about 8 out of 10 times. It appears that the more features the KAR file contains the lower the probability of success. Our actual project KAR fails deployment about 9 out of 10 times.
Not all Camel components are equally likely to cause the deployment failure. The most likely to trigger a failure are data formats, e.g., jackson-json or jaxb.
Once the KAR file has deployed successfully, restarting Karaf will consistently deploy the bundles successfully. Until one deletes Karaf&amp;amp;apos;s data folder, then all bets are off again.
Adding the feature.xml generated for the KAR with feature:repo-add and then deploying the features with feature:install virtually never fails.
Stack traces for most frequent deployment failure of the sample KAR are attached to the ticket.
EDIT
The issue is actually unrelated to fact that the features are deployed via a KAR file. While I can successfully install each feature individually on the command line, if I restart Karaf and the features are deployed from the $KARAF_HOME/data directory, the behavior is the same as described above.
I encountered another class of errors: A bean declared in the blueprint context was not resolvable in the Camel context in the same file. 
Defining a start-level for my bundles (90) seems to be a workaround for the different issues described above.</description>
			<version>2.16.1</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.blueprint.handler.CamelNamespaceHandler.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">9963</link>
		</links>
	</bug>
	<bug id="9553" opendate="2016-02-01 08:09:51" fixdate="2016-02-01 08:40:26" resolution="Fixed">
		<buginformation>
			<summary>Twitter consumer doesn&amp;apos;t respect the delay parameter</summary>
			<description>I&amp;amp;apos;ve configured a polling Twitter endpoint with nearly default Spring configuration as follows:


from("twitter://search?type=polling&amp;amp;keywords=searchterms&amp;amp;delay=60&amp;amp;consumerKey=[s]&amp;amp;consumerSecret=[s]&amp;amp;accessToken=[s]&amp;amp;accessTokenSecret=[s]")


However, it doesn&amp;amp;apos;t seem to respect the delay parameter.
On debugging, the delay parameter is set properly:


    public TwitterConsumerPolling(TwitterEndpoint endpoint, Processor processor,
                                  Twitter4JConsumer twitter4jConsumer) {
        super(endpoint, processor);

        this.twitter4jConsumer = twitter4jConsumer;

        int delay = endpoint.getProperties().getDelay();
        setInitialDelay(1);
        setDelay(delay);  // delay is set properly to 60 here
        setTimeUnit(TimeUnit.SECONDS);
    }


but when the run() method of the ScheduledPollConsumer runs, the delay parameter is still the default of 500.


public void run() {
        // avoid this thread to throw exceptions because the thread pool wont re-schedule a new thread
        try {
            // log starting
            if (LoggingLevel.ERROR == runLoggingLevel) {
                LOG.error("Scheduled task started on:   {}", this.getEndpoint());
            } else if (LoggingLevel.WARN == runLoggingLevel) {
                LOG.warn("Scheduled task started on:   {}", this.getEndpoint());
            } else if (LoggingLevel.INFO == runLoggingLevel) {
                LOG.info("Scheduled task started on:   {}", this.getEndpoint());
            } else if (LoggingLevel.DEBUG == runLoggingLevel) {
                LOG.debug("Scheduled task started on:   {}", this.getEndpoint());
            } else {
                LOG.trace("Scheduled task started on:   {}", this.getEndpoint());
            }

            // execute scheduled task
            doRun();

            // log completed
            if (LoggingLevel.ERROR == runLoggingLevel) {
                LOG.error("Scheduled task completed on: {}", this.getEndpoint());
            } else if (LoggingLevel.WARN == runLoggingLevel) {
                LOG.warn("Scheduled task completed on: {}", this.getEndpoint());
            } else if (LoggingLevel.INFO == runLoggingLevel) {
                LOG.info("Scheduled task completed on: {}", this.getEndpoint());
            } else if (LoggingLevel.DEBUG == runLoggingLevel) {
                LOG.debug("Scheduled task completed on: {}", this.getEndpoint());
            } else {
                LOG.trace("Scheduled task completed on: {}", this.getEndpoint());
            }

        } catch (Error e) {
            // must catch Error, to ensure the task is re-scheduled
            LOG.error("Error occurred during running scheduled task on: " + this.getEndpoint() + ", due: " + e.getMessage(), e);
        }
    }

</description>
			<version>2.16.2</version>
			<fixedVersion>2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.twitter.consumer.TwitterConsumerPolling.java</file>
			<file type="M">org.apache.camel.component.twitter.SearchPollingTest.java</file>
			<file type="M">org.apache.camel.component.twitter.TwitterEndpointPolling.java</file>
			<file type="M">org.apache.camel.component.twitter.TwitterConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="9557" opendate="2016-02-02 06:07:25" fixdate="2016-02-03 07:32:12" resolution="Fixed">
		<buginformation>
			<summary>Facebook consumer throws IllegalArgumentException with reading parameters</summary>
			<description>I&amp;amp;apos;ve configured a polling Facebook consumer with nearly default Spring configuration as follows:


&amp;lt;camel:from uri="facebook://getFeed?
    reading.since=2016-01-01T00:00:00Z&amp;amp;amp;
    userId=myUserId&amp;amp;amp;
    consumer.delay=60000&amp;amp;amp;
    oAuthAppId=[s]&amp;amp;amp;
    oAuthAppSecret=[s]&amp;amp;amp;
    oAuthAccessToken=[s]
    "/&amp;gt;


However, an IllegalArgument is thrown with any reading.* parameter regardless of endpoint:


java.lang.IllegalArgumentException: No matching operation for getFeed, with arguments [readingOptions, reading, userId]


On debugging, the method FacebookEndpoint.configureProperties sets two properties on the configuration object: (readingOptions, reading).


FacebookPropertiesHelper.configureReadingProperties(configuration, options);


readingOptions is a Map which is finally size 0 after all the relevant properties are extracted into the reading parameter. However, it isn&amp;amp;apos;t nullified.
In the subsequent method initState(), it tries to look for a method in FacebookMethodTypes with the signature:


getFeed(String userId, Reading reading)


Because readingOptions is non null, it looks for a readingOptions parameter as well which doesn&amp;amp;apos;t exist, throwing the Exception.
Is there a workaround I can use for the moment? Thanks!</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.facebook.data.FacebookPropertiesHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="9560" opendate="2016-02-02 15:04:00" fixdate="2016-02-04 18:43:56" resolution="Fixed">
		<buginformation>
			<summary>RabbitMQ InOut Producer generates a null body response when a correlationId is used</summary>
			<description>The use case uses a correlationId with RabbitMQ InOut Producer :


from("direct:route")
   .setHeader(RabbitMQConstants.EXCHANGE_NAME, constant("exchange"))
   .setHeader(RabbitMQConstants.CORRELATIONID, constant("123"))
   .inOut("rabbitmq://...")


The response always contains a null out body message.
The problem is located when restoring the original correlation id in org.apache.camel.component.rabbitmq.reply.ReplyManagerSupport : 


public void processReply(ReplyHolder holder)




// restore correlation id in case the remote server messed with it
if (holder.getOriginalCorrelationId() != null) {
   if (exchange.getOut() != null) {
      exchange.getOut().setHeader(RabbitMQConstants.CORRELATIONID, 
         holder.getOriginalCorrelationId());
   } else {
      exchange.getIn().setHeader(RabbitMQConstants.CORRELATIONID, 
         holder.getOriginalCorrelationId());
   }
}


The test exchange.getOut() is always successful because of the lazy creation in DefaultExchange.getOut


public Message getOut() {
   // lazy create
   if (out == null) {
      out = (in != null &amp;amp;&amp;amp; in instanceof MessageSupport)
      ? ((MessageSupport)in).newInstance() : new DefaultMessage();
      configureMessage(out);
   }
   return out;
}


The in body message contains the correct response from RabbitMQ. However, since the out message will be always created with a null body, the null body response will be returned in the pipeline</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rabbitmq.reply.ReplyManagerSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="9558" opendate="2016-02-02 09:00:25" fixdate="2016-02-05 15:57:08" resolution="Fixed">
		<buginformation>
			<summary>DefaultErrorHandler logs despite "handled true"</summary>
			<description>The assumption is that handled exceptions will not be propagated any further.
In version 2.15.5 the test code (from the camel-jetty page) runs fine - but since 2.16.0 the handled exception is propagated to the DefaultErrorHandler which causes ERROR logs for every handled exception.
I could not find a hint in the release notes - so I think it&amp;amp;apos;s a bug.


public class MyTest extends CamelTestSupport {

    @Test
    public void test() throws Exception {
        // using httpclient 4.3.5
        CloseableHttpClient httpclient = HttpClients.createDefault();
        HttpGet httRequest = new HttpGet("http://127.0.0.1:7890/myserver");
        HttpResponse response = httpclient.execute(httRequest);
        assertThat(response.getStatusLine().getStatusCode(), is(500));
    }

    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {

            @Override
            public void configure() throws Exception {
                from("jetty://http://localhost:7890/myserver").tracing()
                        // use onException to catch all exceptions and return a custom reply message
                        .onException(Exception.class).handled(true)
                        // create a custom failure response
                        .transform(constant("Dude something went wrong"))
                        // we must remember to set error code 500 as handled(true)
                        // otherwise would let Camel thing its a OK response (200)
                        .setHeader(Exchange.HTTP_RESPONSE_CODE, constant(500)).end()
                        // now just force an exception immediately
                        .throwException(new IllegalArgumentException("I cannot do this"));
            }
        };
    }
}


References from the user-list
http://camel.465427.n5.nabble.com/onException-block-in-camel-2-16-1-td5777019.html#a5777064
http://camel.465427.n5.nabble.com/jetty-handled-true-not-working-as-before-td5776774.html</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.DeadLetterChannelLogExhaustedMessageHistoryTest.java</file>
			<file type="M">org.apache.camel.builder.DeadLetterChannelBuilder.java</file>
			<file type="M">org.apache.camel.processor.RedeliveryErrorHandler.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8755</link>
		</links>
	</bug>
	<bug id="9569" opendate="2016-02-05 16:20:16" fixdate="2016-02-05 16:56:28" resolution="Fixed">
		<buginformation>
			<summary>Idempotent Consumer EIP - Memory leak when add/remove routes</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Leak-of-Memory-using-JdbcMessageIdRepository-tp5777242.html</description>
			<version>2.15.5</version>
			<fixedVersion>2.15.6, 2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.idempotent.IdempotentConsumer.java</file>
			<file type="M">org.apache.camel.model.IdempotentConsumerDefinition.java</file>
			<file type="M">org.apache.camel.spi.IdempotentRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="9576" opendate="2016-02-08 12:45:09" fixdate="2016-02-08 17:24:43" resolution="Fixed">
		<buginformation>
			<summary>ClassLoadingAwareObjectInputStream cannot handle deserializing proxies with mixed JDK &amp; non-JDK interfaces</summary>
			<description>The camel-sql component contains a class called ClassLoadingAwareObjectInputStream, which is a copy from a class from the apache activeMQ project.
There was a bug in this class that was fixed in the activeMQ project but was not updated in the camel-sql component.
I face the same issue as in: https://issues.apache.org/jira/browse/AMQ-3537
where I cannot deserialize an object that contains a mix of jdk and non-jdk classes.</description>
			<version>2.16.2</version>
			<fixedVersion>2.15.6, 2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.aggregate.jdbc.ClassLoadingAwareObjectInputStream.java</file>
		</fixedFiles>
	</bug>
	<bug id="9582" opendate="2016-02-09 11:20:31" fixdate="2016-02-09 11:21:34" resolution="Fixed">
		<buginformation>
			<summary>swagger-api docs not working in only using xml without any java route</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Swagger-not-working-tp5777255.html</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.core.xml.AbstractCamelContextFactoryBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="9431" opendate="2015-12-17 14:12:50" fixdate="2016-02-10 14:04:09" resolution="Fixed">
		<buginformation>
			<summary>camel-spring-boot - TypeConverter autoconfiguration leads to invalid shutdown sequence</summary>
			<description>When using autoconfiguration provided by the camel-spring-boot artifact,  a TypeConverter bean is automatically registered into the Spring context: 
TypeConversionConfiguration.java

@Bean
TypeConverter typeConverter(CamelContext camelContext) {
    return camelContext.getTypeConverter();
}


The returned bean is an instance of DefaultTypeConverter, which in turn implements ServiceSupport and its method public void shutdown(). This method is infered as a destroy-method by Spring, and called during the shutdown of the ApplicationContext. 
As a consequence, the TypeConverter will be destroyed before the CamelContext, effectively preventing any type conversion support for the inflight messages that have still to be processed during the graceful shutdown period of Camel. 
AFAIK the simple fix would be to disable the destroy-method inference using @Bean(destroyMethod=""). This will let Camel have a chance to perform a clean shutdown in the right sequence. 
As a workaround, it is possible to entirely disable the registration of the type converter in Spring using the property
camel.springboot.type-conversion = false</description>
			<version>2.16.1</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.boot.TypeConversionConfiguration.java</file>
			<file type="M">org.apache.camel.spring.boot.CamelAutoConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="9593" opendate="2016-02-12 09:28:36" fixdate="2016-02-12 09:50:55" resolution="Fixed">
		<buginformation>
			<summary>camel-example-swagger-cdi is not producing valid swagger definition</summary>
			<description>http://camel.465427.n5.nabble.com/Camel-Swagger-cdi-Example-td5777632.html</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.example.cdi.UserRouteBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="9444" opendate="2015-12-23 10:50:35" fixdate="2016-02-12 16:55:06" resolution="Fixed">
		<buginformation>
			<summary>Incorrect exceptions handling from Splitter</summary>
			<description>Steps to reproduce:
1. Create global onException handler


&amp;lt;onException&amp;gt;
    &amp;lt;exception&amp;gt;java.lang.Exception&amp;lt;/exception&amp;gt;
    &amp;lt;handled&amp;gt;
        &amp;lt;constant&amp;gt;false&amp;lt;/constant&amp;gt;
    &amp;lt;/handled&amp;gt;
    &amp;lt;log message="SOME MESSAGE"/&amp;gt;
&amp;lt;/onException&amp;gt;


2. Create 2 routes with Splitter (set shareUnitOfWork to TRUE, important)


&amp;lt;route&amp;gt;
    &amp;lt;from uri="timer://foo?repeatCount=1"/&amp;gt;

    &amp;lt;!-- Add some value list to body here --&amp;gt;

    &amp;lt;split shareUnitOfWork="true" stopOnException="true"&amp;gt;
        &amp;lt;simple&amp;gt;${body}&amp;lt;/simple&amp;gt;
        &amp;lt;to uri="direct:handleSplit"/&amp;gt;
    &amp;lt;/split&amp;gt;
&amp;lt;/route&amp;gt;

&amp;lt;route&amp;gt;
    &amp;lt;from uri="direct:handleSplit"/&amp;gt;
    &amp;lt;throwException ref="myException"/&amp;gt;
&amp;lt;/route&amp;gt;


Expected: string "SOME MESSAGE" is logged
Actual:  &amp;lt;log message="SOME MESSAGE"/&amp;gt; is not executed at all </description>
			<version>2.16.1</version>
			<fixedVersion>2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.RecipientList.java</file>
			<file type="M">org.apache.camel.model.SplitDefinition.java</file>
			<file type="M">org.apache.camel.processor.SplitSubUnitOfWorkTest.java</file>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.model.RecipientListDefinition.java</file>
			<file type="M">org.apache.camel.processor.Splitter.java</file>
			<file type="M">org.apache.camel.model.MulticastDefinition.java</file>
			<file type="M">org.apache.camel.issues.RecipientListShareUnitOfWorkOnExceptionHandledFalseIssueTest.java</file>
			<file type="M">org.apache.camel.issues.MulticastShareUnitOfWorkOnExceptionHandledFalseIssueTest.java</file>
			<file type="M">org.apache.camel.processor.MulticastSubUnitOfWorkTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultSubUnitOfWork.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">9573</link>
		</links>
	</bug>
	<bug id="9599" opendate="2016-02-13 16:32:26" fixdate="2016-02-13 16:54:22" resolution="Fixed">
		<buginformation>
			<summary>camel-cxfrs - When responding then do not use content-length from input</summary>
			<description>The simple binding of cxfrs uses the content-length header from the input as the response content-length. It should not do that.</description>
			<version>2.16.2</version>
			<fixedVersion>2.15.6, 2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.jaxrs.SimpleCxfRsBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="9608" opendate="2016-02-17 07:44:40" fixdate="2016-02-17 08:14:45" resolution="Fixed">
		<buginformation>
			<summary>camel-jpa consumer fails to poll after transaction timeout</summary>
			<description>On JBoss EAP environment, camel-jpa consumer receives following right after transaction timeout

15:08:36,356 WARN  [org.apache.camel.component.jpa.JpaConsumer] (Camel ({urnswitchyard-quickstartcamel-jpa-binding0.1.0}camel-jpa-retrieve-binding) thread #0 - jpa://org.switchyard.quickstarts.camel.jpa.binding.domain.Greet) Consumer Consumer[jpa://org.switchyard.quickstarts.camel.jpa.binding.domain.Greet?consumeDelete=true&amp;amp;consumeLockEntity=false&amp;amp;consumer.transacted=true&amp;amp;delay=500&amp;amp;initialDelay=1000&amp;amp;persistenceUnit=JpaEvents&amp;amp;transactionManager=%23jtaTransactionManager] failed polling endpoint: Endpoint[jpa://org.switchyard.quickstarts.camel.jpa.binding.domain.Greet?consumeDelete=true&amp;amp;consumeLockEntity=false&amp;amp;consumer.transacted=true&amp;amp;delay=500&amp;amp;initialDelay=1000&amp;amp;persistenceUnit=JpaEvents&amp;amp;transactionManager=%23jtaTransactionManager]. Will try again at next poll. Caused by: [javax.persistence.PersistenceException - org.hibernate.HibernateException: Transaction was rolled back in a different thread!]: javax.persistence.PersistenceException: org.hibernate.HibernateException: Transaction was rolled back in a different thread!
	at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1387) [hibernate-entitymanager-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1310) [hibernate-entitymanager-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1316) [hibernate-entitymanager-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.ejb.AbstractEntityManagerImpl.remove(AbstractEntityManagerImpl.java:911) [hibernate-entitymanager-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) [rt.jar:1.8.0_65]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) [rt.jar:1.8.0_65]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) [rt.jar:1.8.0_65]
	at java.lang.reflect.Method.invoke(Method.java:497) [rt.jar:1.8.0_65]
	at org.springframework.orm.jpa.ExtendedEntityManagerCreator$ExtendedEntityManagerInvocationHandler.invoke(ExtendedEntityManagerCreator.java:366) [spring-orm-3.2.12.RELEASE.jar:3.2.12.RELEASE]
	at com.sun.proxy.$Proxy45.remove(Unknown Source)
	at org.apache.camel.component.jpa.JpaConsumer$5.deleteObject(JpaConsumer.java:456) [camel-jpa-2.15.2.jar:2.15.2]
..... (snip) .....
Caused by: org.hibernate.HibernateException: Transaction was rolled back in a different thread!
	at org.hibernate.engine.transaction.synchronization.internal.SynchronizationCallbackCoordinatorTrackingImpl.processAnyDelayedAfterCompletion(SynchronizationCallbackCoordinatorTrackingImpl.java:105) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.internal.SessionImpl.delayedAfterCompletion(SessionImpl.java:636) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.internal.SessionImpl.checkTransactionSynchStatus(SessionImpl.java:2070) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.internal.SessionImpl.fireDelete(SessionImpl.java:916) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.internal.SessionImpl.delete(SessionImpl.java:855) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.ejb.AbstractEntityManagerImpl.remove(AbstractEntityManagerImpl.java:905) [hibernate-entitymanager-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	... 20 more


After this, camel-jpa is no longer able to handle its polling due to staled connection

15:08:36,860 WARN  [org.apache.camel.component.jpa.JpaConsumer] (Camel ({urnswitchyard-quickstartcamel-jpa-binding0.1.0}camel-jpa-retrieve-binding) thread #0 - jpa://org.switchyard.quickstarts.camel.jpa.binding.domain.Greet) Consumer Consumer[jpa://org.switchyard.quickstarts.camel.jpa.binding.domain.Greet?consumeDelete=true&amp;amp;consumeLockEntity=false&amp;amp;consumer.transacted=true&amp;amp;delay=500&amp;amp;initialDelay=1000&amp;amp;persistenceUnit=JpaEvents&amp;amp;transactionManager=%23jtaTransactionManager] failed polling endpoint: Endpoint[jpa://org.switchyard.quickstarts.camel.jpa.binding.domain.Greet?consumeDelete=true&amp;amp;consumeLockEntity=false&amp;amp;consumer.transacted=true&amp;amp;delay=500&amp;amp;initialDelay=1000&amp;amp;persistenceUnit=JpaEvents&amp;amp;transactionManager=%23jtaTransactionManager]. Will try again at next poll. Caused by: [javax.persistence.PersistenceException - org.hibernate.HibernateException: Logical connection is closed]: javax.persistence.PersistenceException: org.hibernate.HibernateException: Logical connection is closed
	at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1387) [hibernate-entitymanager-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1310) [hibernate-entitymanager-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.ejb.QueryImpl.getResultList(QueryImpl.java:277) [hibernate-entitymanager-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.apache.camel.component.jpa.JpaConsumer$1.doInTransaction(JpaConsumer.java:104) [camel-jpa-2.15.2.jar:2.15.2]
	at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:131) [spring-tx-3.2.12.RELEASE.jar:3.2.12.RELEASE]
	at org.apache.camel.component.jpa.JpaConsumer.poll(JpaConsumer.java:92) [camel-jpa-2.15.2.jar:2.15.2]
..... (snip) .....
Caused by: org.hibernate.HibernateException: Logical connection is closed
	at org.hibernate.engine.jdbc.internal.LogicalConnectionImpl.getConnection(LogicalConnectionImpl.java:150) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.engine.jdbc.internal.StatementPreparerImpl.connection(StatementPreparerImpl.java:56) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.engine.jdbc.internal.StatementPreparerImpl$5.doPrepare(StatementPreparerImpl.java:159) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.engine.jdbc.internal.StatementPreparerImpl$StatementPreparationTemplate.prepareStatement(StatementPreparerImpl.java:183) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.engine.jdbc.internal.StatementPreparerImpl.prepareQueryStatement(StatementPreparerImpl.java:157) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.loader.Loader.prepareQueryStatement(Loader.java:1881) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.loader.Loader.executeQueryStatement(Loader.java:1858) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.loader.Loader.executeQueryStatement(Loader.java:1838) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.loader.Loader.doQuery(Loader.java:906) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.loader.Loader.doQueryAndInitializeNonLazyCollections(Loader.java:348) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.loader.Loader.doList(Loader.java:2550) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.loader.Loader.doList(Loader.java:2536) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.loader.Loader.listIgnoreQueryCache(Loader.java:2366) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.loader.Loader.list(Loader.java:2361) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.loader.hql.QueryLoader.list(QueryLoader.java:495) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.hql.internal.ast.QueryTranslatorImpl.list(QueryTranslatorImpl.java:357) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.engine.query.spi.HQLQueryPlan.performList(HQLQueryPlan.java:198) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.internal.SessionImpl.list(SessionImpl.java:1230) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.internal.QueryImpl.list(QueryImpl.java:101) [hibernate-core-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	at org.hibernate.ejb.QueryImpl.getResultList(QueryImpl.java:268) [hibernate-entitymanager-4.2.21.Final-redhat-1.jar:4.2.21.Final-redhat-1]
	... 12 more


According to the Java Persistence API 3.3.2 Transaction Rollback, the persistence context could be in inconsistent state after transaction rollback, which is suggesting to renew the EntityManager instance after transaction rollback. Actually I verified that if I renewed the EntityManager instance after rollback then camel-jpa could continue to work after that. I&amp;amp;apos;ll submit a pull request in a minute.</description>
			<version>2.15.5</version>
			<fixedVersion>2.15.6, 2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jpa.JpaConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9607" opendate="2016-02-16 15:15:06" fixdate="2016-02-17 08:51:51" resolution="Fixed">
		<buginformation>
			<summary>chmod does not work for the File producer whitout setting a charset</summary>
			<description>Hello
https://github.com/apache/camel/blob/camel-2.15.2/camel-core/src/main/java/org/apache/camel/component/file/FileOperations.java
Permissions are never updated without setting a charset.
The block code at line 280 seems to be at the wrong place.
Best,
Nicolas.</description>
			<version>2.15.2</version>
			<fixedVersion>2.15.6, 2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="9611" opendate="2016-02-17 14:27:53" fixdate="2016-02-19 08:43:09" resolution="Fixed">
		<buginformation>
			<summary>Restlet GET request should not trying to stringify the exchange body</summary>
			<description>When sending a restlet GET request, the body should not be looked at at all.  
Currently In my exchange i have a java object in the body, and i send a restlet GET request, i expect the restlet response to replace whatever is in the body.  But i get a type conversion error because it is trying to stringify the java object before sending the get request.
I think the body should only be used in PUT and POST request.
Here is the fix in org.apache.camel.component.restlet.DefaultRestletBinding.java  line 151:
   public void populateRestletRequestFromExchange(Request request, Exchange exchange) {
        request.setReferrerRef("camel-restlet");
        String body = null;
        if(request.getMethod() == Method.POST || request.getMethod() == Method.PUT)
        {
        	body = exchange.getIn().getBody(String.class);
    	}
        Form form = new Form();
        // add the body as the key in the form with null value
        form.add(body, null);</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.DefaultRestletBinding.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">9966</link>
		</links>
	</bug>
	<bug id="9641" opendate="2016-02-24 15:56:04" fixdate="2016-02-24 16:31:51" resolution="Fixed">
		<buginformation>
			<summary>Simple backwards parser bug if using file</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Unknown-File-Language-Syntax-tp5778208.html</description>
			<version>2.16.2</version>
			<fixedVersion>2.15.6, 2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.language.simple.SimpleTest.java</file>
			<file type="M">org.apache.camel.language.simple.ast.SimpleFunctionExpression.java</file>
		</fixedFiles>
	</bug>
	<bug id="9636" opendate="2016-02-23 17:34:13" fixdate="2016-02-24 20:20:43" resolution="Fixed">
		<buginformation>
			<summary>CamelBlueprintTestSupport - initialization error in case of empty cm:property-placeholder</summary>
			<description>Test execution hangs with the specific use case of passing a configuration similar to:


  &amp;lt;cm:property-placeholder persistent-id="my-placeholders" update-strategy="reload"&amp;gt;
  &amp;lt;/cm:property-placeholder&amp;gt;


The will pass value for that pid only at Test level inside the method useOverridePropertiesWithConfigAdmin
The fix makes the attached test case succeed.
</description>
			<version>2.15.5</version>
			<fixedVersion>2.15.6, 2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.test.blueprint.CamelBlueprintHelper.java</file>
			<file type="M">org.apache.camel.test.blueprint.ConfigAdminNoDefaultValuesBlueprintCreationTest.java</file>
			<file type="M">org.apache.camel.test.blueprint.CamelBlueprintTestSupport.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">9313</link>
		</links>
	</bug>
	<bug id="9432" opendate="2015-12-17 20:18:58" fixdate="2016-02-25 07:12:36" resolution="Fixed">
		<buginformation>
			<summary>Bindy CSV separator not treated as regex but fixed character in all cases</summary>
			<description>In the camel-bindy documentation (http://camel.apache.org/bindy.html) it says that the @CsvRecord separator parameter is interpreted as a regex. While that does seem to be the case when the record is being parsed, it seems to be treated as a literal string when autospanLine is true.
For example, if we have 


@CsvRecord(separator="\\s+", autospanLine=true)


 and we have defined three string @DataField fields, and we have a line of input like this:


     field1 field2 field3a field3b


then the third field value will be


    "field3a\s+field3b"


Looking at the code in BindyCsvDataFormat.java it seems that this is because in some cases the separator string is treated as a literal string, not a regex. For example, this also seems to be true in some cases in the unquoteTokens method.</description>
			<version>2.16.1</version>
			<fixedVersion>2.15.6, 2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindyCsvDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="8163" opendate="2014-12-18 12:46:27" fixdate="2016-02-25 07:13:06" resolution="Fixed">
		<buginformation>
			<summary>socketFactory must also be set in MailConfiguration when STARTTLS is used</summary>
			<description>When using STARTTLS with custom sslContextParameters it fails since the factory setup is only done for smtps/imaps/pops, same problem applies to the "dummyTrustManager.</description>
			<version>2.14.0</version>
			<fixedVersion>2.15.6, 2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.security.SslContextParametersMailRouteTest.java</file>
			<file type="M">org.apache.camel.component.mail.MailConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="9640" opendate="2016-02-24 11:33:40" fixdate="2016-02-25 09:39:23" resolution="Fixed">
		<buginformation>
			<summary>Query string gets decoded when bridging from netty*-http to netty*-http</summary>
			<description>The same problem as CAMEL-9442 but for camel-netty*-http instead of camel-http4.</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpHelper.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpProducerBridgeTest.java</file>
			<file type="M">org.apache.camel.http.common.HttpHelper.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpHelper.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpProducerBridgeTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">9442</link>
			<link type="Reference" description="is related to">9658</link>
		</links>
	</bug>
	<bug id="9666" opendate="2016-03-03 09:48:09" fixdate="2016-03-04 08:38:47" resolution="Fixed">
		<buginformation>
			<summary>Safe copy of DefaultExchange does not propagate &amp;apos;fault&amp;apos; property </summary>
			<description>fault property should be copied in the following places:
https://github.com/apache/camel/blob/master/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java#L100
https://github.com/apache/camel/blob/master/camel-core/src/main/java/org/apache/camel/impl/DefaultExchange.java#L107
Consequences:
DefaultExchange#isFault() does not work if exception property is not set.</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultExchange.java</file>
			<file type="M">org.apache.camel.impl.DefaultExchangeTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9660" opendate="2016-03-02 06:22:16" fixdate="2016-03-04 09:43:26" resolution="Fixed">
		<buginformation>
			<summary>HTTP producers crash when Exchange.HTTP_URI header contains unencoded unsafe characters</summary>
			<description>For instance,


template.sendBodyAndHeader("jetty:http://localhost:9000/test?bridgeEndpoint=true", "Hello World", Exchange.HTTP_URI, "/&amp;lt;&amp;gt;{}");


this test code crashes with the following error:


java.net.URISyntaxException: Illegal character in path at index 1: /&amp;lt;&amp;gt;{}


It is because there are places in the HTTP producers code where they are trying to create a java.net.URI instance based on the unsafe string "/&amp;lt;&amp;gt;{}".
This issue causes practical problems when bridging between Netty HTTP consumer endpoints and those HTTP producer endpoints, since Netty consumers route IN messages with Exchange.HTTP_URI header being unencoded.</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http4.helper.HttpMethodHelper.java</file>
			<file type="M">org.apache.camel.component.http.HttpBridgeEndpointTest.java</file>
			<file type="M">org.apache.camel.http.common.HttpHelper.java</file>
			<file type="M">org.apache.camel.component.http4.HttpBridgeEndpointTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">9442</link>
			<link type="Reference" description="relates to">9658</link>
		</links>
	</bug>
	<bug id="9658" opendate="2016-03-01 08:18:59" fixdate="2016-03-04 09:44:02" resolution="Fixed">
		<buginformation>
			<summary>Path gets decoded when bridging HTTP endpoints</summary>
			<description>When bridging HTTP endpoints like this, the HTTP path gets decoded at the TO endpoint:


from("netty-http:http://localhost:9000/camel?matchOnUriPrefix=true")
        .to("http4://host1:9000/fred?bridgeEndpoint=true");


For instance, requesting to http://localhost:9000/camel/%3B will result in a call to http://host1:9000/fred/;, thus cause several issues downstream.</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.CamelContinuationServlet.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpBridgeEncodedPathTest.java</file>
			<file type="M">org.apache.camel.component.netty.http.DefaultNettyHttpBinding.java</file>
			<file type="M">org.apache.camel.http.common.DefaultHttpBinding.java</file>
			<file type="M">org.apache.camel.component.jetty.HttpBridgeEncodedPathTest.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpBridgeEncodedPathTest.java</file>
			<file type="M">org.apache.camel.component.netty4.http.DefaultNettyHttpBinding.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">9442</link>
			<link type="Reference" description="relates to">9640</link>
			<link type="Reference" description="is related to">9660</link>
		</links>
	</bug>
	<bug id="9670" opendate="2016-03-04 09:32:33" fixdate="2016-03-04 10:44:34" resolution="Fixed">
		<buginformation>
			<summary>Camel-ftp: No error message on invalid credentials</summary>
			<description>As result of CAMEL-8718 the connection will be closed on invalid credentials before throwing an exception.
But disconnecting the ftpclient will reset the reply string, so the exception message is null.
The attached patch will store the reply string before disconnecting.</description>
			<version>2.14.2</version>
			<fixedVersion>2.15.6, 2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.FtpOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="9664" opendate="2016-03-02 15:05:07" fixdate="2016-03-04 14:10:53" resolution="Fixed">
		<buginformation>
			<summary>DefaultRestletBinding.populateRestletRequestFromExchange uses wrong mediaType comparison</summary>
			<description>We are trying to bind an incoming POST REST call with Content-Type application/x-www-form-urlencoded to an outgoing one. The incoming request body containing the url encoded form does not get transferred to the outgoing one. We investigated and saw there&amp;amp;apos;s a bug in 
DefaultRestletBinding.populateRestletRequestFromExchange:180 (2.16.2):
if (request.getMethod() == Method.GET || (request.getMethod() == Method.POST &amp;amp;&amp;amp; mediaType == MediaType.APPLICATION_WWW_FORM)) {
The mediaType gets compared using ==. This is wrong. The condition always evaluates to false although the configured Content-Type within the header is "application/x-www-form-urlencoded" (or in our case "application/x-www-form-urlencoded; charset=ISO-8859-1").</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.DefaultRestletBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="9665" opendate="2016-03-02 15:06:59" fixdate="2016-03-06 11:37:21" resolution="Fixed">
		<buginformation>
			<summary>camel-ahc-ws Consumer does not connect</summary>
			<description>WsEndpoint.connect(WsConsumer) should connect to the WebSocket server in case this is not already done. 
The test case (WsProducerConsumerTest.java) only works, since the producer is connecting first and the consumer is using the same connection. If no producer is used, then no connection is created and the consumer will not receive any messages.
Suggestion:


  void connect(final WsConsumer wsConsumer)
  {
    this.consumers.add(wsConsumer);

    if (this.websocket == null || !this.websocket.isOpen())
    {
      this.connect();
    }
  }

</description>
			<version>2.16.1</version>
			<fixedVersion>2.15.6, 2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.ahc.ws.WsProducer.java</file>
			<file type="M">org.apache.camel.component.ahc.ws.WsEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="9673" opendate="2016-03-07 07:53:31" fixdate="2016-03-07 08:21:08" resolution="Fixed">
		<buginformation>
			<summary>doTry .. doFinally should run the finally block for fault messages also</summary>
			<description>If a message has fault flag, then a doFinally block is only executed the first processor. We should ensure the entire block is processed like we do if an exception was thrown. The same kind of logic should apply for fault.</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.FinallyProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="9672" opendate="2016-03-07 06:55:12" fixdate="2016-03-07 08:58:46" resolution="Fixed">
		<buginformation>
			<summary>ClassCastException with interceptFrom</summary>
			<description>If a statement like


interceptFrom().when(simple("${header.foo} == &amp;amp;apos;bar&amp;amp;apos;")).to("mock:intercepted");


is available in a route builder with JMX enabled the startup will fail in Camel 2.16.2 (and the current 2.17-SNAPSHOT) with a ClassCastException in line 310 of DefaultManagementObjectStrategy.
The generated processor is a FilterProcessor, but the resulting definition is a WhenDefinition not a FilterDefinition.
The reason is that CAMEL-8992 introduced a too precise class check for this.
The attached patch relexes the class constraint on the definition.</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.mbean.ManagedFilter.java</file>
			<file type="M">org.apache.camel.management.DefaultManagementObjectStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="9506" opendate="2016-01-12 20:35:26" fixdate="2016-03-08 09:38:18" resolution="Fixed">
		<buginformation>
			<summary>STOMP component does not handle stream objects</summary>
			<description>The STOMP component only performs a very simple toString() on the body of the incoming exchange when it creates a STOMP message. This does not work when the body does not support a toString() which gives some reasonable human readable representation of the object. This is exactly the case if you try to do the following:


from("direct:a").marshal().json(JsonLibrary.Gson).to("stomp:topic:foobar")


The result of the JSON serialization is a Stream, and the toString() on a Stream results in an object hash (e.g. "[B@30479402"). A more appropriate thing to do here is similar to what the File component does. (Basically, read the stream for the data.)</description>
			<version>2.16.1</version>
			<fixedVersion>2.16.2, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.stomp.StompProducerTest.java</file>
			<file type="M">org.apache.camel.component.stomp.StompEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="9680" opendate="2016-03-08 14:11:04" fixdate="2016-03-09 09:58:27" resolution="Fixed">
		<buginformation>
			<summary>Stream caching is broken under Spring Boot</summary>
			<description>As documented in the camel-spring-boot documentation, camel-spring-boot will delegate type conversion to Spring by default (see org.apache.camel.spring.boot.TypeConversionConfiguration). Whenever the body of a route changes to a List, Spring believes it can convert it and fails. See the supplied test.
The runs correctly if the SpringTypeConverter is removed.
StreamCachingTest.java

package com.example.bugs;

import org.apache.camel.CamelContext;
import org.apache.camel.EndpointInject;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.spring.boot.SpringTypeConverter;
import org.apache.camel.test.junit4.CamelTestSupport;
import org.junit.Test;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.core.convert.ConversionService;
import org.springframework.core.convert.converter.Converter;
import org.springframework.core.convert.support.DefaultConversionService;

import java.io.File;
import java.io.FileInputStream;
import java.util.List;

import static java.util.Arrays.asList;

public class StreamCachingTest extends CamelTestSupport {

    public static final String URI_END_OF_ROUTE = "mock:end_of_route";

    @EndpointInject(uri = URI_END_OF_ROUTE)
    private MockEndpoint endOfRoute;

    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                context.getTypeConverterRegistry().addFallbackTypeConverter(springTypeConverter(context, new ConversionService[]{new DefaultConversionService()}), true);

                from("direct:foo")
                    .streamCaching()
                    .bean(MyBean.class)
                    .to(URI_END_OF_ROUTE);
            }
        };
    }

    @Test
    public void stream_caching_with_spring() throws Exception {
        endOfRoute.expectedMessageCount(1);

        template.sendBody("direct:foo", new FileInputStream(new File("src/main/resources/banner.txt")));

        endOfRoute.assertIsSatisfied();

    }

    public static class MyBean {
        public List&amp;lt;Integer&amp;gt; someNumbers() {
            return asList(1, 2, 3);
        }
    }

    /**
     * Copied from org.apache.camel.spring.boot.TypeConversionConfiguration (they are package protected)
     **/
    @Bean
    SpringTypeConverter springTypeConverter(CamelContext camelContext, ConversionService[] conversionServices) {
        SpringTypeConverter springTypeConverter = new SpringTypeConverter(asList(conversionServices));
        camelContext.getTypeConverterRegistry().addFallbackTypeConverter(springTypeConverter, true);
        return springTypeConverter;
    }

    @ConditionalOnMissingBean
    @Bean
    ConversionService defaultCamelConversionService(ApplicationContext applicationContext) {
        DefaultConversionService service = new DefaultConversionService();
        for (Converter converter : applicationContext.getBeansOfType(Converter.class).values()) {
            service.addConverter(converter);
        }
        return service;
    }
}


Result:


org.apache.camel.CamelExecutionException: Exception occurred during execution on the exchange: Exchange[ID-CAW811-53239-1457446127171-0-2][Message: 1,2,3]
	at org.apache.camel.util.ObjectHelper.wrapCamelExecutionException(ObjectHelper.java:1658)
	at org.apache.camel.util.ExchangeHelper.extractResultBody(ExchangeHelper.java:646)
	at org.apache.camel.impl.DefaultProducerTemplate.extractResultBody(DefaultProducerTemplate.java:471)
	at org.apache.camel.impl.DefaultProducerTemplate.extractResultBody(DefaultProducerTemplate.java:467)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:139)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:144)
	at no.avinor.agressointegration.StreamCachingTest.stream_caching_with_spring(StreamCachingTest.java:50)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:78)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:212)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:68)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)
Caused by: org.apache.camel.TypeConversionException: Error during type conversion from type: java.lang.String to the required type: org.apache.camel.StreamCache with value 1,2,3 due Failed to convert from type [java.util.Arrays$ArrayList&amp;lt;?&amp;gt;] to type [org.apache.camel.StreamCache] for value &amp;amp;apos;[1, 2, 3]&amp;amp;apos;; nested exception is org.springframework.core.convert.ConverterNotFoundException: No converter found capable of converting from type [java.util.Arrays$ArrayList&amp;lt;?&amp;gt;] to type [org.apache.camel.StreamCache]
	at org.apache.camel.impl.converter.BaseTypeConverterRegistry.createTypeConversionException(BaseTypeConverterRegistry.java:610)
	at org.apache.camel.impl.converter.BaseTypeConverterRegistry.convertTo(BaseTypeConverterRegistry.java:137)
	at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:72)
	at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:47)
	at org.apache.camel.impl.DefaultStreamCachingStrategy.cache(DefaultStreamCachingStrategy.java:189)
	at org.apache.camel.processor.CamelInternalProcessor$StreamCachingAdvice.before(CamelInternalProcessor.java:765)
	at org.apache.camel.processor.CamelInternalProcessor$StreamCachingAdvice.before(CamelInternalProcessor.java:744)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:138)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:121)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:83)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:190)
	at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:62)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:190)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:109)
	at org.apache.camel.processor.UnitOfWorkProducer.process(UnitOfWorkProducer.java:68)
	at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:412)
	at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:380)
	at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:270)
	at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:380)
	at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:221)
	at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:124)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:137)
	... 34 more
Caused by: org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.util.Arrays$ArrayList&amp;lt;?&amp;gt;] to type [org.apache.camel.StreamCache] for value &amp;amp;apos;[1, 2, 3]&amp;amp;apos;; nested exception is org.springframework.core.convert.ConverterNotFoundException: No converter found capable of converting from type [java.util.Arrays$ArrayList&amp;lt;?&amp;gt;] to type [org.apache.camel.StreamCache]
	at org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:41)
	at org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:192)
	at org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:176)
	at org.apache.camel.spring.boot.SpringTypeConverter.convertTo(SpringTypeConverter.java:40)
	at org.apache.camel.impl.converter.BaseTypeConverterRegistry.doConvertTo(BaseTypeConverterRegistry.java:333)
	at org.apache.camel.impl.converter.BaseTypeConverterRegistry.convertTo(BaseTypeConverterRegistry.java:120)
	... 54 more
Caused by: org.springframework.core.convert.ConverterNotFoundException: No converter found capable of converting from type [java.util.Arrays$ArrayList&amp;lt;?&amp;gt;] to type [org.apache.camel.StreamCache]
	at org.springframework.core.convert.support.GenericConversionService.handleConverterNotFound(GenericConversionService.java:313)
	at org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:195)
	at org.springframework.core.convert.support.CollectionToObjectConverter.convert(CollectionToObjectConverter.java:64)
	at org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:35)
	... 59 more

</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.boot.SpringTypeConverter.java</file>
			<file type="M">org.apache.camel.spring.boot.CamelAutoConfigurationTest.java</file>
			<file type="M">org.apache.camel.spring.boot.SpringConverterDelegationTest.java</file>
			<file type="M">org.apache.camel.karaf.commands.EndpointList.java</file>
			<file type="M">org.apache.camel.karaf.commands.internal.CamelControllerImpl.java</file>
			<file type="M">org.apache.camel.karaf.commands.ContextList.java</file>
			<file type="M">org.apache.camel.karaf.commands.CamelController.java</file>
			<file type="M">org.apache.camel.karaf.commands.RouteList.java</file>
		</fixedFiles>
	</bug>
	<bug id="9686" opendate="2016-03-09 14:18:45" fixdate="2016-03-09 14:21:58" resolution="Fixed">
		<buginformation>
			<summary>camel-aws - Using cron scheduler on aws-s3 do not work</summary>
			<description>See SO
http://stackoverflow.com/questions/35865863/camel-aws-s3-cron-schedule</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.aws.s3.S3Component.java</file>
		</fixedFiles>
	</bug>
	<bug id="9687" opendate="2016-03-09 18:30:36" fixdate="2016-03-10 07:07:18" resolution="Fixed">
		<buginformation>
			<summary>camel-swagger - Should use resolved placeholders in output</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/camel-swagger-java-not-parse-property-tp5778734.html</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.mbean.ManagedCamelContext.java</file>
			<file type="M">org.apache.camel.management.mbean.ManagedRoute.java</file>
			<file type="M">org.apache.camel.model.RouteDefinitionHelper.java</file>
			<file type="M">org.apache.camel.swagger.RestSwaggerSupport.java</file>
			<file type="M">org.apache.camel.api.management.mbean.ManagedRouteMBean.java</file>
			<file type="M">org.apache.camel.api.management.mbean.ManagedCamelContextMBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="9700" opendate="2016-03-11 13:09:42" fixdate="2016-03-11 13:14:24" resolution="Fixed">
		<buginformation>
			<summary>seda - discardIfNoConsumers=true do not call on completions </summary>
			<description>See SO
http://stackoverflow.com/questions/35938139/how-to-release-file-lock-with-camel-when-not-consuming-from-seda-queue/35940850#35940850</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.seda.SedaProducer.java</file>
			<file type="M">org.apache.camel.component.seda.SedaDiscardIfNoConsumerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9689" opendate="2016-03-09 21:25:15" fixdate="2016-03-15 07:20:52" resolution="Fixed">
		<buginformation>
			<summary>Websocket Component Failing to Install in Karaf 4</summary>
			<description>When installing the camel-websocket component in Karaf 4.0.4 the process hangs.
When I try to install via Karaf&amp;amp;apos;s hot deploy I get:
karaf@root()&amp;gt; ERROR: Bundle org.apache.camel.camel-websocket [94] Error starting file:/opt/apache-karaf-4.0.4/deploy/camel-websocket-2.16.2.jar (org.osgi.framework.BundleException: Unable to resolve org.apache.camel.camel-websocket [94](R 94.0): missing requirement [org.apache.camel.camel-websocket [94](R 94.0)] osgi.wiring.package; (&amp;amp;(osgi.wiring.package=javax.servlet)(version&amp;gt;=2.6.0)(Unable to render embedded object: File ( [[org.apache.camel.camel-websocket [94](R 94.0)] osgi.wiring.package; (&amp;amp;(osgi.wiring.package=javax.servlet)(version&amp;gt;=2.6.0)() not found.(version&amp;gt;=3.0.0)))]) org.osgi.framework.BundleException: Unable to resolve org.apache.camel.camel-websocket [94](R 94.0): missing requirement [org.apache.camel.camel-websocket [94](R 94.0)] osgi.wiring.package; (&amp;amp;(osgi.wiring.package=javax.servlet)(version&amp;gt;=2.6.0)(Unable to render embedded object: File ( [[org.apache.camel.camel-websocket [94](R 94.0)] osgi.wiring.package; (&amp;amp;(osgi.wiring.package=javax.servlet)(version&amp;gt;=2.6.0)() not found.(version&amp;gt;=3.0.0)))] at org.apache.felix.framework.Felix.resolveBundleRevision(Felix.java:4111) at org.apache.felix.framework.Felix.startBundle(Felix.java:2117) at org.apache.felix.framework.Felix.setActiveStartLevel(Felix.java:1371) at org.apache.felix.framework.FrameworkStartLevelImpl.run(FrameworkStartLevelImpl.java:308) at java.lang.Thread.run(Thread.java:745)</description>
			<version>2.16.2</version>
			<fixedVersion>2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.servletlistener.MyLifecycle.java</file>
			<file type="M">org.apache.camel.component.servletlistener.CamelServletContextListener.java</file>
			<file type="M">org.apache.camel.component.servletlistener.CamelContextLifecycle.java</file>
		</fixedFiles>
	</bug>
	<bug id="9713" opendate="2016-03-15 17:13:09" fixdate="2016-03-15 19:48:30" resolution="Fixed">
		<buginformation>
			<summary>Can not set custom Jetty HttpClient to producer endpoint</summary>
			<description>The camel-jetty page has a "httpClient" option that can be set on camel-jetty producer endpoint and it says:


To use a shared org.eclipse.jetty.client.HttpClient for all producers created by this endpoint. This option should only be used in special circumstances.
This option should only be used in special circumstances.


In some cases, user might want to set a shard Jetty HttpClient among camel-jetty producer endpoints. For instance, user might use recipientList with camel-jetty producer endpoint to support multiple dynamically created URLs. So setting a shared Jetty HttpClient with a shared thread pool would be ideal to avoid exploding number of producer endpoints + their own producer thread pools in this use case. However, there is no way to set it to camel-jetty producer endpoint.</description>
			<version>2.15.1</version>
			<fixedVersion>2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.jetty.JettyHttpEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="9710" opendate="2016-03-15 15:38:19" fixdate="2016-03-16 07:11:47" resolution="Fixed">
		<buginformation>
			<summary>Camel Dozer Component - Fails to load custom function due to NPE </summary>
			<description>Camel Dozer component throws NPE, when using custom converter as shown in the following example. 
 &amp;lt;mapping&amp;gt;
    &amp;lt;class-a&amp;gt;org.example.A&amp;lt;/class-a&amp;gt;
    &amp;lt;class-b&amp;gt;org.example.B&amp;lt;/class-b&amp;gt;
    &amp;lt;field custom-converter-id="_customMapping" 
        custom-converter-param="org.example.CustomMapper,mapCustomer"&amp;gt;
      &amp;lt;a&amp;gt;sourceField&amp;lt;/a&amp;gt;
      &amp;lt;b&amp;gt;destinationField&amp;lt;/b&amp;gt;
    &amp;lt;/field&amp;gt;
  &amp;lt;/mapping&amp;gt;
When the sourceField value is null in the Class A,Fails to load custom function and  throws RuntimeException caused due to NPE.
Issue with Code: (
------------------------
Class: CustomMapper
Method: invokeFunction
Line# 117
        Object customObj;
        Method method = null;
        try {
            Class&amp;lt;?&amp;gt; customClass = resolver.resolveClass(className);
            customObj = customClass.newInstance();
            // If a specific mapping operation has been supplied use that
            if (operation != null &amp;amp;&amp;amp; prmTypesAndValues != null) 
{
                method = selectMethod(customClass, operation, source, prmTypesAndValues);
            }
 else if (operation != null) 
{
                method = customClass.getMethod(operation, source.getClass()); // ***** THIS LINE CAUSES NPE, as source is NULL */
            }
 else 
{
                method = selectMethod(customClass, source);
            }
        } catch (Exception e) 
{
            throw new RuntimeException("Failed to load custom function", e);
        }



StackTrace:
-------------------
java.lang.RuntimeException: Failed to load custom function
	at org.apache.camel.component.dozer.CustomMapper.mapCustom(CustomMapper.java:122)
	at org.apache.camel.component.dozer.CustomMapper.convert(CustomMapper.java:46)
	at org.dozer.MappingProcessor.mapUsingCustomConverterInstance(MappingProcessor.java:977)
	at org.dozer.MappingProcessor.mapFromFieldMap(MappingProcessor.java:355)
	at org.dozer.MappingProcessor.mapField(MappingProcessor.java:307)
	at org.dozer.MappingProcessor.map(MappingProcessor.java:267)
	at org.dozer.MappingProcessor.mapToDestObject(MappingProcessor.java:216)
	at org.dozer.MappingProcessor.createByCreationDirectiveAndMap(MappingProcessor.java:196)
	at org.dozer.MappingProcessor.mapGeneral(MappingProcessor.java:170)
	at org.dozer.MappingProcessor.map(MappingProcessor.java:104)
	at org.dozer.MappingProcessor.map(MappingProcessor.java:99)
	at org.dozer.DozerBeanMapper.map(DozerBeanMapper.java:120)
	at org.apache.camel.component.dozer.DozerProducer.process(DozerProducer.java:82)
	at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:141)
	at org.apache.camel.management.InstrumentationProcessor.process(InstrumentationProcessor.java:77)
	at org.apache.camel.processor.interceptor.HandleFaultInterceptor.process(HandleFaultInterceptor.java:42)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:91)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:460)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:190)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:121)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:83)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:190)
	at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:62)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:190)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:109)
	at org.apache.camel.processor.UnitOfWorkProducer.process(UnitOfWorkProducer.java:68)
	at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:412)
	at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:380)
	at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:270)
	at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:380)
	at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:221)
	at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:124)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:137)
	at org.apache.camel.impl.DefaultProducerTemplate.sendBody(DefaultProducerTemplate.java:144)
	at com.ta.shop.integration.routes.doz.DozerJsonTest.testDozerHappyPath(DozerJsonTest.java:23)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:606)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)
Caused by: java.lang.NullPointerException
	at org.apache.camel.component.dozer.CustomMapper.mapCustom(CustomMapper.java:117)</description>
			<version>2.16.1</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.dozer.CustomMapper.java</file>
			<file type="M">org.apache.camel.component.dozer.CustomMapperParametersTest.java</file>
			<file type="M">org.apache.camel.component.dozer.CustomMapperTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9714" opendate="2016-03-16 07:52:43" fixdate="2016-03-16 08:04:56" resolution="Fixed">
		<buginformation>
			<summary>camel-boon - Unmarshal to Map does not work</summary>
			<description></description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.boon.BoonDataFormatTest.java</file>
			<file type="M">org.apache.camel.component.boon.BoonDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="9566" opendate="2016-02-04 06:59:23" fixdate="2016-03-17 17:03:41" resolution="Fixed">
		<buginformation>
			<summary>camel-asf-ws component does not reconnect to the web socket </summary>
			<description>Create a web socket consumer route 
Ensure that the web socket provider is available
Create connection to the web socket provider from the consumer
Send a message from the provider (send to all)
Message gets consumed in the consumer route
Bring down the producer
Bring up the producer 
Create connection to the web socket provider from the consumer
Send a message from the provider (send to all)
Message is not printed as reconnect was not done
</description>
			<version>2.16.1</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.ahc.ws.WsConsumer.java</file>
			<file type="M">org.apache.camel.component.ahc.ws.WsProducerConsumerTest.java</file>
			<file type="M">org.apache.camel.component.ahc.ws.WsEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="9730" opendate="2016-03-21 12:28:59" fixdate="2016-03-21 12:54:41" resolution="Fixed">
		<buginformation>
			<summary>NPE in camel-jaxb when using in OSGi running from CamelTestBlueprint</summary>
			<description>You can get this stacktrace with a camel-jaxb in testing using camel-test-blueprint.


Caused by: org.apache.camel.TypeConverterLoaderException: Failed to load type converters because of: Cannot load type converters using OSGi bundle: 28
	at org.apache.camel.impl.osgi.Activator$BundleTypeConverterLoader.load(Activator.java:380)
	at org.apache.camel.core.osgi.OsgiTypeConverter.createRegistry(OsgiTypeConverter.java:219)
	at org.apache.camel.core.osgi.OsgiTypeConverter.getDelegate(OsgiTypeConverter.java:185)
	at org.apache.camel.core.osgi.OsgiTypeConverter.getStatistics(OsgiTypeConverter.java:160)
	at org.apache.camel.impl.DefaultCamelContext.forceLazyInitialization(DefaultCamelContext.java:3625)
	at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:2977)
	at org.apache.camel.impl.DefaultCamelContext.access$000(DefaultCamelContext.java:175)
	at org.apache.camel.impl.DefaultCamelContext$2.call(DefaultCamelContext.java:2848)
	at org.apache.camel.impl.DefaultCamelContext$2.call(DefaultCamelContext.java:2844)
	at org.apache.camel.impl.DefaultCamelContext.doWithDefinedClassLoader(DefaultCamelContext.java:2867)
	at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:2844)
	at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:61)
	at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:2813)
	at org.apache.camel.blueprint.BlueprintCamelContext.start(BlueprintCamelContext.java:180)
	at org.apache.camel.test.blueprint.CamelBlueprintTestSupport.setUp(CamelBlueprintTestSupport.java:240)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:283)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:173)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:153)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:128)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:203)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:155)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:103)
Caused by: java.lang.NullPointerException: null
	at org.apache.camel.converter.jaxb.FallbackTypeConverter.setCamelContext(FallbackTypeConverter.java:116)
	at org.apache.camel.impl.converter.BaseTypeConverterRegistry.addFallbackTypeConverter(BaseTypeConverterRegistry.java:462)
	at org.apache.camel.impl.osgi.Activator$BundleTypeConverterLoader$Loader.load(Activator.java:471)
	at org.apache.camel.impl.osgi.Activator$BundleTypeConverterLoader.load(Activator.java:378)
	at org.apache.camel.core.osgi.OsgiTypeConverter.createRegistry(OsgiTypeConverter.java:219)
	at org.apache.camel.core.osgi.OsgiTypeConverter.getDelegate(OsgiTypeConverter.java:185)
	at org.apache.camel.core.osgi.OsgiTypeConverter.getStatistics(OsgiTypeConverter.java:160)
	at org.apache.camel.impl.DefaultCamelContext.forceLazyInitialization(DefaultCamelContext.java:3625)
	at org.apache.camel.impl.DefaultCamelContext.doStartCamel(DefaultCamelContext.java:2977)
	at org.apache.camel.impl.DefaultCamelContext.access$000(DefaultCamelContext.java:175)
	at org.apache.camel.impl.DefaultCamelContext$2.call(DefaultCamelContext.java:2848)
	at org.apache.camel.impl.DefaultCamelContext$2.call(DefaultCamelContext.java:2844)
	at org.apache.camel.impl.DefaultCamelContext.doWithDefinedClassLoader(DefaultCamelContext.java:2867)
	at org.apache.camel.impl.DefaultCamelContext.doStart(DefaultCamelContext.java:2844)
	at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:61)
	at org.apache.camel.impl.DefaultCamelContext.start(DefaultCamelContext.java:2813)
	at org.apache.camel.blueprint.BlueprintCamelContext.start(BlueprintCamelContext.java:180)
	at org.apache.camel.test.blueprint.CamelBlueprintTestSupport.setUp(CamelBlueprintTestSupport.java:240)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:483)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:283)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:173)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:153)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:128)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:203)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:155)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:103)

</description>
			<version>2.17.0</version>
			<fixedVersion>2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.osgi.OsgiSpringCamelContext.java</file>
			<file type="M">org.apache.camel.core.osgi.OsgiTypeConverter.java</file>
			<file type="M">org.apache.camel.impl.converter.BaseTypeConverterRegistry.java</file>
			<file type="M">org.apache.camel.blueprint.BlueprintCamelContext.java</file>
			<file type="M">org.apache.camel.converter.jaxb.FallbackTypeConverter.java</file>
			<file type="M">org.apache.camel.core.osgi.OsgiDefaultCamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="9732" opendate="2016-03-21 15:52:08" fixdate="2016-03-21 16:01:24" resolution="Fixed">
		<buginformation>
			<summary>camel-swagger-java - Issue in appendModels in the reader</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Re-Bug-in-RestSwaggerReader-appendModels-need-confirmation-td5779271.html</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.swagger.RestSwaggerReader.java</file>
		</fixedFiles>
	</bug>
	<bug id="9656" opendate="2016-02-29 16:26:34" fixdate="2016-03-22 09:53:06" resolution="Fixed">
		<buginformation>
			<summary>Using SpringBoot HealthEndpoint bean throws AmbiguousMethodCallException</summary>
			<description>I&amp;amp;apos;m trying to re-use the Springboot Actuator HealthEndpoint and InfoEndpoint beans and exposing them via rest:


@Autowired
HealthEndpoint healthEndpoint;
...
//build the route
from("rest:get:health").routeId("REST-healthcheck").bean(healthEndpoint, "invoke");


However when that gets invoked, it throws a AmbiguousMethodCallException and its other candidate for "invoke()" is on the abstract class that HealthEndpoint is extending
It looks like the issue is here:
https://github.com/apache/camel/blob/master/camel-core/src/main/java/org/apache/camel/component/bean/BeanInfo.java#L1020
In this case HealthEndpoint extends AbstractHealthEndpoint, which is abstract, but invoke() is declared on the Endpoint interface. So this logic: 

 !isFromInterface &amp;amp;&amp;amp; Modifier.isAbstract(info.getMethod().getModifiers()) 

Will not evaluate to true, and the abstract method will remain a candidate.
Here are the sources for the Endpoint/HealthEndpoint/AbstractEndpoint classes:
https://github.com/spring-projects/spring-boot/blob/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/endpoint/Endpoint.java#L56
https://github.com/spring-projects/spring-boot/blob/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/endpoint/AbstractEndpoint.java#L32
https://github.com/spring-projects/spring-boot/blob/master/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/endpoint/HealthEndpoint.java#L36
It seems this is intentional, due to the "if the class is an interface then keep the method" comment in BeanInfo.
I&amp;amp;apos;m curious as to why that is.</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.issues.BeanInfoSingleMethodServiceTest.java</file>
			<file type="M">org.apache.camel.example.spring.boot.MySpringBootRouter.java</file>
			<file type="M">org.apache.camel.util.ObjectHelper.java</file>
			<file type="M">org.apache.camel.example.spring.boot.MySpringBootRouterTest.java</file>
			<file type="M">org.apache.camel.component.bean.issues.SingleMethodServiceImpl.java</file>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">9690</link>
		</links>
	</bug>
	<bug id="9738" opendate="2016-03-22 10:55:20" fixdate="2016-03-22 12:20:18" resolution="Fixed">
		<buginformation>
			<summary>Thread leak for camel-mina2 consumers</summary>
			<description>The camel-mina2 consumer (org.apache.camel.component.mina2.Mina2Consumer.doStart()) internally start a Mina2 IoAcceptor (org.apache.mina.core.service.IoAcceptor), but the org.apache.camel.component.mina2.Mina2Consumer.doStop() do not invoke acceptor.dispose(true); to release the threadpool started by Mina2.
Current behavior: While stopping the web application, the threadpool started by Mina2 IoAcceptor will not be stopped, so we have several thread which do not properly shutdown.
Current workaround: I create custom CamelShutdownStrategy and collect all Mina2Consumer and invoke Mina2consumer.getAcceptor.dispose(true); OR as an alternative create a dedicated consumer and overwrite the stop method of the Mina2 consumer as seen here: https://github.com/oehf/ipf/commit/12fdde8df7ebbbb7cd9966aadeab3ea3bed8fe75
Suggested bugfix: In org.apache.camel.component.mina2.Mina2Consumer.doShutdown() call the IoAcceptor dispose(true) method after unbind from the address.</description>
			<version>2.16.2</version>
			<fixedVersion>2.15.6, 2.16.3, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina2.Mina2Consumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9739" opendate="2016-03-22 11:31:25" fixdate="2016-03-22 12:47:37" resolution="Fixed">
		<buginformation>
			<summary>Mina2Consumer exception handler do close session also for IOException</summary>
			<description>The camel-mina2 consumer Exception handler (org.apache.camel.component.mina2.Mina2Consumer.ReceiveHandler.exceptionCaught(IoSession, Throwable)
Is an implementation of the Mina2 interface org.apache.mina.core.service.IoHandler. The Javadoc Mina2 documentation of exceptionCaught explicitly mention, that Mina2 will close the connection for all IOExceptions automatically. But camel-mina2 seems to close the connection for any kind of exception.
Current behavior: If an error occurs on the transport layer (e.g. secure TCP connection where the certificate was not trusted and a SSLException occure), I saw the following warning:


org.apache.camel.component.mina2.Mina2Consumer#exceptionCaught(376) - Closing session as an exception was thrown from MINA


And also an error from mina2:


org.apache.mina.filter.ssl.SslHandler#destroy(210) - Unexpected exception from SSLEngine.closeInbound().
" javax.net.ssl.SSLException: Inbound closed before receiving peer&amp;amp;apos;s close_notify: possible truncation attack?


From a functional perspective, beside the annoying log entries, it looks like the SSL error details are sometime not send properly back to the client.
Current workaround: I dont have one.
Suggested bugfix: Implement the Mina2Consumer exception handling similar to org.apache.mina.handler.stream.StreamIoHandler.exceptionCaught(IoSession, Throwable) and do not handle IoException and simply rethrow them. E.g.


if (cause instanceof IOException) {
	LOG.info("IOException will be closed by Mina itself")
	return;
}

</description>
			<version>2.16.2</version>
			<fixedVersion>2.15.6, 2.16.3, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina2.Mina2Consumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9774" opendate="2016-03-30 08:06:04" fixdate="2016-03-30 08:15:40" resolution="Fixed">
		<buginformation>
			<summary>CXFPayload may lose CDATA sections under stream caching</summary>
			<description>CAMEL-8410 introduced CachedCXFPayload to add stream-caching support to CXFPayload. This may use during its sequence of conversions the default java.xml.transform.Transformer to convert javax.xml.transform.stax.StAXSource to SAX, which will then drop CDATA sections because its CDATA handling is empty.
http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/com/sun/org/apache/xalan/internal/xsltc/trax/StAXStream2SAX.java#StAXStream2SAX.handleCDATA%28%29
To avoid this, CachedCXFPayload can use the conversion utility already included in CXF.</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.converter.CachedCxfPayloadTest.java</file>
			<file type="M">org.apache.camel.component.cxf.converter.CachedCxfPayload.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8410</link>
		</links>
	</bug>
	<bug id="9777" opendate="2016-03-30 13:32:59" fixdate="2016-03-30 13:34:56" resolution="Fixed">
		<buginformation>
			<summary>camel-zipfile - Using zip iterator with dataformat may fail</summary>
			<description>The zip entry may say the current size of the entry is -1 while there is still data.</description>
			<version>2.17.0</version>
			<fixedVersion>2.16.3, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.zipfile.ZipIterator.java</file>
		</fixedFiles>
	</bug>
	<bug id="9779" opendate="2016-03-30 15:25:16" fixdate="2016-03-30 15:34:39" resolution="Fixed">
		<buginformation>
			<summary>camel-netty4-http - Using no port number issue</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/netty4-http-IllegalArgumentException-port-out-of-range-1-tp5779995.html</description>
			<version>2.17.0</version>
			<fixedVersion>2.16.3, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.http.NettyCamelWebsiteTest.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyCamelWebsiteTest.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpConfiguration.java</file>
			<file type="M">org.apache.camel.component.netty.NettyConfiguration.java</file>
			<file type="M">org.apache.camel.component.netty.http.NettyHttpConfiguration.java</file>
			<file type="M">org.apache.camel.component.netty4.NettyConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="9793" opendate="2016-04-01 15:55:59" fixdate="2016-04-02 07:05:14" resolution="Fixed">
		<buginformation>
			<summary>PropertyPlaceHolder not loading Property, thinks it is a Parameter</summary>
			<description>When loading a standard rest service into Camel and setting up Swagger.


rest("{{BASE_URL}}").get("/{customerId}").description("...")...


The Base_URL portion is
1. interpreted as a parameter much like 
{customerId}
, i.e. the JSON displays: "
{BASE_URL}
" and "customerId" as the parameter name (removing outside curly brace)
2. the associated property is not loaded from the properties file
The Property Place Holder portion though works for the rest-dsl configuration:


 restConfiguration().apiProperty("api.title", "{{spring.application.name}}")

</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.3, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.rest.RestDefinition.java</file>
			<file type="M">org.apache.camel.swagger.RestSwaggerReaderPropertyPlaceholderTest.java</file>
			<file type="M">org.apache.camel.swagger.RestSwaggerSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="9807" opendate="2016-04-04 10:30:25" fixdate="2016-04-04 12:35:08" resolution="Fixed">
		<buginformation>
			<summary>Blocking of CXF consumer endpoint by http GET request</summary>
			<description>Hi,
by chance we found a problem that can create a security risk. The scenario is a CXF WS consumer endpoint configured without WSDL and right after that a step, e.g. a setHeader that uses an XPath to access the CXF payload. When you now create a http GET request on the endpoint (normally it should be POST) then the error No type converter available to convert from type: org.apache.camel.component.cxf.converter.CachedCxfPayload to the required type: javax.xml.transform.sax.SAXSource with value org.apache.camel.component.cxf.converter.CachedCxfPayload@45812dad
is thrown.
First of all it is surprising that CXF accepts the request. Second a type conversion like that is possible. The reason for this error message is within the type converter coding. The converter returns a null object for the not existing payload of the GET request but this is interpreted as there is no type converter available. One could say that this is just a bad error message but more over the type converter is now kind of black-listed internally. That means the next calls being correct or wrong will not look for a type converter but return immedeately the above error. That means the endpoint is blocked until the scenario is restarted. This seems to be more efficient than a DOS attack (but of course one has to have access rights). I provide a simple patch that raises a runtime exception in the CXF type converter when there is no payload. I am not 100% sure whether this is the best way to fix it. Maybe GET requests should be blocked already in CXF. I also could imagine that somethin like that is also possible in other components. 
We use Camel 2.16.2 and I tested it in CXF 2.16.3 and it is not fixed.  </description>
			<version>2.16.2</version>
			<fixedVersion>2.16.4, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.converter.CxfPayloadConverterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.converter.CxfPayloadConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="9812" opendate="2016-04-04 13:00:56" fixdate="2016-04-05 09:24:07" resolution="Fixed">
		<buginformation>
			<summary>Camel leaves Kafka consumers running after shutdown</summary>
			<description>After shutting down a camel context, there are still threads running kafka consumers. 
In the logs after the shutdown I can see:

14:45:57,455 INFO  [org.apache.camel.spring.SpringCamelContext] (ServerService Thread Pool -- 81) Apache Camel 2.17.0 (CamelContext: ucms-camel-ctx) uptime 25.047 seconds
14:45:57,455 INFO  [org.apache.camel.spring.SpringCamelContext] (ServerService Thread Pool -- 81) Apache Camel 2.17.0 (CamelContext: ucms-camel-ctx) is shutdown in 0.856 seconds
14:45:57,494 INFO  [org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean] (ServerService Thread Pool -- 81) Closing JPA EntityManagerFactory for persistence unit &amp;amp;apos;default&amp;amp;apos;
14:45:57,652 INFO  [org.jboss.as.server.deployment] (MSC service thread 1-3) WFLYSRV0028: Stopped deployment ucms-wildfly-container-3.0.1-SNAPSHOT.war (runtime-name: ucms-wildfly-container-3.0.1-SNAPSHOT.war) in 1098ms
14:45:57,906 INFO  [org.jboss.as.repository] (DeploymentScanner-threads - 2) WFLYDR0002: Content removed from location /opt/wildfly/standalone/data/content/20/13979a02e4b4ec178461d06c2de59fbf424215/content
14:45:57,916 INFO  [org.jboss.as.server] (DeploymentScanner-threads - 2) WFLYSRV0009: Undeployed "ucms-wildfly-container-3.0.1-SNAPSHOT.war" (runtime-name: "ucms-wildfly-container-3.0.1-SNAPSHOT.war")
14:46:24,972 INFO  [org.apache.kafka.clients.consumer.internals.AbstractCoordinator] (Camel (ucms-camel-ctx) thread #0 - KafkaTopic[ucmsControlTopic]) Marking the coordinator 2147483647 dead.
14:46:26,467 INFO  [org.apache.kafka.clients.consumer.internals.AbstractCoordinator] (Camel (ucms-camel-ctx) thread #2 - KafkaTopic[TOPIC1]) Marking the coordinator 2147483647 dead.


So in theory the context is stopped, but I can see threads running with the polling of the sockets of kafka consumers (see attached immage).
This deployed in an application server (wilfly in my case), causes a lot of issues, because apps get deployed and undeployed without stopping the  JVM, but threads from previous deployments are left there.
Please also bear in mind that kafka (9.0.1) throws warning messages due to the fact that un expected config items are thrown to the kafka consumer properties.

14:45:33,840 WARN  [org.apache.kafka.clients.consumer.ConsumerConfig] (ServerService Thread Pool -- 76) The configuration sasl.kerberos.ticket.renew.window.factor = 0.8 was supplied but isn&amp;amp;apos;t a known config.
14:45:33,841 WARN  [org.apache.kafka.clients.consumer.ConsumerConfig] (ServerService Thread Pool -- 76) The configuration sasl.kerberos.kinit.cmd = /usr/bin/kinit was supplied but isn&amp;amp;apos;t a known config.
14:45:33,841 WARN  [org.apache.kafka.clients.consumer.ConsumerConfig] (ServerService Thread Pool -- 76) The configuration sasl.kerberos.ticket.renew.jitter = 0.05 was supplied but isn&amp;amp;apos;t a known config.
14:45:33,841 WARN  [org.apache.kafka.clients.consumer.ConsumerConfig] (ServerService Thread Pool -- 76) The configuration ssl.keystore.type = JKS was supplied but isn&amp;amp;apos;t a known config.
14:45:33,841 WARN  [org.apache.kafka.clients.consumer.ConsumerConfig] (ServerService Thread Pool -- 76) The configuration ssl.trustmanager.algorithm = PKIX was supplied but isn&amp;amp;apos;t a known config.
14:45:33,841 WARN  [org.apache.kafka.clients.consumer.ConsumerConfig] (ServerService Thread Pool -- 76) The configuration sasl.kerberos.min.time.before.relogin = 60000 was supplied but isn&amp;amp;apos;t a known config.
14:45:33,841 WARN  [org.apache.kafka.clients.consumer.ConsumerConfig] (ServerService Thread Pool -- 76) The configuration ssl.protocol = TLS was supplied but isn&amp;amp;apos;t a known config.
14:45:33,841 WARN  [org.apache.kafka.clients.consumer.ConsumerConfig] (ServerService Thread Pool -- 76) The configuration ssl.enabled.protocols = TLSv1.2,TLSv1.1,TLSv1 was supplied but isn&amp;amp;apos;t a known config.
14:45:33,841 WARN  [org.apache.kafka.clients.consumer.ConsumerConfig] (ServerService Thread Pool -- 76) The configuration ssl.truststore.type = JKS was supplied but isn&amp;amp;apos;t a known config.
14:45:33,841 WARN  [org.apache.kafka.clients.consumer.ConsumerConfig] (ServerService Thread Pool -- 76) The configuration ssl.keymanager.algorithm = SunX509 was supplied but isn&amp;amp;apos;t a known config.


Thanks!
</description>
			<version>2.17.0</version>
			<fixedVersion>2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.kafka.KafkaConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9820" opendate="2016-04-05 20:42:04" fixdate="2016-04-06 10:09:13" resolution="Fixed">
		<buginformation>
			<summary>SFTP readLock=changed does not work with readLockMinAge option</summary>
			<description>For the feature I am building, I need to use SFTP to fetch files to process. When it comes to large files, I want to be able to pick up a file for processing only when its been completely written. In order to achieve this, I tried the following combination suggesting the file age should be 10 minutes or more.
readLock=changed
readLockMinAge=10m 
This did not work as expected and kept picking up the files in the next poll as soon as the write has started. I found the following while debugging.
In class SftpChangedExclusiveReadLockStrategy,  
long startTime = (new Date()).getTime();  ==&amp;gt; returns time in milliseconds as long
newLastModified = f.getAttrs().getMTime();  ==&amp;gt; returns time in seconds as int casted to long.
Hence when the following check is made, the comparison becomes to be between newLastModified which is in seconds and newOlderThan in milliseconds hence never quite honoring the readLockMinAge specified.
(minAge != 0 &amp;amp;&amp;amp; newLastModified &amp;lt; newOlderThan)
It looks like there should be 
newLastModified = f.getAttrs().getMTime() * 1000; 
to convert this to milliseconds.</description>
			<version>2.16.1</version>
			<fixedVersion>2.16.4, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.strategy.SftpChangedExclusiveReadLockStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="9768" opendate="2016-03-27 14:33:06" fixdate="2016-04-07 08:43:28" resolution="Fixed">
		<buginformation>
			<summary>HTTP[4] component disableStreamCache issue: java.io.IOException: Attempted read from closed stream.</summary>
			<description>This issue is related to CAMEL-7638 which was recently fixed/released in 2.17.0
I was doing some testing with disableStreamCache=true on a http4 producer and am getting "java.io.IOException: Attempted read from closed stream"
The stack trace shows the error occurring when trying to copy the input stream to an output stream inside the DefaultHttpBinding copyStream methods (i am using camel as a proxy from a sevlet component (consumer) to an http4 component (producer)).
I think though, I see the root cause of this issue.  Inside the HttpProducer process method.


// lets store the result in the output message.
        HttpResponse httpResponse = null;
        try {
            if (LOG.isDebugEnabled()) {
                LOG.debug("Executing http {} method: {}", httpRequest.getMethod(), httpRequest.getURI().toString());
            }
            httpResponse = executeMethod(httpRequest);
            int responseCode = httpResponse.getStatusLine().getStatusCode();
            LOG.debug("Http responseCode: {}", responseCode);

            if (!throwException) {
                // if we do not use failed exception then populate response for all response codes
                populateResponse(exchange, httpRequest, httpResponse, in, strategy, responseCode);
            } else {
                boolean ok = HttpHelper.isStatusCodeOk(responseCode, getEndpoint().getOkStatusCodeRange());
                if (ok) {
                    // only populate response for OK response
                    populateResponse(exchange, httpRequest, httpResponse, in, strategy, responseCode);
                } else {
                    // operation failed so populate exception to throw
                    throw populateHttpOperationFailedException(exchange, httpRequest, httpResponse, responseCode);
                }
            }
        } finally {
            if (httpResponse != null) {
                try {
                    EntityUtils.consume(httpResponse.getEntity());
                } catch (IOException e) {
                    // nothing we could do
                }
            }
        }


Specifically, that finally block at the end.
When disableStreamCache=true is set on the Producer, the raw input stream is put in the exchange body, which was the change fixed by CAMEL-7638
However, the finally block is consuming and closing that input stream making it unusable later when we try to copy it to the servlet output stream to send back to the caller.
I think the fix for this would be to check the endpoint to see if disableStreamCaching is set prior to consuming the entity in the finally block, perhaps something like this:


    ...
    } finally {
            if (httpResponse != null &amp;amp;&amp;amp; !getEndpoint().isDisableStreamCache()) {
                try {
                    EntityUtils.consume(httpResponse.getEntity());
                } catch (IOException e) {
                    // nothing we could do
                }
            }
        }

</description>
			<version>2.17.0</version>
			<fixedVersion>2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.http4.HttpProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9828" opendate="2016-04-07 08:06:36" fixdate="2016-04-07 10:34:05" resolution="Fixed">
		<buginformation>
			<summary>Swagger seems to inject empty headers</summary>
			<description>See http://camel.465427.n5.nabble.com/swagger-injects-empty-headers-in-2-17-0-td5780620.html
key part copied below.
I have routes built using REST DSL, and this includes swagger definitions.
With 2.1.6.2 all was good.
On switching to 2.17.0 I find that having a swagger query parameter definition causes a header property to be defined as an empty string even when there is no query parameter defined.
As an example, the REST DSL snippet looks like this:
.post("/
{notebookid}
/e").description("Description ...")
.bindingMode(RestBindingMode.json).produces("application/json")
.outType(Foo.class)
.param().name("notebookid").type(path).description("Notebook ID").dataType("long").endParam()
.param().name("parent").type(query).description("The parent").dataType("long").required(false).endParam()
.route()
.process((Exchange exch) -&amp;gt; 
{
    Long parent = exch.getIn().getHeader("parent", Long.class);
    ...
}
)
.endRest()
"parent" is an optional query param.
With 2.16.2 there was no "parent" header.
With 2.17.0 a "parent" header is magically added with the value being the empty string, which causes the TypeConversion to Long to blow up. 
If I remove the swagger params then it works OK again.</description>
			<version>2.17.0</version>
			<fixedVersion>2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.rest.RestDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="9841" opendate="2016-04-08 13:31:42" fixdate="2016-04-09 05:56:59" resolution="Fixed">
		<buginformation>
			<summary>NPE in MIME-Multipart Data Format if no file name is defined on attachment</summary>
			<description>If an MIME-Multipart message is unmarshalled into a Camel Message with attachments and the attachment parts do not have a file name defined, the MIME-Multipart data format will throw a NullPointerException (because the file name is used as the key for the map where the DataHandler is stored in the Camel Message).
The provided patch checks whether there is a file name defined on the data handler. If this is not the case the Content-ID header of the attachment is used, if that is also not defined a unique id is generated for the key.
See the two attached MIME-Multipart documents used in the unit tests for details.</description>
			<version>2.17.0</version>
			<fixedVersion>2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.mime.multipart.MimeMultipartDataFormatTest.java</file>
			<file type="M">org.apache.camel.dataformat.mime.multipart.MimeMultipartDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="9863" opendate="2016-04-13 07:16:45" fixdate="2016-04-13 09:22:52" resolution="Fixed">
		<buginformation>
			<summary>loopDoWhile will loop forever if using ahc component in the loop.</summary>
			<description>I have tested several times. The loop condition will not be checked if ahc component is in the loop.
        from("quartz2://jf-log/trigger3?trigger.repeatInterval=2&amp;amp;trigger.repeatCount=0")
            .loopDoWhile(body().isNotEqualTo("done"))
              .setHeader(Exchange.HTTP_METHOD, constant("GET"))
              .to("ahc:https://www.baidu.com/")
              .choice()
              .when(exchangeProperty("CamelLoopIndex").isEqualTo(3))
                .setBody(constant("done"))
                .endChoice()
              .end()
            .end()
            .to("mock:result");
The loop will be infinite, the workarround is to use http component instead of ahc.</description>
			<version>2.17.0</version>
			<fixedVersion>2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.LoopProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="9862" opendate="2016-04-12 12:51:10" fixdate="2016-04-13 11:36:56" resolution="Fixed">
		<buginformation>
			<summary>Potential NPE in UndertowComponent.unregisterConsumer</summary>
			<description>There&amp;amp;apos;s a potential NPE in the UndertowComponent class when Undertow consumers are stopped. Here&amp;amp;apos;s a snippet from the unregisterConsumer method:


    public void unregisterConsumer(UndertowConsumer consumer) {
        int port = consumer.getEndpoint().getHttpURI().getPort();
        if (serversRegistry.containsKey(port)) {
            serversRegistry.get(port).unregisterConsumer(consumer);
        }
        if (serversRegistry.get(port).isEmpty()) {
          // stuff happens here
        }
    }


If serversRegistry.containsKey returns false for the given port, then we should not be proceeding to call methods like isEmpty afterwards.</description>
			<version>2.16.3</version>
			<fixedVersion>2.16.4, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.undertow.UndertowComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="9866" opendate="2016-04-13 12:51:22" fixdate="2016-04-14 05:43:35" resolution="Fixed">
		<buginformation>
			<summary>@PropertyInject doesn&amp;apos;t work with Spring-Boot</summary>
			<description>When I upgraded Camel Spring-Boot project to use Camel 2.16.3 from Camel 2.16.2 the @PropertyInject annotations broke.
The problem occurs when using the annotation in a Spring-Boot application like this


@SpringBootApplication
public class MySpringBootRouter extends FatJarRouter {

    @PropertyInject("inject-value")
    private String injectedValue;
    
    @Override
    public void configure() {
        from("timer:trigger")
        .log("PropertyInject: "+injectedValue);
    }
}


Running the code above with command

mvn spring-boot:run


causes the following exception:

java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.springframework.boot.maven.AbstractRunMojo$LaunchRunner.run(AbstractRunMojo.java:478)
	at java.lang.Thread.run(Thread.java:745)
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;mySpringBootRouter&amp;amp;apos;: Initialization of bean failed; nested exception is org.apache.camel.spring.GenericBeansException: Error post processing bean: mySpringBootRouter; nested exception is org.apache.camel.RuntimeCamelException: java.lang.IllegalArgumentException: Cannot add component as its already previously added: properties
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:772)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:839)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:538)
	at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:118)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:766)
	at org.springframework.boot.SpringApplication.createAndRefreshContext(SpringApplication.java:361)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:307)
	at org.apache.camel.spring.boot.FatJarRouter.main(FatJarRouter.java:26)
	... 6 more
Caused by: org.apache.camel.spring.GenericBeansException: Error post processing bean: mySpringBootRouter; nested exception is org.apache.camel.RuntimeCamelException: java.lang.IllegalArgumentException: Cannot add component as its already previously added: properties
	at org.apache.camel.spring.CamelBeanPostProcessor.postProcessBeforeInitialization(CamelBeanPostProcessor.java:154)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:408)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1570)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:545)
	... 19 more
Caused by: org.apache.camel.RuntimeCamelException: java.lang.IllegalArgumentException: Cannot add component as its already previously added: properties
	at org.apache.camel.util.ObjectHelper.wrapRuntimeCamelException(ObjectHelper.java:1680)
	at org.apache.camel.impl.CamelPostProcessorHelper.getInjectionPropertyValue(CamelPostProcessorHelper.java:263)
	at org.apache.camel.impl.DefaultCamelBeanPostProcessor.injectFieldProperty(DefaultCamelBeanPostProcessor.java:206)
	at org.apache.camel.impl.DefaultCamelBeanPostProcessor$1.doWith(DefaultCamelBeanPostProcessor.java:172)
	at org.apache.camel.util.ReflectionHelper.doWithFields(ReflectionHelper.java:73)
	at org.apache.camel.impl.DefaultCamelBeanPostProcessor.injectFields(DefaultCamelBeanPostProcessor.java:168)
	at org.apache.camel.impl.DefaultCamelBeanPostProcessor.postProcessBeforeInitialization(DefaultCamelBeanPostProcessor.java:82)
	at org.apache.camel.spring.CamelBeanPostProcessor.postProcessBeforeInitialization(CamelBeanPostProcessor.java:148)
	... 22 more
Caused by: java.lang.IllegalArgumentException: Cannot add component as its already previously added: properties
	at org.apache.camel.impl.DefaultCamelContext.addComponent(DefaultCamelContext.java:370)
	at org.apache.camel.util.CamelContextHelper.lookupPropertiesComponent(CamelContextHelper.java:578)
	at org.apache.camel.impl.CamelPostProcessorHelper.getInjectionPropertyValue(CamelPostProcessorHelper.java:237)
	... 28 more


Using placeholders like 

.log("{{inject-value}}")

 still works just as before. I tried to browse through changes between 2.16.2 and 2.16.3 but I didn&amp;amp;apos;t catch any obvious reason for this problem.
I created a runnable demo of the problem here: https://github.com/jnupponen/camel-properties-component-spring-boot-problem</description>
			<version>2.16.3</version>
			<fixedVersion>2.16.4, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.boot.CamelAutoConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="9851" opendate="2016-04-10 23:39:40" fixdate="2016-04-15 06:54:32" resolution="Fixed">
		<buginformation>
			<summary>Zookeeper RoutePolicy failing to create znode</summary>
			<description>I am trying to setup a ZooKeeper route policy like this
ZooKeeperRoutePolicy policy = new ZooKeeperRoutePolicy("zookeeper:localhost/regexTest1?create=true", 1);
from("direct:start").routePolicy(policy).to(mock:end);
And when I run my unit test to trigger the route, I get the following exception in my logs

Node &amp;amp;apos;/regexTest1/192.168.202.25-3306c9d2-1354-4dbe-aaff-846eee5bb60d&amp;amp;apos; did not exist, creating it.
Error setting up election node /regexTest1/192.168.202.25-25829641-de1f-4389-9bb6-2967ea60de1a
org.apache.zookeeper.KeeperException$NoNodeException: KeeperErrorCode = NoNode for /regexTest1/192.168.202.25-25829641-de1f-4389-9bb6-2967ea60de1a
	at org.apache.zookeeper.KeeperException.create(KeeperException.java:111) ~[zookeeper-3.4.8.jar:3.4.8--1]
	at org.apache.zookeeper.KeeperException.create(KeeperException.java:51) ~[zookeeper-3.4.8.jar:3.4.8--1]
	at org.apache.zookeeper.ZooKeeper.create(ZooKeeper.java:783) ~[zookeeper-3.4.8.jar:3.4.8--1]
	at org.apache.camel.component.zookeeper.operations.CreateOperation.getResult(CreateOperation.java:52) ~[camel-zookeeper-2.17.0.jar:2.17.0]
	at org.apache.camel.component.zookeeper.operations.ZooKeeperOperation.get(ZooKeeperOperation.java:70) ~[camel-zookeeper-2.17.0.jar:2.17.0]
	at org.apache.camel.component.zookeeper.ZookeeperProducer.createNode(ZookeeperProducer.java:222) ~[camel-zookeeper-2.17.0.jar:2.17.0]
	at org.apache.camel.component.zookeeper.ZookeeperProducer.synchronouslySetData(ZookeeperProducer.java:238) ~[camel-zookeeper-2.17.0.jar:2.17.0]
	at org.apache.camel.component.zookeeper.ZookeeperProducer.process(ZookeeperProducer.java:88) ~[camel-zookeeper-2.17.0.jar:2.17.0]
	at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61) ~[camel-core-2.17.0.jar:2.17.0]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:190) [camel-core-2.17.0.jar:2.17.0]
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:109) [camel-core-2.17.0.jar:2.17.0]
	at org.apache.camel.processor.UnitOfWorkProducer.process(UnitOfWorkProducer.java:68) [camel-core-2.17.0.jar:2.17.0]
	at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:412) [camel-core-2.17.0.jar:2.17.0]
	at org.apache.camel.impl.ProducerCache$2.doInProducer(ProducerCache.java:380) [camel-core-2.17.0.jar:2.17.0]
	at org.apache.camel.impl.ProducerCache.doInProducer(ProducerCache.java:270) [camel-core-2.17.0.jar:2.17.0]
	at org.apache.camel.impl.ProducerCache.sendExchange(ProducerCache.java:380) [camel-core-2.17.0.jar:2.17.0]
	at org.apache.camel.impl.ProducerCache.send(ProducerCache.java:205) [camel-core-2.17.0.jar:2.17.0]
	at org.apache.camel.impl.DefaultProducerTemplate.send(DefaultProducerTemplate.java:119) [camel-core-2.17.0.jar:2.17.0]
	at org.apache.camel.component.zookeeper.policy.ZooKeeperElection.createCandidateNode(ZooKeeperElection.java:146) [camel-zookeeper-2.17.0.jar:2.17.0]
	at org.apache.camel.component.zookeeper.policy.ZooKeeperElection.testAndCreateCandidateNode(ZooKeeperElection.java:116) [camel-zookeeper-2.17.0.jar:2.17.0]
	at org.apache.camel.component.zookeeper.policy.ZooKeeperElection.isMaster(ZooKeeperElection.java:92) [camel-zookeeper-2.17.0.jar:2.17.0]
	at org.apache.camel.component.zookeeper.policy.ZooKeeperRoutePolicy.onExchangeBegin(ZooKeeperRoutePolicy.java:79) [camel-zookeeper-2.17.0.jar:2.17.0]
	at org.apache.camel.processor.CamelInternalProcessor$RoutePolicyAdvice.before(CamelInternalProcessor.java:483) [camel-core-2.17.0.jar:2.17.0]


It looks like it knows the znode doesnt exist but seems to be unable to create it? From the zookeeper server side logs, I can see incoming connections and it returning the error that the znode doesnt exist but doesnt look like theres any attempts to create it after that.
Ive tried using the zookeeper component directly in my route and I am able to create/write/read from a znode fine so it seems like its just failing in the route policy for some reason.
I am using Camel 2.17.0 and zookeeper 3.4.8
Ive investigated this further and the exception is thrown from the ZooKeeper.create method. Camel is actually trying to create a znode with a path /regexTest1/192.168.202.25-25829641-de1f-4389-9bb6-2967ea60de1a without creating the parent node /regexTest1 first. 
According to the Zookeeper.create method documentation 
"If the parent node does not exist in the ZooKeeper, a KeeperException

with error code KeeperException.NoNode will be thrown."

And I dont see anywhere in Camels code where it is creating the parent nodes first before attempting to create the final node for master election.
So I removed the path off the uri for the route policy like this
ZooKeeperRoutePolicy policy = new ZooKeeperRoutePolicy("zookeeper:localhost", 1);
And it has gotten past that error but now has encountered a different error where it has trouble creating a threadpool.

2016-04-08 11:47:15,071 [main] ERROR org.apache.camel.component.zookeeper.policy.ZooKeeperElection - Error configuring ZookeeperElection
java.lang.IllegalArgumentException: id for thread pool org.apache.camel.util.concurrent.RejectableThreadPoolExecutor@1ec912d7[Running, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 0][Camel-Zookeeper Ops executor] must be specified and not empty
	at org.apache.camel.util.ObjectHelper.notEmpty(ObjectHelper.java:351) ~[camel-core-2.16.0.jar:2.16.0]
	at org.apache.camel.impl.DefaultExecutorServiceManager.onThreadPoolCreated(DefaultExecutorServiceManager.java:522) ~[camel-core-2.16.0.jar:2.16.0]
	at org.apache.camel.impl.DefaultExecutorServiceManager.newThreadPool(DefaultExecutorServiceManager.java:191) ~[camel-core-2.16.0.jar:2.16.0]
	at org.apache.camel.impl.DefaultExecutorServiceManager.newFixedThreadPool(DefaultExecutorServiceManager.java:230) ~[camel-core-2.16.0.jar:2.16.0]
	at org.apache.camel.component.zookeeper.ZooKeeperConsumer.doStart(ZooKeeperConsumer.java:72) ~[camel-zookeeper-2.16.0.jar:2.16.0]
	at org.apache.camel.support.ServiceSupport.start(ServiceSupport.java:61) ~[camel-core-2.16.0.jar:2.16.0]
	at org.apache.camel.impl.DefaultCamelContext.startService(DefaultCamelContext.java:3219) ~[camel-core-2.16.0.jar:2.16.0]

</description>
			<version>2.17.0</version>
			<fixedVersion>2.16.4, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.zookeeper.operations.CreateOperation.java</file>
			<file type="M">org.apache.camel.component.zookeeper.operations.CreateOperationTest.java</file>
			<file type="M">org.apache.camel.component.zookeeper.policy.ZooKeeperElection.java</file>
			<file type="M">org.apache.camel.component.zookeeper.ZooKeeperConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9890" opendate="2016-04-20 11:16:30" fixdate="2016-04-20 13:03:09" resolution="Fixed">
		<buginformation>
			<summary>Migrate Camel-websocket to Jetty9</summary>
			<description>I guess it&amp;amp;apos;s time to switch to Jetty 9.</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.websocket.WebsocketProducer.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketComponent.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketComponentTest.java</file>
			<file type="M">org.apache.camel.component.websocket.JettyClassPathResource.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketComponentServlet.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketProducerTest.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketComponentServletTest.java</file>
			<file type="M">org.apache.camel.component.websocket.DefaultWebsocket.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketSSLRouteExampleTest.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketClientCamelRouteTest.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketTwoRoutesExampleTest.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketTwoRoutesToSameEndpointExampleTest.java</file>
			<file type="M">org.apache.camel.component.websocket.WebscoketEndpointConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketRouteExampleTest.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketProducerRouteRestartTest.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketConsumerRouteTest.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketTwoRoutesToSIndividualAndBroadcastEndpointExampleTest.java</file>
			<file type="M">org.apache.camel.component.websocket.WebSocketFactory.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketComponentRouteExampleTest.java</file>
			<file type="M">org.apache.camel.component.websocket.DefaultWebsocketFactory.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketProducerRouteExampleTest.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketSSLContextInUriRouteExampleTest.java</file>
			<file type="M">org.apache.camel.component.websocket.DefaultWebsocketTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8789</link>
			<link type="Reference" description="is related to">8789</link>
		</links>
	</bug>
	<bug id="9898" opendate="2016-04-21 10:17:07" fixdate="2016-04-21 19:42:29" resolution="Fixed">
		<buginformation>
			<summary>SimpleBuilder throws NullPointerException when replacing string using regexAll method and the regex contains }</summary>
			<description>
Add this unit test in org.apache.camel.builder.SimpleBuilderTest to reproduce the issue. Only fails when the regex contains }


public  void testRegexAllWithPlaceHolders() {
        exchange.getIn().setHeader("activateUrl", "http://some/rest/api/(id)/activate");
        assertEquals("http://some/rest/api/12/activate",SimpleBuilder.simple("${header.activateUrl.replaceAll(\"\\(id\\)\",\"12\")}").evaluate(exchange,String.class));

        //passes when contains { only
        exchange.getIn().setHeader("activateUrl", "http://some/rest/api/{id/activate");
        assertEquals("http://some/rest/api/12/activate",SimpleBuilder.simple("${header.activateUrl.replaceAll(\"\\{id\",\"12\")}").evaluate(exchange,String.class));


        String replaced  = "http://some/rest/api/{id}/activate".replaceAll("\\{id\\}","12");
        assertEquals( "http://some/rest/api/12/activate", replaced);
        /// But throws throws NullPointerException when regexALl inside a simple expression
        exchange.getIn().setHeader("activateUrl", "http://some/rest/api/{id}/activate");
        assertEquals("http://some/rest/api/12/activate",SimpleBuilder.simple("${header.activateUrl.replaceAll(\"\\{id\\}\",\"12\")}").evaluate(exchange,String.class));
    }

</description>
			<version>2.17.0</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.language.simple.SimpleTest.java</file>
			<file type="M">org.apache.camel.builder.SimpleBuilderTest.java</file>
			<file type="M">org.apache.camel.language.simple.SimpleTokenizer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9903" opendate="2016-04-22 13:29:04" fixdate="2016-04-22 19:07:38" resolution="Fixed">
		<buginformation>
			<summary>DumpRouteStatsAsXml do not work when jmx domain is customized</summary>
			<description>According to the documentation (Here) we can customize the jmx domain name.
When the domain name is different from org.apache.camel all the dumpRouteStatsAsXml are empty and does not work anymore.
After some investigation it is because the MBean operation does not take into account the runtime domain name and only use "org.apache.camel" (here) 
I&amp;amp;apos;ve done a unit test to reproduce and tried to do a fix,</description>
			<version>2.17.0</version>
			<fixedVersion>2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.management.mbean.ManagedCamelContext.java</file>
			<file type="M">org.apache.camel.management.mbean.ManagedRoute.java</file>
		</fixedFiles>
	</bug>
	<bug id="9906" opendate="2016-04-23 06:07:08" fixdate="2016-04-23 06:53:34" resolution="Fixed">
		<buginformation>
			<summary>camel-sql - Should allow null values as a valid value</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/2-17-0-NULLs-are-not-allowed-with-named-parameter-in-SQL-component-tp5781552.html</description>
			<version>2.17.0</version>
			<fixedVersion>2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sql.DefaultSqlPrepareStatementStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="9896" opendate="2016-04-21 08:31:38" fixdate="2016-04-23 09:04:46" resolution="Fixed">
		<buginformation>
			<summary>Deadletter Failure processor is invoked even if error handling strategy defines to continue routing</summary>
			<description>When a DeadLetterChannel is used as context scoped error handling strategy with FailureProcessor set and a route scoped error handling strategy is defined to continue routing in case of certain exception classes, then it is observed that even in case of exceptions which belong to exceptions defined in OnException clause, the dead letter&amp;amp;apos;s failure processor is still triggered. 
A test case to simulate this behaviour is pasted. 
http://pastebin.com/raw/cfQhsJj0 - contains test case.
http://pastebin.com/raw/K6wZc9Yh - test output</description>
			<version>2.15.6</version>
			<fixedVersion>2.16.4, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.issues.OnExceptionContinuedNoFailureProcessorTest.java</file>
			<file type="M">org.apache.camel.processor.RedeliveryErrorHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="9872" opendate="2016-04-17 22:40:07" fixdate="2016-04-24 09:07:25" resolution="Fixed">
		<buginformation>
			<summary>VetoCamelContextStartException with rethrowException=false cases MainSupport class to hang</summary>
			<description>Hi,
I just created my own LifecycleStrategy implementation, that performs some sanity checks on context startup, and throws a VetoCamelContextStartException if it detects a problem. But since I only want a user friendly error message to be printed, and no stack trace, I opted to have rethrowException=false. That caused Camel to abort the start of the context. But it keeps the process running, instead of letting it terminate. If I use rethrowException=false the process terminates as expected.
When debugging this in Eclipse, I see that Camel get stuck in the method waitUntilCompleted() in org.apache.camel.main.MainSupport.
I use Apache Camel 2.17.0, Camel Spring (XML), and start the process using org.apache.camel.spring.Main. When asking about this behaivor in the user mailing list, Claus Ibsen hinted that this is a bug that I should report here. Apparently the Main class doesn&amp;amp;apos;t handle the veto properly.
Regards
/Jimi</description>
			<version>2.17.0</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.processor.SpringCamelContextLogExhaustedMessageBodyTest.java</file>
			<file type="M">org.apache.camel.spring.handler.CamelNamespaceHandler.java</file>
			<file type="M">org.apache.camel.spring.CamelContextFactoryBean.java</file>
			<file type="M">org.apache.camel.spring.Main.java</file>
			<file type="M">org.apache.camel.CamelContext.java</file>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
			<file type="M">org.apache.camel.main.Main.java</file>
		</fixedFiles>
	</bug>
	<bug id="9887" opendate="2016-04-19 16:02:22" fixdate="2016-04-24 13:49:41" resolution="Fixed">
		<buginformation>
			<summary>onCompletion not called on Splitter configured with CompletionAwareAggregationStrategy and shareUnitOfWork=true</summary>
			<description>In 2.17.0, if a Splitter is configured with shareUnitOfWork=true, then its AggregationStrategy is now wrapped by a ShareUnitOfWorkAggregationStrategy. This causes the following code from MulticastProcessor.doDone() to fail to invoke onCompletion when the configured strategy implements CompletionAwareAggregationStrategy.

if (strategy instanceof CompletionAwareAggregationStrategy) {
    ((CompletionAwareAggregationStrategy) strategy).onCompletion(subExchange);
}


It appears the change was a part of CAMEL-9573.
I haven&amp;amp;apos;t completely analyzed the shared unit of work changes but one possible approach to fix this would be to have the ShareUnitOfWorkAggregationStrategy implement CompletionAwareAggregationStrategy and then have its onCompletionMethod delegate to the wrapped strategy iff it also implements CompletionAwareAggregationStrategy.</description>
			<version>2.17.0</version>
			<fixedVersion>2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.aggregate.AggregateProcessor.java</file>
			<file type="M">org.apache.camel.processor.aggregate.ShareUnitOfWorkAggregationStrategy.java</file>
			<file type="M">org.apache.camel.processor.MulticastProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="9911" opendate="2016-04-25 17:18:05" fixdate="2016-04-27 06:31:21" resolution="Fixed">
		<buginformation>
			<summary>RestBindingMode auto not honored</summary>
			<description>The usage of rest binding mode is confusing/doesn&amp;amp;apos;t work consistently.
If you look at the field definition:


    @XmlAttribute @Metadata(defaultValue = "auto")
    private RestBindingMode bindingMode;


You would expect that the default value is "auto" but in fact there is no default when running.
You need to explicitly set it in configuration, like this:


restConfiguration()
                .component("jetty")
                .port(9097)
                .bindingMode(RestBindingMode.auto)
        ;

</description>
			<version>2.17.0</version>
			<fixedVersion>2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.rest.RestBindingDefinition.java</file>
			<file type="M">org.apache.camel.model.rest.RestConfigurationDefinition.java</file>
			<file type="M">org.apache.camel.processor.binding.RestBindingProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="9917" opendate="2016-04-27 14:37:24" fixdate="2016-04-27 14:42:25" resolution="Fixed">
		<buginformation>
			<summary>Route stopped events are sent in inconsistent order</summary>
			<description></description>
			<version>2.17.0</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultCamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="9784" opendate="2016-03-31 12:28:30" fixdate="2016-04-28 07:05:52" resolution="Fixed">
		<buginformation>
			<summary>Camel polling the files from S3 only once if deleteAfterRead is false</summary>
			<description>if deleteAfterRead option is kept false while fetching all the files in the S3 bucket to linux machine, Camel polls all the files only once. I tried to debug org.apache.camel.component.aws.s3.S3Consumer.java class inside method poll() there is check for filesConsumed boolean variable which seems to be always true after the first polling and then it never access any files.
Same issue was reported http://stackoverflow.com/questions/34193738/apache-camel-s3-only-do-polling-once but the suggestion was to downgrade to 2.16.0 which has many different issues which got fixed in 2.17.0</description>
			<version>2.17.0</version>
			<fixedVersion>2.16.4, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.aws.s3.S3Consumer.java</file>
			<file type="M">org.apache.camel.component.aws.s3.S3Configuration.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8431</link>
		</links>
	</bug>
	<bug id="9920" opendate="2016-04-27 18:57:22" fixdate="2016-04-28 07:11:18" resolution="Fixed">
		<buginformation>
			<summary>Handle SocketTimeoutException on accept</summary>
			<description>The MLLP receiver logs and error when a SocketTimeoutException is encountered while waiting for a connection.  It will not successfully accept connections after that.</description>
			<version>2.17.0</version>
			<fixedVersion>2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mllp.MllpTcpServerConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9805" opendate="2016-04-04 06:24:11" fixdate="2016-04-28 08:15:57" resolution="Fixed">
		<buginformation>
			<summary>camel-sql - body not copied from in to out when useing outputHeader and outputType=SelectOne when sql doesn&amp;apos;t return a result</summary>
			<description>When using the options outputHeader and outputType=SelectOne the body of the Exchange is not copied from in to out when the select returns no data..
Probably root is line 175-185 of SqlProducer.java that is missing an else for the above mentioned case.


if (data != null) { // &amp;lt;--- Missing the else
// for noop=true we still want to enrich with the row count header
  if (getEndpoint().isNoop()) {
    exchange.getOut().setBody(exchange.getIn().getBody());
  } else if (getEndpoint().getOutputHeader() != null) {
    exchange.getOut().setBody(exchange.getIn().getBody());
    exchange.getOut().setHeader(getEndpoint().getOutputHeader(), data);
  } else {
    exchange.getOut().setBody(data); 
  }
  exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT, 1);
}


following could be added (untested)


else { // if data == null
if (getEndpoint().isNoop()) {
                                        exchange.getOut().setBody(exchange.getIn().getBody());
                                    } else if (getEndpoint().getOutputHeader() != null) {
                                        exchange.getOut().setBody(exchange.getIn().getBody());
                                    }
 exchange.getOut().setHeader(SqlConstants.SQL_ROW_COUNT, 0);
}


</description>
			<version>2.17.0</version>
			<fixedVersion>2.16.4, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.elsql.ElsqlProducer.java</file>
			<file type="M">org.apache.camel.component.sql.SqlProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9874" opendate="2016-04-18 09:05:09" fixdate="2016-04-28 08:28:12" resolution="Fixed">
		<buginformation>
			<summary>Camel Jetty consumer endpoint incorrectly handles multipart/form-data</summary>
			<description>The problem lies in the way Camel Jetty (camel-jetty9 to be precise) handles multipart/form-data requets.
The issue consists of two parts:

NPE is thrown if no Content-Type is specified in a part;
Only application/octet-stream part Content-Type is supported (not sure whether it actually should be relevant)

Location in code:
https://github.com/apache/camel/blob/c134e5a6e104c60ddcd198341718a37f0a4401ba/components/camel-jetty9/src/main/java/org/apache/camel/component/jetty9/AttachmentHttpBinding.java#L53
To reproduce:


from("jetty:http://0.0.0.0:8028").process((e) -&amp;gt; {});


The call (generated from postman)


OkHttpClient client = new OkHttpClient();

MediaType mediaType = MediaType.parse("multipart/form-data; boundary=---011000010111000001101001");
RequestBody body = RequestBody.create(mediaType, "-----011000010111000001101001\r\nContent-Disposition: form-data; name=\"test\"\r\n\r\ntest\r\n-----011000010111000001101001--");
Request request = new Request.Builder()
  .url("http://localhost:8028/")
  .post(body)
  .addHeader("content-type", "multipart/form-data; boundary=---011000010111000001101001")
  .addHeader("cache-control", "no-cache")
  .addHeader("postman-token", "a9fd95b6-04b9-ea7a-687e-ff828ea00774")
  .build();

Response response = client.newCall(request).execute();


Exception:


org.apache.camel.RuntimeCamelException: Cannot populate attachments
        at org.apache.camel.component.jetty9.AttachmentHttpBinding.populateAttachments(AttachmentHttpBinding.java:56) ~[camel-jetty-2.17.0.jar!/:2.17.0]
        at org.apache.camel.http.common.DefaultHttpBinding.readRequest(DefaultHttpBinding.java:176) ~[camel-http-common-2.17.0.jar!/:2.17.0]
        at org.apache.camel.http.common.HttpMessage.&amp;lt;init&amp;gt;(HttpMessage.java:52) ~[camel-http-common-2.17.0.jar!/:2.17.0]
        at org.apache.camel.component.jetty.CamelContinuationServlet.service(CamelContinuationServlet.java:161) ~[camel-jetty-common-2.17.0.jar!/:2.17.0]
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:790) ~[javax.servlet-api-3.1.0.jar!/:3.1.0]
        at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:812) ~[jetty-servlet-9.2.15.v20160210.jar!/:9.2.15.v20160210]
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1669) ~[jetty-servlet-9.2.15.v20160210.jar!/:9.2.15.v20160210]
        at org.eclipse.jetty.servlets.MultiPartFilter.doFilter(MultiPartFilter.java:200) ~[jetty-servlets-9.2.15.v20160210.jar!/:9.2.15.v20160210]
        at org.apache.camel.component.jetty.CamelFilterWrapper.doFilter(CamelFilterWrapper.java:43) ~[camel-jetty-common-2.17.0.jar!/:2.17.0]
        at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1652) ~[jetty-servlet-9.2.15.v20160210.jar!/:9.2.15.v20160210]
        at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:585) [jetty-servlet-9.2.15.v20160210.jar!/:9.2.15.v20160210]
        at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1127) [jetty-server-9.2.15.v20160210.jar!/:9.2.15.v20160210]
        at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:515) [jetty-servlet-9.2.15.v20160210.jar!/:9.2.15.v20160210]
        at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1061) [jetty-server-9.2.15.v20160210.jar!/:9.2.15.v20160210]
        at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141) [jetty-server-9.2.15.v20160210.jar!/:9.2.15.v20160210]
        at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97) [jetty-server-9.2.15.v20160210.jar!/:9.2.15.v20160210]
        at org.eclipse.jetty.server.Server.handle(Server.java:499) [jetty-server-9.2.15.v20160210.jar!/:9.2.15.v20160210]
        at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:311) [jetty-server-9.2.15.v20160210.jar!/:9.2.15.v20160210]
        at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:257) [jetty-server-9.2.15.v20160210.jar!/:9.2.15.v20160210]
        at org.eclipse.jetty.io.AbstractConnection$2.run(AbstractConnection.java:544) [jetty-io-9.2.15.v20160210.jar!/:9.2.15.v20160210]
        at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:635) [jetty-util-9.2.15.v20160210.jar!/:9.2.15.v20160210]
        at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:555) [jetty-util-9.2.15.v20160210.jar!/:9.2.15.v20160210]
        at java.lang.Thread.run(Thread.java:745) [na:1.8.0_73]
Caused by: java.lang.NullPointerException: null
        at org.apache.camel.component.jetty9.AttachmentHttpBinding.populateAttachments(AttachmentHttpBinding.java:48) ~[camel-jetty-2.17.0.jar!/:2.17.0]
        ... 22 common frames omitted


SO: https://stackoverflow.com/questions/36656340/how-to-upload-a-file-via-multipart-form-data-file-upload-to-camel-jetty-2-17-0</description>
			<version>2.17.0</version>
			<fixedVersion>2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.MultiPartFormWithCustomFilterTest.java</file>
			<file type="M">org.apache.camel.component.jetty9.AttachmentHttpBinding.java</file>
			<file type="M">org.apache.camel.component.jetty.MultiPartFormTest.java</file>
			<file type="M">org.apache.camel.component.jetty.HttpBridgeMultipartRouteTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9854" opendate="2016-04-11 11:52:42" fixdate="2016-04-28 12:18:28" resolution="Fixed">
		<buginformation>
			<summary>CXF Stream Cache contains duplicate namespace definition</summary>
			<description>If stream caching is enabled for incoming messages in Camel-CXF and a namespace defined on the SOAP envelope is also defined on the root tag of the payload document the XML contained within the stream cache contains a duplicate namespace definition.
See attached unit test for details</description>
			<version>2.16.3</version>
			<fixedVersion>2.16.4, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.converter.DelegatingXMLStreamReader.java</file>
		</fixedFiles>
	</bug>
	<bug id="7443" opendate="2014-05-16 09:53:26" fixdate="2016-04-28 12:28:35" resolution="Fixed">
		<buginformation>
			<summary>Remote Print URI changed to UNC Name</summary>
			<description>I&amp;amp;apos;m using a printing URI in the form of lpr://lh.abc.de:631/bbk-test (Hostname changed) and getting an PrintException:
Reason: javax.print.PrintException: No printer found with name: \\lhgoe.gbv.de\bbk-test. Please verify that the host and printer are registered and reachable from this machine.
Which is true, since Camel Printer has changed my URI to a Windows UNC (see backslashes).</description>
			<version>2.13.0</version>
			<fixedVersion>2.16.4, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.printer.PrinterProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9200" opendate="2015-10-08 04:27:03" fixdate="2016-04-28 15:20:53" resolution="Fixed">
		<buginformation>
			<summary>Context component conflates endpoints with the same local id from different CamelContexts</summary>
			<description>The context component experiences clashes between endpoints with the same local name, but from different contexts.  If two contexts both contain a local endpoint "direct:out", any route involving both endpoints will fail to start due to a FailedToStartRouteException; "Multiple consumers for the same endpoint is not allowed: Endpoint[direct://out]."
As an example, the following set of routes will fail due to this issue:
from("direct:in").to("blackBox:in");
from("blackBox:out").to("direct:out");
from("direct:out").to("mock:results");
See  thread:
http://camel.465427.n5.nabble.com/Context-Component-issue-td5770975.html</description>
			<version>2.15.3</version>
			<fixedVersion>2.16.4, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.cdi.test.ContextComponentTest.java</file>
			<file type="M">org.apache.camel.component.context.LocalContextComponent.java</file>
			<file type="M">org.apache.camel.component.context.SpringDslContextComponentTest.java</file>
			<file type="M">org.apache.camel.impl.DefaultEndpoint.java</file>
			<file type="M">org.apache.camel.component.context.ContextEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="9929" opendate="2016-04-29 12:10:18" fixdate="2016-04-29 12:13:14" resolution="Fixed">
		<buginformation>
			<summary>camel-restlet - Using synchronous=false with no error handler leak inflight exchange</summary>
			<description>invoking restlet component within a recipientList EIP with noErrorHandler configured on route is causing DefaultExchange&amp;amp;apos;s to build up in org.apache.camel.impl.DefaultInflightRepository.</description>
			<version>2.17.0</version>
			<fixedVersion>2.16.4, 2.17.1, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.RestletProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9933" opendate="2016-05-02 05:31:18" fixdate="2016-05-02 09:51:39" resolution="Fixed">
		<buginformation>
			<summary>Camel-CSV marshalling breaks characters not in default charset</summary>
			<description>Marshalling data with camel-csv will use the JVM default encoding instead of the one configured for the message. This will break non-ascii characters, especially if the platform default encoding does not support them (e.g. because the platform default encoding is ASCII)</description>
			<version>2.16.3</version>
			<fixedVersion>2.16.4, 2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.csv.CsvMarshaller.java</file>
		</fixedFiles>
	</bug>
	<bug id="7884" opendate="2014-10-01 06:29:14" fixdate="2016-05-03 12:29:17" resolution="Fixed">
		<buginformation>
			<summary>camel-netty4-http does not work for HTTP POST requests on routingSlip</summary>
			<description>I tried to add the camel-netty4-http component to a proper working project that uses camel-netty-http.
HTTP GET requests are working properly but POST requests are not working.
It might be an issue in Netty but I could not find a solution to get it to work.
Here is the exception I see:
2014-10-01 09:12:18,012 DEBUG [042ase_1412143933559.data] [n.s.ehcache.store.disk.Segment]     fault removed 0 from heap
2014-10-01 09:12:18,012 DEBUG [042ase_1412143933559.data] [n.s.ehcache.store.disk.Segment]     fault added 0 on disk
2014-10-01 09:12:18,012 TRACE [pool-1-thread-1          ] [o.a.c.i.c.DefaultTypeConverter]     Converting io.netty.util.IllegalReferenceCountException -&amp;gt; java.lang.Throwable with value: {}
io.netty.util.IllegalReferenceCountException: refCnt: 0
	at io.netty.buffer.AbstractByteBuf.ensureAccessible(AbstractByteBuf.java:1187) ~[netty-buffer-4.0.23.Final.jar:4.0.23.Final]
	at io.netty.buffer.AbstractByteBuf.checkReadableBytes(AbstractByteBuf.java:1170) ~[netty-buffer-4.0.23.Final.jar:4.0.23.Final]
	at io.netty.buffer.AbstractByteBuf.readBytes(AbstractByteBuf.java:676) ~[netty-buffer-4.0.23.Final.jar:4.0.23.Final]
	at io.netty.buffer.CompositeByteBuf.readBytes(CompositeByteBuf.java:1461) ~[netty-buffer-4.0.23.Final.jar:4.0.23.Final]
	at io.netty.buffer.CompositeByteBuf.readBytes(CompositeByteBuf.java:40) ~[netty-buffer-4.0.23.Final.jar:4.0.23.Final]
	at org.apache.camel.component.netty4.http.NettyChannelBufferStreamCache.read(NettyChannelBufferStreamCache.java:69) ~[camel-netty4-http-2.14.0.jar:2.14.0]
	at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284) ~[na:1.8.0]
	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326) ~[na:1.8.0]
	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178) ~[na:1.8.0]
	at java.io.InputStreamReader.read(InputStreamReader.java:184) ~[na:1.8.0]
	at java.io.BufferedReader.fill(BufferedReader.java:161) ~[na:1.8.0]
	at java.io.BufferedReader.read1(BufferedReader.java:212) ~[na:1.8.0]
	at java.io.BufferedReader.read(BufferedReader.java:286) ~[na:1.8.0]
	at java.io.Reader.read(Reader.java:140) ~[na:1.8.0]
	at org.apache.camel.converter.IOConverter.toString(IOConverter.java:304) ~[camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.converter.IOConverter.toString(IOConverter.java:290) ~[camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.converter.IOConverter.toString(IOConverter.java:351) ~[camel-core-2.14.0.jar:2.14.0]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0]
	at java.lang.reflect.Method.invoke(Method.java:483) ~[na:1.8.0]
	at org.apache.camel.util.ObjectHelper.invokeMethod(ObjectHelper.java:1002) ~[camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.impl.converter.StaticMethodTypeConverter.convertTo(StaticMethodTypeConverter.java:59) ~[camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.impl.converter.BaseTypeConverterRegistry.doConvertTo(BaseTypeConverterRegistry.java:276) ~[camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.impl.converter.BaseTypeConverterRegistry.mandatoryConvertTo(BaseTypeConverterRegistry.java:165) ~[camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.impl.MessageSupport.getMandatoryBody(MessageSupport.java:99) ~[camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.builder.ExpressionBuilder$41.evaluate(ExpressionBuilder.java:1011) ~[camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.support.ExpressionAdapter.evaluate(ExpressionAdapter.java:36) ~[camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.component.bean.MethodInfo$2.evaluateParameterBinding(MethodInfo.java:595) ~[camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.component.bean.MethodInfo$2.evaluate(MethodInfo.java:485) ~[camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.component.bean.MethodInfo.createMethodInvocation(MethodInfo.java:240) ~[camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.component.bean.BeanInfo.createInvocation(BeanInfo.java:280) ~[camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.component.bean.BeanInfo.createInvocation(BeanInfo.java:180) ~[camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.component.bean.BeanProcessor.process(BeanProcessor.java:149) ~[camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:398) ~[camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:191) [camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:118) [camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.processor.Pipeline.access$100(Pipeline.java:43) [camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.processor.Pipeline$1.done(Pipeline.java:136) [camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.processor.CamelInternalProcessor$InternalCallback.done(CamelInternalProcessor.java:251) [camel-core-2.14.0.jar:2.14.0]
	at org.apache.camel.processor.RedeliveryErrorHandler$1.done(RedeliveryErrorHandler.java:410) [camel-core-2.14.0.jar:2.14.0]</description>
			<version>2.14.0</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.http.NettyChannelBufferStreamCache.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyChannelBufferStreamCacheOnCompletion.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpConfiguration.java</file>
			<file type="M">org.apache.camel.component.netty4.http.DefaultNettyHttpBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="9040" opendate="2015-07-31 12:16:58" fixdate="2016-05-04 12:10:12" resolution="Fixed">
		<buginformation>
			<summary>netty4-http - LEAK: ByteBuf.release() was not called before it&amp;apos;s garbage-collected</summary>
			<description>In a reverse-proxy with multiple routes that utilize the netty4-http component both as the consumer and producer I am receiving the following error:

2015-07-30 11:52:34,416 | ERROR | yServerTCPWorker | ResourceLeakDetector             | 97 - io.netty.common - 4.0.27.Final |   | LEAK: ByteBuf.release() was not called before it&amp;amp;apos;s garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.


Setting the Netty leak reporting to paranoid (-Dio.netty.leakDetectionLevel=paranoid) yields an error for almost every request (it probably is 1:1). 
The stacktraces come in two variants. Variant 1 is far less frequent than variant 2.
Variant 1:

Recent access records: 0
Created at:
io.netty.buffer.CompositeByteBuf.&amp;lt;init&amp;gt;(CompositeByteBuf.java:60)
io.netty.buffer.Unpooled.compositeBuffer(Unpooled.java:353)
io.netty.handler.codec.http.HttpObjectAggregator.decode(HttpObjectAggregator.java:153)
io.netty.handler.codec.http.HttpObjectAggregator.decode(HttpObjectAggregator.java:54)
io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:89)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:242)
io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:147)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
java.lang.Thread.run(Thread.java:745)


Variant 2:

Recent access records: 5
#5:
io.netty.buffer.AdvancedLeakAwareByteBuf.getBytes(AdvancedLeakAwareByteBuf.java:223)
io.netty.buffer.CompositeByteBuf.getBytes(CompositeByteBuf.java:684)
io.netty.buffer.CompositeByteBuf.getBytes(CompositeByteBuf.java:40)
io.netty.buffer.AbstractByteBuf.readBytes(AbstractByteBuf.java:677)
io.netty.buffer.CompositeByteBuf.readBytes(CompositeByteBuf.java:1493)
io.netty.buffer.CompositeByteBuf.readBytes(CompositeByteBuf.java:40)
io.netty.buffer.ByteBufInputStream.read(ByteBufInputStream.java:120)
java.io.BufferedInputStream.fill(BufferedInputStream.java:235)
java.io.BufferedInputStream.read1(BufferedInputStream.java:275)
java.io.BufferedInputStream.read(BufferedInputStream.java:334)
org.bouncycastle.util.io.TeeInputStream.read(Unknown Source)
com.ctc.wstx.io.BaseReader.readBytes(BaseReader.java:155)
com.ctc.wstx.io.UTF8Reader.loadMore(UTF8Reader.java:368)
com.ctc.wstx.io.UTF8Reader.read(UTF8Reader.java:111)
com.ctc.wstx.io.ReaderBootstrapper.initialLoad(ReaderBootstrapper.java:250)
com.ctc.wstx.io.ReaderBootstrapper.bootstrapInput(ReaderBootstrapper.java:133)
com.ctc.wstx.stax.WstxInputFactory.doCreateSR(WstxInputFactory.java:545)
com.ctc.wstx.stax.WstxInputFactory.createSR(WstxInputFactory.java:605)
com.ctc.wstx.stax.WstxInputFactory.createSR(WstxInputFactory.java:628)
com.ctc.wstx.stax.WstxInputFactory.createXMLStreamReader(WstxInputFactory.java:331)
ch.vivates.pep.stream.ResponseStatusFilter.filter(ResponseStatusFilter.java:41)
ch.vivates.pep.stream.BaseStreamFilter.run(BaseStreamFilter.java:141)
java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)
java.util.concurrent.FutureTask.run(FutureTask.java:262)
java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
java.lang.Thread.run(Thread.java:745)
#4:
io.netty.buffer.AdvancedLeakAwareByteBuf.release(AdvancedLeakAwareByteBuf.java:45)
io.netty.handler.codec.http.DefaultHttpContent.release(DefaultHttpContent.java:72)
io.netty.util.ReferenceCountUtil.release(ReferenceCountUtil.java:59)
io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:91)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:242)
io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:147)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
java.lang.Thread.run(Thread.java:745)
#3:
io.netty.buffer.AdvancedLeakAwareByteBuf.slice(AdvancedLeakAwareByteBuf.java:73)
io.netty.buffer.CompositeByteBuf.addComponent0(CompositeByteBuf.java:170)
io.netty.buffer.CompositeByteBuf.addComponent(CompositeByteBuf.java:112)
io.netty.handler.codec.http.HttpObjectAggregator.decode(HttpObjectAggregator.java:191)
io.netty.handler.codec.http.HttpObjectAggregator.decode(HttpObjectAggregator.java:54)
io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:89)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:242)
io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:147)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
java.lang.Thread.run(Thread.java:745)
#2:
io.netty.buffer.AdvancedLeakAwareByteBuf.order(AdvancedLeakAwareByteBuf.java:63)
io.netty.buffer.CompositeByteBuf.addComponent0(CompositeByteBuf.java:170)
io.netty.buffer.CompositeByteBuf.addComponent(CompositeByteBuf.java:112)
io.netty.handler.codec.http.HttpObjectAggregator.decode(HttpObjectAggregator.java:191)
io.netty.handler.codec.http.HttpObjectAggregator.decode(HttpObjectAggregator.java:54)
io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:89)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:242)
io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:147)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
java.lang.Thread.run(Thread.java:745)
#1:
io.netty.buffer.AdvancedLeakAwareByteBuf.retain(AdvancedLeakAwareByteBuf.java:709)
io.netty.handler.codec.http.DefaultHttpContent.retain(DefaultHttpContent.java:60)
io.netty.handler.codec.http.HttpObjectAggregator.decode(HttpObjectAggregator.java:190)
io.netty.handler.codec.http.HttpObjectAggregator.decode(HttpObjectAggregator.java:54)
io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:89)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:242)
io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:147)
io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:339)
io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:324)
io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:847)
io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:131)
io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
java.lang.Thread.run(Thread.java:745)
Created at:
io.netty.buffer.UnpooledByteBufAllocator.newDirectBuffer(UnpooledByteBufAllocator.java:55)
io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:155)
io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:146)
io.netty.buffer.AbstractByteBufAllocator.ioBuffer(AbstractByteBufAllocator.java:107)
io.netty.channel.AdaptiveRecvByteBufAllocator$HandleImpl.allocate(AdaptiveRecvByteBufAllocator.java:104)
io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:117)
io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
java.lang.Thread.run(Thread.java:745)


Variant 2 creates the buffer in UnpooledByteBufAllocator. Which might mean that there is no real resource leak in that case. Rather the coding pattern required for objects that might be pooled is not adhered to.
Nevertheless, running my load tests just long enough yields an OOME Direct buffer memory:

org.apache.camel.CamelExecutionException: Exception occurred during execution on the exchange: Exchange[Message: [Body is instance of org.apache.camel.StreamCache]]
        at org.apache.camel.util.ObjectHelper.wrapCamelExecutionException(ObjectHelper.java:1635)[70:org.apache.camel.camel-core:2.15.2]
        at org.apache.camel.impl.DefaultExchange.setException(DefaultExchange.java:308)[70:org.apache.camel.camel-core:2.15.2]
        at org.apache.camel.component.netty4.handlers.ClientChannelHandler.exceptionCaught(ClientChannelHandler.java:81)[143:org.apache.camel.camel-netty4:2.15.2]
        at io.netty.channel.AbstractChannelHandlerContext.invokeExceptionCaught(AbstractChannelHandlerContext.java:275)[138:io.netty.transport:4.0.27.Final]
        at io.netty.channel.AbstractChannelHandlerContext.fireExceptionCaught(AbstractChannelHandlerContext.java:253)[138:io.netty.transport:4.0.27.Final]
        at io.netty.channel.ChannelInboundHandlerAdapter.exceptionCaught(ChannelInboundHandlerAdapter.java:131)[138:io.netty.transport:4.0.27.Final]
        at io.netty.channel.AbstractChannelHandlerContext.invokeExceptionCaught(AbstractChannelHandlerContext.java:275)[138:io.netty.transport:4.0.27.Final]
        at io.netty.channel.AbstractChannelHandlerContext.fireExceptionCaught(AbstractChannelHandlerContext.java:253)[138:io.netty.transport:4.0.27.Final]
        at io.netty.channel.ChannelInboundHandlerAdapter.exceptionCaught(ChannelInboundHandlerAdapter.java:131)[138:io.netty.transport:4.0.27.Final]
        at io.netty.channel.CombinedChannelDuplexHandler.exceptionCaught(CombinedChannelDuplexHandler.java:137)[138:io.netty.transport:4.0.27.Final]
        at io.netty.channel.AbstractChannelHandlerContext.invokeExceptionCaught(AbstractChannelHandlerContext.java:275)[138:io.netty.transport:4.0.27.Final]
        at io.netty.channel.AbstractChannelHandlerContext.fireExceptionCaught(AbstractChannelHandlerContext.java:253)[138:io.netty.transport:4.0.27.Final]
        at io.netty.channel.DefaultChannelPipeline.fireExceptionCaught(DefaultChannelPipeline.java:835)[138:io.netty.transport:4.0.27.Final]
        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.handleReadException(AbstractNioByteChannel.java:87)[138:io.netty.transport:4.0.27.Final]
        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:162)[138:io.netty.transport:4.0.27.Final]
        at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)[138:io.netty.transport:4.0.27.Final]
        at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)[138:io.netty.transport:4.0.27.Final]
        at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)[138:io.netty.transport:4.0.27.Final]
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)[138:io.netty.transport:4.0.27.Final]
        at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)[137:io.netty.common:4.0.27.Final]
        at java.lang.Thread.run(Thread.java:745)[:1.7.0_60]
Caused by: java.lang.OutOfMemoryError: Direct buffer memory
        at java.nio.Bits.reserveMemory(Bits.java:658)[:1.7.0_60]
        at java.nio.DirectByteBuffer.&amp;lt;init&amp;gt;(DirectByteBuffer.java:123)[:1.7.0_60]
        at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:306)[:1.7.0_60]
        at io.netty.buffer.UnpooledUnsafeDirectByteBuf.allocateDirect(UnpooledUnsafeDirectByteBuf.java:108)[139:io.netty.buffer:4.0.27.Final]
        at io.netty.buffer.UnpooledUnsafeDirectByteBuf.&amp;lt;init&amp;gt;(UnpooledUnsafeDirectByteBuf.java:69)[139:io.netty.buffer:4.0.27.Final]
        at io.netty.buffer.UnpooledByteBufAllocator.newDirectBuffer(UnpooledByteBufAllocator.java:50)[139:io.netty.buffer:4.0.27.Final]
        at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:155)[139:io.netty.buffer:4.0.27.Final]
        at io.netty.buffer.AbstractByteBufAllocator.directBuffer(AbstractByteBufAllocator.java:146)[139:io.netty.buffer:4.0.27.Final]
        at io.netty.buffer.AbstractByteBufAllocator.ioBuffer(AbstractByteBufAllocator.java:107)[139:io.netty.buffer:4.0.27.Final]
        at io.netty.channel.AdaptiveRecvByteBufAllocator$HandleImpl.allocate(AdaptiveRecvByteBufAllocator.java:104)[138:io.netty.transport:4.0.27.Final]
        at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:117)[138:io.netty.transport:4.0.27.Final]
        ... 6 more


This is one of the routes that trigger the error:


&amp;lt;route id="pep-xds_b-registry"&amp;gt;
	&amp;lt;from uri="netty4-http:http://{{pep.host}}:{{pep.xds.b.registry.port}}/XDS3/registry?matchOnUriPrefix=true&amp;amp;amp;disableStreamCache=true" /&amp;gt;
	&amp;lt;process ref="registryInboundProcessor" /&amp;gt;
	&amp;lt;to uri="netty4-http:http://{{xds.b.registry.host}}:{{xds.b.registry.port}}/XDS3/registry?bridgeEndpoint=true&amp;amp;amp;throwExceptionOnFailure=false&amp;amp;amp;chunkedMaxContentLength={{pep.xds.b.registry.max.message.size}}&amp;amp;amp;disableStreamCache=false" /&amp;gt;
	&amp;lt;!-- Unfortunately disabling the stream cache only works for requests, but not responses: https://issues.apache.org/jira/browse/CAMEL-7638 --&amp;gt;
	&amp;lt;process ref="registryOutboundProcessor" /&amp;gt;
&amp;lt;/route&amp;gt;

</description>
			<version>2.15.1</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.http.DefaultNettyHttpBinding.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpConfiguration.java</file>
			<file type="M">org.apache.camel.component.netty4.handlers.ClientChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpHandle404Test.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttp500ErrorThrowExceptionOnServerTest.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttp500ErrorTest.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpReturnFaultTest.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpProducer.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpOkStatusCodeTest.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpOperationFailedException.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpAccessHttpRequestAndResponseBeanTest.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpAccessHttpRequestBeanTest.java</file>
			<file type="M">org.apache.camel.component.netty4.http.HttpServerSharedInitializerFactory.java</file>
			<file type="M">org.apache.camel.component.netty4.http.handlers.HttpServerChannelHandler.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyChannelBufferStreamCacheOnCompletion.java</file>
			<file type="M">org.apache.camel.component.netty4.http.HttpServerInitializerFactory.java</file>
			<file type="M">org.apache.camel.component.netty4.http.HttpClientInitializerFactory.java</file>
			<file type="M">org.apache.camel.component.netty4.NettyUdpConnectedSendTest.java</file>
			<file type="M">org.apache.camel.component.netty4.NettyUdpConnectionlessSendTest.java</file>
			<file type="M">org.apache.camel.component.netty4.MyCustomCodec.java</file>
			<file type="M">org.apache.camel.component.netty4.NettyConverter.java</file>
			<file type="M">org.apache.camel.component.netty4.NettyConverterTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">8899</link>
			<link type="Reference" description="relates to">9940</link>
		</links>
	</bug>
	<bug id="9921" opendate="2016-04-28 06:32:11" fixdate="2016-05-05 10:18:52" resolution="Fixed">
		<buginformation>
			<summary>Dozer variable mapping doesn&amp;apos;t work on karaf</summary>
			<description>The configuration variables defined in transformation.xml is not resolved to the value on karaf. Attached reproducer CAMEL-9921.tgz shows this behavior using Pax Exam, camel-2.18-SNAPSHOT and karaf-4.0.5.
Steps to reproduce

Unpack CAMEL-9921.tgz
Run &amp;amp;apos;mvn clean package&amp;amp;apos;
PaxExamTest fails with following error, which shows the variable mapping doesn&amp;amp;apos;t work in karaf while it succeeds in CamelBlueprintTest


test(org.apache.camel.component.dozer.PaxExamTest)  Time elapsed: 15.878 sec  &amp;lt;&amp;lt;&amp;lt; FAILURE!
org.junit.ComparisonFailure: expected:&amp;lt;[ACME-SALES]&amp;gt; but was:&amp;lt;[${CUST_ID}]&amp;gt;
    at org.apache.camel.component.dozer.PaxExamTest.test(PaxExamTest.java:89)



</description>
			<version>2.15.6</version>
			<fixedVersion>2.16.4, 2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.dozer.DozerEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="9950" opendate="2016-05-06 10:55:12" fixdate="2016-05-06 11:16:33" resolution="Fixed">
		<buginformation>
			<summary>Camel-Websocket: NPE in case minThreads, maxThreads and getThreadPool equals to null</summary>
			<description>We need to manage this situation.</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.websocket.WebsocketComponent.java</file>
			<file type="D">org.apache.camel.component.websocket.WebscoketEndpointConfigurationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9953" opendate="2016-05-07 08:34:41" fixdate="2016-05-07 09:09:25" resolution="Fixed">
		<buginformation>
			<summary>Camel-ssh: Review logic in doStart and doStop in the SshConsumer and SshProducer</summary>
			<description>We need to create the client before calling super start and in the doStop method we need to stop the scheduler before stopping and nulling the client.</description>
			<version>2.18.0</version>
			<fixedVersion>2.16.4, 2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.ssh.SshConsumer.java</file>
			<file type="M">org.apache.camel.component.ssh.SshProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="9951" opendate="2016-05-06 12:20:49" fixdate="2016-05-09 11:43:08" resolution="Fixed">
		<buginformation>
			<summary>Setup default values for thread-connected properties in WebSocket component</summary>
			<description>If you do not set properties minThreads or maxThreads or method getThreadPool() returns null the you will get RuntimeCamelException and websocket cosumer will not be created. These attributes were not required in previous versions of camel. Websocket component now uses Jetty 9. If these properties are really required why do not use some default values?
e.g.


minThreads = 1
maxThreads = Runtime.getRuntime().availableProcessors()


https://github.com/apache/camel/blob/master/components/camel-websocket/src/main/java/org/apache/camel/component/websocket/WebsocketComponent.java#L341</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.websocket.WebsocketComponent.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketEndpointConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketConsumerRouteTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9968" opendate="2016-05-13 22:49:24" fixdate="2016-05-20 05:07:47" resolution="Fixed">
		<buginformation>
			<summary>camel restlet not populating body form parameters correctly for x-www-form-urlencoded</summary>
			<description>Currently for x-www-form-urlencoded post request camel puts the body into a form key with a null value:


if ((Method.PUT == method || Method.POST == method) &amp;amp;&amp;amp; MediaType.APPLICATION_WWW_FORM.equals(mediaType, true)) {
            form = new Form();
            // must use string based for forms
            String body = exchange.getIn().getBody(String.class);
            if (body != null) {
                form.add(body, null);
            }
        }


Which results in a body like this:
name=jay&amp;amp;password=secret
ending up with a form parameter looking like this: 
name%3Djay%26password%3Dsecret=null
I think something like this should be used to correctly set the key values.


if ((Method.PUT == method || Method.POST == method) &amp;amp;&amp;amp; MediaType.APPLICATION_WWW_FORM.equals(mediaType, true)) {
            form = new Form();
            // must use string based for forms
            String body = exchange.getIn().getBody(String.class);
            if (body != null) {
                List&amp;lt;NameValuePair&amp;gt; pairs = URLEncodedUtils.parse(body, Charset.forName("UTF-8"));
                for(NameValuePair p : pairs){
                	form.add(p.getName(), p.getValue());
                }
            }
        }

</description>
			<version>2.17.1</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.restlet.DefaultRestletBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="9970" opendate="2016-05-16 13:30:13" fixdate="2016-05-20 07:08:21" resolution="Fixed">
		<buginformation>
			<summary>CamelFileLength header is wrong for long write file</summary>
			<description>Given a long write file slowfile.dat. Camel polls the file and stores its parameters (length, lastModified...). Camel tries to get exclusive read lock and fails as file is writing by someone, next time Camel gets lock. But file was changed and its parameters are wrong.
The solution is pretty simple - check the file length and lastModified when exclusive read lock is granted and update them.
Here is a patch: http://pastebin.com/2vyF8BTU</description>
			<version>2.16.3</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.FileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.GenericFileConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.FtpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.remote.RemoteFileIgnoreDoPollErrorTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.SftpConsumer.java</file>
			<file type="M">org.apache.camel.component.file.strategy.FileChangedReadLockTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9973" opendate="2016-05-17 14:48:58" fixdate="2016-05-20 16:51:11" resolution="Fixed">
		<buginformation>
			<summary>CdiCamelExtension.shouldDeployDefaultCamelContext throws NPE with primitive injection points</summary>
			<description>The NPE prevents Camel to start :


java.lang.NullPointerException
	at org.apache.camel.cdi.CdiCamelExtension.shouldDeployDefaultCamelContext(CdiCamelExtension.java:310)
	at org.apache.camel.cdi.CdiCamelExtension.afterBeanDiscovery(CdiCamelExtension.java:234)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.jboss.weld.injection.StaticMethodInjectionPoint.invoke(StaticMethodInjectionPoint.java:88)
	at org.jboss.weld.injection.MethodInvocationStrategy$SpecialParamPlusBeanManagerStrategy.invoke(MethodInvocationStrategy.java:144)
	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:309)
	at org.jboss.weld.event.ExtensionObserverMethodImpl.sendEvent(ExtensionObserverMethodImpl.java:124)
	at org.jboss.weld.event.ObserverMethodImpl.sendEvent(ObserverMethodImpl.java:287)
	at org.jboss.weld.event.ObserverMethodImpl.notify(ObserverMethodImpl.java:265)
	at org.jboss.weld.event.ObserverNotifier.notifySyncObservers(ObserverNotifier.java:271)
	at org.jboss.weld.event.ObserverNotifier.notify(ObserverNotifier.java:260)
	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:154)
	at org.jboss.weld.event.ObserverNotifier.fireEvent(ObserverNotifier.java:148)
	at org.jboss.weld.bootstrap.events.AbstractContainerEvent.fire(AbstractContainerEvent.java:53)
	at org.jboss.weld.bootstrap.events.AbstractDefinitionContainerEvent.fire(AbstractDefinitionContainerEvent.java:42)
	at org.jboss.weld.bootstrap.events.AfterBeanDiscoveryImpl.fire(AfterBeanDiscoveryImpl.java:61)
	at org.jboss.weld.bootstrap.WeldStartup.deployBeans(WeldStartup.java:423)
	at org.jboss.weld.bootstrap.WeldBootstrap.deployBeans(WeldBootstrap.java:83)


The issue seems to be related to CAMEL-9904.
It works well when I get back to version 2.17.0.</description>
			<version>2.17.1</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.cdi.CdiCamelExtension.java</file>
		</fixedFiles>
	</bug>
	<bug id="9982" opendate="2016-05-22 18:42:54" fixdate="2016-05-23 06:10:31" resolution="Fixed">
		<buginformation>
			<summary>Marshalling fixed length record with links fails</summary>
			<description>When a fixed length record contains a "Link" marshalling doesn&amp;amp;apos;t take this field into account while with unmarshalling it is unmarshalled.
Issue comes from a difference in building the model in BindyCsvDataFormat and BindyFixedLengthDataFormat. In the csv-format all field are taken into account that have the "Link"  annotation.</description>
			<version>2.17.1</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.bindy.fixed.BindyFixedLengthDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.fixed.link.BindySimpleFixedLengthWithLinkTest.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindyCsvDataFormat.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyAbstractDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="9981" opendate="2016-05-21 21:17:35" fixdate="2016-05-23 06:55:01" resolution="Fixed">
		<buginformation>
			<summary>CamelSpringJUnit4ClassRunner registers listeners twice</summary>
			<description>Using camel-test-spring I found that CamelSpringJUnit4ClassRunner registers the listener twice. This causes the following error in transactional tests:

java.lang.IllegalStateException: Cannot start a new transaction without ending the existing transaction.


To fix it, it is required to only add the expected listeners :


line:57
         public CamelTestContextManager(Class&amp;lt;?&amp;gt; testClass) {
            super(testClass);

            // inject Camel first, and then disable jmx and add the stop-watch
            // WARNING: The listeners are registered within the super class.
            /// DON&amp;amp;apos;T get current listeners.
            // List&amp;lt;TestExecutionListener&amp;gt; list = getTestExecutionListeners();
            //
            List&amp;lt;TestExecutionListener&amp;gt; list = new ArrayList&amp;lt;TestExecutionListener&amp;gt;(3);

            list.add(new CamelSpringTestContextLoaderTestExecutionListener());
            list.add(new DisableJmxTestExecutionListener());
            list.add(new StopWatchTestExecutionListener());
            OrderComparator.sort(list);
            registerTestExecutionListeners(list);
        }



Spring version: 4.2.5.</description>
			<version>2.14.0</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.test.spring.CamelSpringBootRunner.java</file>
			<file type="M">org.apache.camel.test.spring.CamelSpringRunner.java</file>
		</fixedFiles>
	</bug>
	<bug id="9926" opendate="2016-04-29 03:03:25" fixdate="2016-05-23 18:25:44" resolution="Fixed">
		<buginformation>
			<summary>HTTP Proxy support in Salesforce component is broken with upgrade to Jetty9</summary>
			<description>HTTP Proxy support in Jetty9 Client is broken, which causes HTTP Proxy tests in the Salesforce components to fail. 
They have been marked as ignored for now, but it MUST be fixed in Jetty9 ASAP and the component updated to use the new version of Jetty9 client with working support for Proxy authentication. </description>
			<version>2.17.1</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.salesforce.HttpProxyIntegrationTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">9925</link>
		</links>
	</bug>
	<bug id="9986" opendate="2016-05-24 07:07:47" fixdate="2016-05-24 07:47:36" resolution="Fixed">
		<buginformation>
			<summary>MIME-Multipart Data Format is inconsistent if trying to unmarshal non-MIME data</summary>
			<description>If data that is not a MIME-Multipart is tried to marshal with the headersInline option set to false, no error is thrown and the message is left as the original message.
In case the headersInline option is set to true, an empty message is returned.
The provided patch changes the behavior that it also tries to return the original message in case the message is not a mime-multipart and headersInline is set to true. However there are limits to this: If the message body is a stream and stream caching is not enabled it is necessary to read the stream in order to find out whether this is a MIME-Multipart or not. Afterwards the message body will be empty (as with the previous implementation). </description>
			<version>2.17.1</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.mime.multipart.MimeMultipartDataFormatTest.java</file>
			<file type="M">org.apache.camel.dataformat.mime.multipart.MimeMultipartDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="9984" opendate="2016-05-23 12:53:40" fixdate="2016-05-24 09:53:48" resolution="Fixed">
		<buginformation>
			<summary>RabbitConsumer.stop() doesn&amp;apos;t stop underlying AutorecoveringConnection obtained from supplied ConnectionFactory</summary>
			<description>If I have a ConnectionFactory defined as:


ConnectionFactory connectionFactory = new ConnectionFactory();
connectionFactory.setAutomaticRecoveryEnabled(true);
connectionFactory.setUsername(username);
connectionFactory.setPassword(password);


And a Camel route defined like:


rabbitmq://localhost:5672/MyExchange?connectionFactory=#connectionFactory&amp;amp;exchangeType=direct&amp;amp;queue=MyQueue&amp;amp;routingKey=MyRoutingKey


Performing these steps:

Start my application and it connects to Rabbit and consumes messages
Shutdown the RabbbitMQ server
Shutdown my Camel application

The application doesn&amp;amp;apos;t stop fully because the automatic recovery mechanism has background threads running. It carries on indefinately logging messages like:


	at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:106)
	at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:102)
	at com.rabbitmq.client.impl.AMQConnection.start(AMQConnection.java:350)
	at com.rabbitmq.client.impl.recovery.RecoveryAwareAMQConnectionFactory.newConnection(RecoveryAwareAMQConnectionFactory.java:37)
	at com.rabbitmq.client.impl.recovery.AutorecoveringConnection.recoverConnection(AutorecoveringConnection.java:476)
	at com.rabbitmq.client.impl.recovery.AutorecoveringConnection.beginAutomaticRecovery(AutorecoveringConnection.java:444)
	at com.rabbitmq.client.impl.recovery.AutorecoveringConnection.access$000(AutorecoveringConnection.java:53)
	at com.rabbitmq.client.impl.recovery.AutorecoveringConnection$1.shutdownCompleted(AutorecoveringConnection.java:383)
	at com.rabbitmq.client.impl.ShutdownNotifierComponent.notifyListeners(ShutdownNotifierComponent.java:75)
	at com.rabbitmq.client.impl.AMQConnection$MainLoop.run(AMQConnection.java:578)


Looking at org.apache.camel.component.rabbitmq.RabbitConsumer.stop()


    public void stop() throws IOException, TimeoutException {
        stopping = true;
        if (channel == null) {
            return;
        }
        channel.basicCancel(tag);
        try {
            channel.close();
        } catch (TimeoutException e) {
            log.error("Timeout occured");
            throw e;
        }
    }


The calls to channel.basicCancel(tag) and channel.close() both throw com.rabbitmq.client.AlreadyClosedException when the server has closed the connection which stops the automatic recovery thread from being halted. Checking whether the channel is open before the calls to channel.basicCancel(tag) and channel.close() seems to fix the issue.


    public void stop() throws IOException, TimeoutException {
        stopping = true;
        if (channel == null) {
            return;
        }
        if (tag != null &amp;amp;&amp;amp; isChannelOpen()) {
            channel.basicCancel(tag);
        }
        try {
            if (isChannelOpen()) {
                channel.close();
            }
        } catch (TimeoutException e) {
            log.error("Timeout occured");
            throw e;
        }
    }


I&amp;amp;apos;ll submit a PR later</description>
			<version>2.17.1</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitConsumer.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQConsumerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="9941" opendate="2016-05-03 18:50:30" fixdate="2016-06-01 07:41:51" resolution="Fixed">
		<buginformation>
			<summary>Blueprint bug ARIES-1544 causes issues in Olingo2 configuration</summary>
			<description>Due to Blueprint bug ARIES-1544, the setConfiguration() method overridden in Olingo2Component for Camel documentation, MUST have a matching getConfiguration() method. </description>
			<version>2.17.0</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.google.drive.GoogleDriveComponent.java</file>
			<file type="M">org.apache.camel.component.box.BoxComponent.java</file>
			<file type="M">org.apache.camel.component.google.mail.GoogleMailComponent.java</file>
			<file type="M">org.apache.camel.component.linkedin.LinkedInComponent.java</file>
			<file type="M">org.apache.camel.component.olingo2.Olingo2Component.java</file>
		</fixedFiles>
	</bug>
	<bug id="10011" opendate="2016-06-02 14:45:35" fixdate="2016-06-02 15:02:56" resolution="Fixed">
		<buginformation>
			<summary>Overlap in management name for multiple contexts in OSGi bundle</summary>
			<description>Problem is that OsgiManagementNameStrategy uses only the bundle symbolic name for the management name used for each CamelContext. So if you have multiple CamelContexts per bundle this creates overlap in the naming. </description>
			<version>2.17.1</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.core.osgi.OsgiManagementNameStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="10012" opendate="2016-06-03 07:30:31" fixdate="2016-06-03 07:52:28" resolution="Fixed">
		<buginformation>
			<summary>Add a Path Home option in camel-elasticsearch configuration</summary>
			<description>Otherwise we get errors.
https://github.com/elastic/elasticsearch/blob/v2.2.0/core/src/main/java/org/elasticsearch/env/Environment.java#L101
https://github.com/elastic/elasticsearch/blob/v2.3.3/core/src/main/java/org/elasticsearch/env/Environment.java#L101</description>
			<version>2.17.1</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.elasticsearch.ElasticsearchGetSearchDeleteExistsUpdateTest.java</file>
			<file type="M">org.apache.camel.component.elasticsearch.ElasticsearchEndpoint.java</file>
			<file type="M">org.apache.camel.component.elasticsearch.ElasticsearchConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="10009" opendate="2016-06-02 09:06:25" fixdate="2016-06-03 08:47:31" resolution="Fixed">
		<buginformation>
			<summary>Using &lt;to&gt; with id and ref fails</summary>
			<description>If you use spring and then refer to an endpoint


        &amp;lt;endpoint id="csv2json" uri="dozer:csv2json?sourceModel=org.acme.Customer&amp;amp;amp;targetModel=org.globex.Account&amp;amp;amp;marshalId=json&amp;amp;amp;unmarshalId=csv&amp;amp;amp;mappingFile=transformation.xml"/&amp;gt;


And then in a route has


                &amp;lt;to id="_to2" ref="csv2json"/&amp;gt;


Then you get this spring error


Caused by: org.springframework.beans.NotWritablePropertyException: Invalid property &amp;amp;apos;ref&amp;amp;apos; of bean class [org.apache.camel.spring.CamelEndpointFactoryBean]: Bean property &amp;amp;apos;ref&amp;amp;apos; is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?

</description>
			<version>2.17.1</version>
			<fixedVersion>2.16.4, 2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.CamelEndpointFactoryBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="10017" opendate="2016-06-03 11:28:36" fixdate="2016-06-03 13:14:54" resolution="Fixed">
		<buginformation>
			<summary>Fix syntax for ironmq component</summary>
			<description>replace ironmq:queue by ironmq:queueName</description>
			<version>2.17.0</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.ironmq.IronMQEndpoint.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">10013</link>
		</links>
	</bug>
	<bug id="10015" opendate="2016-06-03 11:26:27" fixdate="2016-06-03 13:15:18" resolution="Fixed">
		<buginformation>
			<summary>Fix syntax for braintree component</summary>
			<description>replace braintree:name by braintree:apiName/methodName</description>
			<version>2.17.0</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.braintree.BraintreeEndpoint.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">10013</link>
		</links>
	</bug>
	<bug id="10014" opendate="2016-06-03 11:25:33" fixdate="2016-06-03 13:15:40" resolution="Fixed">
		<buginformation>
			<summary>Fix syntax for kubernetes component</summary>
			<description>replace kubernetes:master by kubernetes:masterUrl</description>
			<version>2.17.0</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.kubernetes.KubernetesEndpoint.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">10013</link>
		</links>
	</bug>
	<bug id="10016" opendate="2016-06-03 11:27:35" fixdate="2016-06-08 13:06:10" resolution="Fixed">
		<buginformation>
			<summary>Fix syntax for crypto component</summary>
			<description>replace crypto:cryptoOperation:name by crypto:cryptoOperation</description>
			<version>2.17.0</version>
			<fixedVersion>2.16.4, 2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.crypto.DigitalSignatureConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">10013</link>
		</links>
	</bug>
	<bug id="10034" opendate="2016-06-09 08:50:13" fixdate="2016-06-09 09:10:32" resolution="Fixed">
		<buginformation>
			<summary>Spring-boot health check causes application startup failure</summary>
			<description>After the introducion of the health check in CAMEL-10026, I get the attached exception on a sample application that depends on spring-boot-starter and camel-spring-boot-starter.
The problem seems to be related to the following dependency on the camel-spring-boot module:

&amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-boot-actuator&amp;lt;/artifactId&amp;gt;
      &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
      &amp;lt;version&amp;gt;${spring-boot-version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;


The dependency is declared as optional, but the HealthCheck component inherits from org.springframework.boot.actuate.health.AbstractHealthIndicator.
A project importing the camel-spring-boot module does not import transitively the actuator module, so I get the exception.
If the application does not start, the dependency cannot be optional.
Excaption:

java.lang.IllegalStateException: Could not evaluate condition on org.apache.camel.spring.boot.health.CamelHealthAutoConfiguration#camelHealthIndicator due to org/springframework/boot/actuate/health/AbstractHealthIndicator not found. Make sure your own configuration does not rely on that class. This can also happen if you are @ComponentScanning a springframework package (e.g. if you put a @ComponentScan in the default package by mistake)
	at org.springframework.boot.autoconfigure.condition.SpringBootCondition.matches(SpringBootCondition.java:55) ~[spring-boot-autoconfigure-1.3.5.RELEASE.jar!/:1.3.5.RELEASE]
	at org.springframework.context.annotation.ConditionEvaluator.shouldSkip(ConditionEvaluator.java:102) ~[spring-context-4.2.6.RELEASE.jar!/:4.2.6.RELEASE]
	at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForBeanMethod(ConfigurationClassBeanDefinitionReader.java:178) ~[spring-context-4.2.6.RELEASE.jar!/:4.2.6.RELEASE]
	at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitionsForConfigurationClass(ConfigurationClassBeanDefinitionReader.java:140) ~[spring-context-4.2.6.RELEASE.jar!/:4.2.6.RELEASE]
	at org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader.loadBeanDefinitions(ConfigurationClassBeanDefinitionReader.java:116) ~[spring-context-4.2.6.RELEASE.jar!/:4.2.6.RELEASE]
	at org.springframework.context.annotation.ConfigurationClassPostProcessor.processConfigBeanDefinitions(ConfigurationClassPostProcessor.java:333) ~[spring-context-4.2.6.RELEASE.jar!/:4.2.6.RELEASE]
	at org.springframework.context.annotation.ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(ConfigurationClassPostProcessor.java:243) ~[spring-context-4.2.6.RELEASE.jar!/:4.2.6.RELEASE]
	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessors(PostProcessorRegistrationDelegate.java:273) ~[spring-context-4.2.6.RELEASE.jar!/:4.2.6.RELEASE]
	at org.springframework.context.support.PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(PostProcessorRegistrationDelegate.java:98) ~[spring-context-4.2.6.RELEASE.jar!/:4.2.6.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:678) ~[spring-context-4.2.6.RELEASE.jar!/:4.2.6.RELEASE]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:520) ~[spring-context-4.2.6.RELEASE.jar!/:4.2.6.RELEASE]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:766) [spring-boot-1.3.5.RELEASE.jar!/:1.3.5.RELEASE]
	at org.springframework.boot.SpringApplication.createAndRefreshContext(SpringApplication.java:361) [spring-boot-1.3.5.RELEASE.jar!/:1.3.5.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:307) [spring-boot-1.3.5.RELEASE.jar!/:1.3.5.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1191) [spring-boot-1.3.5.RELEASE.jar!/:1.3.5.RELEASE]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1180) [spring-boot-1.3.5.RELEASE.jar!/:1.3.5.RELEASE]
	at org.apache.camel.itest.springboot.ITestBoot.main(ITestBoot.java:29) [test.jar!/:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_91]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_91]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_91]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_91]
	at org.springframework.boot.loader.MainMethodRunner.run(MainMethodRunner.java:54) [test.jar!/:na]
	at java.lang.Thread.run(Thread.java:745) [na:1.8.0_91]
Caused by: java.lang.NoClassDefFoundError: org/springframework/boot/actuate/health/AbstractHealthIndicator
	at java.lang.ClassLoader.defineClass1(Native Method) ~[na:1.8.0_91]
	at java.lang.ClassLoader.defineClass(ClassLoader.java:763) ~[na:1.8.0_91]
	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) ~[na:1.8.0_91]
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:467) ~[na:1.8.0_91]
	at java.net.URLClassLoader.access$100(URLClassLoader.java:73) ~[na:1.8.0_91]
	at java.net.URLClassLoader$1.run(URLClassLoader.java:368) ~[na:1.8.0_91]
	at java.net.URLClassLoader$1.run(URLClassLoader.java:362) ~[na:1.8.0_91]
	at java.security.AccessController.doPrivileged(Native Method) ~[na:1.8.0_91]
	at java.net.URLClassLoader.findClass(URLClassLoader.java:361) ~[na:1.8.0_91]
	at org.springframework.boot.loader.LaunchedURLClassLoader.doLoadClass(LaunchedURLClassLoader.java:170) ~[test.jar!/:na]
	at org.springframework.boot.loader.LaunchedURLClassLoader.loadClass(LaunchedURLClassLoader.java:142) ~[test.jar!/:na]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_91]
	at org.springframework.core.type.classreading.AnnotationReadingVisitorUtils.convertClassValues(AnnotationReadingVisitorUtils.java:73) ~[spring-core-4.2.6.RELEASE.jar!/:4.2.6.RELEASE]
	at org.springframework.core.type.classreading.MethodMetadataReadingVisitor.getAnnotationAttributes(MethodMetadataReadingVisitor.java:125) ~[spring-core-4.2.6.RELEASE.jar!/:4.2.6.RELEASE]
	at org.springframework.core.type.classreading.MethodMetadataReadingVisitor.getAnnotationAttributes(MethodMetadataReadingVisitor.java:118) ~[spring-core-4.2.6.RELEASE.jar!/:4.2.6.RELEASE]
	at org.springframework.core.type.classreading.MethodMetadataReadingVisitor.getAnnotationAttributes(MethodMetadataReadingVisitor.java:45) ~[spring-core-4.2.6.RELEASE.jar!/:4.2.6.RELEASE]
	at org.springframework.boot.autoconfigure.condition.OnBeanCondition$BeanSearchSpec.&amp;lt;init&amp;gt;(OnBeanCondition.java:274) ~[spring-boot-autoconfigure-1.3.5.RELEASE.jar!/:1.3.5.RELEASE]
	at org.springframework.boot.autoconfigure.condition.OnBeanCondition.getMatchOutcome(OnBeanCondition.java:111) ~[spring-boot-autoconfigure-1.3.5.RELEASE.jar!/:1.3.5.RELEASE]
	at org.springframework.boot.autoconfigure.condition.SpringBootCondition.matches(SpringBootCondition.java:47) ~[spring-boot-autoconfigure-1.3.5.RELEASE.jar!/:1.3.5.RELEASE]
	... 22 common frames omitted
Caused by: java.lang.ClassNotFoundException: org.springframework.boot.actuate.health.AbstractHealthIndicator
	at java.net.URLClassLoader.findClass(URLClassLoader.java:381) ~[na:1.8.0_91]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_91]
	at org.springframework.boot.loader.LaunchedURLClassLoader.doLoadClass(LaunchedURLClassLoader.java:178) ~[test.jar!/:na]
	at org.springframework.boot.loader.LaunchedURLClassLoader.loadClass(LaunchedURLClassLoader.java:142) ~[test.jar!/:na]
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_91]
	... 41 common frames omitted

</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.boot.health.CamelHealthIndicator.java</file>
			<file type="M">org.apache.camel.spring.boot.health.CamelHealthAutoConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="10032" opendate="2016-06-09 06:46:45" fixdate="2016-06-09 13:26:10" resolution="Fixed">
		<buginformation>
			<summary>camel-braintree - Cannot install in Karaf</summary>
			<description>karaf@root()&amp;gt; feature:install camel-braintree
Error executing command: Unable to resolve root: missing requirement [root] osgi.identity; osgi.identity=camel-braintree; type=karaf.feature; version="[2.18.0.SNAPSHOT,2.18.0.SNAPSHOT]"; filter:="(&amp;amp;(osgi.identity=camel-braintree)(type=karaf.feature)(version&amp;gt;=2.18.0.SNAPSHOT)(version&amp;lt;=2.18.0.SNAPSHOT))" [caused by: Unable to resolve camel-braintree/2.18.0.SNAPSHOT: missing requirement [camel-braintree/2.18.0.SNAPSHOT] osgi.identity; osgi.identity=org.apache.camel.camel-braintree; type=osgi.bundle; version="[2.18.0.SNAPSHOT,2.18.0.SNAPSHOT]"; resolution:=mandatory [caused by: Unable to resolve org.apache.camel.camel-braintree/2.18.0.SNAPSHOT: missing requirement [org.apache.camel.camel-braintree/2.18.0.SNAPSHOT] osgi.wiring.package; filter:="(&amp;amp;(osgi.wiring.package=org.slf4j.bridge)(version&amp;gt;=1.6.0)(!(version&amp;gt;=2.0.0)))" [caused by: Unable to resolve jul.to.slf4j/1.7.21: missing requirement [jul.to.slf4j/1.7.21] osgi.wiring.package; filter:="(&amp;amp;(osgi.wiring.package=org.slf4j)(version&amp;gt;=1.7.21))"]]]</description>
			<version>2.18.0</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.braintree.AbstractBraintreeTestSupport.java</file>
			<file type="M">org.apache.camel.component.braintree.MerchantAccountGatewayIntegrationTest.java</file>
			<file type="M">org.apache.camel.component.braintree.BraintreeConfiguration.java</file>
			<file type="M">org.apache.camel.component.braintree.PaymentMethodGatewayIntegrationTest.java</file>
			<file type="M">org.apache.camel.component.braintree.ClientTokenGatewayIntegrationTest.java</file>
			<file type="M">org.apache.camel.component.braintree.CustomerGatewayIntegrationTest.java</file>
			<file type="M">org.apache.camel.component.braintree.WebhookNotificationGatewayIntegrationTest.java</file>
			<file type="M">org.apache.camel.component.braintree.TransactionGatewayIntegrationTest.java</file>
			<file type="M">org.apache.camel.component.braintree.AddressGatewayIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="10039" opendate="2016-06-10 06:10:34" fixdate="2016-06-10 06:25:38" resolution="Fixed">
		<buginformation>
			<summary>LinkedIn broke login in LinnkedIn component by adding a redundant reference to the callback url</summary>
			<description></description>
			<version>2.17.1</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.box.internal.LoginAuthFlowUI.java</file>
			<file type="M">org.apache.camel.component.linkedin.api.LinkedInOAuthRequestFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="10048" opendate="2016-06-11 21:41:44" fixdate="2016-06-12 09:44:54" resolution="Fixed">
		<buginformation>
			<summary>Memory leak in RoutingSlip</summary>
			<description>RoutingSlip has a cache of error handlers implemented as a ConcurrentHashMap. This map stores error handlers as values, and uses some synthetic objects as keys. For some kind of destinations provided in routing slip, map lookup operation does not work. Hence, new error handlers are always added to the map and existing error handlers never reused. Finally, the program runs out of memory.
The synthetic keys are actually instances of class RoutingSlip.PreparedErrorHandler. Such key is based on two objects: RouteContext and destination Processor. Neither RouteContext nor Processor do not require their implementations to provide equals() and hashCode() methods. Strictly speaking, caching implementation in RoutingSlip is incorrect, because it uses hash map in the discouraged way. However, for some cases it works.
The problem occurs when routing slip contains a &amp;amp;apos;sync&amp;amp;apos; destination, in other words - destination is a Processor that does not implement AsyncProcessor interface. RoutingSlip determines destination producer via ProducerCache.doInAsyncProducer(), and the latter uses AsyncProcessorConverterHelper.convert() method. This method creates new instance of Processor for every processor that is not an instance of AsyncProcessor. This is where the problem hides: new object has different hash code (defined by Object.hashCode()) and new object isn&amp;amp;apos;t equal to the object used as a key in the hash map (well, Object.equals()). Finally, new key for the hash map is calculated, lookup operation cannot find this key in the hash map, new key-value pair is put into the hash map.</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.4, 2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.RoutingSlip.java</file>
			<file type="M">org.apache.camel.util.AsyncProcessorConverterHelper.java</file>
		</fixedFiles>
		<links>
			<link type="Incorporates" description="incorporates">10050</link>
		</links>
	</bug>
	<bug id="10051" opendate="2016-06-12 12:46:24" fixdate="2016-06-12 14:32:39" resolution="Fixed">
		<buginformation>
			<summary>netty4 reuseChannel not working as expected</summary>
			<description>NettyProducer returns the channel to the pool every time a message is sent when the reuseChannel is set to true. It should instead return the channel to the pool only if the exchange is completed, so that other exchanges will not use the same channel.
I have the following problem:
I need to send messages to a legacy tcp server through a REST server.
The tcp server requires messages from one connection to be send in a specific order, for example in order to send COMMAND1 I have to first send PRE1 and PRE2 and then COMMAND1. The component is set to reuseChannel=true and be sync=true and i have the following exchange:


from("direct:command1")
    .setBody(constant("PRE1"))
    .to(nettyEndpoint)
    .setBody(constant("PRE2"))
    .to(nettyEndpoint)
    .setBody(constant("COMMAND1"))
    .to(nettyEndpoint);


The problem is that the NettyProducer returns the channel to the pool every time i send a message. So if concurrent requests are sent to the REST server things get messy. 
NettyProducer supports this behavior, if the reuseChannel is set to true the producer adds an onCompletion listener on the exchange that returns the channel to the pool. The problem is that it also sets the callback of the NettyCamelState to a NettyProducerCallback which runs every time a message is send by the ClientChannelHandler and returns the channel to the pool.</description>
			<version>2.17.1</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.NettyProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="10063" opendate="2016-06-16 12:48:14" fixdate="2016-06-21 08:56:29" resolution="Fixed">
		<buginformation>
			<summary>Camel on Karaf 4.0.5: java.lang.NoClassDefFoundError: org/apache/karaf/util/StringEscapeUtils</summary>
			<description>Stock Karaf, unpacked, started via bin/karaf, repo-add camel + Features camel-quartz2 and camel-blueprint (2.18.0.SNAPSHOT).
Deployed a blueprint with a Camel route. Shell shows the following error on issuing this command:
karaf@root()&amp;gt; camel:route-info route1
Error executing command: org/apache/karaf/util/StringEscapeUtils
Log:
java.lang.NoClassDefFoundError: org/apache/karaf/util/StringEscapeUtils
	at org.apache.camel.karaf.commands.internal.StringEscape.unescapeJava(StringEscape.java:25)
	at org.apache.camel.commands.RouteInfoCommand.executeOnRoute(RouteInfoCommand.java:52)
	at org.apache.camel.commands.AbstractRouteCommand.execute(AbstractRouteCommand.java:56)
	at org.apache.camel.karaf.commands.RouteInfo.doExecute(RouteInfo.java:35)
	at org.apache.karaf.shell.console.AbstractAction.execute(AbstractAction.java:34)[44:org.apache.karaf.shell.core:4.0.5]
	at org.apache.karaf.shell.console.OsgiCommandSupport.execute(OsgiCommandSupport.java:41)[44:org.apache.karaf.shell.core:4.0.5]
	at org.apache.karaf.shell.commands.basic.AbstractCommand.execute(AbstractCommand.java:34)[44:org.apache.karaf.shell.core:4.0.5]
	at org.apache.karaf.shell.compat.CommandTracker$1.execute(CommandTracker.java:112)[44:org.apache.karaf.shell.core:4.0.5]
	at org.apache.karaf.shell.impl.console.osgi.secured.SecuredCommand.execute(SecuredCommand.java:67)[44:org.apache.karaf.shell.core:4.0.5]
	at org.apache.karaf.shell.impl.console.osgi.secured.SecuredCommand.execute(SecuredCommand.java:87)[44:org.apache.karaf.shell.core:4.0.5]
	at org.apache.felix.gogo.runtime.Closure.executeCmd(Closure.java:480)[44:org.apache.karaf.shell.core:4.0.5]
	at org.apache.felix.gogo.runtime.Closure.executeStatement(Closure.java:406)[44:org.apache.karaf.shell.core:4.0.5]
	at org.apache.felix.gogo.runtime.Pipe.run(Pipe.java:108)[44:org.apache.karaf.shell.core:4.0.5]
	at org.apache.felix.gogo.runtime.Closure.execute(Closure.java:182)[44:org.apache.karaf.shell.core:4.0.5]
	at org.apache.felix.gogo.runtime.Closure.execute(Closure.java:119)[44:org.apache.karaf.shell.core:4.0.5]
	at org.apache.felix.gogo.runtime.CommandSessionImpl.execute(CommandSessionImpl.java:94)[44:org.apache.karaf.shell.core:4.0.5]
	at org.apache.karaf.shell.impl.console.ConsoleSessionImpl.run(ConsoleSessionImpl.java:270)[44:org.apache.karaf.shell.core:4.0.5]
	at java.lang.Thread.run(Thread.java:745)[:1.8.0_72]
</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.karaf.commands.internal.StringEscape.java</file>
		</fixedFiles>
		<links>
			<link type="Incorporates" description="incorporates">4582</link>
		</links>
	</bug>
	<bug id="10082" opendate="2016-06-21 18:42:45" fixdate="2016-06-21 23:09:48" resolution="Fixed">
		<buginformation>
			<summary>camel-api-component-maven-plugin doesn&amp;apos;t handle inner class names in Javadoc</summary>
			<description>ApiMethodParser.forName() doesn&amp;amp;apos;t handle inner class names of the format package.OutClass.InnerClass from camel-api-component-maven-plugin&amp;amp;apos;s Javadoc parser. It needs to convert class names in this human readable format to package.OutClass$InnerClass form as expected by Class.forName().</description>
			<version>2.17.1</version>
			<fixedVersion>2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.component.ApiMethodParser.java</file>
			<file type="M">org.apache.camel.util.component.ArgumentSubstitutionParserTest.java</file>
			<file type="M">org.apache.camel.util.component.TestProxy.java</file>
			<file type="M">org.apache.camel.util.component.ApiMethodHelperTest.java</file>
			<file type="M">org.apache.camel.component.test.TestProxy.java</file>
		</fixedFiles>
	</bug>
	<bug id="10024" opendate="2016-06-07 07:39:24" fixdate="2016-06-23 20:47:37" resolution="Fixed">
		<buginformation>
			<summary>Race condition in Mina2Producer/Mina2Consumer when closing connections with disconnect=true</summary>
			<description>There is a race condition in the Mina2Producer when trying to close connections after use by setting disconnect=true or
setting CamelMina2CloseSessionWhenComplete=true. 
Connections will not be fully closed in the method maybeDisconnectOnDone. 
The call to session.close(true) returns a CloseFuture - one must await this to ensure the session is really closed.
In the current implementation, there is no await on the CloseFuture. This means that the producer will be returned to the pool before the session is closed. If the next call comes right after, it is very likely that it will get the same producer and that the session will suddenly be closed while in use, leading to errors like 
ExchangeTimedOutException: The OUT message was not received within 30000 ms
or 
java.lang.IllegalStateException: handler cannot be set while the service is active.
The fix is trivial - just change line 221 in Mina2Producer.java from


session.close(true);


to 


long timeout = getEndpoint().getConfiguration().getTimeout();          
CloseFuture closeFuture = session.close(true);  
closeFuture.awaitUninterruptibly(timeout, TimeUnit.MILLISECONDS);


But the unit testing might be more complex.
There might be a similar issue in Mina2Consumer - but I could not provoke it as easily.
Here is a small program demonstrating the problem - on my system it will fail within the first 50 iterations. When looking at the debug log, it is clear that the connections are closed too late - after the next iteration has started.



import org.apache.camel.*;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.impl.DefaultCamelContext;
import org.slf4j.*;

/**
 * Demonstrating race condition
 */
public class Main {
    public static void main(String[] args) throws Exception {

        System.setProperty("org.slf4j.simpleLogger.log.org.apache.camel.component.mina2.Mina2Producer", "trace");
        System.setProperty("org.slf4j.simpleLogger.log.org.apache.mina.filter.logging.LoggingFilter", "trace");
        
        Logger logger = LoggerFactory.getLogger(Main.class);
        CamelContext context = new DefaultCamelContext();
        context.addRoutes(new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                from("mina2:tcp://localhost:20000?sync=true").setBody(simple("Hello ${in.body}"));
            }
        });

        ProducerTemplate producerTemplate = context.createProducerTemplate();
        context.start();
        try {
            for (int i = 0; i &amp;lt; 10000; i++) {
                logger.info("---- Call # " + i);
                String result = (String) producerTemplate.requestBody("mina2:tcp://localhost:20000?disconnect=true&amp;amp;timeout=1000&amp;amp;sync=true&amp;amp;minaLogger=true", "world " + i);
                logger.info("---- End call # " + i + ": " + result);
            }
        } finally {
            context.stop();
        }
    }
}


</description>
			<version>2.17.1</version>
			<fixedVersion>2.17.2, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mina2.Mina2Producer.java</file>
			<file type="M">org.apache.camel.component.mina2.Mina2TextLineDelimiter.java</file>
			<file type="M">org.apache.camel.component.mina2.Mina2NoResponseFromServerTest.java</file>
			<file type="M">org.apache.camel.component.mina2.Mina2Consumer.java</file>
			<file type="M">org.apache.camel.component.mina2.Mina2ProducerShutdownMockTest.java</file>
			<file type="M">org.apache.camel.component.mina2.Mina2ExchangeTimeOutTest.java</file>
			<file type="M">org.apache.camel.component.mina2.Mina2ClientModeTcpTextlineDelimiterTest.java</file>
			<file type="M">org.apache.camel.component.mina2.Mina2EncodingTest.java</file>
			<file type="M">org.apache.camel.component.mina2.Mina2TransferExchangeOptionTest.java</file>
			<file type="M">org.apache.camel.component.mina2.Mina2ReverseProtocolHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="10091" opendate="2016-06-27 06:54:08" fixdate="2016-06-27 07:35:46" resolution="Fixed">
		<buginformation>
			<summary>Camel-Git: Always check if Git instance is null in GitProducer before closing</summary>
			<description>We need to double check JGit Git class instance each time we want to close it.</description>
			<version>2.17.1</version>
			<fixedVersion>2.16.4, 2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.git.producer.GitProducer.java</file>
			<file type="M">org.apache.camel.component.git.producer.GitProducerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="10103" opendate="2016-06-29 15:10:50" fixdate="2016-06-30 04:26:55" resolution="Fixed">
		<buginformation>
			<summary>Camel FTP - Unknown parser type </summary>
			<description>Some servers are not recognized by camel-ftp
 org.apache.commons.net.ftp.parser.ParserInitializationException: Unknown parser type: WIN32 A N (WFTPD by Texas Imperial Software)
 org.apache.commons.net.ftp.parser.ParserInitializationException: Unknown parser type: Linux Version: Cleo VLTrader/5.2.0.19 FTP server
LINUX and WIN32  are missing in OsgiParserFactory.createFileEntryParser(...)
For these servers 
UnixFTPEntryParser btw. NTFTPEntryParser will work.
</description>
			<version>2.16.2</version>
			<fixedVersion>2.16.4, 2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.OsgiParserFactoryTest.java</file>
			<file type="M">org.apache.camel.component.file.remote.OsgiParserFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="10104" opendate="2016-06-30 06:11:46" fixdate="2016-06-30 06:30:48" resolution="Fixed">
		<buginformation>
			<summary>Mail consumer does not work with quartz scheduler</summary>
			<description>Using the mail consumer with the quartz scheduler like
imap://myhost?scheduler=quartz2&amp;amp;scheduler.cron=0%2F5+0-23%3F+&amp;amp;scheduler.timeZone=Europe%2FBerlin
leads to an error:
"There are 2 scheduler parameters that couldn&amp;amp;apos;t be set on the endpoint. Check the uri if the parameters are spelt correctly and that they are properties of the endpoint."</description>
			<version>2.16.3</version>
			<fixedVersion>2.16.4, 2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailComponent.java</file>
			<file type="M">org.apache.camel.component.mail.MailComponentTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="10087" opendate="2016-06-23 13:44:00" fixdate="2016-07-01 06:59:10" resolution="Fixed">
		<buginformation>
			<summary>camel-kafka does not work in OSGI container</summary>
			<description>Currently this component is broken in OSGI environment due to this:
https://issues.apache.org/jira/browse/KAFKA-3218
We can leave it broken until they get their bugs worked out.  Or i can submit a PR with an intermediate fix that should work, as described in the jira noted above.
https://github.com/apache/camel/pull/1053</description>
			<version>2.17.1</version>
			<fixedVersion>2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.kafka.KafkaEndpoint.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaProducer.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaConsumer.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">10069</link>
		</links>
	</bug>
	<bug id="10111" opendate="2016-07-01 08:53:04" fixdate="2016-07-01 10:05:54" resolution="Fixed">
		<buginformation>
			<summary>Creating an InputStream from XMLStreamReader fails with ASCII default platform encoding</summary>
			<description>If a type conversion is performed between XMLStreamReader and the platform default encoding is not UTF-8 and the used Stax parser is the one from the JDK the conversion will fail.
The error message will look like that:
Caused by: javax.xml.stream.XMLStreamException: Underlying stream encoding &amp;amp;apos;ASCII&amp;amp;apos; and input paramter for writeStartDocument() method &amp;amp;apos;utf-8&amp;amp;apos; do not match.
The underlying issue was introduced with CAMEL-10070 and CAMEL-10080.
Unfortunately this cannot be unit tested, as in the unit tests the default platform encoding is UTF-8 and the used Stax parser is woodstox. Both conditions prevent the issue from occuring.</description>
			<version>2.17.2</version>
			<fixedVersion>2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.jaxp.XMLStreamReaderInputStream.java</file>
			<file type="M">org.apache.camel.component.cxf.converter.CxfPayloadConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="10110" opendate="2016-06-30 20:04:34" fixdate="2016-07-01 23:31:09" resolution="Fixed">
		<buginformation>
			<summary>Marshaling using CSV will insert escape char in header if using a pipe as separator</summary>
			<description>This was an old bug that was supposedly resolved, but with version:2.15.2, the bug remains. The escape characters are still added into the Header Columns when marshaling back the object. 
e.g. 
Separator = \ \ |
Output: 
Header 1 \ | Header2 \ |...
Pls. advise when we can expect the fix.
Thanks.
Reply</description>
			<version>2.15.2</version>
			<fixedVersion>2.16.4, 2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.bindy.csv.BindyPipeDelimiterTest.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.BindyCsvFactory.java</file>
			<file type="M">org.apache.camel.dataformat.bindy.model.simple.pipeline.MyData.java</file>
		</fixedFiles>
	</bug>
	<bug id="10115" opendate="2016-07-01 15:50:26" fixdate="2016-07-04 12:34:41" resolution="Fixed">
		<buginformation>
			<summary>Kafka consumer stays running if no messages were received after shutdown start</summary>
			<description>After triggering CamelContext#close() method the execution will reach org.apache.camel.component.kafka.KafkaConsumer#doStop where the shutdown of the executor instance will be triggered and where in it&amp;amp;apos;s turn the interruption of the submitted to the executor threads should happen (by reaching the native implementation of Thread#interrupt())
According to https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#interrupt-- interrupt method will only set a corresponding status to the thread, but will not terminate it. 
Problem is in the line KafkaConsumer.java:108:
ConsumerRecords&amp;lt;Object, Object&amp;gt; records = consumer.poll(Long.MAX_VALUE);
In the Kafka implementation of the poll method this will lead to almost infinite while loop which is not checking the thread status and this loop will exit only in case of receiving a message from a broker. Only after exciting the loop the interrupted status of the thread will be discovered and the thread will be terminated.
This leads to a couple of problems:
1. The KafkaConsumers remain alive until receiving at least one more message from the broker.
2. As the CamelContext at this point of time is most likely already shut down, the received message is not going to be processed, but will be acknowledged to the broker. So effectively the message gets lost.
A potential fix would be to either make the poll timeout reasonably small or configurable.</description>
			<version>2.17.1</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.kafka.KafkaConfiguration.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaConsumerTest.java</file>
			<file type="M">org.apache.camel.component.kafka.KafkaConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="10120" opendate="2016-07-04 13:09:36" fixdate="2016-07-04 13:34:25" resolution="Fixed">
		<buginformation>
			<summary>Creating an InputStream from XMLStreamReader fails without default namespace</summary>
			<description>The XMLStreamReaderInputStream created by the StaxConverter will fail if the document does not define a default namespace, a tag contains an attribute without namespace prefix and the XMLStreamWriter from the JDK is used.
The error message is:
javax.xml.stream.XMLStreamException: NamespaceURI cannot be null
	at com.sun.xml.internal.stream.writers.XMLStreamWriterImpl.writeAttribute(XMLStreamWriterImpl.java:615)
	at org.apache.camel.converter.jaxp.XMLStreamReaderInputStream.ensureBuffering(XMLStreamReaderInputStream.java:106)
The fix is relatively simple: a check needs to be introduced that replaces null namespaceUris with empty namespace Uris.
The issue was introduced with CAMEL-10070.
The issue will not happen with unit tests because those use the woodstox Stax parser.</description>
			<version>2.17.2</version>
			<fixedVersion>2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.converter.jaxp.XMLStreamReaderInputStream.java</file>
		</fixedFiles>
	</bug>
	<bug id="10128" opendate="2016-07-06 10:39:44" fixdate="2016-07-06 10:41:16" resolution="Fixed">
		<buginformation>
			<summary>camel-jt400 - Need to call configure consumer</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Problem-with-JT400-DataQueue-tp5784876.html
When creating the consumer we must remember to call configureConsumer like all other component does.</description>
			<version>2.17.2</version>
			<fixedVersion>2.16.4, 2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jt400.Jt400Endpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="10129" opendate="2016-07-06 13:54:08" fixdate="2016-07-06 13:58:27" resolution="Duplicate">
		<buginformation>
			<summary>do not cache OSGi service by registry</summary>
			<description>OsgiServiceRegistry uses cache (serviceCacheMap) for services. If declarative services are provided by several bundles then keeping reference to those objects conflicts OSGi frameworks that support changing them at runtime.
serviceCacheMap should be removed or a new configuration option (enable/disable) should be added to easily disable caching.</description>
			<version>2.17.1</version>
			<fixedVersion></fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.core.osgi.OsgiServiceRegistry.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">9631</link>
		</links>
	</bug>
	<bug id="9631" opendate="2016-02-22 02:21:34" fixdate="2016-07-07 07:30:09" resolution="Fixed">
		<buginformation>
			<summary>The OsgiServiceRegistry class caches service references</summary>
			<description>As discussed in http://camel.465427.n5.nabble.com/OsgiServiceRegistry-caching-service-references-why-td5777410.html the OsgiServiceRegistry class caches service references hence limits the ability to dynamically install and use a new version of the same service</description>
			<version>2.15.4</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.core.osgi.OsgiServiceRegistry.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">10129</link>
		</links>
	</bug>
	<bug id="10116" opendate="2016-07-02 12:55:54" fixdate="2016-07-07 21:53:26" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException in DefaultAsyncProcessorAwaitManager</summary>
			<description>The following statement can cause a NPE (line #256 in DefaultAsyncProcessorAwaitManager at version 2.17.1):
MessageHistory history = list.get(list.size() - 1);


java.lang.NullPointerException: null
        at org.apache.camel.impl.DefaultAsyncProcessorAwaitManager$AwaitThreadEntry.&amp;lt;init&amp;gt;(DefaultAsyncProcessorAwaitManager.java:257) ~[camel-core-2.17.1.jar!/:2.17.1]
        at org.apache.camel.impl.DefaultAsyncProcessorAwaitManager$AwaitThreadEntry.&amp;lt;init&amp;gt;(DefaultAsyncProcessorAwaitManager.java:238) ~[camel-core-2.17.1.jar!/:2.17.1]
        at org.apache.camel.impl.DefaultAsyncProcessorAwaitManager.await(DefaultAsyncProcessorAwaitManager.java:73) ~[camel-core-2.17.1.jar!/:2.17.1]
        at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:122) ~[camel-core-2.17.1.jar!/:2.17.1]
        at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:87) ~[camel-core-2.17.1.jar!/:2.17.1]
        at org.apache.camel.component.stream.StreamConsumer.processLine(StreamConsumer.java:218) ~[camel-stream-2.17.1.jar!/:2.17.1]
        at org.apache.camel.component.stream.StreamConsumer.readFromStream(StreamConsumer.java:146) ~[camel-stream-2.17.1.jar!/:2.17.1]
        at org.apache.camel.component.stream.StreamConsumer.run(StreamConsumer.java:99) ~[camel-stream-2.17.1.jar!/:2.17.1]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_91]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_91]
        at java.lang.Thread.run(Thread.java:745) [na:1.8.0_91]

</description>
			<version>2.17.1</version>
			<fixedVersion>2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultExchange.java</file>
			<file type="M">org.apache.camel.impl.DefaultAsyncProcessorAwaitManager.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
			<file type="M">org.apache.camel.processor.CamelInternalProcessor.java</file>
			<file type="M">org.apache.camel.impl.DefaultInflightRepository.java</file>
			<file type="M">org.apache.camel.processor.async.AsyncProcessorAwaitManagerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="10144" opendate="2016-07-14 02:06:04" fixdate="2016-07-14 06:41:23" resolution="Fixed">
		<buginformation>
			<summary>Salesforce keeps breaking backward compatibility by adding fields to older API versions</summary>
			<description>Salesforce adds fields to org.apache.camel.component.salesforce.api.dto.RestResources even after an API has been released. This needs to be handled in the component by ignoring unknown properties for that type. 
XStream doesn&amp;amp;apos;t support doing this for an single DTO, but it can be done for all types by using XStream.ignoreUknownProperties(). It will make it ignore all unknown properties for all inbuilt DTOs as wells user generated ones. But since the XML payload is less popular, hopefully this behavior won&amp;amp;apos;t be an issue. </description>
			<version>2.17.2</version>
			<fixedVersion>2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.salesforce.internal.processor.XmlRestProcessor.java</file>
			<file type="M">org.apache.camel.component.salesforce.api.dto.AbstractDTOBase.java</file>
			<file type="M">org.apache.camel.maven.CamelSalesforceMojo.java</file>
			<file type="M">org.apache.camel.component.salesforce.internal.client.DefaultRestClient.java</file>
		</fixedFiles>
	</bug>
	<bug id="10143" opendate="2016-07-13 21:41:39" fixdate="2016-07-14 06:42:32" resolution="Fixed">
		<buginformation>
			<summary>Camel Salesforce component field LastActivityDate is typed with java.lang.String, which is not consistent with the Salesforce SOAP type "xsd:date"</summary>
			<description>This field was not a valid date time field in older versions of the Salesforce APIs, hence it was left as String. 
It should now be converted into DateTime to work with latest Salesforce API and be mappable to dates in Hibernate for e.g.</description>
			<version>2.17.1</version>
			<fixedVersion>2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.salesforce.api.dto.AbstractSObjectBase.java</file>
		</fixedFiles>
	</bug>
	<bug id="10145" opendate="2016-07-14 07:59:09" fixdate="2016-07-14 08:53:50" resolution="Fixed">
		<buginformation>
			<summary>Camel-Git: Pull and Push operations require the remote Name and not the remote Path to git repository</summary>
			<description>Using the remote Path to git Repository is causing errors during Pull and Push operations.
I&amp;amp;apos;ll add a new option remoteName in GitEndpoint to avoid this situation.</description>
			<version>2.17.2</version>
			<fixedVersion>2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.git.GitEndpoint.java</file>
			<file type="M">org.apache.camel.component.git.producer.GitProducer.java</file>
			<file type="M">org.apache.camel.component.git.producer.GitProducerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="10147" opendate="2016-07-14 12:09:55" fixdate="2016-07-15 06:57:02" resolution="Fixed">
		<buginformation>
			<summary>MesssageHistory will take very long time for large expressions</summary>
			<description>If a route contains a large expressen (a few MB) and an error occurs the message history feature will take a very long time.
The following code is a slightly modified unit test from camel-core (the only change is the String used in the constant expression).


import org.apache.camel.CamelExecutionException;
import org.apache.camel.ContextTestSupport;
import org.apache.camel.builder.RouteBuilder;

/**
 * @version 
 */
public class SedaInOutWithErrorTest extends ContextTestSupport {

    public void testInOutWithError() throws Exception {
        getMockEndpoint("mock:result").expectedMessageCount(0);

        try {
            template.requestBody("direct:start", "Hello World", String.class);
            fail("Should have thrown an exception");
        } catch (CamelExecutionException e) {
            assertIsInstanceOf(IllegalArgumentException.class, e.getCause());
            assertEquals("Damn I cannot do this", e.getCause().getMessage());
        }

        assertMockEndpointsSatisfied();
    }

    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                StringBuilder sb = new StringBuilder();
                sb.append("Something ");
                for (int i=0; i&amp;lt;1000000; i++) {
                    sb.append("very ");
                }
                sb.append("long");
                
                from("direct:start").to("seda:foo");

                from("seda:foo").transform(constant(sb.toString()))
                    .throwException(new IllegalArgumentException("Damn I cannot do this"))
                    .to("mock:result");
            }
        };
    }
}


This test will set the body to a 5MB test and then run into an error. This will run for a very long time, because MessageHelper.doDumpMessageHistoryStacktrace() will first run a URISupport.sanitizeUri() on the expression and then cut it off to 78 characters.
If we cut the expression of (e.g. to 100 characters) before doing the sanitizeUri() this will run much faster in this case (and not slower for smaller expressions).</description>
			<version>2.17.1</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.MessageHelper.java</file>
			<file type="M">org.apache.camel.util.StringHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="10142" opendate="2016-07-13 15:07:11" fixdate="2016-07-15 13:21:47" resolution="Fixed">
		<buginformation>
			<summary>ScheduledPollingConsumer properties</summary>
			<description>It appears that support for a named scheduled polling consumer is there, but you have to have at least one scheduler.xxx property set before it utilises it. e.g. 
I have this configured: 
&amp;lt;bean id="nps-scheduler" class="org.apache.camel.pollconsumer.quartz2.QuartzScheduledPollConsumerScheduler"&amp;gt;
    &amp;lt;property name="cron" value="0 * * * * ?"/&amp;gt;
&amp;lt;/bean&amp;gt;
In my route, I reference it like this, but it doesn&amp;amp;apos;t use it: 
&amp;lt;from uri="ftp://ftp.somewhere.com/path?scheduler=nps-scheduler" /&amp;gt;
If I add a scheduler property, it then uses it, e.g. 
&amp;lt;from uri="ftp://ftp.somewhere.com/path?scheduler=nps-scheduler&amp;amp;scheduler.triggerId=?" /&amp;gt;
Discussion with Claus Ibsen here: http://camel.465427.n5.nabble.com/ScheduledPollingConsumer-properties-td5785071.html
</description>
			<version>2.17.1</version>
			<fixedVersion>2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.DefaultComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="10151" opendate="2016-07-16 07:33:18" fixdate="2016-07-16 07:36:59" resolution="Fixed">
		<buginformation>
			<summary>camel-sql - Query parameter count mismatch when using IN and other names in SQL</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/camel-sql-IN-query-number-of-parameters-mismatch-tp5785054.html</description>
			<version>2.17.2</version>
			<fixedVersion>2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sql.DefaultSqlPrepareStatementStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="10150" opendate="2016-07-15 13:17:05" fixdate="2016-07-18 11:07:01" resolution="Fixed">
		<buginformation>
			<summary>Camel-Apt: Check for empty lines in parseAsMap method of EndpointAnnotationProcessor</summary>
			<description></description>
			<version>2.17.2</version>
			<fixedVersion>2.16.4, 2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.tools.apt.EndpointAnnotationProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="10157" opendate="2016-07-19 11:04:12" fixdate="2016-07-20 12:02:56" resolution="Fixed">
		<buginformation>
			<summary>Values in KafkaConstants don&amp;apos;t fit their variable name</summary>
			<description>Value of KafkaConstants.KEY = "kafka.CONTENT_TYPE" and KafkaConstants.PARTITION = "kafka.EXCHANGE_NAME" should match their variable name.


    public static final String PARTITION = "kafka.PARTITION";
    public static final String KEY = "kafka.KEY";

</description>
			<version>2.16.3</version>
			<fixedVersion>2.16.4, 2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.kafka.KafkaConstants.java</file>
		</fixedFiles>
	</bug>
	<bug id="10038" opendate="2016-06-09 16:13:03" fixdate="2016-07-21 07:17:03" resolution="Fixed">
		<buginformation>
			<summary>BlueprintPropertiesParser breaks propertyPlaceholder fallbackToUnaugmentedProperty behavior</summary>
			<description>When BlueprintPropertiesParser parses an "augmented" property key that is not found (i.e. value is null), it does not return the null value so that the fallbackToUnaugmentedProperty="true" (default) behavior can run. Instead, it immediately throws an IllegalArgumentException.
As a result, it appears to be impossible to take advantage of fallbackToUnaugmentedProperty="true" behavior when using the Blueprint properties resolver/parser.
I discovered this against Red Hat&amp;amp;apos;s JBoss Fuse impl of Camel, but am reporting it here because it appears to be a bug in base Camel. More details in comments.</description>
			<version>2.15.1</version>
			<fixedVersion>2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.test.blueprint.ConfigAdminNoDefaultValuesBlueprintCreationTest.java</file>
			<file type="M">org.apache.camel.blueprint.BlueprintPropertiesParser.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">7630</link>
		</links>
	</bug>
	<bug id="10161" opendate="2016-07-20 06:18:32" fixdate="2016-07-21 12:12:41" resolution="Fixed">
		<buginformation>
			<summary>camel-sql - Does not propagate headers for outputType=StreamList</summary>
			<description>All headers are cleared when returning from 
to("sql:&amp;lt;query&amp;gt;?outputType=StreamList")</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sql.SqlProducer.java</file>
			<file type="M">org.apache.camel.component.sql.SqlProducerOutputTypeStreamListTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="10174" opendate="2016-07-22 12:58:35" fixdate="2016-07-25 11:58:38" resolution="Fixed">
		<buginformation>
			<summary>weaveByToString throws UnsupportedOperationException on CBR</summary>
			<description>weaveByToString throws UnsupportedOperationException on CBR.
See the attached test case.</description>
			<version>2.17.2</version>
			<fixedVersion>2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.builder.AdviceWithTasks.java</file>
			<file type="M">org.apache.camel.model.ChoiceDefinition.java</file>
		</fixedFiles>
	</bug>
	<bug id="10192" opendate="2016-07-27 19:21:42" fixdate="2016-07-28 07:18:38" resolution="Fixed">
		<buginformation>
			<summary>Specifying jobFromHeader in URI option throws exception</summary>
			<description>Setting the jobFromHeader option in the URI throws exception.
Caused by: org.apache.camel.ResolveEndpointFailedException: Failed to resolve endpoint: spring-batch://myJob?jobFromHeader= due to: Failed to resolve endpoint: spring-batch://myJob?jobFromHeader= due to: There are 1 parameters that couldn&amp;amp;apos;t be set on the endpoint. Check the uri if the parameters are spelt correctly and that they are properties of the endpoint. Unknown parameters=[
{jobFromHeader=}
]
	at org.apache.camel.impl.DefaultCamelContext.getEndpoint(DefaultCamelContext.java:588) ~[camel-core-2.17.1.jar:2.17.1]
	at org.apache.camel.util.CamelContextHelper.getMandatoryEndpoint(CamelContextHelper.java:79) ~[camel-core-2.17.1.jar:2.17.1]
	at org.apache.camel.model.RouteDefinition.resolveEndpoint(RouteDefinition.java:211) ~[camel-core-2.17.1.jar:2.17.1]
	at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:107) ~[camel-core-2.17.1.jar:2.17.1]
	at org.apache.camel.impl.DefaultRouteContext.resolveEndpoint(DefaultRouteContext.java:113) ~[camel-core-2.17.1.jar:2.17.1]
	at org.apache.camel.model.SendDefinition.resolveEndpoint(SendDefinition.java:62) ~[camel-core-2.17.1.jar:2.17.1]
	at org.apache.camel.model.SendDefinition.createProcessor(SendDefinition.java:56) ~[camel-core-2.17.1.jar:2.17.1]
	at org.apache.camel.model.ProcessorDefinition.makeProcessorImpl(ProcessorDefinition.java:534) ~[camel-core-2.17.1.jar:2.17.1]
	at org.apache.camel.model.ProcessorDefinition.makeProcessor(ProcessorDefinition.java:495) ~[camel-core-2.17.1.jar:2.17.1]
	at org.apache.camel.model.ProcessorDefinition.addRoutes(ProcessorDefinition.java:219) ~[camel-core-2.17.1.jar:2.17.1]
	at org.apache.camel.model.RouteDefinition.addRoutes(RouteDefinition.java:1069) ~[camel-core-2.17.1.jar:2.17.1]
	... 31 common frames omitted</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.spring.batch.SpringBatchEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="10200" opendate="2016-07-29 05:20:32" fixdate="2016-07-29 05:40:51" resolution="Fixed">
		<buginformation>
			<summary>Mail consumer sets wrong Content-Type header for mails with attachment</summary>
			<description>If a mail with attachment is received the mail consumer components (imap and pop3) set the message body to a Multipart Message and take over all headers from the mail message.
All known consumers of the message body (including the mail (SMTP) producer) will convert the body into somthing else (using one of the provided type converters) and will receive the first text part of the messsage, which is the mail body. This is the behaviour one would expect.
Unfortunately the Content-Type header taken over from the Multipart mail will contain a multipart content type (including the MIME boundary) of the whole mail, not the content type of the entity usually used as mail body,
As a consequence the following route will always fail:


from("pop3://james3@localhost?consumer.delay=1000").removeHeader("to").to("smtp://james4@localhost");


The error message is.

2016-07-28 20:01:24,892 [ames2@localhost] ERROR DefaultErrorHandler            - Failed delivery for (MessageId: ID-WDFD30052822A-54830-1469728883014-0-1 on ExchangeId: ID-WDFD30052822A-54830-1469728883014-0-2). Exhausted after delivery attempt: 1 caught: javax.mail.MessagingException: Missing start boundary

Message History
---------------------------------------------------------------------------------------------------------------------------------------
RouteId              ProcessorId          Processor                                                                        Elapsed (ms)
[route1            ] [route1            ] [pop3://james2@localhost?consumer.delay=1000                                   ] [        18]
[route1            ] [to1               ] [smtp://james3@localhost                                                       ] [        13]

Stacktrace
---------------------------------------------------------------------------------------------------------------------------------------
javax.mail.MessagingException: Missing start boundary
	at javax.mail.internet.MimeMultipart.parse(MimeMultipart.java:682)
	at javax.mail.internet.MimeMultipart.updateHeaders(MimeMultipart.java:513)
	at javax.mail.internet.MimeBodyPart.updateHeaders(MimeBodyPart.java:1483)
	at javax.mail.internet.MimeBodyPart.updateHeaders(MimeBodyPart.java:1131)
	at javax.mail.internet.MimeMultipart.updateHeaders(MimeMultipart.java:515)
	at javax.mail.internet.MimeBodyPart.updateHeaders(MimeBodyPart.java:1483)
	at javax.mail.internet.MimeMessage.updateHeaders(MimeMessage.java:2198)
	at javax.mail.internet.MimeMessage.saveChanges(MimeMessage.java:2159)
	at org.apache.camel.component.mail.DefaultJavaMailSender.send(DefaultJavaMailSender.java:118)
	at org.apache.camel.component.mail.MailProducer.process(MailProducer.java:63)
	at org.apache.camel.util.AsyncProcessorConverterHelper$ProcessorToAsyncProcessorBridge.process(AsyncProcessorConverterHelper.java:61)
	at org.apache.camel.processor.SendProcessor$2.doInAsyncProducer(SendProcessor.java:173)
	at org.apache.camel.impl.ProducerCache.doInAsyncProducer(ProducerCache.java:362)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:168)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:525)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:197)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:197)
	at org.apache.camel.util.AsyncProcessorHelper.process(AsyncProcessorHelper.java:109)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:91)
	at org.apache.camel.component.mail.MailConsumer.processExchange(MailConsumer.java:382)
	at org.apache.camel.component.mail.MailConsumer.processBatch(MailConsumer.java:221)
	at org.apache.camel.component.mail.MailConsumer.poll(MailConsumer.java:128)
	at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:175)
	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:102)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)


The provided patch will set the Content-Type header of the message to the content type of the first text part of the multipart (the one which is also returned by the type converters)</description>
			<version>2.16.3</version>
			<fixedVersion>2.16.4, 2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailMessage.java</file>
			<file type="M">org.apache.camel.component.mail.MimeMessageConsumeTest.java</file>
			<file type="M">org.apache.camel.component.mail.MailBinding.java</file>
		</fixedFiles>
	</bug>
	<bug id="10184" opendate="2016-07-26 09:12:01" fixdate="2016-07-29 07:36:17" resolution="Fixed">
		<buginformation>
			<summary>ChannelGroup option is not active for NettyProducer</summary>
			<description>The NettyProducer does not check if a valid ChannelGroup is declared in the NettyConfiguration and always instanciate a DefaultChannelGroup. It would be interesting to add this check, as done in NettyConsumer .
</description>
			<version>2.17.2</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.springboot.NettyComponentAutoConfiguration.java</file>
			<file type="M">org.apache.camel.component.netty4.NettyServerBootstrapConfiguration.java</file>
			<file type="M">org.apache.camel.component.netty4.NettyProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="10215" opendate="2016-08-01 22:43:27" fixdate="2016-08-02 06:49:45" resolution="Fixed">
		<buginformation>
			<summary>EventDrivenPollingConsumer is not thread safe when used with ConsumerCache </summary>
			<description>For static endpoints, if DefaultConsumerTemplate#receive() is used,  ConsumerCache will return the cached instance of PollingConsumer for every thread part of parallel processing of split/aggregate.
Now, if EventDrivenPollingConsumer is used, returning same cache instance causes race condition in receive and receive(long) as the methods are not thread safe. The ordering of beforePoll, poll and afterPoll needs to be synchronized, otherwise the consumer might end up being suspended in afterPoll and the client whose beforePoll couldn&amp;amp;apos;t wake up the suspended thread will get no data.
</description>
			<version>2.18.0</version>
			<fixedVersion>2.16.4, 2.17.3, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.impl.EventDrivenPollingConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="10185" opendate="2016-07-26 09:32:13" fixdate="2016-08-05 05:54:13" resolution="Fixed">
		<buginformation>
			<summary>camel-ftp - fastExistsCheck issue</summary>
			<description>See SO
https://github.com/apache/camel/commit/91c086b7af22b6cfaf2f66b2c872b752dc10a19c#commitcomment-18363186</description>
			<version>2.17.2</version>
			<fixedVersion>2.16.4, 2.17.4, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.file.remote.strategy.FtpChangedExclusiveReadLockStrategy.java</file>
			<file type="M">org.apache.camel.component.file.remote.strategy.SftpChangedExclusiveReadLockStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="10195" opendate="2016-07-28 08:55:37" fixdate="2016-08-05 05:55:10" resolution="Fixed">
		<buginformation>
			<summary>rest-dsl - automatic binding failure with waitForTaskToComplete=Never</summary>
			<description>Hello,
Into my project i am using rest dsl.
when insert into my seda waitForTaskToComplete=Never attribute, automatic binding (json) is disabled!!!!
I create a simple camel example (see attachment)
To simulate it:
1. extract zip file
2. run "mvn clean camel:run"
TEST SUCCESS
curl -X GET -H "Content-type: application/json" -H "Accept: application/json"  localhost:8080/test/ok"
OUTPUT (JSON):

{
  "id" : 100.0
}

TEST FAILURE
curl -X GET -H "Content-type: application/json" -H "Accept: application/json"localhost:8080/test/failure"
OUTPUT (HashMap.toString()):

{id=100.0}

Best regards
FabryProg</description>
			<version>2.17.2</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.seda.SedaProducer.java</file>
			<file type="M">org.apache.camel.util.ExchangeHelper.java</file>
			<file type="M">org.apache.camel.spi.UnitOfWork.java</file>
			<file type="M">org.apache.camel.impl.DefaultUnitOfWork.java</file>
		</fixedFiles>
	</bug>
	<bug id="10090" opendate="2016-06-25 18:32:30" fixdate="2016-08-11 19:59:38" resolution="Fixed">
		<buginformation>
			<summary>Salesforce doesn&amp;apos;t support full ISO-8601 datetimes</summary>
			<description>See http://camel.465427.n5.nabble.com/camel-salesforce-component-date-time-issue-td5784399.html
When communicating old dates the timezone-offset in a ISO-8601 format contain seconds. This isn&amp;amp;apos;t supported by Salesforce.</description>
			<version>2.17.1</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.salesforce.api.utils.DateTimeUtils.java</file>
			<file type="D">org.apache.camel.component.salesforce.api.JodaTimeConverter.java</file>
			<file type="D">org.apache.camel.component.salesforce.internal.datetime.DateTimeDeserializer.java</file>
			<file type="D">org.apache.camel.component.salesforce.internal.datetime.DateTimeSerializer.java</file>
			<file type="M">org.apache.camel.component.salesforce.internal.processor.XmlRestProcessor.java</file>
			<file type="D">org.apache.camel.component.salesforce.internal.datetime.DateTimeModule.java</file>
			<file type="M">org.apache.camel.component.salesforce.internal.processor.JsonRestProcessorTest.java</file>
			<file type="M">org.apache.camel.component.salesforce.internal.processor.JsonRestProcessor.java</file>
			<file type="M">org.apache.camel.component.salesforce.RestApiIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="10244" opendate="2016-08-13 17:23:55" fixdate="2016-08-15 15:40:26" resolution="Fixed">
		<buginformation>
			<summary>When same netty endpoint producer is used twice in a route, BlockingOperationException is raised</summary>
			<description>Due to synchronous nature of connection establishment, when same endpoint producer is used twice in same route (e.g. to make two sequential WS calls), BlockingOperationException is thrown:



java.lang.AssertionError: io.netty.util.concurrent.BlockingOperationException: DefaultChannelPromise@4360ffb3(incomplete)
	at org.apache.camel.component.netty4.NettyTCPChainedTest.sendFile(NettyTCPChainedTest.java:53)
	at org.apache.camel.component.netty4.NettyTCPChainedTest.testTCPChainedConnectionFromCallbackThread(NettyTCPChainedTest.java:62)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
	at org.junit.rules.RunRules.evaluate(RunRules.java:20)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:78)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:212)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:68)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)
Caused by: io.netty.util.concurrent.BlockingOperationException: DefaultChannelPromise@4360ffb3(incomplete)
	at io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:398)
	at io.netty.channel.DefaultChannelPromise.checkDeadLock(DefaultChannelPromise.java:157)
	at io.netty.util.concurrent.DefaultPromise.awaitUninterruptibly(DefaultPromise.java:254)
	at io.netty.channel.DefaultChannelPromise.awaitUninterruptibly(DefaultChannelPromise.java:135)
	at io.netty.channel.DefaultChannelPromise.awaitUninterruptibly(DefaultChannelPromise.java:28)
	at org.apache.camel.component.netty4.NettyProducer.openChannel(NettyProducer.java:488)
	at org.apache.camel.component.netty4.NettyProducer$NettyProducerPoolableObjectFactory.makeObject(NettyProducer.java:563)
	at org.apache.camel.component.netty4.NettyProducer$NettyProducerPoolableObjectFactory.makeObject(NettyProducer.java:558)
	at org.apache.commons.pool.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:1188)
	at org.apache.camel.component.netty4.NettyProducer.process(NettyProducer.java:210)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:145)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:542)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:197)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:197)
	at org.apache.camel.component.direct.DirectProducer.process(DirectProducer.java:62)
	at org.apache.camel.processor.SendProcessor.process(SendProcessor.java:145)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:542)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:197)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:120)
	at org.apache.camel.processor.Pipeline.access$100(Pipeline.java:44)
	at org.apache.camel.processor.Pipeline$1.done(Pipeline.java:138)
	at org.apache.camel.processor.CamelInternalProcessor$InternalCallback.done(CamelInternalProcessor.java:257)
	at org.apache.camel.processor.RedeliveryErrorHandler$2.done(RedeliveryErrorHandler.java:554)
	at org.apache.camel.processor.SendProcessor$1.done(SendProcessor.java:155)
	at org.apache.camel.processor.CamelInternalProcessor$InternalCallback.done(CamelInternalProcessor.java:257)
	at org.apache.camel.processor.CamelInternalProcessor$InternalCallback.done(CamelInternalProcessor.java:257)
	at org.apache.camel.processor.RedeliveryErrorHandler$2.done(RedeliveryErrorHandler.java:554)
	at org.apache.camel.processor.SendProcessor$1.done(SendProcessor.java:155)
	at org.apache.camel.component.netty4.NettyProducer$NettyProducerCallback.done(NettyProducer.java:550)
	at org.apache.camel.component.netty4.NettyProducer$2.operationComplete(NettyProducer.java:338)
	at org.apache.camel.component.netty4.NettyProducer$2.operationComplete(NettyProducer.java:304)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:514)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:488)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:427)
	at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:111)
	at io.netty.channel.DefaultChannelPromise.trySuccess(DefaultChannelPromise.java:82)
	at io.netty.channel.ChannelOutboundBuffer.safeSuccess(ChannelOutboundBuffer.java:673)
	at io.netty.channel.ChannelOutboundBuffer.remove(ChannelOutboundBuffer.java:263)
	at io.netty.channel.ChannelOutboundBuffer.removeBytes(ChannelOutboundBuffer.java:343)
	at io.netty.channel.socket.nio.NioSocketChannel.doWrite(NioSocketChannel.java:425)
	at io.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:856)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.flush0(AbstractNioChannel.java:356)
	at io.netty.channel.AbstractChannel$AbstractUnsafe.flush(AbstractChannel.java:823)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.flush(DefaultChannelPipeline.java:1296)
	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:786)
	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:778)
	at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:759)
	at io.netty.channel.ChannelOutboundHandlerAdapter.flush(ChannelOutboundHandlerAdapter.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:786)
	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:778)
	at io.netty.channel.AbstractChannelHandlerContext.access$1500(AbstractChannelHandlerContext.java:38)
	at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1149)
	at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1090)
	at io.netty.util.concurrent.SingleThreadEventExecutor.safeExecute(SingleThreadEventExecutor.java:451)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:418)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:401)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:877)
	at java.lang.Thread.run(Thread.java:745)

</description>
			<version>2.17.3</version>
			<fixedVersion>2.17.4, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.NettyProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="10229" opendate="2016-08-09 15:47:55" fixdate="2016-08-16 14:29:56" resolution="Fixed">
		<buginformation>
			<summary>camel-rabbitmq - Race condition when stopping context with autoack=false</summary>
			<description>Run the following code and hit enter while one message is in unacked state (see RabbitMQ console):


public static void main(String[] args) throws Exception {
	CamelContext context = new DefaultCamelContext();

	context.addRoutes(new RouteBuilder() {
		@Override
		public void configure() {
			from("rabbitmq://localhost/?queue=sourceQueue&amp;amp;skipExchangeDeclare=true&amp;amp;skipQueueDeclare=true&amp;amp;autoAck=false&amp;amp;prefetchEnabled=true&amp;amp;prefetchCount=1")
					.delayer(5000)
					.setHeader("rabbitmq.ROUTING_KEY", constant("destinationQueue"))
					.to("rabbitmq://localhost/?skipExchangeDeclare=true&amp;amp;skipQueueDeclare=true&amp;amp;autoAck=false")
					.routeId("myRoute");
		}
	});
	context.start();
	new BufferedReader(new InputStreamReader(System.in)).readLine();
	context.stop();
}


you get the following exception:

com.rabbitmq.client.impl.DefaultExceptionHandler: Consumer org.apache.camel.component.rabbitmq.RabbitConsumer@4c57777e (amq.ctag-dWpQw46flmamv0dM_Fa_Qg) method handleDelivery for channel AMQChannel(amqp://rabbit_user@127.0.0.1:5672/,1) threw an exception for channel AMQChannel(amqp://rabbit_user@127.0.0.1:5672/,1):
com.rabbitmq.client.AlreadyClosedException: channel is already closed due to clean channel shutdown; protocol method: #method&amp;lt;channel.close&amp;gt;(reply-code=200, reply-text=OK, class-id=0, method-id=0)
	at com.rabbitmq.client.impl.AMQChannel.ensureIsOpen(AMQChannel.java:195)
	at com.rabbitmq.client.impl.AMQChannel.transmit(AMQChannel.java:309)
	at com.rabbitmq.client.impl.AMQChannel.transmit(AMQChannel.java:303)
	at com.rabbitmq.client.impl.ChannelN.basicAck(ChannelN.java:1043)
	at org.apache.camel.component.rabbitmq.RabbitConsumer.handleDelivery(RabbitConsumer.java:108)
	at com.rabbitmq.client.impl.ConsumerDispatcher$5.run(ConsumerDispatcher.java:144)
	at com.rabbitmq.client.impl.ConsumerWorkService$WorkPoolRunnable.run(ConsumerWorkService.java:99)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)


I think that this is caused by a race condition between the main thread that runs channel.close() immediately after channel.basicCancel(tag) (see org.apache.camel.component.rabbitmq.RabbitConsumer) without waiting the channel.basicAck(deliveryTag, false) in handleDelivery().
Another bad side effect is that you&amp;amp;apos;ll find a duplicate of a message on the destinationQueue. For example if you have 10 initial messages in sourceQueue and you hit enter while it&amp;amp;apos;s processing the third one, you&amp;amp;apos;ll get 7 messages in sourceQueue and 4 messages in destinationQueue.
The correct behaviour should be the following:
1) Stop consumer: channel.basicCancel(tag)
2) Wait if there is a running consumer
3) The consumer acks the previous message
4) Close the channel</description>
			<version>2.17.3</version>
			<fixedVersion>2.17.4, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="10171" opendate="2016-07-21 23:32:13" fixdate="2016-08-17 07:53:32" resolution="Fixed">
		<buginformation>
			<summary>Camel CXF expired continuations cause memory leak</summary>
			<description>Looks like exchanges expired by CXF continuation timeout are being accumulated in InflightRepository. Tested with Camel 2.17.1 and cxf-rt-transports-http-jetty:
Dependencies:

&amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.camel&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;camel-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.17.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.camel&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;camel-cxf&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.17.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.cxf&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;cxf-rt-transports-http-jetty&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.1.5&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

Reproducer:

import org.apache.camel.CamelContext;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.cxf.CxfEndpoint;
import org.apache.camel.component.cxf.DataFormat;
import org.apache.camel.impl.DefaultCamelContext;
import org.springframework.util.StreamUtils;
import org.w3c.dom.Document;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.soap.MessageFactory;
import javax.xml.soap.SOAPMessage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

public class Sample {

    private final static String URI = "http://127.0.0.1:8080/";
    private final static long CONTINUATION_TIMEOUT = 100L;
    private final static long DELAYER_VALUE = 200L;
    private final static int SENDER_THREADS = Runtime.getRuntime().availableProcessors();
    private final static int MESSAGES_PER_SENDER = 10000;

    private static void setupCamel() throws Exception {
        final CamelContext camelContext = new DefaultCamelContext();
        final CxfEndpoint endpoint = (CxfEndpoint)camelContext.getEndpoint( "cxf://" + URI );
        endpoint.setContinuationTimeout( CONTINUATION_TIMEOUT );
        endpoint.setDataFormat( DataFormat.PAYLOAD );
        camelContext.addRoutes( new RouteBuilder() {
            public void configure() throws Exception {
                from( endpoint )
                .threads()
                .setBody( constant( "&amp;lt;ok /&amp;gt;" ) )
                .delay( DELAYER_VALUE )
                .end();
            }
        });
        final TimerTask repoSizeReporter = new TimerTask() {
            public void run() {
                System.out.println( "Inflight repository size: " + camelContext.getInflightRepository().size() );
                System.gc();
                System.out.println( "Memory usage: " + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory())/(1024*1024) + "MB" );
            }
        };
        final Timer repoSizeReporterTimer = new Timer();
        repoSizeReporterTimer.schedule( repoSizeReporter, 1000, 1000 );
        camelContext.start();
    }

    private static byte[] createSoapMessage() throws Exception {
        final StringBuilder payloadBuilder = new StringBuilder( "&amp;lt;payload&amp;gt;" );
        for( int i = 0; i &amp;lt; 5000; i++ ) {
            payloadBuilder.append( "&amp;lt;payloadElement /&amp;gt;" );
        }
        final String payload = payloadBuilder.append( "&amp;lt;/payload&amp;gt;" ).toString();
        final DocumentBuilder documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        final Document payloadDocument = documentBuilder.parse( new ByteArrayInputStream( payload.getBytes() ) );
        final ByteArrayOutputStream soapOutStream = new ByteArrayOutputStream();
        final SOAPMessage message = MessageFactory.newInstance().createMessage();
        message.getSOAPBody().addDocument( payloadDocument );
        message.writeTo( soapOutStream );
        return soapOutStream.toByteArray();
    }

    private static Runnable soapSender() {
        return () -&amp;gt; {
            try {
                final byte[] soapMessage = createSoapMessage();
                for( int i = 0; i &amp;lt; MESSAGES_PER_SENDER; i++ ) {
                    final HttpURLConnection connection = (HttpURLConnection)new URL( URI ).openConnection();
                    connection.setDoOutput( true );
                    connection.setRequestProperty( "Content-Type", "text/xml" );
                    connection.setRequestProperty( "SOAPAction", "\"\"" );
                    connection.setRequestMethod( "POST" );
                    connection.setRequestProperty( "Accept", "*/*" );
                    connection.connect();
                    StreamUtils.copy( soapMessage, connection.getOutputStream() );
                    connection.getResponseCode();
                    connection.disconnect();
                }
            } catch ( final Exception ex ) {
                ex.printStackTrace();
            }
        };
    }

    public static void main(String[] args) throws Exception {
        setupCamel();
        final Executor executor = Executors.newFixedThreadPool( SENDER_THREADS );
        for( int i = 0; i &amp;lt; SENDER_THREADS; i++ ) {
            executor.execute( soapSender() );
        }
    }
}
</description>
			<version>2.17.1</version>
			<fixedVersion>2.17.4, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.CxfConsumer.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.CxfRsInvoker.java</file>
		</fixedFiles>
	</bug>
	<bug id="10253" opendate="2016-08-18 15:25:42" fixdate="2016-08-21 10:46:00" resolution="Fixed">
		<buginformation>
			<summary>NullPointer in ThrowExceptionProcessor.getTraceLabel</summary>
			<description>When using
ProcessorDefinition.java

 throwException(Class&amp;lt;? extends Exception&amp;gt; type, String message) 


to define a Exception and having the tracing set to True in Camel context, if  an exception occurred, it will call 
ThrowExceptionProcessor.java

  public String getTraceLabel() {
        return "throwException[" + this.exception.getClass().getSimpleName() + "]";
    }


But this.exception is null.
A patch could be:
ThrowExceptionProcessor.java

    public String getTraceLabel() {
        String className= this.exception==null?this.type.getSimpleName():this.exception.getClass().getSimpleName();
        return "throwException[" + className + "]";
    }


</description>
			<version>2.17.3</version>
			<fixedVersion>2.16.4, 2.17.4, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.ThrowExceptionProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="10254" opendate="2016-08-19 08:23:37" fixdate="2016-08-22 16:08:15" resolution="Fixed">
		<buginformation>
			<summary>Error may still block mail-consumer </summary>
			<description>If an error occurs before routing an email (email corrupt), the consumer blocks and does not process further emails. A similar issue was fixed with CAMEL-7474, but the issue still exists at another location.
CAMEL-7474 introduced a parameter "skipFailedMessage", which is used in Line 291 of the MailConsumer. If an error occurs in "createExchanges" (Line 128) the parameter is not evaluated.
Example stacktrace:


2016.08.19 10:10:35.613 DEBUG Camel (camel-1) thread #52 - pop3s://dev1@dev.de) Error populating the initial mail message attachments
org.apache.camel.RuntimeCamelException: Error populating the initial mail message attachments
	at org.apache.camel.component.mail.MailMessage.populateInitialAttachments(MailMessage.java:131)
	at org.apache.camel.impl.DefaultMessage.createAttachments(DefaultMessage.java:216)
	at org.apache.camel.impl.DefaultMessage.getAttachments(DefaultMessage.java:281)
	at org.apache.camel.component.mail.MailConsumer.createExchanges(MailConsumer.java:328)
	at org.apache.camel.component.mail.MailConsumer.poll(MailConsumer.java:121)
	at org.apache.camel.impl.ScheduledPollConsumer.doRun(ScheduledPollConsumer.java:174)
	at org.apache.camel.impl.ScheduledPollConsumer.run(ScheduledPollConsumer.java:101)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)
	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:304)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:178)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
	at java.lang.Thread.run(Thread.java:745)
Caused by: javax.mail.MessagingException: Missing start boundary
	at javax.mail.internet.MimeMultipart.parsebm(MimeMultipart.java:882)
	at javax.mail.internet.MimeMultipart.parse(MimeMultipart.java:503)
	at javax.mail.internet.MimeMultipart.getCount(MimeMultipart.java:244)
	at org.apache.camel.component.mail.MailBinding.extractAttachmentsFromMultipart(MailBinding.java:304)
	at org.apache.camel.component.mail.MailBinding.extractAttachmentsFromMail(MailBinding.java:293)
	at org.apache.camel.component.mail.MailMessage.populateInitialAttachments(MailMessage.java:128)
	... 13 more


Results are the same as described in CAMEL-7474</description>
			<version>2.15.3</version>
			<fixedVersion>2.17.4, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mail.MailConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="10273" opendate="2016-08-26 15:59:48" fixdate="2016-08-27 08:41:03" resolution="Fixed">
		<buginformation>
			<summary>[Jetty] missing jmx object if custom thread pool is used</summary>
			<description>If a custom configuration for the ThreadPool is passed, the correspondent JMX object is not published.
The issue here is that enableJmx(), https://github.com/apache/camel/blob/camel-2.17.3/components/camel-jetty-common/src/main/java/org/apache/camel/component/jetty/JettyHttpComponent.java#L314
that adds the mbeans listeners is called only after setThread https://github.com/apache/camel/blob/camel-2.17.3/components/camel-jetty-common/src/main/java/org/apache/camel/component/jetty/JettyHttpComponent.java#L1177 method, so this explains how come the threadpool is not exposed on JMX.
I&amp;amp;apos;ve put a simple PR that just adds a check for enableJmx flag at component level, but I wonder if I should make it smarter to take in account possible settings only at Endpoint level or instead if we should remove it the flag per Endpoint altogether.</description>
			<version>2.17.3</version>
			<fixedVersion>2.17.4, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="10282" opendate="2016-09-01 08:23:33" fixdate="2016-09-01 08:52:50" resolution="Fixed">
		<buginformation>
			<summary>[Avro] Issue on OSGi due to static cache</summary>
			<description>Avro holds a cache of classloaders and other reflection related classes in a static map here:
https://github.com/apache/avro/blob/master/lang/java/avro/src/main/java/org/apache/avro/specific/SpecificData.java#L52-L57
Keys of that map are {{String}}s with classname.
The cache is never updated, and this breaks OSGi ability to update a new class definition, since avro will keep pointing to the old version.
This will lead to a situation where, on an OSGi platform, you are exposed to ClassCastException since the rest of the platform might see a different varsion than the old one cached by avro.
The attached fix is a simple way to entirely bypass this caching behavior with just public subclasses that turn off just the caching behavior.</description>
			<version>2.17.3</version>
			<fixedVersion>2.16.4, 2.17.4, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.dataformat.avro.AvroDataFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="10291" opendate="2016-09-05 18:00:11" fixdate="2016-09-06 06:05:44" resolution="Fixed">
		<buginformation>
			<summary>Camel RabbitMQ invalid handling of message timestamp</summary>
			<description>At the moment the RabbitMQ component is does not map the timestamp of a message appropriately. The outbound mapping (producer) expects the timestamp of the camel message is of type String whereas the String is just the long value representing the timestamp. However the timestamp is already a java.util.Date when the producer just forwards a message from a rabbitmq consumer as the timestamp is already a java.util.date as define in AMQP.BasicProperties.
The provided pull request provides a compatible change. So it still keeps the old behaviour as fallback so that the long value is evaluated if the provided data is not a java.util.Date</description>
			<version>2.17.3</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQProducerTest.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQMessageConverter.java</file>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQConsumerIntTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="10064" opendate="2016-06-16 13:06:51" fixdate="2016-09-06 08:49:07" resolution="Fixed">
		<buginformation>
			<summary>Extra request parameter sent by the camel-jetty component</summary>
			<description>Trying to build a very simple HTTP proxy, exactly like described in the first code sample from http://camel.apache.org/how-to-use-camel-as-a-http-proxy-between-a-client-and-server.html.
Using wireshark to see exactly what is going on.
When i do a request on http://localhost:8080/myapp, the request that is sended to real server is http://realserverhostname:8090/myapp?bridgeEndpoint=true&amp;amp;throwExceptionOnFailure=false.
when i do a parameterized request http://localhost:8080/myapp?toto=tata, the request that is sended to real server is http://realserverhostname:8090/myapp?toto=tata.
So when the when there is no request param, the endpoint parameter bridgeEndpoint=true&amp;amp;throwExceptionOnFailure=false are sended to the realserver, and if there is param they are not sended.</description>
			<version>2.16.3</version>
			<fixedVersion>2.17.4, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty.JettyHttpComponent.java</file>
			<file type="M">org.apache.camel.component.jetty.jettyproducer.JettyHttpProducerBridgeTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">4768</link>
		</links>
	</bug>
	<bug id="10296" opendate="2016-09-07 19:01:32" fixdate="2016-09-08 07:40:54" resolution="Fixed">
		<buginformation>
			<summary>Guaranteed Delivery not working if no timeout is set</summary>
			<description>When guaranteed delivery is activated but no timeout is set for publisher acknowledgement waitForConfirmsOrDie will never return.
This is because the close is not triggered on the channel even if the connection is closed when an exception is thrown in the return listener.
This is also the reason why the integration test for the producer does not complete.
The provided pull request fixes this issue in that way that it will just remember that a basic.return has been received and will throw the exception after waitForReturnOrDie completes</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.rabbitmq.RabbitMQMessagePublisher.java</file>
		</fixedFiles>
	</bug>
	<bug id="10293" opendate="2016-09-06 16:11:27" fixdate="2016-09-10 11:05:07" resolution="Fixed">
		<buginformation>
			<summary>[camel-maven-plugin] When blueprint detected, plugin ignores useBlueprint, fileApplicationContextUri tags</summary>
			<description>It seems not to be possible to force camel:run to use Spring DSL file if OSGi bluepring is available. Following configuration is completely ignored if there is a blueprint in OSGI-INF folder:


            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.camel&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;camel-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.17.3&amp;lt;/version&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;useBlueprint&amp;gt;false&amp;lt;/useBlueprint&amp;gt;
                    &amp;lt;fileApplicationContextUri&amp;gt;
                        META-INF/spring/camel-context.xml
                    &amp;lt;/fileApplicationContextUri&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;

</description>
			<version>2.17.3</version>
			<fixedVersion>2.17.4, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.maven.RunMojo.java</file>
		</fixedFiles>
	</bug>
	<bug id="10303" opendate="2016-09-09 18:34:13" fixdate="2016-09-15 07:27:57" resolution="Fixed">
		<buginformation>
			<summary>MllpTcpServerConsumer fails silently on acknowledgment failure</summary>
			<description>If an error occurs when MllpTcpServerConsumer is delivering the acknowledgment back to the caller, there is now way to tell that the acknowledgement failed.
The MllpTcpServerConsumer needs to make the route fail and log an error about the condition.</description>
			<version>2.17.0</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mllp.MllpTcpServerConsumerConnectionTest.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpCommitErrorAcknowledgementException.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpComponent.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpConstants.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpAcknowledgementTimoutException.java</file>
			<file type="M">org.apache.camel.component.mllp.impl.MllpUtil.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpAcknowledgementException.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpInvalidAcknowledgementException.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpException.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpApplicationErrorAcknowledgementException.java</file>
			<file type="D">org.apache.camel.component.mllp.MllpCorruptFrameException.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpApplicationRejectAcknowledgementException.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpProducerConsumerLoopbackTest.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpTcpServerConsumerAcknowledgementTest.java</file>
			<file type="M">org.apache.camel.test.junit.rule.mllp.MllpClientResource.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpTcpClientProducer.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpTimeoutException.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpTcpServerConsumer.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpTcpClientProducerTest.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpCommitRejectAcknowledgementException.java</file>
			<file type="M">org.apache.camel.component.mllp.MllpWriteException.java</file>
		</fixedFiles>
	</bug>
	<bug id="10342" opendate="2016-09-26 13:37:08" fixdate="2016-09-27 06:33:22" resolution="Fixed">
		<buginformation>
			<summary>WebSockets options are ignored</summary>
			<description>Setting maxTextMessageSize or maxBinaryMessageSize has no effect, messages above the limit are still consumed and the route is started.
I was debugging it to understand what was wrong and I came to the conclusion that parameters are set correctly on the camel WebSocketEndpoint and then on the ServletContextHandler (in camel method WebSocketComponent.setWebSocketComponentServletInitialParameter).
But then the same values are null in jetty method WebSocketServlet.init() and they are not set on the WebSocketFactory.
When I open a WebSocket connection I can see the default values are used instead of my settings in jetty WebSocketFactory.upgrade method.
I think the problem is the init parameters that are set on the camel ServletContextHandler are not copied on the jetty ServletHolder.
If I override the websocket bean in blueprint.xml with my own and override the createServlet method to copy the parameters then everything works correctly.
So effectively changing the line in createServlet
	handler.addServlet(new ServletHolder(servlet), pathSpec);
By
	ServletHolder servletHolder = new ServletHolder(servlet);
	servletHolder.setInitParameters(handler.getInitParams());
	handler.addServlet(servletHolder, pathSpec);
Also I think the unit test WebscoketEndpointConfigurationTest.testSetServletInitalparameters is wrong, it simply verifies that the values are set in camel but never checks they are set correctly on the jetty side.</description>
			<version>2.16.3</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.websocket.WebsocketEndpointConfigurationTest.java</file>
			<file type="M">org.apache.camel.component.websocket.WebsocketComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="10359" opendate="2016-09-30 02:32:25" fixdate="2016-09-30 02:42:52" resolution="Fixed">
		<buginformation>
			<summary>Fix failing test org.apache.camel.component.salesforce.RestApiIntegrationTest.testQueryAll</summary>
			<description>The test fails since the XmlRestProcessor is missing a case for QUERY_ALL enum in processRequest(). </description>
			<version>2.18.0</version>
			<fixedVersion>2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.salesforce.internal.processor.XmlRestProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="10238" opendate="2016-08-11 13:39:50" fixdate="2016-09-30 08:18:45" resolution="Fixed">
		<buginformation>
			<summary>Camel-salesforce component never tries to reconnect after a disconnect</summary>
			<description>My connection to salesforce-streaming api gets disconnect automatically after 2 hours. This is because salesforce automatically disconnects the connection from server side. However, I was expecting camel-salesforce component to reconnect automatically after disconnect. But, it does not reconnect and I do not have a  hold or a way to reconnect. Seems to be a defect and a blocker to me.
Here is the trace log


[36mo.a.c.c.s.i.s.SubscriptionHelper        [0;39m [2m:[0;39m [CHANNEL:META_CONNECT]: {clientId=3u9riwg6ag3r5dd3ay86i444f, channel=/meta/connect, id=84, successful=true}
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m Connecting, transport org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$3@4e0cc334
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m Sending messages [{clientId=3u9riwg6ag3r5dd3ay86i444f, channel=/meta/connect, id=85, connectionType=long-polling}]
[36mo.a.c.c.s.i.s.SubscriptionHelper$3      [0;39m [2m:[0;39m Received messages [{clientId=3u9riwg6ag3r5dd3ay86i444f, channel=/meta/connect, id=85, successful=true}]
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m Processing /meta/connect {clientId=3u9riwg6ag3r5dd3ay86i444f, channel=/meta/connect, id=85, successful=true}
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m State update: CONNECTED -&amp;gt; CONNECTED
[36mo.a.c.c.s.i.s.SubscriptionHelper        [0;39m [2m:[0;39m [CHANNEL:META_CONNECT]: {clientId=3u9riwg6ag3r5dd3ay86i444f, channel=/meta/connect, id=85, successful=true}
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m Connecting, transport org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$3@4e0cc334
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m Sending messages [{clientId=3u9riwg6ag3r5dd3ay86i444f, channel=/meta/connect, id=86, connectionType=long-polling}]
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m State update: CONNECTED -&amp;gt; UNCONNECTED
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m Messages failed [{clientId=3u9riwg6ag3r5dd3ay86i444f, channel=/meta/connect, id=86, connectionType=long-polling}]

java.io.EOFException: HttpConnectionOverHTTP@12f0e719(l:/10.172.131.200:50574 &amp;lt;-&amp;gt; r:my-proxy.com/x.x.x.x:xx,closed=false)[HttpChannelOverHTTP@2a4927(exchange=HttpExchange@6ae1ae35 req=TERMINATED/null@null res=PENDING/null@null)[send=HttpSenderOverHTTP@51fea1e0(req=QUEUED,snd=COMPLETED,failure=null)[HttpGenerator{s=START}],recv=HttpReceiverOverHTTP@44234ce9(rsp=IDLE,failure=null)[HttpParser{s=CLOSED,0 of -1}]]]
	at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.earlyEOF(HttpReceiverOverHTTP.java:277) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:1309) [jetty-http-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.shutdown(HttpReceiverOverHTTP.java:182) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.process(HttpReceiverOverHTTP.java:129) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.http.HttpReceiverOverHTTP.receive(HttpReceiverOverHTTP.java:69) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.http.HttpChannelOverHTTP.receive(HttpChannelOverHTTP.java:89) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.onFillable(HttpConnectionOverHTTP.java:122) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.io.AbstractConnection$2.run(AbstractConnection.java:544) [jetty-io-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:635) [jetty-util-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:555) [jetty-util-9.2.14.v20151106.jar:9.2.14.v20151106]
	at java.lang.Thread.run(Thread.java:745) [na:1.8.0_66]

[36mo.a.c.c.s.i.s.SubscriptionHelper        [0;39m [2m:[0;39m [CHANNEL:META_CONNECT]: {failure={exception=java.io.EOFException: HttpConnectionOverHTTP@12f0e719(l:/10.172.131.200:50574 &amp;lt;-&amp;gt; r:my-proxy.com/x.x.x.x:xx,closed=false)[HttpChannelOverHTTP@2a4927(exchange=HttpExchange@6ae1ae35 req=TERMINATED/null@null res=PENDING/null@null)[send=HttpSenderOverHTTP@51fea1e0(req=QUEUED,snd=COMPLETED,failure=null)[HttpGenerator{s=START}],recv=HttpReceiverOverHTTP@44234ce9(rsp=IDLE,failure=null)[HttpParser{s=CLOSED,0 of -1}]]], message={clientId=3u9riwg6ag3r5dd3ay86i444f, channel=/meta/connect, id=86, connectionType=long-polling}, connectionType=long-polling}, channel=/meta/connect, id=86, subscription=null, successful=false}
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m Connecting, transport org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$3@4e0cc334
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m Sending messages [{clientId=3u9riwg6ag3r5dd3ay86i444f, advice={timeout=0}, channel=/meta/connect, id=87, connectionType=long-polling}]
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m State update: UNCONNECTED -&amp;gt; UNCONNECTED
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m Messages failed [{clientId=3u9riwg6ag3r5dd3ay86i444f, advice={timeout=0}, channel=/meta/connect, id=87, connectionType=long-polling}]

org.eclipse.jetty.io.EofException: null
	at org.eclipse.jetty.io.ssl.SslConnection$DecryptedEndPoint.flush(SslConnection.java:723) ~[jetty-io-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.io.WriteFlusher.flush(WriteFlusher.java:408) ~[jetty-io-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.io.WriteFlusher.write(WriteFlusher.java:302) ~[jetty-io-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.io.AbstractEndPoint.write(AbstractEndPoint.java:129) [jetty-io-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.http.HttpSenderOverHTTP.sendHeaders(HttpSenderOverHTTP.java:108) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.HttpSender.send(HttpSender.java:204) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.http.HttpChannelOverHTTP.send(HttpChannelOverHTTP.java:78) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.http.HttpConnectionOverHTTP$Delegate.send(HttpConnectionOverHTTP.java:218) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.http.HttpConnectionOverHTTP.send(HttpConnectionOverHTTP.java:91) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.http.HttpDestinationOverHTTP.send(HttpDestinationOverHTTP.java:36) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.http.HttpDestinationOverHTTP.send(HttpDestinationOverHTTP.java:26) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.PoolingHttpDestination.process(PoolingHttpDestination.java:150) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.PoolingHttpDestination.send(PoolingHttpDestination.java:85) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.PoolingHttpDestination.send(PoolingHttpDestination.java:76) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.HttpDestination.send(HttpDestination.java:187) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.HttpClient.send(HttpClient.java:527) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.HttpRequest.send(HttpRequest.java:694) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.eclipse.jetty.client.HttpRequest.send(HttpRequest.java:678) [jetty-client-9.2.14.v20151106.jar:9.2.14.v20151106]
	at org.cometd.client.transport.LongPollingTransport.send(LongPollingTransport.java:191) [cometd-java-client-3.0.9.jar:na]
	at org.cometd.client.BayeuxClient$BayeuxClientState.transportSend(BayeuxClient.java:1430) [cometd-java-client-3.0.9.jar:na]
	at org.cometd.client.BayeuxClient$BayeuxClientState.send(BayeuxClient.java:1425) [cometd-java-client-3.0.9.jar:na]
	at org.cometd.client.BayeuxClient.sendConnect(BayeuxClient.java:482) [cometd-java-client-3.0.9.jar:na]
	at org.cometd.client.BayeuxClient$12.run(BayeuxClient.java:815) [cometd-java-client-3.0.9.jar:na]
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [na:1.8.0_66]
	at java.util.concurrent.FutureTask.run(FutureTask.java:266) [na:1.8.0_66]
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) [na:1.8.0_66]
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) [na:1.8.0_66]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_66]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_66]
	at java.lang.Thread.run(Thread.java:745) [na:1.8.0_66]
Caused by: java.nio.channels.ClosedChannelException: null
	... 30 common frames omitted

[36mo.a.c.c.s.i.s.SubscriptionHelper        [0;39m [2m:[0;39m [CHANNEL:META_CONNECT]: {failure={exception=org.eclipse.jetty.io.EofException, message={clientId=3u9riwg6ag3r5dd3ay86i444f, advice={timeout=0}, channel=/meta/connect, id=87, connectionType=long-polling}, connectionType=long-polling}, channel=/meta/connect, id=87, subscription=null, successful=false}
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m Connecting, transport org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$3@4e0cc334
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m Sending messages [{clientId=3u9riwg6ag3r5dd3ay86i444f, advice={timeout=0}, channel=/meta/connect, id=88, connectionType=long-polling}]
[36mo.a.c.c.s.i.s.SubscriptionHelper$3      [0;39m [2m:[0;39m Received messages [{advice={reconnect=handshake, interval=0}, channel=/meta/connect, id=88, error=403::Unknown client, successful=false}]
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m Processing /meta/connect {advice={reconnect=handshake, interval=0}, channel=/meta/connect, id=88, error=403::Unknown client, successful=false}
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m State update: UNCONNECTED -&amp;gt; REHANDSHAKING
[36mo.a.c.c.s.i.s.SubscriptionHelper        [0;39m [2m:[0;39m [CHANNEL:META_CONNECT]: {advice={reconnect=handshake, interval=0}, channel=/meta/connect, id=88, error=403::Unknown client, successful=false}
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m Handshaking on transport org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper$3@4e0cc334: {supportedConnectionTypes=[long-polling], channel=/meta/handshake, version=1.0}
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m Sending messages [{ext={replay=true}, supportedConnectionTypes=[long-polling], channel=/meta/handshake, id=89, version=1.0}]
[36mo.a.c.c.s.i.s.SubscriptionHelper$3      [0;39m [2m:[0;39m Received messages [{ext={replay=true}, advice={reconnect=none}, channel=/meta/handshake, id=89, error=401::Authentication invalid, successful=false}]
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m Processing /meta/handshake {ext={replay=true}, advice={reconnect=none}, channel=/meta/handshake, id=89, error=401::Authentication invalid, successful=false}
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m State update: REHANDSHAKING -&amp;gt; TERMINATING
[36mo.a.c.c.s.i.s.SubscriptionHelper        [0;39m [2m:[0;39m [CHANNEL:META_HANDSHAKE]: {ext={replay=true}, advice={reconnect=none}, channel=/meta/handshake, id=89, error=401::Authentication invalid, successful=false}
[36morg.cometd.client.BayeuxClient          [0;39m [2m:[0;39m State update: TERMINATING -&amp;gt; DISCONNECTED

</description>
			<version>2.17.2</version>
			<fixedVersion>2.17.4, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.salesforce.internal.streaming.SubscriptionHelper.java</file>
			<file type="M">org.apache.camel.component.salesforce.springboot.SalesforceComponentConfiguration.java</file>
			<file type="M">org.apache.camel.component.salesforce.SalesforceEndpointConfig.java</file>
			<file type="M">org.apache.camel.component.salesforce.SalesforceComponent.java</file>
			<file type="M">org.apache.camel.component.salesforce.SalesforceConsumer.java</file>
			<file type="M">org.apache.camel.component.salesforce.internal.client.SalesforceSecurityHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="10340" opendate="2016-09-23 03:25:03" fixdate="2016-09-30 11:59:45" resolution="Fixed">
		<buginformation>
			<summary>camel-aws - SQS option deleteAfterRead not work if set deleteIfFiltered=false</summary>
			<description>I&amp;amp;apos;m using aws-sqs 2.17.3, if I set deleteAfterRead=true and deleteIfFiltered=false in my DSL, the message will not be deleted. If I want to delete the message after read it, I have to set deleteAfterRead and deleteIfFiltered both with true when I use the two options in one DSL, but in fact there is no filter in my route, the message should be removed whatever the deleteIfFiltered option set to ture or false.
SqsConsumerDeleteTest.java

from("aws-sqs:my-quque"
    + "?amazonSQSClient=#conn_cAWSConnection_1"
    + "&amp;amp;deleteAfterRead=" + true + "&amp;amp;deleteIfFiltered="
    + false).to("log:qs_route.cLog_1" + "?level=DEBUG").to("mock:mock_1");


I attached my test file, after run the test method, the sqs message still exists in the sqs queue after 30 seconds.</description>
			<version>2.17.3</version>
			<fixedVersion>2.17.4, 2.18.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.aws.sqs.SqsConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="10366" opendate="2016-10-04 09:00:38" fixdate="2016-10-06 02:36:55" resolution="Fixed">
		<buginformation>
			<summary>Missing input/output values in camel-catalog for several eips</summary>
			<description>In camel-catalog jar in org.apache.camel.catalog.models/*.json,
some of the files does not define the input/output values
list of elements for which it is missing:
beanPostProcessor, errorHandler, endpoint, streamCaching, propertiesFunction, export, restContext, propertyPlaceholder, fluentTemplate, template, consumerTemplate, camelContext, routeContext, jmxAgent, redeliveryPolicyProfile, threadPool, proxy</description>
			<version>2.18.0</version>
			<fixedVersion>2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.tools.apt.SpringAnnotationProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="10370" opendate="2016-10-04 14:18:01" fixdate="2016-10-06 05:44:51" resolution="Fixed">
		<buginformation>
			<summary>Conversion to CxfPayload throws Exception for Non-XML payload</summary>
			<description>The CxfPayloadConverter throws a runtime Exception for (optional) conversion from byte[] to CxfPayload instead of returning null when the body is not valid XML.</description>
			<version>2.17.3</version>
			<fixedVersion>2.17.4, 2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.converter.CxfPayloadConverterTest.java</file>
			<file type="M">org.apache.camel.component.cxf.converter.CxfPayloadConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="10372" opendate="2016-10-07 13:10:02" fixdate="2016-10-07 15:09:32" resolution="Fixed">
		<buginformation>
			<summary>camel-stream - Component doc issue</summary>
			<description>A little mistake</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.stream.StreamEndpoint.java</file>
			<file type="M">org.apache.camel.component.stream.StreamComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="10381" opendate="2016-10-11 19:03:53" fixdate="2016-10-11 19:15:57" resolution="Fixed">
		<buginformation>
			<summary>camel-google-mail getting NPE from component configuration</summary>
			<description>From forums:
When i run the application and start the route i get an NPE which points to
org.apache.camel.component.google.mail.GoogleMailComponent.getClient(GoogleMailComponent.java:50
as the culprit.</description>
			<version>2.18.0</version>
			<fixedVersion>2.17.3, 2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.google.calendar.GoogleCalendarEndpoint.java</file>
			<file type="M">org.apache.camel.component.google.calendar.GoogleCalendarComponent.java</file>
			<file type="M">org.apache.camel.component.google.drive.GoogleDriveComponent.java</file>
			<file type="M">org.apache.camel.component.google.drive.GoogleDriveFilesConverter.java</file>
			<file type="M">org.apache.camel.component.google.drive.GoogleDriveEndpoint.java</file>
			<file type="M">org.apache.camel.component.google.mail.GoogleMailEndpoint.java</file>
			<file type="M">org.apache.camel.component.google.mail.GoogleMailComponent.java</file>
		</fixedFiles>
	</bug>
	<bug id="10376" opendate="2016-10-10 13:14:14" fixdate="2016-10-12 10:57:23" resolution="Fixed">
		<buginformation>
			<summary>BeanInfo#introspect does not work correctly with bridge methods</summary>
			<description>Instead of selecting implementation method, bridge method is used. We faced an issue with conversion of parameter when bean implements generic interface.
For example having bean implementation like this:


    public interface Service&amp;lt;R&amp;gt; {

        int process(R request);
    }

    public static class MyService implements Service&amp;lt;Request&amp;gt; {

        public int process(Request request) {
            return request.x + 1;
        }
    }


would lead to beanInfo containing Method with signature 


public abstract int process(Object request)


in methodMap
This is not correct as conversion of parameter is not possible in this case.
I could find an issue with the same problem that was previously fixed (CAMEL-8940), but later on it was broken with CAMEL-9656 (commit 5639b78).</description>
			<version>2.17.3</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.bean.BeanInfo.java</file>
		</fixedFiles>
	</bug>
	<bug id="10385" opendate="2016-10-13 03:18:41" fixdate="2016-10-14 08:14:59" resolution="Fixed">
		<buginformation>
			<summary>simple ognl expression issue w/ list &amp; spring boot</summary>
			<description>conflict running simple expression w/ list under spring boot.  SpringTypeConverter is registered as a fallback converter which gets picked up during ognl while attempting to convert list -&amp;gt; map causing an exception instead of a null response that is expected.  It is happening under 2.17 &amp;amp; 2.18.
sample expression: $
{body.list[0].field}
 
10:20:32.499 [main] TRACE o.a.c.i.c.DefaultTypeConverter | Converting java.util.ArrayList -&amp;gt; java.util.Map 
10:20:32.500 [main] TRACE o.a.c.i.c.DefaultTypeConverter | Using converter: org.apache.camel.impl.converter.ArrayTypeConverter@79d7035 to convert [class java.util.ArrayList=&amp;gt;interface java.util.Map] 
Caused by: org.apache.camel.TypeConversionException: Error during type conversion from type: java.util.ArrayList to the required type: java.util.Map with due Failed to convert from type [java.util.ArrayList&amp;lt;?&amp;gt;] to type [java.util.Map&amp;lt;?, ?&amp;gt;] 
        at org.apache.camel.impl.converter.BaseTypeConverterRegistry.createTypeConversionException(BaseTypeConverterRegistry.java:629) 
        at org.apache.camel.impl.converter.BaseTypeConverterRegistry.convertTo(BaseTypeConverterRegistry.java:150) 
        at org.apache.camel.impl.converter.BaseTypeConverterRegistry.convertTo(BaseTypeConverterRegistry.java:121) 
        at org.apache.camel.language.bean.BeanExpression$OgnlInvokeProcessor.lookupResult(BeanExpression.java:358) 
        at org.apache.camel.language.bean.BeanExpression$OgnlInvokeProcessor.process(BeanExpression.java:334) 
        at org.apache.camel.language.bean.BeanExpression.evaluate(BeanExpression.java:114) 
        ... 55 common frames omitted 
Caused by: org.springframework.core.convert.ConversionFailedException: Failed to convert from type [java.util.ArrayList&amp;lt;?&amp;gt;] to type [java.util.Map&amp;lt;?, ?&amp;gt;] 
        at org.springframework.core.convert.support.ConversionUtils.invokeConverter(ConversionUtils.java:42) 
        at org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:192) 
        at org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:176) 
        at org.apache.camel.spring.boot.SpringTypeConverter.convertTo(SpringTypeConverter.java:46) 
        at org.apache.camel.impl.converter.BaseTypeConverterRegistry.doConvertTo(BaseTypeConverterRegistry.java:346) 
        at org.apache.camel.impl.converter.BaseTypeConverterRegistry.convertTo(BaseTypeConverterRegistry.java:133) 
        ... 59 common frames omitted </description>
			<version>2.17.0</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.boot.SpringTypeConverter.java</file>
			<file type="M">org.apache.camel.spring.boot.issues.SimpleOgnlTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="10386" opendate="2016-10-13 21:33:35" fixdate="2016-10-14 08:47:51" resolution="Fixed">
		<buginformation>
			<summary>simple language nullsafe expression fails on empty array</summary>
			<description>limitation w/ simple language on the 1st index of an empty array with a nullsafe expression  
sample expression: $
{in.body?.list[0].toString}

org.apache.camel.language.bean.RuntimeBeanExpressionException: Failed to invoke method: ?.get(&amp;amp;apos;list&amp;amp;apos;)[0].toString on java.util.HashMap due to: java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 
        at org.apache.camel.language.bean.BeanExpression.evaluate(BeanExpression.java:120) 
        at org.apache.camel.language.bean.BeanExpression.evaluate(BeanExpression.java:138) 
        at org.apache.camel.model.language.ExpressionDefinition.evaluate(ExpressionDefinition.java:126) 
        at org.apache.camel.model.language.ExpressionDefinition.evaluate(ExpressionDefinition.java:118) 
        at org.apache.camel.builder.ExpressionBuilder$40.evaluate(ExpressionBuilder.java:993) 
        at org.apache.camel.support.ExpressionAdapter.evaluate(ExpressionAdapter.java:36) 
        at org.apache.camel.TestSupport.assertExpression(TestSupport.java:255) 
        at org.apache.camel.ContextTestSupport.assertExpression(ContextTestSupport.java:314) 
        at org.apache.camel.LanguageTestSupport.assertExpression(LanguageTestSupport.java:62) 
        at org.apache.camel.LanguageTestSupport.assertExpression(LanguageTestSupport.java:69) 
        at org.apache.camel.language.simple.SimpleTest.testOGNLBodyEmptyList(SimpleTest.java:267) 
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) 
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) 
        at java.lang.reflect.Method.invoke(Method.java:497) 
        at junit.framework.TestCase.runTest(TestCase.java:176) 
        at junit.framework.TestCase.runBare(TestCase.java:141) 
        at org.apache.camel.TestSupport.runBare(TestSupport.java:58) 
        at junit.framework.TestResult$1.protect(TestResult.java:122) 
        at junit.framework.TestResult.runProtected(TestResult.java:142) 
        at junit.framework.TestResult.run(TestResult.java:125) 
        at junit.framework.TestCase.run(TestCase.java:129) 
        at junit.framework.TestSuite.runTest(TestSuite.java:252) 
        at junit.framework.TestSuite.run(TestSuite.java:247) 
        at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86) 
        at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86) 
        at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) 
        at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459) 
        at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675) 
        at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382) 
        at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192) 
Caused by: java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 
        at java.util.ArrayList.rangeCheck(ArrayList.java:653) 
        at java.util.ArrayList.get(ArrayList.java:429) 
        at org.apache.camel.language.bean.BeanExpression$OgnlInvokeProcessor.lookupResult(BeanExpression.java:385) 
        at org.apache.camel.language.bean.BeanExpression$OgnlInvokeProcessor.process(BeanExpression.java:334) 
        at org.apache.camel.language.bean.BeanExpression.evaluate(BeanExpression.java:114) </description>
			<version>2.17.3</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.language.simple.SimpleTest.java</file>
			<file type="M">org.apache.camel.language.bean.BeanExpression.java</file>
		</fixedFiles>
	</bug>
	<bug id="10383" opendate="2016-10-12 08:39:41" fixdate="2016-10-16 11:15:32" resolution="Fixed">
		<buginformation>
			<summary>activemq-camel - Issue with parsing uri to determine queue vs topic</summary>
			<description>See screenshot
</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.util.EndpointHelper.java</file>
			<file type="M">org.apache.camel.util.URISupport.java</file>
			<file type="M">org.apache.camel.catalog.CamelCatalogTest.java</file>
			<file type="M">org.apache.camel.catalog.URISupport.java</file>
			<file type="M">org.apache.camel.util.JsonSchemaHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="10380" opendate="2016-10-11 13:57:45" fixdate="2016-10-17 09:34:52" resolution="Fixed">
		<buginformation>
			<summary>JettyHttpEndpoint9 ignores eagerCheckContentAvailable so Jetty builds a reuqest with "Transfer-Encoding: chunked"</summary>
			<description>My original problem is the fact, that in a Jetty based proxy the consumer sets the header "Transfer-Encoding: chunked" to the backend request for a GET request without body. This is not necessary, since there is no body, but the http component puts that null body into a InputStreamCache/HttpInputOverHTTP. This happens, because there is no content-length header set (which means it&amp;amp;apos;s "-1"):
see https://github.com/apache/camel/blob/master/components/camel-http-common/src/main/java/org/apache/camel/http/common/DefaultHttpBinding.java#L564
The only workaround I found, is to set "eagerCheckContentAvailable=true". Unfortunately the JettyHttpEndpoint9 does not transfer this setting to the http binding and therefor my problem can&amp;amp;apos;t be fixed. (Ok, I found another workaround, but it&amp;amp;apos;s really ugly.)
I found that problem using camel-2.17. In the current master branch, there is an open TODO to transfer this option:
https://github.com/apache/camel/blame/master/components/camel-jetty9/src/main/java/org/apache/camel/component/jetty9/JettyHttpEndpoint9.java#L52
For me this fixed the problem in my "test".
I didn&amp;amp;apos;t manage to build a good test, since that header is set deeply inside "org.eclipse.jetty.client.HttpConnection.normalizeRequest(Request)", but it&amp;amp;apos;s easy to reproduce it, by running a simple proxy and enable DEBUG log for "org.eclipse.jetty.client.HttpSender":
Inside the log a http header like will be logged:

Accept-Encoding: gzip
User-Agent: Jetty/9.2.15.v20160210
sendDirect: true
Host: 127.0.0.1
Transfer-Encoding: chunked


This is the test I used to reproduce and debug that problen


public class JettyEndpointsChuckedFalseTest extends BaseJettyTest {
    
    @Test
    public void runningTest() throws Exception {
        Exchange exchange = template.request("http://localhost:{{port}}/test", new Processor() {
            @Override
            public void process(Exchange exchange) throws Exception {
            	exchange.getIn().getBody();
            }
        });
        assertNotNull(exchange);
    }
    
    @Override
    protected RouteBuilder createRouteBuilder() throws Exception {
        return new RouteBuilder() {
            @Override
            public void configure() throws Exception {

            	from("jetty:http://localhost:{{port}}/test?matchOnUriPrefix=true&amp;amp;chunked=false&amp;amp;disableStreamCache=true"
            			+ "&amp;amp;eagerCheckContentAvailable=true")
	            	.to("log:request-debug?showHeaders=true&amp;amp;showBody=false&amp;amp;level=INFO")
	            	.to("jetty:http://localhost:{{port2}}/test?bridgeEndpoint=true&amp;amp;chunked=false");
            	
                from("jetty:http://localhost:{{port2}}/test")
                	.to("mock:dead.end");
            }
        };
    }
}

</description>
			<version>2.17.3</version>
			<fixedVersion>2.17.4, 2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty9.JettyHttpEndpoint9.java</file>
		</fixedFiles>
	</bug>
	<bug id="9606" opendate="2016-02-16 12:04:36" fixdate="2016-10-19 07:56:27" resolution="Fixed">
		<buginformation>
			<summary>SJMS Consumer-Producer in transaciton</summary>
			<description>I&amp;amp;apos;m not 100% sure this is a bug but it feels that way from conversation I had via mailing lists.
I&amp;amp;apos;m trying to ensure transactional processing between SJMS consumer and producer (e.g. using same JMS session). 
In other words this simple case:
1. prepare higher amount of JMS messages in broker (e.g. ActiveMQ with 1000 messages) 
2. use Camel route from input queue to output queue using trasacted=true 
3. start context (starts consuming messages) and in any time kill java process 
When I kill process, I would expect that sum of messages in input and output queue will be 1000 - so the transaction works. But what happens is that I always end up with 1001+ messages. Maybe it is misconfiguration of routes or misunderstanding how SJMS can work.
I feel this is critical because JMS is generally used because it its transactional capabilities.
Here is the sample code I used for reproduction (using ActiveMQ):


public class SjmsTransaction {

    public static void main(String[] args) throws Exception {
        RouteBuilder rb = new RouteBuilder() {
            @Override
            public void configure() throws Exception {
                onException(Exception.class)
                        .process(systemOut("Exception!!"));

                from("sjms:queue:test-in?transacted=true&amp;amp;consumerCount=5")
                        .process(systemOut("Processing"))
                        .to("sjms:queue:test-out?transacted=true")
                        .process(systemOut("Processed"));
            }
        };

        CamelContext context = new DefaultCamelContext();
        addJmsComponent(context);
        context.addRoutes(rb);

        System.out.println("=====&amp;gt; Starting context");
        context.start();
        // Now the context will run and consume messages, when I kill application by force in any time
        // I expect this to be true: &amp;lt;#messagesInInputAtBeginning&amp;gt; == &amp;lt;#messagesInInputNow&amp;gt; + &amp;lt;#messagesInOutputNow&amp;gt;
        // What happens is that there is always &amp;lt; (e.g. I submitted 1000 messages, out has 500, in has 501)
    }

    private static void addJmsComponent(CamelContext context) {
        ConnectionFactory factory = new ActiveMQConnectionFactory("tcp://localhost:61616");
        ConnectionFactoryResource connResource = new ConnectionFactoryResource(5, factory);
        SjmsComponent comp = new SjmsComponent();
        comp.setConnectionResource(connResource);
        context.addComponent("sjms", comp);
    }

    private static Processor systemOut(final String message) {
        return new Processor() {
            @Override
            public void process(Exchange exchange) throws Exception {
                System.out.println(exchange.getExchangeId() + ": " + message);
            }
        };
    }
}


Note that I tried to use it with various combinations of acknowledgeMode and In/InOut exchange pattern - but without luck.
I&amp;amp;apos;m not that much oriented in Camel source code but I found that JMS session is held within the exchange so probably when producer finds in an exchange existing JMS session and is configured to be transacted, then maybe it can participate this session? Or maybe there are other hooks (like Synchronization objects) in some registry that take care of this issue?
Here is the link to the previous mailing list conversation: http://camel.465427.n5.nabble.com/SJMS-transaction-td5777522.html</description>
			<version>2.15.4</version>
			<fixedVersion>2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.sjms.consumer.AbstractMessageHandler.java</file>
			<file type="M">org.apache.camel.component.sjms.SjmsProducer.java</file>
			<file type="M">org.apache.camel.component.sjms.SjmsConstants.java</file>
			<file type="M">org.apache.camel.component.sjms.producer.InOutProducer.java</file>
			<file type="M">org.apache.camel.component.sjms.SjmsConsumer.java</file>
			<file type="M">org.apache.camel.component.sjms.SjmsEndpoint.java</file>
			<file type="M">org.apache.camel.component.sjms.producer.InOnlyProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="10411" opendate="2016-10-24 15:30:20" fixdate="2016-10-25 06:49:45" resolution="Fixed">
		<buginformation>
			<summary>Camel-Blueprint - failed container gets restarted automatically</summary>
			<description>In case of a wrong endpoint definition, a CamelContext could be automatically restarted even if the start operation was correctly aborted.
This happens because during BlueprintCamelContext, the CamelContext instance is registered as a ServiceListener
https://github.com/apache/camel/blob/master/components/camel-blueprint/src/main/java/org/apache/camel/blueprint/BlueprintCamelContext.java#L102
Due to that reason, even after a stop() call is invoked by the error execution branch of start(), that instance is receptive to external service events that result in the invocation of this method:
https://github.com/apache/camel/blob/master/components/camel-blueprint/src/main/java/org/apache/camel/blueprint/BlueprintCamelContext.java#L155
That method has the freedom to start again the CamelContext instance.
The proposed solution is to use a BlueprintCamelContext local flag to keep track of the successful initialization of the Context, to be able to ignore events in case activation wasn&amp;amp;apos;t successful.
Note that the BlueprintCamelContext instance, un-registers itself as a service listener, only in its destroy() method.
Attached to JBoss-Fuse linked case, there is a reproducer that shows the issue.</description>
			<version>2.18.0</version>
			<fixedVersion>2.17.4, 2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.blueprint.BlueprintCamelContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="10341" opendate="2016-09-23 11:12:11" fixdate="2016-10-26 14:34:42" resolution="Fixed">
		<buginformation>
			<summary>When using SSL, a NettyConsumer set to Client Mode does not initiate a handshake</summary>
			<description>When used as a Consumer Netty can be put into clientMode, which will cause it to act as a client rather than a server.  However when SSL is enabled on the endpoint the SSL Handshake does not occur.
DefaultServerInitializerFactory creates a new SslHandler on-demand during channel initialisation, but forces the SSLEngine to not use client mode, regardless of the setting in the NettyConfiguration instance.
To cause handshakes to happen when in client mode, set the section in DefaultServerInitializerFactory.configureServerSSLOnDemand() to:


SSLEngine engine = sslContext.createSSLEngine();
engine.setUseClientMode(consumer.getConfiguration().isClientMode());
engine.setNeedClientAuth(consumer.getConfiguration().isNeedClientAuth());


For reference see StackOverflow.</description>
			<version>2.17.1</version>
			<fixedVersion>2.17.4, 2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.DefaultServerInitializerFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="10399" opendate="2016-10-19 09:58:53" fixdate="2016-10-27 06:26:21" resolution="Fixed">
		<buginformation>
			<summary>OutOfMemoryError: Java heap space when sending large file to endpoint</summary>
			<description>My route and jetty configuration:
&amp;lt;route id="ds-rest-archive-upload-processor"&amp;gt;
            &amp;lt;from uri="jetty:https://storage:8443/data/archive?sslContextParametersRef=sslContextParameters&amp;amp;amp;requestBufferSize=32768&amp;amp;amp;responseBufferSize=32768&amp;amp;amp;httpMethodRestrict=POST" /&amp;gt;
            &amp;lt;to uri="bean:uploadFromArchiveFileProcessor?method=process" pattern="InOut" /&amp;gt;
&amp;lt;/route&amp;gt;
&amp;lt;bean id="jetty" class="org.apache.camel.component.jetty9.JettyHttpComponent9"&amp;gt;
        &amp;lt;property name="endpointClass" value="org.apache.camel.component.jetty9.JettyHttpEndpoint9" /&amp;gt;
        &amp;lt;property name="sslContextParameters" ref="sslContextParameters" /&amp;gt;
        &amp;lt;property name="useContinuation" value="true" /&amp;gt;
        &amp;lt;property name="requestBufferSize" value="32768" /&amp;gt;
        &amp;lt;property name="responseBufferSize" value="32768" /&amp;gt;
        &amp;lt;property name="threadPool"&amp;gt;
            &amp;lt;bean class="org.eclipse.jetty.util.thread.QueuedThreadPool"&amp;gt;
                &amp;lt;constructor-arg index="0" value="1000" /&amp;gt;
            &amp;lt;/bean&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property name="jettyHttpBinding"&amp;gt;
            &amp;lt;bean class="org.apache.camel.component.jetty.DefaultJettyHttpBinding"&amp;gt;
                &amp;lt;property name="transferException" value="false" /&amp;gt;
            &amp;lt;/bean&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
When I send file to this endpoint I have out of memory with this stacktrace:
 java.lang.OutOfMemoryError: Java heap space
      at java.lang.StringCoding.decode(StringCoding.java:215)
      at java.lang.String.&amp;lt;init&amp;gt;(String.java:463)
      at java.lang.String.&amp;lt;init&amp;gt;(String.java:515)
      at org.eclipse.jetty.servlets.MultiPartFilter$Wrapper.getParameterBytesAsString(MultiPartFilter.java:390)
      at org.eclipse.jetty.servlets.MultiPartFilter$Wrapper.getParameterValues(MultiPartFilter.java:337)
      at org.apache.camel.http.common.DefaultHttpBinding.populateRequestParameters(DefaultHttpBinding.java:219)
      at org.apache.camel.http.common.DefaultHttpBinding.readHeaders(DefaultHttpBinding.java:174)
      at org.apache.camel.http.common.DefaultHttpBinding.readRequest(DefaultHttpBinding.java:110)
      at org.apache.camel.http.common.HttpMessage.&amp;lt;init&amp;gt;(HttpMessage.java:52)
      at org.apache.camel.component.jetty.CamelContinuationServlet.doService(CamelContinuationServlet.java:161)
      at org.apache.camel.http.common.CamelServlet.service(CamelServlet.java:74)
      at javax.servlet.http.HttpServlet.service(HttpServlet.java:790)
      at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:812)
      at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1669)
      at org.eclipse.jetty.servlets.MultiPartFilter.doFilter(MultiPartFilter.java:200)
      at org.apache.camel.component.jetty.CamelFilterWrapper.doFilter(CamelFilterWrapper.java:43)
      at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1652)
      at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:585)
      at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1127)
      at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:515)
      at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1061)
      at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:141)
      at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:97)
      at org.eclipse.jetty.server.Server.handle(Server.java:499)
      at org.eclipse.jetty.server.HttpChannel.handle(HttpChannel.java:311)
      at org.eclipse.jetty.server.HttpConnection.onFillable(HttpConnection.java:257)
      at org.eclipse.jetty.io.AbstractConnection$2.run(AbstractConnection.java:544)
      at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:635)
      at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:555)
      at java.lang.Thread.run(Thread.java:745)</description>
			<version>2.17.3</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.jetty9.AttachmentHttpBinding.java</file>
			<file type="M">org.apache.camel.component.jetty.MultiPartFormTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="10414" opendate="2016-10-25 11:11:43" fixdate="2016-10-28 08:13:13" resolution="Fixed">
		<buginformation>
			<summary>Query is ignore if field filter header is set</summary>
			<description>If the field filter header (CamelMongoDbFieldsFilter) is set the query is ignored.
As can be seen here:
https://github.com/apache/camel/blob/camel-2.18.x/components/camel-mongodb/src/main/java/org/apache/camel/component/mongodb/MongoDbProducer.java#L314-L320</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mongodb.MongoDbFindOperationTest.java</file>
			<file type="M">org.apache.camel.component.mongodb.MongoDbProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="10384" opendate="2016-10-12 15:57:50" fixdate="2016-10-29 20:06:09" resolution="Fixed">
		<buginformation>
			<summary>Shutdown broken when using Spring Boot</summary>
			<description>Camel doesn&amp;amp;apos;t shutdown properly in a Spring Boot environment. Calling the /shutdown endpoint causes Camel to hang-up after stopping the CamelContext. The reason for this is the count-down latch in the CamelSpringBootApplicationController. The overriden Main class modifies the latch in the Main class itself, not the one in CamelSpringBootApplicationController. As a result, the latch in CamelSpringBootApplicationController is waiting forever preventing a proper shutdown.
CamelSpringBootApplicationController .java

    public CamelSpringBootApplicationController(final ApplicationContext applicationContext, final CamelContext camelContext) {
        this.main = new Main() {
             
            ...

            @Override
            protected void doStop() throws Exception {
                LOG.debug("Controller is shutting down CamelContext");
                try {
                    super.doStop();
                } finally {
                    // Should be CamelSpringBootApplicationController.this.latch.countDown();
                    latch.countDown();
                }
            }
        };
    }

</description>
			<version>2.17.3</version>
			<fixedVersion>2.17.4, 2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.spring.boot.CamelSpringBootApplicationController.java</file>
		</fixedFiles>
	</bug>
	<bug id="10425" opendate="2016-10-30 08:20:26" fixdate="2016-10-30 17:05:34" resolution="Fixed">
		<buginformation>
			<summary>java.io.IOException: Stream closed - When setting result from bean in route</summary>
			<description>Related to CAMEL-10424 which can cause an exception


org.apache.camel.RuntimeCamelException: java.io.IOException: Stream closed
	at org.apache.camel.http.common.HttpMessage.createBody(HttpMessage.java:74)
	at org.apache.camel.impl.MessageSupport.getBody(MessageSupport.java:47)
	at org.apache.camel.processor.CamelInternalProcessor$StreamCachingAdvice.after(CamelInternalProcessor.java:799)
	at org.apache.camel.processor.CamelInternalProcessor$StreamCachingAdvice.after(CamelInternalProcessor.java:767)
	at org.apache.camel.processor.CamelInternalProcessor$InternalCallback.done(CamelInternalProcessor.java:246)
	at org.apache.camel.processor.RedeliveryErrorHandler.deliverToFailureProcessor(RedeliveryErrorHandler.java:1069)
	at org.apache.camel.processor.RedeliveryErrorHandler.process(RedeliveryErrorHandler.java:468)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:197)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:120)
	at org.apache.camel.processor.Pipeline.process(Pipeline.java:83)
	at org.apache.camel.processor.CamelInternalProcessor.process(CamelInternalProcessor.java:197)
	at org.apache.camel.processor.DelegateAsyncProcessor.process(DelegateAsyncProcessor.java:97)
	at org.apache.camel.http.common.CamelServlet.doService(CamelServlet.java:195)
	at org.apache.camel.http.common.CamelServlet.service(CamelServlet.java:74)


such as from:
https://builds.apache.org/job/Camel.trunk.fulltest.java8/org.apache.camel$camel-example-spring-boot-rest-jpa/1002/testReport/junit/org.apache.camel.example.spring.boot.rest.jpa/ApplicationTest/newOrderTest/
</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.TransformProcessor.java</file>
			<file type="M">org.apache.camel.processor.SetBodyProcessor.java</file>
			<file type="M">org.apache.camel.component.bean.MethodInfo.java</file>
			<file type="M">org.apache.camel.processor.SortProcessor.java</file>
			<file type="M">org.apache.camel.Message.java</file>
			<file type="M">org.apache.camel.processor.ConvertBodyProcessor.java</file>
			<file type="M">org.apache.camel.impl.MessageSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="10430" opendate="2016-11-01 11:22:50" fixdate="2016-11-01 11:25:46" resolution="Fixed">
		<buginformation>
			<summary>camel-hystrix - Should also execute fallback if exception not from Camel</summary>
			<description>See nabble
http://camel.465427.n5.nabble.com/Hystrix-Fallback-not-executed-on-Thread-Pool-Semaphore-rejection-tp5789521.html</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.hystrix.processor.HystrixProcessorCommand.java</file>
		</fixedFiles>
	</bug>
	<bug id="10427" opendate="2016-11-01 02:13:15" fixdate="2016-11-01 11:41:33" resolution="Fixed">
		<buginformation>
			<summary>CXFRS client gets "Response timeout" exception when used with Camel transport</summary>
			<description>When a CXFRS client is used with Camel transport:


  &amp;lt;cxf:rsClient id="rsClient" address="camel://direct:cxf.in" ...&amp;gt;


it throws the following exception waiting for a response from the target REST server:


javax.ws.rs.ProcessingException: Response timeout
    at org.apache.cxf.jaxrs.client.AbstractClient.waitForResponseCode(AbstractClient.java:617)
    at org.apache.cxf.jaxrs.client.AbstractClient.checkClientException(AbstractClient.java:598)
    at org.apache.cxf.jaxrs.client.AbstractClient.preProcessResult(AbstractClient.java:580)
    at org.apache.cxf.jaxrs.client.WebClient.doResponse(WebClient.java:1098)
    at org.apache.cxf.jaxrs.client.WebClient.doChainedInvocation(WebClient.java:1035)
    at org.apache.cxf.jaxrs.client.WebClient.doInvoke(WebClient.java:892)
    at org.apache.cxf.jaxrs.client.WebClient.doInvoke(WebClient.java:863)
    at org.apache.cxf.jaxrs.client.WebClient.invoke(WebClient.java:329)
    at org.apache.camel.component.cxf.jaxrs.CxfRsProducer.invokeHttpClient(CxfRsProducer.java:210)
    at org.apache.camel.component.cxf.jaxrs.CxfRsProducer.process(CxfRsProducer.java:89)
    [...]


unless you explicitly remap the following header:


    &amp;lt;setHeader headerName="org.apache.cxf.message.Message.RESPONSE_CODE"&amp;gt;
        &amp;lt;simple&amp;gt;${headers.CamelHttpResponseCode}&amp;lt;/simple&amp;gt;
    &amp;lt;/setHeader&amp;gt;

</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.common.header.CxfHeaderHelperTest.java</file>
			<file type="M">org.apache.camel.component.cxf.common.header.CxfHeaderHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="10431" opendate="2016-11-01 15:36:15" fixdate="2016-11-01 16:11:19" resolution="Fixed">
		<buginformation>
			<summary>camel-elsql - Does not read named parameter from header properties</summary>
			<description>Camel-elsql could not lookup for parameters from message headers. Problem is here https://github.com/apache/camel/blob/camel-2.18.0/components/camel-elsql/src/main/java/org/apache/camel/component/elsql/ElsqlSqlMapSource.java#L70
Sample route:


from("direct:projects")
  .setHeader("lic", constant("ASF"))
  .setHeader("min", constant(123))
  .to("elsql:projects:com/foo/projects.elsql")


ElSql:


@NAME(projects)
  SELECT *
  FROM projects
  WHERE license = :lic AND id &amp;gt; :min
  ORDER BY id

</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.elsql.ElsqlSqlMapSource.java</file>
			<file type="M">org.apache.camel.component.elsql.ElSqlProducerBodySimpleTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="10394" opendate="2016-10-17 16:46:56" fixdate="2016-11-04 15:16:11" resolution="Fixed">
		<buginformation>
			<summary>BlueprintCamelContext cannot find components created in RouteBuilder.configure method</summary>
			<description>When a simple java RouteBuilder that creates a component and adds it to the context in the configure method is used in a blueprint, the context cannot find the component.
Example Builder:
public class TimerRouteBuilder extends RouteBuilder {
    @Override
    public void configure() throws Exception 
{
        TimerComponent timerComponent = new TimerComponent();

        getContext().addComponent("my-timer", timerComponent);

        from( "my-timer://test-timer")
                .log("Timer Fired")
                .to("mock://result");
    }
}
Example Blueprint:
&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="
http://www.osgi.org/xmlns/blueprint/v1.0.0 https://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
http://camel.apache.org/schema/blueprint http://camel.apache.org/schema/blueprint/camel-blueprint.xsd"&amp;gt;
    &amp;lt;bean id="timer-route-builder" class="com.pronoia.camel.builder.TimerRouteBuilder"/&amp;gt;
    &amp;lt;camelContext id="blueprint-context" xmlns="http://camel.apache.org/schema/blueprint"&amp;gt;
        &amp;lt;routeBuilder ref="timer-route-builder"/&amp;gt;
    &amp;lt;/camelContext&amp;gt;
&amp;lt;/blueprint&amp;gt;
This test fails:
public class BlueprintTest extends CamelBlueprintTestSupport {
    @EndpointInject(uri = "mock://result")
    MockEndpoint result;
    @Override
    protected String getBlueprintDescriptor() 
{
        return "/OSGI-INF/blueprint/blueprint.xml";
    }

    @Test
    public void testRoute() throws Exception 
{
        result.expectedMessageCount(5);

        assertMockEndpointsSatisfied(10, TimeUnit.SECONDS);
    }

}

But this test passes
public class CamelTest extends CamelTestSupport {

    @EndpointInject(uri = "mock://result")
    MockEndpoint result;

    @Override
    protected RoutesBuilder createRouteBuilder() throws Exception {
        return new TimerRouteBuilder();
    }

    @Test
    public void testRoute() throws Exception {
        result.expectedMessageCount(5);

        assertMockEndpointsSatisfied(10, TimeUnit.SECONDS);
    }
}</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.blueprint.handler.CamelNamespaceHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="10442" opendate="2016-11-03 10:36:51" fixdate="2016-11-04 16:45:34" resolution="Fixed">
		<buginformation>
			<summary>Multicast leaks into Pipeline stages?</summary>
			<description>When defining a route with two (or more) parallel pipelines, it seems that the exchange is being broadcast to all steps (including the intermediate) of the pipelines, rather than just their heads. Whether or not this unintuitive - if not incorrect - behavior occurs when using shorthand syntaxes in the route definition (see https://gist.github.com/ecausarano/4b66294464741b9f626890b29ea0aec2)
Working route: 
.pipeline().to("A").to("B").end()
.pipeline().to("C").to("D").end()
10:41:12.644 [main] INFO route1 - after direct:start body=START
10:41:12.666 [main] DEBUG org.apache.camel.processor.SendProcessor - &amp;gt;&amp;gt;&amp;gt;&amp;gt; A Exchange[ID-Spitfire-local-50181-1477993271722-0-3]
10:41:12.667 [main] DEBUG com.esc.test.MulticastPipelinesTest - A got in=START
10:41:12.667 [main] DEBUG org.apache.camel.processor.SendProcessor - &amp;gt;&amp;gt;&amp;gt;&amp;gt; B Exchange[ID-Spitfire-local-50181-1477993271722-0-3]
10:41:12.667 [main] DEBUG com.esc.test.MulticastPipelinesTest - B got in=A
10:41:12.670 [main] DEBUG org.apache.camel.processor.SendProcessor - &amp;gt;&amp;gt;&amp;gt;&amp;gt; C Exchange[ID-Spitfire-local-50181-1477993271722-0-4]
10:41:12.671 [main] DEBUG com.esc.test.MulticastPipelinesTest - C got in=START
10:41:12.671 [main] DEBUG org.apache.camel.processor.SendProcessor - &amp;gt;&amp;gt;&amp;gt;&amp;gt; D Exchange[ID-Spitfire-local-50181-1477993271722-0-4]
10:41:12.671 [main] DEBUG com.esc.test.MulticastPipelinesTest - D got in=C
Faulty routes:
.pipeline("A", "B")
.pipeline("C", "D)
or					
.to("A", "B")
.to("C", "D")
10:43:46.383 [main] INFO route1 - after direct:start body=START
10:43:46.389 [main] DEBUG org.apache.camel.processor.SendProcessor - &amp;gt;&amp;gt;&amp;gt;&amp;gt; A Exchange[ID-Spitfire-local-50316-1477993425625-0-3]
10:43:46.389 [main] DEBUG com.esc.test.MulticastPipelinesTest - A got in=START
10:43:46.390 [main] DEBUG org.apache.camel.processor.SendProcessor - &amp;gt;&amp;gt;&amp;gt;&amp;gt; B Exchange[ID-Spitfire-local-50316-1477993425625-0-4]
10:43:46.390 [main] DEBUG com.esc.test.MulticastPipelinesTest - B got in=START
10:43:46.391 [main] DEBUG org.apache.camel.processor.SendProcessor - &amp;gt;&amp;gt;&amp;gt;&amp;gt; C Exchange[ID-Spitfire-local-50316-1477993425625-0-5]
10:43:46.391 [main] DEBUG com.esc.test.MulticastPipelinesTest - C got in=START
10:43:46.391 [main] DEBUG org.apache.camel.processor.SendProcessor - &amp;gt;&amp;gt;&amp;gt;&amp;gt; D Exchange[ID-Spitfire-local-50316-1477993425625-0-6]
10:43:46.391 [main] DEBUG com.esc.test.MulticastPipelinesTest - D got in=START
</description>
			<version>2.18.0</version>
			<fixedVersion>2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.model.ProcessorDefinition.java</file>
			<file type="M">org.apache.camel.processor.MulticastPipelineTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="10429" opendate="2016-11-01 11:14:23" fixdate="2016-11-05 12:10:24" resolution="Fixed">
		<buginformation>
			<summary>CXFRS client requires Exchange.HTTP_URI instead of HTTP_PATH for Camel tranport</summary>
			<description>The camel-cxfrs doc writes that HTTP_PATH is required for camel-cxfrs producer when it&amp;amp;apos;s used with httpClientAPI option.

The CXF JAXRS front end also provides a http centric client API. You can also invoke this API from camel-cxfrs producer. You need to specify the HTTP_PATH and the HTTP_METHOD and let the producer use the http centric client API by using the URI option httpClientAPI or by setting the message header CxfConstants.CAMEL_CXF_RS_USING_HTTP_API.
However, when Camel transport is used between CXFRS producer and consumer, the invocation succeeds only if it sets HTTP_URI, not HTTP_PATH, to the header.


                from("direct:input.camel")
                    .setHeader(Exchange.HTTP_METHOD, constant("GET"))
                    .setHeader(Exchange.CONTENT_TYPE, constant("text/plain"))
                    .setHeader(Exchange.HTTP_URI, simple("/greeting/hello/${body}"))
                    //.setHeader(Exchange.HTTP_PATH, simple("/greeting/hello/${body}")) // &amp;lt;- fails
                    .inOut("cxfrs:bean:rsClient");


Otherwise it fails with 404 error.</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.camel.component.cxf.util.CxfMessageHelperTest.java</file>
			<file type="M">org.apache.camel.component.cxf.transport.CamelOutputStream.java</file>
			<file type="M">org.apache.camel.component.cxf.common.header.CxfHeaderHelperTest.java</file>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.jaxrs.DefaultCxfRsBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.common.header.CxfHeaderHelper.java</file>
			<file type="M">org.apache.camel.component.cxf.transport.CamelDestination.java</file>
			<file type="M">org.apache.camel.component.cxf.util.CxfUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">10446</link>
		</links>
	</bug>
	<bug id="10443" opendate="2016-11-03 12:24:55" fixdate="2016-11-07 09:48:42" resolution="Fixed">
		<buginformation>
			<summary>findById does not work with ObjectId</summary>
			<description>When using Camel MongoDB component with "operation=findById" and [_id] field is happened to be a standard ObjectId(), it doesn&amp;amp;apos;t work anymore in v.2.18 (worked 2.17.3 and before). 
Basically, to test you&amp;amp;apos;d need to send org.bson.types.ObjectId in the message body but it never finds a document. 
The problem lies in MongoDbProducer.createDoFindById(). 
Can be fixed by replacing line: 
                String id = exchange1.getIn().getMandatoryBody(String.class); 
with 
                Object id = exchange1.getIn().getMandatoryBody(); </description>
			<version>2.18.0</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.mongodb.MongoDbFindOperationTest.java</file>
			<file type="M">org.apache.camel.component.mongodb.MongoDbProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="10449" opendate="2016-11-07 14:28:40" fixdate="2016-11-07 19:25:26" resolution="Fixed">
		<buginformation>
			<summary>Set CXF SoapAction header correctly</summary>
			<description>As of CXF-6732, CXF will by default always set the SoapAction header with the value found at key SoapBindingConstants.SOAP_ACTION. See comment for more details. Workaround can be either adding a custom CXF OutInterceptor or use a different Camel/CXF binding.</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBinding.java</file>
			<file type="M">org.apache.camel.component.cxf.DefaultCxfBindingTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="10460" opendate="2016-11-09 16:36:28" fixdate="2016-11-10 09:33:33" resolution="Fixed">
		<buginformation>
			<summary>MetricsMessageHistoryFactory.java:138 Generate a NPE</summary>
			<description>I&amp;amp;apos;m trying to play with Spring-boot camel and metrics to expose dashboard. 
Hawtio is a great tools to check what it&amp;amp;apos;s going on at runtime but no persistence is done. We would like to persist statistics in prometheus by example. 
I configure camel context with MetricsMessageHistoryFactory as: 
    MetricsMessageHistoryFactory metricsMessageHistoryFactory = new MetricsMessageHistoryFactory(); 
    metricsMessageHistoryFactory.setMetricsRegistry(metricRegistry); 
    camelContext.setMessageHistoryFactory(metricsMessageHistoryFactory); 
where metricRegistry is injected with: 
  /** 

Srping Boot metrics
   */ 
  @Autowired 
  private MetricRegistry metricRegistry; 

Everything is ok until I passed in OnExceptionRoute. It seems that the routeId is set to Null in this case and generate a NPE (line MetricsMessageHistoryFactory:138) in the exception route. Route causing the NPE:
onException(NoAttachmentToProcessException.class) 
        .routeId(RouteIds.TECHNICAL_ERROR_HANDLING.routeId()) 
        .log(LoggingLevel.ERROR,"TECHNICAL ERROR: $
{exchangeProperty.CamelExceptionCaught}
") </description>
			<version>2.18.0</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.processor.CamelInternalProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="10480" opendate="2016-11-15 08:40:18" fixdate="2016-11-15 09:17:57" resolution="Fixed">
		<buginformation>
			<summary>MemoryLeak in the DatagramPacketObjectEncoder</summary>
			<description>Just found a memory leak in the camel-netty4 UDP encoding when working on CAMEL-10409. 


Failed tests:
  NettyUDPAsyncTest&amp;gt;BaseNettyTest.verifyNoLeaks:89 Leaks detected while running tests: [org.apache.logging.log4j.core.impl.MutableLogEvent@7c96c85]
  NettyUDPMessageLargerThanDefaultBufferSizeTest&amp;gt;BaseNettyTest.verifyNoLeaks:89 Leaks detected while running tests: [org.apache.logging.log4j.core.impl.MutableLogEvent@73bb1337]
  NettyUDPObjectSyncTest&amp;gt;BaseNettyTest.verifyNoLeaks:89 Leaks detected while running tests: [org.apache.logging.log4j.core.impl.MutableLogEvent@5eed6dfb, org.apache.logging.log4j.core.impl.MutableLogEvent@7c96c85, org.apache.logging.log4j.core.impl.MutableLogEvent@7c96c85]
  NettyUDPSyncTest&amp;gt;BaseNettyTest.verifyNoLeaks:89 Leaks detected while running tests: [org.apache.logging.log4j.core.impl.MutableLogEvent@7c96c85, org.apache.logging.log4j.core.impl.MutableLogEvent@7c96c85]

</description>
			<version>2.17.3</version>
			<fixedVersion>2.17.4, 2.18.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.codec.DatagramPacketObjectEncoder.java</file>
		</fixedFiles>
	</bug>
	<bug id="10409" opendate="2016-10-22 14:24:13" fixdate="2016-11-15 09:19:57" resolution="Fixed">
		<buginformation>
			<summary>Double release of netty buffer</summary>
			<description>It looks like CAMEL-9040 fix introduced a double release of a netty buffer
 that leads to IllegalReferenceCountException under load:


2016-10-22 10:20:15.442  WARN 6853 --- [ClientTCPWorker] io.netty.util.ReferenceCountUtil         : Failed to release a message: AdvancedLeakAwareByteBuf(PooledUnsafeDirectByteBuf(freed))

io.netty.util.IllegalReferenceCountException: refCnt: 0, decrement: 1
	at io.netty.buffer.AbstractReferenceCountedByteBuf.release(AbstractReferenceCountedByteBuf.java:111) ~[netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.buffer.WrappedByteBuf.release(WrappedByteBuf.java:1029) ~[netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.buffer.AdvancedLeakAwareByteBuf.release(AdvancedLeakAwareByteBuf.java:951) ~[netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.util.ReferenceCountUtil.release(ReferenceCountUtil.java:84) ~[netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.util.ReferenceCountUtil.safeRelease(ReferenceCountUtil.java:109) ~[netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.ChannelOutboundBuffer.remove0(ChannelOutboundBuffer.java:296) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.ChannelOutboundBuffer.failFlushed(ChannelOutboundBuffer.java:621) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.AbstractChannel$AbstractUnsafe.flush0(AbstractChannel.java:869) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.flush0(AbstractNioChannel.java:362) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.AbstractChannel$AbstractUnsafe.flush(AbstractChannel.java:823) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.DefaultChannelPipeline$HeadContext.flush(DefaultChannelPipeline.java:1296) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:786) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush(AbstractChannelHandlerContext.java:778) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.AbstractChannelHandlerContext.flush(AbstractChannelHandlerContext.java:759) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.flush(CombinedChannelDuplexHandler.java:530) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.ChannelOutboundHandlerAdapter.flush(ChannelOutboundHandlerAdapter.java:115) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.CombinedChannelDuplexHandler.flush(CombinedChannelDuplexHandler.java:355) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeFlush0(AbstractChannelHandlerContext.java:786) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeWriteAndFlush(AbstractChannelHandlerContext.java:812) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.AbstractChannelHandlerContext.write(AbstractChannelHandlerContext.java:824) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(AbstractChannelHandlerContext.java:804) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.AbstractChannelHandlerContext.writeAndFlush(AbstractChannelHandlerContext.java:841) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.DefaultChannelPipeline.writeAndFlush(DefaultChannelPipeline.java:1032) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.AbstractChannel.writeAndFlush(AbstractChannel.java:296) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at org.apache.camel.component.netty4.NettyHelper.writeBodyAsync(NettyHelper.java:105) [camel-netty4-2.18.0.jar:2.18.0]
	at org.apache.camel.component.netty4.NettyProducer.processWithConnectedChannel(NettyProducer.java:306) [camel-netty4-2.18.0.jar:2.18.0]
	at org.apache.camel.component.netty4.NettyProducer$ChannelConnectedListener.operationComplete(NettyProducer.java:642) [camel-netty4-2.18.0.jar:2.18.0]
	at org.apache.camel.component.netty4.NettyProducer$ChannelConnectedListener.operationComplete(NettyProducer.java:619) [camel-netty4-2.18.0.jar:2.18.0]
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:514) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:507) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:486) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:427) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:111) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.DefaultChannelPromise.trySuccess(DefaultChannelPromise.java:82) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:306) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:341) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:627) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:551) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:465) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:437) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873) [netty-all-4.1.5.Final.jar:4.1.5.Final]
	at java.lang.Thread.run(Thread.java:745) [na:1.8.0_101]



The buffer is release at


	at org.apache.camel.component.netty4.http.NettyHttpProducer$1.onDone(NettyHttpProducer.java:85)
	at org.apache.camel.support.SynchronizationAdapter.onComplete(SynchronizationAdapter.java:35)
	at org.apache.camel.util.UnitOfWorkHelper.doneSynchronizations(UnitOfWorkHelper.java:104)
	at org.apache.camel.impl.DefaultUnitOfWork.done(DefaultUnitOfWork.java:230)
	at org.apache.camel.util.UnitOfWorkHelper.doneUow(UnitOfWorkHelper.java:65)
	at org.apache.camel.impl.DefaultConsumer.doneUoW(DefaultConsumer.java:107)
	at org.apache.camel.component.netty4.handlers.ServerChannelHandler$1.done(ServerChannelHandler.java:149)
	at org.apache.camel.processor.CamelInternalProcessor$InternalCallback.done(CamelInternalProcessor.java:257)
	at org.apache.camel.processor.Pipeline$1.done(Pipeline.java:147)
	at org.apache.camel.processor.CamelInternalProcessor$InternalCallback.done(CamelInternalProcessor.java:257)
	at org.apache.camel.processor.RedeliveryErrorHandler$2.done(RedeliveryErrorHandler.java:554)
	at org.apache.camel.management.InstrumentationProcessor$1.done(InstrumentationProcessor.java:86)
	at org.apache.camel.processor.SendProcessor$1.done(SendProcessor.java:155)
	at org.apache.camel.component.netty4.http.NettyHttpProducer$NettyHttpProducerCallback.done(NettyHttpProducer.java:149)
	at org.apache.camel.component.netty4.NettyProducer$NettyProducerCallback.done(NettyProducer.java:548)
	at org.apache.camel.component.netty4.handlers.ClientChannelHandler.channelRead0(ClientChannelHandler.java:205)
	at io.netty.channel.SimpleChannelInboundHandler.channelRead(SimpleChannelInboundHandler.java:105)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:372)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:358)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:350)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:102)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:372)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:358)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:350)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:435)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:293)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:267)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:250)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:372)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:358)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:350)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:372)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:358)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:129)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:610)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:551)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:465)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:437)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873)
	at java.lang.Thread.run(Thread.java:745)


and 



	at org.apache.camel.component.netty4.NettyHelper.writeBodyAsync(NettyHelper.java:105)
	at org.apache.camel.component.netty4.NettyProducer.processWithConnectedChannel(NettyProducer.java:306)
	at org.apache.camel.component.netty4.NettyProducer$ChannelConnectedListener.operationComplete(NettyProducer.java:642)
	at org.apache.camel.component.netty4.NettyProducer$ChannelConnectedListener.operationComplete(NettyProducer.java:619)
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:514)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:507)
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:486)
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:427)
	at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:111)
	at io.netty.channel.DefaultChannelPromise.trySuccess(DefaultChannelPromise.java:82)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.fulfillConnectPromise(AbstractNioChannel.java:306)
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe.finishConnect(AbstractNioChannel.java:341)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:627)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:551)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:465)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:437)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:873)
	at java.lang.Thread.run(Thread.java:745)


Note that refCnt check do not work if buffer is being used by another thread, it&amp;amp;apos;s just hiding a problem if it works. I will try to look into it deeper, but I am not sure if I fully understand the buffer allocation / freeing lifecycle in netty yet 
My test routes are:


        from("timer:load?period=100")
                .to("log:client?groupInterval=5000")
                .to("netty4-http:http://127.0.0.1:8081/main-service");
        from("netty4-http:http://0.0.0.0:8081/main-service")
                .to("log:main-service?groupInterval=5000")
                .to("netty4-http:http://127.0.0.1:8082/childService1")
                .to("netty4-http:http://127.0.0.1:8083/childService2");
        from("netty4-http:http://0.0.0.0:8082/childService1")
                .to("log:childService1?groupInterval=5000")
                .delayer(100);
        from("netty4-http:http://0.0.0.0:8083/childService2")
                .to("log:childService2?groupInterval=5000")
                .delayer(100);

</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.netty4.http.BaseNettyTest.java</file>
			<file type="M">org.apache.camel.component.netty4.BaseNettyTest.java</file>
			<file type="M">org.apache.camel.component.netty4.NettyProducer.java</file>
			<file type="M">org.apache.camel.component.netty4.http.NettyHttpProducer.java</file>
		</fixedFiles>
	</bug>
	<bug id="10453" opendate="2016-11-08 14:39:30" fixdate="2016-11-16 09:45:16" resolution="Fixed">
		<buginformation>
			<summary>camel-elsql does not set CamelSqlUpdateCount header on update operation</summary>
			<description>Camel ElSql should store number of rows updated for update operation into CamelSqlUpdateCount header.
Route:


&amp;lt;route&amp;gt;
  &amp;lt;from uri="direct:updateLicense"/&amp;gt;
  &amp;lt;to uri="elsql:updateLicense"/&amp;gt;
  &amp;lt;to uri="mock:updateLicense"/&amp;gt;
&amp;lt;/route&amp;gt;


ElSQL


@NAME(updateLicense)
    UPDATE projects
    SET license = :lic
    WHERE id = :id

</description>
			<version>2.18.0</version>
			<fixedVersion>2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.component.elsql.ElsqlProducer.java</file>
			<file type="M">org.apache.camel.component.elsql.ElSqlProducerBodySimpleTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="10476" opendate="2016-11-14 16:09:36" fixdate="2016-11-18 17:09:14" resolution="Fixed">
		<buginformation>
			<summary>configAdminFile not used to populate property placeholders in camel-test-blueprint when run via camel-maven-plugin</summary>
			<description>Problem: When running with a Camel Blueprint project a configAdminFile is not used to populate propertyplacehoders in camel-test-blueprint when exectued with camel-maven-plugin(camel:run). So a user can&amp;amp;apos;t run camel locally in a similar way to running in Karaf with file based property placeholder values. 
Workaround: I think, but haven&amp;amp;apos;t tested yet, that you can work around this locally using the methods described here: http://ggrzybek.blogspot.com/2015/12/camel-blueprint-test-support.html and/or how this solution  https://github.com/cschneider/Karaf-Tutorial/tree/master/camel/order/src appears to use exec:java locally and loads the properties via PropertiesComponent.
To reproduce the problem:
Create a new project using camel-archetype-blueprint. (You need to change the log4j config to make it run.) To reduce the time, I created a project that runs here: https://github.com/ryanco/propertyconfig. Instead of using a default in the blueprint XML for the propertyplaceholder, I setup the POM to include the following:


      &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.camel&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;camel-maven-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.18.0&amp;lt;/version&amp;gt;
        &amp;lt;configuration&amp;gt;
	      &amp;lt;useBlueprint&amp;gt;true&amp;lt;/useBlueprint
         &amp;lt;configAdminPid&amp;gt;com.yarsquidy.props.propertyconfig&amp;lt;/configAdminPid&amp;gt;
          &amp;lt;configAdminFileName&amp;gt;etc/com.yarsquidy.props.propertyconfig&amp;lt;/configAdminFileName&amp;gt;
        &amp;lt;/configuration&amp;gt;
      &amp;lt;/plugin&amp;gt;


In Camel 2.15.2 or earlier, this file would be loaded when mvn camel:run was invoked and the properties would be available via the PID at run time. After the changes made in CAMEL-9313, it appears that the method org.apache.camel.test.blueprint.CamelBlueprintHelper#setPersistentFileForConfigAdmin is only called in when the createTestBundle pathway is taken in org.apache.camel.test.blueprint.CamelBlueprintHelper#createBundleContext(java.lang.String, java.lang.String, boolean, java.lang.String, java.lang.String, java.lang.String, java.lang.String[]...). So it appears test using CamelBlueprintTestSupport get this functionality (as shown by the tests) but things executed from camel:run do not.
Here you can see in Camel 2.14 that call to org.apache.camel.test.blueprint.CamelBlueprintHelper#setPersistentFileForConfigAdmin is made after the bundelContext is created.
https://github.com/apache/camel/blob/camel-2.14.x/components/camel-test-blueprint/src/main/java/org/apache/camel/test/blueprint/Main.java#L103
In the master branch version, that call is no longer made from main after the context is returned.
https://github.com/apache/camel/blob/master/components/camel-test-blueprint/src/main/java/org/apache/camel/test/blueprint/Main.java#L106
I made a change locally to add a similar call to org.apache.camel.test.blueprint.CamelBlueprintHelper#setPersistentFileForConfigAdmin in Camel 2.18:


LOG.debug("Starting Blueprint XML file: " + descriptors);
if (configAdminPid != null &amp;amp;&amp;amp; configAdminFileName != null) {
		// pid/file is used to set INITIAL content of ConfigAdmin to be used when blueprint container is started
		LOG.info("ConfigAdminPid and ConfigAdminFileName are not null");
		bundleContext = createBundleContext(bundleName, new String[] {configAdminFileName, configAdminPid});
} else {
		bundleContext = createBundleContext(bundleName);
}
CamelBlueprintHelper.setPersistentFileForConfigAdmin(bundleContext, configAdminPid, configAdminFileName, new Properties(), null, null, false);


Here is the output of the log statement from the example before this change:

[ntext          INFO  Apache Camel 2.18.0 (CamelContext: blueprint-bean-context) started in 0.214 seconds
[ntext) thread #0 - timer://foo] timerToLog                     INFO  The message contains ${greeting} at 2016-11-14 08:42:03
[ntext) thread #0 - timer://foo] timerToLog                     INFO  The message contains ${greeting} at 2016-11-14 08:42:08


Here is the output of the log statement from the example after this change:

[         Blueprint Extender: 3] BlueprintCamelContext          INFO  Apache Camel 2.18.1-SNAPSHOT (CamelContext: blueprint-bean-context) started in 0.257 seconds
[ntext) thread #0 - timer://foo] timerToLog                     INFO  The message contains Hello From File! at 2016-11-14 08:54:09
[ntext) thread #0 - timer://foo] timerToLog                     INFO  The message contains Hello From File! at 2016-11-14 08:54:14


As you can see before the change, the $
{greeting}
 property is not poplulated via propertyplacehoder. After the change it is replaced.
Given all the discussion of timing related issues in CAMEL-9313, I&amp;amp;apos;m hesitant to say this is a good enough solution or that it aligns with the intention of the changes made in that fix. Given that configAdminFileName and configAdminPid are passed into createBundleContext, perhaps the call to org.apache.camel.test.blueprint.CamelBlueprintHelper#setPersistentFileForConfigAdmin should happen inside createBundleContext or one of it sub-methods. 
Overall, I "think" a user should be able to use the configAdminPid and configAdminFileName settings to load properties via camel:run rather than work aound it, but I could be persumptious there.</description>
			<version>2.15.3</version>
			<fixedVersion>2.16.5, 2.17.4, 2.18.1, 2.19.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.camel.test.blueprint.CamelBlueprintHelper.java</file>
			<file type="M">org.apache.camel.test.blueprint.MainTest.java</file>
			<file type="M">org.apache.camel.test.blueprint.Main.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">9313</link>
			<link type="Reference" description="relates to">9377</link>
		</links>
	</bug>
</bugrepository>