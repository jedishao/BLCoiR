<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat Dec 03 18:05:13 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-8362/HBASE-8362.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-8362] Possible MultiGet optimization</title>
                <link>https://issues.apache.org/jira/browse/HBASE-8362</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;Currently MultiGets are executed on a RegionServer in a single thread in a loop that handles each Get separately (opening a scanner, seeking, etc).&lt;br/&gt;
It seems we could optimize this (per region at least) by opening a single scanner and issue a reseek for each Get that was requested.&lt;/p&gt;

&lt;p&gt;I have not tested this yet and no patch, but I would like to solicit feedback on this idea.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12642997">HBASE-8362</key>
            <summary>Possible MultiGet optimization</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="lhofhansl">Lars Hofhansl</reporter>
                        <labels>
                    </labels>
                <created>Wed, 17 Apr 2013 18:46:05 +0000</created>
                <updated>Fri, 13 Jun 2014 16:16:28 +0000</updated>
                                                                                <due></due>
                            <votes>0</votes>
                                    <watches>13</watches>
                                                                <comments>
                            <comment id="13634311" author="nkeywal" created="Wed, 17 Apr 2013 18:54:44 +0000"  >&lt;p&gt;I expect it will be much better. My only concern I have is for sparse multigets when there are a lot of regions. We may hit some servers that we would not hit with the current approach, with the risk of going to a slow/dead server. So doing the optimization per region would solve this specific case (or doing it per region server only).&lt;/p&gt;</comment>
                            <comment id="13634369" author="lhofhansl" created="Wed, 17 Apr 2013 20:08:44 +0000"  >&lt;p&gt;I assume we&apos;d hit the same region server(s). The optimization I have in mind would only be per region.&lt;/p&gt;</comment>
                            <comment id="13634371" author="lhofhansl" created="Wed, 17 Apr 2013 20:12:15 +0000"  >&lt;p&gt;Looking at patch possibilities... A problem is that a reseek can&apos;t tell whether it placed the scanner on an existing row or not, so after each reseek we&apos;d need to do a next even when the row does not exist.&lt;/p&gt;</comment>
                            <comment id="13634518" author="varunsharma" created="Wed, 17 Apr 2013 22:20:09 +0000"  >&lt;p&gt;I also think this would be better.&lt;/p&gt;

&lt;p&gt;Apologies but I did not completely understand the reseek comment, does that mean we could seek to a row &amp;gt; the value of the seek hint ?&lt;/p&gt;

&lt;p&gt;Also, I wonder if an implementation via a filter could be possible. It might allow this technique of sorting the input and reseeking to scans (wherever it may make sense) unless we already have something for scans which does this. I think fuzzyRowFilter might be doing something similar to this (it seems to do more).&lt;/p&gt;

&lt;p&gt;I am really, looking forward to testing an implementation on a setup we have (6 region server with 0.94, no blooms, block cache @64k with multi gets of 50 rows). &lt;/p&gt;</comment>
                            <comment id="13634546" author="lhofhansl" created="Wed, 17 Apr 2013 22:42:35 +0000"  >&lt;p&gt;Doing this via a custom filter is possible. Currently, though, you cannot have different filters in different regions (i.e. all Gets would have to be passed to every filter materialized in every region); at least I do not see a way to do that.&lt;/p&gt;

&lt;p&gt;The problem with reseek is that it does not necessarily seek to an existing row. Say you have row1 and row3 in a table and now you issue a get for row2. You&apos;d reseek to row2, which would place the scanner just before row3, the next call to next() would return row3, which is not what you want; hence we&apos;d either have know whether the reseek found an existing row (in which case next will return the one we want) or we need to check the result from next() (and if the row key does not match we are this work for nothing).&lt;/p&gt;

&lt;p&gt;The other question is around bloom filters, which currently are only checked for get scans.&lt;/p&gt;</comment>
                            <comment id="13634663" author="lhofhansl" created="Thu, 18 Apr 2013 00:15:27 +0000"  >&lt;p&gt;Then of course every Get can have its own timerange and filter, so the cases where this can be used is more limited than I had thought. I suppose one could Gets by timerange and filter, or only do this for Gets without timerange/filter specified.&lt;/p&gt;

&lt;p&gt;Maybe this is dud.&lt;br/&gt;
I&apos;ll think about this a bit more and then either provide a patch or close as &quot;Another-nonsense-LarsH-idea&quot;.&lt;/p&gt;</comment>
                            <comment id="13634673" author="varunsharma" created="Thu, 18 Apr 2013 00:26:21 +0000"  >&lt;p&gt;How about an algorithm like this:&lt;/p&gt;

&lt;p&gt;1) Sort all the incoming gets and a point i initialized to 0. Lets call gets&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; the i-th row in this list of sorted gets&lt;br/&gt;
Loop&lt;br/&gt;
2) RESEEK to gets&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; - call next() and let the obtained row be currentRow&lt;br/&gt;
   a) If gets&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; matches currentRow, great, include the row in results, i++ and RESEEK&lt;br/&gt;
   b) We got currentRow &amp;gt; gets&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;, increment i such that gets&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; &amp;gt;= currentRow. If gets&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; == currentRow, then include the row and do i++ and continue the loop&lt;/p&gt;

&lt;p&gt;Run this loop until either the scanner is exhausted or until i &amp;gt; gets.length&lt;/p&gt;

&lt;p&gt;Of course this requires that you sort the gets first, so that you seek unidirectionally in the forward direction which is also more optimal. This could be formulated as a filter and we could replace the many gets in the multi() function with a scan() operation bundled with the filter. The filter can be:&lt;/p&gt;

&lt;p&gt;MultiRowFilter(byte[][] rows)  // List of rows to limit the scan to.&lt;/p&gt;

&lt;p&gt;We would only pass &quot;rows&quot; which are within the regions boundaries and ignore all others. IMHO, that seems to be one way of implementing this solution...&lt;/p&gt;


&lt;p&gt;Thanks&lt;br/&gt;
Varun&lt;/p&gt;

</comment>
                            <comment id="13634684" author="varunsharma" created="Thu, 18 Apr 2013 00:37:03 +0000"  >&lt;p&gt;Assuming what I said above, is not rubbish, I can try testing out something along those lines...&lt;/p&gt;</comment>
                            <comment id="13634691" author="lhofhansl" created="Thu, 18 Apr 2013 00:44:37 +0000"  >&lt;p&gt;I&apos;ve done a sample patch along those exact lines.&lt;br/&gt;
Then I came across bloom filters, per Get timeranges, and per Get filters, and started to question the entire idea.&lt;/p&gt;</comment>
                            <comment id="13634694" author="lhofhansl" created="Thu, 18 Apr 2013 00:46:26 +0000"  >&lt;p&gt;I like your last idea. Per region we&apos;d just create a local filter and execute a single Scan with it. Would work nicely as long as the Gets do not have their own filters, and all use the same timeranges.&lt;/p&gt;</comment>
                            <comment id="13634702" author="varunsharma" created="Thu, 18 Apr 2013 00:52:52 +0000"  >&lt;p&gt;Great !&lt;/p&gt;

&lt;p&gt;I missed your last comment. That makes it moot though. Is it possible for a Scan to bootstrap from another scan.&lt;/p&gt;

&lt;p&gt;I was thinking if the following could be possible:&lt;br/&gt;
1) There is this TopLevel Scan which scans and seeks through rows&lt;br/&gt;
2) When you reach a row worth including, we create RowLevel Scan which bootstraps from the TopLevel scan - basically is positioned at the same point. The RowLevel scan uses the corresponding Get filter to only include the relevant KV(s) once done.&lt;br/&gt;
3) The RowLevel Scan is now closed and we move on...&lt;/p&gt;</comment>
                            <comment id="13634710" author="lhofhansl" created="Thu, 18 Apr 2013 01:00:08 +0000"  >&lt;p&gt;Not sure how you can do that and avoid the seek that the bootstrapped scanner would do.&lt;br/&gt;
It is not really that common to provide a filter for Gets and even timeranges are not used that often, so we could just only do this for Get with either of those.&lt;/p&gt;</comment>
                            <comment id="13634722" author="varunsharma" created="Thu, 18 Apr 2013 01:17:38 +0000"  >&lt;p&gt;Actually, I think we could support running multi get where all gets have the same filter. Like say retrieve multi rows but then columns with a certain prefix for all those rows. That might be doable (if we can have this new filter play nice with the Column* filters).&lt;/p&gt;

&lt;p&gt;Right now, it seems that we initialize our scanners with a predefined set of filters which can&apos;t be changed throughout their lifetime. If that behaviour was easy to change 1) We could seek across rows using a MultiRowFilter 2) Seek within rows using the specific Get filters to each Get. It seems doable at the surface but I am the sure the devil is in the details...&lt;/p&gt;

&lt;p&gt;Varun&lt;/p&gt;</comment>
                            <comment id="13634870" author="anoop.hbase" created="Thu, 18 Apr 2013 06:02:13 +0000"  >&lt;p&gt;Not using row blooms was the thing came to my mind also when I saw this issue. We need to see how we can (can we?) make use of this row bloom with seeks..  &lt;/p&gt;

&lt;p&gt;I will explore options in that area as this will help in some of our usecase as well. (Not multi get)&lt;/p&gt;</comment>
                            <comment id="13634877" author="nkeywal" created="Thu, 18 Apr 2013 06:10:28 +0000"  >&lt;blockquote&gt;&lt;p&gt;It is not really that common to provide a filter for Gets and even timeranges are not used that often, so we could just only do this for Get with either of those.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We could change the API to support a single timerange and filter for a multiget. I bet it would cover 99% of the use cases.&lt;/p&gt;</comment>
                            <comment id="13634884" author="varunsharma" created="Thu, 18 Apr 2013 06:19:18 +0000"  >&lt;p&gt;Or add a new API and retain the older API for the exotic 1 % ?&lt;/p&gt;</comment>
                            <comment id="13634930" author="nkeywal" created="Thu, 18 Apr 2013 07:20:04 +0000"  >&lt;blockquote&gt;&lt;p&gt;Or add a new API and retain the older API for the exotic 1 % ?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;+1 (that&apos;s what I wanted to say actually)&lt;/p&gt;</comment>
                            <comment id="13637138" author="lhofhansl" created="Sat, 20 Apr 2013 06:39:15 +0000"  >&lt;p&gt;Why can&apos;t StoreFileScanner.requestSeek make use of a ROW bloom filter? We&apos;d check the ROW BF before the ROWCOL BF and if is does not pass we can immediately hint to the last KV on the row. That way if a row is not found in an HFile at all, we can skip that file, rather looking for all columns.&lt;br/&gt;
(It&apos;s probably not that simple, or we would do that already)&lt;/p&gt;</comment>
                            <comment id="13637157" author="anoop.hbase" created="Sat, 20 Apr 2013 08:32:59 +0000"  >&lt;blockquote&gt;&lt;p&gt;Why can&apos;t StoreFileScanner.requestSeek make use of a ROW bloom filter?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Should be possible. I was also thinking this way Lars. Will check further. Now we make use of the ROWCOL bloom when the seek key contains a non null CF name.  If CF name is not present we can make use of the ROW bloom (If it is there). When CF name  is there and there is no ROWCOL bloom available but a ROW bloom, we can make use of that.&lt;/p&gt;</comment>
                            <comment id="13637399" author="lhofhansl" created="Sat, 20 Apr 2013 23:06:31 +0000"  >&lt;p&gt;Filed &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8388&quot; title=&quot;Use ROW bloom filter for scanning&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8388&quot;&gt;&lt;del&gt;HBASE-8388&lt;/del&gt;&lt;/a&gt; for the ROW BF work during scanning.&lt;/p&gt;</comment>
                            <comment id="13648615" author="varunsharma" created="Fri, 3 May 2013 17:49:03 +0000"  >&lt;p&gt;Is this being actively worked on ?&lt;/p&gt;

&lt;p&gt;Thanks&lt;br/&gt;
Varun&lt;/p&gt;</comment>
                            <comment id="13649001" author="lhofhansl" created="Sat, 4 May 2013 04:04:36 +0000"  >&lt;p&gt;It&apos;s on my (long&apos;ish) list of things to do.&lt;br/&gt;
It is not 100% clear that we would see a large improvement from this.&lt;/p&gt;

&lt;p&gt;If the Gets in a batch a far apart (in terms of blocks) reseek won&apos;t buy much; if on the other hand there is a high probability that the Gets end up on the same block we&apos;d expect to see an improvement.&lt;/p&gt;

&lt;p&gt;I am not saying it should not be done, just that I do not think this should be generally enabled, but be at the discretion of the caller. I.e. a new API.&lt;/p&gt;

&lt;p&gt;If ROW bloomfilters would work with scans this might be a different story. Another consideration could be a new scanner API (something like reseekExact or something), which would attempt to reseek to an exact position and indicate whether than succeeded or not.&lt;/p&gt;</comment>
                            <comment id="13659247" author="lhofhansl" created="Thu, 16 May 2013 05:31:31 +0000"  >&lt;p&gt;We either have to guarantee and all gets have:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;the same filter(s)&lt;/li&gt;
	&lt;li&gt;the same time range&lt;/li&gt;
	&lt;li&gt;the same column families&lt;/li&gt;
	&lt;li&gt;the same set of columns&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;or (as Varun and Nicholas suggest) have a new API.&lt;/p&gt;

&lt;p&gt;I now prefer the new API.&lt;/p&gt;

&lt;p&gt;Some options:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A completely new API taking Scan object along with a set or rowkeys to hit.&lt;/li&gt;
	&lt;li&gt;More state on the Scan object itself (a set of rows to hit, rather just start/stop row)&lt;/li&gt;
	&lt;li&gt;An API taking a prototypical Get object along with a set of rowkeys&lt;/li&gt;
	&lt;li&gt;A new API taking a set of Gets all of which will be forced to be identical in the attributes mentioned above.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In terms of executing we would want to avoid sending all rowkeys to every region. So the client would break the set of row keys by region boundaries (similar to what it now does for a set of Gets) and then hit the right region server with a subset of the keys.&lt;/p&gt;

&lt;p&gt;Another option is to have a new &quot;MultiRowFilter&quot;, which would do seeks between rows to hit. The client would prepare a filter for each region in question, and pass that along with the Scan to each region (again each serialized filter would only have the subset of the keys for the region in question). Note that we just provide such a MultiRowFilter, this can already be done today with some client side code.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="12710109">HBASE-11056</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 17 Apr 2013 18:54:44 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>323407</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            3 years, 29 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1jsqn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>323752</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>