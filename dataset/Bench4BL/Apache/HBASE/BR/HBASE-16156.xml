<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat Dec 03 15:54:08 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-16156/HBASE-16156.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-16156] In write heavy scenario creating in memory flushes leads to contention</title>
                <link>https://issues.apache.org/jira/browse/HBASE-16156</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;In write heavy cases, the inmemory flushes blocks the write because it takes a update lock. Dumps show that it is causing heavy contention and leads to memstore filling up and so intern blocks the flush from happening sooner. This JIRA is to discuss optimal settings and then make suitable changes.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12985812">HBASE-16156</key>
            <summary>In write heavy scenario creating in memory flushes leads to contention</summary>
                <type id="7" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/subtask_alternate.png">Sub-task</type>
                            <parent id="12977487">HBASE-16003</parent>
                                    <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="3">Duplicate</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="ram_krish">ramkrishna.s.vasudevan</reporter>
                        <labels>
                    </labels>
                <created>Thu, 30 Jun 2016 16:07:37 +0000</created>
                <updated>Mon, 4 Jul 2016 05:39:08 +0000</updated>
                            <resolved>Mon, 4 Jul 2016 05:39:08 +0000</resolved>
                                    <version>2.0.0</version>
                                    <fixVersion>2.0.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="15357563" author="stack" created="Thu, 30 Jun 2016 17:57:46 +0000"  >&lt;p&gt;You have thread dump w/ the contention showing? &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=anastas&quot; class=&quot;user-hover&quot; rel=&quot;anastas&quot;&gt;Anastasia Braginsky&lt;/a&gt; or &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=eshcar&quot; class=&quot;user-hover&quot; rel=&quot;eshcar&quot;&gt;Eshcar Hillel&lt;/a&gt;, what ye reckon?&lt;/p&gt;</comment>
                            <comment id="15358498" author="anoop.hbase" created="Fri, 1 Jul 2016 06:42:39 +0000"  >&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
getRegionServices().blockUpdates();
    &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
      MutableSegment active = getActive();
      LOG.info(&lt;span class=&quot;code-quote&quot;&gt;&quot;IN-MEMORY FLUSH: Pushing active segment into compaction pipeline, &quot;&lt;/span&gt;
            + &lt;span class=&quot;code-quote&quot;&gt;&quot;and initiating compaction.&quot;&lt;/span&gt;);
      pushActiveToPipeline(active);
    } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
      getRegionServices().unblockUpdates();
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;It was this way.  So under the lock we do log also !!!!   Now I changed level to debug so that u will see better.   Even we need change that also. After the lock is released we can debug log that the active is pushed.&lt;/p&gt;</comment>
                            <comment id="15358503" author="ram_krish" created="Fri, 1 Jul 2016 06:47:58 +0000"  >&lt;p&gt;Yes. In my testing I had already removed these logs that were coming a lot of times. &lt;/p&gt;</comment>
                            <comment id="15358534" author="anoop.hbase" created="Fri, 1 Jul 2016 07:11:05 +0000"  >&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!active.isEmpty()) {
      &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; delta = DEEP_OVERHEAD_PER_PIPELINE_ITEM - DEEP_OVERHEAD;
      active.setSize(active.getSize() + delta);
      pipeline.pushHead(active);
      resetCellSet();
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Why we need block all the writes for push also? &lt;br/&gt;
We can create new active and only when the new CSLM is assigned to active we need lock.  &lt;/p&gt;</comment>
                            <comment id="15358860" author="ram_krish" created="Fri, 1 Jul 2016 12:06:40 +0000"  >&lt;p&gt;Linking &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16162&quot; title=&quot;Compacting Memstore : unnecessary push of active segments to pipeline&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16162&quot;&gt;&lt;del&gt;HBASE-16162&lt;/del&gt;&lt;/a&gt;, I think that may help solve this issue.&lt;/p&gt;</comment>
                            <comment id="15360084" author="anastas" created="Sat, 2 Jul 2016 08:49:45 +0000"  >&lt;p&gt;Hi Guys,&lt;/p&gt;

&lt;p&gt;I have just seen this and &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16162&quot; title=&quot;Compacting Memstore : unnecessary push of active segments to pipeline&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16162&quot;&gt;&lt;del&gt;HBASE-16162&lt;/del&gt;&lt;/a&gt;. Both JIRAs have the same root. Indeed there is a bug in synchronization of dispatching the &lt;b&gt;single&lt;/b&gt; compaction thread. This includes that active should be pushed to the compaction pipeline only once. We have seen this synch problem and solved it like this:&lt;/p&gt;

&lt;p&gt;private boolean shouldFlushInMemory() {&lt;br/&gt;
    if(getActive().getSize() &amp;gt; inmemoryFlushSize) &lt;/p&gt;
{ // size above flush threshold
      if (allowCompaction.get())      // the compaction is allowed in the test case
        // the inMemoryFlushInProgress is CASed to be true here in order to mutual exclude
        // the insert of the active into the compaction pipeline
        return (inMemoryFlushInProgress.compareAndSet(false,true)); // the winner is the only thread who is going to deal with compaction
    }
&lt;p&gt;    return false;&lt;br/&gt;
  }&lt;/p&gt;

&lt;p&gt;protected void checkActiveSize() {&lt;br/&gt;
    if (shouldFlushInMemory()) &lt;/p&gt;
{
      /* The thread is dispatched to flush-in-memory. This cannot be done
      * on the same thread, because for flush-in-memory we require updatesLock
      * in exclusive mode while this method (checkActiveSize) is invoked holding updatesLock
      * in the shared mode. */
      InMemoryFlushRunnable runnable = new InMemoryFlushRunnable();
      LOG.info(&quot;Dispatching the MemStore in-memory flush for store &quot; + store.getColumnFamilyName());
      getPool().execute(runnable);
    }
&lt;p&gt;  }&lt;/p&gt;

&lt;p&gt;// internally used method, externally visible only for tests&lt;br/&gt;
  // when invoked directly from tests it must be verified that the caller doesn&apos;t hold updatesLock,&lt;br/&gt;
  // otherwise there is a deadlock&lt;br/&gt;
  @VisibleForTesting&lt;br/&gt;
  void flushInMemory() throws IOException {&lt;br/&gt;
    // Phase I: Update the pipeline&lt;br/&gt;
    getRegionServices().blockUpdates();&lt;br/&gt;
    try &lt;/p&gt;
{
      MutableSegment active = getActive();
      LOG.info(&quot;IN-MEMORY FLUSH: Pushing active segment into compaction pipeline, &quot; +
          &quot;and initiating compaction.&quot;);
      pushActiveToPipeline(active);
    }
&lt;p&gt; finally &lt;/p&gt;
{
      getRegionServices().unblockUpdates();
    }
&lt;p&gt;    // Phase II: Compact the pipeline&lt;br/&gt;
    try {&lt;br/&gt;
      if (allowCompaction.get()) &lt;/p&gt;
{
        // setting the inMemoryFlushInProgress flag again for the case this method is invoked
        // directly (only in tests) in the common path setting from true to true is idempotent
        inMemoryFlushInProgress.set(true);
        // Speculative compaction execution, may be interrupted if flush is forced while
        // compaction is in progress
        compactor.start();
      }
&lt;p&gt;    } catch (IOException e) &lt;/p&gt;
{
      LOG.warn(&quot;Unable to run memstore compaction. region &quot;
          + getRegionServices().getRegionInfo().getRegionNameAsString()
          + &quot;store: &quot;+ getFamilyName(), e);
    }
&lt;p&gt; finally &lt;/p&gt;
{
      stopCompaction();
    }
&lt;p&gt;  }&lt;/p&gt;

&lt;p&gt;After the fix we didn&apos;t see synch issues. This is included in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-14921&quot; title=&quot;Inmemory Compaction Optimizations; Segment Structure&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-14921&quot;&gt;&lt;del&gt;HBASE-14921&lt;/del&gt;&lt;/a&gt; patch that is going to be released tomorrow. But truly we should have done it as separate fix...&lt;/p&gt;</comment>
                            <comment id="15360191" author="anoop.hbase" created="Sat, 2 Jul 2016 14:38:26 +0000"  >&lt;p&gt;So setting inMemoryFlushInProgress time before. Ya that should be better.  Because we wont make a new thread unwantedly.   &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16162&quot; title=&quot;Compacting Memstore : unnecessary push of active segments to pipeline&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16162&quot;&gt;&lt;del&gt;HBASE-16162&lt;/del&gt;&lt;/a&gt;  I can fix that way then.  &lt;br/&gt;
Thought of checking and changing this locking way as part of more generic item and just solve this bug.  That is why I added the extra check in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16162&quot; title=&quot;Compacting Memstore : unnecessary push of active segments to pipeline&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16162&quot;&gt;&lt;del&gt;HBASE-16162&lt;/del&gt;&lt;/a&gt;  fix.&lt;/p&gt;</comment>
                            <comment id="15360452" author="eshcar" created="Sun, 3 Jul 2016 07:45:46 +0000"  >&lt;p&gt;Yes, we mis-placed the CAS of the atomic boolean.&lt;br/&gt;
So now (as Anastasia suggested) setting it while checking if we should flush ensures that the active is pushed to the pipeline only once &lt;b&gt;and&lt;/b&gt; the compaction is done by a single thread.&lt;br/&gt;
This should solve both unnecessary flushes of active segments to pipeline (&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16162&quot; title=&quot;Compacting Memstore : unnecessary push of active segments to pipeline&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16162&quot;&gt;&lt;del&gt;HBASE-16162&lt;/del&gt;&lt;/a&gt;) as well as contention on the updates lock by multiple threads (current Jira).&lt;br/&gt;
Also note that the atomic boolean is also set to true (without a CAS) after pushing the active to the pipeline and before compaction - this is needed for the test to work; in the normal flow this is done by the single thread executing this code - the same thread that applied the CAS successfully. &lt;/p&gt;</comment>
                            <comment id="15360859" author="anoop.hbase" created="Mon, 4 Jul 2016 05:39:08 +0000"  >&lt;p&gt;Cause is same as that of &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-16162&quot; title=&quot;Compacting Memstore : unnecessary push of active segments to pipeline&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-16162&quot;&gt;&lt;del&gt;HBASE-16162&lt;/del&gt;&lt;/a&gt;.  Closing as dup.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                            <outwardlinks description="depends upon">
                                        <issuelink>
            <issuekey id="12986080">HBASE-16162</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 30 Jun 2016 17:57:46 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            21 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i30do7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>