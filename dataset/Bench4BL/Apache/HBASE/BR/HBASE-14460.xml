<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Thu Dec 01 22:10:19 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-14460/HBASE-14460.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-14460] [Perf Regression] Merge of MVCC and SequenceId (HBASE-8763) slowed Increments, CheckAndPuts, batch operations</title>
                <link>https://issues.apache.org/jira/browse/HBASE-14460</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;As reported by &#37428;&#26408;&#20426;&#35029; up on the mailing list &amp;#8211; see &quot;Performance degradation between CDH5.3.1(HBase0.98.6) and CDH5.4.5(HBase1.0.0)&quot; &amp;#8211; our unification of sequenceid and MVCC slows Increments (and other ops) as the mvcc needs to &apos;catch up&apos; to our current point before we can read the last Increment value that we need to update.&lt;/p&gt;

&lt;p&gt;We can say that our Increment is just done wrong, we should just be writing Increments and summing on read, but checkAndPut as well as batching operations have the same issue. Fix.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12895334">HBASE-14460</key>
            <summary>[Perf Regression] Merge of MVCC and SequenceId (HBASE-8763) slowed Increments, CheckAndPuts, batch operations</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.png">Critical</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="stack">stack</assignee>
                                    <reporter username="stack">stack</reporter>
                        <labels>
                    </labels>
                <created>Tue, 22 Sep 2015 05:08:26 +0000</created>
                <updated>Thu, 18 Feb 2016 06:18:39 +0000</updated>
                            <resolved>Mon, 8 Feb 2016 18:47:22 +0000</resolved>
                                                    <fixVersion>2.0.0</fixVersion>
                    <fixVersion>1.2.0</fixVersion>
                    <fixVersion>1.3.0</fixVersion>
                    <fixVersion>1.1.4</fixVersion>
                    <fixVersion>1.0.4</fixVersion>
                                    <component>Performance</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>36</watches>
                                                                                                            <comments>
                            <comment id="14901950" author="stack" created="Tue, 22 Sep 2015 05:11:16 +0000"  >&lt;p&gt;Silly test to demonstrate the problem.&lt;/p&gt;</comment>
                            <comment id="14901958" author="stack" created="Tue, 22 Sep 2015 05:17:38 +0000"  >&lt;p&gt;Here is link to the mailing list where &#37428;&#26408;&#20426;&#35029; describes the issue:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/hbase-dev/201509.mbox/%3CCANGerjyO+k+cPSKvOqxF7qVK9wZVSNm9JWDnd4q8D11y3mfROw@mail.gmail.com%3E&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://mail-archives.apache.org/mod_mbox/hbase-dev/201509.mbox/%3CCANGerjyO+k+cPSKvOqxF7qVK9wZVSNm9JWDnd4q8D11y3mfROw@mail.gmail.com%3E&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I&apos;ve attached here the nice diagram he made to illustrate the problem.&lt;/p&gt;</comment>
                            <comment id="14902002" author="eclark" created="Tue, 22 Sep 2015 06:02:59 +0000"  >&lt;p&gt;Yeah this is mostly because we have no idea what rows we&apos;re waiting for on mvcc. So to be extra cautious we wait for everything.&lt;br/&gt;
After &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12751&quot; title=&quot;Allow RowLock to be reader writer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12751&quot;&gt;&lt;del&gt;HBASE-12751&lt;/del&gt;&lt;/a&gt; goes in we can hold the row lock until after sync (since it&apos;s reader/writer this shouldn&apos;t slow down normal puts). That would mean that getting the write rowlock means that there are no transactions for that row in flight. That would make increment/check and mutate a little bit faster.&lt;/p&gt;</comment>
                            <comment id="14902884" author="chenheng" created="Tue, 22 Sep 2015 16:13:01 +0000"  >&lt;p&gt;It seems the thread was blocked when acquiring lock for &lt;tt&gt;mvcc.writeQueue&lt;/tt&gt;,  And &lt;tt&gt;mvcc.writeQueue&lt;/tt&gt; is Region Level Lock, So other put/append/increment actions on this &lt;br/&gt;
region were blocked.&lt;/p&gt;

&lt;p&gt;Why one region only has one &lt;tt&gt;mvcc.writeQueue&lt;/tt&gt;?   &lt;br/&gt;
Is it better to make &lt;tt&gt;mvcc.writeQueue&lt;/tt&gt; to be Row Level?&lt;/p&gt;</comment>
                            <comment id="14902921" author="stack" created="Tue, 22 Sep 2015 16:33:47 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=chenheng&quot; class=&quot;user-hover&quot; rel=&quot;chenheng&quot;&gt;Heng Chen&lt;/a&gt; Ideally, yeah, would be row level but how would we do that do you think?&lt;/p&gt;</comment>
                            <comment id="14902935" author="chenheng" created="Tue, 22 Sep 2015 16:42:43 +0000"  >&lt;blockquote&gt;
&lt;p&gt;how would we do that do you think?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;One simple way is to use a Map to store &lt;tt&gt;WriteEntry&lt;/tt&gt; in &lt;tt&gt;mvcc&lt;/tt&gt;, the map&apos;s key is &lt;tt&gt;row&lt;/tt&gt;, and value is &lt;tt&gt;writeQueue&lt;/tt&gt;. Every public interface in &lt;tt&gt;mvcc&lt;/tt&gt;, we pass param &lt;tt&gt;row&lt;/tt&gt; into it...&lt;/p&gt;</comment>
                            <comment id="14902943" author="stack" created="Tue, 22 Sep 2015 16:45:16 +0000"  >&lt;p&gt;I thought this a little ugly because row could be massive... Maybe it&apos;d be ok... row should stick around a short time only. Could try and get away with not making a copy.&lt;/p&gt;</comment>
                            <comment id="14902976" author="chenheng" created="Tue, 22 Sep 2015 16:57:41 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I thought this a little ugly because row could be massive...  row should stick around a short time only. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;yeah... It is ugly... We should remove the row in map when relates writeQueue be empty for a while.... &lt;/p&gt;

&lt;p&gt;And the map&apos;s value should be a wrapper class which contains a writeQueue and a readPoint....&lt;/p&gt;</comment>
                            <comment id="14902981" author="stack" created="Tue, 22 Sep 2015 17:00:12 +0000"  >&lt;blockquote&gt;&lt;p&gt;We should remove the row in map when relates writeQueue be empty for a while....&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry, what you saying above?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;And the map&apos;s value should be a wrapper class which contains a writeQueue and a readPoint....&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Because the readpoint will no longer be global but by row?&lt;/p&gt;</comment>
                            <comment id="14903011" author="chenheng" created="Tue, 22 Sep 2015 17:12:04 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Sorry, what you saying above?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Because row could be massive,  so we will remove it  from our map when it&apos;s writeQueue has nothing to reduce memory used.  &lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;the readpoint will no longer be global but by row?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes,  i think &lt;tt&gt;mvcc&lt;/tt&gt; is to control concurrency read and write for one row, so readPoint should be row level too.&lt;/p&gt;

&lt;p&gt;Is there any problems?&lt;/p&gt;</comment>
                            <comment id="14903505" author="eclark" created="Tue, 22 Sep 2015 21:46:14 +0000"  >&lt;p&gt;We can&apos;t make mvcc per row it will break scan read point. Also it will break any multi-row endpoints&lt;/p&gt;</comment>
                            <comment id="14903506" author="eclark" created="Tue, 22 Sep 2015 21:46:51 +0000"  >&lt;p&gt;However we can try and remove the locks in the mvcc implementation and use java&apos;s concurrent queues.&lt;/p&gt;</comment>
                            <comment id="14903734" author="stack" created="Wed, 23 Sep 2015 00:56:28 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=eclark&quot; class=&quot;user-hover&quot; rel=&quot;eclark&quot;&gt;Elliott Clark&lt;/a&gt; We could keep up global read and write points and Scan could use those. Ditto for multi-row endpoints (or it could query mvcc with the rows it is trying to keep aligned).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;However we can try and remove the locks in the mvcc implementation and use java&apos;s concurrent queues.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You thinking it our being bound up on mvcc and not the fact that a slow write of one row is holding up another?&lt;/p&gt;</comment>
                            <comment id="14904251" author="chenheng" created="Wed, 23 Sep 2015 09:38:06 +0000"  >&lt;p&gt;with &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt; patch, the problem could be easily reproduced locally on master...  &lt;br/&gt;
All threads were blocked on the same position. They were waiting for the slow write.&lt;/p&gt;

&lt;p&gt;This is my jstack information &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-quote&quot;&gt;&quot;9&quot;&lt;/span&gt; #19 prio=5 os_prio=31 tid=0x00007fa8bcbe2800 nid=0x6103 in &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;.wait() [0x000000011d50c000]
   java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.State: WAITING (on object monitor)
	at java.lang.&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;.wait(Native Method)
	- waiting on &amp;lt;0x00000007887e8528&amp;gt; (a java.lang.&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;)
	at org.apache.hadoop.hbase.regionserver.MultiVersionConcurrencyControl.waitForRead(MultiVersionConcurrencyControl.java:207)
	- locked &amp;lt;0x00000007887e8528&amp;gt; (a java.lang.&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;)
	at org.apache.hadoop.hbase.regionserver.MultiVersionConcurrencyControl.completeAndWait(MultiVersionConcurrencyControl.java:143)
	at org.apache.hadoop.hbase.regionserver.TestMultiVersionConcurrencyControlBasic$CycleSomeMvccOps.run(TestMultiVersionConcurrencyControlBasic.java:73)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14904957" author="eclark" created="Wed, 23 Sep 2015 18:12:57 +0000"  >&lt;p&gt;Why don&apos;t we try what I was suggesting for the first? And hold the locks per row until after the sync. Then there&apos;s no need to ever call waitForRead before starting the check and mutate type operations.&lt;/p&gt;</comment>
                            <comment id="14904974" author="stack" created="Wed, 23 Sep 2015 18:21:59 +0000"  >&lt;blockquote&gt;&lt;p&gt;And hold the locks per row until after the sync. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Folks did a load of work to avoid our having to wait on sync while the row lock was held... &lt;/p&gt;

&lt;p&gt;But that was another time. WAL has changed a bunch since then.&lt;/p&gt;

&lt;p&gt;We&apos;ll have to check perf.... make sure no significant degradation... Ideally, our group commit will absorb any extra friction doing an append ... and we won&apos;t back up to fill all handlers.&lt;/p&gt;

&lt;p&gt;If we could lock across an append and perf was ok, then we could refactor the current crazyness of append, then memstore, then sync...&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12751&quot; title=&quot;Allow RowLock to be reader writer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12751&quot;&gt;&lt;del&gt;HBASE-12751&lt;/del&gt;&lt;/a&gt; went into trunk yesterday. Trying to backport it to branch-1 now.&lt;/p&gt;

&lt;p&gt;Don&apos;t we still do an mvcc transaction inside the row lock... we&apos;ll wait till mvcc catches up after we take the row lock... then we complete it and on the end ... So, before releasing the row lock, we&apos;d stamp the mvcc as current writes sequenceid... unless it had already gone beyond us?&lt;/p&gt;</comment>
                            <comment id="14905021" author="eclark" created="Wed, 23 Sep 2015 18:45:32 +0000"  >&lt;blockquote&gt;&lt;p&gt;Folks did a load of work to avoid our having to wait on sync while the row lock was held...&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yeah my thought only works after locks are reader/writer.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Don&apos;t we still do an mvcc transaction inside the row lock... we&apos;ll wait till mvcc catches up after we take the row lock... then we complete it and on the end ... So, before releasing the row lock, we&apos;d stamp the mvcc as current writes sequenceid... unless it had already gone beyond us?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah so that will slow us down in situations where we&apos;re highly contented on the same row. However if there are lots of rows having a check and mutate operation run on then there is no need to wait of other mvcc transactions to complete. Currently even if there is no in flight transaction for the row you&apos;re trying to read modify write, the server waits for all transactions to complete. Holding the lock just gets us up to a point where the server will only wait on transactions for the row that is in question.&lt;/p&gt;</comment>
                            <comment id="14909368" author="apurtell" created="Sat, 26 Sep 2015 17:39:39 +0000"  >&lt;p&gt;After we&apos;re done this I wonder if we can circle back to an argument from the OP on this issue:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We can say that our Increment is just done wrong, we should just be writing Increments and summing on read&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed. For both increments and appends we should be simply writing out the submitted deltas and summing at query or compaction time.  New issue for that?&lt;/p&gt;

&lt;p&gt;We still want the changes under discussion to minimize effect of slow ops on other ops in flight.&lt;/p&gt;</comment>
                            <comment id="14909404" author="stack" created="Sat, 26 Sep 2015 18:28:48 +0000"  >&lt;blockquote&gt;&lt;p&gt;After we&apos;re done this I wonder if we can circle back to an argument from the OP on this issue...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-3434&quot; title=&quot;ability to increment a counter without reading original value from storage&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-3434&quot;&gt;HBASE-3434&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See also this old article on distributed counters with CRDT: &lt;a href=&quot;https://queue.acm.org/detail.cfm?id=2462076&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://queue.acm.org/detail.cfm?id=2462076&lt;/a&gt;. Relevant piece quoted below.&lt;/p&gt;

&lt;p&gt;&quot;...consider building an increment-only counter that is replicated on two servers. We might implement the increment operation by first reading the counter&apos;s value on one replica, incrementing the value by one, and writing the new value back on every replica. If the counter is initially at 0 and two different users simultaneously initiate increment operations on separate servers, both users may read 0 and then distribute the value 1 to the replicas; the counter ends up with a value of 1 instead of the correct value of 2. Instead, we can use a G-counter CRDT, which relies on the fact that increment is a commutative operation&#8212;it doesn&apos;t matter in what order the two increment operations are applied, as long as they are both eventually applied at all sites. With a G-counter, the current counter status is represented as the count of distinct increment invocations, similar to how counting is introduced at the grade-school level: by making a tally mark for every increment then summing the total. In our example, instead of reading and writing counter values, each invocation distributes an increment operation. All replicas end up with two increment operations, which sum to the correct value of 2. This works because the replicas understand the semantics of increment operations instead of providing general-purpose read/write operations, which are not commutative.&quot;&lt;/p&gt;</comment>
                            <comment id="14979850" author="jingcheng.du@intel.com" created="Thu, 29 Oct 2015 05:33:18 +0000"  >&lt;blockquote&gt;&lt;p&gt;We can say that our Increment is just done wrong, we should just be writing Increments and summing on read, but checkAndPut as well as batching operations have the same issue. Fix.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This is a good way to do such operations. But what if the cell is expired (TTL) or out of max versions? Does it mean if it is done in the suggested way, the max versions and TTL won&apos;t be honored?&lt;/p&gt;</comment>
                            <comment id="14979872" author="stack" created="Thu, 29 Oct 2015 05:51:09 +0000"  >&lt;blockquote&gt;&lt;p&gt;Does it mean if it is done in the suggested way, the max versions and TTL won&apos;t be honored?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes. It&apos;d be a &apos;counter&apos; column type so rules would be different. On compaction, we&apos;d sum up all current increments and only write out the sum rather than each individual edit.... tricks like this. Does it have to be a special counter column family so it easy to treat counters special?&lt;/p&gt;</comment>
                            <comment id="14979888" author="jingcheng.du@intel.com" created="Thu, 29 Oct 2015 06:07:06 +0000"  >&lt;blockquote&gt;&lt;p&gt;Does it have to be a special counter column family so it easy to treat counters special?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes, it can be. Or maybe these counter types(append, increase, etc.) of cells and the latest put that is older than counter cells with the same row key can be kept always, maybe the TTL can be honored for this latest put?&lt;/p&gt;</comment>
                            <comment id="14979901" author="jingcheng.du@intel.com" created="Thu, 29 Oct 2015 06:17:48 +0000"  >&lt;p&gt;This description is misleading. Sorry for that.&lt;br/&gt;
I mean if all the counter cells are only summed up in major compaction, the special column family is not needed.&lt;/p&gt;</comment>
                            <comment id="14979933" author="jingcheng.du@intel.com" created="Thu, 29 Oct 2015 06:52:32 +0000"  >&lt;blockquote&gt;&lt;p&gt;Or maybe these counter types(append, increase, etc.) of cells and the latest put that is older than counter cells with the same row key can be kept always, maybe the TTL can be honored for this latest put?&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;I mean if all the counter cells are only summed up in major compaction, the special column family is not needed.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Sorry for the misleading words. I mean these counter cells and latest put that is older than counter cells with the same row key can be kept in minor compaction. In this case, at least one put (even it is expired) for each key will be kept even if there is not counter cells for that key in this minor compaction. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Does it have to be a special counter column family so it easy to treat counters special?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;And yes,  a special column family is a better idea to avoid breaking the compaction rules in normal column families.&lt;/p&gt;</comment>
                            <comment id="14980549" author="chenheng" created="Thu, 29 Oct 2015 14:48:48 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Does it have to be a special counter column family so it easy to treat counters special?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed.. It seems not only compaction, but also split policy,  r/w procedure even memstore flush will be different with current mutation. ...&lt;/p&gt;</comment>
                            <comment id="15033061" author="bbeaudreault" created="Tue, 1 Dec 2015 04:36:43 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt; What versions was your test run against? I am trying to reproduce against cdh 5.3.1 and seeing the same behavior as 5.4.7. Not sure if the original issue was missing part of the underlying problem, or if I&apos;m not reproducing appropriately.&lt;/p&gt;

&lt;p&gt;I had to rename your MultiVersionConcurrencyControl import and function calls to MultiVersionConsistencyControl. I am seeing 10 test threads block while the &quot;slowpoke&quot; thread is churning, which I&apos;m guessing is case we are looking for.&lt;/p&gt;</comment>
                            <comment id="15033142" author="stack" created="Tue, 1 Dec 2015 05:41:01 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=bbeaudreault&quot; class=&quot;user-hover&quot; rel=&quot;bbeaudreault&quot;&gt;Bryan Beaudreault&lt;/a&gt; The issue found here is in hbase-1.0.0/cdh-5.4+. cdh-5.3.x is 0.98.x It shouldn&apos;t have this particular issue. See above the &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=chenheng&quot; class=&quot;user-hover&quot; rel=&quot;chenheng&quot;&gt;Heng Chen&lt;/a&gt; comment for what to look for in thread dumps.&lt;/p&gt;</comment>
                            <comment id="15034389" author="stack" created="Tue, 1 Dec 2015 19:13:45 +0000"  >&lt;p&gt;Bryan, off-list, turned up this readless increment project from our brothers and sisters over at Cask: &lt;a href=&quot;https://github.com/caskdata/cdap-hbase-increments/commits/develop&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/caskdata/cdap-hbase-increments/commits/develop&lt;/a&gt; We should roll it in so you don&apos;t need a CP to run it.&lt;/p&gt;

&lt;p&gt;Bryan also is seeing slowdown in 0.98+ increments over 0.94. 0.98 does mvcc where 0.94 does not but he is seeing hold up in obtaining a row lock.... and the mechanisms in the two versions look similar...(0.94 allowed setting row lock id in Increment constructor... I wonder if we were by-passing row lock... let me try it).&lt;/p&gt;</comment>
                            <comment id="15034748" author="apurtell" created="Tue, 1 Dec 2015 22:33:24 +0000"  >&lt;blockquote&gt;&lt;p&gt;Bryan, off-list, turned up this readless increment project from our brothers and sisters over at Cask: &lt;a href=&quot;https://github.com/caskdata/cdap-hbase-increments/commits/develop&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/caskdata/cdap-hbase-increments/commits/develop&lt;/a&gt; We should roll it in so you don&apos;t need a CP to run it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Interesting, agreed.&lt;/p&gt;

</comment>
                            <comment id="15036353" author="bbeaudreault" created="Wed, 2 Dec 2015 18:46:16 +0000"  >&lt;p&gt;Thank you &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;. One piece of feedback we have so far on CDAP after only a couple days using it is that it is installed on a column family and thus requires each CF it is installed on to have unlimited versions.  We understand why it requires unlimited versions in its current state to roll up the increments, but this is awful when you have a column which is incremented in a CF with other non-increment data. All of that other data will have unlimited versions as well.&lt;/p&gt;

&lt;p&gt;If something like CDAP were incorporated into hbase native I imagine there are better ways to do this roll up. I just wanted to make sure I voiced this as a great thing to improve upon: in the hbase-native version, we shouldn&apos;t need to configure an entire CF to have unlimited versions if just 1 or 2 columns are being incremented.&lt;/p&gt;

&lt;p&gt;Also, the vast majority of our increments are write-only (we don&apos;t care about the result at increment time). But a small handful do care about that value. So having two different versions (one read-write, one write-only) would be great.&lt;/p&gt;</comment>
                            <comment id="15054692" author="stack" created="Sat, 12 Dec 2015 23:13:48 +0000"  >&lt;p&gt;Thanks for the input &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=bbeaudreault&quot; class=&quot;user-hover&quot; rel=&quot;bbeaudreault&quot;&gt;Bryan Beaudreault&lt;/a&gt; (Just saw it).&lt;/p&gt;</comment>
                            <comment id="15054711" author="stack" created="Sat, 12 Dec 2015 23:31:02 +0000"  >&lt;p&gt;There are two ways in which master is slower than 0.94 increments. There is the case where threads are contending to update a single Cell and then there is the case described at the head of this issue where the mvcc coordination is acting like a region-wide lock though all threads incrementing may not be contending on a Cell.&lt;/p&gt;

&lt;p&gt;Here are some rough measurements of the first case. See attached test. It has 100 threads doing 10k increments of a single Cell up against a Region Instance.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
0.94 ~84 seconds
0.98 ~140 seconds
master ~180 seconds
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;0.98 is almost 2x slower than 0.94 (though the code path profile is pretty close if you look at the accompanying flame graphs) and master is slower again, more than 2x slower.&lt;/p&gt;

&lt;p&gt;As is, reports from the field have it that even 0.98 increments are too slow as is (being 2x slower, if many, can back up all handlers so no other work can get in). Hence the above exercise. It seem that indeed even without mvcc unification, increments have gotten slower.&lt;/p&gt;

&lt;p&gt;Let me go measure the case where mvcc is getting in the way next.&lt;/p&gt;</comment>
                            <comment id="15055454" author="stack" created="Mon, 14 Dec 2015 05:55:44 +0000"  >&lt;p&gt;If I run a test that has 100 threads each updating their own rows &amp;#8211; i.e. no contention on a row &amp;#8211; then I see master branch completing before 0.94 does; i.e. master is faster. This is in spite of the thread dump resembling that reported as problematic up top of this issue.&lt;/p&gt;

&lt;p&gt;In 0.94, all are stuck waiting on the WAL syncer to come in:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-quote&quot;&gt;&quot;50&quot;&lt;/span&gt; #74 daemon prio=5 os_prio=0 tid=0x00007f7a78661000 nid=0x3364 waiting &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; monitor entry [0x00007f7a30ecd000]
   java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.State: BLOCKED (on object monitor)
        at org.apache.hadoop.hbase.regionserver.wal.HLog.syncer(HLog.java:1334)
        - waiting to lock &amp;lt;0x00000004cde22390&amp;gt; (a java.lang.&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;)
        at org.apache.hadoop.hbase.regionserver.wal.HLog.sync(HLog.java:1476)
        at org.apache.hadoop.hbase.regionserver.HRegion.syncOrDefer(HRegion.java:6160)
        at org.apache.hadoop.hbase.regionserver.HRegion.increment(HRegion.java:5571)
        at org.apache.hadoop.hbase.regionserver.HRegion.increment(HRegion.java:5454)
        at org.apache.hadoop.hbase.regionserver.TestIncrement$SingleCellIncrementer.run(TestIncrement.java:84)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In master they are stuck here:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&quot;17&quot; #55 daemon prio=5 os_prio=0 tid=0x00007f0374c6d000 nid=0x3a0b in Object.wait() &lt;span class=&quot;error&quot;&gt;&amp;#91;0x00007f030c346000&amp;#93;&lt;/span&gt;&lt;br/&gt;
   java.lang.Thread.State: BLOCKED (on object monitor)&lt;br/&gt;
        at java.lang.Object.wait(Native Method)&lt;br/&gt;
        at org.apache.hadoop.hbase.regionserver.MultiVersionConcurrencyControl.waitForRead(MultiVersionConcurrencyControl.java:218)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;locked &amp;lt;0x00000004d2e26208&amp;gt; (a java.lang.Object)&lt;br/&gt;
        at org.apache.hadoop.hbase.regionserver.MultiVersionConcurrencyControl.completeAndWait(MultiVersionConcurrencyControl.java:149)&lt;br/&gt;
        at org.apache.hadoop.hbase.regionserver.MultiVersionConcurrencyControl.await(MultiVersionConcurrencyControl.java:137)&lt;br/&gt;
        at org.apache.hadoop.hbase.regionserver.HRegion.increment(HRegion.java:7360)&lt;br/&gt;
        at org.apache.hadoop.hbase.regionserver.HRegion.increment(HRegion.java:7315)&lt;br/&gt;
        at org.apache.hadoop.hbase.regionserver.TestIncrement$SingleCellIncrementer.run(TestIncrement.java:86)&lt;br/&gt;
{code&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The flame graphs show basically the same profile across all verisons (master spends a bit less time appending which I suppose is expected).&lt;/p&gt;</comment>
                            <comment id="15055467" author="chenheng" created="Mon, 14 Dec 2015 06:04:18 +0000"  >&lt;blockquote&gt;
&lt;p&gt;If I run a test that has 100 threads each updating their own rows &#8211; i.e. no contention on a row &#8211; then I see master branch completing before 0.94 does; i.e. master is faster. &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;are all the rows in one region?&lt;/p&gt;</comment>
                            <comment id="15055475" author="stack" created="Mon, 14 Dec 2015 06:13:05 +0000"  >&lt;blockquote&gt;&lt;p&gt;....are all the rows in one region?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yes (good question though).&lt;/p&gt;</comment>
                            <comment id="15055510" author="stack" created="Mon, 14 Dec 2015 06:34:48 +0000"  >&lt;p&gt;Just checked patch. All Increments are on same column family so is a single memstore and so all should be contending on mvcc. Interesting is that thread dump shows mvcc as where we contend but the test completes faster.&lt;/p&gt;

&lt;p&gt;TODO: Get numbers on diff between 0.98 and master branch as per original reporters complaint (was comparing 0.94 and master).&lt;/p&gt;</comment>
                            <comment id="15055809" author="jingcheng.du@intel.com" created="Mon, 14 Dec 2015 10:45:17 +0000"  >&lt;p&gt;I am thinking about an alternative way to improve the implementation in increment, checkAndPut, etc.&lt;br/&gt;
In each operation, we can attach a write number per row, in the operation of increment, we can wait for the previous operations to finish only in this row in mvcc.await()?&lt;br/&gt;
I had drafted an ugly patch (only for master) to do this for discussion. And I ran the TestIncrement, the results are listed in the following.&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;1. testContendedSingleCellIncrementer:
      With the patch: 1st run is 228.185s. 2nd run is 232.453s. 3th run is 235.457s. 4th run is 229.003s.
      Without the patch: 1st run is 230.299s. 2nd run is 234.997s. 3rd run is 219.224s. 4th run is 225.731s..
2. testUnContendedSingleCellIncrementer:
      With the patch: 59.244s.
      Without the patch: 81.667s.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The patch is attached in this JIRA for discussion. Thanks!&lt;/p&gt;</comment>
                            <comment id="15056586" author="stack" created="Mon, 14 Dec 2015 19:46:15 +0000"  >&lt;p&gt;Sweet &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jingcheng.du%40intel.com&quot; class=&quot;user-hover&quot; rel=&quot;jingcheng.du@intel.com&quot;&gt;Jingcheng Du&lt;/a&gt; Thank you. I like the numbers.  Will be back with comments on the patch....&lt;/p&gt;</comment>
                            <comment id="15057465" author="stack" created="Tue, 15 Dec 2015 07:02:45 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jingcheng.du%40intel.com&quot; class=&quot;user-hover&quot; rel=&quot;jingcheng.du@intel.com&quot;&gt;Jingcheng Du&lt;/a&gt; I&apos;m not clear on how your patch works. Please explain it to those who are slower than you.&lt;/p&gt;

&lt;p&gt;I see that at the start of the Increment, when we begin mvcc, we pass in this new RowContext. I see then that in begin, we run through contexts looking at write numbers to find the highest write number on a row which I suppose could be less than the one we are assigned by default; that&apos;d be good.  How is row write number assigned?&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;</comment>
                            <comment id="15057484" author="jingcheng.du@intel.com" created="Tue, 15 Dec 2015 07:17:02 +0000"  >&lt;p&gt;Thanks for reviewing &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;.&lt;br/&gt;
It&apos;s in method stampRegionSequenceId of FSWALEntry when doing wal.append?&lt;/p&gt;</comment>
                            <comment id="15057499" author="jingcheng.du@intel.com" created="Tue, 15 Dec 2015 07:32:51 +0000"  >&lt;p&gt;Most of the difference is what mvcc.await does in the beginning of the increment, checkAndMutate, etc. operations, it only waits for the operations in its row. In the mvcc.await after the operations, it is the same with the current way to wait for the finish of the current operation.&lt;br/&gt;
If it is a batch operation, all the row operation context in that batch will have the same write number of a WriteEntry. This write number will be used in mvcc.await method in the beginning of next increment operation.&lt;/p&gt;</comment>
                            <comment id="15057635" author="stack" created="Tue, 15 Dec 2015 08:48:59 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jingcheng.du%40intel.com&quot; class=&quot;user-hover&quot; rel=&quot;jingcheng.du@intel.com&quot;&gt;Jingcheng Du&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;But at the start of the increment when we do this...&lt;/p&gt;

&lt;p&gt;          mvcc.await(rowLockPair.getFirst().getRowOperationContext());&lt;/p&gt;

&lt;p&gt;... the rowOperationContext does not have our rows sequenceid, right? That does not get assigned much later when we do the append way down inside this method. The mvcc.await at the head of the increment is working with the initial setting, -1, so is not waiting at all?&lt;/p&gt;

&lt;p&gt;Maybe I am not following. Please correct me if I am misreading. Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jingcheng.du%40intel.com&quot; class=&quot;user-hover&quot; rel=&quot;jingcheng.du@intel.com&quot;&gt;Jingcheng Du&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The difference you see when you run the test is interesting in of it itself.&lt;/p&gt;</comment>
                            <comment id="15057684" author="jingcheng.du@intel.com" created="Tue, 15 Dec 2015 09:16:27 +0000"  >&lt;p&gt;The assigning of the write number is done in begin(RowOperationContext... rowOperationContexts) method which is invoked in mvcc.await(rowOperationContexts), right?&lt;/p&gt;</comment>
                            <comment id="15057719" author="jingcheng.du@intel.com" created="Tue, 15 Dec 2015 09:44:58 +0000"  >&lt;p&gt;in the method begin(RowOperationContext... rowOperationContexts), it does several things.&lt;br/&gt;
1. Generate the next write number.&lt;br/&gt;
2. Get the last write number that the current WritenEntry concerns ( by comparing the exiting RowOperationContext in this batch and get the biggest one).&lt;br/&gt;
3. Set the next writer number for each RowOperationContext in this batch.&lt;br/&gt;
4. Set the next writer number to the current WriteEntry and add it to the write queue.&lt;/p&gt;</comment>
                            <comment id="15058443" author="stack" created="Tue, 15 Dec 2015 18:03:28 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jingcheng.du%40intel.com&quot; class=&quot;user-hover&quot; rel=&quot;jingcheng.du@intel.com&quot;&gt;Jingcheng Du&lt;/a&gt; Thanks. The explanation helps.&lt;/p&gt;

&lt;p&gt;I think I understand now where the speedup comes from now (pardon my being so dense).&lt;/p&gt;

&lt;p&gt;Here is basic Increment flow:&lt;/p&gt;

&lt;p&gt;1. get row lock&lt;br/&gt;
2. wait on ALL outstanding transactions to complete so can do a read and know it will have the latest data&lt;br/&gt;
3. do get, then append...&lt;br/&gt;
4. call sync&lt;br/&gt;
4. let go of lock&lt;br/&gt;
5. wait on sync to complete&lt;br/&gt;
6. wait on read point to catch up with the write for the above added increment so for sure the client and read what they wrote (this latter is probably not needed given we start an increment by waiting on read to catch up with write &amp;#8211; TODO).&lt;/p&gt;

&lt;p&gt;Your speed up comes of the following:&lt;/p&gt;

&lt;p&gt;1. get row lock AND look to see if we have any write context for this row already&lt;br/&gt;
2. if we don&apos;t have an existing write op on this row, proceed as per above but if we do find an existing context....then all we have to do is wait on the write number for this existing transaction to clean, NOT for all existing writes to clear...&lt;br/&gt;
3. as per above, etc.&lt;/p&gt;

&lt;p&gt;Do I have it right? If so, sweet (again)... and, yeah, could we skip out on the wait in step #6 above in the first list.&lt;/p&gt;

&lt;p&gt;Now to the patch.... some more questions (smile).&lt;/p&gt;

&lt;p&gt;In begin, we do this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
        &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; lastWriterNumber = -1;
        &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (RowOperationContext context : rowOperationContexts) {
          &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (context != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (lastWriterNumber &amp;lt; context.getNextWriteNumber()) {
              lastWriterNumber = context.getNextWriteNumber();
            }
            context.setNextWriteNumber(nextWriteNumber);
          }
        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Is the intent that all passed in rowOperationContexts all get the highest found nextWrite Number? If so, this loop does not seem like it will achieve this (if rowOperationContexts have write numbers 1 to 3 say, then after the loop is done, all rowOperationContexts will have the same 1 to 3 write numbers...  but if write numbers are 3 to 1, then they will have a write number of 3......)&lt;/p&gt;

&lt;p&gt;Let me look more... will be back.&lt;/p&gt;




</comment>
                            <comment id="15059279" author="stack" created="Wed, 16 Dec 2015 01:15:33 +0000"  >&lt;p&gt;Attempts at reproducing the slowdown in the small have failed to pay off. I see the roughly 2x difference but not the 7x claimed by the original poster.&lt;/p&gt;

&lt;p&gt;With some help from Preston Koprivica, you need to have some friction in place to see the issue; the friction gets amplified by mvcc wait.&lt;/p&gt;

&lt;p&gt;Here is a test that clearly shows the problem. 0.98 is about 33% slower than 0.94 (0.98 added in mvcc) and then 1.0+ is about 10x the latency WHEN you have 80 clients running external to the regionserver process banging on it.&lt;/p&gt;

&lt;p&gt;The flame graphs show us spending loads of time in mvcc waiting. The stack trace is the SAME as for the tests in the small but we just seem to be waiting overall longer. There is an amplification going on.&lt;/p&gt;

&lt;p&gt;Looking at options:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jingcheng.du%40intel.com&quot; class=&quot;user-hover&quot; rel=&quot;jingcheng.du@intel.com&quot;&gt;Jingcheng Du&lt;/a&gt;&apos;s suggestion is a nice one. Will narrow what we have to wait on. I tried disabling completely our wait-on-mvcc before we read at all and this helps; we are only 3x slower than 0.98 (and 4x slower than 0.94).&lt;/p&gt;

&lt;p&gt;Need some other bit of trickery to take us closer to what was there before.&lt;/p&gt;</comment>
                            <comment id="15059394" author="jingcheng.du@intel.com" created="Wed, 16 Dec 2015 02:51:26 +0000"  >&lt;p&gt;Thanks for comments!&lt;br/&gt;
You are right, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;.&lt;br/&gt;
In the current implementation, region caches a row lock context in lockedRows. In the patch I wrap the lock into a RowContext, and add one more RowOperationContext in RowContext, consequently the lockedRows cache the RowContext instead.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;could we skip out on the wait in step #6 above in the first list.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;If we skip the waiting, does it mean a user gets the response, but this cell is not yet visible? Is it ok?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Is the intent that all passed in rowOperationContexts all get the highest found nextWrite Number? If so, this loop does not seem like it will achieve this (if rowOperationContexts have write numbers 1 to 3 say, then after the loop is done, all rowOperationContexts will have the same 1 to 3 write numbers... but if write numbers are 3 to 1, then they will have a write number of 3......)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, this is done on purpose. It tries to find the biggest lastWriteNumber (which means this current WriteEntry for this batch has to wait for the biggest lastWriteNumber is visible before it can continue in waitForRead). For each RowOperationContext, it has the same nextWriteNumber (by using context.setNextWriteNumber(nextWriteNumber)). Maybe the names are similar, and get mixed up for reading?&lt;br/&gt;
In the given example, if RowOperationContext has write number 1 to 3, after the loop is done, the lastWritenNumber for the WriteEntry is 3, and the nextWriteNumber in each RowOperationContext has a new number (maybe 4).&lt;/p&gt;</comment>
                            <comment id="15059596" author="stack" created="Wed, 16 Dec 2015 06:47:24 +0000"  >&lt;p&gt;First, now that I understand, I like your idea. We should do it. Lets work on your patch. Will give some more feedback tomorrow (need to consider your response on rowOperationContexts... try it).&lt;/p&gt;

&lt;p&gt;We need more speed up though. Looks like your change could get us from 10x to 3 or 4x what it used be which is close. Trying to figure how to get it closer in. One unformed thought is a means of exploiting the context you&apos;ve uncovered and somehow using it to do aggregations of counts that are stuck waiting on a rowlock and or mvcc; i.e. if a handler arrives and we are waiting on mvcc and/or row lock, add our increment elsewhere, park until the increment has been applied and then skip out on doing the increment path ourselves. Probably not possible without compounding complexity and synchronization points so could slow more than it speeds us up.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;...but this cell is not yet visible? Is it ok?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We are out past the sync of the write at this point and while the increment is not yet generally available, as soon as someone needs to read it, they&apos;ll be forced to wait till the mvcc catches up. Given this, I think we might be able to get away with this if we narrow the options around when Increments become &apos;visiible&apos;.&lt;/p&gt;

&lt;p&gt;We need another 2x to get us within shouting distance of how it used all work in 0.98/0.94 timeframe. Some folks are late upgrading and they&apos;ve built their apps based on a fast Increment. They are kinda hosed w/o it.&lt;/p&gt;</comment>
                            <comment id="15059723" author="jingcheng.du@intel.com" created="Wed, 16 Dec 2015 08:59:03 +0000"  >&lt;p&gt;Complement some more information.&lt;br/&gt;
I ran the same test in my node for 0.98 (I used the same env for the previous tests), and got the following results.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
1. testContendedSingleCellIncrementer: 1st run is 176.674s. 2nd run is 175.813s.
2. testUnContendedSingleCellIncrementer: 62.989s.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;It seems the performance gap is not as large as 10x in my poor test env&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I didn&apos;t see too many differences in code between 0.98 and trunk, why are the performances so different?&lt;/p&gt;</comment>
                            <comment id="15060191" author="jingcheng.du@intel.com" created="Wed, 16 Dec 2015 15:53:34 +0000"  >&lt;p&gt;There is an issue in this patch. The RowContext is released when the lock is released, it is before mvcc.completeAndWait is finished. It means the following operations cannot get the lastWriteNumber before the last operation is completed indeed because the cached context had been cleaned. We should clear the cached context a little later and right after mvcc.completeAndWait.&lt;/p&gt;</comment>
                            <comment id="15060266" author="stack" created="Wed, 16 Dec 2015 16:39:43 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jingcheng.du%40intel.com&quot; class=&quot;user-hover&quot; rel=&quot;jingcheng.du@intel.com&quot;&gt;Jingcheng Du&lt;/a&gt; Yeah. The tests only show 2x difference. You have to run the last posted from separate JVM to see the 10x. The attached flame graphs show difference is time spent in mvcc waiting. Even a small slowdown in mvcc throughput &amp;#8211; there is more machinery involved in 1.0+ mvcc-- has broad implications for region throughput given its region-wide scope. Let me try and get more specific. Not waiting for mvcc to align before proceeding with Increment doesn&apos;t seem to be enough.&lt;/p&gt;</comment>
                            <comment id="15060538" author="eclark" created="Wed, 16 Dec 2015 18:59:16 +0000"  >&lt;p&gt;I think we should just make it so that the read for increment/ check and put doesn&apos;t have to wait for the mvcc number at all. That should be easily do-able by moving the row locks around a little. That won&apos;t affect normal put performance since they are read locks only.&lt;br/&gt;
That way once the increment has the write lock all outstanding edits are visible.&lt;br/&gt;
This will keep us from having to lug around extra state per row, which would be a perf loss for all other writes.&lt;/p&gt;</comment>
                            <comment id="15061274" author="stack" created="Thu, 17 Dec 2015 01:22:31 +0000"  >&lt;p&gt;Patch for discussion. Gets us back to 0.98 speeds; i.e. about 1/3rd slower than 0.94.&lt;/p&gt;

&lt;p&gt;Idea is to unshackle Increments and MVCC other than to keep MVCC abreast of sequenceId change. I can do this if I reorder Increment so the Increment get and write (as well as sync) are all under the row lock; this makes it so my read will get the latest always  since no concurrent writer on this row (because I have undone the mvcc connection, I need to read with isolation UNCOMMITTED). If I reorder Increment so its read, append, sync, then update memstore, I can undo the crazy +1B and the need of the post-modification of Cells in MemStore.&lt;/p&gt;

&lt;p&gt;The gambit is a slower Increment because all happens under the row lock including the sync of the write which used to be done on the outside. This makes it so we don&apos;t need MVCC for correctness and so can by-pass the MVCC-is-a-region-wide-lock phenomenon.&lt;/p&gt;

&lt;p&gt;See attached flamegraph. It looks like 0.98 now.&lt;/p&gt;

&lt;p&gt;Some basic tests using the above attached IncrementTest (80 concurrent threads doing an increment over 50k rows) show us doing:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
75th: 3.92218
95th: 5.648627799999997
98th: 8.072542299999984
99th: 23.11843173
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The same test against 0.98 as quoted above shows:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
75th: 4.400081
95th: 6.0390387
98th: 6.7202052
99th: 7.264320360000001

Time: 191.393
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Posting the patch for discussion.&lt;/p&gt;

&lt;p&gt;Need to figure downsides. Will study the patch more. Our Increment in memstore should work as expected when Scanning since we are using the actual assigned sequenceid. On crash, edit could be in WAL and client may not know it made it but this has always been an issue.&lt;/p&gt;</comment>
                            <comment id="15061278" author="stack" created="Thu, 17 Dec 2015 01:25:49 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=eclark&quot; class=&quot;user-hover&quot; rel=&quot;eclark&quot;&gt;Elliott Clark&lt;/a&gt; I just read your comment. Sorry. It looks like my patch does sort of what you suggest (I&apos;m working on branch-1.0... I want to fix it here for the folks coming onto to hbase-1.0/1.1 first...). Any chance of a review? If the numbers I have gotten so far are any indication, I&apos;m looking forward to refactor of master and branch-1 tip to make this zig-zag around read/append/memstore upsert/sync/mvcc finish run more direct.&lt;/p&gt;</comment>
                            <comment id="15061326" author="jingcheng.du@intel.com" created="Thu, 17 Dec 2015 02:13:39 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=eclark&quot; class=&quot;user-hover&quot; rel=&quot;eclark&quot;&gt;Elliott Clark&lt;/a&gt;, using the write lock is a good way to do that. But we have to release the lock a little later after the current write number is visible? A larger locked code block impacts the put operations too?&lt;/p&gt;</comment>
                            <comment id="15061361" author="jingcheng.du@intel.com" created="Thu, 17 Dec 2015 02:40:30 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;, I got your and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=eclark&quot; class=&quot;user-hover&quot; rel=&quot;eclark&quot;&gt;Elliott Clark&lt;/a&gt;&apos;s ideas. It tries to use write lock to guarantee there is not earlier entries on this row.&lt;br/&gt;
Does it impact if the wal sync is included in the write lock (During the test, it uses WAL_SKIP, right?)? What if users enable the wal, would it be much worse? Please advise.&lt;/p&gt;</comment>
                            <comment id="15061410" author="stack" created="Thu, 17 Dec 2015 03:48:43 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jingcheng.du%40intel.com&quot; class=&quot;user-hover&quot; rel=&quot;jingcheng.du@intel.com&quot;&gt;Jingcheng Du&lt;/a&gt; Thanks for taking a look. I did not enable WAL_SKIP. The test is against a server with all defaults (so writing WAL but local fs) and then the test is run from outside. Will try up on a cluster over HDFS.&lt;/p&gt;</comment>
                            <comment id="15061570" author="stack" created="Thu, 17 Dec 2015 06:15:53 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jingcheng.du%40intel.com&quot; class=&quot;user-hover&quot; rel=&quot;jingcheng.du@intel.com&quot;&gt;Jingcheng Du&lt;/a&gt; I tried 0.94 vs 1.0 over an HDFS cluster. The extra HDFS friction seems to erase any differences.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
80 clients, 50k increments, 0.94 with RS on one node and Master and Client on other
75th: 5.36942775
95th: 7.5628056
98th: 10.062703859999981
99th: 23.159486310000002

Time: 232.06
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
80 clients, 50k increments, hbase-1.0  with RS on one node and Master and Client on other WITH HACK PATCH

75th: 5.3913165
95th: 7.8763459
98th: 8.724306259999997
99th: 10.49309876000002

Time: 229.237

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="15061578" author="jingcheng.du@intel.com" created="Thu, 17 Dec 2015 06:28:03 +0000"  >&lt;p&gt;Wow, great! Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt;.&lt;br/&gt;
I am sorry that I didn&apos;t ask my question clearly&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  Does an larger blocked code block (include the sync) impact other types of operations? For instance put, etc.? Thanks&lt;/p&gt;</comment>
                            <comment id="15061625" author="stack" created="Thu, 17 Dec 2015 06:59:11 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jingcheng.du%40intel.com&quot; class=&quot;user-hover&quot; rel=&quot;jingcheng.du@intel.com&quot;&gt;Jingcheng Du&lt;/a&gt;&lt;br/&gt;
The plan is to change Increment/CheckAndPut/etc. only in this patch and for branch-1. These changes do not impinge on other operations (unless you disagree?). If a user does a Put onto a Cell coordinate that is being used for Increments then all bets are off... but this has always been a problem, no different with this patch. That said, we should spend some time on our write pipeline. We might be able to straighten the road our writes take getting into the system... less zig-zagging updating memory after append but before sync and then rollback in case failure.... we might be able to simplify... Need to do a bit of perf testing to see how much we&apos;d lose in the redo (or how much we&apos;d gain).  Thanks.&lt;/p&gt;</comment>
                            <comment id="15061691" author="eclark" created="Thu, 17 Dec 2015 08:09:54 +0000"  >&lt;blockquote&gt;&lt;p&gt;A larger locked code block impacts the put operations too?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Not really. In the latest branches we&apos;ve made the row locks reader/writer. That means that there can be any number of puts for the same row going on. So holding the row lock until after the mvcc has been fully applied shouldn&apos;t change the normal put flow. It also won&apos;t change the increment flow.&lt;/p&gt;

&lt;p&gt;The only place it will matter is when there are increments and puts going to the same row from different clients. That&apos;s always going to be the case since we only have per row level locks.&lt;/p&gt;</comment>
                            <comment id="15061697" author="jingcheng.du@intel.com" created="Thu, 17 Dec 2015 08:17:24 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=eclark&quot; class=&quot;user-hover&quot; rel=&quot;eclark&quot;&gt;Elliott Clark&lt;/a&gt;, that was what I tried to express, different operation types with the same row. Sorry for my previous unclear expression confuse &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt; and you.&lt;/p&gt;</comment>
                            <comment id="15061699" author="eclark" created="Thu, 17 Dec 2015 08:20:46 +0000"  >&lt;p&gt;Yes different operations on the same row from different clients will be a little slower. I think that&apos;s a fair trade off.&lt;/p&gt;</comment>
                            <comment id="15061767" author="eclark" created="Thu, 17 Dec 2015 09:17:24 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt; Your patch doesn&apos;t move the row lock for doMiniBatchMutation so there&apos;s a race there.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Put comes in setting the cell to 0&lt;/li&gt;
	&lt;li&gt;10 increments to the cell.&lt;/li&gt;
	&lt;li&gt;Put comes in setting the cell back to zero.
	&lt;ul&gt;
		&lt;li&gt;Put is applied to WAL&lt;/li&gt;
		&lt;li&gt;doMinibatchMutation releases the row lock.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Increment comes in
	&lt;ul&gt;
		&lt;li&gt;Increment grabs the row lock&lt;/li&gt;
		&lt;li&gt;Increment reads the data from memestore.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Put gets applied to memstore.&lt;/li&gt;
	&lt;li&gt;Increment gets applied to memstore.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;For the above sequence where a put and an increment race the valid results are 0 and 1. But the race allows 11 to be possible.&lt;/p&gt;

&lt;p&gt;I agree with you though that it looks like rollback is no longer needed. Getting this into a branch before the reader/writer re-write is going to be painful.&lt;/p&gt;</comment>
                            <comment id="15061771" author="jingcheng.du@intel.com" created="Thu, 17 Dec 2015 09:21:53 +0000"  >&lt;p&gt;Something like the TestAtomicOperation does.&lt;br/&gt;
But if &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stack&quot; class=&quot;user-hover&quot; rel=&quot;stack&quot;&gt;stack&lt;/a&gt; uses &lt;tt&gt;get.setIsolationLevel(IsolationLevel.READ_UNCOMMITTED);&lt;/tt&gt;, is there such an issue?&lt;br/&gt;
If &lt;tt&gt;get.setIsolationLevel(IsolationLevel.READ_UNCOMMITTED);&lt;/tt&gt;, do we need to enlarge the locked block?&lt;/p&gt;</comment>
                            <comment id="15061801" author="ram_krish" created="Thu, 17 Dec 2015 09:43:15 +0000"  >&lt;p&gt;One question on the patch&lt;br/&gt;
-&amp;gt; thread T1 tries to do a put on a row with val 50&lt;br/&gt;
-&amp;gt; Another threads T2 tries to do a checkAndPut(say from 10 to 11)&lt;br/&gt;
-&amp;gt; The put has updated the value in memstore and yet to sync to WAL&lt;br/&gt;
-&amp;gt; The T2 does a Get with &apos;UN_COMMITTED&apos; isolation level so it will be able to see the updated val 50 in the memstore.&lt;br/&gt;
-&amp;gt; The thread T1 fails in sync and hence roll back.&lt;br/&gt;
-&amp;gt; thread T2 cannot do the updation since the val is already 50?&lt;br/&gt;
So neither Put nor Increment happened? May be am missing something.&lt;/p&gt;</comment>
                            <comment id="15061811" author="jingcheng.du@intel.com" created="Thu, 17 Dec 2015 09:54:20 +0000"  >&lt;p&gt;Good catch, Ram!&lt;br/&gt;
The rollback in put is out of row lock, the following increment/checkAndMutate can read the dirty cell with IsolationLevel.READ_UNCOMMITTED. It seems we have to remove the get.setIsolationLevel(IsolationLevel.READ_UNCOMMITTED) and have to release the lock in doMiniBatchMutation method after the readPt catchs up?&lt;/p&gt;</comment>
                            <comment id="15061975" author="eclark" created="Thu, 17 Dec 2015 12:24:18 +0000"  >&lt;p&gt;Yeah we can&apos;t use read uncommitted at all. Has to be a normal read. Which means that we have to be sure that there are no other transactions in flight. To do that there are two possible ways.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;Hold the row lock longer on all transactions&lt;/li&gt;
	&lt;li&gt;Wait for mvcc to catch up to any transactions in flight for the row&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="15062384" author="stack" created="Thu, 17 Dec 2015 17:28:25 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=eclark&quot; class=&quot;user-hover&quot; rel=&quot;eclark&quot;&gt;Elliott Clark&lt;/a&gt; Are you talking about a Put and Increment going against same Cell in your scenario; if so, yes, they will mess each other up.&lt;/p&gt;

&lt;p&gt;This issue is about fixing Increment in branch-1 first. The patch will come with a constraint: i.e. you can only use the Increment codepath making Increments. This is a change in behavior but what is there currently is broke. I could add a switch that turned this behavior on/off but that seems OTTT.&lt;/p&gt;

&lt;p&gt;Please correct me if I am misunderstanding you.&lt;/p&gt;

&lt;p&gt;Yeah, will rejigger the write path for all Mutations to get us the straight run of synced-append-to-WAL and then memstore so Put and Increment can be intermixed but that will be a subsequent patch after I&apos;ve done some tests to see perf difference.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Getting this into a branch before the reader/writer re-write is going to be painful.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry, what do you mean here Sir?&lt;/p&gt;

&lt;p&gt;On &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ram_krish&quot; class=&quot;user-hover&quot; rel=&quot;ram_krish&quot;&gt;ramkrishna.s.vasudevan&lt;/a&gt; scenario, I think it fine they both fail (the Put is a &apos;normal&apos; failure that this patch has nothing to do with... and would the checkAndPut proceed at all if a bad WAL caused the first Put fail? Won&apos;t the Put from checkAndPut also fail since it is coming in  later).&lt;/p&gt;

&lt;p&gt;Ram&apos;s scenario does give me pause though and makes me think that on branch 1, we should only do Increments with this treatment. Increments are usually higher-rate than checkAnd*; a slow checkAnd* is probably tolerable in branch-1. Can fix in later branches.&lt;/p&gt;

&lt;p&gt;On the use of READ_UNCOMMITTED, its use is narrow, confined to the Increment case; we are only reading Increment cells. We can&apos;t do 1., in branch-1 or at least not in versions up to hbase-1.2. If we do 2., we are slow again.&lt;/p&gt;

&lt;p&gt;Great feedback lads. Patch should be for Increments only with big warning that bets are off if you mix Put and Increment . Hows that sound?&lt;/p&gt;


</comment>
                            <comment id="15062719" author="stack" created="Thu, 17 Dec 2015 20:17:41 +0000"  >&lt;p&gt;In backchannel discussion with &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=eclark&quot; class=&quot;user-hover&quot; rel=&quot;eclark&quot;&gt;Elliott Clark&lt;/a&gt;, he makes good argument that this constrained, faster Increment &amp;#8211; one that breaks if Put and Increment address the same Cell &amp;#8211; should be an option you have to turn on since it undoes our strong consistency on row story, if only in an extreme, isolated case. He double-downed with this would be a change on a patch release... so, yeah, let me make this behavior something you have to turn on.&lt;/p&gt;

&lt;p&gt;So, let me work up a patch that is for Increment only for branch-1 that needs to be enabled and that is clear on the pros and cons. Meantime, keep the great feedback coming. Thanks.&lt;/p&gt;</comment>
                            <comment id="15062767" author="eclark" created="Thu, 17 Dec 2015 20:42:20 +0000"  >&lt;blockquote&gt;&lt;p&gt;Patch should be for Increments only with big warning that bets are off if you mix Put and Increment &lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We would only need that for 1.1 and 1.0 based branches. Can we gate that behind something the user can turn on or off? Conf, mutation attribute, or overload the durability for increment. The perf win is big enough that I can see people on older versions really needing this. We just should go for the least surprise of anyone who doesn&apos;t know about this jira.&lt;/p&gt;

&lt;p&gt;For branch-1.2, branch-1, and master we can just hold the lock longer in doMiniBatchMutation and then there&apos;s no need for read-uncommitted.&lt;/p&gt;</comment>
                            <comment id="15062769" author="eclark" created="Thu, 17 Dec 2015 20:43:48 +0000"  >&lt;blockquote&gt;&lt;p&gt;So, let me work up a patch that is for Increment only for branch-1 that needs to be enabled&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;We only need the flag for branch-1.1 and branch-1.0. branch-1 can get the real always on patch.&lt;/p&gt;</comment>
                            <comment id="15062779" author="stack" created="Thu, 17 Dec 2015 20:50:08 +0000"  >&lt;blockquote&gt;&lt;p&gt;For branch-1.2, branch-1, and master we can just hold the lock longer in doMiniBatchMutation and then there&apos;s no need for read-uncommitted.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;d like to do general perf compare first before doing above. Will do in another issue.&lt;/p&gt;

&lt;p&gt;I believe I need the READ_UNCOMMITTED in this patch because mvcc is global to the region. At the end of the increment I add my write to mvcc but other writes that have not yet completed may hold up my write being &apos;committed&apos; in mvcc... meantime a new Increment could come in and not see the just-written value in memstore.&lt;/p&gt;

&lt;p&gt;Thanks Elliott.&lt;/p&gt;</comment>
                            <comment id="15062802" author="eclark" created="Thu, 17 Dec 2015 20:59:30 +0000"  >&lt;blockquote&gt;&lt;p&gt;I believe I need the READ_UNCOMMITTED in this patch because mvcc is global to the region.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yeah but if you hold the row lock until after the mvcc is completed on every transaction then getting the write lock on a row means that there are no outstanding transactions on a row.&lt;/p&gt;</comment>
                            <comment id="15062816" author="stack" created="Thu, 17 Dec 2015 21:07:06 +0000"  >&lt;blockquote&gt;&lt;p&gt;Yeah but if you hold the row lock until after the mvcc is completed on every transaction then getting the write lock on a row means that there are no outstanding transactions on a row.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Nod. Will do in the all-encompassing retrofit. Thanks.&lt;/p&gt;</comment>
                            <comment id="15068543" author="stack" created="Tue, 22 Dec 2015 18:53:23 +0000"  >&lt;p&gt;Patch for branch-1.0. This is what I&apos;m going to fix first. This patch tries to minimize change. Master branch will be very different with a radical redo (it is warranted given the code duplication and duplication of record keeping; i.e. we  keep all Cells incremented twice... once as standalone list and then again inside in FSWALEntry.  Here is the commit log message:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Patch &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; branch-1.0 first. Will address later branches with a different
approach (a more radical fixup). Here we are trying to be safe making  minimal
change.

This patch adds a fast increment. To enable it you set the below configuration
to &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt; in your hbase-site.xml configuration:

      hbase.increment.fast.but.narrow.consistency

This sets region to take the fast increment path. Constraint is that caller
can only access the  Cell via Increment; intermixing Increment with other
Mutations will give indeterminate results. Get will work or an Increment of zero
will &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; current value.

So, to add the above, we effectively copy/paste current Increment after doing
a bunch of work to &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; and move common code out into methods that can be
shared. Current increment becomes a &lt;span class=&quot;code-keyword&quot;&gt;switch&lt;/span&gt; and dependent on config we take the
slow but consistent or the fast but narrowly consistent code path. Increment
code path has too much state that it needs to keep up so hard to shrink it down more
than what we have here without radical refactor (TODO in master patch; the
refactor is needed because even cursory exploration has us DUPLICATING lists
of Cells ... some of which is addressed on fast path here but more to &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt;; fast
path also simplifies the write to hbase so am able to drop some of the state
keeping).

Adds a carryForward set of methods &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; Tags handling which allows us clean up
some duplicated code.

So, difference between fastAndNarrowConsistencyIncrement and slowButConsistentIncrement is
that the former holds the row lock until the sync completes; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; allows us to reason that
there are no other writers afoot when we read the current increment value. This means
we &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; not wait on mvcc reads to &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; up to writes before we proceed with the read, the
root of the slowdown seen in HBASE-14460. The fast-path also does not wait on mvcc to
complete before returning to the client and we reorder the write so that the update of
memstore happens AFTER sync returns; i.e. the write pipeline is less zigzagging now.

Added some simple concurrency testing and then a performance testing tool &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;
Increments.

Added test that Increment of zero amount returns the current Increment value.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="15068546" author="stack" created="Tue, 22 Dec 2015 18:55:29 +0000"  >&lt;p&gt;Doing the branch-1.0 patch as a subtask.&lt;/p&gt;</comment>
                            <comment id="15111221" author="stack" created="Thu, 21 Jan 2016 20:15:55 +0000"  >&lt;p&gt;Added release note on approach going on in here. (Unfortunately,) We have three different changes made under the rubric of this issue. In the branch-1.0 (and branch-1.1)  fix, &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15031&quot; title=&quot;Fix merge of MVCC and SequenceID performance regression in branch-1.0 for Increments&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15031&quot;&gt;&lt;del&gt;HBASE-15031&lt;/del&gt;&lt;/a&gt;, and in the branch-1.2+ fix, &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15091&quot; title=&quot;Forward-port to 1.2+ HBASE-15031 &amp;quot;Fix merge of MVCC and SequenceID performance regression in branch-1.0 for Increments&amp;quot;&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15091&quot;&gt;&lt;del&gt;HBASE-15091&lt;/del&gt;&lt;/a&gt;, we address the Increment slow down only; you set a flag to take a &apos;fast path&apos; for Increments only. The patches for branch-1.0+branch-1.1 and that for branch-1.2+ differ pretty substantially mostly because &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12751&quot; title=&quot;Allow RowLock to be reader writer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12751&quot;&gt;&lt;del&gt;HBASE-12751&lt;/del&gt;&lt;/a&gt; changed the theatre of operation. The fix for master branch is a general fix. It builds on the changes in branch-1 taking the &apos;fast path&apos; only for increments but then changes the write path for all updates in hbase &amp;#8211; appends, checkAnd* AND the ho-hum batchMutate, doMiniBatchMutate, etc., &amp;#8211; to do similar, making all changes under row lock, including sync and mvcc catchup, so append and checkAnd* can take the same &apos;fast path&apos; and we can continue to honor our consistency-on-a-row tenet. Doing all under a lock was intentionally avoided in the past for performance reasons but &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12751&quot; title=&quot;Allow RowLock to be reader writer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12751&quot;&gt;&lt;del&gt;HBASE-12751&lt;/del&gt;&lt;/a&gt; (row locks are read/write rather than xclusive) plus all that has changed in the write path since changes the lay of the land; &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15046&quot; title=&quot;Perf test doing all mutation steps under row lock&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15046&quot;&gt;&lt;del&gt;HBASE-15046&lt;/del&gt;&lt;/a&gt; seems to show the default path runs a little faster though all now done under lock (more perf testing to follow).&lt;/p&gt;</comment>
                            <comment id="15112673" author="bbeaudreault" created="Fri, 22 Jan 2016 16:56:23 +0000"  >&lt;p&gt;Thanks for the work here guys. A couple questions/comments:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;We are also running into this issue pretty regularly for checkAndPut. A burst of checkAndPuts can easily bring a RegionServer to it&apos;s knees. If we could apply the same fix made for Increments to checkAnd* operations, that would be great.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The vast majority of our Increment and checkAnd* usage could safely use this, but given our environment it&apos;s hard to make that statement cluster-wide.  It would be &lt;b&gt;very&lt;/b&gt; nice if this config could be enable for just particular tables (or, if possible, CFs within a table).&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15112690" author="stack" created="Fri, 22 Jan 2016 17:05:19 +0000"  >&lt;p&gt;Hey &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=bbeaudreault&quot; class=&quot;user-hover&quot; rel=&quot;bbeaudreault&quot;&gt;Bryan Beaudreault&lt;/a&gt; I made &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15159&quot; title=&quot;Fix merge of MVCC and SequenceID performance regression in branch-1.0 for checkAnd* and Append&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15159&quot;&gt;&lt;del&gt;HBASE-15159&lt;/del&gt;&lt;/a&gt; a subtask here. I don&apos;t think it&apos;d be too hard making the branch-1 hack for increments work for checkAnd*... let me take a look. Doing it on a per table or per column-family basis might be tough. Let me report back on &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15159&quot; title=&quot;Fix merge of MVCC and SequenceID performance regression in branch-1.0 for checkAnd* and Append&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15159&quot;&gt;&lt;del&gt;HBASE-15159&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="15135390" author="stack" created="Sat, 6 Feb 2016 01:08:25 +0000"  >&lt;p&gt;Quick update. &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15213&quot; title=&quot;Fix increment performance regression caused by HBASE-8763 on branch-1.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15213&quot;&gt;&lt;del&gt;HBASE-15213&lt;/del&gt;&lt;/a&gt; fixes mvcc. Means we get our perf back for increment, append, and checkAnd* on branch-1.0 and branch-1.1. The same issue, &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15213&quot; title=&quot;Fix increment performance regression caused by HBASE-8763 on branch-1.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15213&quot;&gt;&lt;del&gt;HBASE-15213&lt;/del&gt;&lt;/a&gt;, identifies that hbase-1.2.0 does not suffer the performance regression. It did, but it got fixed by &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12751&quot; title=&quot;Allow RowLock to be reader writer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12751&quot;&gt;&lt;del&gt;HBASE-12751&lt;/del&gt;&lt;/a&gt; which does similar to &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15213&quot; title=&quot;Fix increment performance regression caused by HBASE-8763 on branch-1.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15213&quot;&gt;&lt;del&gt;HBASE-15213&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So, the work done to make an increment &apos;fast path&apos; in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15031&quot; title=&quot;Fix merge of MVCC and SequenceID performance regression in branch-1.0 for Increments&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15031&quot;&gt;&lt;del&gt;HBASE-15031&lt;/del&gt;&lt;/a&gt; for branch-1.0+ where we skirt mvcc when incrementing is now no longer needed. Let me actually remove this option (after &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15213&quot; title=&quot;Fix increment performance regression caused by HBASE-8763 on branch-1.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15213&quot;&gt;&lt;del&gt;HBASE-15213&lt;/del&gt;&lt;/a&gt; goes in).&lt;/p&gt;

&lt;p&gt;Will be back with cleaner messaging on release notes and up on dev mailing list after all gets committed.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12936660">HBASE-15213</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="12310050">
                    <name>Regression</name>
                                                                <inwardlinks description="is broken by">
                                        <issuelink>
            <issuekey id="12653582">HBASE-8763</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12777401" name="0.94.test.patch" size="8932" author="stack" created="Mon, 14 Dec 2015 05:55:44 +0000"/>
                            <attachment id="12777403" name="0.98.test.patch" size="7055" author="stack" created="Mon, 14 Dec 2015 05:55:44 +0000"/>
                            <attachment id="12777883" name="1.0.80.flamegraph-7932.svg" size="703586" author="stack" created="Wed, 16 Dec 2015 01:15:33 +0000"/>
                            <attachment id="12761566" name="14460.txt" size="3769" author="stack" created="Tue, 22 Sep 2015 05:11:16 +0000"/>
                            <attachment id="12779101" name="14460.v0.branch-1.0.patch" size="56334" author="stack" created="Tue, 22 Dec 2015 18:53:23 +0000"/>
                            <attachment id="12777884" name="98.80.flamegraph-11428.svg" size="1017552" author="stack" created="Wed, 16 Dec 2015 01:15:33 +0000"/>
                            <attachment id="12777447" name="HBASE-14460-discussion.patch" size="31034" author="jingcheng.du@intel.com" created="Mon, 14 Dec 2015 10:45:17 +0000"/>
                            <attachment id="12777885" name="client.test.patch" size="6482" author="stack" created="Wed, 16 Dec 2015 01:15:33 +0000"/>
                            <attachment id="12777313" name="flamegraph-13120.svg.master.singlecell.svg" size="932725" author="stack" created="Sat, 12 Dec 2015 23:31:02 +0000"/>
                            <attachment id="12777400" name="flamegraph-26636.094.100.svg" size="505892" author="stack" created="Mon, 14 Dec 2015 05:55:44 +0000"/>
                            <attachment id="12777312" name="flamegraph-28066.098.singlecell.svg" size="578192" author="stack" created="Sat, 12 Dec 2015 23:31:02 +0000"/>
                            <attachment id="12777399" name="flamegraph-28767.098.100.svg" size="841009" author="stack" created="Mon, 14 Dec 2015 05:55:44 +0000"/>
                            <attachment id="12777398" name="flamegraph-31647.master.100.svg" size="656309" author="stack" created="Mon, 14 Dec 2015 05:55:44 +0000"/>
                            <attachment id="12777314" name="flamegraph-9466.094.singlecell.svg" size="473920" author="stack" created="Sat, 12 Dec 2015 23:31:02 +0000"/>
                            <attachment id="12778152" name="hack.flamegraph-16593.svg" size="1056668" author="stack" created="Thu, 17 Dec 2015 01:22:31 +0000"/>
                            <attachment id="12778153" name="hack.uncommitted.patch" size="9705" author="stack" created="Thu, 17 Dec 2015 01:22:31 +0000"/>
                            <attachment id="12777402" name="m.test.patch" size="7060" author="stack" created="Mon, 14 Dec 2015 05:55:44 +0000"/>
                            <attachment id="12761568" name="region_lock.png" size="235328" author="stack" created="Tue, 22 Sep 2015 05:17:38 +0000"/>
                            <attachment id="12777317" name="testincrement.094.patch" size="5393" author="stack" created="Sat, 12 Dec 2015 23:31:02 +0000"/>
                            <attachment id="12777316" name="testincrement.098.patch" size="5179" author="stack" created="Sat, 12 Dec 2015 23:31:02 +0000"/>
                            <attachment id="12777315" name="testincrement.master.patch" size="5059" author="stack" created="Sat, 12 Dec 2015 23:31:02 +0000"/>
                    </attachments>
                <subtasks>
                            <subtask id="12923809">HBASE-15031</subtask>
                            <subtask id="12924586">HBASE-15046</subtask>
                            <subtask id="12928587">HBASE-15082</subtask>
                            <subtask id="12929566">HBASE-15091</subtask>
                            <subtask id="12929660">HBASE-15095</subtask>
                            <subtask id="12933136">HBASE-15153</subtask>
                            <subtask id="12933258">HBASE-15157</subtask>
                            <subtask id="12933263">HBASE-15158</subtask>
                            <subtask id="12933395">HBASE-15159</subtask>
                            <subtask id="12936660">HBASE-15213</subtask>
                            <subtask id="12937233">HBASE-15224</subtask>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>21.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 22 Sep 2015 06:02:59 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            42 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2ldrb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310192" key="com.atlassian.jira.plugin.system.customfieldtypes:textarea">
                        <customfieldname>Release Note</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>This release note tries to tell the general story. Dive into sub-tasks for more specific release noting.&lt;br/&gt;
&lt;br/&gt;
Increments, appends, checkAnd* have been slow since hbase-.1.0.0. The unification of mvcc and sequence id done by &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-8763&quot; title=&quot;Combine MVCC and SeqId&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-8763&quot;&gt;&lt;strike&gt;HBASE-8763&lt;/strike&gt;&lt;/a&gt; was responsible.&lt;br/&gt;
&lt;br/&gt;
A &#8216;fast-path&#8217; workaround was added by &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15031&quot; title=&quot;Fix merge of MVCC and SequenceID performance regression in branch-1.0 for Increments&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15031&quot;&gt;&lt;strike&gt;HBASE-15031&lt;/strike&gt;&lt;/a&gt; &#8220;Fix merge of MVCC and SequenceID performance regression in branch-1.0 for Increments&#8221;. It became available in 1.0.3 and 1.1.3. To enable the fast path, set &amp;quot;hbase.increment.fast.but.narrow.consistency&amp;quot; and then rolling restart. The workaround was for increments only (appends, checkAndPut, etc., were not addressed. See &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15031&quot; title=&quot;Fix merge of MVCC and SequenceID performance regression in branch-1.0 for Increments&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15031&quot;&gt;&lt;strike&gt;HBASE-15031&lt;/strike&gt;&lt;/a&gt; release note for more detail).&lt;br/&gt;
&lt;br/&gt;
Subsequently, the regression was properly identified and fixed in &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15213&quot; title=&quot;Fix increment performance regression caused by HBASE-8763 on branch-1.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15213&quot;&gt;&lt;strike&gt;HBASE-15213&lt;/strike&gt;&lt;/a&gt; and the fix applied to branch-1.0 and branch-1.1. As it happens, hbase-1.2.0 does not suffer from the performance regression (though the thought was that it did -- and so it got the fast-path patch too via &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15092&quot; title=&quot;HBase personality should order modules correctly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15092&quot;&gt;&lt;strike&gt;HBASE-15092&lt;/strike&gt;&lt;/a&gt;) nor does the master branch. &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15213&quot; title=&quot;Fix increment performance regression caused by HBASE-8763 on branch-1.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15213&quot;&gt;&lt;strike&gt;HBASE-15213&lt;/strike&gt;&lt;/a&gt; identified that &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-12751&quot; title=&quot;Allow RowLock to be reader writer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-12751&quot;&gt;&lt;strike&gt;HBASE-12751&lt;/strike&gt;&lt;/a&gt; (as a side effect) had cured the regression.&lt;br/&gt;
&lt;br/&gt;
hbase-1.0.4 (if it is ever released -- 1.0 has been end-of-lifed) and hbase-1.1.4 will have the &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-15213&quot; title=&quot;Fix increment performance regression caused by HBASE-8763 on branch-1.0&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-15213&quot;&gt;&lt;strike&gt;HBASE-15213&lt;/strike&gt;&lt;/a&gt; fix.  If you are suffering from the increment regression and you are on 1.0.3 or 1.1.3, you can enable the work around to get back your increment performance but you should upgrade.</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>