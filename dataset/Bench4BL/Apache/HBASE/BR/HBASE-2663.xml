<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat Dec 03 15:49:13 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/HBASE-2663/HBASE-2663.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[HBASE-2663] LRU cache makes needless datastructure copies during eviction</title>
                <link>https://issues.apache.org/jira/browse/HBASE-2663</link>
                <project id="12310753" key="HBASE">HBase</project>
                    <description>&lt;p&gt;Was browsing the LRU eviction code and came upon some very inefficient code. When we do eviction, BlockBucket.free() calls queue.get() which first inserts everything from the PriorityQueue&amp;lt;Block&amp;gt; into a LinkedList, then copies that entire linked list into an array. We then iterate over usually just a small percentage of the array to free some blocks until we have freed the requested amount.&lt;/p&gt;

&lt;p&gt;We ought to be able to just pull items out of the PriorityQueue directly and avoid all the churn.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12466141">HBASE-2663</key>
            <summary>LRU cache makes needless datastructure copies during eviction</summary>
                <type id="4" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="3">Duplicate</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="tlipcon">Todd Lipcon</reporter>
                        <labels>
                    </labels>
                <created>Thu, 3 Jun 2010 23:07:16 +0000</created>
                <updated>Tue, 20 May 2014 00:19:08 +0000</updated>
                            <resolved>Tue, 20 May 2014 00:19:08 +0000</resolved>
                                                                    <component>regionserver</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                <comments>
                            <comment id="12891314" author="stack" created="Thu, 22 Jul 2010 20:12:19 +0000"  >&lt;p&gt;What you thinking?  A PriorityDequeue?  An implementation is not easy to come by.  It&apos;d be less performant keeping sort up on both ends.  I wonder if we just used a NavigableSet, if that&apos;d be performant enough.  We&apos;d have to change the compare to take into consideration priority.&lt;/p&gt;</comment>
                            <comment id="12892573" author="tlipcon" created="Tue, 27 Jul 2010 00:48:59 +0000"  >&lt;p&gt;Why not track the blocks through a linked list, drop the &quot;accessTime&quot; member, and whenever it&apos;s accessed, move it to the front of the list? Then when we want to evict, just scan from the end of the list?&lt;/p&gt;

&lt;p&gt;At least we could avoid the complete shallow copy into a LinkedList at LruBlockCache.java:422 - here we copy the entire PriorityQueue out into a LinkedList when we call queue.get(), and then we only iterate the first couple elements of the linked list. Instead, we could just pull elements off the PrioritiyQueue directly, one by one, evicting until we&apos;ve evicted enough.&lt;/p&gt;</comment>
                            <comment id="12892607" author="stack" created="Tue, 27 Jul 2010 02:02:19 +0000"  >&lt;blockquote&gt;&lt;p&gt;Then when we want to evict, just scan from the end of the list&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;You&apos;d use the LinkedList in addition to PriorityQueue, just so pull off the end of the queue?  Or you thinking dump PriorityQueue and just use LinkedList (do they have same add/remove characteristic?).&lt;/p&gt;

&lt;p&gt;You&apos;d run three linked lists, one for SINGLE, MULTI and MEMORY (see head of BlockPriority)?&lt;/p&gt;

&lt;p&gt;We&apos;d need to keep running counts on each of the three linked lists lettting any of them grow to fill space unused by others?&lt;/p&gt;</comment>
                            <comment id="12893148" author="streamy" created="Wed, 28 Jul 2010 12:00:08 +0000"  >&lt;p&gt;The implementation of the lru was originally intended to put all overhead at eviction time and as little as possible for reads/writes.  This included an attempted lock-free design based around the ConcurrentHashMap as the data structure for blocks.&lt;/p&gt;

&lt;p&gt;Given we&apos;re in java land, this background memory usage still impacts us, not sure how significant, but for sure it&apos;s lots of objects.&lt;/p&gt;

&lt;p&gt;You could get rid of the shallow copy into the structure that sorts by accessTime by keeping an up-to-date linked list for each priority.  I think you need to roll your own LL implementation because the java one won&apos;t let you get the LL pointers referenced into some other object (you want a LL but you also need a constant time operation like removeAndPushToFront).  Needs to be thread-safe too, blocks being updated by concurrent reads and a concurrent eviction process.&lt;/p&gt;

&lt;p&gt;You&apos;d still have to iterate the entire list and calculate the total sizes for each priority and you&apos;ll still need the hash map, right?&lt;/p&gt;

&lt;p&gt;So then, in the end, are you using the same amount of memory but keeping it around and maintaining it in order versus re-allocating and calculating on the fly at eviction time?&lt;/p&gt;</comment>
                            <comment id="12893152" author="streamy" created="Wed, 28 Jul 2010 12:11:24 +0000"  >&lt;p&gt;i see the original copy you are talking about.  can definitely clean that up but i still think the other thoughts floating around are valid on a more broad scope.&lt;/p&gt;

&lt;p&gt;one thing to note about the copy in queue.get()  is that we don&apos;t usually iterate just a small percentage of what is in the queue.  The queue won&apos;t contain all the blocks, just the minimum number of least-recently-used blocks that would need to be evicted given a specified max to free.  We pass in the maximum amount of bytes that would possibly have to be freed from each priority.  So we won&apos;t always iterate all of them, but not too bad.  still definitely should fix it.&lt;/p&gt;</comment>
                            <comment id="12893262" author="stack" created="Wed, 28 Jul 2010 17:19:06 +0000"  >&lt;blockquote&gt;&lt;p&gt;You&apos;d still have to iterate the entire list and calculate the total sizes for each priority and you&apos;ll still need the hash map, right?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The traversal can be avoided by keeping a running size that gets updated on adds and removes?&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;...you also need a &lt;span class=&quot;error&quot;&gt;&amp;#91;thread-safe&amp;#93;&lt;/span&gt; constant time operation like removeAndPushToFront..&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This&apos;d be the interesting bit.&lt;/p&gt;

&lt;p&gt;FYI, this change, 674cf0d9b0648d146d5a67d95443826f1298b27a, got rid of the creation of an array of CachedBlocks &amp;#8211; instead we just return the just-made LL instead and iterate that.  e.g.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
@@ -414,10 +419,10 @@ &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class LruBlockCache &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; BlockCache, HeapSize {
     }
 
     &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; free(&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; toFree) {
-      CachedBlock [] blocks = queue.get();
+      LinkedList&amp;lt;CachedBlock&amp;gt; blocks = queue.get();
       &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; freedBytes = 0;
-      &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i=0; i&amp;lt;blocks.length; i++) {
-        freedBytes += evictBlock(blocks[i]);
+      &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;(CachedBlock cb: blocks) {
+        freedBytes += evictBlock(cb);
         &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(freedBytes &amp;gt;= toFree) {
           &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; freedBytes;
         }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
</comment>
                            <comment id="12893323" author="streamy" created="Wed, 28 Jul 2010 19:31:23 +0000"  >&lt;blockquote&gt;&lt;p&gt;The traversal can be avoided by keeping a running size that gets updated on adds and removes?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Yeah, you&apos;d have to keep running tabs on the size of each priority (and decrement it when evicting) in addition to keeping the up-to-date LRU linked list.  I went the way of keeping locks out of the get/set path and pushing overhead to eviction.  If we track as we go, we&apos;ll introduce a number of locks.&lt;/p&gt;

&lt;p&gt;I&apos;m just unsure of a clear win here.  Only if it&apos;s truly a non-trivial amount of overhead to do the iteration and build the PQ does pushing overhead into the getter/setters make sense.&lt;/p&gt;

&lt;p&gt;In that case, would we then no longer use a background eviction thread?  The benefit is you never hold up get/set with eviction (trade-off is you can&apos;t utilize the entire cache to the brim since you rely on high/low watermarks rather than checking for capacity on each set).  But if the eviction thread actually acts directly against the sorted linked lists and the actively-tracked priority sizes, it will need to at least partially lock these things during the eviction process so new gets/sets don&apos;t interfere with an active eviction process.&lt;/p&gt;</comment>
                            <comment id="12893359" author="ryanobjc" created="Wed, 28 Jul 2010 20:43:36 +0000"  >&lt;p&gt;So there is another thing here, by deferring the evictions to the&lt;br/&gt;
background thread you increase the chance that the block will be&lt;br/&gt;
tenured then it must be collected from CMS space, thus radically&lt;br/&gt;
increasing the GC complexity of the cache.  Originally when the LRU&lt;br/&gt;
block cache came in, it made my collections 10x as slow until I&lt;br/&gt;
disabled the block cache for compactions.&lt;/p&gt;

&lt;p&gt;Unfortunately all these micro-optimizations might be falling under the&lt;br/&gt;
GC wayside.&lt;/p&gt;

</comment>
                            <comment id="12893389" author="streamy" created="Wed, 28 Jul 2010 22:00:25 +0000"  >&lt;p&gt;@Ryan, not sure I follow.  In what case do you not &quot;defer evictions&quot;?  I don&apos;t see how the blocks tenuring would be impacted by the approaches discussed above.  In all cases they would still be in the cache for the same amount of time and with same numbers of accesses?  In the case that we keep things up to date, we&apos;ll access more objects more often so more ref counting.  Am I missing something?&lt;/p&gt;</comment>
                            <comment id="14002629" author="stack" created="Tue, 20 May 2014 00:19:08 +0000"  >&lt;p&gt;A later issue that describes the same issue &apos;fixes&apos; this: &lt;a href=&quot;https://issues.apache.org/jira/browse/HBASE-4752&quot; title=&quot;Don&amp;#39;t create an unnecessary LinkedList when evicting from the BlockCache&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HBASE-4752&quot;&gt;&lt;del&gt;HBASE-4752&lt;/del&gt;&lt;/a&gt;  Resolving.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12472991">HBASE-2945</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 22 Jul 2010 20:12:19 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>32703</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            2 years, 28 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i02fl3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>12126</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>