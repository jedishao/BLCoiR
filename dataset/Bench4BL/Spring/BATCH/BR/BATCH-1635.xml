<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 11:22:24 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/BATCH-1635/BATCH-1635.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[BATCH-1635] Spring Batch and Hibernate Search do not work together</title>
                <link>https://jira.spring.io/browse/BATCH-1635</link>
                <project id="10090" key="BATCH">Spring Batch</project>
                    <description>&lt;p&gt;We are having a problem when using spring batch and hibernate search together.   Basically when hibernate search needs to lazy load a entity using indexing (which occurs during the commit processing) we get a lazy load exception (org.hibernate.LazyInitializationException: could not initialize proxy - no Session).&lt;/p&gt;

&lt;p&gt;I&apos;m pretty sure this problem is caused by the call to hibernateTemplate.clear() in HibernateItemWriter:&lt;/p&gt;

&lt;p&gt;	public final void write(List&amp;lt;? extends T&amp;gt; items) {&lt;br/&gt;
		doWrite(hibernateTemplate, items);&lt;br/&gt;
		try &lt;/p&gt;
{
			hibernateTemplate.flush();
		}
&lt;p&gt;		finally &lt;/p&gt;
{
			// This should happen when the transaction commits anyway, but to be
			// sure...
			hibernateTemplate.clear();
		}
&lt;p&gt;	}&lt;/p&gt;

&lt;p&gt;As the affect of this is also to clear the session on any hibernate proxies.  &lt;/p&gt;

&lt;p&gt;As the comment says, the clear should not be needed and I would suggest either removing it or at least making it configurable.&lt;/p&gt;</description>
                <environment></environment>
        <key id="33533">BATCH-1635</key>
            <summary>Spring Batch and Hibernate Search do not work together</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://jira.spring.io/images/icons/priorities/minor.png">Minor</priority>
                        <status id="5" iconUrl="https://jira.spring.io/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="8">Complete</resolution>
                                        <assignee username="david_syer">Dave Syer</assignee>
                                    <reporter username="damien.hollis">Damien Hollis</reporter>
                        <labels>
                    </labels>
                <created>Mon, 27 Sep 2010 22:22:29 +0000</created>
                <updated>Wed, 1 Jun 2011 02:42:42 +0000</updated>
                            <resolved>Thu, 3 Feb 2011 09:43:59 +0000</resolved>
                                    <version>2.1.3</version>
                                    <fixVersion>2.1.6</fixVersion>
                                    <component>Core</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                    <timeoriginalestimate seconds="7200">0.25d</timeoriginalestimate>
                            <timeestimate seconds="7200">0.25d</timeestimate>
                                        <comments>
                            <comment id="58522" author="david_syer" created="Tue, 28 Sep 2010 00:35:37 +0000"  >&lt;p&gt;I&apos;m not very familiar with Hibernate Search.  How come the Session doesn&apos;t flush all its changes on the explicit call to flush() above?  Can you paste the stack trace and/or provide some sample code?  If you have a test case that would be really good.&lt;/p&gt;</comment>
                            <comment id="63026" author="jserdaru" created="Wed, 2 Feb 2011 14:29:44 +0000"  >&lt;p&gt;Actually I have a similar issue using Spring, JTA/JPA and Spring Batch. Hibernate Search registers a Post-Completion synchronization callback in order to perform the indexing of items modified in the current transaction. &lt;/p&gt;

&lt;p&gt;At this point, some lazy loading exceptions can happen since the hibernate Session lifecycle seems to be handled manually by Spring Batch, and has been closed at this point. I bypassed the issue so far by disabling automatic indexing in Hibernate Search and manually indexing the entire database after a batch. This works but is not the desired behavior. I think manually indexing/re-attaching the entities in the writer could also work. This problem is not reproducible in a web-application when using the OpenSessionInView pattern which maintains a hibernate Session open throughout an HTTP request lifecycle. &lt;/p&gt;

&lt;p&gt;I have been in touch with Lucas on this issue and I&apos;m trying various alternative. Will keep you posted if I find anything useful or manage to isolate a unit test.&lt;/p&gt;

&lt;p&gt;For what it&apos;s worth, my stack trace is the following:&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;taskExecutor-1&amp;#93;&lt;/span&gt; ERROR tializationException - failed to lazily initialize a collection of role: com.joss.common.domain.City.attributes, no session or session was closed&lt;br/&gt;
org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role: com.joss.common.domain.City.attributes, no session or session was closed&lt;br/&gt;
	at org.hibernate.collection.AbstractPersistentCollection.throwLazyInitializationException(AbstractPersistentCollection.java:380)&lt;br/&gt;
	at org.hibernate.collection.AbstractPersistentCollection.throwLazyInitializationExceptionIfNotConnected(AbstractPersistentCollection.java:372)&lt;br/&gt;
	at org.hibernate.collection.AbstractPersistentCollection.initialize(AbstractPersistentCollection.java:365)&lt;br/&gt;
	at org.hibernate.collection.AbstractPersistentCollection.read(AbstractPersistentCollection.java:108)&lt;br/&gt;
	at org.hibernate.collection.PersistentSet.iterator(PersistentSet.java:186)&lt;br/&gt;
	at org.hibernate.search.engine.DocumentBuilderIndexedEntity.buildDocumentFields(DocumentBuilderIndexedEntity.java:436)&lt;br/&gt;
	at org.hibernate.search.engine.DocumentBuilderIndexedEntity.buildDocumentFields(DocumentBuilderIndexedEntity.java:450)&lt;br/&gt;
	at org.hibernate.search.engine.DocumentBuilderIndexedEntity.getDocument(DocumentBuilderIndexedEntity.java:380)&lt;br/&gt;
	at org.hibernate.search.engine.DocumentBuilderIndexedEntity.createAddWork(DocumentBuilderIndexedEntity.java:328)&lt;br/&gt;
	at org.hibernate.search.engine.DocumentBuilderIndexedEntity.addWorkToQueue(DocumentBuilderIndexedEntity.java:300)&lt;br/&gt;
	at org.hibernate.search.backend.impl.BatchedQueueingProcessor.addWorkToBuilderQueue(BatchedQueueingProcessor.java:153)&lt;br/&gt;
	at org.hibernate.search.backend.impl.BatchedQueueingProcessor.processWorkByLayer(BatchedQueueingProcessor.java:140)&lt;br/&gt;
	at org.hibernate.search.backend.impl.BatchedQueueingProcessor.prepareWorks(BatchedQueueingProcessor.java:128)&lt;br/&gt;
	at org.hibernate.search.backend.impl.PostTransactionWorkQueueSynchronization.beforeCompletion(PostTransactionWorkQueueSynchronization.java:47)&lt;br/&gt;
	at bitronix.tm.BitronixTransaction.fireBeforeCompletionEvent(BitronixTransaction.java:397)&lt;br/&gt;
	at bitronix.tm.BitronixTransaction.commit(BitronixTransaction.java:147)&lt;br/&gt;
	at bitronix.tm.BitronixTransactionManager.commit(BitronixTransactionManager.java:95)&lt;br/&gt;
	at org.springframework.transaction.jta.JtaTransactionManager.doCommit(JtaTransactionManager.java:1009)&lt;br/&gt;
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommit(AbstractPlatformTransactionManager.java:754)&lt;br/&gt;
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:723)&lt;br/&gt;
	at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:147)&lt;br/&gt;
	at org.springframework.batch.core.step.tasklet.TaskletStep$2.doInChunkContext(TaskletStep.java:262)&lt;br/&gt;
	at org.springframework.batch.core.scope.context.StepContextRepeatCallback.doInIteration(StepContextRepeatCallback.java:76)&lt;br/&gt;
	at org.springframework.batch.repeat.support.RepeatTemplate.getNextResult(RepeatTemplate.java:367)&lt;br/&gt;
	at org.springframework.batch.repeat.support.RepeatTemplate.executeInternal(RepeatTemplate.java:214)&lt;br/&gt;
	at org.springframework.batch.repeat.support.RepeatTemplate.iterate(RepeatTemplate.java:143)&lt;br/&gt;
	at org.springframework.batch.core.step.tasklet.TaskletStep.doExecute(TaskletStep.java:248)&lt;br/&gt;
	at org.springframework.batch.core.step.AbstractStep.execute(AbstractStep.java:195)&lt;br/&gt;
	at org.springframework.batch.core.job.SimpleStepHandler.handleStep(SimpleStepHandler.java:135)&lt;br/&gt;
	at org.springframework.batch.core.job.flow.JobFlowExecutor.executeStep(JobFlowExecutor.java:61)&lt;br/&gt;
	at org.springframework.batch.core.job.flow.support.state.StepState.handle(StepState.java:60)&lt;br/&gt;
	at org.springframework.batch.core.job.flow.support.SimpleFlow.resume(SimpleFlow.java:144)&lt;br/&gt;
	at org.springframework.batch.core.job.flow.support.SimpleFlow.start(SimpleFlow.java:124)&lt;br/&gt;
	at org.springframework.batch.core.job.flow.FlowJob.doExecute(FlowJob.java:135)&lt;br/&gt;
	at org.springframework.batch.core.job.AbstractJob.execute(AbstractJob.java:281)&lt;br/&gt;
	at org.springframework.batch.core.launch.support.SimpleJobLauncher$1.run(SimpleJobLauncher.java:120)&lt;br/&gt;
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(Unknown Source)&lt;br/&gt;
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)&lt;br/&gt;
	at java.lang.Thread.run(Unknown Source)&lt;/p&gt;</comment>
                            <comment id="63027" author="lucas.l.ward" created="Wed, 2 Feb 2011 14:37:42 +0000"  >&lt;p&gt;I think this is still a classic hibernate detached object issue.  Because the writer is called in a separate transaction but the object obtained from the session is what is passed, then there&apos;s an issue.  I know you&apos;re using this in the processor, but it&apos;s probably better in the writer.  However, for a long time we have recommended using the hibernate Batch specific session.  This is because hibernate&apos;s session is fundamentally designed for the web request lifecycle and not a long running batch process.  Though, in your case it&apos;s tricky because you would like to update your objects through the normal hibernate hook that allows for the index to be updated as part of the write.  However, I&apos;m not sure this will ever make the same sense in batch.  It may be best to just manually update the index in the same way as the hibernate interceptor after the chunk is done.&lt;/p&gt;</comment>
                            <comment id="63041" author="david_syer" created="Thu, 3 Feb 2011 01:25:22 +0000"  >&lt;p&gt;Sounds about right: if you use Hibernate for reading and writing that means two sessions.  You would have the same problem if you tried to visit the lazy loaded references yourself in the writer or processor, which you should be able to verify quite easily.  The best fix is probably to attach the entities to the current (transactional) session before doing anything in your processor (session.lock(...)).&lt;/p&gt;

&lt;p&gt;If we can verify this is the problem, all we need to do is document it I think, unless you can think of a way to make it automatic or easier.&lt;/p&gt;</comment>
                            <comment id="63045" author="damien.hollis" created="Thu, 3 Feb 2011 01:58:09 +0000"  >&lt;p&gt;Sorry, I didn&apos;t notice you had commented on this back in September.&lt;/p&gt;

&lt;p&gt;The stacktrace I have is basically the same as the one Julien reported (I can provide it if necessary).  &lt;/p&gt;

&lt;p&gt;To answer Dave&apos;s first question about why the changes aren&apos;t written to the index when an explicit flush is called, I would imagine that because lucene is not transactional hibernate search waits until it is confident that the database commit will success (or probably has completed) and then updates the indexes.  Otherwise there would be no practical way to rollback index changes if the transaction failed.&lt;/p&gt;

&lt;p&gt;I don&apos;t think we are dealing with a classic detached object problem because we solved it by copying your implementation of HibernateItemWriter and removing the explicit clear.  We also only get ids in the Reader and the Writer does all the real work.&lt;/p&gt;

&lt;p&gt;Let me know if you need any more info? &lt;/p&gt;</comment>
                            <comment id="63056" author="david_syer" created="Thu, 3 Feb 2011 09:43:58 +0000"  >&lt;p&gt;That was easy then.&lt;/p&gt;</comment>
                            <comment id="66401" author="kyrill007" created="Sun, 15 May 2011 12:47:44 +0000"  >&lt;p&gt;Hmm... It is sad that you removed session clearing at the chunk boundary. It is crucial from performance perspective to not let Hibernate session grow unconstrained. We relied quite heavily one on it. The deal with Hibernate Search is, I don&apos;t know how to put it, well, pathetic? I mean all the developer has to do is load the index-able object graph in memory before transaction commits, which has to happen anyway. There is no need to keep the session &quot;uncleared&quot;, all one needs to do is make index-able entities are reachable, they don&apos;t need to sit in session.&lt;/p&gt;</comment>
                            <comment id="66953" author="david_syer" created="Wed, 1 Jun 2011 01:42:53 +0000"  >&lt;p&gt;Kyrill, good point (must be a brain fart).  I think maybe I&apos;ll sneak it back in as the default in 2.1.8 (with a boolean property to switch it off, so if anyone doesn&apos;t believe your argument they can try it out).  See &lt;a href=&quot;https://jira.spring.io/browse/BATCH-1759&quot; title=&quot;Restore default behaviour in HibernateItemWriter (clear Session to prevent memory leak)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BATCH-1759&quot;&gt;&lt;del&gt;BATCH-1759&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="66959" author="damien.hollis" created="Wed, 1 Jun 2011 02:42:42 +0000"  >&lt;p&gt;I agree with allowing this feature again, as long as it&apos;s switchable - as per your proposal.&lt;/p&gt;

&lt;p&gt;Btw: I agree with Kyrill&apos;s comment that hibernate search should handle session clear but his solution wouldn&apos;t be as easy as he suggests. Once the session is cleared there are no references to the objects that were in the session.  So there is no way to reload the object graphs.  The only way that would work is that as each object is flushed by hibernate, hibernate search would need to keep a reference to the object id.   &lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 28 Sep 2010 00:35:37 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10280" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11100</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i03uv3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>22542</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10381" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Ranking</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>19015</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>