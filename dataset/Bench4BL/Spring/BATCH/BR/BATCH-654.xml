<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 11:17:43 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/BATCH-654/BATCH-654.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[BATCH-654] Ensure best efforts are made to commit StepExecution when commit fails</title>
                <link>https://jira.spring.io/browse/BATCH-654</link>
                <project id="10090" key="BATCH">Spring Batch</project>
                    <description>&lt;p&gt;When the commit operation fails in an ItemOrientedStep, the writing of the Spring Batch metadata fails (trying to write the rollback information). &lt;/p&gt;

&lt;p&gt;When trying to commit the transaction, SB has already set the information it&apos;s about to persist in the StepExecutionContext. Then, in another transaction, SB wants to store that a rollback ocurred. Nevertheless, SB hasn&apos;t read the current persisted state from the database, so it still has the Version it read when trying to commit. That&apos;s why we think it fails.&lt;/p&gt;

&lt;p&gt;Furthermore, even if it succeeded, the persisted information wouldn&apos;t be accurate, because, as I&apos;ve pointed out, the StepExecutionContext hasn&apos;t been reset.&lt;/p&gt;</description>
                <environment>Noticed the failure when using JTA, with JOTM.</environment>
        <key id="22482">BATCH-654</key>
            <summary>Ensure best efforts are made to commit StepExecution when commit fails</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="david_syer">Dave Syer</assignee>
                                    <reporter username="telematica">Telematica</reporter>
                        <labels>
                    </labels>
                <created>Thu, 5 Jun 2008 02:31:58 +0000</created>
                <updated>Thu, 7 Aug 2008 02:07:12 +0000</updated>
                            <resolved>Tue, 17 Jun 2008 20:47:51 +0000</resolved>
                                    <version>1.0.1</version>
                                    <fixVersion>1.1.0</fixVersion>
                                    <component>Core</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                    <timeoriginalestimate seconds="7200">0.25d</timeoriginalestimate>
                            <timeestimate seconds="0">0d</timeestimate>
                            <timespent seconds="7200">0.25d</timespent>
                                <comments>
                            <comment id="36479" author="david_syer" created="Thu, 5 Jun 2008 02:50:18 +0000"  >&lt;p&gt;I&apos;m not entirely sure what the problem is here.  If a commit fails then the system is almost by definition in an inconsistent state.  You can&apos;t really expect anything sensible to happen after a failed commit - even a rollback would not be trusted.  I must be misunderstanding something, so can you show an example of what might happen, and what you think should happen in the scenario you describe?&lt;/p&gt;</comment>
                            <comment id="36483" author="robert.kasanicky" created="Thu, 5 Jun 2008 03:30:18 +0000"  >&lt;p&gt;When the metadata database is separate from business database we should be storing &apos;FAILED&apos; (or maybe &apos;UNKNOWN&apos;) status for the StepExecution if the business database failed to commit.&lt;/p&gt;</comment>
                            <comment id="36510" author="robert.kasanicky" created="Thu, 5 Jun 2008 18:49:25 +0000"  >&lt;p&gt;I&apos;m wondering about the priority of the issue - I suppose the JobExecution metadata gets written and only the StepExecution is left in inconsistent state. The job therefore can&apos;t be restarted which is fine because the actual state is undefined as Dave pointed out.&lt;/p&gt;

&lt;p&gt;So I think the high level behavior is correct (job&apos;s status is &apos;FAILED&apos; and can&apos;t be restarted), but the error message is misleading and StepExecution&apos;s status should be set to &apos;UNKNOWN&apos;. It is also very unlikely to occur (successful flush but failed commit immediately after). Not really a blocker issue I think - or am I missing something?&lt;/p&gt;</comment>
                            <comment id="36516" author="david_syer" created="Thu, 5 Jun 2008 22:18:39 +0000"  >&lt;p&gt;I agree - changed the priority.  We should be able to set the StepExecution status and maybe the exit message (I thought the message was something clear like &quot;commit failed&quot;, but maybe it could be clearer if we say that the result is an undefined state and restart is impossible as well).&lt;/p&gt;</comment>
                            <comment id="36526" author="robert.kasanicky" created="Fri, 6 Jun 2008 01:40:54 +0000"  >&lt;p&gt;I think I was wrong about the &apos;job can&apos;t be restarted&apos;. Job only checks for &apos;UNKNOWN&apos; status to refuse restart, but in this case we&apos;ll end up with &apos;STARTED&apos; (we&apos;ll fail to write UNKNOWN due to OptimisticLockingFailure). The same scenario applies for failed update of the execution context which we definitely need to handle well.&lt;/p&gt;</comment>
                            <comment id="36527" author="lucas.l.ward" created="Fri, 6 Jun 2008 01:44:32 +0000"  >&lt;p&gt;Regarding flush.  I think it&apos;s assumed if you&apos;re a restartable writer that after a failure you have to check to ensure that the state you had stored in the execution context is consistent with where you&apos;re going to start writing.  In the example of a file, if there&apos;s extra lines on top of what the execution context says you should have, the file should be truncated to the EC indicated level&lt;/p&gt;</comment>
                            <comment id="36529" author="wxlund" created="Fri, 6 Jun 2008 02:13:43 +0000"  >&lt;p&gt;I&apos;d like to see the original reporter provide the example of where it was failing with JTA and JOTM.  We used to do a lot of extensive use of JTA/JOTM on our legacy batch system and found there were scenarios where JOTM behaved very differently from our production system (WebSphere&apos;s JTA).  Could we get a sample failure attached?&lt;/p&gt;</comment>
                            <comment id="36612" author="telematica" created="Mon, 9 Jun 2008 19:21:44 +0000"  >&lt;p&gt;I&apos;ll explain the failure:&lt;/p&gt;

&lt;p&gt;Here&apos;s the context configuration:&lt;br/&gt;
&amp;lt;!-- DATASOURCES --&amp;gt;&lt;br/&gt;
&amp;lt;bean id=&quot;modelDataSource&quot;&lt;br/&gt;
	class=&quot;org.enhydra.jdbc.pool.StandardXAPoolDataSource&quot;&amp;gt;&lt;br/&gt;
	&amp;lt;property name=&quot;dataSource&quot;&amp;gt;&lt;br/&gt;
		&amp;lt;bean class=&quot;org.enhydra.jdbc.standard.StandardXADataSource&quot;&amp;gt;&lt;br/&gt;
			&amp;lt;property name=&quot;transactionManager&quot; ref=&quot;jotm&quot; /&amp;gt;&lt;br/&gt;
			&amp;lt;property name=&quot;driverName&quot; value=&quot;...ModelDriver&quot; /&amp;gt;&lt;br/&gt;
		&amp;lt;/bean&amp;gt;&lt;br/&gt;
	&amp;lt;/property&amp;gt;&lt;br/&gt;
&amp;lt;/bean&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;bean id=&quot;dataSource&quot;&lt;br/&gt;
	class=&quot;org.enhydra.jdbc.pool.StandardXAPoolDataSource&quot;&amp;gt;&lt;br/&gt;
	&amp;lt;property name=&quot;dataSource&quot;&amp;gt;&lt;br/&gt;
		&amp;lt;bean class=&quot;org.enhydra.jdbc.standard.StandardXADataSource&quot;&amp;gt;&lt;br/&gt;
			&amp;lt;property name=&quot;transactionManager&quot; ref=&quot;jotm&quot; /&amp;gt;&lt;br/&gt;
			&amp;lt;property name=&quot;driverName&quot; value=&quot;...MetaDataDriver&quot; /&amp;gt;&lt;br/&gt;
		&amp;lt;/bean&amp;gt;&lt;br/&gt;
	&amp;lt;/property&amp;gt;&lt;br/&gt;
&amp;lt;/bean&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;!-- TRANSACTION MANAGER (small timeOut to force rollback)--&amp;gt;&lt;br/&gt;
&amp;lt;bean id=&quot;jotm&quot; class=&quot;org.springframework.transaction.jta.JotmFactoryBean&quot; /&amp;gt;&lt;br/&gt;
&amp;lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;&amp;gt;&lt;br/&gt;
	&amp;lt;property name=&quot;userTransaction&quot;&amp;gt;&lt;br/&gt;
		&amp;lt;ref local=&quot;jotm&quot; /&amp;gt;&lt;br/&gt;
	&amp;lt;/property&amp;gt;&lt;br/&gt;
	&amp;lt;property name=&quot;allowCustomIsolationLevels&quot; value=&quot;true&quot;/&amp;gt;&lt;br/&gt;
	&amp;lt;property name=&quot;defaultTimeout&quot; value=&quot;10&quot;/&amp;gt;&lt;br/&gt;
&amp;lt;/bean&amp;gt;&lt;/p&gt;

&lt;p&gt;And now the log output. Up to this point, we&apos;ve written 10 items to the database. We are bout to commit the transaction but we won&apos;t let that happen, wating for more time than the max timeout.&lt;/p&gt;

&lt;p&gt;09:52:31,764 DEBUG main DataSourceUtils:112 - Fetching JDBC Connection from DataSource&lt;br/&gt;
09:52:31,764 DEBUG main DataSourceUtils:116 - Registering transaction synchronization for JDBC Connection&lt;br/&gt;
09:52:31,764 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 1, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;Tue Jun 10 09:52:22 CEST 2008&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.util.Date&amp;#93;&lt;/span&gt;, SQL type 93&lt;br/&gt;
09:52:31,764 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 2, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;null&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;null&amp;#93;&lt;/span&gt;, SQL type 93&lt;br/&gt;
09:52:31,764 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 3, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;STARTED&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.String&amp;#93;&lt;/span&gt;, SQL type 12&lt;br/&gt;
09:52:31,764 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 4, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.Integer&amp;#93;&lt;/span&gt;, SQL type 4&lt;br/&gt;
09:52:31,764 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 5, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;20&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.Integer&amp;#93;&lt;/span&gt;, SQL type 4&lt;br/&gt;
09:52:31,764 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 6, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;Y&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.String&amp;#93;&lt;/span&gt;, SQL type 1&lt;br/&gt;
09:52:31,764 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 7, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;UNKNOWN&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.String&amp;#93;&lt;/span&gt;, SQL type 12&lt;br/&gt;
09:52:31,764 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 8, parameter value [], value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.String&amp;#93;&lt;/span&gt;, SQL type 12&lt;br/&gt;
09:52:31,764 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 9, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.Integer&amp;#93;&lt;/span&gt;, SQL type 4&lt;br/&gt;
09:52:31,764 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 10, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;71&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.Long&amp;#93;&lt;/span&gt;, SQL type 4&lt;br/&gt;
09:52:31,764 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 11, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.Integer&amp;#93;&lt;/span&gt;, SQL type 4&lt;br/&gt;
09:52:31,764 DEBUG main JdbcTemplate:797 - SQL update affected 1 rows&lt;br/&gt;
09:52:31,764  INFO main ChunkLogAdvice:45 - &lt;span class=&quot;error&quot;&gt;&amp;#91;JOB monitorizacionJobJTA; STEP step1&amp;#93;&lt;/span&gt; CHUNK: 20 elemento(s) procesado(s).&lt;/p&gt;

&lt;p&gt;//Ten seconds and the maximum timeout expires. A rollback is imperative&lt;/p&gt;

&lt;p&gt;09:52:41,515  INFO JonasBatch jotm:691 - set rollback only (tx=bb14111130343639633564386631613030615f305f &lt;br/&gt;
09:52:42,688 DEBUG main DataSourceUtils:312 - Returning JDBC Connection to DataSource&lt;br/&gt;
09:52:42,688 DEBUG main DataSourceUtils:312 - Returning JDBC Connection to DataSource&lt;br/&gt;
09:52:42,703 ERROR main ItemOrientedStep:277 - Fatal error detected during commit.&lt;br/&gt;
09:52:42,719 ERROR main AbstractStep:183 - Encountered an error executing the step&lt;br/&gt;
09:52:42,719 DEBUG main JdbcTemplate:787 - Executing prepared SQL update&lt;br/&gt;
09:52:42,719 DEBUG main JdbcTemplate:571 - Executing prepared SQL statement &lt;span class=&quot;error&quot;&gt;&amp;#91;UPDATE BATCH_STEP_EXECUTION set START_TIME = ?, END_TIME = ?, STATUS = ?, COMMIT_COUNT = ?, ITEM_COUNT = ?, CONTINUABLE = ? , EXIT_CODE = ?, EXIT_MESSAGE = ?, VERSION = ? where STEP_EXECUTION_ID = ? and VERSION = ?&amp;#93;&lt;/span&gt;&lt;br/&gt;
09:52:42,719 DEBUG main DataSourceUtils:112 - Fetching JDBC Connection from DataSource&lt;br/&gt;
09:52:42,719 DEBUG main DataSourceUtils:116 - Registering transaction synchronization for JDBC Connection&lt;br/&gt;
09:52:42,719 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 1, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;Tue Jun 10 09:52:22 CEST 2008&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.util.Date&amp;#93;&lt;/span&gt;, SQL type 93&lt;br/&gt;
09:52:42,719 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 2, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;Tue Jun 10 09:52:42 CEST 2008&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.util.Date&amp;#93;&lt;/span&gt;, SQL type 93&lt;br/&gt;
09:52:42,719 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 3, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;UNKNOWN&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.String&amp;#93;&lt;/span&gt;, SQL type 12&lt;br/&gt;
09:52:42,719 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 4, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.Integer&amp;#93;&lt;/span&gt;, SQL type 4&lt;br/&gt;
09:52:42,719 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 5, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;20&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.Integer&amp;#93;&lt;/span&gt;, SQL type 4&lt;br/&gt;
09:52:42,719 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 6, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;N&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.String&amp;#93;&lt;/span&gt;, SQL type 1&lt;br/&gt;
09:52:42,719 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 7, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;FAILED&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.String&amp;#93;&lt;/span&gt;, SQL type 12&lt;br/&gt;
09:52:42,719 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 8, parameter value [org.springframework.batch.core.step.AbstractStep$FatalException: Fatal error detected during commit&lt;br/&gt;
	at org.springframework.batch.core.step.item.ItemOrientedStep$1.doInIteration(ItemOrientedStep.java:278)&lt;br/&gt;
	at org.springframework.batch.repeat.suppor], value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.String&amp;#93;&lt;/span&gt;, SQL type 12&lt;br/&gt;
09:52:42,719 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 9, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;3&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.Integer&amp;#93;&lt;/span&gt;, SQL type 4&lt;br/&gt;
09:52:42,719 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 10, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;71&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.Long&amp;#93;&lt;/span&gt;, SQL type 4&lt;br/&gt;
09:52:42,719 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 11, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.Integer&amp;#93;&lt;/span&gt;, SQL type 4&lt;br/&gt;
09:52:42,750 DEBUG main JdbcTemplate:797 - SQL update affected 0 rows&lt;br/&gt;
09:52:42,750 DEBUG main JdbcTemplate:636 - Executing prepared SQL query&lt;br/&gt;
09:52:42,750 DEBUG main JdbcTemplate:571 - Executing prepared SQL statement &lt;span class=&quot;error&quot;&gt;&amp;#91;SELECT VERSION FROM BATCH_STEP_EXECUTION WHERE STEP_EXECUTION_ID=?&amp;#93;&lt;/span&gt;&lt;br/&gt;
09:52:42,750 DEBUG main StatementCreatorUtils:203 - Setting SQL statement parameter value: column index 1, parameter value &lt;span class=&quot;error&quot;&gt;&amp;#91;71&amp;#93;&lt;/span&gt;, value class &lt;span class=&quot;error&quot;&gt;&amp;#91;java.lang.Long&amp;#93;&lt;/span&gt;, SQL type unknown&lt;br/&gt;
09:52:42,828 DEBUG main DataSourceUtils:312 - Returning JDBC Connection to DataSource&lt;br/&gt;
09:52:42,828 ERROR main AbstractStep:216 - Encountered an error saving batch meta data.This job is now in an unknown state and should not be restarted.&lt;br/&gt;
org.springframework.dao.OptimisticLockingFailureException: Attempt to update step execution id=71 with wrong version (2), where current version is 1&lt;br/&gt;
	at org.springframework.batch.core.repository.dao.JdbcStepExecutionDao.updateStepExecution(JdbcStepExecutionDao.java:333)&lt;br/&gt;
	at org.springframework.batch.core.repository.support.SimpleJobRepository.saveOrUpdate(SimpleJobRepository.java:239)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt;
	at java.lang.reflect.Method.invoke(Method.java:615)&lt;br/&gt;
	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:310)&lt;br/&gt;
	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:182)&lt;br/&gt;
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)&lt;br/&gt;
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:106)&lt;br/&gt;
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)&lt;br/&gt;
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:90)&lt;br/&gt;
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)&lt;br/&gt;
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)&lt;br/&gt;
	at $Proxy0.saveOrUpdate(Unknown Source)&lt;br/&gt;
	at org.springframework.batch.core.step.AbstractStep.execute(AbstractStep.java:201)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)&lt;br/&gt;
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt;
	at java.lang.reflect.Method.invoke(Method.java:615)&lt;br/&gt;
	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:310)&lt;br/&gt;
	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:182)&lt;br/&gt;
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)&lt;br/&gt;
	at org.springframework.aop.aspectj.AspectJAfterAdvice.invoke(AspectJAfterAdvice.java:42)&lt;br/&gt;
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:160)&lt;br/&gt;
	at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:50)&lt;br/&gt;
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:160)&lt;br/&gt;
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:90)&lt;br/&gt;
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)&lt;br/&gt;
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)&lt;br/&gt;
	at $Proxy1.execute(Unknown Source)&lt;br/&gt;
	at org.springframework.batch.core.job.SimpleJob.execute(SimpleJob.java:125)&lt;br/&gt;
	at org.springframework.batch.core.launch.support.SimpleJobLauncher$1.run(SimpleJobLauncher.java:86)&lt;br/&gt;
	at org.springframework.core.task.SyncTaskExecutor.execute(SyncTaskExecutor.java:49)&lt;br/&gt;
	at org.springframework.batch.core.launch.support.SimpleJobLauncher.run(SimpleJobLauncher.java:81)&lt;/p&gt;</comment>
                            <comment id="36613" author="robert.kasanicky" created="Mon, 9 Jun 2008 19:32:31 +0000"  >&lt;p&gt;Raised the priority to major due to the restart implications described in my previous comment.&lt;/p&gt;

&lt;p&gt;I don&apos;t yet see a fully satisfactory way to fix the problem - decrementing version number in step looks awful. Maybe the repository could do it in case execution context&apos;s update fails, but it doesn&apos;t help with failed commit.&lt;/p&gt;</comment>
                            <comment id="36668" author="david_syer" created="Thu, 12 Jun 2008 22:49:44 +0000"  >&lt;p&gt;I didn&apos;t catch where the timeout came from in that example?  Isn&apos;t it artificial in some way?  I suppose in principle if all the resources in the job are fully XA capable (i.e. no file I/O) then we might expect to be able to recover from a commit failure, but only if we can distinguish a true commit failure from a failure in some other component (e.g. a listener).  Is that going to be the target here?&lt;/p&gt;

&lt;p&gt;Also, surely we can create a test case that doesn&apos;t need JTA?&lt;/p&gt;</comment>
                            <comment id="36727" author="telematica" created="Mon, 16 Jun 2008 01:15:26 +0000"  >&lt;p&gt;Yep, this is artificial in this example because we force a rollback explicitly waiting for a timeout to expire. We could have, as well, unplugged our network connection before the commit took place. But this is not the point here. The problem is that the ExecutionContext is not synchronized with the current database status after the commit failure is detected, because it hasn&apos;t been re-queried. &lt;/p&gt;

&lt;p&gt;Surely, every test sample that comes with the distribution has no need for JTA. The problem is, as stated, when you need 2 datasources. Then you need XA resources and two-phase commits. &lt;/p&gt;</comment>
                            <comment id="36775" author="david_syer" created="Tue, 17 Jun 2008 20:47:51 +0000"  >&lt;p&gt;One of the problems here is that the execution context needs to be saved independently of the step execution (so if there is a rollback, the step execution is not affected and in particular so that the version is not incremented).  Thus SimpleJobRepository.saveOrUpdateExecutionContext &lt;b&gt;should not&lt;/b&gt; call saveOrUpdate(StepExecution) - it is up to the caller to decide when it is necessary.  I have made this change and the tests pass, but really I think there is a weakness here that needs to be addressed through the interface JobRepository (see &lt;a href=&quot;https://jira.spring.io/browse/BATCH-668&quot; title=&quot;JobRepository needs to distinguish between save and update of execution context&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BATCH-668&quot;&gt;&lt;del&gt;BATCH-668&lt;/del&gt;&lt;/a&gt;).  It could also be addressed by providing an explicit load() method in the JobRepository, so that the latest value from the database can be loaded after a rollback.&lt;/p&gt;

&lt;p&gt;So the changes are:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;make sure saveOrUpdate(StepExecution) is called explicitly &lt;b&gt;before&lt;/b&gt; any calls to save the execution context - this is fragile but necessary unless we change the JobRepository&lt;/li&gt;
	&lt;li&gt;if a fatal execption was detected before the rollback was attempted, try to save the step execution so that the UNKNOWN status is persisteed properly&lt;/li&gt;
	&lt;li&gt;a test for the above (ItemOrientedStepIntegrationTests)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The original description in of this issue seems to be slightly wrong: the execution context should always rollback in such situations, as long as the database is still available.&lt;/p&gt;</comment>
                            <comment id="38696" author="david_syer" created="Thu, 7 Aug 2008 02:07:12 +0000"  >&lt;p&gt;Assume closed as resolved and released&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 5 Jun 2008 02:50:18 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10280" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11907</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i01tfz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>10647</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10381" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Ranking</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>10626</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>