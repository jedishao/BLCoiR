<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 12:22:49 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/BATCH-398/BATCH-398.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[BATCH-398] That old stateful / stateless thing again....</title>
                <link>https://jira.spring.io/browse/BATCH-398</link>
                <project id="10090" key="BATCH">Spring Batch</project>
                    <description>&lt;p&gt;Step used to have StepExecutorFactory to create stack-confined stateful StepExecutor instances.  Now that StepExecutor is merged with Step it needs to have its own factory.  Or else we go back to the StepExecutor/Factory design.  So Job has a list of StepFactory instead of a list of Steps, and creates a Step for use inside its execute() method.  The simplest possible factory would be a prototype bean lookup, otherwise the factory has to have all the public setters of the Step implementation (maybe now that things are settling down that isn&apos;t so bad).&lt;/p&gt;</description>
                <environment></environment>
        <key id="20809">BATCH-398</key>
            <summary>That old stateful / stateless thing again....</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="david_syer">Dave Syer</reporter>
                        <labels>
                    </labels>
                <created>Wed, 27 Feb 2008 22:03:01 +0000</created>
                <updated>Thu, 7 Aug 2008 02:06:53 +0000</updated>
                            <resolved>Fri, 29 Feb 2008 19:57:50 +0000</resolved>
                                    <version>1.0.0.m5</version>
                                    <fixVersion>1.0.0.m5</fixVersion>
                                    <component>Core</component>
                    <component>Infrastructure</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                    <timeoriginalestimate seconds="28800">1d</timeoriginalestimate>
                            <timeestimate seconds="28800">1d</timeestimate>
                                        <comments>
                            <comment id="32611" author="david_syer" created="Wed, 27 Feb 2008 23:13:44 +0000"  >&lt;p&gt;A JobScope would be one way for doing it (someone already asked &lt;a href=&quot;https://jira.spring.io/browse/BATCH-361&quot; title=&quot;Job Scope and Job Context&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BATCH-361&quot;&gt;&lt;del&gt;BATCH-361&lt;/del&gt;&lt;/a&gt;) within the current framework.  Each step would need to be scope=&quot;job&quot; to ensure strict thread safety - it would be optional for anyone using a throwaway application context for every job execution.&lt;/p&gt;

&lt;p&gt;An alternative is to scrap custom scopes and insist that users create a new ApplicationContext for each job execution.  It makes StepContextAware more complicated, but it&apos;s do-able.  There needs to be a registration protocol for *Aware instances, like direct injection into the Job/Step,or autodetection in the ApplicationContext.  Those interfaces might then disappear in favour of *Listener (see &lt;a href=&quot;https://jira.spring.io/browse/BATCH-151&quot; title=&quot;add support for some sort of &amp;#39;final&amp;#39; method to existing or new ItemProcessor implementation and related tasklets&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BATCH-151&quot;&gt;&lt;del&gt;BATCH-151&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://jira.spring.io/browse/BATCH-378&quot; title=&quot;RepeatListener is confusing and too generic to use for &amp;#39;intercepting&amp;#39; a step&quot; class=&quot;issue-link&quot; data-issue-key=&quot;BATCH-378&quot;&gt;&lt;del&gt;BATCH-378&lt;/del&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;In the future we would like to have a more domain-focused way of specifying these concerns - it might take inspiration from the SWF concept of a flow variable (we&apos;d have job and step variables).  The drawback of that approach is that SWF (although it continues to improve) has a clunky model for setting things up, from a user&apos;s perspective - a flow definition file plus a beans definition file for every flow.  I don&apos;t think we should burden users with that, in the long run.&lt;/p&gt;</comment>
                            <comment id="32613" author="david_syer" created="Wed, 27 Feb 2008 23:39:28 +0000"  >&lt;p&gt;Actually there seems to be no reason any longer that reader/writers need to be stateful - they can store their state in the ExecutionContext (an exception might be a multi-threaded state, where maybe transaction resources need to be used in conjunction with ExecutionContext).  Then we have a completely different situation - everything is stateless, and anyone who wants access to some state registers for a callback, e.g. with a marker interface.&lt;/p&gt;

&lt;p&gt;The plan would be to push all state from readers/writers into the execution context and provide registration for *Listeners (which replace and supersede *Aware).&lt;/p&gt;</comment>
                            <comment id="32620" author="david_syer" created="Thu, 28 Feb 2008 00:28:43 +0000"  >&lt;p&gt;Not sure if that will work (I wish it would).  The only way it works is if the readers/writers hang on to a reference to the context, or if &lt;b&gt;all&lt;/b&gt; methods in their interface take the context as an argument.  That seems invasive, at first glance anyway. &lt;/p&gt;</comment>
                            <comment id="32626" author="david_syer" created="Thu, 28 Feb 2008 01:11:17 +0000"  >&lt;p&gt;I split up config for TaskExecutorLauncher a bit.  Heading for a more rational approach based on a new application context per run.  One way to do it would be a new implementation of JobLocator that loads an ApplicationContext instead of just looking in a map.&lt;/p&gt;</comment>
                            <comment id="32627" author="lucas.l.ward" created="Thu, 28 Feb 2008 01:54:18 +0000"  >&lt;p&gt;I&apos;m really not sure that the ItemReaders and Writers can be stateless, I think they&apos;re stateful by definition.  I know we &lt;b&gt;could&lt;/b&gt; put all the state in the ExecutionContext, but we&apos;ve tried this sort of approach before, and it just doesn&apos;t work.&lt;/p&gt;

&lt;p&gt;In batch, our readers have to be streaming over a large dataset, and I just don&apos;t see any advantage in trying to put that state in some other object.  If you&apos;re going to do that, you might as well just put the whole reader and writer in state object&lt;/p&gt;

&lt;p&gt;I guess I&apos;m saying, you can&apos;t use the same readers and writers by multiple threads generally.  Let&apos;s give an example: JdbcCursorItemReader.  If you open the cursor then put the resultSet in state, then try and go at it with another thread that has a different context, you may have issues opening another very large cursor up over the same dataset.  It&apos;s even worse for a file, since the OS is going to lock it, and as we&apos;ve said before, if you&apos;re using different JobParameters (such as a different file) it&apos;s a different JobInstance.&lt;/p&gt;

&lt;p&gt;I think we&apos;re much better off maintaining that only one thread should be touching a reader or writer at a time, rather than trying to bypass this with stack scoped state.&lt;/p&gt;</comment>
                            <comment id="32628" author="david_syer" created="Thu, 28 Feb 2008 01:57:00 +0000"  >&lt;p&gt;I disagree that readers/writers &lt;b&gt;have&lt;/b&gt; to be single-threaded in their contract.  I agree that they are fundamentally stateful.  Some clever stuff would have to be done to make them multi-threaded, but it isn&apos;t impossible.&lt;/p&gt;</comment>
                            <comment id="32674" author="nebhale" created="Thu, 28 Feb 2008 20:22:30 +0000"  >&lt;p&gt; (In reply to comment #6)&lt;br/&gt;
&amp;gt; I disagree that readers/writers &lt;b&gt;have&lt;/b&gt; to be single-threaded in their contract.&lt;br/&gt;
&amp;gt; I agree that they are fundamentally stateful.  Some clever stuff would have to&lt;br/&gt;
&amp;gt; be done to make them multi-threaded, but it isn&apos;t impossible.&lt;/p&gt;

&lt;p&gt;I&apos;m in agreement here.  I think there is some confusion about what&apos;s thread-safe versus what&apos;s stateless.  It&apos;s more than possible to create a stateful thread-safe object with proper synchronization.  I think that the contract of the ItemReader/Writers is that they are thread-safe only (although I don&apos;t think that InputStream implies this so this might not even be part of the contract, you might just have implementations that are thread-safe for use in multi-threaded environments).&lt;/p&gt;

&lt;p&gt;I think the real question of this issue lies in scoping.  I don&apos;t think that an ItemReader/Writer instance can be used outside of a single step scope.  Because they are generally stateful (in that they maintain internal markers/caches/buffers/etc) and also that they can&apos;t be reset to 0 easily (to re-read the file for example) I think  that they&apos;ve got to be instantiated in a way that scopes them on the stack.  This does imply factories for some items (like the reader/writer) but following the WebFlow example, it&apos;s possible to create stateless objects that persist some information in contexts for smaller elements.&lt;/p&gt;</comment>
                            <comment id="32676" author="david_syer" created="Thu, 28 Feb 2008 20:36:42 +0000"  >&lt;p&gt;That&apos;s all so far so good.  I really believe that demanding factories for ItemRead/Writer just isn&apos;t going to work, though.  These are interfaces, not classes, and anyone (by design) can implement the interface and have it used appropriately by a batch job.  I really don&apos;t think we should force people to write factories for their own implementations.  That leaves us with a problem, which up to now I have been inclined to solve with scope=&quot;step&quot;.  It seems more and more like that is not a good solution for users either.&lt;/p&gt;

&lt;p&gt;I want to remove step scope if I can, and for 1.0 recommend that users simply create a new ApplicationContext for each job execution.  It shouldn&apos;t be too hard to do, and all the other benefits (almost) of step scope can be obtained from the new BatchListener and ItemStream interfaces.&lt;/p&gt;

&lt;p&gt;What we do in 2.0 is another question, but surely it must come down to some sort of smart object factory.  SWF is a good place to look for ideas (I like the flow variables, but hate the way you have to configure them).&lt;/p&gt;</comment>
                            <comment id="32678" author="nebhale" created="Thu, 28 Feb 2008 20:45:18 +0000"  >&lt;p&gt;I can agree with removing the scope and saying a new ApplicationContext each time.&lt;/p&gt;</comment>
                            <comment id="32717" author="david_syer" created="Fri, 29 Feb 2008 19:57:50 +0000"  >&lt;p&gt;Step scope is gone.  All sample jobs can be run from command line or JMX since configuration was split into job-only and launcher-only.  TaskExecutorLauncher works with an ApplicationContext per job execution via the new JobFactory strategy.&lt;/p&gt;</comment>
                            <comment id="38497" author="david_syer" created="Thu, 7 Aug 2008 02:06:53 +0000"  >&lt;p&gt;Assume closed as resolved and released&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 28 Feb 2008 01:54:18 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10280" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>12057</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i05747:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30359</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10381" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Ranking</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>27365</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>