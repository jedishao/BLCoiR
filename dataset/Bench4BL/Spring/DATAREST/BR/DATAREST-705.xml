<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 16:57:40 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/DATAREST-705/DATAREST-705.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[DATAREST-705] Cannot PUT versioned entity returned by spring-data-rest</title>
                <link>https://jira.spring.io/browse/DATAREST-705</link>
                <project id="10901" key="DATAREST">Spring Data REST</project>
                    <description>&lt;p&gt;I would expect it to be possible to execute PUT by simply supplying all fields returned by GET. However, this is currently broken as a consequence of &lt;a href=&quot;https://jira.spring.io/browse/DATAREST-160&quot; title=&quot;Support for @Version based ETags&quot; class=&quot;issue-link&quot; data-issue-key=&quot;DATAREST-160&quot;&gt;&lt;del&gt;DATAREST-160&lt;/del&gt;&lt;/a&gt;. &lt;/p&gt;

&lt;p&gt;Now when an entity is exposed via REST API (either as part of a list, or directly), it&apos;s returned without version property. However, when PUT operation is performed, version property can be required, since the whole entity is persisted (as opposed to PATCH logic where only changed fields need to be supplied). This is true, for example, for JPA, which will check version and refuse updating if version is missing.&lt;/p&gt;

&lt;p&gt;This means that REST API client is expected to send a property that it never received. In fact, the client might not even be aware that such property exists, how it&apos;s called, and what value it should contain.&lt;/p&gt;</description>
                <environment></environment>
        <key id="66709">DATAREST-705</key>
            <summary>Cannot PUT versioned entity returned by spring-data-rest</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="olivergierke">Oliver Gierke</assignee>
                                    <reporter username="koscejev">Anton Koscejev</reporter>
                        <labels>
                    </labels>
                <created>Fri, 13 Nov 2015 12:10:23 +0000</created>
                <updated>Fri, 18 Dec 2015 10:14:27 +0000</updated>
                            <resolved>Fri, 20 Nov 2015 15:58:00 +0000</resolved>
                                    <version>2.4 GA (Gosling)</version>
                                    <fixVersion>2.4.2 (Gosling SR2)</fixVersion>
                    <fixVersion>2.5 M1 (Hopper)</fixVersion>
                    <fixVersion>2.3.3 (Fowler SR3)</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="121527" author="koscejev" created="Fri, 13 Nov 2015 12:11:35 +0000"  >&lt;p&gt;It seems that to be consistent Spring-Data-Rest should either:&lt;br/&gt;
1) populate version property with value of ETag on incoming entities, or&lt;br/&gt;
2) return version property when GET is performed (perhaps not for lists, but at least for single entities)&lt;/p&gt;

&lt;p&gt;Also, if the first option is chosen, it seems redundant to load entity from DB and merge incoming entity with existing one, if module (JPA) will check it anyway. Perhaps each module can specify whether it will check version itself, so Spring-Data-Rest doesn&apos;t have to handle ETag directly.&lt;/p&gt;</comment>
                            <comment id="121748" author="olivergierke" created="Fri, 20 Nov 2015 15:58:00 +0000"  >&lt;p&gt;This should be fixed. I explicitly removed the wiping for version and identifier properties from &lt;tt&gt;DomainObjectReader&lt;/tt&gt; to make sure we preserve the server side values. For PUT scenarios this now gives the following situation:&lt;/p&gt;

&lt;p&gt;1. PUTting the document as received will not wipe the version property, thus use the value loaded from the server and only fail (cause a conflict) in case someone else updates the same entity in between load, application of the sent payload and saving. All other requests will strictly write the sent payload.&lt;br/&gt;
2. Conditional PUTs can be issued by adding the &lt;tt&gt;If-Match&lt;/tt&gt; header and using the &lt;tt&gt;ETag&lt;/tt&gt; header received in the original request as it&apos;s evaluated independently of the payload merge and will return &lt;tt&gt;412 Precondition failed&lt;/tt&gt; as defined by the HTTP spec.&lt;/p&gt;

&lt;p&gt;Does that make sense?&lt;/p&gt;</comment>
                            <comment id="121751" author="koscejev" created="Fri, 20 Nov 2015 16:44:42 +0000"  >&lt;p&gt;That would solve the original issue, yes.&lt;/p&gt;

&lt;p&gt;What do you think about the fact that an unnecessary DB operation is performed, when module (JPA) supports optimistic locking natively, and both ID (in URL) and version (in ETag) are provided? In this specific scenario it would be more efficient to simply:&lt;br/&gt;
1) deserialize incoming entity&lt;br/&gt;
2) apply ID from URL (fail if deserialized entity already has different ID specified)&lt;br/&gt;
3) apply version from ETag (fail if different)&lt;br/&gt;
4) persist&lt;/p&gt;

&lt;p&gt;Perhaps this could be an additional feature? &quot;Increase performance by delegating optimistic locking to underlying module.&quot;&lt;/p&gt;</comment>
                            <comment id="121759" author="olivergierke" created="Sat, 21 Nov 2015 10:53:15 +0000"  >&lt;p&gt;Interesting thoughts. I am fearing this approach would cause quite a bit of trouble or would only be suitable in very edge cases due the following problems:&lt;/p&gt;

&lt;p&gt;1. &lt;b&gt;The resource representation you might see doesn&apos;t have to be a 1:1 representation of the underlying entity.&lt;/b&gt; Just imagine one property being &lt;tt&gt;@JsonIgnore&lt;/tt&gt;-ed. That means the client would never see it. If we apply the suggested algorithm, the &lt;tt&gt;PUT&lt;/tt&gt; request would wipe out the properties that were ignored.&lt;br/&gt;
2. &lt;b&gt;I think it&apos;s an anti-pattern to delay the recognition of a potential optimistic locking exception.&lt;/b&gt; As it basically means you hand object instances through business logic (e.g. Spring Data REST pre-save events) although you could&apos;ve recognized they would never even have to be fired in the first place just to eventually run into the database layer rejecting the update.&lt;/p&gt;

&lt;p&gt;To summarize we&apos;re basically optimizing for correctness instead of backend update performance by default. You can always go ahead an simply override the &lt;tt&gt;PUT&lt;/tt&gt; method for a particular item resource if performance is really bad and use more immediate means (e.g. a dedicated repository method that optimizes the call).&lt;/p&gt;</comment>
                            <comment id="121760" author="koscejev" created="Sat, 21 Nov 2015 12:20:30 +0000"  >&lt;p&gt;Regarding @JsonIgnore, I see that you&apos;re basing additional features on top of this, so yes, increased performance would have to come at the cost of purposely avoiding using those features. To be honest, until you said this, I didn&apos;t realize spring-data-rest actually allows some fields to be ignored and not wiped on update. It&apos;s an interesting feature. So losing this (and potentially other) features sounds like a big drawback, but at the same time I can see it being helpful to skip the check, because sometimes increased performance is more important than secondary features.&lt;/p&gt;

&lt;p&gt;I see your point about delaying the recognition, but this is not so clear-cut. This is not just about rearranging things in correct order, so you can skip some things, because other things are more likely to fail. The whole idea of optimistic locking is that you don&apos;t expect to hit the lock often (hence &quot;optimistic&quot;). You expect most of the operations to be fine and you want increased performance that comes with optimistic lock (as opposed to the pessimistic one). Adding an additional check with every operation is exactly the opposite of what one would expect from optimistic locking. In other words, adding that check means you&apos;re being pessimistic. &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Considering the business logic point (e.g., pre-save events), doing an additional check still doesn&apos;t prevent the situation when underlying module will reject the update. So it might still happen that business logic events run through, and then update fails. So the system becomes less consistent/predictable with the idea that you might get increased performance from it (by skipping business logic sometimes). But while the drawback (inconsistency) is introduced, the benefit is questionable - this is because, like I tried to explain in the previous point, the idea of optimistic lock is to allow &quot;good&quot; operations to pass through with as few checks as possible (= as fast as possible) at the cost of perhaps losing some performance when &quot;bad&quot; operations occur. Because if we were properly pessimistic in the first place and locked the record, then &quot;bad&quot; operation would&apos;ve been prevented sooner - but that would be pessimistic lock.&lt;/p&gt;

&lt;p&gt;Basically, I&apos;m not saying this has to be fixed. I&apos;m saying this implementation doesn&apos;t follow the core idea of optimistic locking as strictly as it could. Indeed, if someone wanted increased performance, they could create a workaround. The question is: should it really be a workaround or could there be a feature specifically for this?&lt;/p&gt;

&lt;p&gt;Anyhow, thanks for fixing this bug, we&apos;re looking forward to the next version! &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 20 Nov 2015 15:58:00 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10280" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>olivergierke</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i08wdj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10381" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Ranking</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10480" key="com.pyxis.greenhopper.jira:gh-sprint">
                        <customfieldname>Sprint</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue id="105">Hopper M1</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>