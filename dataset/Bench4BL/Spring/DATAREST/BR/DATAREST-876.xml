<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 17:12:08 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/DATAREST-876/DATAREST-876.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[DATAREST-876] @Transactional annotation is not being enforced on repository methods</title>
                <link>https://jira.spring.io/browse/DATAREST-876</link>
                <project id="10901" key="DATAREST">Spring Data REST</project>
                    <description>&lt;p&gt;I&apos;m trying to fetch &quot;golden&quot; copy of record from DB while validating the entity to check passed field being unique.  Since I cannot change the DB structure to enforce this with annotation, I had to pass repository reference into validator with expected result of being able to refetch the record. &lt;/p&gt;

&lt;p&gt;Here is the link to s sample project that reproduces the issue:&lt;br/&gt;
&lt;a href=&quot;https://github.com/nfedyk/spring-boot-repository-caching-issue-01&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/nfedyk/spring-boot-repository-caching-issue-01&lt;/a&gt;&lt;/p&gt;</description>
                <environment>JVM: 1.8.0_51 (Oracle Corporation 25.51-b03) &lt;br/&gt;
OS: Mac OS X 10.10.5 x86_64</environment>
        <key id="69542">DATAREST-876</key>
            <summary>@Transactional annotation is not being enforced on repository methods</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://jira.spring.io/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="3">Duplicate</resolution>
                                        <assignee username="olivergierke">Oliver Gierke</assignee>
                                    <reporter username="nfedyk">Nestor Fedyk</reporter>
                        <labels>
                    </labels>
                <created>Thu, 18 Aug 2016 16:37:50 +0000</created>
                <updated>Thu, 3 Nov 2016 09:10:44 +0000</updated>
                            <resolved>Thu, 3 Nov 2016 09:10:44 +0000</resolved>
                                    <version>2.5.2 (Hopper SR2)</version>
                                                        <due></due>
                            <votes>2</votes>
                                    <watches>4</watches>
                                                                <comments>
                            <comment id="131379" author="olivergierke" created="Thu, 18 Aug 2016 20:19:41 +0000"  >&lt;p&gt;I don&apos;t think that what you think you observe is what you observe. The &lt;tt&gt;@Transactional&lt;/tt&gt; annotation is not the culprit here but the fact that you issue a query and the persistence provider flushing the pending changes to the database at this point already. This is something we don&apos;t really control, as unfortunately that&apos;s just the way JPA is defined to behave in &lt;tt&gt;FlushModeType.AUTO&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="131380" author="bitsofinfo" created="Thu, 18 Aug 2016 20:23:33 +0000"  >&lt;p&gt;So how does one do what is trying to be achieved in this case? Is our use case reasonable?&lt;/p&gt;

&lt;p&gt;Simply trying to lookup the real value of this record as it resides in the database, in the middle of this existing transaction? We&apos;ve tried creating a completely separate repository instance off a duplicate interface and inject that for the &quot;find&quot; call, but still get this same mutated instance. &lt;/p&gt;</comment>
                            <comment id="131381" author="olivergierke" created="Thu, 18 Aug 2016 20:32:23 +0000"  >&lt;p&gt;There unfortunately currently is no really great way. I am not even sure there&apos;s a way at all, you might wanna try injecting the &lt;tt&gt;EntityManager&lt;/tt&gt; manually set the &lt;tt&gt;FlushModeType&lt;/tt&gt; to &lt;tt&gt;COMMIT&lt;/tt&gt;, proceed with your calls and then set it back to &lt;tt&gt;AUTO&lt;/tt&gt;. I am currently looking into options how we can make sure that is managed behind the scenes so that you don&apos;t have to.&lt;/p&gt;</comment>
                            <comment id="131382" author="bitsofinfo" created="Thu, 18 Aug 2016 20:37:01 +0000"  >&lt;p&gt;Help me understand this. If we were to declare a 2nd interface for a repository (that manages the same JPA pojo), it would be a completely separate instance with an entirely separate EntityManager, yes? So if we were to inject that &quot;2nd instance&quot; of our repo into the repo handling this PATCH, then that one should be hitting a different hibernate session (or none at all) and should hit the DB?&lt;/p&gt;

&lt;p&gt;Or is there another alternate way? Are there any hooks to &quot;load the entity instance&quot; prior to the invocation of all the PATCH handling by spring-data-rest, where we can have a pre-mutated copy to compare against?&lt;/p&gt;</comment>
                            <comment id="133171" author="olivergierke" created="Thu, 3 Nov 2016 09:03:27 +0000"  >&lt;p&gt;No, an &lt;tt&gt;EntityManager&lt;/tt&gt; is a thread-bound instance, so all repositories invoked on a single thread see the same &lt;tt&gt;EntityManager&lt;/tt&gt;. Also, JPA simply doesn&apos;t support loading an old instance of an entity in case an instance has already been loaded, e.g. load user 4711, invoke setters on it, change its state. There is no way to get user instance that represents the state in the database without throwing away all modifications. The only thing you can do is suppress the flushing (to avoid the changes being written to the database eagerly) and then issue a query that uses a DTO constructor expression to retrieve &quot;old&quot; data.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10000">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="59261">DATAREST-373</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10151">
                    <name>Relate</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="69528">DATAREST-874</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="65889">DATAREST-678</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 18 Aug 2016 20:19:41 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10280" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>olivergierke</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i09don:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10381" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Ranking</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10120" key="com.atlassian.jira.plugin.system.customfieldtypes:url">
                        <customfieldname>Reference URL</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[https://gitter.im/spring-projects/spring-data?at=57b4ceffbe8025f1694b05d9]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>