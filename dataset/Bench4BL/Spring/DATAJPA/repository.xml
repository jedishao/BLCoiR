<?xml version = "1.0" encoding = "UTF-8" ?>
<bugrepository name="DATAJPA">
	<bug id="23" opendate="2011-02-14 08:01:40" fixdate="2011-02-14 09:16:58" resolution="Fixed">
		<buginformation>
			<summary>Creating queries from method names with IsNull and IsNotNull is broken</summary>
			<description>In JpaQueryCreator&amp;amp;apos;s toPredicate() method instead of following lines






        case IS_NULL:




            return root.isNull();




        case IS_NOT_NULL:




            return root.isNotNull();






should be






        case IS_NULL:




            return path.isNull();




        case IS_NOT_NULL:




            return path.isNotNull();





</description>
			<version>1.0 M1</version>
			<fixedVersion>1.0 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryCreator.java</file>
		</fixedFiles>
	</bug>
	<bug id="44" opendate="2011-03-29 13:34:20" fixdate="2011-04-05 02:51:47" resolution="Fixed">
		<buginformation>
			<summary>Using named queries fails for methods not returning an entity</summary>
			<description>We are migrating from Hades and were very surprised to find exceptions in the JPA NamedQuery parsing.  The queries are defined on the entities.  The ones triggering the exceptions do not return entities.  I think that this is permitted by the specification and did work fine with Hades and Hibernate.  Here is an example:






@NamedQuery(name = "CountryAgreement.getLatestAgreementVersion", query = "select max(version) from CountryAgreement c where c.country.id = ?1 ")






The repository method Long getLatestAgreementVersion(Long countryId); and exception:
Caused by: java.lang.IllegalArgumentException: No property getLatestAgreement found for type class java.lang.Long
	at org.springframework.data.repository.query.parser.Property.&amp;lt;init&amp;gt;(Property.java:66)
	at org.springframework.data.repository.query.parser.Property.&amp;lt;init&amp;gt;(Property.java:100)
	at org.springframework.data.repository.query.parser.Property.create(Property.java:302)
	at org.springframework.data.repository.query.parser.Property.create(Property.java:268)
	at org.springframework.data.repository.query.parser.Property.from(Property.java:227)
	at org.springframework.data.repository.query.parser.Property.from(Property.java:215)
	at org.springframework.data.repository.query.parser.Part.&amp;lt;init&amp;gt;(Part.java:48)
	at org.springframework.data.repository.query.parser.PartTree$OrPart.&amp;lt;init&amp;gt;(PartTree.java:242)
	at org.springframework.data.repository.query.parser.PartTree.buildTree(PartTree.java:101)
	at org.springframework.data.repository.query.parser.PartTree.&amp;lt;init&amp;gt;(PartTree.java:77)
	at org.springframework.data.jpa.repository.query.PartTreeJpaQuery.&amp;lt;init&amp;gt;(PartTreeJpaQuery.java:51)
	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:100)
	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateIfNotFoundQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:176)
	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$AbstractQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:73)
	at org.springframework.data.repository.support.RepositoryFactorySupport$QueryExecuterMethodInterceptor.&amp;lt;init&amp;gt;(RepositoryFactorySupport.java:259)
	at org.springframework.data.repository.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:143)
	at org.springframework.data.repository.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:107)
	at org.springframework.data.repository.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:36)
	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:142)
	... 36 more</description>
			<version>1.0 M2</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryExecution.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryMethodUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryMethod.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.AbstractJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryExecutionUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="58" opendate="2011-05-06 18:25:26" fixdate="2011-05-19 23:02:40" resolution="Fixed">
		<buginformation>
			<summary>Persistable.isNew is not used by JpaPersistableEntityInformation</summary>
			<description>The isNew()  method is not used by JpaPersistableEntityInformation , which causes unwanted behavior in Repository.save() 
JpaPersistableEntityInformation  should extend PersistableEntityInformation instead of AbstractEntityInformation</description>
			<version>1.0 M2</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.JpaPersistableEntityInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="68" opendate="2011-06-08 08:23:49" fixdate="2011-06-13 16:25:26" resolution="Fixed">
		<buginformation>
			<summary>AuditingEntityListener problem with determining if entity is new</summary>
			<description>Actually ran into this problem in the Hades library but I see the code is still the same.  Using EclipseLink (2.1.3), the id is already set on the entity when it is passed to the method annotated with @PrePersist and @PreUpdate so calling isNew() on the entity to determine if the creation audits should be applied doesn&amp;amp;apos;t work (always returns false).  I suggest splitting the @PrePersist and @PreUpdate to separate methods and not using isNew().</description>
			<version>1.0 M2</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.domain.support.AuditingEntityListener.java</file>
			<file type="M">org.springframework.data.jpa.domain.support.AuditingEntityListenerUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="64" opendate="2011-05-19 15:42:29" fixdate="2011-06-21 12:23:39" resolution="Fixed">
		<buginformation>
			<summary>Automatically generated queries do not use bind variables for numeric parameters</summary>
			<description>The automatically generated queries from method names do not use bind variables for numeric types.  For example,






public interface SomeEntityRepository implements JpaRepository&amp;lt;SomeEntity, Long&amp;gt;




{




    List&amp;lt;SomeEntity&amp;gt; findBySomeProperty(int value);




}






The criteria builder for the query inserts the parameter using the statement builder.equal(path, iterator.next()); rather than assigning it to a bind variable and setting the parameter in the resulting Query.  In the case of numeric parameter types (integer, long, etc.), Hibernate does not turn this into a bind variable; instead it treats the value as a constant in the generated query.  This makes the query from method name feature unusable from a performance standpoint.</description>
			<version>1.0 M1</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.NamedQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaCountQueryCreator.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryExecution.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.SpecialUser.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.Role.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.AbstractStringBasedJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.ParameterBinder.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.AbstractJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.PartTreeJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryExecutionUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryCreator.java</file>
		</fixedFiles>
	</bug>
	<bug id="77" opendate="2011-07-18 23:29:39" fixdate="2011-07-19 00:53:08" resolution="Fixed">
		<buginformation>
			<summary>Count query for manually declared queries (either @Query or NamedQuery) get pagination applied</summary>
			<description>When executing a paging query the executing infrastructure triggers a count query to compute the number of overall results. If you define the query manually by using @Query or via a JPA NamedQuery the count query generation seems to also get the pagination information applied (see forum post for example).
This seems to boil down to SimpleJpaQuery.createCountQuery(...) calling ParameterBinder.bindAndPrepare(...) instead of prepare(...) as the former call applies pagination information to the query.</description>
			<version>1.0 RC1</version>
			<fixedVersion>1.0 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQueryUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="94" opendate="2011-08-27 12:29:45" fixdate="2011-08-29 03:45:43" resolution="Fixed">
		<buginformation>
			<summary>Sort order inside Pageable is not respected on PartTree generated queries</summary>
			<description>Here is a test method for UserRepositoryFinderTests 











@Test




public void respectsPageableOrder() throws Exception {




	Page&amp;lt;User&amp;gt; ascending = userRepository.findByLastname(new PageRequest(0, 10, new Sort(Direction.ASC, "lastname")),"Matthews");




	Page&amp;lt;User&amp;gt; descending = userRepository.findByLastname(new PageRequest(0, 10, new Sort(Direction.DESC, "lastname")),"Matthews");




	assertThat(ascending.getTotalElements(), is(2L));




	assertThat(descending.getTotalElements(), is(2L));




	assertThat(ascending.getContent().get(0).getFirstname(), is(not(equalTo(descending.getContent().get(0).getFirstname()))));




	assertThat(ascending.getContent().get(0).getFirstname(), is(equalTo(descending.getContent().get(1).getFirstname())));




	assertThat(ascending.getContent().get(1).getFirstname(), is(equalTo(descending.getContent().get(0).getFirstname())));




}










</description>
			<version>1.0 GA</version>
			<fixedVersion>1.0.1, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryFinderTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.PartTreeJpaQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="96" opendate="2011-08-29 14:05:09" fixdate="2011-09-04 06:09:35" resolution="Fixed">
		<buginformation>
			<summary>Invalid use of part.getProperty().toDotPath() in JpaQueryCreator</summary>
			<description>As explained in great details in the forum (see reference). Short Summary: 
All usages of part.getProperty().toDotPath() in JpaQueryCreator are invalid because the persistence provider expects single attributes and not object graphs as input of get() method.
Happens with LIKE, NOT_LIKE, BETWEEN and perhaps in other places too.</description>
			<version>1.0 GA</version>
			<fixedVersion>1.0.1, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryCreator.java</file>
		</fixedFiles>
	</bug>
	<bug id="86" opendate="2011-08-13 03:49:52" fixdate="2011-09-05 03:16:48" resolution="Fixed">
		<buginformation>
			<summary>find-Method throws exception when a group-by-clause is used</summary>
			<description>When using a repository to get a Page object with this method Page&amp;lt;T&amp;gt; findAll(Specification&amp;lt;T&amp;gt; specification, Pageable pageable) two queries are generated. A count-Query to get the total number of results and the actual query to get the results for the page. When the specification-parameter contains a group by-clause the count-query throws an exception org.springframework.dao.IncorrectResultSizeDataAccessException result returns more than one elements). The problem is that the group by-clause returns more than one result row for the count query and only a single result with one number is expected.
Example:






SELECT DISTINCT COUNT(id) FROM Table WHERE value &amp;gt; 70 GROUP BY name;






Result:
4 (for name1)
7 (for name2)
2 (for name3)
So if there&amp;amp;apos;s more than one result being returned from the count query we actually have to consider the size of the list instead of the value returned.</description>
			<version>1.0 RC1</version>
			<fixedVersion>1.0.1, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.NamedQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryExecution.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.ParameterBinder.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.AbstractJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryExecutionUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.PartTreeJpaQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="110" opendate="2011-09-28 15:18:02" fixdate="2011-10-11 09:28:44" resolution="Fixed">
		<buginformation>
			<summary>Error identifying &amp;apos;alias&amp;apos; when the entity&amp;apos;s name has numbers</summary>
			<description>When a query is generated by spring-data, an error is provocated by org.springframework.data.jpa.repository.query.QueryUtils because does not recognize names of entities containing numbers. Example of entity name: T05User.
The error is on line 57 of class QueryUtils, the pattern does not match with words that contains numbers.






private static final String IDENTIFIER = "[\\p{L}._$]+";






A proposed solution is






private static final String IDENTIFIER = "[\\p{L}(\\d*)._$]+";





</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2, 1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="111" opendate="2011-10-06 18:23:47" fixdate="2011-10-12 02:51:21" resolution="Fixed">
		<buginformation>
			<summary>The SimpleJpaRepository&amp;apos;s deleteAll() should not call em.clear().</summary>
			<description>Now, the SimpleJpaRepository&amp;amp;apos;s deleteAll() calls em.clear(). So, If I use B.deleteAll() after A.insert(), the insertion of A is ignored.






@Transactional




public void doSomething() {




  Book springBook = new Book("spring");




  bookRepository.save(springBook);




  




  CardRepository.deleteAll();




  




  //then, the springBook will not be inserted to the DB, because in the deleteAll(), em.clear() is called.




}





</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2, 1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="120" opendate="2011-10-31 09:53:42" fixdate="2011-12-02 08:43:55" resolution="Fixed">
		<buginformation>
			<summary>@OneToOne mappings in AbstractAuditable should rather be @ManyToOne ones</summary>
			<description></description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2, 1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.domain.AbstractAuditable.java</file>
		</fixedFiles>
	</bug>
	<bug id="141" opendate="2011-12-14 12:30:34" fixdate="2011-12-15 08:29:36" resolution="Fixed">
		<buginformation>
			<summary>JpaMetamodelEntityInformation cannot deal with mapped superclasses</summary>
			<description>Currently repository interfaces cannot be used with a @MappedSuperclass annotated JPA entity class as we try to lookup an EntityType from the EntityManager&amp;amp;apos;s Metamodel which MappedSuperclass aren&amp;amp;apos;t. We should rather use .managedType() and see if it implements IdentitifiedType to look for id information.</description>
			<version>1.0.2</version>
			<fixedVersion>1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.JpaPersistableEntityInformationUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="138" opendate="2011-12-14 08:22:54" fixdate="2012-01-11 05:22:42" resolution="Fixed">
		<buginformation>
			<summary>MergingPersistenceUnitManager doesnt work with Spring 3.1.0 DefaultPersistenceUnitManager</summary>
			<description>The following check in DefaultPersistenceUnitManager of Spring ORM 3.1.0.RELEASE defeats the purpose of the merge using the same persistence unit name:






String name = pui.getPersistenceUnitName();




if (!this.persistenceUnitInfoNames.add(name)) {




	StringBuilder msg = new StringBuilder();




	msg.append("Conflicting persistence unit definitions for name &amp;amp;apos;").append(name).append("&amp;amp;apos;: ");




	msg.append(pui.getPersistenceUnitRootUrl()).append(", ");




	msg.append(this.persistenceUnitInfos.get(name).getPersistenceUnitRootUrl());




	throw new IllegalStateException(msg.toString());




}





</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.3, 1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.support.MergingPersistenceUnitManager.java</file>
			<file type="M">org.springframework.data.jpa.support.MergingPersistenceUnitManagerUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">8925</link>
			<link type="Depend" description="depends on">151</link>
		</links>
	</bug>
	<bug id="142" opendate="2011-12-16 04:11:08" fixdate="2012-01-11 06:16:28" resolution="Fixed">
		<buginformation>
			<summary>Invalid count query generated when using Pageable and NamedQuery with existing order by</summary>
			<description>Taking:






@NamedQuery(name = "Test.findQuery", query = "from Test te where te.name like ?1 order by te.name desc")






And executing using:






repository.findQuery(name, new PageRequest(0, 5));






Results in:






org.springframework.orm.hibernate3.HibernateJdbcException: 




JDBC exception on Hibernate data access: 




SQLException for SQL [select count(test0_.id) as col_0_0_ from test test0_ where test0_.name=? order by test0_.name desc]; 




SQL state [null]; 




error code [0]; could not execute query; 




nested exception is org.hibernate.exception.GenericJDBCException: could not execute query...






I&amp;amp;apos;m in 2 minds whether this is actually "correct" behaviour and whether there can be a more friendly/elegant way of warning or erroring out upfront if pageable requests are made on a named query with ordering etc. or whether the count query should be amended to exclude the order by (though there are probably a myriad of edge case scenarios that would then need to be catered for.)
Or is it just a case of &amp;amp;apos;caveat emptor&amp;amp;apos; when mapping to a named query and using pageable finders? I&amp;amp;apos;d hope there was some middle ground!</description>
			<version>1.0.2</version>
			<fixedVersion>1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.NamedQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.NamedQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryMethod.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryMethodUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.Query.java</file>
		</fixedFiles>
	</bug>
	<bug id="121" opendate="2011-11-07 20:04:49" fixdate="2012-02-02 06:09:01" resolution="Fixed">
		<buginformation>
			<summary>Query parameter is null,it still use equals(=) to compare</summary>
			<description>When a simple property reference gets a null
a tree model table,it has parent is null,i use method public Tree findByParent(Tree parent);
when parameter is null,will return null result.because it use "where parent=null" or not "parent is null"</description>
			<version>1.0.1</version>
			<fixedVersion>1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.JpaCountQueryCreator.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.PartTreeJpaQueryIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.PartTreeJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.ParameterExpressionProviderTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.CriteriaQueryParameterBinder.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryCreator.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">209</link>
		</links>
	</bug>
	<bug id="137" opendate="2011-12-13 06:06:57" fixdate="2012-02-02 09:20:20" resolution="Fixed">
		<buginformation>
			<summary>deleteAll() - generated bulk delete queries do not respect cascade delete</summary>
			<description>delete from %s x does not respect cascade delete operations (with hibernate at least).
Performing:






for(T entity : this.findAll()) {




    delete(entity);




}






Operates as expected - though obviously looses the efficiency of the bulk query.
Additionally, attempting to do:






delete(findAll())






Will fail if there is a cascade delete dependency between objects of the same type:
"deleted instance passed to merge"
As the check:






em.remove(em.contains(entity) ? entity : em.merge(entity));






Correctly establishes the entity no longer exists and attempts to do a merge instead (not entirely sure why as if it doesn&amp;amp;apos;t exist in the persistence context and we&amp;amp;apos;re attempting to delete it a merge has no purpose?). Surely:






if(em.contains(entity)) {




    em.remove(entity);




}






Is the correct functionality here?</description>
			<version>1.0.2</version>
			<fixedVersion>1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.JpaRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="169" opendate="2012-02-12 14:47:33" fixdate="2012-03-12 11:20:35" resolution="Fixed">
		<buginformation>
			<summary>JPA Repository can get typing of @Query annotated findXXX methods wrong</summary>
			<description>If I have an entity with a getter containing a set (of itself in this case - it&amp;amp;apos;s a tree structure):






    @ManyToMany(fetch=FetchType.EAGER)




    @JoinTable(




        name="ancestors",




        joinColumns=@JoinColumn(name="entity_id"),




        inverseJoinColumns=@JoinColumn(name="entity_ancestor_id")




    )




    public Set&amp;lt;TreeEntity&amp;gt; getAncestors() {




        return ancestors;




    }






and I have a method on my repository:






    @Query("select " +




            "    distinct entity.ancestors " +




            "from " +




            "    example.data.TreeEntity entity " +




            "where " +




            "    entity.id = :entityId")




    public List&amp;lt;TreeEntity&amp;gt; findAncestors(@Param("entityId") Long groupId);






then in 1.1.0 RC1, when the query is parsed, it believes that the signature of the method should return List&amp;lt;Set&amp;lt;TreeEntity&amp;gt;&amp;gt;, when in fact the query will really return a List&amp;lt;Group&amp;gt;. 1.0.3 got this correct, and so it&amp;amp;apos;s a regression.
I attach a very basic Maven project which shows the problem. Changing the version back to 1.0.3 gets the query typing correct.</description>
			<version>1.1 RC1</version>
			<fixedVersion>1.1 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="189" opendate="2012-04-11 07:32:23" fixdate="2012-04-12 01:49:04" resolution="Fixed">
		<buginformation>
			<summary>MergingPersistenceUnitManager potentially adds classes multiple times</summary>
			<description>MergingPersistenceUnitManager does not guard against the the new PUI&amp;amp;apos;s root URL bing equivalent to the old ones. In this case the old PUIs root URL gets added to the list of JAR file URLs but does not get removed as root URL which might cause persistence providers (e.g. Hibernate) cause complaining about duplicate entries. </description>
			<version>1.0.3</version>
			<fixedVersion>1.1 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.support.MergingPersistenceUnitManager.java</file>
			<file type="M">org.springframework.data.jpa.support.MergingPersistenceUnitManagerUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="186" opendate="2012-04-06 22:28:30" fixdate="2012-04-15 10:16:31" resolution="Fixed">
		<buginformation>
			<summary>Typos in log message when named query is used with a Pageable</summary>
			<description>Create a repository method as follows:

public interface UserRepository extends JpaRepository&amp;lt;User, Long&amp;gt;
{
    Page&amp;lt;User&amp;gt; findAllByNameLike(String name, Pageable page);
}
When the application context is initialized, the following message appears in the logs:

INFO Finder method org.example.data.UserRepository.findAllByNameLike is backed by a NamedQuery but contains a Pageble parameter! Sorting deliviered via this Pageable will not be applied!
This message has two typos Pageble and deliviered.</description>
			<version>1.1 RC1</version>
			<fixedVersion>1.0.3, 1.1 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.NamedQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="177" opendate="2012-02-25 07:24:45" fixdate="2012-04-15 11:32:27" resolution="Fixed">
		<buginformation>
			<summary>SimpleJpaRepository.delete(ID id) should validate entity/record existance prior to issue delete command.</summary>
			<description>If an invalid ID (and ID that does not exists in the DB) is passed to delete(ID id), it fails with:
org.springframework.dao.InvalidDataAccessApiUsageException: attempt to create merge event with null entity; nested exception is java.lang.IllegalArgumentException: attempt to create merge event with null entity.
This is caused because delete(ID id) ends up calling delete(T entity) after retrieving the entity with findOne(id):






SimpleJpaRepository.delete(ID id)






public void delete(ID id) {









    delete(findOne(id));




}






So then, delete(T entity) performs a validation prior to calling em.delete():






SimpleJpaRepository.delete(T entity)






public void delete(T entity) {









    em.remove(em.contains(entity) ? entity : em.merge(entity));




}






Since the entity does not exist, em.contains(entity) returns false and em.merge(entity) is called causing the exception above.
IMO, I believe that this situation should be gracefully handled by the framework. I propose changing the delete(ID id) method to something like:






SimpleJpaRepository.delete(ID id)






public void delete(ID id) {




    T entity = findOne(id);




    if(entity == null){




        throw new InvalidIdException(); // just an example, should throw the exception you think is appropiate




    }









    delete(entity);




}






Just my 2 cents. Keep up the great work!</description>
			<version>1.0.3</version>
			<fixedVersion>1.1 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepositoryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="201" opendate="2012-04-25 01:42:19" fixdate="2012-04-27 09:47:25" resolution="Fixed">
		<buginformation>
			<summary>JpaQueryExecution started to throw NullPointerException if pageable is null</summary>
			<description>In version 1.1.0.M1 it was possible to pass null for parameter pageable.
Now JpaQueryExecution throws NullPointerException.
java.lang.NullPointerException
	at org.springframework.data.jpa.repository.query.JpaQueryExecution$PagedExecution.doExecute(JpaQueryExecution.java:107)
	at org.springframework.data.jpa.repository.query.JpaQueryExecution.execute(JpaQueryExecution.java:56)
	at org.springframework.data.jpa.repository.query.AbstractJpaQuery.doExecute(AbstractJpaQuery.java:95)
	at org.springframework.data.jpa.repository.query.AbstractJpaQuery.execute(AbstractJpaQuery.java:85)
	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:302)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:110)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:155)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
	at org.springframework.data.jpa.repository.support.LockModeRepositoryPostProcessor$LockModePopulatingMethodIntercceptor.invoke(LockModeRepositoryPostProcessor.java:91)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:90)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:202)</description>
			<version>1.1 RC1</version>
			<fixedVersion>1.1 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.EclipseLinkNamespaceUserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryExecution.java</file>
		</fixedFiles>
	</bug>
	<bug id="226" opendate="2012-06-29 07:22:14" fixdate="2012-07-18 02:13:54" resolution="Fixed">
		<buginformation>
			<summary>Misleading Exception when @Query is not valid</summary>
			<description>Repository Function:






@Query("select distict(foo.bar) from Foo foo) List&amp;lt;Bar&amp;gt; getBar();






distict is intentional wrong, this will cause the problem. When the Repository is being created the following Exception occurs:






Caused by: java.lang.IllegalArgumentException: No property get found for type class Foo






It seems that after the validation of the Query results in a failure the query generation by method name is triggered.</description>
			<version>1.1 GA</version>
			<fixedVersion>1.1.1, 1.2 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryLookupStrategyUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="232" opendate="2012-07-18 23:52:34" fixdate="2012-07-19 00:59:31" resolution="Fixed">
		<buginformation>
			<summary>Parameter binding in SimpleJpaRepository.findAll(Iterable&lt;ID&gt; ids) fails for non-Lists</summary>
			<description>If I use JpaRepository I have the method:






/**




 * Returns all instances of the type with the given IDs.




 * 




 * @param ids




 * @return




 */




Iterable&amp;lt;T&amp;gt; findAll(Iterable&amp;lt;ID&amp;gt; ids);






But if I call with a Set, the method fail.
Caused by: 






java.lang.IllegalArgumentException: Named parameter [ids] type mismatch; expecting [java.util.List], found [java.util.HashSet]




	at org.hibernate.ejb.criteria.CriteriaQueryCompiler$3.resolveExplicitCriteriaParameterName(CriteriaQueryCompiler.java:392)




	at org.hibernate.ejb.criteria.CriteriaQueryCompiler$3.setParameter(CriteriaQueryCompiler.java:380)




	at org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(SimpleJpaRepository.java:247)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:334)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:319)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:110)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:155)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.data.jpa.repository.support.LockModeRepositoryPostProcessor$LockModePopulatingMethodIntercceptor.invoke(LockModeRepositoryPostProcessor.java:91)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:90)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:202)




	at $Proxy62.findAll(Unknown Source)






Perhaps only fails with Hibernate, but I think at least, the Javadoc or the API must fixed.</description>
			<version>1.1 GA</version>
			<fixedVersion>1.1.1, 1.2 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.EclipseLinkNamespaceUserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.OpenJpaNamespaceUserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="243" opendate="2012-08-11 00:31:04" fixdate="2012-08-13 01:39:22" resolution="Fixed">
		<buginformation>
			<summary>Sorting of paginated results is not working when Querydsl is used </summary>
			<description>I have following code that was working perfectly with 1.1.0.RELEASE (I am using Querydsl 2.7.0):






@Transactional(readOnly = true)




@Override




public List&amp;lt;Person&amp;gt; search(SearchDTO dto) {




	//Gets predicate by using static method of the query builder class




	Predicate predicate = firstOrLastNameStartsWith(dto.getSearchTerm());	




	Pageable pageSpecification = buildPageSpecification(dto.getPageIndex(), dto.getPageSize());









	Page&amp;lt;Person&amp;gt; page = repository.findAll(predicate, pageSpecification);









	return page.getContent();




}









private Pageable buildPageSpecification(int pageIndex, int pageSize) {




	return new PageRequest(pageIndex, pageSize, sortByLastNameAndFirstNameAsc());




}









private Sort sortByLastNameAndFirstNameAsc() {




	return new Sort(new Sort.Order(Sort.Direction.ASC, "lastName"),




	            new Sort.Order(Sort.Direction.ASC, "firstName")




    );




}






After I updated to 1.2.0.M1, query results were no longer sorted. The problem is that the applySorting() method method of Querydsl class is never called when paginated queries are build by Spring Data JPA. The relevant methods of the Querydsl class are given in following (my comment in CAPS):






public JPQLQuery applyPagination(Pageable pageable, JPQLQuery query) {









	if (pageable == null) {




		return query;




	}









	query.offset(pageable.getOffset());




	query.limit(pageable.getPageSize());









        //CALL TO applySorting(pageable.getSort(), query) IS MISSING?









	return query;




}









public JPQLQuery applySorting(Sort sort, JPQLQuery query) {









	if (sort == null) {




		return query;




	}









	for (Order order : sort) {




		query.orderBy(toOrder(order));




	}









	return query;




}









@SuppressWarnings({ "rawtypes", "unchecked" })




private OrderSpecifier&amp;lt;?&amp;gt; toOrder(Order order) {









	Expression&amp;lt;Object&amp;gt; property = builder.get(order.getProperty());









	return new OrderSpecifier(order.isAscending() ? com.mysema.query.types.Order.ASC




			: com.mysema.query.types.Order.DESC, property);




}






The original discussion about this problem is found at:
http://forum.springsource.org/showthread.php?129211-Sorting-problem-with-paginated-query-results-%28Spring-Data-JPA-1-2-0-M1-and-Querydsl%29</description>
			<version>1.2 M1</version>
			<fixedVersion>1.2 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.QueryDslJpaRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.Querydsl.java</file>
		</fixedFiles>
	</bug>
	<bug id="253" opendate="2012-08-30 01:23:44" fixdate="2012-08-30 03:01:23" resolution="Fixed">
		<buginformation>
			<summary>Result of Specifications.not(..) produces wrong Specification when combined directly with other Specifications</summary>
			<description>The specification constructed as 






Specifications spec = Specifications.not(spec1).and(spec2);






results in a Specification without the negation, i.e. SQL like SELECT ... WHERE (...) AND (...) instead of SELECT ... WHERE NOT (...) AND (...). 
This seems to happen because the negation implemented by overriding the Specification.toPredicate() method. 
A fix is to implement negation like the other operations, that is






public static &amp;lt;T&amp;gt; MySpecifications&amp;lt;T&amp;gt; not(final Specification&amp;lt;T&amp;gt; spec) {









   return new MySpecifications&amp;lt;T&amp;gt;(new Specification&amp;lt;T&amp;gt;() {









      public Predicate toPredicate(Root&amp;lt;T&amp;gt; root, CriteriaQuery&amp;lt;?&amp;gt; query, CriteriaBuilder builder) {




         return builder.not(spec.toPredicate(root, query, builder));




      }




   });




}






A workaround is to always wrap negation in a Specification, e.g.






Specifications spec = Specifications.where(Specifications.not(spec1)).and(spec2);





</description>
			<version>1.1.2</version>
			<fixedVersion>1.2 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.domain.Specifications.java</file>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="257" opendate="2012-09-21 01:20:10" fixdate="2012-10-09 00:24:12" resolution="Fixed">
		<buginformation>
			<summary>Calls on Repository Methods with Pageable parameters fail when using horizontal partitioning (eclipseLink)</summary>
			<description>When a Repository method with a Pageable parameter is called this call results in a count query for the entity. If the entity is partitioned EclipseLink (imho every jpa provider) will fire this query on every node associated with the partitioned entity and union the result.
This means the result for the count is no longer one row but multiple rows which causes an exception.
Proposed Fix:
add a flag that can be configured per entity or per call (on the pageable?) that removes the count query.
alternatively remove the count query as it is very expensive anyway (at least on tables with a lot of rows, which is one of the main use cases for pageable requests).
Associated Classes:
org.springframework.data.jpa.repository.support.SimpleJpaRepository</description>
			<version>1.1.2</version>
			<fixedVersion>1.2 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryExecution.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="268" opendate="2012-11-06 04:11:56" fixdate="2012-11-06 06:05:50" resolution="Fixed">
		<buginformation>
			<summary>LockModePopulatingMethodInterceptor leak causes OutOfMemoryError: PermGen space</summary>
			<description>In cases where locking is not externally set (like when invoking it form a non @Transactional call stack) org.springframework.data.jpa.repository.support.LockModeRepositoryPostProcessor.LockModePopulatingMethodIntercceptor.invoke(MethodInvocation) is registering the locking mode itself (with the target method as key) using org.springframework.transaction.support.TransactionSynchronizationManager.bindResource(Object, Object), but is not calling org.springframework.transaction.support.TransactionSynchronizationManager#unbindResource(Object) afterwards.
In environments where the classloaders are discarded but the threads are reused, like in any application or web server with a service thread pool and hot redeployments, the VM ends up running out of PermGen space since 
{@link java.lang.Thread#threadLocals}
 will keep a strong reference to the bound method keeping alive the otherwise unused class loader and all its, classes and objects graph.
Sorry about the test case, it was written in a rush.
Heap dump can be found here (18Mb): https://dl.dropbox.com/u/1249691/LockModeRepositoryPostProcessor_LockModePopulatingMethodIntercceptorMemoryLeakTest.zip</description>
			<version>1.1 GA</version>
			<fixedVersion>1.2.1, 1.3 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.LockModeRepositoryPostProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="252" opendate="2012-08-27 12:41:02" fixdate="2012-12-17 02:32:15" resolution="Fixed">
		<buginformation>
			<summary>Pageable sorting by join property excludes null matches</summary>
			<description>When using the PagingAndSortingRepository with a Pageable query, attempts to sort by the join property will exclude entities where the join condition is absent.
From JSR-317 4.4.5.2:
LEFT JOIN and LEFT OUTER JOIN are synonymous. They enable the retrieval of a set of entities where matching values in the join condition may be absent.
According to standard SQL and JPA specs, the left outer join should always contain all entities from the "left" table even if the join condition is absent. Therefore, the exclusion of the "left" entities when there is no matching value in the "right" table seems incorrect.
For example, given an entity "Person" with optional OneToOne relationship "Address" (where Address is the owner), any attempts to retrieve pages of Person entities from the repository that are ordered by an Address property will only return Person entities that have non-null Addresses. This is only a problem for Pageable and Sort queries; using the same @Query with a non-pageable/sort works as expected.






// Includes Persons with no Addresses and sorts by address.city, as expected




@Query("select p from Person p left outer join p.address address order by address.city")




List&amp;lt;Person&amp;gt; findPersonOrderByCity();









// Excludes Persons with no Addresses when sorting by an address property




@Query("select p from Person p left outer join p.address address")




Page&amp;lt;Person&amp;gt; findPerson(Pageable pageable);









// Excludes Persons with no Addresses when sorting by an address property    




@Query("select p from Person p left outer join p.address address")




List&amp;lt;Person&amp;gt; findPerson(Sort sort);






The resulting core sql statements (simplified slightly for brevity) are as follows; notice the additional FROM clause incorrectly added to the pageable query:






@Query("select p from Person p left outer join p.address address order by address.city")




List&amp;lt;Person&amp;gt; findPersonOrderByCity();




select p.id, p.first_name, p.last_name from person p left outer join address a on p.id=a.person order by a.city









@Query("select p from Person p left outer join p.address address")




Page&amp;lt;Person&amp;gt; findPerson(Pageable pageable);




select p.id, p.first_name, p.last_name from person p left outer join address a on p.id=a.person, address a2 where p.id=a2.person order by a2.city asc






A full test case is attached. This has been tested with spring-data-jpa-1.1.1.RELEASE and hibernate-4.1.5.SP1.</description>
			<version>1.1.2</version>
			<fixedVersion>1.2 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="277" opendate="2012-12-17 06:46:37" fixdate="2013-01-17 05:07:37" resolution="Fixed">
		<buginformation>
			<summary>Pageable sorting by join property excludes null matches with Specifications</summary>
			<description>If you have a repository that extends JpaSpecficationExecutor and use the findAll method with a Specification, the resulting query excludes null matches from the result.  This may be related to issue DATAJPA-252.
I&amp;amp;apos;ve attached a test case that demonstrates how DATAJPA-252 is fixed but this is still an issue.</description>
			<version>1.2 GA</version>
			<fixedVersion>1.2.1, 1.3 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.EclipseLinkNamespaceUserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">346</link>
		</links>
	</bug>
	<bug id="287" opendate="2013-01-23 10:46:23" fixdate="2013-01-25 09:58:54" resolution="Fixed">
		<buginformation>
			<summary>Count query doesn&amp;apos;t take into account the distinct property of target query</summary>
			<description>I found the issue using the Specification and PageRequest when i have joins and distinct at the same time in my query. When i call Page.getTotalElements() i get wrong number, bigger than it should be. Seems that duplicate items introduced by join get counted for total elements.
So the problem is that i use joins while building a Predicate, so to eliminate duplicates i set distinct property of query object to true:






public Predicate toPredicate(Root&amp;lt;Parent&amp;gt; root, CriteriaQuery&amp;lt;?&amp;gt; query, CriteriaBuilder cb) {




                Path&amp;lt;Set&amp;lt;Child&amp;gt;&amp;gt; childrenPath = root.get("children");




                root.join("children");




                query.distinct(true);




                return cb.isNotEmpty(childrenPath);




            }






As i see from DATA JPA code before doing the actual select query it performs count query, from my log it&amp;amp;apos;s the following:






select




        distinct count(*) as col_0_0_ 




    from




        parent parent0_ 




    inner join




        parent_children children1_ 




            on parent0_.id=children1_.parent_id 




    inner join




        child child2_ 




            on children1_.child_id=child2_.id 




    where




        exists (




            select




                child4_.id 




            from




                parent_children children3_,




                child child4_ 




            where




                parent0_.id=children3_.parent_id 




                and children3_.child_id=child4_.id




        )






As i understand distinct clause should be inside count() function:






select count(distinct *) ...






If i run such query directly in DB i&amp;amp;apos;ll get the right number of items.
I believe this issue can be fixed by using countDistinct instead of count() here https://github.com/SpringSource/spring-data-jpa/blob/master/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java#L459
Or it can be conditionally ran 






if (query.isDistinct()) {




    query.select(builder.countDistinct(root));




} else {




    query.select(builder.count(root));




}






Please see the attached zip file of the test project.
Please let me know if there is any workaround.</description>
			<version>1.2 GA</version>
			<fixedVersion>1.3 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="266" opendate="2012-11-01 10:14:43" fixdate="2013-01-28 02:02:44" resolution="Fixed">
		<buginformation>
			<summary> SimpleJpaRepository.exists(ID) fails, if ID is an composite key</summary>
			<description>I tried to deleted an entity via repo.delete(ID). 
The entity uses an composite key. 
Following exception was thrown:
org.springframework.dao.InvalidDataAccessApiUsageException: Parameter value [MyId@92121c] did not match expected type [java.lang.String];
I saw delete(ID) uses exisits(ID). Exists grabs idAttributeName via 
String idAttributeName = entityInformation.getIdAttribute().getName();
But getName() returns the first value of my composite key only.</description>
			<version>1.2 GA</version>
			<fixedVersion>1.2.1, 1.3 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.JpaEntityInformation.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaEntityInformationSupportUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="280" opendate="2013-01-02 07:52:02" fixdate="2013-01-28 02:06:34" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException in unit test</summary>
			<description>NPE is caused when AuditingHandler is null on AuditingEntityListener.






-------------------------------------------------------------------------------




Test set: org.springframework.data.jpa.repository.NamespaceUserRepositoryTests




-------------------------------------------------------------------------------




Tests run: 74, Failures: 0, Errors: 67, Skipped: 1, Time elapsed: 1.943 sec &amp;lt;&amp;lt;&amp;lt; FAILURE!




deleteAll(org.springframework.data.jpa.repository.NamespaceUserRepositoryTests)  Time elapsed: 0.033 sec  &amp;lt;&amp;lt;&amp;lt; ERROR!




java.lang.NullPointerException




	at org.springframework.data.jpa.domain.support.AuditingEntityListener.touchForCreate(AuditingEntityListener.java:67)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.hibernate.ejb.event.ListenerCallback.invoke(ListenerCallback.java:45)




	at org.hibernate.ejb.event.EntityCallbackHandler.callback(EntityCallbackHandler.java:94)




	at org.hibernate.ejb.event.EntityCallbackHandler.preCreate(EntityCallbackHandler.java:63)




	at org.hibernate.ejb.event.EJB3PersistEventListener.saveWithGeneratedId(EJB3PersistEventListener.java:68)




	at org.hibernate.event.def.DefaultPersistEventListener.entityIsTransient(DefaultPersistEventListener.java:201)




	at org.hibernate.event.def.DefaultPersistEventListener.onPersist(DefaultPersistEventListener.java:147)




	at org.hibernate.event.def.DefaultPersistEventListener.onPersist(DefaultPersistEventListener.java:71)




	at org.hibernate.impl.SessionImpl.firePersist(SessionImpl.java:808)




	at org.hibernate.impl.SessionImpl.persist(SessionImpl.java:782)




	at org.hibernate.impl.SessionImpl.persist(SessionImpl.java:786)




	at org.hibernate.ejb.AbstractEntityManagerImpl.persist(AbstractEntityManagerImpl.java:839)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:240)




	at $Proxy35.persist(Unknown Source)






It&amp;amp;apos;s not the only test that fails.</description>
			<version>1.2 GA</version>
			<fixedVersion>1.3 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.domain.support.AuditingEntityListener.java</file>
		</fixedFiles>
	</bug>
	<bug id="296" opendate="2013-02-08 09:29:14" fixdate="2013-02-27 06:31:53" resolution="Fixed">
		<buginformation>
			<summary>Sort does not support case insensitive sorting </summary>
			<description>Currently when using the Sort class in the findAll method, the results returned are always case sensitive.  For example, if the following names were sorted they would be returned in this order:
Dave
Oliver
kevin
I&amp;amp;apos;m proposing that when sorting on properties that are Strings that it is possible to have the sort be case insensitive so that the results above would be returned as:
Dave
kevin
Oliver</description>
			<version>1.3 GA</version>
			<fixedVersion>1.4 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.QueryDslJpaRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.Querydsl.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">281</link>
			<link type="Duplicate" description="is duplicated by">327</link>
		</links>
	</bug>
	<bug id="327" opendate="2013-04-09 19:42:05" fixdate="2013-04-11 00:52:06" resolution="Fixed">
		<buginformation>
			<summary>Case insensitive sorting using Pageable</summary>
			<description>Currently, there is no way to specify in Spring-Data if the sorting is case insensitive or not. It is possible in Hibernate, but since Spring-Data is using springframework classes, clients can&amp;amp;apos;t specify if sorting is case sensitive or not.
Take this example:
I have this method in my Repository 






public interface ItemRepository extends QueryDslPredicateExecutor&amp;lt;Item&amp;gt;{




    @Query("SELECT o FROM Item o WHERE o.status = ?1")




    Page&amp;lt;Item&amp;gt; findByStatus(Item.Status status, Pageable pageable);




}






I want to be able to call that with:






itemRepository.findByStatus(Status.completed, new PageRequest(0, 10, Direction.ASC, "lower(name)")






Note the lower function in the property string. That doesn&amp;amp;apos;t work as Spring-data expects a property there. That will get translated to something like:






SELECT o FROM Item o WHERE o.status = ?1 ORDER BY o.lower(name)






which of course won&amp;amp;apos;t work as there is no &amp;amp;apos;lower&amp;amp;apos; property on the object.
In order to make this work, the Sort interface should have a case sensitive trigger.
Or to make it even more flexible, Sort could accept expressions as &amp;amp;apos;columns&amp;amp;apos;. E.g. accept expressions like:






lower(name)




lower(concat(firstName, ", ", lastName))




etc.






One easy way to do it would be to create a custom implementation of Sort, let&amp;amp;apos;s say ColumnExpressionSort which clients can use to define complex custom columns for sorting. In that case the client is responsible of specifying the full expression.
E.g. in the above case, the user would do:






ColumnExpressionSort sort = new ColumnExpressionSort("lower(o.name)", ASC);




itemRepository.findByStatus(Status.completed, new PageRequest(0, 10, sort);






Given that user does know how the query looks like, they&amp;amp;apos;d know that the returned object is using the o alias. Same for generated queries, they could use the default alias.
I&amp;amp;apos;m happy to work on the changes if the solution makes sense.
Cheers,
Iulian.</description>
			<version>1.3 GA</version>
			<fixedVersion>1.4 M1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.QueryDslJpaRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.Querydsl.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">296</link>
		</links>
	</bug>
	<bug id="330" opendate="2013-04-17 13:41:40" fixdate="2013-04-24 01:51:45" resolution="Fixed">
		<buginformation>
			<summary>@EnableJpaRepositories activates exception translation for @Repository classes not in basePackages</summary>
			<description>I have @Repository DAO classes that are not Spring Data repositories and are not part of the basePackages passed to @EnableJpaRepsitories(basePackages={}). They are incorrectly being activated for Spring DataAcessException translation and fail to autowire.
@Repository annotated classes in the basePackages passed to @EnableJpaRepsitories(basePackages={}) are correctly being activated for Spring DataAcessException translation.
After reading DATAJPA-112 and DATAJPA-221, I understand that @Repository makes a class eligible for Spring DataAccessException translation, but the basePackages paremeter of @EnableJpaRepositories implies I have control over which classes are translated. </description>
			<version>1.3 GA</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.NamespaceUserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.config.AbstractRepositoryConfigTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.config.JpaRepositoryConfigExtension.java</file>
			<file type="M">org.springframework.data.jpa.repository.config.JpaRepositoriesRegistrarIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.config.JpaRepositoryConfigExtensionUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">318</link>
			<link type="Relate" description="is related to">112</link>
			<link type="Relate" description="is related to">221</link>
		</links>
	</bug>
	<bug id="341" opendate="2013-05-03 13:49:59" fixdate="2013-05-29 09:37:47" resolution="Fixed">
		<buginformation>
			<summary>New LIKE expression handling breaks backward compatibility</summary>
			<description>This is a followup to DATAJPA-292: the new behaviour of LIKE expressions is uncompatible with older queries.
For example I have this method:






@Query("FROM User j WHERE j.name LIKE :pattern OR j.description LIKE :pattern")




Page&amp;lt;User&amp;gt; searchUsers(@Param("pattern") String pattern, Pageable page);






That I used to give the client the freedom to choose the pattern, so he could just pass "%" to browse all users, "%substring%" or "alex%" to filter them at will.
Up to Spring Data JPA 1.3.0 that works fine, but with 1.3.1 and above the web app can&amp;amp;apos;t start any more with this error:






Caused by: java.lang.IllegalArgumentException: Illegal like pattern :pattern!




	at org.springframework.data.jpa.repository.query.StringQuery.getLikeTypeFrom(StringQuery.java:205)




	at org.springframework.data.jpa.repository.query.StringQuery.parseLikeBindings(StringQuery.java:155)




	at org.springframework.data.jpa.repository.query.StringQuery.&amp;lt;init&amp;gt;(StringQuery.java:68)




	at org.springframework.data.jpa.repository.query.SimpleJpaQuery.&amp;lt;init&amp;gt;(SimpleJpaQuery.java:53)




	at org.springframework.data.jpa.repository.query.SimpleJpaQuery.fromQueryAnnotation(SimpleJpaQuery.java:138)




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$DeclaredQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:114)




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateIfNotFoundQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:160)




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$AbstractQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:68)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.&amp;lt;init&amp;gt;(RepositoryFactorySupport.java:279)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:147)




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:153)




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:43)




	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:142)






</description>
			<version>1.3.1</version>
			<fixedVersion>1.4 M1, 1.3.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.StringQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.StringQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="342" opendate="2013-05-06 02:59:45" fixdate="2013-05-29 09:38:15" resolution="Fixed">
		<buginformation>
			<summary>Wrong calculation of total number of elements when using DISTINCT clause</summary>
			<description>If I define a custom query of this type:






@Query("SELECT DISTINCT m.genre FROM Media m WHERE m.user = ?1 ORDER BY m.genre ASC")




Page&amp;lt;String&amp;gt; getJukeGenres(User user, Pageable pageable);






The resulting Page element has wrong Total Elements.
It seems like it gives the number of total records instead of the distinct ones.
I had to create another adhoc query just to have the correct count:






@Query("SELECT count(*) as num FROM Media m WHERE m.user = ?1 AND m.genre IS NOT NULL")




long countGenres(User user);






But this is tedious workaround that I would like to avoid</description>
			<version>1.3 GA</version>
			<fixedVersion>1.4 M1, 1.3.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="350" opendate="2013-06-02 16:38:01" fixdate="2013-06-04 05:35:04" resolution="Complete">
		<buginformation>
			<summary>Improve query validation by creating explicit EntityManager instance</summary>
			<description>org.springframework.data.jpa.repository.query.SimpleJpaQuery






SimpleJpaQuery(JpaQueryMethod method, EntityManager em, String queryString) {  









    




  // Try to create a Query object already to fail fast  




  if (!method.isNativeQuery()) {  




    try {  




      em.createQuery(query.getQuery());  




    } catch (RuntimeException e) {  




      // Needed as there&amp;amp;apos;s ambiguities in how an invalid query string shall be expressed by the persistence provider  




      // http://java.net/projects/jpa-spec/lists/jsr338-experts/archive/2012-07/message/17  




      throw e instanceof IllegalArgumentException ? e : new IllegalArgumentException(e);  




    }  




  }  




    




}  






create Query but not close because org.springframework.orm.jpa.SharedEntityManagerCreator
when execute Query:






if (method.getName().equals("getResultList") || method.getName().equals("getSingleResult") ||  




  method.getName().equals("executeUpdate")) {  




  EntityManagerFactoryUtils.closeEntityManager(this.em);  




}






to close the EntityManager. Simple solution:






EntityManager target = null;




// Try to create a Query object already to fail fast




if (!method.isNativeQuery()) {




 try {




  target = em.getEntityManagerFactory().createEntityManager();




  target.createQuery(query.getQuery());




 } catch (RuntimeException e) {




  // Needed as there&amp;amp;apos;s ambiguities in how an invalid query string shall be expressed by the persistence provider




  // http://java.net/projects/jpa-spec/lists/jsr338-experts/archive/2012-07/message/17




  throw e instanceof IllegalArgumentException ? e : new IllegalArgumentException(e);




 } finally {




  EntityManagerFactoryUtils.closeEntityManager(target);




 }




}





 </description>
			<version>1.3.2</version>
			<fixedVersion>1.4 M1, 1.3.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryLookupStrategyUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQueryUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">724</link>
			<link type="Relate" description="relates to">617</link>
			<link type="Relate" description="is related to">11451</link>
		</links>
	</bug>
	<bug id="352" opendate="2013-06-10 02:47:57" fixdate="2013-06-10 03:08:11" resolution="Fixed">
		<buginformation>
			<summary>SimpleJpaQuery validates count queries to aggressively</summary>
			<description>The fix for DATAJPA-350 introduced query validation for count queries as well which causes issues if the original query is not defined to be projected into a count query (e.g. including joins that will break the count() clause).</description>
			<version>1.4 M1</version>
			<fixedVersion>1.4 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQueryUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="359" opendate="2013-06-17 15:34:01" fixdate="2013-06-19 04:26:12" resolution="Complete">
		<buginformation>
			<summary>@Lock annotation doesn&amp;apos;t work on (at least) findOne method</summary>
			<description>If I have a repository defined thus:






public interface DataObjectRepository extends PagingAndSortingRepository&amp;lt;DataObject, Integer&amp;gt; {









	@Override




	@Lock(LockModeType.PESSIMISTIC_WRITE)




	DataObject findOne(Integer id);




	




	@Query("from DataObject o where o.id = ?1")




	@Lock(LockModeType.PESSIMISTIC_WRITE)




	DataObject findOneAndLock(Integer id);




}






and I run both findOne() and findOneAndLock() then only my more specific method acquires a lock - the @Lock annotation applied to the CRUD method has no effect on its operation. Interestingly, applying the annotation to the findAll method (as noted in the docs) does work !? The documentation suggests that the @Lock annotation should also apply to the other CRUD methods.
I&amp;amp;apos;ve created a sample Maven / Eclipse project to demonstrate the issue (this example uses Derby as its DB, but the issue is also present on at least MySQL where I discovered it first)
The output of running the test.Application class ends with some Hibernate logging of the Derby:






Hibernate: 




    select




        dataobject0_.id as id1_0_0_,




        dataobject0_.name as name2_0_0_ 




    from




        data dataobject0_ 




    where




        dataobject0_.id=?




Hibernate: 




    select




        dataobject0_.id as id1_0_,




        dataobject0_.name as name2_0_ 




    from




        data dataobject0_ for update




            with rs




Hibernate: 




    select




        dataobject0_.id as id1_0_,




        dataobject0_.name as name2_0_ 




    from




        data dataobject0_ 




    where




        dataobject0_.id=? for update




            with rs






and I had expected that the first query (using the @Lock&amp;amp;apos;ed findOne) should also have acquired the lock with the "for update" suffix.</description>
			<version>1.3.2</version>
			<fixedVersion>1.3.3, 1.4 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.LockIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.RoleRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="348" opendate="2013-05-27 03:15:06" fixdate="2013-06-20 05:38:40" resolution="Fixed">
		<buginformation>
			<summary>@IdClass of @MappedSuperclass is not supported</summary>
			<description>org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.IdMetadata#getType does not support MappedSuperclass annotation, i.e. if I have @IdClass at superclass with MappedSuperclass this code does not resolve it and returns null. </description>
			<version>1.3.2</version>
			<fixedVersion>1.3.3, 1.4 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="363" opendate="2013-06-27 13:13:42" fixdate="2013-06-27 14:04:32" resolution="Fixed">
		<buginformation>
			<summary>Improve SimpleJpaRepository.delete(ID id) by removing superfluous call to exists().</summary>
			<description>SimpleJpaRepository.delete(ID id) calls exists() to detect whether an entity with the given identifier exists. If that&amp;amp;apos;s the case it loads the entity and passes it on.
The exists call is superfluous as we can simply check the result of findOne() for null and thus avoid the additional SQL statement to be executed.</description>
			<version>1.3.2</version>
			<fixedVersion>1.3.3, 1.4 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="148" opendate="2012-01-04 14:31:19" fixdate="2013-06-27 14:37:47" resolution="Fixed">
		<buginformation>
			<summary>Sort with aggregate properties results in an invalid alias being generated and added to the query</summary>
			<description>I have defined an @Query annotation on a repository query which is aggregating data, but would like to offer the ability to sort on different aggregates in the data. When adding an aggregate statement as a Sort property, Spring Data JPA is automatically adding on an object alias which will cause a completely incorrect query to generate.
Example to replicate:

Use the following @Query: select sum(sessionTime),sum(inputSize),sum(outputSize) from RawData where beginDate between ? and ? group by username
Call: myRepository.customQuery(beginDate,endDate,new Sort("sum(sessionTime"));

Results in following query being generated: select sum(sessionTime),sum(inputSize),sum(outputSize) from RawData where eventDate between ? and ? group by username order by where.sum(sessionTime) asc



Note that the order by clause generates as: where .sum(sessionTime) asc
Resolving this may be possible through a simple check to see if the property contains a parenthesis that would seem to indicate it is an aggregate.  If it is detected as an aggregate, the alias addition would be skipped during the order by statement generation.
Example patch:






*** QueryUtils.java     2012-01-04 16:10:59.000000000 -0600




--- QueryUtils.java     2012-01-04 16:11:15.000000000 -0600




***************




*** 136,142 ****




                builder.append(" order by");









                for (Order order : sort) {




!                       builder.append(String.format(" %s.%s %s,", alias, order.getProperty(), toJpaDirection(order)));




                }









                builder.deleteCharAt(builder.length() - 1);




--- 136,145 ----




                builder.append(" order by");









                for (Order order : sort) {




!                       if (order.getProperty().contains("("))




!                               builder.append(String.format(" %s %s,", order.getProperty(), toJpaDirection(order)));




!                       else




!                               builder.append(String.format(" %s.%s %s,", alias, order.getProperty(), toJpaDirection(order)));




                }









                builder.deleteCharAt(builder.length() - 1);





</description>
			<version>1.0.2</version>
			<fixedVersion>1.3.3, 1.4 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="353" opendate="2013-06-10 06:18:30" fixdate="2013-07-16 08:35:42" resolution="Fixed">
		<buginformation>
			<summary>ClasspathScanningPersistenceUnitPostProcessor does not resolve mapping files properly</summary>
			<description>Using the postprocessor to scan the classpath for mapping orm.xml files using a wildcard pattern. Although the mapping files are discovered, they are added to the PersistenceUnitInfo as URLs. As a result they cannot be resolved by hibernate because it expects them in qualified package resource form:






INFO  org.hibernate.ejb.Ejb3Configuration - HHH000360: Unable to resolve mapping file [file:/Users/dev/Documents/eclipse-workspaces/workspace/project1/target/classes/com/example/model/Mapping.orm.xml]






The property on LocalContainerEntityManagerFactoryBean:






&amp;lt;property name="persistenceUnitPostProcessors"&amp;gt;




	&amp;lt;list&amp;gt;




		&amp;lt;bean class="org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessor"&amp;gt;




			&amp;lt;constructor-arg value="com.example.model" /&amp;gt;




			&amp;lt;property name="mappingFileNamePattern" value="**/*orm.xml" /&amp;gt;




		&amp;lt;/bean&amp;gt;




	&amp;lt;/list&amp;gt;




&amp;lt;/property&amp;gt;





</description>
			<version>1.3.1</version>
			<fixedVersion>1.4 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessor.java</file>
			<file type="M">org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessorUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="373" opendate="2013-07-23 09:34:25" fixdate="2013-07-24 02:35:25" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException for manually defined queries with multiple named like expressions</summary>
			<description></description>
			<version>1.3.3</version>
			<fixedVersion>1.3.4, 1.4 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.StringQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.StringQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="377" opendate="2013-07-25 03:35:33" fixdate="2013-07-25 12:41:29" resolution="Fixed">
		<buginformation>
			<summary>Count queries should be issued without ORDER BY clause</summary>
			<description>I have the following query method:






@Query("SELECT a FROM AdminModule a WHERE a.admin = :admin ORDER BY a.module")




public Page&amp;lt;AdminModule&amp;gt; findByAdmin(@Param("admin") Admin admin, Pageable page);






The test is:






@Test




public void testFindByAdmin() {




  Page&amp;lt;AdminModule&amp;gt; adminModules = adminModuleRepository.findByAdmin(admin0, new PageRequest(0, 10));




  assertEquals(1, adminModules.getContent().size());




  assertEquals(adminModule0.getModule(), adminModules.getContent().get(0).getModule());




  adminModules = adminModuleRepository.findByAdmin(admin1, new PageRequest(0, 10));




  assertEquals(10, adminModules.getContent().size());




  assertEquals(adminModule1.getModule(), adminModules.getContent().get(0).getModule());




  assertEquals(adminModule2.getModule(), adminModules.getContent().get(1).getModule());




  adminModules = adminModuleRepository.findByAdmin(admin1, new PageRequest(1, 10));




  assertEquals(manyAdminModules.get(8).getModule(), adminModules.getContent().get(0).getModule());




  assertEquals(manyAdminModules.get(9).getModule(), adminModules.getContent().get(1).getModule());




}






It is successful when run against the MySQL database. But when run against the H2 database, it gives the following error:






2013-07-25 12:10:40,560 DEBUG  [sqlonly]  org.hibernate.jdbc.AbstractBatcher.getResultSet(AbstractBatcher.java:208)




6. select count(adminmodul0_.id) as col_0_0_ from admin_module adminmodul0_ where adminmodul0_.admin_id=4362




order by adminmodul0_.module




2013-07-25 12:10:40,588 ERROR  [sqlonly]  org.hibernate.jdbc.AbstractBatcher.getResultSet(AbstractBatcher.java:208)




6. select count(adminmodul0_.id) as col_0_0_ from admin_module adminmodul0_ where adminmodul0_.admin_id=4362 order by adminmodul0_.module




org.h2.jdbc.JdbcSQLException: Column "ADMINMODUL0_.MODULE" must be in the GROUP BY list; SQL statement:




select count(adminmodul0_.id) as col_0_0_ from admin_module adminmodul0_ where adminmodul0_.admin_id=? order by adminmodul0_.module [90016-172]






I&amp;amp;apos;m using the following:






  &amp;lt;properties&amp;gt;




    &amp;lt;hibernate.version&amp;gt;3.6.10.Final&amp;lt;/hibernate.version&amp;gt;




  &amp;lt;/properties&amp;gt;









    &amp;lt;dependency&amp;gt;




      &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt;




      &amp;lt;artifactId&amp;gt;hibernate-core&amp;lt;/artifactId&amp;gt;




      &amp;lt;version&amp;gt;${hibernate.version}&amp;lt;/version&amp;gt;




    &amp;lt;/dependency&amp;gt;




    &amp;lt;dependency&amp;gt;




      &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt;




      &amp;lt;artifactId&amp;gt;hibernate-entitymanager&amp;lt;/artifactId&amp;gt;




      &amp;lt;version&amp;gt;${hibernate.version}&amp;lt;/version&amp;gt;




    &amp;lt;/dependency&amp;gt;




    &amp;lt;dependency&amp;gt;




      &amp;lt;groupId&amp;gt;org.springframework.data&amp;lt;/groupId&amp;gt;




      &amp;lt;artifactId&amp;gt;spring-data-jpa&amp;lt;/artifactId&amp;gt;




      &amp;lt;version&amp;gt;1.3.4.RELEASE&amp;lt;/version&amp;gt;




    &amp;lt;/dependency&amp;gt;




    &amp;lt;dependency&amp;gt;




      &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt;




      &amp;lt;artifactId&amp;gt;hibernate-annotations&amp;lt;/artifactId&amp;gt;




      &amp;lt;version&amp;gt;3.5.6-Final&amp;lt;/version&amp;gt;




    &amp;lt;/dependency&amp;gt;




    &amp;lt;dependency&amp;gt;




      &amp;lt;groupId&amp;gt;org.hibernate.javax.persistence&amp;lt;/groupId&amp;gt;




      &amp;lt;artifactId&amp;gt;hibernate-jpa-2.0-api&amp;lt;/artifactId&amp;gt;




      &amp;lt;version&amp;gt;1.0.1.Final&amp;lt;/version&amp;gt;




    &amp;lt;/dependency&amp;gt;




    &amp;lt;dependency&amp;gt;




      &amp;lt;groupId&amp;gt;com.h2database&amp;lt;/groupId&amp;gt;




      &amp;lt;artifactId&amp;gt;h2&amp;lt;/artifactId&amp;gt;




      &amp;lt;version&amp;gt;1.3.172&amp;lt;/version&amp;gt;




    &amp;lt;/dependency&amp;gt;





</description>
			<version>1.3.4</version>
			<fixedVersion>1.4 RC1, 1.3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="269" opendate="2012-11-06 07:12:45" fixdate="2013-07-26 09:47:05" resolution="Fixed">
		<buginformation>
			<summary>Composite Primary Key Class With Foreign Key using IdClass results in TypeMismatchException</summary>
			<description>I am trying to reproduce this jpa model : http://wiki.eclipse.org/EclipseLink/UserGuide/JPA/Basic_JPA_Development/Entities/Ids/IdClass#Example:_Composite_Primary_Key_Class_With_Foreign_Key
When I try to create a new Employee, if have the following stack trace :
org.springframework.beans.TypeMismatchException: Failed to convert property value of type &amp;amp;apos;Department&amp;amp;apos; to required type &amp;amp;apos;java.lang.Long&amp;amp;apos; for property &amp;amp;apos;department&amp;amp;apos;; nested exception is java.lang.IllegalArgumentException: Cannot convert value of type [Department] to required type [java.lang.Long] for property &amp;amp;apos;department&amp;amp;apos;: PropertyEditor [org.springframework.beans.propertyeditors.CustomNumberEditor] returned inappropriate value of type [Department]
	at org.springframework.beans.BeanWrapperImpl.convertIfNecessary(BeanWrapperImpl.java:490)
	at org.springframework.beans.BeanWrapperImpl.convertForProperty(BeanWrapperImpl.java:516)
	at org.springframework.beans.BeanWrapperImpl.setPropertyValue(BeanWrapperImpl.java:1119)
	at org.springframework.beans.BeanWrapperImpl.setPropertyValue(BeanWrapperImpl.java:904)
	at org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation$DirectFieldAccessFallbackBeanWrapper.setPropertyValue(JpaMetamodelEntityInformation.java:205)
	at org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.getId(JpaMetamodelEntityInformation.java:94)
	at org.springframework.data.repository.core.support.AbstractEntityInformation.isNew(AbstractEntityInformation.java:53)
	at org.springframework.data.jpa.repository.support.SimpleJpaRepository.save(SimpleJpaRepository.java:340)
...
The problem comes from JpaMetamodelEntityInformation.getId : this method ignores the fact that the id class contains the id of the department, not a department reference.
NB : in this issue https://jira.springsource.org/browse/DATAJPA-50, the same situation was described in a comment : https://jira.springsource.org/browse/DATAJPA-50?focusedCommentId=66633&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-66633
Thanks for reading</description>
			<version>1.1.2</version>
			<fixedVersion>1.4 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="346" opendate="2013-05-16 23:28:42" fixdate="2013-07-29 04:24:48" resolution="Fixed">
		<buginformation>
			<summary>Sort by property of an associated object doesn&amp;apos;t work. Join type should be LEFT OUTER JOIN for sorting on associated objects.</summary>
			<description>The issue I have is that I try to order by a property in an associated object (composite pattern). Thus I have a class PreApprovalRequest and a property in that class assignedTo of type PaceUser. I am trying to order requests by the name of the assignedTo user.
Concrete code below. I have a call that loads all PreApprovalRequest objects (for simplicity I&amp;amp;apos;ll leave out pagination). E.g.






 select * from PreApprovalRequest






That translates to:






select * from ( select preapprova0_.ID as ID0_, preapprova0_.CREATED as CREATED0_ from PRE_APPROVAL_REQUEST preapprova0_ order by preapprova0_.CREATED desc ) where rownum &amp;lt;= ?






Now, when I apply the ordering by first name and then last name of the assignedTo user, the query translates into:






select * from ( select preapprova0_.ID as ID0_, preapprova0_.CREATED as CREATED0_ from PRE_APPROVAL_REQUEST preapprova0_, PACE_USER paceuser1_ where preapprova0_.ASSIGNED_TO=paceuser1_.ID order by lower(paceuser1_.FIRST_NAME) asc, lower(paceuser1_.LAST_NAME) asc ) where rownum &amp;lt;= ?






Note that because the join used when applying sorting is the default one (not using the JOIN keyword) - which is basically INNER JOIN - the items where there is no user assigned to the request will be filtered out, which is not desired of course.
Thus, I think the solution is to join using LEFT OUTER JOIN instead of default join and that should fix it.
I&amp;amp;apos;m happy to clone the repository and add the fix if needed.
Thanks,
Iulian.</description>
			<version>1.4 M1</version>
			<fixedVersion>1.4 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.EclipseLinkNamespaceUserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">277</link>
		</links>
	</bug>
	<bug id="388" opendate="2013-08-07 17:16:07" fixdate="2013-08-12 04:21:09" resolution="Fixed">
		<buginformation>
			<summary>Spring Data ignores alternative EntityManager Producer in CDI environment</summary>
			<description>I have made a alternative producer(@Alternative) to create a EntityManager for test purposes.
The injection of this EntityManager works like expected, but Spring Data still get the default one.</description>
			<version>1.3.4</version>
			<fixedVersion>1.4 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.data.jpa.repository.cdi.CdiExtensionintegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.cdi.JpaRepositoryExtension.java</file>
		</fixedFiles>
	</bug>
	<bug id="375" opendate="2013-07-24 04:02:20" fixdate="2013-08-13 23:36:14" resolution="Fixed">
		<buginformation>
			<summary>Not specifying the ASC clause results in a double ORDER BY clause</summary>
			<description>I have a query with an ORDER BY clause.






@Query("SELECT a FROM Admin a " + 




       "WHERE LOWER(a.firstname) LIKE LOWER(CONCAT(&amp;amp;apos;%&amp;amp;apos;, :searchTerm, &amp;amp;apos;%&amp;amp;apos;))" + 




       "   OR LOWER(a.lastname) LIKE LOWER(CONCAT(&amp;amp;apos;%&amp;amp;apos;, :searchTerm, &amp;amp;apos;%&amp;amp;apos;))" +




       "   OR LOWER(a.email) LIKE LOWER(CONCAT(&amp;amp;apos;%&amp;amp;apos;, :searchTerm, &amp;amp;apos;%&amp;amp;apos;))" +




       "   OR LOWER(a.login) LIKE LOWER(CONCAT(&amp;amp;apos;%&amp;amp;apos;, :searchTerm, &amp;amp;apos;%&amp;amp;apos;))" +




       "ORDER BY a.lastname, a.firstname")")




public Page&amp;lt;Admin&amp;gt; search(@Param("searchTerm") String searchTerm, Pageable page);






The ORDER BY clause does not specify any ASC nor DESC clause assuming the default ASC clause would be used.
But instead, the generated query looks like:






SELECT a FROM com.thalasoft.learnintouch.core.jpa.domain.Admin a 




WHERE LOWER(a.firstname) LIKE LOWER(CONCAT(&amp;amp;apos;%&amp;amp;apos;, :searchTerm, &amp;amp;apos;%&amp;amp;apos;)) 




   OR LOWER(a.lastname) LIKE LOWER(CONCAT(&amp;amp;apos;%&amp;amp;apos;, :searchTerm, &amp;amp;apos;%&amp;amp;apos;)) 




   OR LOWER(a.email) LIKE LOWER(CONCAT(&amp;amp;apos;%&amp;amp;apos;, :searchTerm, &amp;amp;apos;%&amp;amp;apos;))




   OR LOWER(a.login) LIKE LOWER(CONCAT(&amp;amp;apos;%&amp;amp;apos;, :searchTerm, &amp;amp;apos;%&amp;amp;apos;))




ORDER BY a.lastname, a.firstname order by a.lastname asc, a.firstname asc






It shows two ORDER BY clauses. If I explicitly add the ASC clause then the query is fine.</description>
			<version>1.3.4</version>
			<fixedVersion>1.4 GA, 1.3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="403" opendate="2013-09-20 15:52:23" fixdate="2013-09-25 00:57:16" resolution="Fixed">
		<buginformation>
			<summary>Unnecessary OUTER JOIN are generated when sorting on ElementCollection</summary>
			<description>Extending JpaSpecificationExecutor and calling findAll with a Specification and a Sort cause unnecessary outer join to be add to the query generating wrong results with duplicate data.
This happens if the Specification queries on a field of an object mapped by and @ElementCollection and sort by another field of the same object.
Not sure if the problem in SimpleJpaRepository or in QueryUtils, but somewhere new outer join is created while an existing one could be reuse.
The following query is generated






SELECT




    entitya0_.id AS id1_0_




FROM




    entity_a entitya0_




LEFT OUTER JOIN




    entity_b entitiesb1_




ON




    entitya0_.id=entitiesb1_.entity_a_id




LEFT OUTER JOIN




    entity_b entitiesb2_




ON




    entitya0_.id=entitiesb2_.entity_a_id




WHERE




    entitiesb1_.field=?




ORDER BY




    entitiesb2_.rank DESC






The expected query looks like






SELECT




    entitya0_.id AS id1_0_




FROM




    entity_a entitya0_




LEFT OUTER JOIN




    entity_b entitiesb1_




ON




    entitya0_.id=entitiesb1_.entity_a_id




WHERE




    entitiesb1_.field=?




ORDER BY




    entitiesb1_.rank DESC





</description>
			<version>1.2.1</version>
			<fixedVersion>1.3.5, 1.4.2 (Babbage SR1), 1.5 M1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="401" opendate="2013-09-10 07:58:35" fixdate="2013-09-25 03:21:58" resolution="Fixed">
		<buginformation>
			<summary>Unnecessary OUTER JOIN are generated for querying one single table</summary>
			<description>Since Spring Data JPA 1.2.1, unnecessary outer joins are generated when a single table is queried, which can take 10000 times longer to execute when the table contains millions of records. With log4jdbc we see the generated query and its execution time. Here are "simplified" statements of the SQL statements (our table contain many more columns).
In Spring Data JPA 1.2.0 and lower, the following statement was generated:






select order0_.ID as order1_14_ from ORDER order0_ where order0__.CUSTOMER_ID=123456 




Execution time : 2 ms






In Spring Data JPA 1.2.1 and higher, the following statement is generated:






select order0_.ID as order1_14_ from ORDER order0_ left outer join CUSTOMER customer1_ on order0_.CUSTOMER_ID=customer1_.ID where customer1_.ID=123456 




Execution time : 18842 ms






This problem was introduced by DATAJPA-277 which is included in 1.2.1. In attachment, there is a patch against 1.2.1 which makes this behavior configurable. When the JPA field is annotated with @ManyToOne(optional=false) or @OneToOne(optional=false) the outer joins are replaced with regular inner joins. Please feel free to enhance the patch if you find it appropriate.</description>
			<version>1.2.1</version>
			<fixedVersion>1.4.2 (Babbage SR1), 1.5 M1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="396" opendate="2013-09-03 01:21:49" fixdate="2013-09-30 10:02:06" resolution="Fixed">
		<buginformation>
			<summary>CriteriaQuery caching causes problems with Hibernate&amp;apos;s alias name generation in multithreaded environments</summary>
			<description>In my project, every now and again some Spring Data Repository methods raise a ClassCastException when called. If this happens once, every subsequent call on the same method results in the same exception. The method is then broken until the JVM or the Spring context is restarted.
After investigating further I found out that this is caused by an incorrectly generated query string. In my case this JPA query string is something like 
select generatedAlias0 from Order as generatedAlias0 left join generatedAlias0.product as generatedAlias0 where generatedAlias0=:param0
The generated alias is the same for the root object as well as the join! After taking a closer look at Hibernate&amp;amp;apos;s sources, I found out that Hibernate&amp;amp;apos;s javax.persistence.criteria.CriteriaQuery implementation (CriteriaQueryImpl) is not thread safe. If there are no aliases set on the CriteriaQuery object (=default), alias names are generated on the first call that uses the object. Now, if multiple threads use the CriteriaQuery object at the same time, this can cause incorrectly generated alias names. Since Spring Data JPA repositories use a shared CriteriaQuery object for each query method, this causes problems in multithreaded environments.
JPA does not explicitly require implementations to provide thread safe CriteriaQuery objects. I reproduced this with Hibernate 4.2.5 and 4.1.9. Maybe with other JPA implementations alias generation is implemented differently and thread safe. Either way, unfortunately, Spring Data can not rely on thread safety in this regard. This problem might have been introduced in DATAJPA-71
Investigation notes:
Query generation in Hibernate can found in org.hibernate.ejb.criteria.CriteriaQueryCompiler (line 223). The renderingContext passed is unique for the thread/call (not unique for the CriteriqQuery object)</description>
			<version>1.3.4</version>
			<fixedVersion>1.4.2 (Babbage SR1), 1.5 M1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.PartTreeJpaQuery.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">397</link>
		</links>
	</bug>
	<bug id="407" opendate="2013-10-01 05:33:47" fixdate="2013-10-02 00:55:13" resolution="Fixed">
		<buginformation>
			<summary>ClasspathScanningPersistenceUnitPostProcessor throws IndexOutOfBoundsException on Windows</summary>
			<description>ClasspathScanningPersistenceUnitPostProcessor throws IndexOutOfBoundsException on windows, in scanForMappingFileLocations at line 140:
resourcePath.substring(resourcePath.indexOf(basePackagePathComponent))
That&amp;amp;apos;s because resourcePath always has forward slash path (&amp;amp;apos;/&amp;amp;apos;) separator beeing an URI, while basePackagePathComponent has system dependent separator (on windows it&amp;amp;apos;s the backslash separator). So on windows the indexOf above will return -1 and hence the IndexOutOfBoundsException in substring.
The fix which worked for me:
On line 124 and 125 replace the existing code with the following:
        String basePackagePathComponent = basePackage.replace(&amp;amp;apos;.&amp;amp;apos;, &amp;amp;apos;/&amp;amp;apos;);
        String path = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + basePackagePathComponent + "/" + mappingFileNamePattern;</description>
			<version>1.4 RC1</version>
			<fixedVersion>1.4.2 (Babbage SR1), 1.5 M1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessor.java</file>
			<file type="M">org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessorUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="415" opendate="2013-10-21 02:37:01" fixdate="2013-10-25 10:39:29" resolution="Fixed">
		<buginformation>
			<summary>org.springframework.data.jpa.repository.Query is not supported varargs</summary>
			<description>@org.springframework.data.jpa.repository.Modifying
	@org.springframework.data.jpa.repository.Query("UPDATE #
{#entityName}
 user SET user.status = :userStatus WHERE user.id IN (:ids)")
	void updateUserStatus(@org.springframework.data.repository.query.Param("userStatus") UserStatus userStatus,@org.springframework.data.repository.query.Param("ids") Integer...ids);</description>
			<version>1.4.1</version>
			<fixedVersion>1.5 M1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.EclipseLinkNamespaceUserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.OpenJpaNamespaceUserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.ParameterBinder.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.User.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.ParameterBinderUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">429</link>
			<link type="Relate" description="relates to">461</link>
		</links>
	</bug>
	<bug id="405" opendate="2013-09-27 00:51:55" fixdate="2013-10-27 09:46:09" resolution="Fixed">
		<buginformation>
			<summary>Custom repository method doesn&amp;apos;t parse OrderBy clause properly</summary>
			<description>Currently, there are some custom repository method names with OrderBy clauses that are parsed properly.  Setting aside the database design issues, if you had a database that looked like:






CREATE TABLE project(




  key VARCHAR(8) PRIMARY KEY,




  name VARCHAR(64) NOT NULL




);






That table is mapped to an entity that looks like:






@Entity




public final class Project {









    @Id




    private volatile String key;









    private volatile String name;









    Project() {




    }









    public String getKey() {




        return this.key;




    }









    public String getName() {




        return this.name;




    }









}






The repository used to access this entity looks like:






public interface ProjectRepository extends JpaRepository&amp;lt;Project, String&amp;gt; {









    List&amp;lt;Project&amp;gt; findAllOrderByKeyAsc();









}






When the application starts up, you&amp;amp;apos;ll end up with an exception that says:






Caused by: org.springframework.data.mapping.PropertyReferenceException: No property asc found for type java.lang.String




	at org.springframework.data.mapping.PropertyPath.&amp;lt;init&amp;gt;(PropertyPath.java:75)




	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:327)




	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:307)




	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:330)




	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:353)




	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:307)




	at org.springframework.data.mapping.PropertyPath.from(PropertyPath.java:271)




	at org.springframework.data.mapping.PropertyPath.from(PropertyPath.java:245)




	at org.springframework.data.repository.query.parser.Part.&amp;lt;init&amp;gt;(Part.java:72)




	at org.springframework.data.repository.query.parser.PartTree$OrPart.&amp;lt;init&amp;gt;(PartTree.java:188)




	at org.springframework.data.repository.query.parser.PartTree$Predicate.buildTree(PartTree.java:277)




	at org.springframework.data.repository.query.parser.PartTree$Predicate.&amp;lt;init&amp;gt;(PartTree.java:257)




	at org.springframework.data.repository.query.parser.PartTree.&amp;lt;init&amp;gt;(PartTree.java:71)




	at org.springframework.data.jpa.repository.query.PartTreeJpaQuery.&amp;lt;init&amp;gt;(PartTreeJpaQuery.java:57)




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:90)




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateIfNotFoundQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:162)




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$AbstractQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:68)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.&amp;lt;init&amp;gt;(RepositoryFactorySupport.java:290)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:158)




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:162)




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:44)




	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:144)






This is obviously an error, although I don&amp;amp;apos;t have enough of a grasp of the parsing logic to understand where it might be.  A note is that if I use a findAll(new Sort("key")), it works fine.  So I&amp;amp;apos;ve got a work around, but I&amp;amp;apos;d like to encapsulate the ordering in a specific method on the repository.
I&amp;amp;apos;m free to talk through the issue and try snapshots if needed.</description>
			<version>1.4.1</version>
			<fixedVersion>1.5 M1 (Codd), 1.4.3 (Babbage SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.JpaCountQueryCreator.java</file>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryCreator.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">387</link>
		</links>
	</bug>
	<bug id="424" opendate="2013-11-06 15:11:02" fixdate="2013-11-07 05:10:00" resolution="Fixed">
		<buginformation>
			<summary>#entityName SpEL does not match alias regex when detecting alias</summary>
			<description>Using of the #entityName SpEL within the @Query annotation causes StringQuery.alias to become null because the query string cannot be matched against ALIAS_MATCH in QueryUtils.detectAlias().
This means that using Pageable parameters with repository methods do not evaluate the alias correctly when constructing the sorted query string, i.e. given the @Query on the repository method






@Query("SELECT o FROM #{#entityName} o WHERE o.orderState = :orderState")




public Page&amp;lt;Order&amp;gt; findOrders(@Param("orderState") OrderState orderState, Pageable pageable);






called from 






orderRepository.findOrders(state, new PageRequest(0, 10, Direction.DESC, "orderDate"))






then end query is parsed/resolved to






SELECT o FROM Order o WHERE o.orderState = :orderState  order by null.orderDate desc






</description>
			<version>1.4.2 (Babbage SR1)</version>
			<fixedVersion>1.5 M1 (Codd), 1.4.3 (Babbage SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.sample.MappedTypeRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.MappedTypeRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.ExpressionBasedStringQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.ExpressionBasedStringQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="427" opendate="2013-11-14 03:55:00" fixdate="2013-12-04 05:04:29" resolution="Fixed">
		<buginformation>
			<summary>Sort by property of an associated object generates inner join instead of left join with QueryDsl and Hibernate</summary>
			<description>I have a custom repository implementation with QueryDsl predicate. When I sort by property of an associated object query that gets generated uses inner join instead left join statement.
I also have a custom repository implementation with JpaSpecification executor. There everything works well.
I have attached a test case.</description>
			<version>1.4.2 (Babbage SR1)</version>
			<fixedVersion>1.4.3 (Babbage SR2), 1.5 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.User.java</file>
			<file type="M">org.springframework.data.jpa.repository.EclipseLinkNamespaceUserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.Querydsl.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.QueryDslJpaRepositoryTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">491</link>
		</links>
	</bug>
	<bug id="430" opendate="2013-11-21 00:47:40" fixdate="2013-12-09 05:51:38" resolution="Fixed">
		<buginformation>
			<summary>Fix incompatibilities with latest Hibernate 4.3 (CR2 currently)</summary>
			<description>Hibernate&amp;amp;apos;s behaviour changed with version 4.3.0.Beta5, I think.
Instead of throwing an IllegalStateException, null is returned.
Something like the following might fix it.
In org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.IdMetadata






		public Class&amp;lt;?&amp;gt; getType() {









			if (idType != null) {




				return idType;




			}









			Class&amp;lt;?&amp;gt; idType;









			try {




                final Type&amp;lt;?&amp;gt; idType1 = type.getIdType();




                if (idType1 != null) {




                    idType = idType1.getJavaType();




                } else {




                    IdClass annotation = AnnotationUtils.findAnnotation(type.getJavaType(), IdClass.class);




                    idType = annotation == null ? null : annotation.value();




                }




			} catch (IllegalStateException e) {




				// see https://hibernate.onjira.com/browse/HHH-6951




				IdClass annotation = AnnotationUtils.findAnnotation(type.getJavaType(), IdClass.class);




				idType = annotation == null ? null : annotation.value();




			}









			this.idType = idType;




			return idType;




		}





</description>
			<version>1.4.2 (Babbage SR1)</version>
			<fixedVersion>1.4.3 (Babbage SR2), 1.5 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.PartTreeJpaQueryIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="420" opendate="2013-10-28 21:36:57" fixdate="2013-12-10 14:26:23" resolution="Fixed">
		<buginformation>
			<summary>COUNT syntax error when use scalar select (select a.b ,a.c from ...) with paging</summary>
			<description>When use select with scalar &amp;amp; paging in Spring data JPA as below
@Query("select s.fname,s.lname from Student s") 
Page&amp;lt;Object&amp;gt; findWithScalarSelect(Pageable pageable);
Eclipselink generate malform jpql as below
select count(s.fname,s.lname) from Student s
I made test on github =&amp;gt; https://github.com/pramoth/springdata-pagingbug</description>
			<version>1.4.2 (Babbage SR1)</version>
			<fixedVersion>1.4.3 (Babbage SR2), 1.5 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="444" opendate="2014-01-08 00:16:36" fixdate="2014-01-13 06:23:45" resolution="Fixed">
		<buginformation>
			<summary>PersistenceProvider enum should also match org.hibernate.jpa.HibernateEntityManager</summary>
			<description>With Hibernate 4.3 the package for HibernateEntityManager changed to org.hibernate.jpa.HibernateEntityManager.
The lack of support for the new location leads to a QueryCreationException because of an erroneous fallback to GENERIC_JPA which sets canExtractQuery() to false.
PersistenceProvider should also match the new location to HIBERNATE or a new enum value which returns true for canExtractQuery().</description>
			<version>1.4.3 (Babbage SR2)</version>
			<fixedVersion>1.5 RC1 (Codd), 1.4.4 (Babbage SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.PersistenceProvider.java</file>
		</fixedFiles>
	</bug>
	<bug id="442" opendate="2014-01-06 04:45:37" fixdate="2014-01-13 06:31:20" resolution="Fixed">
		<buginformation>
			<summary>Repository initialization causes transaction rollback in CDI environments</summary>
			<description>The CreateIfNotFoundQueryLookupStrategy cannot be used with Hibernate 4.3 in a JTA environment. Spring Data JPA calls em.createNamedQuery(queryName) in the NamedQuery constructor to check if the named query exists. In previous Hibernate versions this caused an IllegalArgumentException to be thrown by the entity manager. But now Hibernate roles back the transaction and a NullPointerException is thrown that is never caught by Spring Data JPA.</description>
			<version>1.4.3 (Babbage SR2)</version>
			<fixedVersion>1.5 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.cdi.PersonRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.cdi.CdiExtensionIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.cdi.JpaRepositoryExtension.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">416</link>
			<link type="Relate" description="relates to">724</link>
		</links>
	</bug>
	<bug id="429" opendate="2013-11-20 07:16:05" fixdate="2014-02-06 04:11:58" resolution="Duplicate">
		<buginformation>
			<summary>Cannot pass vararg when using @Query</summary>
			<description>I have came across an issue where if I use @Query with hql, I cannot have a vararg as a parameter. I CAN have a vararg if I just create a method name like &amp;amp;apos;findByPropertyIn(String... str)&amp;amp;apos; 
Now, if I try @Query("from Entity e where e.property in ?1") I get this exception:
org.springframework.dao.InvalidDataAccessApiUsageException: Encountered array-valued parameter binding, but was expecting [some class].  </description>
			<version>1.4.1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.EclipseLinkNamespaceUserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.OpenJpaNamespaceUserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.ParameterBinder.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.User.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.ParameterBinderUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">415</link>
		</links>
	</bug>
	<bug id="454" opendate="2014-01-28 03:15:58" fixdate="2014-02-06 10:28:27" resolution="Fixed">
		<buginformation>
			<summary>Query on byte array fails</summary>
			<description>I have a blob which is mapped as a byte array in my entity. When creating a method to search on it in Spring JPA, I got an exception at server launch.
Entity:






@Entity




@Table(name = "CERTIFICATE")




public class Certificate {









	@Id




	@Column(name = "ID")




	@GeneratedValue(strategy = GenerationType.AUTO)




	private Integer id;









	@Column(name = "CERTIFICATE")




	@Lob




	private byte[] binary;




	// Getters and setters present but not shown




}






DAO:






public interface CertificateDAO extends JpaRepository&amp;lt;Certificate, Integer&amp;gt; {









	public Certificate findByBinary(byte[] binary);




}






Exception in attached file. It seems that the array is always handled as a relation and thus try to generate a join. At line 453 of QueryUtils property.isCollection() is true.</description>
			<version>1.4.3 (Babbage SR2)</version>
			<fixedVersion>1.4.4 (Babbage SR3), 1.5 GA (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.User.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">476</link>
		</links>
	</bug>
	<bug id="473" opendate="2014-02-21 19:57:25" fixdate="2014-02-23 05:14:15" resolution="Fixed">
		<buginformation>
			<summary>When used  "LIKE expression" and "other expression" at the same time, occurred the QuerySyntaxException of Hibernate.</summary>
			<description>When "Other Expression" after the "LIKE Expression" was specified, this error occurred.
note) 1.4.3 was no problem.
Specified query in @Query :






    @Query("SELECT a FROM Article a"




            + " WHERE a.overview LIKE %:escapedWord% ESCAPE &amp;amp;apos;~&amp;amp;apos;"




            + " OR a.content LIKE %:escapedWord% ESCAPE &amp;amp;apos;~&amp;amp;apos;"




            + " OR a.title = :word ORDER BY a.articleId DESC")




    Page&amp;lt;Article&amp;gt; findPageBy(@Param("escapedWord") String escapedWord,




            @Param("word") String word, Pageable pageable);






StackTrace : 






	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:770) ~[spring-beans-3.2.4.RELEASE.jar:3.2.4.RELEASE]




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:486) ~[spring-beans-3.2.4.RELEASE.jar:3.2.4.RELEASE]




	... 24 common frames omitted




Caused by: java.lang.IllegalArgumentException: Validation failed for query for method public abstract org.springframework.data.domain.Page xxxxxx.yyyyyy.zzzzzz.domain.repository.ArticleRepository.findPageBy(java.lang.String,java.lang.String,org.springframework.data.domain.Pageable)!




	at org.springframework.data.jpa.repository.query.SimpleJpaQuery.validateQuery(SimpleJpaQuery.java:97) ~[spring-data-jpa-1.4.4.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.SimpleJpaQuery.&amp;lt;init&amp;gt;(SimpleJpaQuery.java:66) ~[spring-data-jpa-1.4.4.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.SimpleJpaQuery.fromQueryAnnotation(SimpleJpaQuery.java:169) ~[spring-data-jpa-1.4.4.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$DeclaredQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:114) ~[spring-data-jpa-1.4.4.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateIfNotFoundQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:160) ~[spring-data-jpa-1.4.4.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$AbstractQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:68) ~[spring-data-jpa-1.4.4.RELEASE.jar:na]




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.&amp;lt;init&amp;gt;(RepositoryFactorySupport.java:304) ~[spring-data-commons-1.6.4.RELEASE.jar:na]




	at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:161) ~[spring-data-commons-1.6.4.RELEASE.jar:na]




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:162) ~[spring-data-commons-1.6.4.RELEASE.jar:na]




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:45) ~[spring-data-commons-1.6.4.RELEASE.jar:na]




	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:142) ~[spring-beans-3.2.4.RELEASE.jar:3.2.4.RELEASE]




	... 32 common frames omitted




Caused by: java.lang.IllegalArgumentException: org.hibernate.hql.internal.ast.QuerySyntaxException: unexpected token: % near line 1, column 81 [SELECT a FROM xxxxxx.yyyyyy.zzzzzz.domain.model.Article a WHERE a.overview LIKE %:escapedWord% ESCAPE &amp;amp;apos;~&amp;amp;apos; OR a.content LIKE %:escapedWord% ESCAPE &amp;amp;apos;~&amp;amp;apos; OR a.title = :word ORDER BY a.articleId DESC]




	at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1374) ~[hibernate-entitymanager-4.2.3.Final.jar:4.2.3.Final]




	at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1310) ~[hibernate-entitymanager-4.2.3.Final.jar:4.2.3.Final]




	at org.hibernate.ejb.AbstractEntityManagerImpl.createQuery(AbstractEntityManagerImpl.java:294) ~[hibernate-entitymanager-4.2.3.Final.jar:4.2.3.Final]




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_51]




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_51]




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_51]




	at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_51]




	at org.springframework.orm.jpa.ExtendedEntityManagerCreator$ExtendedEntityManagerInvocationHandler.invoke(ExtendedEntityManagerCreator.java:366) ~[spring-orm-3.2.4.RELEASE.jar:3.2.4.RELEASE]




	at com.sun.proxy.$Proxy32.createQuery(Unknown Source) ~[na:na]




	at org.springframework.data.jpa.repository.query.SimpleJpaQuery.validateQuery(SimpleJpaQuery.java:91) ~[spring-data-jpa-1.4.4.RELEASE.jar:na]




	... 42 common frames omitted




Caused by: org.hibernate.hql.internal.ast.QuerySyntaxException: unexpected token: % near line 1, column 81 [SELECT a FROM xxxxxx.yyyyyy.zzzzzz.domain.model.Article a WHERE a.overview LIKE %:escapedWord% ESCAPE &amp;amp;apos;~&amp;amp;apos; OR a.content LIKE %:escapedWord% ESCAPE &amp;amp;apos;~&amp;amp;apos; OR a.title = :word ORDER BY a.articleId DESC]




	at org.hibernate.hql.internal.ast.QuerySyntaxException.convert(QuerySyntaxException.java:54) ~[hibernate-core-4.2.3.Final.jar:4.2.3.Final]




	at org.hibernate.hql.internal.ast.QuerySyntaxException.convert(QuerySyntaxException.java:47) ~[hibernate-core-4.2.3.Final.jar:4.2.3.Final]





</description>
			<version>1.4.4 (Babbage SR3)</version>
			<fixedVersion>1.5 GA (Codd), 1.4.5 (Babbage SR4)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.StringQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.StringQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="483" opendate="2014-02-26 19:23:01" fixdate="2014-02-27 01:14:15" resolution="Fixed">
		<buginformation>
			<summary>Parameter binding detection for in clause broken for parameters surrounded with parentheses</summary>
			<description>The following code was working happily in 1.5.0.M1 and 1.5.0.RC1 however when I upgraded to 1.5.0.RELEASE it produced an exception.






    @Query("select count(we) from MyEntity we where we.status in (:statuses)")




    Long countByStatus(@Param("statuses") Status... statuses);






And the exception produced ...






Caused by: java.lang.IllegalArgumentException: Encountered array-valued parameter binding, but was expecting [mymaskedpackage.Status (n/a)]




        at org.hibernate.jpa.spi.BaseQueryImpl.validateArrayValuedParameterBinding(BaseQueryImpl.java:925)




        at org.hibernate.jpa.spi.BaseQueryImpl.validateBinding(BaseQueryImpl.java:881)




        at org.hibernate.jpa.internal.QueryImpl.access$000(QueryImpl.java:80)




        at org.hibernate.jpa.internal.QueryImpl$ParameterRegistrationImpl.bindValue(QueryImpl.java:248)




        at org.hibernate.jpa.spi.BaseQueryImpl.setParameter(BaseQueryImpl.java:631)




        at org.hibernate.jpa.spi.AbstractQueryImpl.setParameter(AbstractQueryImpl.java:179)




        at org.hibernate.jpa.spi.AbstractQueryImpl.setParameter(AbstractQueryImpl.java:49)




        at org.springframework.data.jpa.repository.query.ParameterBinder.bind(ParameterBinder.java:131)




        at org.springframework.data.jpa.repository.query.StringQueryParameterBinder.bind(StringQueryParameterBinder.java:61)




        at org.springframework.data.jpa.repository.query.ParameterBinder.bind(ParameterBinder.java:110)




        at org.springframework.data.jpa.repository.query.ParameterBinder.bindAndPrepare(ParameterBinder.java:153)




        at org.springframework.data.jpa.repository.query.ParameterBinder.bindAndPrepare(ParameterBinder.java:144)




        at org.springframework.data.jpa.repository.query.AbstractStringBasedJpaQuery.doCreateQuery(AbstractStringBasedJpaQuery.java:68)




        at org.springframework.data.jpa.repository.query.AbstractJpaQuery.createQuery(AbstractJpaQuery.java:145)




        at org.springframework.data.jpa.repository.query.JpaQueryExecution$SingleEntityExecution.doExecute(JpaQueryExecution.java:142)




        at org.springframework.data.jpa.repository.query.JpaQueryExecution.execute(JpaQueryExecution.java:61)




        at org.springframework.data.jpa.repository.query.AbstractJpaQuery.doExecute(AbstractJpaQuery.java:96)




        at org.springframework.data.jpa.repository.query.AbstractJpaQuery.execute(AbstractJpaQuery.java:86)




        at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:337)




        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




        at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:98)




        at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:262)




        at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:95)




        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




        at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:136)






The code making the call was simply doing:






myRepository.countByStatus(Status.OK)






Perhaps this has been introduced as part of this update: DATAJPA-461 ?</description>
			<version>1.5 GA (Codd)</version>
			<fixedVersion>1.5.1 (Codd SR1), 1.6 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.StringQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.StringQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="472" opendate="2014-02-20 15:08:07" fixdate="2014-03-06 23:09:44" resolution="Fixed">
		<buginformation>
			<summary>Can&amp;apos;t use pagination (Pageable) with @IdClass entities (spring-data-jpa 1.4.3 &amp;  Hibernate 4.1.9)</summary>
			<description>If you try to use findAll(Pageable)on a PagingAndSortingRepository you get an "java.lang.IllegalStateException: No supertype found" if the entity key is defined using @IdClass and you&amp;amp;apos;re using Hibernate 4.1.9
As soon as you replace @IdClass with @EmbeddedId everything works fine. 
This error is similar to https://jira.springsource.org/browse/DATAJPA-50 but it&amp;amp;apos;s still happening for PagingAndSortingRepository. I would expect to work fine when declaring the entity&amp;amp;apos;s key with @IdClass 
The exception you get when using @IdClass and trying to call repo.findAll(Pageable request):






*org.springframework.dao.InvalidDataAccessApiUsageException: No supertype found; nested exception is java.lang.IllegalStateException: No supertype found*




	at org.springframework.orm.jpa.EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(EntityManagerFactoryUtils.java:293)




	at org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:108)




	at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.translateExceptionIfPossible(AbstractEntityManagerFactoryBean.java:403)




	at org.springframework.dao.support.ChainedPersistenceExceptionTranslator.translateExceptionIfPossible(ChainedPersistenceExceptionTranslator.java:58)




	at org.springframework.dao.support.DataAccessUtils.translateIfNecessary(DataAccessUtils.java:213)




	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:163)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.data.jpa.repository.support.LockModeRepositoryPostProcessor$LockModePopulatingMethodIntercceptor.invoke(LockModeRepositoryPostProcessor.java:92)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:91)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)




	at $Proxy38.findAll(Unknown Source)




	at au.com.flado.tpp.data.dao.PageableTest.test(PageableTest.java:49)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)




	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:74)




	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:83)




	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:231)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:88)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)




	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)




	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:71)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:174)




	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)




	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)




*Caused by: java.lang.IllegalStateException: No supertype found*




	at org.hibernate.ejb.metamodel.AbstractIdentifiableType.requireSupertype(AbstractIdentifiableType.java:85)




	at org.hibernate.ejb.metamodel.AbstractIdentifiableType.getIdType(AbstractIdentifiableType.java:173)




	at org.hibernate.ejb.criteria.expression.function.AggregationFunction$COUNT.renderArguments(AggregationFunction.java:112)




	at org.hibernate.ejb.criteria.expression.function.ParameterizedFunctionExpression.render(ParameterizedFunctionExpression.java:96)




	at org.hibernate.ejb.criteria.expression.function.BasicFunctionExpression.renderProjection(BasicFunctionExpression.java:73)




	at org.hibernate.ejb.criteria.QueryStructure.render(QueryStructure.java:252)




	at org.hibernate.ejb.criteria.CriteriaQueryImpl.render(CriteriaQueryImpl.java:340)




	at org.hibernate.ejb.criteria.CriteriaQueryCompiler.compile(CriteriaQueryCompiler.java:217)




	at org.hibernate.ejb.AbstractEntityManagerImpl.createQuery(AbstractEntityManagerImpl.java:587)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:241)




	at $Proxy33.createQuery(Unknown Source)




	at org.springframework.data.jpa.repository.support.SimpleJpaRepository.getCountQuery(SimpleJpaRepository.java:482)




	at org.springframework.data.jpa.repository.support.SimpleJpaRepository.readPage(SimpleJpaRepository.java:422)




	at org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(SimpleJpaRepository.java:321)




	at org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(SimpleJpaRepository.java:290)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:358)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:343)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:96)




	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:260)




	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:94)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:155)




	... 36 more










</description>
			<version>1.4.3 (Babbage SR2)</version>
			<fixedVersion>1.5.1 (Codd SR1), 1.6 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.data.jpa.repository.DataJpa269RepositoryWithCompositeKeyTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="492" opendate="2014-03-07 06:09:11" fixdate="2014-03-07 09:48:58" resolution="Fixed">
		<buginformation>
			<summary>findAll(Iterable&lt;ID&gt;)  : Invalid comparation Exception  thrown</summary>
			<description>I am developping a web application which uses Spring and JPA. My aim is to get the content of a table called Product with a filter on the table identifier (use of the SQL syntax &amp;amp;apos;IN&amp;amp;apos;). For that, I use the method findAll(Iterable&amp;lt;ID&amp;gt;) of an interface which extends of CrudRepository.
On the call of the method findAll, I catch an exception which tell me that Spring can&amp;amp;apos;t compare an Integer object to an Iterable object. But, I don&amp;amp;apos;t understand why Spring try to compare an Integer object to an Iterable object.
Please find in attachment a simple project which reproduces the exception
The URL of the exception: http://localhost:8080/myshop/product/list</description>
			<version>1.5 GA (Codd)</version>
			<fixedVersion>1.4.5 (Babbage SR4), 1.5.1 (Codd SR1), 1.6 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepository.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">433</link>
		</links>
	</bug>
	<bug id="494" opendate="2014-03-09 07:05:05" fixdate="2014-03-11 04:56:41" resolution="Fixed">
		<buginformation>
			<summary>Missing Imports in Spring Data JPA for Auditing</summary>
			<description>As mentioned in DATAJPA-482 there is a missing import package statement in spring data in conjunction with auditing. 
I have created an integration test which could be found on github. There is also a fragment-bundle, which adds the missing imports. 
There aren&amp;amp;apos;t spring 3.2.8 Jars available yet, so i couldn&amp;amp;apos;t test it against data jpa 1.5.0.
If the package "org.springframework.beans.factory.aspectj" is missing, the following exception will be thrown: org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: Could not configure Spring Data JPA auditing-feature because spring-aspects.jar is not on the classpath!
If you want to use auditing please add spring-aspects.jar to the classpath.
I would suggest to add the Classname to the message. </description>
			<version>1.4.4 (Babbage SR3)</version>
			<fixedVersion>1.5.1 (Codd SR1), 1.6 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.config.JpaAuditingRegistrar.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">482</link>
		</links>
	</bug>
	<bug id="496" opendate="2014-03-13 04:23:30" fixdate="2014-03-13 04:47:46" resolution="Fixed">
		<buginformation>
			<summary>Query derivation doesn&amp;apos;t create joins for in-clauses on element collections</summary>
			<description>We currently don&amp;amp;apos;t support finderQueries for ElementCollection since we don&amp;amp;apos;t generate the necessary joins.
E.g.: The following use case dosen&amp;amp;apos;t work at the moment:






...




@ElementCollection private Set&amp;lt;String&amp;gt; attributes;




...












...




List&amp;lt;User&amp;gt; findByAttributesIn(Set&amp;lt;String&amp;gt; attributes);




...





</description>
			<version>1.5 GA (Codd)</version>
			<fixedVersion>1.5.1 (Codd SR1), 1.6 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.User.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.EclipseLinkNamespaceUserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="476" opendate="2014-02-25 01:44:23" fixdate="2014-03-13 10:18:05" resolution="Fixed">
		<buginformation>
			<summary>IllegalStateException caused by QueryUtils.toExpressionRecursively()</summary>
			<description>I&amp;amp;apos;ve been using 1.5.0.RC1 for a while now without issue. Yesterday, when I upgraded to 1.5.0.RELEASE, on boot of my application, I now get this failing error:






java.lang.IllegalStateException: Illegal attempt to dereference path source [null.credentials] of basic type




	at org.hibernate.jpa.criteria.path.AbstractPathImpl.illegalDereference(AbstractPathImpl.java:98) ~[hibernate-entitymanager-4.3.1.Final.jar:4.3.1.Final]




	at org.hibernate.jpa.criteria.path.AbstractPathImpl.get(AbstractPathImpl.java:182) ~[hibernate-entitymanager-4.3.1.Final.jar:4.3.1.Final]




	at org.springframework.data.jpa.repository.query.QueryUtils.toExpressionRecursively(QueryUtils.java:499) ~[spring-data-jpa-1.5.0.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.QueryUtils.toExpressionRecursively(QueryUtils.java:458) ~[spring-data-jpa-1.5.0.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.QueryUtils.toExpressionRecursively(QueryUtils.java:455) ~[spring-data-jpa-1.5.0.RELEASE.jar:na]






This issue does not appear with 1.5.0.RC1 (I&amp;amp;apos;ve reverted back to RC1 for now).</description>
			<version>1.5 GA (Codd)</version>
			<fixedVersion>1.4.5 (Babbage SR4), 1.5.1 (Codd SR1), 1.6 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">491</link>
			<link type="Relate" description="is related to">454</link>
		</links>
	</bug>
	<bug id="397" opendate="2013-09-04 08:57:47" fixdate="2014-03-13 11:29:35" resolution="Duplicate">
		<buginformation>
			<summary>generatedAlias not incrementing correctly in generated query</summary>
			<description>Given the following repository method:






public interface PayrollParametersRepository extends JpaRepository&amp;lt;PayrollParameters, Integer&amp;gt;, QueryDslPredicateExecutor&amp;lt;PayrollParameters&amp;gt;, PayrollParametersRepositoryCustom {




 




       public PayrollParameters findByPriceScheduleAndProcessPeriodAndCalculationType(




                     PriceSchedule priceSchedule, ProcessPeriod processPeriod, CalculationType calculation);




}






The PayrollParameters class has a reference to the PriceSchedule and ProcessPeriod entities. CalculationType is an enum.
The following query is generated:






select generatedAlias0 




  from com.example.domain.agreement.PayrollParameters as generatedAlias0 left join generatedAlias0.priceSchedule as generatedAlias1 left join generatedAlias0.processPeriod as generatedAlias0




 where ( ( generatedAlias1=:param0 ) and ( generatedAlias0=:param1 ) ) and ( generatedAlias0.calculationType=:param2 )];






Notice that generatedAlias0 is used twice. Once for the PayrollParameters and another time to represent the ProcessPeriod. As a result, when it references generatedAlias0.calculationType, it is ambiguous.</description>
			<version>1.3.4</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.PartTreeJpaQuery.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">396</link>
		</links>
	</bug>
	<bug id="497" opendate="2014-03-13 07:10:30" fixdate="2014-03-17 04:37:29" resolution="Fixed">
		<buginformation>
			<summary>Sorting for a field in a composite primary key throws "Can&amp;apos;t cast to EntityPath"</summary>
			<description>An entity with composite PK:






@Entity




public class DamageCode implements Serializable {




    @EmbeddedId




    DamageCodePK pk;




    ...    




}






and a primary key class:






@Embeddable




public class DamageCodePK implements Serializable {




   




    @Column(name="SERVICENO_ID")




    private String serviceNo;




    




    @Column(name="CODE")




    private String code;









    ....




}






then if I do:






damageCodeRepo.findAll(




                damageCode.pk.serviceNo.eq(serviceNo),




                damageCode.pk.code.asc())); // SEE .pk.code !!!






I get an Exception from spring-data-jpa with something like "Can&amp;amp;apos;t cast DamageCodePK to EntityPath"






Caused by: java.lang.ClassCastException: de.wirthedv.wrnvgca.app.domain.QDamageCodePK cannot be cast to com.mysema.query.types.EntityPath




	at org.springframework.data.jpa.repository.support.Querydsl.adjustOrderSpecifierIfNecessary(Querydsl.java:185) ~[spring-data-jpa-1.5.0.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.support.Querydsl.addOrderByFrom(Querydsl.java:150) ~[spring-data-jpa-1.5.0.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.support.Querydsl.applySorting(Querydsl.java:135) ~[spring-data-jpa-1.5.0.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.support.QueryDslJpaRepository.findAll(QueryDslJpaRepository.java:105) ~[spring-data-jpa-1.5.0.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.support.QueryDslJpaRepository.findAll(QueryDslJpaRepository.java:44) ~[spring-data-jpa-1.5.0.RELEASE.jar:na]





</description>
			<version>1.5 GA (Codd)</version>
			<fixedVersion>1.6 M1 (Dijkstra), 1.5.2 (Codd SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.domain.sample.EmbeddedIdExampleEmployee.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.IdClassExampleEmployeePK.java</file>
			<file type="M">org.springframework.data.jpa.repository.RepositoryWithCompositeKeyTests.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.EmbeddedIdExampleDepartment.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.EmbeddedIdExampleEmployeePK.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.EmployeeRepositoryWithEmbeddedId.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.EmployeeRepositoryWithIdClass.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.Querydsl.java</file>
		</fixedFiles>
	</bug>
	<bug id="500" opendate="2014-03-18 07:46:43" fixdate="2014-03-20 00:10:10" resolution="Fixed">
		<buginformation>
			<summary>Sorting of Embeddables raises ClassCastException </summary>
			<description>Sorting via an Embeddable creates a ClassCastException
QEntity cannot be cast to com.mysema.query.types.EntityPath
See referenced Gist.</description>
			<version>1.5.1 (Codd SR1)</version>
			<fixedVersion>1.6 M1 (Dijkstra), 1.5.2 (Codd SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.QueryDslJpaRepositoryTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="504" opendate="2014-03-23 10:16:00" fixdate="2014-03-27 09:29:32" resolution="Fixed">
		<buginformation>
			<summary>Error on QueryDSL after upgrade</summary>
			<description> have a project to demonstrate the use of spring-data-jpa and spring-data-mongodb on the same set of entities as part of presentation I prepared.
When I upgrade the spring-data-jpa to 1.5.1 I get a new exception. 1.4.5 with QueryDSL 3.2.4 does work and 1.3 with QueryDSL 2.9.0 works. I tried QueryDSL 3.3.1 as well as the older versions.
The project link is [https://github.com/corneil/spring-data-demo]
The exception occurs in src/main/java/org/springframework/data/demo/service/UserGroupDataServiceImpl.java line 95
It is a DSL query resulting in a seeming valid JPA query that works on the previous versions.
Stacktrace
DEBUG com.mysema.query.jpa.impl.JPAQuery - select groupMember from GroupMember groupMember   left join groupMember.member as member where groupMember.memberOfgroup.groupName = ?1 and groupMember.enabled = ?2 order by member.userId desc
ERROR org.hibernate.hql.internal.ast.ErrorCounter - line 5:10: unexpected token: member
ERROR org.hibernate.hql.internal.ast.ErrorCounter - line 5:10: unexpected token: member
line 5:10: unexpected token: member
    at org.hibernate.hql.internal.antlr.HqlBaseParser.negatedExpression(HqlBaseParser.java:2355)
    at org.hibernate.hql.internal.antlr.HqlBaseParser.logicalAndExpression(HqlBaseParser.java:2259)
    at org.hibernate.hql.internal.antlr.HqlBaseParser.logicalOrExpression(HqlBaseParser.java:2224)
    at org.hibernate.hql.internal.antlr.HqlBaseParser.expression(HqlBaseParser.java:2010)
    at org.hibernate.hql.internal.antlr.HqlBaseParser.orderElement(HqlBaseParser.java:2050)
    at org.hibernate.hql.internal.antlr.HqlBaseParser.orderByClause(HqlBaseParser.java:1172)
    at org.hibernate.hql.internal.antlr.HqlBaseParser.queryRule(HqlBaseParser.java:749)
    at org.hibernate.hql.internal.antlr.HqlBaseParser.selectStatement(HqlBaseParser.java:294)
    at org.hibernate.hql.internal.antlr.HqlBaseParser.statement(HqlBaseParser.java:157)
    at org.hibernate.hql.internal.ast.QueryTranslatorImpl.parse(QueryTranslatorImpl.java:266)
    at org.hibernate.hql.internal.ast.QueryTranslatorImpl.doCompile(QueryTranslatorImpl.java:180)
    at org.hibernate.hql.internal.ast.QueryTranslatorImpl.compile(QueryTranslatorImpl.java:136)
    at org.hibernate.engine.query.spi.HQLQueryPlan.&amp;lt;init&amp;gt;(HQLQueryPlan.java:105)
    at org.hibernate.engine.query.spi.HQLQueryPlan.&amp;lt;init&amp;gt;(HQLQueryPlan.java:80)
    at org.hibernate.engine.query.spi.QueryPlanCache.getHQLQueryPlan(QueryPlanCache.java:168)
    at org.hibernate.internal.AbstractSessionImpl.getHQLQueryPlan(AbstractSessionImpl.java:221)
    at org.hibernate.internal.AbstractSessionImpl.createQuery(AbstractSessionImpl.java:199)
    at org.hibernate.internal.SessionImpl.createQuery(SessionImpl.java:1735)
    at org.hibernate.ejb.AbstractEntityManagerImpl.createQuery(AbstractEntityManagerImpl.java:291)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:241)
    at $Proxy42.createQuery(Unknown Source)
    at com.mysema.query.jpa.impl.AbstractJPAQuery.createQuery(AbstractJPAQuery.java:129)
    at com.mysema.query.jpa.impl.AbstractJPAQuery.createQuery(AbstractJPAQuery.java:97)
    at com.mysema.query.jpa.impl.AbstractJPAQuery.list(AbstractJPAQuery.java:242)
    at org.springframework.data.jpa.repository.support.QueryDslJpaRepository.findAll(QueryDslJpaRepository.java:106)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
    at java.lang.reflect.Method.invoke(Method.java:597)
    at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:358)
    at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:343)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
    at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:96)
    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:260)
    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:94)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
    at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:155)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
    at org.springframework.data.jpa.repository.support.LockModeRepositoryPostProcessor$LockModePopulatingMethodIntercceptor.invoke(LockModeRepositoryPostProcessor.java:92)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
    at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:91)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)
    at $Proxy45.findAll(Unknown Source)
    at org.springframework.data.demo.service.UserGroupDataServiceImpl.listActiveUsersInGroup_aroundBody12(UserGroupDataServiceImpl.java:72)
    at org.springframework.data.demo.service.UserGroupDataServiceImpl$AjcClosure13.run(UserGroupDataServiceImpl.java:1)

The query logged by QueryDSL is different when the version of Spring Data JPA is changed from 1.4.5 to 1.5.1
SDJ 1.4.5






select 




    groupMember 




from 




    GroupMember groupMember left join groupMember.member as member 




where 




    groupMember.memberOfgroup.groupName = ?1 and groupMember.enabled = ?2 




order by 




    member.userId desc






SDJ 1.5.1






select 




    groupMember 




from 




    GroupMember groupMember left join groupMember.member as groupMember_member 




where 




    groupMember.memberOfgroup.groupName = ?1 and groupMember.enabled = ?2 




order by 




    groupMember_member.userId desc





</description>
			<version>1.5.1 (Codd SR1)</version>
			<fixedVersion>1.6 M1 (Dijkstra), 1.5.2 (Codd SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.Querydsl.java</file>
		</fixedFiles>
	</bug>
	<bug id="505" opendate="2014-03-23 13:52:16" fixdate="2014-03-31 06:06:50" resolution="Fixed">
		<buginformation>
			<summary>Blob query result only returns first byte</summary>
			<description>After upgrading Spring Data from 1.5.0 to 1.5.1, the following query always returns a byte array containing only the first byte of the expected blob, instead of the entire blob:






    @Query("select w.bytes from EntityWithBlobField w where w.id = :id")




    public byte[] getBytes(@Param(value = "id") long id);






 Reverting to Spring Data 1.5.0 fixed this issue for me.</description>
			<version>1.5.1 (Codd SR1)</version>
			<fixedVersion>1.6 M1 (Dijkstra), 1.5.2 (Codd SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryMethod.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">506</link>
		</links>
	</bug>
	<bug id="512" opendate="2014-04-14 00:19:24" fixdate="2014-04-14 00:22:29" resolution="Duplicate">
		<buginformation>
			<summary>Improve error message if parameter name could not be found.</summary>
			<description></description>
			<version>1.5.1 (Codd SR1)</version>
			<fixedVersion></fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.StringQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.StringQuery.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">513</link>
		</links>
	</bug>
	<bug id="509" opendate="2014-03-27 04:36:06" fixdate="2014-04-14 01:18:56" resolution="Fixed">
		<buginformation>
			<summary>Entity name used in &amp;apos;count&amp;apos; queries ignores the entity name set in ORM mapping file</summary>
			<description>To return the entity name, DefaultJpaEntityMetadata always uses either the entity class name or the name parameter of the Entity annotation.






public String getEntityName() {




  Entity entity = domainType.getAnnotation(Entity.class);




  boolean hasName = null != entity &amp;amp;&amp;amp; StringUtils.hasText(entity.name());




  return hasName ? entity.name() : domainType.getSimpleName();




}






If the entity name has been configured in an ORM mapping file, this is ignored, e.g.:






&amp;lt;entity name="car" class="com.sample.CarImpl"&amp;gt;




  ...




&amp;lt;/entity&amp;gt;






This means that an exception is thrown when using the count or exists methods of the Spring Data repositories. Specifically (longer trace attached): 






Caused by: java.lang.IllegalArgumentException: org.hibernate.hql.internal.ast.QuerySyntaxException: CarImpl is not mapped [select count(*) from CarImpl x WHERE x.carId = :carId AND 1 = 1]




	at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1364)




	at org.hibernate.ejb.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1300)




	at org.hibernate.ejb.AbstractEntityManagerImpl.createQuery(AbstractEntityManagerImpl.java:309)





</description>
			<version>1.5.1 (Codd SR1)</version>
			<fixedVersion>1.5.2 (Codd SR2), 1.6 RC1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.config.QueryLookupStrategyTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.RoleRepository.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.Role.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.RoleRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="513" opendate="2014-04-14 00:20:36" fixdate="2014-04-14 01:42:44" resolution="Fixed">
		<buginformation>
			<summary>Improve error message for missing @Param annotations for query methods with named parameters</summary>
			<description>Assume you have a repository declaration like this:






public PeopleRepository extends Repository&amp;lt;Person, Long&amp;gt; {









  @Query("select p from Person p where p.lastname = :lastname")




  List&amp;lt;Person&amp;gt; findByLastname(String lastname);




}






On method invocation you get a "Name must not be null or empty!" from StringQuery which doesn&amp;amp;apos;t make too obvious that you&amp;amp;apos;re missing @Param annotations on the lastname parameter. We should improve the exception message to guide users a bit more.</description>
			<version>1.5.1 (Codd SR1)</version>
			<fixedVersion>1.5.2 (Codd SR2), 1.6 RC1 (Dijkstra)</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.StringQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.StringQuery.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">512</link>
		</links>
	</bug>
	<bug id="517" opendate="2014-04-22 05:27:09" fixdate="2014-04-22 05:52:32" resolution="Fixed">
		<buginformation>
			<summary>Defensively check for null for optional dependency to CrudMethodMetadata in SimpleJpaRepository</summary>
			<description>DATAJPA-173 introduced a CrudMethodMetadata abstraction used in SimpleJpaRepository. As it&amp;amp;apos;s an optional dependency (configured through a setter) we do guard access to it with null checks.</description>
			<version>1.6 M1 (Dijkstra)</version>
			<fixedVersion>1.6 RC1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="499" opendate="2014-03-16 10:35:05" fixdate="2014-04-29 00:10:28" resolution="Fixed">
		<buginformation>
			<summary>Paginate with QueryDSL generate "nulls last" illegal syntax when using MSSQL.</summary>
			<description>Microsoft SQL Server does not support NULLS FIRST|LAST (of SQL:2003) for ORDER BY syntax, but QueryDSL add it on paginated list.
I found NullHandling.NullsLast just used in Querydsl.toOrderSpecifier on 1.5.1.RELEASE. when I passed custom Pageable without NullHandling (according to 1.5.0.RELEASE), It just run well.
(Then may I mess with Microsoft? )</description>
			<version>1.5.1 (Codd SR1)</version>
			<fixedVersion>1.6 RC1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.Querydsl.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">518</link>
			<link type="Relate" description="is related to">491</link>
		</links>
	</bug>
	<bug id="510" opendate="2014-03-31 22:55:46" fixdate="2014-05-19 03:35:18" resolution="Fixed">
		<buginformation>
			<summary>Regression in 1.5.1 - Sort by property of an associated object doesn&amp;apos;t work. Join property and INNER vs OUTER join when sorting</summary>
			<description>Order by a column on a join table seems to be filtering out null values again (INNER JOIN vs OUTER JOIN?). This is with an Oracle-backed db.
DATAJPA-346 fixed this issue, however after upgrading to 1.5.1 it has come back.
Library versions are:
spring-data-jpa 1.5.1.RELEASE
querydsl 3.3.2
hibernate 4.3.4.Final
When I try to sort on a joined column, the null joins are filtered out. When I change spring-dta-jpa to 1.5.0.RELEASE it works again without filtering with all other dependencies the same version.
Seems like a regression in 1.5.1.
The offending generated query is shown in both versions below






1.5.0 (working)






    select




        * 




    from




        (




        select




            &amp;lt;&amp;lt;all-my-select-cols&amp;gt;&amp;gt;




        from




            REQUEST request0_ 




        left outer join




            SITE_USER siteuser1_ 




                on request0_.ASSIGNED_TO=siteuser1_.ID 




        where




            request0_.ROW_END_DATE is null 




        order by




            lower(siteuser1_.FIRST_NAME) asc,




            lower(siteuser1_.LAST_NAME) asc) 




    where




        rownum &amp;lt;= ?












1.5.1 (broke)






    select




        * 




    from




        (




        select




            &amp;lt;&amp;lt;all-my-select-cols&amp;gt;&amp;gt;




        from




            REQUEST request0_,




            SITE_USER siteuser1_ 




        where




            request0_.ASSIGNED_TO=siteuser1_.ID 




            and (




                request0_.ROW_END_DATE is null




            ) 




        order by




            lower(siteuser1_.FIRST_NAME) asc) 




    where




        rownum &amp;lt;= ?






It also looks like my secondary order by column is missing (LAST_NAME), as the only thing I changed between runs was the spring-data-jpa version.</description>
			<version>1.5.1 (Codd SR1)</version>
			<fixedVersion>1.5.3 (Codd SR3), 1.6 GA (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.Querydsl.java</file>
		</fixedFiles>
	</bug>
	<bug id="545" opendate="2014-05-21 10:40:38" fixdate="2014-05-22 03:14:17" resolution="Fixed">
		<buginformation>
			<summary>Special characters not allowed anymore in named binding parameter</summary>
			<description>Migration from 1.2.0 to 1.5.2 leads to regression in terms of support of accentuated characters in named binding parameters. The problem comes form the use of \w+ in regular expression to match named parameter.  One solution would be to use "\p
{L}
+" instead (see the JavaDoc of Pattern).
The code that might be improved is in the static field PARAMETER_BINDING_PATTERN in the enum ParameterBindingParser of org.springframework.data.jpa.repository.query.StringQuery class.






public static void main(String[] args) {




  




  String frenchWord = "abonns";









  Pattern pOK = Pattern.compile("\\p\{L\}+", Pattern.CASE_INSENSITIVE);




  Matcher matcherOK = pOK.matcher(frenchWord);




  System.out.println(frenchWord + " matches " +  pOK.pattern() + " : " + matcherOK.matches());




		




  Pattern pKO = Pattern.compile("\\w+", Pattern.CASE_INSENSITIVE);




  Matcher matcherKO = pKO.matcher(frenchWord);




  System.out.println(frenchWord + " matches " +  pKO.pattern() + " : " + matcherKO.matches());




}






I modified several of my source files because I needed the update, but I am a bit frustrated. It would be nice to check elsewhere the use of \w+ in Spring data regular expression. Thank you very much in advance to bring back the support of native languages everywhere, just like Java does.</description>
			<version>1.5.2 (Codd SR2)</version>
			<fixedVersion>1.5.3 (Codd SR3), 1.6.1 (Dijkstra SR1), 1.7 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.StringQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.StringQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="527" opendate="2014-05-05 03:01:09" fixdate="2014-06-17 04:33:39" resolution="Fixed">
		<buginformation>
			<summary>CrudRepository.exists(ID id) fails for entity with @IdClass</summary>
			<description>Given following setup (equals, hashcode and constructors omitted):






@Entity




@IdClass(A.Id.class)




public class A {




    @javax.persistence.Id




    private Long basicId;









    @javax.persistence.Id




    @ManyToOne




    private B b;









    public static class Id implements Serializable {




        private Long basicId;









        private Long b;




}









@Entity




public class B {




    @Id




    private Long id;




}









public interface ARepository extends Repository&amp;lt;A, A.Id&amp;gt; {




    public boolean exists(A.Id id);




}






the following test fails with an error:






    @Test




    public void exclusion_exists() {




        B b = new B(1L);




        em.persist(b);




        em.persist(new A(2L, b));









        boolean exists = repository.exists(new A.Id(2L, 1L));









        assertThat(exists).isTrue();




    }






The error is (Spring Data 1.4.3)






java.lang.IllegalArgumentException: Parameter value [1] did not match expected type [com.mach.msp.qos.error_exclusion.model.B (n/a)]




	at org.hibernate.ejb.AbstractQueryImpl.validateBinding(AbstractQueryImpl.java:382)




	at org.hibernate.ejb.AbstractQueryImpl.registerParameterBinding(AbstractQueryImpl.java:356)




	at org.hibernate.ejb.AbstractQueryImpl.registerParameterBinding(AbstractQueryImpl.java:347)




	at org.hibernate.ejb.QueryImpl.setParameter(QueryImpl.java:373)




	at org.springframework.data.jpa.repository.support.SimpleJpaRepository.exists(SimpleJpaRepository.java:234)




...






I checked also 1.4.5 and 1.5.2 and both fail in the same way.
It seems to me that Spring Data does not realize that when a relationship is used in a composite key, the relationship is marked with @Id, but in the IdClass only the key of the relationship&amp;amp;apos;s other side must be used (cf. JPA 2.0 spec: 2.4.1 Primary Keys Corresponding to Derived Identities).
Running repository.findOne() works fine under the same circumstances.</description>
			<version>1.4.3 (Babbage SR2)</version>
			<fixedVersion>1.5.3 (Codd SR3), 1.6.1 (Dijkstra SR1), 1.7 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.JpaRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaEntityInformation.java</file>
			<file type="M">org.springframework.data.jpa.repository.RepositoryWithCompositeKeyTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="561" opendate="2014-06-26 03:23:46" fixdate="2014-06-26 07:26:04" resolution="Fixed">
		<buginformation>
			<summary>Entity with primitive version property invalidly considered not new</summary>
			<description>Hello,
we have some problems while saving entities with cascading after updating from 1.3.4.RELEASE to 1.6.0.RELEASE.
Calling save with a list of entities will return a list of entities where only one has an ID.
This results in a constraint violation if the corresponding data should be inserted into the database.
Dependencies:
Before (Working):

spring-data-jpa 1.3.4.RELEASE
spring-data-commons 1.7.1.RELEASE
spring 4.0.5.RELEASE
eclipselink 2.5.1

After (Not working):

spring-data-jpa 1.6.0.RELEASE
spring-data-commons 1.8.0.RELEASE
spring 4.0.5.RELEASE
eclipselink 2.5.1

See attachement for JUnit test case.
I hope the single files are ok for you. If not I can upload a complete test project somewhere.
I figured out that the problematic line of code seems to be ChildEntity:52.
Here the child will be added to the list of children in the parent.
I dont know if this is good style but it worked fine with previous version of spring-data.
Is this really a bug or is the style of adding children to parents not more supported?
Thanks and best regards
Dennis</description>
			<version>1.6 GA (Dijkstra)</version>
			<fixedVersion>1.6.1 (Dijkstra SR1), 1.7 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="519" opendate="2014-04-23 09:18:59" fixdate="2014-06-27 10:14:11" resolution="Fixed">
		<buginformation>
			<summary>ClasspathScanningPersistenceUnitPostProcessor throws NPE</summary>
			<description>My web app has heterogenous DB support, and imports 3 jars each with its own Mongo, JPA MySQL, and JPA Postgres support. The datasource is chosen at runtime via conditional configuration loading.
I have to setup my web app to load DB-specific orm.xml files using intra-jar class loading. For example, my Postgres config looks like this:






Class&amp;lt;?&amp;gt; klass = com.acme.postgres.Placeholder.class;




ClasspathScanningPersistenceUnitPostProcessor processor = new ClasspathScanningPersistenceUnitPostProcessor(klass.getPackage().getName());




processor.setResourceLoader(new DefaultResourceLoader(klass.getClassLoader()));




processor.setMappingFileNamePattern("**/orm.xml");




entityManagerFactoryBean.setPersistenceUnitPostProcessors(processor);






The orm.xml file is located successfully within one of the WEB-INF/lib jars:






09:06:50 web.1  | 706  [localhost-startStop-1] DEBUG PathMatchingResourcePatternResolver  - Resolved location pattern [classpath*:com/acme/postgres/**/*orm.xml] to resources [URL [jar:file:/Users/me/workspaces/feature-springdata/MyServer/target/tomcat.5000/work/Tomcat/localhost/_/WEB-INF/lib/MyPostgresSupport-0.0.1-SNAPSHOT.jar!/com/acme/postgres/orm.xml]]






But then a traversal of resources throws a NPE:






09:06:50 web.1  | Caused by: java.lang.NullPointerException




09:06:50 web.1  | 	at org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessor.scanForMappingFileLocations(ClasspathScanningPersistenceUnitPostProcessor.java:146)




09:06:50 web.1  | 	at org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessor.postProcessPersistenceUnitInfo(ClasspathScanningPersistenceUnitPostProcessor.java:103)






The suspicious code is this:






for (Resource resource : scannedResources) {




   try {




      String resourcePath = resource.getURI().getPath();




      String resourcePathInClasspath = resourcePath.substring(resourcePath.indexOf(basePackagePathComponent));




      




  }




}






In the above code, resourcePath is null. And the resource.getURI() is:






jar:file:/Users/me/workspaces/feature-springdata/MyServer/target/tomcat.5000/work/Tomcat/localhost/_/WEB-INF/lib/MyPostgresSupport-0.0.1-SNAPSHOT.jar!/com/acme/postgres/orm.xml





</description>
			<version>1.5.2 (Codd SR2)</version>
			<fixedVersion>1.6.1 (Dijkstra SR1), 1.7 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessor.java</file>
			<file type="M">org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessorUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="568" opendate="2014-07-04 00:49:38" fixdate="2014-07-10 05:33:04" resolution="Fixed">
		<buginformation>
			<summary>Cannot update the new inserted entity which has @Version</summary>
			<description>I have a record in database with ID=1 and version is 0(which is the initial value). When I save an entity from DTO W/ ID=1 and version is 0. I got the typical detached entity related exception.
Because in the class org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation,  the line 206 is return versionAttribute.getJavaType().isPrimitive() &amp;amp;&amp;amp; ((Number) versionValue).longValue() == 0 
which regards the version value = 0 as a NEW entity. Then the persist method will be mis-invoked.
</description>
			<version>1.6.1 (Dijkstra SR1)</version>
			<fixedVersion>1.7 M1 (Evans), 1.6.2 (Dijkstra SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.PrimitiveVersionProperty.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">567</link>
		</links>
	</bug>
	<bug id="567" opendate="2014-07-02 01:37:09" fixdate="2014-07-10 05:33:23" resolution="Fixed">
		<buginformation>
			<summary>OptimisticLock does not work anymore</summary>
			<description>When migrating from spring-data-jpa 1.6.0 to 1.6.1.RELEASE, Optimistic Locking does not work anymore. Here is my entity:






@Entity




@Table




public class MyEntity implements Serializable {









	@Id




	@Column(unique = true, nullable = false)




	private String id;









	@Version




	@Column(name = "version")




	private long version;




	




}






The following JUnit test works fine before 1.6.1:






@Test(expected = OptimisticLockException.class)




public void testWithOptimisticLock() {




	MyEntity myEntity = new Entity();




        myEntity.setId("myId");




	myEntityDao.save(myEntity);




	myEntityDao.save(myEntity);




}






myEntityDao is an interface which extends JpaRepository.</description>
			<version>1.6.1 (Dijkstra SR1)</version>
			<fixedVersion>1.7 M1 (Evans), 1.6.2 (Dijkstra SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.PrimitiveVersionProperty.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">568</link>
		</links>
	</bug>
	<bug id="362" opendate="2013-06-27 00:40:23" fixdate="2014-07-18 02:51:15" resolution="Fixed">
		<buginformation>
			<summary>Parameter used in % LIKE expression is changed for whole query</summary>
			<description>





@Query("SELECT e FROM Example e WHERE e.one = ?1 OR e.two LIKE %?1")




List&amp;lt;Example&amp;gt; findByOneOrTwo(String query);






will result in the following SQL query being executed (parameter &amp;amp;apos;QUERY&amp;amp;apos;):






SELECT e.one, e.two FROM examples e WHERE e.one = &amp;amp;apos;%QUERY&amp;amp;apos; OR e.two LIKE &amp;amp;apos;%QUERY&amp;amp;apos;






but it should look like this:






SELECT e.one, e.two FROM examples e WHERE e.one = &amp;amp;apos;QUERY&amp;amp;apos; OR e.two LIKE &amp;amp;apos;%QUERY&amp;amp;apos;






A workaround is to use a separate parameter for the LIKE expression:






@Query("SELECT e FROM Example e WHERE e.one = ?1 OR e.two LIKE %?2")




List&amp;lt;Example&amp;gt; findByOneOrTwo(String query, String queryTwo);





</description>
			<version>1.3.2</version>
			<fixedVersion>1.6.2 (Dijkstra SR2), 1.7 RC1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.StringQueryUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="581" opendate="2014-07-31 04:02:53" fixdate="2014-08-06 01:27:32" resolution="Fixed">
		<buginformation>
			<summary>Can no longer call save() with a @Version&amp;apos;ed detached entity in 1.6.2</summary>
			<description>My use case is to take objects provided to be saved as part of an HTTP request, and then save the updated object to the DB. I do however use the optimistic locking with an @Version field on the entity.
Prior to 1.6.2, I could simply take the detached entity, and pass that to a Repository.save() method, but in 1.6.2, this throws an exception complaining that a detached entity has been passed to the persist() method
I attach a minimal test case to illustrate the problem. Changing the POM dependency to 1.6.1 removes the issue (as does commenting out the @Version annotation, but I don&amp;amp;apos;t want to do that!). Worth also noting that although the s-d-commons dependency is at 1.8.1, makes no difference to the bug behaviour if you change that to be in sync with the s-d-jpa version.
The exception trace I get from running an mvn package within my test case is:






org.springframework.orm.jpa.JpaSystemException: org.hibernate.PersistentObjectException: detached entity passed to persist: example.data.TreeEntity; nested exception is javax.persistence.PersistenceException: org.hibernate.PersistentObjectException: detached entity passed to persist: example.data.TreeEntity




        at org.springframework.orm.jpa.EntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(EntityManagerFactoryUtils.java:418)




        at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.translateExceptionIfPossible(AbstractEntityManagerFactoryBean.java:418)




        at org.springframework.dao.support.ChainedPersistenceExceptionTranslator.translateExceptionIfPossible(ChainedPersistenceExceptionTranslator.java:58)




        at org.springframework.dao.support.DataAccessUtils.translateIfNecessary(DataAccessUtils.java:213)




        at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:163)




        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




        at org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor$CrudMethodMetadataPopulatingMethodIntercceptor.invoke(CrudMethodMetadataPostProcessor.java:111)




        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




        at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:91)




        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




        at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)




        at com.sun.proxy.$Proxy22.save(Unknown Source)




        at example.data.RepositoryTest.testExample(RepositoryTest.java:25)




        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




        at java.lang.reflect.Method.invoke(Method.java:483)




        at org.junit.internal.runners.TestMethodRunner.executeMethodBody(TestMethodRunner.java:99)




        at org.junit.internal.runners.TestMethodRunner.runUnprotected(TestMethodRunner.java:81)




        at org.junit.internal.runners.BeforeAndAfterRunner.runProtected(BeforeAndAfterRunner.java:34)




        at org.junit.internal.runners.TestMethodRunner.runMethod(TestMethodRunner.java:75)




        at org.junit.internal.runners.TestMethodRunner.run(TestMethodRunner.java:45)




        at org.junit.internal.runners.TestClassMethodsRunner.invokeTestMethod(TestClassMethodsRunner.java:71)




        at org.junit.internal.runners.TestClassMethodsRunner.run(TestClassMethodsRunner.java:35)




        at org.junit.internal.runners.TestClassRunner$1.runUnprotected(TestClassRunner.java:42)




        at org.junit.internal.runners.BeforeAndAfterRunner.runProtected(BeforeAndAfterRunner.java:34)




        at org.junit.internal.runners.TestClassRunner.run(TestClassRunner.java:52)




        at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)




        at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)




        at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)




        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




        at java.lang.reflect.Method.invoke(Method.java:483)




        at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)




        at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)




        at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)




        at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)




        at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75)




Caused by: javax.persistence.PersistenceException: org.hibernate.PersistentObjectException: detached entity passed to persist: example.data.TreeEntity




        at org.hibernate.jpa.spi.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1763)




        at org.hibernate.jpa.spi.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1677)




        at org.hibernate.jpa.spi.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1683)




        at org.hibernate.jpa.spi.AbstractEntityManagerImpl.persist(AbstractEntityManagerImpl.java:1187)




        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




        at java.lang.reflect.Method.invoke(Method.java:483)




        at org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:289)




        at com.sun.proxy.$Proxy16.persist(Unknown Source)




        at org.springframework.data.jpa.repository.support.SimpleJpaRepository.save(SimpleJpaRepository.java:389)




        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




        at java.lang.reflect.Method.invoke(Method.java:483)




        at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:405)




        at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:390)




        at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:344)




        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




        at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:96)




        at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:260)




        at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:94)




        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




        at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:155)




        ... 34 more




Caused by: org.hibernate.PersistentObjectException: detached entity passed to persist: example.data.TreeEntity




        at org.hibernate.event.internal.DefaultPersistEventListener.onPersist(DefaultPersistEventListener.java:139)




        at org.hibernate.event.internal.DefaultPersistEventListener.onPersist(DefaultPersistEventListener.java:75)




        at org.hibernate.internal.SessionImpl.firePersist(SessionImpl.java:811)




        at org.hibernate.internal.SessionImpl.persist(SessionImpl.java:784)




        at org.hibernate.internal.SessionImpl.persist(SessionImpl.java:789)




        at org.hibernate.jpa.spi.AbstractEntityManagerImpl.persist(AbstractEntityManagerImpl.java:1181)




        ... 54 more





</description>
			<version>1.6.2 (Dijkstra SR2)</version>
			<fixedVersion>1.7 RC1 (Evans), 1.6.4 (Dijkstra SR4)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.data.jpa.domain.sample.SampleWithIdClassPK.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.SampleWithIdClass.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.EclipseLinkJpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformationUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">590</link>
			<link type="Duplicate" description="is duplicated by">597</link>
		</links>
	</bug>
	<bug id="582" opendate="2014-08-01 09:39:24" fixdate="2014-08-06 01:27:44" resolution="Fixed">
		<buginformation>
			<summary>JpaMetamodelEntityInformation.isNew() throws ClassCastException for @Version of type Calendar</summary>
			<description>If a domain object uses a @Version on a Calendar, then the following  error occurs:






ClassCastException: java.util.GregorianCalendar cannot be cast to java.lang.Number




	at org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.isNew(JpaMetamodelEntityInformation.java:207)




	at org.springframework.data.jpa.repository.support.SimpleJpaRepository.save(SimpleJpaRepository.java:388)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:606)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:443)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:428)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:382)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:98)




	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:266)




	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:95)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:136)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor$CrudMethodMetadataPopulatingMethodIntercceptor.invoke(CrudMethodMetadataPostProcessor.java:111)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207)




	at com.sun.proxy.$Proxy49.save(Unknown Source)




	at org.springframework.security.samples.mvc.MessageController.create(MessageController.java:55)






This problem seems to be related to commit 68ed8a908.</description>
			<version>1.7 RC1 (Evans)</version>
			<fixedVersion>1.7 RC1 (Evans), 1.6.4 (Dijkstra SR4)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.data.jpa.domain.sample.SampleWithIdClassPK.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.SampleWithIdClass.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.EclipseLinkJpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformationUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">590</link>
		</links>
	</bug>
	<bug id="590" opendate="2014-08-19 09:00:26" fixdate="2014-08-19 09:27:01" resolution="Duplicate">
		<buginformation>
			<summary>@Version implementation changes from 1.6.0 to 1.6.2 is a breaking change that doesn&amp;apos;t make much sense</summary>
			<description>isNew is implemented incorrectly in &amp;gt; 1.6.0...






JpaMetamodelEntityInformation.isNew() in 1.6.0






    @Override




    public boolean isNew(T entity) {




        




        if (versionAttribute == null) {




        	return super.isNew(entity);




        }




        




        return new DirectFieldAccessFallbackBeanWrapper(entity).getPropertyValue(versionAttribute.getName()) == null;




    }






This is to me a correct implementation that specifies an entity is &amp;amp;apos;new&amp;amp;apos; when there is no Version populated.






JpaMetamodelEntityInformation.isNew() in 1.6.2











	@Override




	public boolean isNew(T entity) {









		if (versionAttribute == null || versionAttribute.getJavaType().isPrimitive()) {




			return super.isNew(entity);




		}









		BeanWrapper wrapper = new DirectFieldAccessFallbackBeanWrapper(entity);




		Object versionValue = wrapper.getPropertyValue(versionAttribute.getName());









		if (versionValue == null) {




			return true;




		}









		return ((Number) versionValue).longValue() == 0;




	}






You can see that the latest code now expects the version to be non-zero. Hibernate by default inserts a 0 for newly created objects, it seems strange to make everyone default to 1 for versioning.. it seems even stranger to do it in a patch/minor release.</description>
			<version>1.6.1 (Dijkstra SR1)</version>
			<fixedVersion>1.7 RC1 (Evans), 1.6.4 (Dijkstra SR4)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.data.jpa.domain.sample.SampleWithIdClassPK.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.SampleWithIdClass.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.EclipseLinkJpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformationUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">582</link>
			<link type="Duplicate" description="duplicates">581</link>
		</links>
	</bug>
	<bug id="597" opendate="2014-08-26 08:25:52" fixdate="2014-08-26 09:01:45" resolution="Fixed">
		<buginformation>
			<summary>Saving detatched entity breaks when moving from Spring Data JPA 1.5.3 to 1.6.2</summary>
			<description>We have working code that uses an older version of Spring Data JPA and some of our integration tests broke when we upgraded to 1.6.2.  I&amp;amp;apos;ve created a self-contained Gradle project and put it up on GitHub for perusal and placed the link in the &amp;amp;apos;Reference URL&amp;amp;apos; field of this form.  If you change the versions of the Spring Data JPA library you will see how the test passes or fails depending on what library version is included.  For now, we&amp;amp;apos;ll stay at 1.5.3 but we would like to be able to move our code forward at some point.  I search the database and found DATAJPA-581 might be a similar issue.</description>
			<version>1.6.2 (Dijkstra SR2)</version>
			<fixedVersion>1.6.4 (Dijkstra SR4), 1.7 GA (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.data.jpa.domain.sample.SampleWithIdClassPK.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.SampleWithIdClass.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.EclipseLinkJpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformationUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">581</link>
		</links>
	</bug>
	<bug id="593" opendate="2014-08-20 12:37:55" fixdate="2014-09-01 04:47:38" resolution="Fixed">
		<buginformation>
			<summary>Custom repository implementations are not picked up when using CDI</summary>
			<description></description>
			<version>1.7 RC1 (Evans)</version>
			<fixedVersion>1.7 GA (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.cdi.JpaRepositoryBean.java</file>
			<file type="M">org.springframework.data.jpa.repository.cdi.JpaRepositoryExtension.java</file>
		</fixedFiles>
	</bug>
	<bug id="608" opendate="2014-09-15 05:09:07" fixdate="2014-09-15 05:17:47" resolution="Fixed">
		<buginformation>
			<summary>JpaPersistentEntityImpl.isEntity() should consider actual type</summary>
			<description>JpaPersistentProperty.isEntity() is defined to return true if the actual property type is an entity. So Collection and Map types need to inspect the component and value types. It&amp;amp;apos;s probably safe to simply rely on getActualType() here.</description>
			<version>1.6.4 (Dijkstra SR4)</version>
			<fixedVersion>1.8 M1 (Fowler), 1.6.5 (Dijkstra SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.mapping.JpaMetamodelMappingContextIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.mapping.JpaPersistentPropertyImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="617" opendate="2014-10-23 03:27:07" fixdate="2014-10-29 01:59:49" resolution="Fixed">
		<buginformation>
			<summary>Named query lookups might cause transaction to be rolled back</summary>
			<description>The execution of a paged repository method backed by a JPA named query might break the currently running transaction as it tries to look up a named count query but can mitigate a lookup failure. However, the failing lookup causes the transaction to be marked as rollback (as required by the JPA specification).
We should revisit named query validation and execution like we did for manually defined queries using @Query in DATAJPA-350.</description>
			<version>1.6.4 (Dijkstra SR4)</version>
			<fixedVersion>1.7.1 (Evans SR1), 1.8 M1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.NamedQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaRepositoryFactoryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.CrudMethodMetadataIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.NamedQueryUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">724</link>
			<link type="Relate" description="is related to">350</link>
		</links>
	</bug>
	<bug id="620" opendate="2014-10-29 09:38:03" fixdate="2014-10-30 02:01:59" resolution="Fixed">
		<buginformation>
			<summary>Infinite loop in unsynchronized HashMap in CrudMethodMetadataPostProcessor</summary>
			<description>The method org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor.CrudMethodMetadataPopulatingMethodIntercceptor#invoke is not thread-safe, although it is called concurrently when Spring-Data-JPA-Queries are executed concurrently.
More concretely, since the method uses the non-thread-safe java.util.HashMap, concurrent calls to this method may result in an infinite loop when executing the Hashmap-Lookup &amp;amp;apos;metadataCache.get(method)&amp;amp;apos; (line 101 in version 1.7.0.RELEASE), and I have actually encountered this behavior in an application. (Infinite loops in concurrently used hashmaps appear to be a known problem, see, e.g., https://jira.spring.io/browse/DATACMNS-518 or http://mailinator.blogspot.dk/2009/06/beautiful-race-condition.html.)
I therefore believe that this method should be made thread-safe, e.g., by using a java.util.concurrent.ConcurrentHashMap.</description>
			<version>1.7 GA (Evans)</version>
			<fixedVersion>1.7.1 (Evans SR1), 1.8 M1 (Fowler), 1.6.5 (Dijkstra SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="605" opendate="2014-09-05 16:23:03" fixdate="2014-11-10 05:46:09" resolution="Fixed">
		<buginformation>
			<summary>JpaPersistentPropertyImpl does not override method isVersionProperty</summary>
			<description>JpaPersistentPropertyImpl is not overriding the isVersionProperty so if you call PersistentEntity.hasVersionProperty it could return incorrectly false.</description>
			<version>1.6.4 (Dijkstra SR4)</version>
			<fixedVersion>1.8 M1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.mapping.JpaPersistentPropertyImpl.java</file>
			<file type="M">org.springframework.data.jpa.mapping.JpaPersistentPropertyImplUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="627" opendate="2014-11-13 05:22:15" fixdate="2014-11-17 08:03:00" resolution="Fixed">
		<buginformation>
			<summary>Typo in BeanDefinitionNames.</summary>
			<description>





	public static final String JPA_MAPPING_CONTEXT_BEAN_NAME = "jpaMapppingContext";






should be:






	public static final String JPA_MAPPING_CONTEXT_BEAN_NAME = "jpaMappingContext";





</description>
			<version>1.6.4 (Dijkstra SR4)</version>
			<fixedVersion>1.8 M1 (Fowler), 1.6.5 (Dijkstra SR5), 1.7.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.config.BeanDefinitionNames.java</file>
		</fixedFiles>
	</bug>
	<bug id="622" opendate="2014-11-06 16:45:59" fixdate="2014-11-24 09:17:27" resolution="Fixed">
		<buginformation>
			<summary>Hibernate thinks AbstractPersistable.isNew() is a property</summary>
			<description>https://gist.github.com/xenoterracide/caf86e765bcaac24a705
The above contains the Entity classes and full stack trace, I can provide more details on request, here&amp;amp;apos;s a snippet.






Caused by: org.hibernate.PropertyNotFoundException: Could not find a setter for property new in class com.xenoterracide.rpf.model.Character




	at org.hibernate.property.BasicPropertyAccessor.createSetter(BasicPropertyAccessor.java:246)




	at org.hibernate.property.BasicPropertyAccessor.getSetter(BasicPropertyAccessor.java:240)




	at org.hibernate.mapping.Property.getSetter(Property.java:328)




	at org.hibernate.tuple.entity.PojoEntityTuplizer.buildPropertySetter(PojoEntityTuplizer.java:416)




	at org.hibernate.tuple.entity.AbstractEntityTuplizer.&amp;lt;init&amp;gt;(AbstractEntityTuplizer.java:201)




	at org.hibernate.tuple.entity.PojoEntityTuplizer.&amp;lt;init&amp;gt;(PojoEntityTuplizer.java:80)




	... 178 more






adding the method 





public void setNew( final boolean val ) {}





 fixes the problem, also worth noting is that the REST implementation returns 





 "new" : false,





 in the json
this is a gist of the full app in broken state
https://gist.github.com/xenoterracide/66cafbc651c938aa74e5</description>
			<version>1.6.4 (Dijkstra SR4)</version>
			<fixedVersion>1.8 M1 (Fowler), 1.6.5 (Dijkstra SR5), 1.7.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.domain.AbstractPersistable.java</file>
			<file type="M">org.springframework.data.jpa.repository.AbstractPersistableIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="629" opendate="2014-11-14 03:13:49" fixdate="2014-11-27 09:03:49" resolution="Fixed">
		<buginformation>
			<summary>SPEL expression does not work with #{#entityName} in @Query</summary>
			<description></description>
			<version>1.7.1 (Evans SR1)</version>
			<fixedVersion>1.8 M1 (Fowler), 1.7.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.ExpressionBasedStringQuery.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">628</link>
		</links>
	</bug>
	<bug id="523" opendate="2014-04-29 05:06:57" fixdate="2014-11-28 00:55:33" resolution="Fixed">
		<buginformation>
			<summary>Specifications should implement Serializable</summary>
			<description>org.springframework.data.jpa.domain.Specifications does not implement Serializable therefore it cannot be used to create a Specification for remote (e.g. via Spring Remoting) call of  JpaSpecificationExecutor repositories.</description>
			<version>1.5.2 (Codd SR2)</version>
			<fixedVersion>1.8 M1 (Fowler), 1.6.5 (Dijkstra SR5), 1.7.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.domain.Specification.java</file>
			<file type="M">org.springframework.data.jpa.domain.SpecificationsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.domain.Specifications.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">525</link>
		</links>
	</bug>
	<bug id="606" opendate="2014-09-11 03:16:08" fixdate="2014-11-28 01:55:02" resolution="Fixed">
		<buginformation>
			<summary>SQLGrammarException for IN-clause with empty collection as parameter</summary>
			<description>Consider the following repository method:






List&amp;lt;AvatarEntity&amp;gt; findByCategoryInOrderByCategoryAsc(List&amp;lt;String&amp;gt; categories);






When this method gets called with an empty list, it leads to the following exception:






Exception: javax.ejb.EJBTransactionRolledbackException: org.hibernate.exception.SQLGrammarException: could not extract ResultSet




Caused by: javax.persistence.PersistenceException: org.hibernate.exception.SQLGrammarException: could not extract ResultSet




Caused by: org.hibernate.exception.SQLGrammarException: could not extract ResultSet




Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &amp;amp;apos;) order by avatar0_.category asc&amp;amp;apos; at line 1






which essentially happens with the malformed query






SELECT * FROM avatar WHERE category IN () ORDER BY category ASC;






As a workaround, callers have to check for an empty parameter list before invocation.</description>
			<version>1.7 GA (Evans)</version>
			<fixedVersion>1.8 M1 (Fowler), 1.7.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.ParameterMetadataProvider.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.ParameterExpressionProviderTests.java</file>
			<file type="M">org.springframework.data.jpa.provider.PersistenceProvider.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.PartTreeJpaQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="611" opendate="2014-09-29 23:26:34" fixdate="2014-11-28 03:40:18" resolution="Fixed">
		<buginformation>
			<summary>SimpleJpaRepository.findAll(Iterable&lt;ID ids) not working when for composite primary keys</summary>
			<description>I have a composite primary key and this is how i have incorporated it:
@IdClass(PrimaryKey.class)
class Table {
@Id
private String id1;
@Id
private String id2;
@Id
private Integer id3;
}
class PrimaryKey {
private String id1;
private String id2;
private Integer id3;
}
public interface TableRepository extends JpaRepository&amp;lt;Table, PrimaryKey&amp;gt;
FindOne works fine with this PrimaryKey, however, it is unable to recognize the fields correctly when i use FindAll with a List of PrimaryKeys.
Attached is a log.
I use Hibernate with Spring Data JPA.</description>
			<version>1.6 GA (Dijkstra)</version>
			<fixedVersion>1.8 M1 (Fowler), 1.6.5 (Dijkstra SR5), 1.7.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.RepositoryWithCompositeKeyTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="652" opendate="2014-12-30 12:11:36" fixdate="2015-02-04 03:48:09" resolution="Fixed">
		<buginformation>
			<summary>Provide support for ParameterMode.REF_CURSOR</summary>
			<description>As described here https://github.com/spring-projects/spring-data-examples/issues/44
I was trying to execute a procedure on spring-data-jpa with hibernate on oracle 11g database.






Procedure






PROCEDURE MY_PROC (




    P_ID IN NUMBER,




    P_PERIOD IN VARCHAR2,




    P_LIMIT IN NUMBER,




    P_CURSOR OUT T_CURSOR);












MyEntity.java






@NamedStoredProcedureQuery(




        name = "myProc",




        procedureName = "MY_PROC",




        resultClasses = ResultEntity.class,




        parameters = {




            @StoredProcedureParameter(mode = ParameterMode.IN, type = Long.class),




            @StoredProcedureParameter(mode = ParameterMode.IN, type = String.class),




            @StoredProcedureParameter(mode = ParameterMode.IN, type = Long.class),




            @StoredProcedureParameter(mode = ParameterMode.REF_CURSOR, type = void.class)












MyRepository.java






@Procedure(name = "myProc", procedureName = "MY_PROC")




    List&amp;lt;ResultEntity&amp;gt; execMyProc(Long userId,String period,Long idClientLimit);












I was able run the procedure programmatically




StoredProcedureQuery query = entityManager.createNamedStoredProcedureQuery("extractWebUser");




query.setParameter(1, userId);




query.setParameter(2, period);




query.setParameter(3, idClientLimit);




query.execute();




List resultList = query.getResultList();






But spring-data uses getOutputParameterValue Method instead of getResultList






Object outputParameterValue = query.getOutputParameterValue(4);






And it makes a lot of problems with hibernate
Hibernate does not support REF_CURSOR: https://github.com/hibernate/hibernate-orm/blob/4.3.7.Final/hibernate-core/src/main/java/org/hibernate/procedure/internal/AbstractParameterRegistrationImpl.java
Finally, I moved to the EclipseLink and it worked perfectly.</description>
			<version>1.6.4 (Dijkstra SR4)</version>
			<fixedVersion>1.8 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.domain.sample.User.java</file>
			<file type="M">org.springframework.data.jpa.support.EntityManagerTestUtils.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.StoredProcedureAttributeSource.java</file>
		</fixedFiles>
	</bug>
	<bug id="656" opendate="2015-01-13 07:28:43" fixdate="2015-02-10 10:06:18" resolution="Fixed">
		<buginformation>
			<summary>Count query with group by returns wrong result</summary>
			<description>The count method of SimpleJpaRepository. 






public long count(Specification&amp;lt;T&amp;gt; spec) {




	return getCountQuery(spec).getSingleResult();




}






Gives a wrong result when using a specification having a group by.
While the method below does this correctly for grouped queries.






protected Page&amp;lt;T&amp;gt; readPage(TypedQuery&amp;lt;T&amp;gt; query, Pageable pageable, Specification&amp;lt;T&amp;gt; spec) {









	query.setFirstResult(pageable.getOffset());




	query.setMaxResults(pageable.getPageSize());









	Long total = QueryUtils.executeCountQuery(getCountQuery(spec));




	List&amp;lt;T&amp;gt; content = total &amp;gt; pageable.getOffset() ? query.getResultList() : Collections.&amp;lt;T&amp;gt; emptyList();









	return new PageImpl&amp;lt;T&amp;gt;(content, pageable, total);




}






</description>
			<version>1.7 GA (Evans)</version>
			<fixedVersion>1.8 RC1 (Fowler), 1.7.3 (Evans SR3), 1.6.6 (Dijkstra SR6)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="681" opendate="2015-02-27 09:42:59" fixdate="2015-02-27 10:15:26" resolution="Fixed">
		<buginformation>
			<summary>Execution of derived stored procedures fails if named parameters are used</summary>
			<description>If a derived stored procedure is used (like here in the Spring Data examples) and named parameters are enabled (e.g., through compiling with -parameters on JDK 8) the execution fails as the output parameter will always be bound by position. This effectively means mixing named and positional parameters which is forbidden by the JPA spec.
We should alter newAdhocStoredProcedureQuery() by using a synthetic output parameter name if named parameters are used.</description>
			<version>1.6.5 (Dijkstra SR5)</version>
			<fixedVersion>1.8 RC1 (Fowler), 1.7.3 (Evans SR3), 1.6.6 (Dijkstra SR6)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.StoredProcedureJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.StoredProcedureAttributeSourceUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.StoredProcedureAttributes.java</file>
		</fixedFiles>
	</bug>
	<bug id="712" opendate="2015-05-03 02:34:55" fixdate="2015-05-19 07:47:01" resolution="Fixed">
		<buginformation>
			<summary>Bug in binding in clause parameters with SPEL</summary>
			<description>





@Entity




public class A {









    private @id @GeneratedValue Long id;




    private String b, c;




}






Repository:






public interface ARepository extends CrudRepository&amp;lt;A, Long&amp;gt; {









    @Query("select a from A a where a.b in :#{#bs} and a.c in :#{#cs}}")




    List&amp;lt;A&amp;gt; findByBinCin(@Param("bs") List&amp;lt;String&amp;gt; bs, @Param("cs") List&amp;lt;String&amp;gt; cs);




}






Gives you the following error when application starts.






Caused by: java.lang.IllegalArgumentException: org.hibernate.QueryException: unexpected char: &amp;amp;apos;#&amp;amp;apos; [select a from org.sf.jpaembeddedsubclasses.model.A a where a.b in :#{#bs} and a.c in :__$synthetic$__2}






I think that there is an issue in StringQuery, lines 250-259 of spring-data-jpa-1.7.2.RELEASE.











case IN:




if (parameterIndex != null) {




	checkAndRegister(new InParameterBinding(parameterIndex, expression), bindings);




} else {




	checkAndRegister(new InParameterBinding(parameterName, expression), bindings);




}




*result = query;*




break;






Line result = query deletes the binding for bs when binding for cs is created.</description>
			<version>1.7.2 (Evans SR2)</version>
			<fixedVersion>1.9 M1 (Gosling), 1.8.1 (Fowler SR1), 1.7.3 (Evans SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.StringQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.StringQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="736" opendate="2015-06-05 03:32:11" fixdate="2015-06-14 03:20:01" resolution="Complete">
		<buginformation>
			<summary>Count query creation fails when entity names contain non-ASCII characters</summary>
			<description>org.springframework.data.jpa.repository.query.QueryUtils.createCountQueryFor(String, String) uses pattern matching to derive the count query. However, this pattern matching does not support the presence of accented letters in entity names.
An example of a query for which the count query computation fails:
select u from Usr u where u.firstname like ?1%
Of course the example is dumb, but in non-English languages entity names might have accents (JPA allows it).</description>
			<version>1.8 GA (Fowler)</version>
			<fixedVersion>1.8.1 (Fowler SR1), 1.7.3 (Evans SR3), 1.6.6 (Dijkstra SR6), 1.9 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="759" opendate="2015-07-10 09:06:13" fixdate="2015-07-10 09:43:05" resolution="Fixed">
		<buginformation>
			<summary>Log names of Class and Mapping Files found during scan to DEBUG level in ClasspathScanningPersistenceUnitPostProcessor</summary>
			<description>This is very minor low-hanging fruit. 
When users troubleshoot Entity Manager classpath scanning, it is helpful to enable DEBUG logging to see what Entity/MappedSuperclass and Mapping Files are found by spring. In fact, this logging was the intention of the current code, however it fails to output the actual resource name that was found, as below:






07/10/2015 11:17:43 DEBUG org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessor (ClasspathScanningPersistenceUnitPostProcessor.java:101) - Registering classpath-scanned entity %s in persistence unit info!




07/10/2015 11:17:43 DEBUG org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessor (ClasspathScanningPersistenceUnitPostProcessor.java:106) - Registering classpath-scanned entity mapping file in persistence unit info!






Since slf4j is being used, the fix is likely just adding the "{}" token instead of "%s".






in: org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessor.postProcessPersistenceUnitInfo(MutablePersistenceUnitInfo)




. . .




LOG.debug("Registering classpath-scanned entity %s in persistence unit info!", definition.getBeanClassName());




. . .




LOG.debug("Registering classpath-scanned entity mapping file in persistence unit info!", location);





</description>
			<version>1.8.1 (Fowler SR1)</version>
			<fixedVersion>1.8.2 (Fowler SR2), 1.9 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="758" opendate="2015-07-10 04:02:26" fixdate="2015-07-15 07:28:09" resolution="Fixed">
		<buginformation>
			<summary>Using Java 8 named parameter prevents positional query parameter binding</summary>
			<description>When I turned on parameter naming in the java 8 compiler all the non named parameters I have no longer work.
In other words, Spring Data JPA insists on using the parameter name...
Simple Example:






    @Query("select r from Role r where ?1 member of r.permissions")




    public List&amp;lt;Role&amp;gt; findByPermission(Permission permission);






Works fine without parameter names added to compiler.
When I turn on the inclusion of parameter names I get this error:
Using named parameters for method public abstract java.util.List com.xxx.RoleRepository.findByPermission(com.xxx.Permission) but parameter &amp;amp;apos;permission&amp;amp;apos; not found in annotated query &amp;amp;apos;select r from AshesRole r where ?1 member of r.permissions&amp;amp;apos;!
And if I now change it to:






    @Query("select r from AshesRole r where :permission member of r.permissions")




    public List&amp;lt;Role&amp;gt; findByPermission(Permission permission);






It works again...
This could be by design - I understand that if it is the case. i.e. when you turn on parameter name inclusion then you must name all your parameters.
A fall back to "non named" would be ideal if scanning with parameter names is not successful but that might be too much overhead.
Though another option would be to allow the user to turn off using named parameters even when available. Developers might require parameter names in classes for some unrelated purpose and turning it on would break all their JPA queries (as they have not used it up to now).
Maybe making it configurable per repository is an alternative...</description>
			<version>1.8.1 (Fowler SR1)</version>
			<fixedVersion>1.8.2 (Fowler SR2), 1.9 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.ParameterMetadataProvider.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryMethodUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryMethod.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">731</link>
		</links>
	</bug>
	<bug id="763" opendate="2015-07-20 00:06:54" fixdate="2015-07-20 10:07:53" resolution="Fixed">
		<buginformation>
			<summary>Executing a Specification with fetch-joins leads to wrong HQL query</summary>
			<description>IS
Calling the mentioned method with a Specification which contains fetches only will lead to an added join clause for the entity used within the sort declaration. This leads to the following exception: 






org.springframework.dao.InvalidDataAccessApiUsageException: org.hibernate.QueryException: query specified join fetching, but the owner of the fetched association was not present in the select list






SHOULD
The mentioned method should not add a join clause to the Root as there is already a suitable fetch join.
HINTS
This behaviour cannot be reproduced in spring-data-jpa Version 1.2.0</description>
			<version>1.8.1 (Fowler SR1)</version>
			<fixedVersion>1.8.2 (Fowler SR2), 1.9 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.EclipseLinkQueryUtilsIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="798" opendate="2015-09-14 06:58:57" fixdate="2015-09-14 14:49:21" resolution="Fixed">
		<buginformation>
			<summary>Repository query method fails when sorting with Pageable and query with line breaks.</summary>
			<description>I have a repository with a custom query (using @Query) that has line breaks in the String specifying the query, for readability in the repository interface and in the log output. Specifically, the problem is that the original query in the @Query annotation is not correctly parsed when there are line breaks between the FROM and the main ENTITY.






@Query(




	"	select m 																	\n"+




	"	from \n Movement as m 														\n"+	// WTF?? If there&amp;amp;apos;s a new line between the FROM and the main entity class alias ("m") SpringData fails to parse the query correctly!!




	"		left join m.toAccount as toAcc												\n"+




	"		left join m.toAccount.owner as toOwn										\n"+




	"	where                                                                           								\n"+




	"		(:login is null or (m.account.owner.login = :login) or (toOwn.login = :login))			\n"+	// The owner of the account transferred from/to




	"		and (:accountId is null or (m.account.id = :accountId) or (toAcc.id = :accountId))		\n"+	// Transfers from/to this account




	"		and (:movTypeKey is null or m.type.key = :movTypeKey)                         			\n"+




	"		and (:movStatusKey is null or m.status.key = :movStatusKey)                   			\n")






I have included an attached .txt file with the details.
</description>
			<version>1.7.3 (Evans SR3)</version>
			<fixedVersion>1.9.1 (Gosling SR1), 1.10 M1 (Hopper), 1.8.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="805" opendate="2015-09-27 15:53:28" fixdate="2015-10-05 10:31:45" resolution="Fixed">
		<buginformation>
			<summary>Typo in @Modifying documentation</summary>
			<description>In @Modifying javadoc there&amp;amp;apos;s a typo in the description of the clearAutomatically attribute.
    clearAutomatically
 public abstract boolean clearAutomatically
    Defines whether we should clear the underlying persistence context after excuting the modifying query.
 Returns:
 Default:
false
</description>
			<version>1.8.2 (Fowler SR2)</version>
			<fixedVersion>1.9.1 (Gosling SR1), 1.10 M1 (Hopper), 1.8.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.Modifying.java</file>
		</fixedFiles>
	</bug>
	<bug id="585" opendate="2014-08-08 04:03:18" fixdate="2015-10-06 05:38:37" resolution="Fixed">
		<buginformation>
			<summary>Incomplete null handling in QueryDslJpaRepository </summary>
			<description>In QueryDslJpaRepository, when findAll(Predicate, Pageable) is called with a null Pageable, a NPE is thrown after the code tries to access the offset. However, delegation to the Querydsl helper class has dealt with the null value properly two lines above. </description>
			<version>1.6.1 (Dijkstra SR1)</version>
			<fixedVersion>1.9.1 (Gosling SR1), 1.10 M1 (Hopper), 1.8.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.QueryDslJpaRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.QueryDslJpaRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="742" opendate="2015-06-17 14:51:38" fixdate="2015-10-20 17:19:14" resolution="Fixed">
		<buginformation>
			<summary>Java 8 Stream support broken</summary>
			<description>When I call a method of a Repository returning a Java 8 Stream, I get the following exception :






org.springframework.beans.NotReadablePropertyException: Invalid property &amp;amp;apos;query&amp;amp;apos; of bean class [com.sun.proxy.$Proxy51]: Bean property &amp;amp;apos;query&amp;amp;apos; is not readable or has an invalid getter method: Does the return type of the getter match the parameter type of the setter?




	at org.springframework.beans.AbstractNestablePropertyAccessor.getPropertyValue(AbstractNestablePropertyAccessor.java:617)




	at org.springframework.beans.AbstractNestablePropertyAccessor.getPropertyValue(AbstractNestablePropertyAccessor.java:608)




	at org.springframework.data.jpa.provider.PersistenceProvider$HibernateScrollableResultsIterator.extractHibernateQueryFromQueryImpl(PersistenceProvider.java:442)




	at org.springframework.data.jpa.provider.PersistenceProvider$HibernateScrollableResultsIterator.extractHibernate4Query(PersistenceProvider.java:425)




	at org.springframework.data.jpa.provider.PersistenceProvider$HibernateScrollableResultsIterator.&amp;lt;init&amp;gt;(PersistenceProvider.java:381)




	at org.springframework.data.jpa.provider.PersistenceProvider$1.executeQueryWithResultStream(PersistenceProvider.java:119)




	at org.springframework.data.jpa.repository.query.JpaQueryExecution$StreamExecution.doExecute(JpaQueryExecution.java:322)




	at org.springframework.data.jpa.repository.query.JpaQueryExecution.execute(JpaQueryExecution.java:77)




	at org.springframework.data.jpa.repository.query.AbstractJpaQuery.doExecute(AbstractJpaQuery.java:100)




	at org.springframework.data.jpa.repository.query.AbstractJpaQuery.execute(AbstractJpaQuery.java:91)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:431)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:409)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:61)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99)




	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281)




	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:136)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor$CrudMethodMetadataPopulatingMethodInterceptor.invoke(CrudMethodMetadataPostProcessor.java:121)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207)




	at com.sun.proxy.$Proxy47.streamAll(Unknown Source)




	at fr.romainmoreau.test.Main.main(Main.java:26)





</description>
			<version>1.8.2 (Fowler SR2)</version>
			<fixedVersion>1.9.1 (Gosling SR1), 1.10 M1 (Hopper), 1.8.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.provider.PersistenceProvider.java</file>
		</fixedFiles>
	</bug>
	<bug id="815" opendate="2015-10-20 21:44:46" fixdate="2015-10-21 09:33:24" resolution="Fixed">
		<buginformation>
			<summary>order by qualifyReference when property begins with joinAlias</summary>
			<description>When a property begins with a joinAlias, the order by clause incorrectly assigns the qualifyReference boolean.
The following query shows the problem.  It assumes Cat.created and Dog.created exist, and a Sort column of "created".
from Cat c join Dog d
Because both tables have "created" as a column name and the property "created" begins with a joinAlias "c", the qualifyReference is set to false, resulting in "order by created" instead of "order by c.created".  This results in "column reference created is ambiguous".
I have attached a patch that resolves the issue.
</description>
			<version>1.8.2 (Fowler SR2)</version>
			<fixedVersion>1.9.1 (Gosling SR1), 1.10 M1 (Hopper), 1.8.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="820" opendate="2015-11-05 22:46:47" fixdate="2015-11-06 10:44:09" resolution="Fixed">
		<buginformation>
			<summary>New entity merged rather than persisted when ID is not generated and version is in a MappedSuperClass </summary>
			<description>Effect of bug is that SimpleJpaRepository::save(...) uses em.merge on a brand new entity, causing both  @PostPersist and @PostUpdate callbacks to be invoked.
Requirements to hit the bug:

An Entity class that has a provided identity (i.e. no id generation), so the ID field is non-null at the very start.







public class User extends AbstractEntity {




  @Id()




  @Column(nullable = false, length = 64, unique = true)




  private String phone;




  ...




}







A MappedSuperclass that contains the version field:






@MappedSuperclass




public abstract class AbstractEntity implements Serializable {









  @Version




  private Long version;




  ...




}







=&amp;gt; With this, we will get two callbacks.
=&amp;gt; Moving the version field from the abstract class to every concrete class causes the expected behaviour to occur.
</description>
			<version>1.9 GA (Gosling)</version>
			<fixedVersion>1.9.1 (Gosling SR1), 1.10 M1 (Hopper), 1.8.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.JpaPersistableEntityInformationUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.OpenJpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.EclipseLinkJpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.AbstractMappedType.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformationUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="830" opendate="2015-12-02 06:38:37" fixdate="2015-12-02 06:53:39" resolution="Fixed">
		<buginformation>
			<summary>NotContaining doesn&amp;apos;t work for String properties on query methods</summary>
			<description></description>
			<version>1.8.2 (Fowler SR2)</version>
			<fixedVersion>1.9.2 (Gosling SR2), 1.10 M1 (Hopper), 1.8.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryFinderTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.ParameterMetadataProvider.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryCreator.java</file>
		</fixedFiles>
	</bug>
	<bug id="848" opendate="2016-01-15 04:03:08" fixdate="2016-01-15 13:49:12" resolution="Fixed">
		<buginformation>
			<summary>AbstractPersistable.equals() always returns false if target entity is a proxy</summary>
			<description>I found a problem with org.springframework.data.jpa.domain.AbstractPersistable class equals method implementation.
It always return false if target entity for comparison is javassist proxy which hibernate returns for example if you do entityRepository.getOne(123) instead of findOne.
The problem is with line






if (!getClass().equals(obj.getClass())) {






The obj.getClass returns something like Employee_$$_jvst860_de while this already deproxyfied and has class Employee. So this two classes of course not equal.
I think we can do instead this:






if (!getClass().isInstance(obj)) {






Or this:






Class&amp;lt;?&amp;gt; otherClass = HibernateProxyHelper.getClassWithoutInitializingProxy(obj);




if (!getClass().equals(otherClass)) {






The second variant is more "right" because it excludes subclasses but using HibernateProxyHelper in AbstractPersistable is bad idea I think.
The first variant works but can&amp;amp;apos;t guarantee that obj is same class as this and not subclass (other than proxy). But I think even this is better then just return false for the same entity.
Simple code to reproduce this bug:






Employee e1 = employeeRepository.getOne(15);




Employee e2 = employeeRepository.getOne(15);




System.out.println(e1.getClass()); // Employee_$$_jvst860_de




System.out.println(e2.getClass()); // Employee_$$_jvst860_de




// The classes equal here but inside e1.equals method e1&amp;amp;apos;s &amp;amp;apos;this&amp;amp;apos; has class Employee (not proxy)




System.out.println(e1.equals(e2)); // false










</description>
			<version>1.9.2 (Gosling SR2)</version>
			<fixedVersion>1.10 M1 (Hopper), 1.9.4 (Gosling SR4), 1.8.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.sample.CustomAbstractPersistableRepository.java</file>
			<file type="M">org.springframework.data.jpa.domain.AbstractPersistable.java</file>
			<file type="M">org.springframework.data.jpa.repository.AbstractPersistableIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="858" opendate="2016-02-10 17:16:09" fixdate="2016-02-10 17:25:54" resolution="Fixed">
		<buginformation>
			<summary>Contains binding inspects first property for collections, not the leaf property</summary>
			<description>





class User {




  Set&amp;lt;Role&amp;gt; roles;




}









class Role {




  String name;




}






A query findByRolesNameContaining() will fail as it tries to trigger collection contains binding as it&amp;amp;apos;s inspecting the first traversal (the one to roles). It has to inspect the leaf property instead and only trigger that special binding if the leaf property is a collection.</description>
			<version>1.9.2 (Gosling SR2)</version>
			<fixedVersion>1.10 M1 (Hopper), 1.9.4 (Gosling SR4), 1.8.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryCreator.java</file>
		</fixedFiles>
	</bug>
	<bug id="813" opendate="2015-10-14 12:23:01" fixdate="2016-02-26 19:12:02" resolution="Fixed">
		<buginformation>
			<summary>Error creating DefaultJpaContext bean in test cases</summary>
			<description>After upgrading from commons:1.10.2 and jpa:1.8.2 to the Gosling combo (1.11, 1.9.) I get the following exception in my unit tests:






org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &amp;amp;apos;jpaContext&amp;amp;apos;: Unsatisfied dependency expressed through constructor argument with index 0 of type [java.util.Set]: : No qualifying bean of type [javax.persistence.EntityManager] found for dependency [collection of javax.persistence.EntityManager]: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {}; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [javax.persistence.EntityManager] found for dependency [collection of javax.persistence.EntityManager]: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {}




	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:749)




	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:185)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1143)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1046)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:510)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:305)




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:301)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:196)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:772)




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:834)




	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:537)




	at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:125)




	at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:60)




	at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.delegateLoading(AbstractDelegatingSmartContextLoader.java:109)




	at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.loadContext(AbstractDelegatingSmartContextLoader.java:261)




	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:98)




	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:116)




	at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:83)




	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.injectDependencies(DependencyInjectionTestExecutionListener.java:117)




	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.prepareTestInstance(DependencyInjectionTestExecutionListener.java:83)




	at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:228)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:217)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:276)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:278)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:236)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:87)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)




	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)




	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:180)




	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:283)




	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:173)




	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:153)




	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:128)




	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:203)




	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:155)




	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:103)




Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [javax.persistence.EntityManager] found for dependency [collection of javax.persistence.EntityManager]: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {}




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoSuchBeanDefinitionException(DefaultListableBeanFactory.java:1326)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1024)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:967)




	at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:813)




	at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:741)




	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:185)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1143)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1046)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:510)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:305)




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:301)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:196)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:772)




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:834)




	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:537)




	at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:125)




	at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:60)




	at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.delegateLoading(AbstractDelegatingSmartContextLoader.java:109)




	at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.loadContext(AbstractDelegatingSmartContextLoader.java:261)




	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:98)




	at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:116)




	at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:83)




	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.injectDependencies(DependencyInjectionTestExecutionListener.java:117)




	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.prepareTestInstance(DependencyInjectionTestExecutionListener.java:83)




	at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:228)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:217)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:276)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:278)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:236)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:87)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)




	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)




	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:180)




	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:283)




	at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:173)




	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:153)




	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:128)




	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:203)




	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:155)




	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:103)






The exception really confuses me because there is an EntityManager available in the context (at least before Gosling). I confirmed this one more time by adding the following code to the unit test class and then check for not-null in the test:






@PersistenceContext




private EntityManager entityManager;






Any ideas how to tackle this?</description>
			<version>1.9 GA (Gosling)</version>
			<fixedVersion>1.10 RC1 (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.DefaultJpaContextIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.util.BeanDefinitionUtils.java</file>
			<file type="M">org.springframework.data.jpa.repository.config.JpaRepositoryConfigExtensionUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">821</link>
			<link type="Relate" description="relates to">13986</link>
		</links>
	</bug>
	<bug id="885" opendate="2016-04-07 19:34:50" fixdate="2016-04-09 14:58:35" resolution="Fixed">
		<buginformation>
			<summary>No aliases found in result tuple</summary>
			<description>After migrating Spring Data application from Gosling-SR4 to Hopper-SR1 release, all custom queries that extends JpaRepository throws the following message:






Caused by: java.lang.IllegalStateException: No aliases found in result tuple! Make sure your query defines aliases!




    at org.springframework.data.jpa.repository.query.AbstractJpaQuery$TupleConverter.convert(AbstractJpaQuery.java:246) [spring-data-jpa-1.10.1.RELEASE.jar:]




    at org.springframework.data.repository.query.ResultProcessor$ChainingConverter.convert(ResultProcessor.java:185) [spring-data-commons-1.12.1.RELEASE.jar:]




    at org.springframework.data.repository.query.ResultProcessor$ChainingConverter$1.convert(ResultProcessor.java:173) [spring-data-commons-1.12.1.RELEASE.jar:]




    at org.springframework.data.repository.query.ResultProcessor$ChainingConverter.convert(ResultProcessor.java:185) [spring-data-commons-1.12.1.RELEASE.jar:]




    at org.springframework.data.repository.query.ResultProcessor.processResult(ResultProcessor.java:142) [spring-data-commons-1.12.1.RELEASE.jar:]




    at org.springframework.data.jpa.repository.query.AbstractJpaQuery.doExecute(AbstractJpaQuery.java:107) [spring-data-jpa-1.10.1.RELEASE.jar:]




    at org.springframework.data.jpa.repository.query.AbstractJpaQuery.execute(AbstractJpaQuery.java:92) [spring-data-jpa-1.10.1.RELEASE.jar:]




    at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:482) [spring-data-commons-1.12.1.RELEASE.jar:]




    at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:460) [spring-data-commons-1.12.1.RELEASE.jar:]




    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) [spring-aop-4.2.5.RELEASE.jar:4.2.5.RELEASE]




    at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99) [spring-tx-4.2.5.RELEASE.jar:4.2.5.RELEASE]




    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281) [spring-tx-4.2.5.RELEASE.jar:4.2.5.RELEASE]




    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96) [spring-tx-4.2.5.RELEASE.jar:4.2.5.RELEASE]




    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) [spring-aop-4.2.5.RELEASE.jar:4.2.5.RELEASE]




    at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:136) [spring-tx-4.2.5.RELEASE.jar:4.2.5.RELEASE]




    ... 113 more












public interface UserProfileAccessGroupRepository extends




        JpaRepository&amp;lt;UserProfileAccessGroup, UserProfileAccessGroupPK&amp;gt; {









    @Modifying




    @Query("DELETE FROM UserProfileAccessGroup upag WHERE upag.id.accessGroup = ?1")




    public void deleteByAccessGroup(AccessGroup accessGroup);









    @Modifying




    @Query("DELETE FROM UserProfileAccessGroup upag WHERE upag.id.userProfile = ?1")




    public void deleteByUserProfile(UserProfile userProfile);









    @Query("SELECT upag.id.accessGroup FROM UserProfileAccessGroup upag WHERE upag.id.userProfile = ?1")




    public List&amp;lt;AccessGroup&amp;gt; findAccessGroupByUserProfile(UserProfile userProfile);









    @Query("SELECT upag.id.accessGroup FROM UserProfileAccessGroup upag WHERE upag.id.userProfile = ?1 AND upag.id.accessGroup.functionality = false")




    public List&amp;lt;AccessGroup&amp;gt; findGroupByUserProfile(UserProfile userProfile);









    public List&amp;lt;UserProfileAccessGroup&amp;gt; findByExpirationDateBefore(Date date);




}












@Entity




public class UserProfileAccessGroup implements Serializable {









    private static final long serialVersionUID = 1L;









    @EmbeddedId




    private UserProfileAccessGroupPK id;









    private Date expirationDate;









    @ManyToOne




    @JoinColumn(name = "authorizedBy")




    private UserProfile authorizedBy;









    public UserProfileAccessGroupPK getId() {









        if (id == null) {




            id = new UserProfileAccessGroupPK();




        }




        return id;




    }









    public void setId(UserProfileAccessGroupPK id) {




        this.id = id;




    }









    public Date getExpirationDate() {




        return expirationDate;




    }









    public void setExpirationDate(Date expirationDate) {




        this.expirationDate = expirationDate;




    }









    public UserProfile getAuthorizedBy() {




        return authorizedBy;




    }









    public void setAuthorizedBy(UserProfile authorizedBy) {




        this.authorizedBy = authorizedBy;




    }









    @Embeddable




    public static class UserProfileAccessGroupPK implements Serializable {









        private static final long serialVersionUID = 1L;









        @ManyToOne




        @JoinColumn(name = "accessGroupId")




        private AccessGroup accessGroup;









        @ManyToOne




        @JoinColumn(name = "userProfileId")




        private UserProfile userProfile;









        public UserProfileAccessGroupPK() {




        }









        public UserProfileAccessGroupPK(AccessGroup accessGroup, UserProfile userProfile) {




            this.accessGroup = accessGroup;




            this.userProfile = userProfile;




        }









        public AccessGroup getAccessGroup() {




            return accessGroup;




        }









        public void setAccessGroup(AccessGroup accessGroup) {




            this.accessGroup = accessGroup;




        }









        public UserProfile getUserProfile() {




            return userProfile;




        }









        public void setUserProfile(UserProfile userProfile) {




            this.userProfile = userProfile;




        }









        @Override




        public int hashCode() {




            final int prime = 31;




            int result = 1;




            result = prime * result + ((accessGroup == null) ? 0 : accessGroup.hashCode());




            result = prime * result + ((userProfile == null) ? 0 : userProfile.hashCode());




            return result;




        }









        @Override




        public boolean equals(Object obj) {




            if (this == obj)




                return true;




            if (obj == null)




                return false;




            if (getClass() != obj.getClass())




                return false;




            UserProfileAccessGroupPK other = (UserProfileAccessGroupPK) obj;




            if (accessGroup == null) {




                if (other.accessGroup != null)




                    return false;




            } else if (!accessGroup.equals(other.accessGroup))




                return false;




            if (userProfile == null) {




                if (other.userProfile != null)




                    return false;




            } else if (!userProfile.equals(other.userProfile))




                return false;




            return true;




        }




    }




}





</description>
			<version>1.10.1 (Hopper SR1)</version>
			<fixedVersion>1.10.2 (Hopper SR2), 1.11 M1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.StringQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.AbstractStringBasedJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.PartTreeJpaQueryIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.StringQueryUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">913</link>
			<link type="Relate" description="relates to">984</link>
			<link type="Relate" description="relates to">862</link>
			<link type="Relate" description="relates to">841</link>
		</links>
	</bug>
	<bug id="903" opendate="2016-05-24 19:55:25" fixdate="2016-05-25 14:09:35" resolution="Fixed">
		<buginformation>
			<summary>Stream&lt;Object[]&gt; missing result attributes on Hibernate</summary>
			<description>Having 






 




    @Query("select 1,2,3,4 from Offer")




    Stream&amp;lt;Object[]&amp;gt; streamQuery();









    @Query("select 1,2,3,4 from Offer")




    List&amp;lt;Object[]&amp;gt; listQuery();












    @Test




    public void listVsStreamQuery() throws Exception {




        List&amp;lt;Object[]&amp;gt; res1 = testRepo.listQuery();




        List&amp;lt;Object[]&amp;gt; res2 = testRepo.streamQuery().collect(Collectors.toList());









        assertEquals(res1, res2);




    }






ER. The above test passes. 
AR. The above test fails. res1 contains [[1,2,3,4]], res2 contains [1] (only first argument). 
Is this a known limitation of streaming approach?
Hibernate is the ORM provider. Using springBoot 1.3.3.RELEASE.</description>
			<version>1.9.4 (Gosling SR4)</version>
			<fixedVersion>1.10.2 (Hopper SR2), 1.11 M1 (Ingalls), 1.9.5 (Gosling SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.provider.PersistenceProvider.java</file>
		</fixedFiles>
	</bug>
	<bug id="909" opendate="2016-06-01 20:13:49" fixdate="2016-06-02 12:08:14" resolution="Fixed">
		<buginformation>
			<summary>Count query breaks if pagination is used with projections</summary>
			<description>The functionality described in the stack overflow below (requiring the use of the AS keyword for projection support) doesn&amp;amp;apos;t seem to be documented. I think it would be very helpful to have at least a mention of this included in the main documentation
http://stackoverflow.com/questions/36701358/using-projections-with-pageable-in-spring-data/37317529#37317529</description>
			<version>1.10.1 (Hopper SR1)</version>
			<fixedVersion>1.10.2 (Hopper SR2), 1.11 M1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.JpaCountQueryCreator.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryCreator.java</file>
		</fixedFiles>
	</bug>
	<bug id="904" opendate="2016-05-26 15:47:55" fixdate="2016-06-08 08:23:34" resolution="Fixed">
		<buginformation>
			<summary>Potential NullPointerException in JpaPersistentPropertyImpl.isEntity()</summary>
			<description>Hi,
I&amp;amp;apos;m using Hibernate to map the tables of our database and some of them are audited with Envers (@Audited on the entity class). To solve the same problem that is described in DATAJPA-885, I switched to the latest snapshot (1.11.0).
I&amp;amp;apos;m now getting a NullPointerException at the start of the application on the table_AUD classes generated by Hibernate. The NPE is because the javaType of the _AUD EmbeddableTypeImpl object is null.






org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;jpaMappingContext&amp;amp;apos;: Invocation of init method failed; nested exception is java.lang.NullPointerException




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1578)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:545)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:753)




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:839)




	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:538)




	at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:139)




	at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:83)




	at sgcib.ged.bcs.spring.SpringLauncher.launch(SpringLauncher.java:57)




	at sgcib.ged.bcs.spring.SpringLauncher.launch(SpringLauncher.java:38)




	at sgcib.ged.bcs.spring.SpringLauncher.launch(SpringLauncher.java:26)




	at sgcib.ged.bcs.reflex.server.ReflexServer.main(ReflexServer.java:13)




Caused by: java.lang.NullPointerException




	at org.springframework.data.jpa.mapping.JpaPersistentPropertyImpl.isEntity(JpaPersistentPropertyImpl.java:161)




	at org.springframework.data.mapping.model.AbstractPersistentProperty.getPersistentEntityType(AbstractPersistentProperty.java:129)




	at org.springframework.data.jpa.mapping.JpaPersistentPropertyImpl.getPersistentEntityType(JpaPersistentPropertyImpl.java:133)




	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:488)




	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:446)




	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:689)




	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:314)




	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:276)




	at org.springframework.data.mapping.context.AbstractMappingContext.initialize(AbstractMappingContext.java:392)




	at org.springframework.data.jpa.repository.config.JpaMetamodelMappingContextFactoryBean.createInstance(JpaMetamodelMappingContextFactoryBean.java:73)




	at org.springframework.data.jpa.repository.config.JpaMetamodelMappingContextFactoryBean.createInstance(JpaMetamodelMappingContextFactoryBean.java:26)




	at org.springframework.beans.factory.config.AbstractFactoryBean.afterPropertiesSet(AbstractFactoryBean.java:134)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1637)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1574)




	... 15 more






How do I solve this problem? Is this a problem in Hibernate?</description>
			<version>1.9.4 (Gosling SR4)</version>
			<fixedVersion>1.10.2 (Hopper SR2), 1.11 M1 (Ingalls), 1.9.5 (Gosling SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.mapping.JpaPersistentPropertyImpl.java</file>
			<file type="M">org.springframework.data.jpa.mapping.JpaPersistentPropertyImplUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">929</link>
		</links>
	</bug>
	<bug id="913" opendate="2016-06-18 14:47:28" fixdate="2016-06-19 06:52:38" resolution="Duplicate">
		<buginformation>
			<summary>Inconsistent behavior with projections when using @NamedQuery vs @Query</summary>
			<description>Queries are interpreted differently when using @NamedQuery and @Query in regard of projections. Having the following as a named query:






@NamedQueries({    




    @NamedQuery(




	    name = "FoobarEntity.getDateOfFirstRecord1",




	    query




	    = "Select coalesce(min(m.recordedOn), current_date()) as dateOfFirstRecord1 from FoobarEntity m"




    )




})






and a repository method






public interface FoobarRepository extends JpaRepository&amp;lt;FoobarEntity, Integer&amp;gt; {




    Calendar getDateOfFirstRecord1();




}






I get the expected date. If I however put the same query directly on the method like:






    @Query("Select coalesce(min(m.recordedOn), current_date()) as dateOfFirstRecord2 from FoobarEntity m")




    Calendar getDateOfFirstRecord2();






I end up with






org.springframework.dao.InvalidDataAccessApiUsageException: Projection type must be an interface!; nested exception is java.lang.IllegalArgumentException: Projection type must be an interface!






That used to work in 1.9.5. Attached is a small demo.</description>
			<version>1.10.1 (Hopper SR1)</version>
			<fixedVersion>1.10.2 (Hopper SR2)</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.StringQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.AbstractStringBasedJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.PartTreeJpaQueryIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.StringQueryUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">885</link>
		</links>
	</bug>
	<bug id="413" opendate="2013-10-10 08:12:13" fixdate="2016-07-20 11:39:53" resolution="Fixed">
		<buginformation>
			<summary>Nested Id classes fail to populate in JpaMetamodelEntityInformation</summary>
			<description>I have 2 JPA entities that have compound keys, and so both are using the @IdClass object to store the compound primary key.
The first entity and id class uses two integers as the compound key.






 




@Entity




@IdClass(ItemId.class)




public class Item {




	




	@Id




	@Column(columnDefinition = "INT")




	private Integer id;









	@Id




	@Column(name = "sales_device_id", columnDefinition = "INT")




	private Integer salesDeviceId;









	....




}














public class ItemId implements Serializable {




	




	public Integer id;




	




	public Integer salesDeviceId;









	....




}






The second entity and id class uses three integers as the compound key, however I am using entities as the @Id values.  Two of the primary key columns are part of the Item entity, and the third column belongs to the Site entity.






 




@Entity




@IdClass(ItemSiteId.class)




public class ItemSite {




	




	@Id




	@ManyToOne




	private Item item;




	




	@Id




	@ManyToOne




	private Site site;









	....




}






For this case the Id class for ItemSite must use the Id class from Item as described in the OpenJPA documentation in example 5.6 http://openjpa.apache.org/builds/2.2.2/apache-openjpa/docs/ref_guide_pc_oid.htmll 






 




public class ItemSiteId implements Serializable {




	




	public ItemId item;




	




	public Integer site;









	....




}






Using these nested Id classes, spring data throws an exception of type conversion failure from the JpaMetamodelEntityInformation class.  After downloading version 1.4.1 source, I applied a rewrite of the IdentifierDerivingDirectFieldAccessFallbackBeanWrapper method setPropertyValue (around line 323 in JpaMetamodelEntityInformation) and it resolves the exception.  
Here is my change:






 




@Override




public void setPropertyValue(String propertyName, Object value) {









	if (isIdentifierDerivationNecessary(value)) {









		// Derive the identifer from the nested entity that is part of the composite key.




		@SuppressWarnings({ "rawtypes", "unchecked" })




		JpaMetamodelEntityInformation nestedEntityInformation = new JpaMetamodelEntityInformation(value.getClass(),




				this.metamodel);




		




		super.setPropertyValue(propertyName, nestedEntityInformation.getId(value));




		return;




	}









	super.setPropertyValue(propertyName, value);




}





 </description>
			<version>1.4.1</version>
			<fixedVersion>1.11 M1 (Ingalls), 1.9.5 (Gosling SR5), 1.10.3 (Hopper SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.domain.sample.ItemSite.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.Item.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformationIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="937" opendate="2016-07-27 08:56:30" fixdate="2016-07-27 10:04:58" resolution="Fixed">
		<buginformation>
			<summary>Broken placeholder in exception message to be created in QueryByExamplePredicateBuilder.getPredicate()</summary>
			<description>Hi,
the class QueryByExamplePredicateBuilder has a bug in the getPredicates-Method. If it tries to throw a JpaSystemException the string formattier throws an UnknownFormatConversionException because of the missing "s" after the second "%" in the formatting template.






String.format("Unexpected path type for %s. Found % where From.class was expected.", currentPath, from)));






best regards,
Raphael</description>
			<version>1.10.2 (Hopper SR2)</version>
			<fixedVersion>1.11 M1 (Ingalls), 1.10.3 (Hopper SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.convert.QueryByExamplePredicateBuilderUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.convert.QueryByExamplePredicateBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="929" opendate="2016-07-18 13:19:45" fixdate="2016-08-03 16:41:10" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException in AbstractStringBasedJpaQuery.isJpaManaged()</summary>
			<description>Hi,
I&amp;amp;apos;m using SpringData JPA Hopper-SR1 and I want to upgrade to Hopper-SR2 but I&amp;amp;apos;m facing NullPointer exception in AbstractStringBasedJpaQuery.isJpaManaged() which in newly introduced in Hopper-SR2 (with Hopper-SR1 everything works fine)
I&amp;amp;apos;m using Envers 
I have entity DonwloadItem which has correspoding table "download_item"






@Entity




@Table(name = "download_item")




public class DownloadItem extends BaseVersionEntity {









    @Audited




    @NotNull




    @Size(max = DOWNLOAD_ITEM_NAME_LENGTH)




    @Column(nullable=false)




    private String name;









    ....




}






but in db there is also envers auditing table "download_item_AUD" which doesn&amp;amp;apos;t have corresponding Java Type and thats the problem
In method isJpaManaged() is called managedType.getJavaType() that returns null for ManagedType that contains DownloadItem_aud entity
Stacktrace:






java.lang.NullPointerException: null




	at org.springframework.data.jpa.repository.query.AbstractStringBasedJpaQuery.isJpaManaged(AbstractStringBasedJpaQuery.java:155) ~[spring-data-jpa-1.10.2.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.AbstractStringBasedJpaQuery.createJpaQuery(AbstractStringBasedJpaQuery.java:141) ~[spring-data-jpa-1.10.2.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.AbstractStringBasedJpaQuery.doCreateQuery(AbstractStringBasedJpaQuery.java:80) ~[spring-data-jpa-1.10.2.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.AbstractJpaQuery.createQuery(AbstractJpaQuery.java:176) ~[spring-data-jpa-1.10.2.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.JpaQueryExecution$CollectionExecution.doExecute(JpaQueryExecution.java:114) ~[spring-data-jpa-1.10.2.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.JpaQueryExecution.execute(JpaQueryExecution.java:78) ~[spring-data-jpa-1.10.2.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.AbstractJpaQuery.doExecute(AbstractJpaQuery.java:102) ~[spring-data-jpa-1.10.2.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.AbstractJpaQuery.execute(AbstractJpaQuery.java:92) ~[spring-data-jpa-1.10.2.RELEASE.jar:na]




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:482) ~[spring-data-commons-1.12.2.RELEASE.jar:na]




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:460) ~[spring-data-commons-1.12.2.RELEASE.jar:na]




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) ~[spring-aop-4.2.7.RELEASE.jar:4.2.7.RELEASE]




	at org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:61) ~[spring-data-commons-1.12.2.RELEASE.jar:na]




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) ~[spring-aop-4.2.7.RELEASE.jar:4.2.7.RELEASE]




	at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99) ~[spring-tx-4.2.7.RELEASE.jar:4.2.7.RELEASE]




	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281) ~[spring-tx-4.2.7.RELEASE.jar:4.2.7.RELEASE]




	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96) ~[spring-tx-4.2.7.RELEASE.jar:4.2.7.RELEASE]




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) ~[spring-aop-4.2.7.RELEASE.jar:4.2.7.RELEASE]




	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:136) ~[spring-tx-4.2.7.RELEASE.jar:4.2.7.RELEASE]




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) ~[spring-aop-4.2.7.RELEASE.jar:4.2.7.RELEASE]




	at org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor$CrudMethodMetadataPopulatingMethodInterceptor.invoke(CrudMethodMetadataPostProcessor.java:133) ~[spring-data-jpa-1.10.2.RELEASE.jar:na]




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) ~[spring-aop-4.2.7.RELEASE.jar:4.2.7.RELEASE]




	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92) ~[spring-aop-4.2.7.RELEASE.jar:4.2.7.RELEASE]




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) ~[spring-aop-4.2.7.RELEASE.jar:4.2.7.RELEASE]




	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:208) ~[spring-aop-4.2.7.RELEASE.jar:4.2.7.RELEASE]




....





</description>
			<version>1.10.2 (Hopper SR2)</version>
			<fixedVersion>1.11 M1 (Ingalls), 1.10.3 (Hopper SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.CrudMethodMetadataUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.mapping.JpaPersistentPropertyImpl.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.SimpleJpaQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.JpaRepositoryFactoryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.NamedQueryUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryLookupStrategyUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.AbstractStringBasedJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.AbstractJpaQuery.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">904</link>
		</links>
	</bug>
	<bug id="951" opendate="2016-08-12 12:09:56" fixdate="2016-08-17 14:43:36" resolution="Fixed">
		<buginformation>
			<summary>Projections not handled correctly when Optional is used as wrapping return type</summary>
			<description>When using Optional return type and JPQL projection to create an object (not an Entity type)
The following exception is thrown:






org.springframework.core.convert.ConverterNotFoundException: No converter found capable of converting from type [java.util.Optional&amp;lt;?&amp;gt;] to type [com.cookies.domain.dto.AuthenticationPrincipal]






An exaple repository is:






@Repository




public interface UserPrincipalRepository extends CrudRepository&amp;lt;UserAccountPair, String&amp;gt; {




 




    @Query(value = "SELECT " +




            "new xxx.AuthenticationPrincipal(u.id, u.email, u.password, u.enabled) " +




            "FROM ApiUser u "




            + "WHERE LOWER(u.email) = LOWER(?1)")




    Optional&amp;lt;AuthenticationPrincipal&amp;gt; findUserForAuthentication(String string);




}






In previous versions this was working as expected.</description>
			<version>1.10.2 (Hopper SR2)</version>
			<fixedVersion>1.10.3 (Hopper SR3), 1.11 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryExecutionUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryExecution.java</file>
		</fixedFiles>
	</bug>
	<bug id="938" opendate="2016-07-27 11:12:24" fixdate="2016-08-29 12:26:27" resolution="Fixed">
		<buginformation>
			<summary>Complex select clauses in manually declared query using constructor expressions fail</summary>
			<description>If repository contains HQL query with "SELECT new" statement Spring Data Jpa fails with exception. 
I got this behaviour after I updated version from 1.9.1.RELEASE to 1.10.2.RELEASE.
I reproduced this behaviour on 1.10.1.RELEASE version.
Example of repository method:






@Query("select new com.Dto( o.field1, o.field2, o.field3) from Order o")




List&amp;lt;Dto&amp;gt; findOrders();






Exception:






java.lang.IllegalArgumentException: org.hibernate.QueryException: ResultTransformer is not allowed for &amp;amp;apos;select new&amp;amp;apos; queries.




	at org.hibernate.jpa.spi.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1679) ~[hibernate-entitymanager-5.0.2.Final.jar:5.0.2.Final]




	at org.hibernate.jpa.spi.AbstractEntityManagerImpl.convert(AbstractEntityManagerImpl.java:1602) ~[hibernate-entitymanager-5.0.2.Final.jar:5.0.2.Final]




	at org.hibernate.jpa.internal.QueryImpl.getResultList(QueryImpl.java:445) ~[hibernate-entitymanager-5.0.2.Final.jar:5.0.2.Final]




	at org.springframework.data.jpa.repository.query.JpaQueryExecution$CollectionExecution.doExecute(JpaQueryExecution.java:114) ~[spring-data-jpa-1.10.1.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.JpaQueryExecution.execute(JpaQueryExecution.java:78) ~[spring-data-jpa-1.10.1.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.AbstractJpaQuery.doExecute(AbstractJpaQuery.java:102) ~[spring-data-jpa-1.10.1.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.AbstractJpaQuery.execute(AbstractJpaQuery.java:92) ~[spring-data-jpa-1.10.1.RELEASE.jar:na]




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:482) ~[spring-data-commons-1.12.2.RELEASE.jar:na]




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:460) ~[spring-data-commons-1.12.2.RELEASE.jar:na]




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) ~[spring-aop-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:61) ~[spring-data-commons-1.12.2.RELEASE.jar:na]




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) ~[spring-aop-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99) ~[spring-tx-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281) ~[spring-tx-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96) ~[spring-tx-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) ~[spring-aop-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:136) ~[spring-tx-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) ~[spring-aop-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor$CrudMethodMetadataPopulatingMethodInterceptor.invoke(CrudMethodMetadataPostProcessor.java:133) ~[spring-data-jpa-1.10.1.RELEASE.jar:na]




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) ~[spring-aop-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92) ~[spring-aop-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) ~[spring-aop-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:208) ~[spring-aop-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at com.sun.proxy.$Proxy498.findPromoDealOfferings(Unknown Source) ~[na:na]




	at com.frontier.service.deal.DealOfferingService.getForPromoDeal(DealOfferingService.java:707) ~[deal-service-1.0.37-SNAPSHOT.jar:na]




	at com.frontier.service.deal.DealOfferingService.find(DealOfferingService.java:644) ~[deal-service-1.0.37-SNAPSHOT.jar:na]




	at com.frontier.service.deal.DealOfferingService$$FastClassBySpringCGLIB$$68ebdfce.invoke(&amp;lt;generated&amp;gt;) ~[deal-service-1.0.37-SNAPSHOT.jar:na]




	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) ~[spring-core-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:718) ~[spring-aop-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157) ~[spring-aop-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99) ~[spring-tx-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281) ~[spring-tx-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96) ~[spring-tx-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) ~[spring-aop-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:654) ~[spring-aop-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at com.frontier.service.deal.DealOfferingService$$EnhancerBySpringCGLIB$$b99e020e.find(&amp;lt;generated&amp;gt;) ~[deal-service-1.0.37-SNAPSHOT.jar:na]




	at com.frontier.controller.deal.DealOfferingController.find(DealOfferingController.java:27) ~[deal-service-1.0.37-SNAPSHOT.jar:na]




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_91]




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_91]




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_91]




	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_91]




	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:222) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:137) ~[spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110) ~[spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:814) ~[spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:737) ~[spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) ~[spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:959) ~[spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:893) ~[spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) [spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) [spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:620) [servlet-api.jar:na]




	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) [spring-webmvc-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:727) [servlet-api.jar:na]




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303) [catalina.jar:7.0.54]




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) [catalina.jar:7.0.54]




	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:121) [spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) [spring-web-4.2.3.RELEASE.jar:4.2.3.RELEASE]




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) [catalina.jar:7.0.54]




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) [catalina.jar:7.0.54]




	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) [tomcat7-websocket.jar:7.0.54]




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) [catalina.jar:7.0.54]




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) [catalina.jar:7.0.54]




	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:220) [catalina.jar:7.0.54]




	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:122) [catalina.jar:7.0.54]




	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:501) [catalina.jar:7.0.54]




	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171) [catalina.jar:7.0.54]




	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102) [catalina.jar:7.0.54]




	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:950) [catalina.jar:7.0.54]




	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116) [catalina.jar:7.0.54]




	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:408) [catalina.jar:7.0.54]




	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1040) [tomcat-coyote.jar:7.0.54]




	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:607) [tomcat-coyote.jar:7.0.54]




	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:316) [tomcat-coyote.jar:7.0.54]




	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_91]




	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_91]




	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-coyote.jar:7.0.54]




	at java.lang.Thread.run(Thread.java:745) [na:1.8.0_91]




Caused by: org.hibernate.QueryException: ResultTransformer is not allowed for &amp;amp;apos;select new&amp;amp;apos; queries.




	at org.hibernate.loader.hql.QueryLoader.checkQuery(QueryLoader.java:506) ~[hibernate-core-5.0.2.Final.jar:5.0.2.Final]




	at org.hibernate.loader.hql.QueryLoader.list(QueryLoader.java:500) ~[hibernate-core-5.0.2.Final.jar:5.0.2.Final]




	at org.hibernate.hql.internal.ast.QueryTranslatorImpl.list(QueryTranslatorImpl.java:371) ~[hibernate-core-5.0.2.Final.jar:5.0.2.Final]




	at org.hibernate.engine.query.spi.HQLQueryPlan.performList(HQLQueryPlan.java:220) ~[hibernate-core-5.0.2.Final.jar:5.0.2.Final]




	at org.hibernate.internal.SessionImpl.list(SessionImpl.java:1268) ~[hibernate-core-5.0.2.Final.jar:5.0.2.Final]




	at org.hibernate.internal.QueryImpl.list(QueryImpl.java:87) ~[hibernate-core-5.0.2.Final.jar:5.0.2.Final]




	at org.hibernate.jpa.internal.QueryImpl.list(QueryImpl.java:567) ~[hibernate-entitymanager-5.0.2.Final.jar:5.0.2.Final]




	at org.hibernate.jpa.internal.QueryImpl.getResultList(QueryImpl.java:436) ~[hibernate-entitymanager-5.0.2.Final.jar:5.0.2.Final]




	... 75 common frames omitted






</description>
			<version>1.10.1 (Hopper SR1)</version>
			<fixedVersion>1.10.3 (Hopper SR3), 1.11 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="956" opendate="2016-08-25 09:32:39" fixdate="2016-09-04 11:02:51" resolution="Fixed">
		<buginformation>
			<summary>Error creating DefaultJpaContext bean with a non-EntityManagerFactory JndiObjectFactoryBean defined via JavaConfig</summary>
			<description>After upgrading to 1.10.2, the following exception occurs at startup.






org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &amp;amp;apos;org.springframework.orm.jpa.SharedEntityManagerCreator#2&amp;amp;apos;: Unsatisfied dependency expressed through method &amp;amp;apos;createSharedEntityManager&amp;amp;apos; parameter 0: Could not convert argument value of type [com.sun.proxy.$Proxy138] to required type [javax.persistence.EntityManagerFactory]: Failed to convert value of type [com.sun.proxy.$Proxy138 implementing javax.jms.QueueConnectionFactory,org.springframework.aop.SpringProxy,org.springframework.aop.framework.Advised,org.springframework.core.DecoratingProxy] to required type [javax.persistence.EntityManagerFactory]; nested exception is java.lang.IllegalStateException: Cannot convert value of type [com.sun.proxy.$Proxy138 implementing javax.jms.QueueConnectionFactory,org.springframework.aop.SpringProxy,org.springframework.aop.framework.Advised,org.springframework.core.DecoratingProxy] to required type [javax.persistence.EntityManagerFactory]: no matching editors or conversion strategy found




        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:723)




        at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:467)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1123)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1018)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:510)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)




        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)




        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)




        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)




        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)




        at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:207)




        at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1214)




        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveMultipleBeans(DefaultListableBeanFactory.java:1120)




        at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1049)




        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1019)




        at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:835)




        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:741)




        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1143)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1046)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:510)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)




        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)




        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)




        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)




        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)




        at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:776)




        at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:861)




        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:541)




        at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:444)




        at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:326)




        at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:107)






I think this is caused by EntityManagerBeanDefinitionRegistrarPostProcessor. It is trying to create a SharedEntityManagerCreator even for JndiObjectFactoryBeans which do not expose a EntityManagerFactory.
After looking at the code, it seems to be an effect of DATAJPA-813.</description>
			<version>1.10.2 (Hopper SR2)</version>
			<fixedVersion>1.10.3 (Hopper SR3), 1.11 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.DefaultJpaContextIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.util.BeanDefinitionUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="960" opendate="2016-09-07 10:44:29" fixdate="2016-09-07 16:51:08" resolution="Fixed">
		<buginformation>
			<summary>Order by clause not created correctly if a manually defined query is not using an alias</summary>
			<description>In my repository I have:






@Query(value = "from mytable where" 




		+ " name  LIKE CONCAT(&amp;amp;apos;%&amp;amp;apos;, :name, &amp;amp;apos;%&amp;amp;apos;) "




		+ "and  ((trunc ( to_date(date, &amp;amp;apos;DD/MM/YYYY&amp;amp;apos; )) = trunc (to_date(:date,&amp;amp;apos;DD/MM/YYYY&amp;amp;apos;))) or :date is null) ")




List&amp;lt;Prodotto&amp;gt; cercaProdotto(@Param("name") String name, @Param("date") Date date, Pageable p);









Pageable and Sort (in service class):




Pageable p = new PageRequest(1, 10, mySort);




Sort mySort = new Sort(Sort.Direction.ASC, "name");






I am getting an error finishing with:  order by where.name asc.</description>
			<version>1.9.4 (Gosling SR4)</version>
			<fixedVersion>1.9.5 (Gosling SR5), 1.10.3 (Hopper SR3), 1.11 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="965" opendate="2016-09-20 08:26:23" fixdate="2016-09-20 08:40:33" resolution="Fixed">
		<buginformation>
			<summary>Mapping Sort instances to ORDER BY expressions should be restricted to fields for manually defined queries</summary>
			<description></description>
			<version>1.9.4 (Gosling SR4)</version>
			<fixedVersion>1.9.5 (Gosling SR5), 1.10.3 (Hopper SR3), 1.11 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.domain.JpaSort.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.domain.JpaSortTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">970</link>
		</links>
	</bug>
	<bug id="970" opendate="2016-09-22 19:27:23" fixdate="2016-09-23 08:24:53" resolution="Fixed">
		<buginformation>
			<summary>Ensure JDK 6 compatibility of regular expression used in QueryUtils</summary>
			<description>continued from https://jira.spring.io/browse/DATAJPA-965
somehow it seems the fix of this issue (or rather one of the added regex expressions) broke java 6 compatibility (using oracle jdk1.6.0_45)?






Caused By: java.util.regex.PatternSyntaxException: Look-behind group does not have an obvious maximum length near index 58




\s+\w+\([0-9a-zA-z\._,\s&amp;amp;apos;]+\)\s+[as|AS]+\s+(?&amp;lt;alias&amp;gt;[\w\.]+)




                                                          ^




        at java.util.regex.Pattern.error(Pattern.java:1713)




        at java.util.regex.Pattern.group0(Pattern.java:2488)




        at java.util.regex.Pattern.sequence(Pattern.java:1806)




        at java.util.regex.Pattern.expr(Pattern.java:1752)




        at java.util.regex.Pattern.compile(Pattern.java:1460)




        at java.util.regex.Pattern.&amp;lt;init&amp;gt;(Pattern.java:1133)




        at java.util.regex.Pattern.compile(Pattern.java:823)




        at org.springframework.data.jpa.repository.query.QueryUtils.&amp;lt;clinit&amp;gt;(QueryUtils.java:164)




        at org.springframework.data.jpa.repository.query.JpaQueryMethod.assertParameterNamesInAnnotatedQuery(JpaQueryMethod.java:102)




        at org.springframework.data.jpa.repository.query.JpaQueryMethod.&amp;lt;init&amp;gt;(JpaQueryMethod.java:95)




        at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$AbstractQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:77)




        at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.&amp;lt;init&amp;gt;(RepositoryFactorySupport.java:435)




        at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:220)




        at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.initAndReturn(RepositoryFactoryBeanSupport.java:266)




        at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.afterPropertiesSet(RepositoryFactoryBeanSupport.java:252)




        at org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean.afterPropertiesSet(JpaRepositoryFactoryBean.java:92)






ref. https://github.com/spring-projects/spring-data-jpa/blame/1.10.3.RELEASE/src/main/java/org/springframework/data/jpa/repository/query/QueryUtils.java#L162</description>
			<version>1.9.5 (Gosling SR5)</version>
			<fixedVersion>1.9.6 (Gosling SR6), 1.11 RC1 (Ingalls), 1.10.4 (Hopper SR4)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">965</link>
		</links>
	</bug>
	<bug id="974" opendate="2016-09-28 11:32:21" fixdate="2016-09-28 13:08:26" resolution="Fixed">
		<buginformation>
			<summary>Projections referring to collection attributes don&amp;apos;t create a proper selection (missing joins)</summary>
			<description>I have model entity as below
Document &amp;lt;-1-----M--&amp;gt; Document
and repository method is "public List&amp;lt;DocumentWithoutParent&amp;gt; findByParentIsNull()"
where &amp;amp;apos;DocumentWithoutParent&amp;amp;apos; is projection
sql that hibernate generate is incorrect. but when I change List&amp;lt;DocumentWithoutParent&amp;gt; to List&amp;lt;Document&amp;gt; it is OK.
So I think problem come from spring data jpa.
Below is  a test project on this problem.
https://github.com/pramoth/hibernate-generate-wrong-sql-with-projection</description>
			<version>1.10.3 (Hopper SR3)</version>
			<fixedVersion>1.11 RC1 (Ingalls), 1.10.4 (Hopper SR4)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryFinderTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryCreator.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">921</link>
		</links>
	</bug>
	<bug id="984" opendate="2016-10-20 08:52:40" fixdate="2016-10-21 07:30:44" resolution="Fixed">
		<buginformation>
			<summary>JPA projection query returning single non-standard JPA type results in "No aliases found in result tuple" error</summary>
			<description>This relates directly to DATAJPA-885. The issue described there still occurs when a query returns a standard JPA projection consisting of a single type, where Spring Data JPA doesn&amp;amp;apos;t recognize that the type can be mapped by the JPA provider itself. In my case this happens when returning a collection of Joda LocalDate instances. 
I&amp;amp;apos;ve attached a small sample app with a unit test that shows the problem. The same test also shows that a direct JPA query does work.
It would be nice if Spring Data JPA could somehow detect that I&amp;amp;apos;m not trying to use its projection feature in this case, to prevent the "No aliases found in result tuple" error from happening. </description>
			<version>1.10.4 (Hopper SR4)</version>
			<fixedVersion>1.10.5 (Hopper SR5), 1.11 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.AbstractJpaQuery.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">885</link>
		</links>
	</bug>
	<bug id="684" opendate="2015-03-03 13:49:46" fixdate="2016-11-03 09:52:30" resolution="Duplicate">
		<buginformation>
			<summary>QueryDslPredicateExecutor + EntityGraph + findAll</summary>
			<description>When overriding the findAll() method of  QueryDslPredicateExecutor with an @EntityGraph the query fails with:






org.hibernate.QueryException: query specified join fetching, but the owner of the fetched association was not present in the select list






What is the easiest way to provide a (non) working example? Sorry when I did something wrong, thats my first JIRA issue for Spring.</description>
			<version>1.7.2 (Evans SR2)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.EntityGraphRepositoryMethodsIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.RepositoryMethodsWithEntityGraphConfigRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.QueryDslJpaRepository.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">790</link>
		</links>
	</bug>
	<bug id="790" opendate="2015-09-02 23:06:28" fixdate="2016-11-03 10:30:54" resolution="Fixed">
		<buginformation>
			<summary>org.hibernate.QueryException when applying @EntityGraph on (Querydsl) findAll(Predicate, Pageable) method</summary>
			<description>The exception is thrown when applying @EntityGraph annotation on the Page&amp;lt;T&amp;gt; findAll(Predicate, Pageable) method in a repository interface.
Example Stacktrace (source: stackoverflow):






org.springframework.dao.InvalidDataAccessApiUsageException: org.hibernate.QueryException: query specified join fetching, but the owner of the fetched association was not present in the select list [FromElement{explicit,not a collection join,fetch join,fetch non-lazy properties,classAlias=appointment,role=com.physioclinic.entity.Appointment.createdBy,tableName=user,tableAlias=user5_,origin=appointment appointmen0_,columns={appointmen0_.createdBy_id ,className=com.physioclinic.entity.User}}] [select count(appointment)




from com.physioclinic.entity.Appointment appointment where lower(concat(concat(appointment.patient.person.name,?1),appointment.patient.person.surname)) like ?2 escape &amp;amp;apos;!&amp;amp;apos;]; nested exception is java.lang.IllegalArgumentException: org.hibernate.QueryException: query specified join fetching, but the owner of the fetched association was not present in the select list [FromElement{explicit,not a collection join,fetch join,fetch non-lazy properties,classAlias=appointment,role=com.physioclinic.entity.Appointment.createdBy,tableName=user,tableAlias=user5_,origin=appointment appointmen0_,columns={appointmen0_.createdBy_id ,className=com.physioclinic.entity.User}}]






Applying the annotation on the Iterable&amp;lt;T&amp;gt; findAll(Predicate) is not resulting with the exception (works just fine).</description>
			<version>1.9 GA (Gosling)</version>
			<fixedVersion>1.10.5 (Hopper SR5), 1.11 RC1 (Ingalls), 1.9.7 (Gosling SR7)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.EntityGraphRepositoryMethodsIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.RepositoryMethodsWithEntityGraphConfigRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.support.QueryDslJpaRepository.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">684</link>
		</links>
	</bug>
	<bug id="1000" opendate="2016-11-09 21:28:35" fixdate="2016-11-11 09:10:59" resolution="Fixed">
		<buginformation>
			<summary>Pageable With Fetch not returning the right alias Name</summary>
			<description>When using @Query in a JPA repository along with Pageable and attempting to sort on a field in a joined fetch entity, the from entity gets prepended to the sort field. Because the alias got a bad result. For example, if I do the following query:






@Query(value = "SELECT DISTINCT user FROM User user LEFT JOIN FETCH user.authorities authority")






 if I simply decide to sort by a field in the Authority entity with this PageRequest:






new PageRequest(0, 10, Direction.DESC, "authority.name");






The query run is:






SELECT DISTINCT user FROM com.admtl.model.user.User user LEFT JOIN FETCH user.authorities authority  order by user.authority.name asc






And I got :






SEVERE: Servlet.service() for servlet [SpringWeb] in context with path [/path] threw exception [Request processing failed; nested exception is org.springframework.dao.InvalidDataAccessApiUsageException: org.hibernate.QueryException: could not resolve property: authority of: com.admtl.model.user.User [SELECT DISTINCT user FROM com.admtl.model.user.User user LEFT JOIN FETCH user.authorities authority  order by user.authority.name asc]; nested exception is java.lang.IllegalArgumentException: org.hibernate.QueryException: could not resolve property: authority of: com.admtl.model.user.User [SELECT DISTINCT user FROM com.admtl.model.user.User user LEFT JOIN FETCH user.authorities authority  order by user.authority.name asc]] with root cause






Normal because authorities is property of User not authority
But If I remove the FETCH






@Query(value = "SELECT DISTINCT user FROM User user LEFT JOIN user.authorities authority")






With the same PageRequest, my query run is:






SELECT DISTINCT user FROM com.admtl.model.user.User user LEFT JOIN FETCH user.authorities authority  order by authority.name asc






Perfect!
I look a bit on the code of org.springframework.data.jpa.repository.query.QueryUtils
for method getOuterJoinAliases






    static Set&amp;lt;String&amp;gt; getOuterJoinAliases(String query) {









		Set&amp;lt;String&amp;gt; result = new HashSet&amp;lt;String&amp;gt;();




		Matcher matcher = JOIN_PATTERN.matcher(query);









		while (matcher.find()) {









			String alias = matcher.group(QUERY_JOIN_ALIAS_GROUP_INDEX);




			if (StringUtils.hasText(alias)) {




				result.add(alias);




			}




		}









		return result;




	}






The FETCH put the mess with the QUERY_JOIN_ALIAS_GROUP_INDEX</description>
			<version>1.10.4 (Hopper SR4)</version>
			<fixedVersion>1.11 RC1 (Ingalls), 1.9.7 (Gosling SR7), 1.10.6 (Hopper SR6)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.QueryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="905" opendate="2016-05-27 04:38:29" fixdate="2016-11-24 16:39:37" resolution="Fixed">
		<buginformation>
			<summary>Count queries should be issued without ORDER BY clause</summary>
			<description>query method:






//Repository




public interface IPoPersonBusinessRepository extends JpaRepository&amp;lt;PoPersonBusinessEntity, Long&amp;gt;




{




	Page&amp;lt;PoPersonBusinessEntity&amp;gt; findAll(Specification&amp;lt;PoPersonBusinessEntity&amp;gt; spec,Pageable pageable);




}












//service




@Service




public class PoPersonBusinessServiceImpl implements IPoPersonBusinessService {




@Autowired




	IPoPersonBusinessRepository businessRepository;









	@Override




	public Page&amp;lt;PoPersonBusinessEntity&amp;gt; findByCondition(CompanyConditionVo vo,Pageable pageable) {









		Page&amp;lt;PoPersonBusinessEntity&amp;gt; pb =businessRepository.findAll((root, query, cb) -&amp;gt; {




            Predicate predicate = cb.conjunction();




               




               List&amp;lt;Order&amp;gt; sort = new ArrayList&amp;lt;&amp;gt;();




               sort.add(cb.asc(root.get("businessOrder")));




               query.orderBy(sort);









            return predicate;




        }, pageable);




		




		return pb;




	}




}












//test




public class PoPersonBusinessServiceTest extends BaseTests{









	 




	@Autowired




	IPoPersonBusinessService businessService;




	




	




	




	//




		@Test




		public void findByCondition(){




			PoPersonBusinessEntity pb = new PoPersonBusinessEntity();




			businessService.save(pb);




			CompanyConditionVo companyConditionVo=new CompanyConditionVo();




//			companyConditionVo.setsCode("incomeModify");




//			companyConditionVo.setsType("1");




//			companyConditionVo.setsIsLogicDel("false");




			Pageable Pageable =new PageRequest(0, 10);




			Page&amp;lt;PoPersonBusinessEntity&amp;gt; Business=  businessService.findByCondition(companyConditionVo, Pageable);




			Assert.assertTrue(Business.getNumberOfElements()&amp;gt;0);




		}




}






t is successful when run against the MySQL database. But when run against the hsqldb database, it gives the following error:











Caused by: java.sql.SQLSyntaxErrorException: invalid ORDER BY expression in statement [select count(popersonbu0_.id) as col_0_0_ from t_po_person_business_m popersonbu0_ where 1=1 order by popersonbu0_.business_order asc]




	at org.hsqldb.jdbc.JDBCUtil.sqlException(Unknown Source)




	at org.hsqldb.jdbc.JDBCUtil.sqlException(Unknown Source)




	at org.hsqldb.jdbc.JDBCPreparedStatement.&amp;lt;init&amp;gt;(Unknown Source)




.......






dependency:






spring-data-jpa : 1.10.1.RELEASE




h2.version : 1.4.191




hsqldb.version: 2.3.4




hibernate.version: 4.3.11.Final






That&amp;amp;apos;s all. Thank you.</description>
			<version>1.10.1 (Hopper SR1)</version>
			<fixedVersion>1.10.2 (Hopper SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.support.SimpleJpaRepository.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.UserSpecifications.java</file>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="920" opendate="2016-06-27 15:04:07" fixdate="2016-12-02 10:29:58" resolution="Fixed">
		<buginformation>
			<summary>Add support for exists projection in repository query derivation</summary>
			<description>Add support for exists projection in repository query derivation.</description>
			<version>1.9.2 (Gosling SR2)</version>
			<fixedVersion>1.11 RC1 (Ingalls), 2.0 M2 (Kay)</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryCreator.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.EmbeddedIdExampleEmployee.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.RepositoryWithCompositeKeyTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.PartTreeJpaQueryIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.IdClassExampleDepartment.java</file>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryExecution.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.EmployeeRepositoryWithEmbeddedId.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.EmployeeRepositoryWithIdClass.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.IdClassExampleEmployee.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.PartTreeJpaQuery.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">875</link>
			<link type="Duplicate" description="duplicates">851</link>
		</links>
	</bug>
	<bug id="851" opendate="2016-01-23 00:40:43" fixdate="2016-12-05 13:33:35" resolution="Duplicate">
		<buginformation>
			<summary>Support existsBy in Repository</summary>
			<description>Currently to implements exists with predicate (e.g. existsByUsername) we have to use @Query manually, e.g. http://stackoverflow.com/a/27156094/122441
Please support this convenience method directly in Spring Data JPA.
Related to DATAJPA-665</description>
			<version>1.9.2 (Gosling SR2)</version>
			<fixedVersion></fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryCreator.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.EmbeddedIdExampleEmployee.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.UserRepository.java</file>
			<file type="M">org.springframework.data.jpa.repository.RepositoryWithCompositeKeyTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.PartTreeJpaQueryIntegrationTests.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.IdClassExampleDepartment.java</file>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryExecution.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.EmployeeRepositoryWithEmbeddedId.java</file>
			<file type="M">org.springframework.data.jpa.repository.sample.EmployeeRepositoryWithIdClass.java</file>
			<file type="M">org.springframework.data.jpa.domain.sample.IdClassExampleEmployee.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.PartTreeJpaQuery.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">920</link>
		</links>
	</bug>
	<bug id="1024" opendate="2016-12-13 09:37:02" fixdate="2016-12-13 09:57:28" resolution="Fixed">
		<buginformation>
			<summary>Querrying empty table for non-standard JPA type results in IllegalStateExcepion with the message "No aliases found in result tuple"</summary>
			<description>Related to DATAJPA-984. Querrying empty table for non-standard JPA type results in IllegalStateExcepion with the message "No aliases found in result tuple", instead of returning null.
In the linked git repository this is showcased with org.joda.time.LocalDate instances. Querries for standard types, e.g. java.time.LocalDate return null as expected. It would be nice if the behaviour was unified.</description>
			<version>1.10.5 (Hopper SR5)</version>
			<fixedVersion>1.9.7 (Gosling SR7), 1.10.6 (Hopper SR6), 2.0 M2 (Kay)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.query.AbstractJpaQuery.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.TupleConverterUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1023" opendate="2016-12-13 08:47:23" fixdate="2016-12-14 16:46:41" resolution="Fixed">
		<buginformation>
			<summary>Reject stream executions if not executed within transaction </summary>
			<description>I&amp;amp;apos;m using Stream&amp;amp;apos;s to loop through each element in a Repository in an @Scheduled method. After running 200 times I get the following error:






2016-12-13 09:40:39.159  WARN 51004 --- [pool-2-thread-1] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 0, SQLState: null




2016-12-13 09:40:39.159 ERROR 51004 --- [pool-2-thread-1] o.h.engine.jdbc.spi.SqlExceptionHelper   : [pool-2-thread-1] Timeout: Pool empty. Unable to fetch a connection in 2 seconds, none available[size:200; busy:200; idle:0; lastwait:2000].






The Repository is defined as such:






public interface PushNotificationRepository extends JpaRepository&amp;lt;PushNotification, Long&amp;gt; {




    @Query(value = "select p from PushNotification p")




    Stream&amp;lt;PushNotification&amp;gt; findAllAndStream();




}






The Service is defined like this:






@Service




@Transactional()




public class PushNotificationFlusherService {




    private static final Logger LOGGER = LoggerFactory.getLogger(PushNotificationFlusherService.class);









    private final PushNotificationRepository pushNotificationRepository;









    @Autowired




    public PushNotificationFlusherService(PushNotificationRepository pushNotificationRepository) {




        this.pushNotificationRepository = pushNotificationRepository;




    }









    @Scheduled(fixedDelay = 5000)




    protected void flushPushNotificationQueue() {




        LOGGER.info("Flushing push notifications");









        try (Stream&amp;lt;PushNotification&amp;gt; pushNotifications = pushNotificationRepository.findAllAndStream()) {




            pushNotifications.forEach((PushNotification pushNotification) -&amp;gt; {




               // Send notification 




            });




        }









        LOGGER.info("Flushed push notifications");




    }






I&amp;amp;apos;ve tried using @Transactional( readOnly=true) but it does not make a difference.</description>
			<version>1.10.5 (Hopper SR5)</version>
			<fixedVersion>1.11 RC1 (Ingalls), 2.0 M2 (Kay)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.jpa.repository.UserRepositoryFinderTests.java</file>
			<file type="M">org.springframework.data.jpa.repository.query.JpaQueryExecution.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">959</link>
		</links>
	</bug>
</bugrepository>