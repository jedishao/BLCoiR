<?xml version = "1.0" encoding = "UTF-8" ?>
<bugrepository name="SEC">
	<bug id="22" opendate="2005-06-25 15:25:28" fixdate="2005-06-26 13:06:38" resolution="Fixed">
		<buginformation>
			<summary>JBossAcegiLoginModule - Bug when identity is created</summary>
			<description>Currently the code used to create the PrincipalAcegiUserToken is the following:
identity = new PrincipalAcegiUserToken(this.key,
                     response.getPrincipal().toString(),
                     response.getCredentials().toString()
                     response.getAuthorities());
This means that the PrincipalAcegiUserToken is passed a serialized response principal NOT the username which is the method signature for PrincipalAcegiUserToken.
I would suggest that the code should look like this:
identity = new PrincipalAcegiUserToken(this.key,
                     response.getPrincipal().getName(), //&amp;lt;-- CHANGED
                     response.getCredentials().toString()
                     response.getAuthorities());
Cheers,
Dan.</description>
			<version>0.8.2</version>
			<fixedVersion>0.9.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.adapters.jboss.JbossAcegiLoginModule.java</file>
		</fixedFiles>
	</bug>
	<bug id="27" opendate="2005-06-29 00:55:00" fixdate="2005-07-08 08:21:14" resolution="Fixed">
		<buginformation>
			<summary>RememberMeProcessingFilter should not fire InteractiveAuthenticationSuccesEvent in case of unsucessful authentication</summary>
			<description>I have tried to start my application with the latest (from CVS) version of acegi and get following exception:
java.lang.IllegalArgumentException: null source
  java.util.EventObject.&amp;lt;init&amp;gt;(EventObject.java:34)
  org.springframework.context.ApplicationEvent.&amp;lt;init&amp;gt;(ApplicationEvent.java:37)
  net.sf.acegisecurity.ui.InteractiveAuthenticationSuccesEvent.&amp;lt;init&amp;gt;(InteractiveAuthenticationSuccesEvent.java:45)
  net.sf.acegisecurity.ui.rememberme.RememberMeProcessingFilter.doFilter(RememberMeProcessingFilter.java:136)
After some investigation I have found reason. In RememberMeProcessingFilter.java InteractiveAuthenticationSuccesEvent is fired even in case of unsucessful authentication.
            SecurityContextHolder.getContext().setAuthentication(rememberMeServi
                .autoLogin(httpRequest, httpResponse));
            if (logger.isDebugEnabled()) 
{
                logger.debug(
                    "Replaced SecurityContextHolder with remember-me token: &amp;amp;apos;"
                    + SecurityContextHolder.getContext().getAuthentication()
                    + "&amp;amp;apos;");
            }

            // Fire event
            if (this.context != null) 
{
                context.publishEvent(new InteractiveAuthenticationSuccesEvent(
                        SecurityContextHolder.getContext().getAuthentication(),
                        this.getClass()));
            }

Fix would be quite easy: check that after autoLogin authentication in security context is not null.
</description>
			<version>0.8.2</version>
			<fixedVersion>0.9.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.rememberme.RememberMeProcessingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="20" opendate="2005-06-24 14:17:57" fixdate="2005-07-11 16:46:19" resolution="Fixed">
		<buginformation>
			<summary>HttpSessionContextIntegrationFilter must set to null irrespective of exception</summary>
			<description>http://forum.springframework.org/viewtopic.php?t=6223
HttpSessionContextIntegrationFilter must set the ContextHolder to null irrespective of exceptions thrown inside the filter chain. ie use a finally {} block to set to null and re-throw exception.</description>
			<version>0.8.2</version>
			<fixedVersion>0.8.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilter.java</file>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilterTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="48" opendate="2005-08-18 02:27:12" fixdate="2005-08-23 02:16:13" resolution="Fixed">
		<buginformation>
			<summary>Improve JaasNameCallbackHandler handling of string </summary>
			<description>I submitted this via the listserv on 7/21/2005, and one of the developers said it would be looked into immediately, so I didnt file a JIRA issue on it, but since it apparently hasn&amp;amp;apos;t been touched in CVS, I&amp;amp;apos;m going to submit it here.  I&amp;amp;apos;m pasting in the email contents below:
I&amp;amp;apos;m also going to submit a patch, which is my version of the fix.
================================
I&amp;amp;apos;ll double check but I&amp;amp;apos;m pretty sure that&amp;amp;apos;s a bug. If so I&amp;amp;apos;ll get it committed either tonight or tomorrow. US time that is  -Ray
On 7/21/05, Tim Kettering &amp;lt;tim.kettering@vivakos.com&amp;gt; wrote:
&amp;gt;  
&amp;gt;  
&amp;gt; 
&amp;gt;   
&amp;gt; 
&amp;gt; I was tracking down some issues that came up after we started using our own
&amp;gt; UserDetails object in the principal of Authentication.    This method in
&amp;gt; JaasNameCallbackHandler seems to be calling the incorrect method.  In 
&amp;gt; AbstractAuthenticationHandler, the methods called are 
&amp;gt; &amp;amp;apos;authentication.getPrincipal().getUsername()&amp;amp;apos;  not
&amp;gt; &amp;amp;apos;toString()&amp;amp;apos;  like it appears below.   Is there any reason for this?  The
&amp;gt; problem we are facing is that our JAAS handler is trying to 
&amp;gt; authenticate on the entire toString() output of our UserDetails 
&amp;gt; object, instead of just the username, at this point, when the Acegi 
&amp;gt; API/source seems to indicate that
&amp;gt; toString() is to be used for debug output.  
&amp;gt; 
&amp;gt;   
&amp;gt; 
&amp;gt;     public void handle(Callback callback, Authentication 
&amp;gt; authentication)
&amp;gt; 
&amp;gt;         throws IOException, UnsupportedCallbackException {
&amp;gt; 
&amp;gt;         if (callback instanceof NameCallback) 
{
&amp;gt; 
&amp;gt;             NameCallback ncb = (NameCallback) callback;
&amp;gt; 
&amp;gt;             ncb.setName(authentication.getPrincipal().toString());
&amp;gt; 
&amp;gt;         }
&amp;gt; 
&amp;gt;     }
-------------------------------------------------------
SF.Net email is sponsored by: Discover Easy Linux Migration Strategies from IBM. Find simple to follow Roadmaps, straightforward articles, informative Webcasts and more! Get everything you need to get up to speed, fast. http://ads.osdn.com/?ad_idt77&amp;amp;alloc_id492&amp;amp;op=ick
_______________________________________________
Home: http://acegisecurity.sourceforge.net
Acegisecurity-developer mailing list
Acegisecurity-developer@lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/acegisecurity-developer</description>
			<version>0.8.2</version>
			<fixedVersion>0.9.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.jaas.JaasNameCallbackHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="43" opendate="2005-07-26 07:50:53" fixdate="2005-10-20 18:32:44" resolution="Fixed">
		<buginformation>
			<summary>JdbcExtendedDaoImpl doesn&amp;apos;t work with Postgres</summary>
			<description>Using JdbcExtendedDaoImpl together with PostgreSQL and the following acl tables fails when inserting new identities or permissions:
create table acl_object_identity (
     id serial primary key,
     object_identity varchar(250) not null unique,
     parent_object integer references acl_object_identity,
     acl_class varchar(250) not null
);
create table acl_permission (
     id serial primary key,
     acl_object_identity integer not null references acl_object_identity(id),
     recipient varchar(100) not null,
     mask integer not null,
     constraint unique_recipient unique(acl_object_identity, recipient)
);
This is due to the fact that JdbcExtendedDaoImpl explicitly sets the id to null. Postgres will naturally give an error as this is a primary key and thus cannot be null. Either set it to the value you want or leave it out of the statement.
It doesn&amp;amp;apos;t seem to be possible to override this by injecting new sql statements for AclObjectIdentityInsertStatement and AclPermissionInsertStatement. AclObjectIdentityInsert and AclPermissionInsert classes declares four parameters, the first of which is hardcoded to null.</description>
			<version>0.8.2</version>
			<fixedVersion>0.9.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.acl.basic.jdbc.JdbcExtendedDaoImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="60" opendate="2005-09-29 22:58:34" fixdate="2005-10-20 18:52:56" resolution="Fixed">
		<buginformation>
			<summary>AbstractSecurityInterceptor does not work with detached Hibernate collections</summary>
			<description>The beforeInvocation method in AbstractSecurityInterceptor class has the following line:
        Assert.isTrue(getSecureObjectClass().isAssignableFrom(object.getClass()), "Security invocation attempted for object " + object
                    + " but AbstractSecurityInterceptor only configured to support secure objects of type: "
                    + getSecureObjectClass());
where the implicit object.toString() causes problems for us with detached Hibernate 3.0
collections. Our code passes an detached org.hibernate.collection.PersistentSet to a DAO
object which initializes it. This works fine in 0.8.0 but is broken in 0.8.3. The root cause
is that it is not safe to call toString() for lazily loaded Hibernate collection that is detached.
I don&amp;amp;apos;t think this is a Hibernate bug as it mimics java.util.Collection toString() behavior. It
would be unsafe for Hibernate to return different values depending on whether the object is
detached or not.
Suggested fix is to either remove the above or make the check configurable so we can
disable it.</description>
			<version>0.8.3</version>
			<fixedVersion>0.9.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.intercept.AbstractSecurityInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="63" opendate="2005-10-10 22:48:17" fixdate="2005-10-20 19:00:49" resolution="Fixed">
		<buginformation>
			<summary>Absolute URL redirection may cause problems in load-balanced environments</summary>
			<description>When re-directing a non-authenticated user, class AuthenticationProcessingFilterEntryPoint builds an absolute URL. 
This is designed this way becuase it may need to replace the protocol (http to https).
In Load-Balanced environments this may lead to loss of the load balancer, as the redirection will use the server as part of the URL. Load balancers / app servers have settings to avoid this, but these entail special configuration and may limit other applications on same server.
Use of relative redirection is much better for most scenarios.</description>
			<version>0.8.2</version>
			<fixedVersion>0.9.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.webapp.AuthenticationProcessingFilterEntryPointTests.java</file>
			<file type="M">org.acegisecurity.ui.webapp.AuthenticationProcessingFilterEntryPoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="64" opendate="2005-10-15 20:45:56" fixdate="2005-11-02 19:48:51" resolution="Fixed">
		<buginformation>
			<summary>FilterChainProxy does not work on Orion Web Application Server</summary>
			<description>Setting up the contacts example on Orion does not work out of the box.
This is because of a bug/feature in Orion where the &amp;amp;apos;getServletPath&amp;amp;apos; method returns null when called from within a filter.  The FilterInvocation class makes use of this method and therefore fails to do the redirects to the &amp;amp;apos;j_acegi_security_check&amp;amp;apos;.  Everything works fine if you configure Acegi longhand via the web.xml.
I realise this is more of a bug with Orion (and I have raised it with them) but it would be good if you guys could put a workaround into the framework.  In my investigations I got it work by putting something similar to the following in the &amp;amp;apos;getRequestUrl()&amp;amp;apos; method of FilterInvocation, but I obviously havn&amp;amp;apos;t done a full impact analysis of this change.
 String uri = request.getServletPath();
    if (uri == null) 
{
      uri = request.getRequestURI();
      uri = uri.substring(request.getContextPath().length());
    }

Thanks
Paul</description>
			<version>0.8.3</version>
			<fixedVersion>0.9.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.intercept.web.FilterInvocation.java</file>
		</fixedFiles>
	</bug>
	<bug id="111" opendate="2005-11-23 02:05:54" fixdate="2005-11-23 02:39:58" resolution="Fixed">
		<buginformation>
			<summary>ContextPropagatingRemoteInvocation fails to reset the context if an exception is thrown during the invocation</summary>
			<description>The context is normally emptied after the invocation but this isn&amp;amp;apos;t done if an exception occurs. So the same context could potentially be used for another call if a thread pool is in use.
http://acegisecurity.sourceforge.net/multiproject/acegi-security/xref/org/acegisecurity/context/rmi/ContextPropagatingRemoteInvocation.html#120</description>
			<version>0.9.0</version>
			<fixedVersion>1.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.context.rmi.ContextPropagatingRemoteInvocationTests.java</file>
			<file type="M">org.acegisecurity.context.rmi.ContextPropagatingRemoteInvocation.java</file>
		</fixedFiles>
	</bug>
	<bug id="105" opendate="2005-11-18 01:26:15" fixdate="2005-11-24 14:29:38" resolution="Fixed">
		<buginformation>
			<summary>Mis-named method signature in n.s.a.util.PortMapperImpl</summary>
			<description>Forum discussion :
http://forum.springframework.org/showthread.php?t=19903
yielded a little problem with PortMappingImpl.  The javadocs state that use the following in a spring config file
   &amp;lt;property name="httpsPortMapping"&amp;gt;
     &amp;lt;map&amp;gt;
       &amp;lt;entry key="80"&amp;gt;&amp;lt;value&amp;gt;443&amp;lt;/value&amp;gt;&amp;lt;/entry&amp;gt;
       &amp;lt;entry key="8080"&amp;gt;&amp;lt;value&amp;gt;8443&amp;lt;/value&amp;gt;&amp;lt;/entry&amp;gt;
     &amp;lt;/map&amp;gt;
   &amp;lt;/property&amp;gt;
Looking into the source of PortMappingImpl and there&amp;amp;apos;s no corresponding setHttpsPortMapping for spring to inject.  Spring falls over.  
Solution : either update the javadocs or better in my opinion change the existing method from setPortMapping(Map m) to setHttpsPortMapping(Map m) </description>
			<version>0.8.3</version>
			<fixedVersion>1.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.util.PortMapperImpl.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">109</link>
		</links>
	</bug>
	<bug id="109" opendate="2005-11-22 00:45:22" fixdate="2005-11-24 14:30:10" resolution="Fixed">
		<buginformation>
			<summary>PortMapperImpl property mistake</summary>
			<description>In accordance wuth Acegi Security System Platform Documentation, you can set a custom definition of socket port mapping (by default this is set in this way HTTP: 80/8080, HTTPS: 443/8443).
The definition of the setter method public void setPortMappings(Map newMappings) set this property httpsPortMapping. 
But this definition cause an Exception on the property writing. 
To allow the settings the property in applicationContext must be set as "portMapping".
Again, API&amp;amp;apos;s report this specifics for method setPortMappiungs:
public void setPortMappings(Map newMappings)
Set to override the default HTTP port to HTTPS port mappings of 80:443, 
and 8080:8443. In a Spring XML ApplicationContext, a definition would look something like 
this:
   &amp;lt;property name="httpsPortMapping"&amp;gt;
     &amp;lt;map&amp;gt;
       &amp;lt;entry key="80"&amp;gt;&amp;lt;value&amp;gt;443&amp;lt;/value&amp;gt;&amp;lt;/entry&amp;gt;
       &amp;lt;entry key="8080"&amp;gt;&amp;lt;value&amp;gt;8443&amp;lt;/value&amp;gt;&amp;lt;/entry&amp;gt;
     &amp;lt;/map&amp;gt;
   &amp;lt;/property&amp;gt;
Parameters:
newMappings - A Map consisting of String keys and String values, where 
for each entry the key is the string representation of an integer HTTP port 
number, and the value is the string representation of the corresponding 
integer HTTPS port number. 
Throws:
IllegalArgumentException - if input map does not consist of String 
keys and values, each representing an integer port number in the range 
1-65535 for that mapping.
Thanks for attention.
Kind Regards
</description>
			<version>0.8.3</version>
			<fixedVersion>1.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.util.PortMapperImpl.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">105</link>
		</links>
	</bug>
	<bug id="110" opendate="2005-11-22 09:39:13" fixdate="2005-11-24 14:33:50" resolution="Fixed">
		<buginformation>
			<summary>ProviderManager does not properly handle ConcurrentLoginException</summary>
			<description>The ProviderManager will incorrectly return an authentication object and fire AuthenticationSuccessEvent when a ConcurrentLoginException is thrown. </description>
			<version>0.9.0</version>
			<fixedVersion>1.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.ProviderManager.java</file>
		</fixedFiles>
	</bug>
	<bug id="112" opendate="2005-11-23 03:52:28" fixdate="2005-11-24 14:37:45" resolution="Fixed">
		<buginformation>
			<summary>Infinite loop when SecurityEnforcementFilter doesn&amp;apos;t clear SecurityContextHolder</summary>
			<description>http://forum.springframework.org/showthread.php?t=19895
If a user is disabled midway through a session, and anonymous authentication is being used to authorize the login form URL, an infinite loop will occur. This is because a DisabledException is thrown by the AuthenticationManager, which SecurityEnforcementFilter will catch and then launch AuthenticationEntryPoint. However, the protected login form URL (ie generally marked as ROLE_ANONYMOUS) will not be authorized, because the AnonymousProcessingFilter will not replace the SecurityContextHolder contents as the SecurityContextHolder already contains an Authentication object (albeit one that is disabled).
The fix is for SecurityEnforcementFilter to clear the SecurityContextHolder before loading any AuthenticationEntryPoint.</description>
			<version>0.8.3</version>
			<fixedVersion>1.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.intercept.web.SecurityEnforcementFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="106" opendate="2005-11-19 00:07:04" fixdate="2005-11-24 14:40:08" resolution="Fixed">
		<buginformation>
			<summary>NoSuchMethodException in AuthenticationTag</summary>
			<description>There&amp;amp;apos;s a problem with a property not found in case of custom UserDetails implementation if this property is defined in a superclass.
The solution is to change getDeclaredMethod() call to getMethod() which searches also the superclass if no matching method&amp;amp;apos;s found in the specified class (patch provided).</description>
			<version>0.9.0</version>
			<fixedVersion>1.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.taglibs.authz.AuthenticationTag.java</file>
		</fixedFiles>
	</bug>
	<bug id="108" opendate="2005-11-21 21:53:15" fixdate="2005-11-28 12:44:06" resolution="Fixed">
		<buginformation>
			<summary>Change JdbcDaoImpl fields to be protected (not private)</summary>
			<description>In the previous version we were able to get to the authoritiesByUsernameMapping via a getter. As of version 0.9.0 this getter is no longer available. We need this in the subclasses of JdbcDaoImpl.</description>
			<version>0.9.0</version>
			<fixedVersion>1.0.0 RC1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.userdetails.jdbc.JdbcDaoImpl.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">117</link>
		</links>
	</bug>
	<bug id="116" opendate="2005-12-01 22:14:23" fixdate="2005-12-01 22:14:46" resolution="Fixed">
		<buginformation>
			<summary>Authentication LoggerListener JavaDocs incorrect</summary>
			<description>The LoggerListener JavaDocs incorrect advise different logging levels are used for different ApplicationEvents. It should specify that all events are logged with warning severity.</description>
			<version>0.9.0</version>
			<fixedVersion>1.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.event.authentication.LoggerListener.java</file>
		</fixedFiles>
	</bug>
	<bug id="117" opendate="2005-12-02 22:17:25" fixdate="2005-12-02 22:24:12" resolution="Fixed">
		<buginformation>
			<summary>JdbcDaoImpl not properly extensible</summary>
			<description>While the javadoc for JdbcDaoImpl suggests that it is possible to override the initMappingSqlQueries() if the default strategy for customizing the SQL queries doesn&amp;amp;apos;t provide enough flexibility, this is in fact impossible because authoritiesByUsernameMapping and usersByUsernameMapping are declared private while they should be protected.
This as far as I can see prevents using this class against an Oracle database that doesn&amp;amp;apos;t support boolean fields.</description>
			<version>0.9.0</version>
			<fixedVersion>1.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.userdetails.jdbc.JdbcDaoImpl.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">108</link>
		</links>
	</bug>
	<bug id="118" opendate="2005-12-02 23:38:25" fixdate="2005-12-03 21:11:19" resolution="Fixed">
		<buginformation>
			<summary>Wrong logger class in JdbcDaoImpl</summary>
			<description>The logger used by JdbcDaoImpl is strangely declared as "private static final Log logger = LogFactory.getLog(JdbcDaoSupport.class);"
Shouldn&amp;amp;apos;t it be "private static final Log logger = LogFactory.getLog(JdbcDaoImpl.class);"?</description>
			<version>0.8.2</version>
			<fixedVersion>1.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.userdetails.jdbc.JdbcDaoImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="143" opendate="2006-01-12 10:42:44" fixdate="2006-01-16 09:56:46" resolution="Fixed">
		<buginformation>
			<summary>NPE in JaasAuthenticationProvider</summary>
			<description>Servlet containers often destroy sessions before an Acegi SecurityContext has been attached to them. This ends up causing a NullPointerException in JaasAuthenticationProvider.handleLogout() line 424.
java.lang.NullPointerException
	at net.sf.acegisecurity.providers.jaas.JaasAuthenticationProvider.handleLogout(JaasAuthenticationProvider.java:424)
	at net.sf.acegisecurity.providers.jaas.JaasAuthenticationProvider.onApplicationEvent(JaasAuthenticationProvider.java:413)
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:45)
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:224)
	at net.sf.acegisecurity.ui.session.HttpSessionEventPublisher.sessionDestroyed(HttpSessionEventPublisher.java:107)
	at com.ibm.ws.webcontainer.httpsession.SessionContext.sessionDestroyedEvent(SessionContext.java:3417)
.....</description>
			<version>0.9.0</version>
			<fixedVersion>1.0.0 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.jaas.JaasAuthenticationProvider.java</file>
		</fixedFiles>
	</bug>
	<bug id="125" opendate="2005-12-13 11:54:09" fixdate="2006-01-25 19:23:54" resolution="Fixed">
		<buginformation>
			<summary>AbstractAuthenticationToken requires hashCode() method</summary>
			<description>http://forum.springframework.org/showthread.php?t=20516
hashCode() method required because equals() is implemented and HttpSessionContextIntegration relies on hash codes now for comparison purposes (see SecurityContextImpl.hashCode() which delegates to Authentication.hashCode()).</description>
			<version>0.8.2</version>
			<fixedVersion>1.0.0 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.AbstractAuthenticationToken.java</file>
			<file type="M">org.acegisecurity.providers.AbstractAuthenticationTokenTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="137" opendate="2006-01-02 05:19:15" fixdate="2006-01-25 19:29:08" resolution="Fixed">
		<buginformation>
			<summary>StackOverFlowError when calling MethodInvocation.createFromClass(clazz, method)</summary>
			<description>     public static MethodInvocation createFromClass(Class clazz,
        String methodName) 
{
        return createFromClass(clazz, methodName);
    }

this causes a stack overflow.
Maybe something like:
     public static MethodInvocation createFromClass(Class clazz,
        String methodName) 
{
        return createFromClass(clazz, methodName, null);
    }</description>
			<version>0.8.3</version>
			<fixedVersion>1.0.0 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.util.MethodInvocationUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="154" opendate="2006-01-25 11:07:53" fixdate="2006-01-25 20:29:22" resolution="Fixed">
		<buginformation>
			<summary>NamedEntityObjectIdentity must support CGLIB (Hibernate) modified domain objects</summary>
			<description>CGLIB-generated classes have names such as foo.DomainObject$$EnhancerByCGLIB, which are incompatible with the NamedEntityObjectIdentity&amp;amp;apos;s internal representation of the classname as a String.
A workaround is to use BasicAclProvider.defaultAclObjectIdentityClass to provide a new instance of AclObjectIdentity which can correctly handle the names. Another workaround is for your domain objects to implement AclObjectIdentityAware and return the AclObjectIdentity that represents the instance.</description>
			<version>0.8.2</version>
			<fixedVersion>1.0.0 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.acl.basic.NamedEntityObjectIdentity.java</file>
		</fixedFiles>
	</bug>
	<bug id="156" opendate="2006-01-25 13:21:59" fixdate="2006-01-26 14:53:10" resolution="Fixed">
		<buginformation>
			<summary>AuthenticationSimpleHttpInvokerRequestExecutor should use getName() instead of toString()</summary>
			<description>http://forum.springframework.org/showthread.php?t=21664</description>
			<version>0.8.2</version>
			<fixedVersion>1.0.0 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.context.httpinvoker.AuthenticationSimpleHttpInvokerRequestExecutor.java</file>
		</fixedFiles>
	</bug>
	<bug id="162" opendate="2006-01-27 11:24:24" fixdate="2006-01-27 11:25:57" resolution="Fixed">
		<buginformation>
			<summary>MethodInvocationPrivilegeEvaluator incorrectly throws exception with null Authentication</summary>
			<description>MethodInvocationPrivilegeEvaluation should not throw an exception if a null Authentication is passed, but instead return false to indicate the current user does not have permission to the requested MethodInvocation.</description>
			<version>1.0.0 RC1</version>
			<fixedVersion>1.0.0 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.intercept.method.MethodInvocationPrivilegeEvaluator.java</file>
		</fixedFiles>
	</bug>
	<bug id="163" opendate="2006-01-28 07:29:31" fixdate="2006-01-28 07:33:52" resolution="Fixed">
		<buginformation>
			<summary>MethodInvocationUtils.create(Object, String, Object[]) causes ClassCastException</summary>
			<description>In RC1, the MethodInvocationUtils.create(Object, String, Object[]) caused a ClassCastException at line 84.
In addition, there was no unit test to pick up this issue.</description>
			<version>1.0.0 RC1</version>
			<fixedVersion>1.0.0 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.util.MethodInvocationUtils.java</file>
			<file type="M">org.acegisecurity.intercept.method.MethodInvocationPrivilegeEvaluatorTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="134" opendate="2005-12-27 16:12:07" fixdate="2006-02-07 12:36:05" resolution="Fixed">
		<buginformation>
			<summary>Authentication.getAuthorities should return a collection rather than an array.</summary>
			<description>Currently Authentication.getAuthorities returns a GrantedAuthority[]. This is dangerous because calling code can accidentaly or deliberatly modify elements of the array to anything.
This method should really return an unmodifiable collection. Alternatly class instances could return a clone of the array.</description>
			<version>0.8.2</version>
			<fixedVersion>1.0.0 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.adapters.AuthByAdapterTests.java</file>
			<file type="M">org.acegisecurity.providers.TestingAuthenticationTokenTests.java</file>
			<file type="M">org.acegisecurity.providers.anonymous.AnonymousAuthenticationTokenTests.java</file>
			<file type="M">org.acegisecurity.providers.rememberme.RememberMeAuthenticationToken.java</file>
			<file type="M">org.acegisecurity.providers.cas.CasAuthenticationToken.java</file>
			<file type="M">org.acegisecurity.MockRunAsAuthenticationToken.java</file>
			<file type="M">org.acegisecurity.adapters.AbstractAdapterAuthenticationToken.java</file>
			<file type="M">org.acegisecurity.runas.RunAsUserToken.java</file>
			<file type="M">org.acegisecurity.providers.smb.NtlmAuthenticationToken.java</file>
			<file type="M">org.acegisecurity.providers.cas.CasAuthenticationTokenTests.java</file>
			<file type="M">org.acegisecurity.providers.AbstractAuthenticationToken.java</file>
			<file type="M">org.acegisecurity.providers.rememberme.RememberMeAuthenticationTokenTests.java</file>
			<file type="M">org.acegisecurity.runas.RunAsUserTokenTests.java</file>
			<file type="M">org.acegisecurity.providers.x509.X509AuthenticationToken.java</file>
			<file type="M">org.acegisecurity.providers.TestingAuthenticationToken.java</file>
			<file type="M">org.acegisecurity.providers.anonymous.AnonymousAuthenticationToken.java</file>
			<file type="M">org.acegisecurity.Authentication.java</file>
			<file type="M">org.acegisecurity.providers.UsernamePasswordAuthenticationToken.java</file>
			<file type="M">org.acegisecurity.providers.AbstractAuthenticationTokenTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="168" opendate="2006-02-03 08:28:45" fixdate="2006-02-07 14:41:49" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentSessionFilter breaks authenticate with: Authentication.getDetails() required</summary>
			<description>Acegi works fine for me in my environment. 
Now i wanted to avoid concurrent logins and followed the steps described at: http://acegisecurity.org/docbook/acegi.html#security-authentication-concurrent-login
Now, when I try to login with the same code that worked before, I get an exception:
Caused by: java.lang.IllegalArgumentException: Authentication.getDetails() required
	at org.springframework.util.Assert.notNull(Assert.java:90)
	at org.acegisecurity.concurrent.SessionRegistryUtils.obtainSessionIdFromAuthentication(SessionRegistryUtils.java:48)
	at org.acegisecurity.concurrent.ConcurrentSessionControllerImpl.checkAuthenticationAllowed(ConcurrentSessionControllerImpl.java:100)
	at org.acegisecurity.providers.ProviderManager.doAuthentication(ProviderManager.java:209)
	at org.acegisecurity.AbstractAuthenticationManager.authenticate(AbstractAuthenticationManager.java:49)
Here is the code snippet:
		Authentication lAuthReq = new UsernamePasswordAuthenticationToken(pUsername, pPassword);
		Authentication lAuth = null;
		lAuth = getAuthenticationManager().authenticate(lAuthReq);
Without the concurrent session filter it works perfectly...</description>
			<version>1.0.0 RC1</version>
			<fixedVersion>1.0.0 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.java</file>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilter.java</file>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilterTests.java</file>
			<file type="M">org.acegisecurity.providers.anonymous.AnonymousProcessingFilter.java</file>
			<file type="M">org.acegisecurity.providers.anonymous.AnonymousAuthenticationToken.java</file>
		</fixedFiles>
	</bug>
	<bug id="174" opendate="2006-02-07 06:45:42" fixdate="2006-02-07 14:58:55" resolution="Fixed">
		<buginformation>
			<summary>IE6 redirect bug in AuthenticationProcessingFilterEntryPoint</summary>
			<description>An application using the attached config files has redirect problems for Windows clients using IE (but not FireFox) if the server is configured to use ports other than 80 and 443 for HTTP and HTTPS respectively. This issue has been addressed in Acegi in other places (such as ExceptionTranslationFilter, RetryWithHttpsEntryPoint ... etc). A patch for AuthenticationProcessingFilterEntryPoint is attached which resolves this issue (tested with Tomcat 5.5 running on a Linux box with IE/Win, FireFox 1.5/Win, FireFox 1.5 Linux as clients).
It should be noted that this bit of code appears in multiple places - and they aren&amp;amp;apos;t all exactly the same.</description>
			<version>1.0.0 RC2</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.webapp.AuthenticationProcessingFilterEntryPointTests.java</file>
			<file type="M">org.acegisecurity.ui.webapp.AuthenticationProcessingFilterEntryPoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="164" opendate="2006-01-30 01:51:42" fixdate="2006-02-07 15:32:26" resolution="Fixed">
		<buginformation>
			<summary>X509AuthenticationProvider does not keep authentication details</summary>
			<description>When the provider authenticates a principal, that last statement reads
  return new X509AuthenticationToken(user, clientCertificate,
                user.getAuthorities());
whereas the AbstractUserDetailsAuthenticationProvider does
   result.setDetails((authentication.getDetails() != null)
            ? authentication.getDetails() : null);
The X509AuthenticationProvider should &amp;amp;apos;copy&amp;amp;apos; the authentication details to the returned object.</description>
			<version>1.0.0 RC1</version>
			<fixedVersion>1.0.0 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.x509.X509AuthenticationProvider.java</file>
		</fixedFiles>
	</bug>
	<bug id="159" opendate="2006-01-25 23:04:40" fixdate="2006-02-08 09:56:53" resolution="Fixed">
		<buginformation>
			<summary>SecurityContextHolder may cause a memory leak on app re-deployment</summary>
			<description>The context thread local reference may prevent an application classloader from being garbage collected
http://forum.springframework.org/showthread.php?t=21144</description>
			<version>0.8.2</version>
			<fixedVersion>1.0.0 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.taglibs.velocity.AuthzImplAuthorizeTagTest.java</file>
			<file type="M">org.acegisecurity.ui.digestauth.DigestProcessingFilterTests.java</file>
			<file type="M">org.acegisecurity.context.rmi.ContextPropagatingRemoteInvocationTests.java</file>
			<file type="M">org.acegisecurity.taglibs.authz.AuthorizeTagAttributeTests.java</file>
			<file type="M">org.acegisecurity.context.SecurityContextHolder.java</file>
			<file type="M">org.acegisecurity.taglibs.authz.AuthorizeTagCustomGrantedAuthorityTests.java</file>
			<file type="M">org.acegisecurity.taglibs.authz.AuthorizeTagExpressionLanguageTests.java</file>
			<file type="M">org.acegisecurity.ui.ExceptionTranslationFilterTests.java</file>
			<file type="M">org.acegisecurity.ui.AbstractProcessingFilterTests.java</file>
			<file type="M">org.acegisecurity.providers.anonymous.AnonymousProcessingFilterTests.java</file>
			<file type="M">org.acegisecurity.ui.basicauth.BasicProcessingFilterTests.java</file>
			<file type="M">org.acegisecurity.context.rmi.ContextPropagatingRemoteInvocation.java</file>
			<file type="M">org.acegisecurity.providers.jaas.SecurityContextLoginModuleTests.java</file>
			<file type="M">org.acegisecurity.taglibs.authz.AuthorizeTagTests.java</file>
			<file type="M">org.acegisecurity.ui.rememberme.RememberMeProcessingFilterTests.java</file>
			<file type="M">org.acegisecurity.intercept.web.FilterSecurityInterceptorTests.java</file>
			<file type="M">org.acegisecurity.captcha.CaptchaChannelProcessorTemplateTests.java</file>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilter.java</file>
			<file type="M">org.acegisecurity.taglibs.velocity.AuthzImplAttributeTest.java</file>
			<file type="M">samples.contacts.src.main.java.sample.contact.ClientApplication.java</file>
		</fixedFiles>
	</bug>
	<bug id="158" opendate="2006-01-25 22:57:12" fixdate="2006-02-08 14:25:33" resolution="Fixed">
		<buginformation>
			<summary>X.509 Auth token should adopt standard behaviour w.r.t. authenticated property</summary>
			<description>http://forum.springframework.org/showthread.php?t=21453</description>
			<version>0.8.2</version>
			<fixedVersion>1.0.0 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.x509.X509AuthenticationToken.java</file>
		</fixedFiles>
	</bug>
	<bug id="183" opendate="2006-02-09 08:58:38" fixdate="2006-02-09 09:02:01" resolution="Fixed">
		<buginformation>
			<summary>Avoid unnecessary HttpSession creation when using Anonymous and Remember-Me authentication</summary>
			<description>A small number of users use HttpSessionContextIntegrationFilter.allowSessionCreation = false, as they are using an authentication mechanism (such as BASIC) which relies upon the user agent for representing authentication information on each web request. For such users, changes made as part of SEC-168 and SEC-182 will cause issues because these changes will always create a HttpSession (in order to obtain a Session ID that in turn was needed by the concurrent session capabilities).</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.java</file>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilter.java</file>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilterTests.java</file>
			<file type="M">org.acegisecurity.providers.anonymous.AnonymousProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">233</link>
		</links>
	</bug>
	<bug id="188" opendate="2006-02-11 16:27:33" fixdate="2006-02-11 16:29:39" resolution="Fixed">
		<buginformation>
			<summary>SecurityContextHolder JavaDoc error</summary>
			<description>From acegisecurity-developer:
Javadoc for org.acegisecurity.context.SecurityContextHolder: "Associates a
given SecurityContext with the current execution thread and any new threads
the current execution thread may spawn." It can confuse users, as I know
InheritableThreadLocal no longer used in SecurityContextHolder, so
SecurityContext will not be associated with new threads which current
execution thread may spawn.</description>
			<version>0.9.0</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.context.SecurityContextHolder.java</file>
		</fixedFiles>
	</bug>
	<bug id="192" opendate="2006-02-19 08:42:38" fixdate="2006-02-19 10:38:29" resolution="Fixed">
		<buginformation>
			<summary>Concurrent login checking fails with CAS</summary>
			<description>http://forum.springframework.org/showthread.php?t=22422
The CAS authentication provider should call setDetails on the newly created CASAuthenticationToken. Alternatively, this could be done somewhere like AbstractAuthenticationProvider.authenticate, since it is probably common to all providers. Something like:
    public final Authentication authenticate(Authentication authentication)
        throws AuthenticationException {
        try {
            Authentication result = doAuthentication(authentication);
            if(result.getDetails() == null) 
{
               result.setDetails(authenitication.getDetails());
            }
        } catch (AuthenticationException e) 
{
            e.setAuthentication(authentication);
            throw e;
        }
    }</description>
			<version>0.9.0</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.digestauth.DigestProcessingFilter.java</file>
			<file type="M">org.acegisecurity.concurrent.ConcurrentSessionControllerImplTests.java</file>
			<file type="M">org.acegisecurity.ui.webapp.AuthenticationProcessingFilter.java</file>
			<file type="M">org.acegisecurity.ui.switchuser.SwitchUserProcessingFilter.java</file>
			<file type="M">org.acegisecurity.ui.cas.CasProcessingFilter.java</file>
			<file type="M">org.acegisecurity.ui.webapp.SiteminderAuthenticationProcessingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="215" opendate="2006-03-09 20:29:55" fixdate="2006-04-16 03:11:52" resolution="Fixed">
		<buginformation>
			<summary>FilterBasedLdapUserSearch creates invalid DN</summary>
			<description>The current Implementation of FilterBasedLdapUserSearch in HEAD will create create DNs that have a invalid comma character at the end of the final DN. E.g. "cn=Stefan Podkowinski,ou=people,dc=my,dc=org,"
Please change the following lines in
acegisecurity/acegisecurity/core/src/main/java/org/acegisecurity/providers/ldap/search/FilterBasedLdapUserSearch.java
from
userDn.append(",");
userDn.append(ctx.getNameInNamespace());
to
String nameInNS = ctx.getNameInNamespace();
if(nameInNS != null &amp;amp;&amp;amp; nameInNS.length() &amp;gt; 0) {
   userDn.append(",");
   userDn.append(nameInNS);
}
</description>
			<version>1.0.0 RC2</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ldap.search.FilterBasedLdapUserSearch.java</file>
		</fixedFiles>
	</bug>
	<bug id="202" opendate="2006-02-28 03:17:24" fixdate="2006-04-16 03:14:11" resolution="Fixed">
		<buginformation>
			<summary>Failing to set manager password on DefaultInitialDirContextFactory causes NullPointerException</summary>
			<description>The password should be set to some default value in the class, e.g. "manager_password_not_set"</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.ldap.DefaultInitialDirContextFactory.java</file>
			<file type="M">org.acegisecurity.providers.ldap.DefaultInitialDirContextFactoryTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="230" opendate="2006-03-15 08:07:20" fixdate="2006-04-23 22:38:27" resolution="Duplicate">
		<buginformation>
			<summary>ExceptionTranslationFilter does not catch AccessDeniedException with Spring MVC M2/M3</summary>
			<description>I am writing a SpringMVC-based web application with Acegi Security.  I have a Spring Controller object that invokes a method that is protected by an Acegi MethodSecurityInterceptor.  When the MethodSecurityInterceptor throws an AccessDeniedException, it is getting wrapped by the Spring FrameworkServlet in a org.springframework.web.util.NestedServletException.  Because of this wrapping, the ExceptionTranslationFilter never catches an AccessDeniedException, thus causing a 500 server error to bubble up instead of a 403/redirect to authenticationEntryPoint. 
I&amp;amp;apos;m not sure whose problem this is - the Acegi code could inspect the root cause of the NestedServletException, or the FrameworkServlet could pass on RuntimeExceptions without wrapping. </description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.ExceptionTranslationFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">199</link>
		</links>
	</bug>
	<bug id="233" opendate="2006-03-22 05:57:18" fixdate="2006-04-23 23:32:22" resolution="Duplicate">
		<buginformation>
			<summary>AnonymousProcessingFilter - redundant creation of Authentication object causes IllegalStateException</summary>
			<description>In the finally block of the doFilter method, it seems the WebAuthenticationDetails object is created again in order to compare against the current Security Context&amp;amp;apos;s Authentication object to see that it has not changed over the course of the request.  This rendundant creation can potentially cause an IllegalStateException: a session cannot be created sine the response is commited.  The response may be commited anytime down the filter pipeline.  Why create another Authentication object just to check for equality.   A references should be held before the filter chain is invoked since this is the only safe time to create a session and that reference should be used for comparison after the filter chain returns.  This will avoid the unnessary and invalid creation of a session.  </description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.java</file>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilter.java</file>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilterTests.java</file>
			<file type="M">org.acegisecurity.providers.anonymous.AnonymousProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">183</link>
		</links>
	</bug>
	<bug id="222" opendate="2006-03-13 17:45:24" fixdate="2006-04-25 12:21:07" resolution="Fixed">
		<buginformation>
			<summary>AbstractAuthenticationToken Hashcode computation</summary>
			<description>The hashCode implementations in User as well as AbstractAuthenticationToken uses the MOD operator with the value 7. 
    public int hashCode() {
        int code = 2305;
        if (this.getAuthorities() != null) {
            for (int i = 0; i &amp;lt; this.getAuthorities().length; i++) 
{
                code = code * (this.getAuthorities()[i].hashCode() % 7);
            }
        }
        ...
This has the unfortunate result that when the hashCode of say a GrantedAuthority is dividable by 7, the result of the MOD will be zero. Since it multiplies all other results with itself, the hashCode will evaluate to zero.
I&amp;amp;apos;m not sure of the consequences of this, but since HttpSessionContextIntegrationFilter compares the hashCode of the SecurityContext before and after the filter chain, this could cause some unexpected behaviour.
The obvious question is how often a hashCode of a String evaluates to something dividable by 7. Well, it&amp;amp;apos;s actually pretty common. An empty password in the principal does, for example. So does "ROLE_General.ITS" and many others.</description>
			<version>0.8.2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.AbstractAuthenticationToken.java</file>
		</fixedFiles>
	</bug>
	<bug id="218" opendate="2006-03-12 20:37:57" fixdate="2006-04-25 12:28:38" resolution="Fixed">
		<buginformation>
			<summary>RememberMeProcessingFilter adds Authentication token to SecurityContextHolder after AuthenticationException</summary>
			<description>The RememberMeProcessingFilter always adds a valid Authentication Token to the SecurityContextHolder, even after a AuthenticationException.  For example :

user &amp;amp;apos;joebob&amp;amp;apos; can only have 1 login session at any time (via the ConcurrentSessionController)
person A logs in with &amp;amp;apos;joebob&amp;amp;apos; on his machine, and sets a cookie on his machine to remember his Authentication details
person A closes his browser and after 30 minutes his session in the acegi SessionRegistry times out
person B logs in with &amp;amp;apos;joebob&amp;amp;apos; on his machine - a valid login attempt as there are no other sessions for &amp;amp;apos;joebob&amp;amp;apos; at the moment
person A opens his browser and attempts to log in automatically with the cookie - and is granted access.  Even though his cookie is invalidated (rememberMeServices.loginFail(httpRequest, httpResponse) - he is still granted a valid authentication token for his session.

A fix is to return from doFilter before exiting the AuthenticationException catch block in RememberMeProcessingFilter, before the SecurityContextHolder is updated with a valid AuthenticationToken.
In general there seems to be a lot of potential overlap here with AbstractProcessingFilter, which seems to offer a lot more with successful and unsuccessful authentication attempts - such as offering a failure url to redirect to, and storing the AuthenticationException in the session.
I kinda get the feeling that the RememberMeProcesssingFilter should extend the AbstractProcessingFilter because of this, its just lacks the right hooks - attemptAuthentication only provides the HttpServletRequest, and both the request and response are required for the rememberMeServices.autoLogin() method.</description>
			<version>0.9.0</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.rememberme.RememberMeProcessingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="223" opendate="2006-03-13 18:16:08" fixdate="2006-04-25 12:31:41" resolution="Fixed">
		<buginformation>
			<summary>Performance of hashCode in AbstractAuthenticationToken</summary>
			<description>The hashCode implementation in AbstractAuthenticationToken calculates the hashCode of its authorities:
    public int hashCode() {
        int code = 2305;
        if (this.getAuthorities() != null) {
            for (int i = 0; i &amp;lt; this.getAuthorities().length; i++) 
{
                code = code * (this.getAuthorities()[i].hashCode() % 7);
            }
        }
        ...
There will be two calls to getAuthorities() for each GrantedAuthority. And this would happen every time hashCode is called on an AuthenticationToken that extends AbstractAuthenticationToken.
This would be fine if getAuthorities() simply returned a value, but it does more than that:
    public GrantedAuthority[] getAuthorities() {
        if (authorities == null) 
{
            return null;
        }

        GrantedAuthority[] copy = new GrantedAuthority[authorities.length];
        System.arraycopy(authorities, 0, copy, 0, authorities.length);
        return copy;
    }
The obvious fix for this unnecessary array copying is:
    public int hashCode() {
        int code = 2305;
        GrantedAuthority[] authorities = this.getAuthorities();
        if (authorities != null) {
            for (int i = 0; i &amp;lt; authorities.length; i++) 
{
                code = code * (authorities[i].hashCode() % 7);
            }
        }
        ...</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.AbstractAuthenticationToken.java</file>
		</fixedFiles>
	</bug>
	<bug id="190" opendate="2006-02-15 10:32:21" fixdate="2006-04-25 12:42:16" resolution="Fixed">
		<buginformation>
			<summary>CaptchaSecurityContextImpl needs to override hashcode()</summary>
			<description>The HttpSessionContextIntegrationFilter only stores the SecurityContext into the session if the context has "changed" during the filter chain. It uses the hashcode() method to determine if the context has "changed". However, CapchaSecurityContextImpl does not override the default hashcode implementation from SecurityContextImpl, and therefore always returns -1 (assuming the authentication is null), even though the context is human.</description>
			<version>0.9.0</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.captcha.CaptchaSecurityContextImplTests.java</file>
			<file type="M">org.acegisecurity.captcha.CaptchaSecurityContextImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="219" opendate="2006-03-13 00:59:22" fixdate="2006-04-25 13:23:45" resolution="Fixed">
		<buginformation>
			<summary>FilterInvocationDefinitionSourceEditor tokenizing of URLs</summary>
			<description>there is unable to process url like this one:
/useraction.do?action=register=ROLE_ANONYMOUS 
after proccesing acegi treat register as role name.
this
      // Tokenize the line into its name/value tokens
       String[] nameValue = StringUtils.delimitedListToStringArray(line,
                        "=");
       String name = nameValue[0];
       String value = nameValue[1];
change to this
    String name = StringUtils.substringBeforeLast( line, "=" );
    String value = StringUtils.substringAfterLast( line, "=" );
where is StringUtils - is apache commons lang 2.0 class
here is source of this methods
public static String substringBeforeLast(String str, String separator) {
    if (str == null || separator == null || str.length() == 0 ||
separator.length() == 0) 
{
        return str;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == -1) {        return str;    }
    return str.substring(0, pos);
}
public static String substringAfterLast(String str, String separator) {
    if (str == null || str.length() == 0) 
{
        return str;
    }
    if (separator == null || separator.length() == 0) 
{
        return EMPTY;
    }
    int pos = str.lastIndexOf(separator);
    if (pos == -1 || pos == (str.length() - separator.length())) {        return EMPTY;    }
    return str.substring(pos + separator.length());
}</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.intercept.web.FilterInvocationDefinitionSourceEditor.java</file>
		</fixedFiles>
	</bug>
	<bug id="243" opendate="2006-04-05 08:56:40" fixdate="2006-04-25 13:37:01" resolution="Fixed">
		<buginformation>
			<summary>SessionRegistryImpl.getAllSessions(Object) incorrectly includes expired and destroyed sessions</summary>
			<description>The function SessionRegistryImpl.getAllSessions(principal) returns all session associated with the principal, even it is marked as expired. This is in violation of the SessionRegistry interface contract.
The fix is to filter out any expired session information return by function sessionRegistry.getAllSessions(principal)</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.concurrent.SessionRegistryImplTests.java</file>
			<file type="M">org.acegisecurity.concurrent.ConcurrentSessionControllerImpl.java</file>
			<file type="M">org.acegisecurity.concurrent.SessionRegistryImpl.java</file>
			<file type="M">org.acegisecurity.concurrent.SessionRegistry.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">197</link>
		</links>
	</bug>
	<bug id="208" opendate="2006-03-06 01:34:54" fixdate="2006-04-25 13:54:47" resolution="Fixed">
		<buginformation>
			<summary>SessionRegistryImpl giving java.util.ConcurrentModificationException</summary>
			<description>When we load-tested the application, the following exception was produced:
java.util.ConcurrentModificationException
at java.util.HashMap$HashIterator.nextEntry(HashMap.j ava:787)
at java.util.HashMap$KeyIterator.next(HashMap.java:82 3)
at org.acegisecurity.concurrent.SessionRegistryImpl.g etAllSessions(SessionRegistryImpl.java:72)
at org.acegisecurity.concurrent.ConcurrentSessionCont rollerImpl.checkAuthenticationAllowed(ConcurrentSe ssionControllerImpl.java:103)
at org.acegisecurity.providers.ProviderManager.doAuth entication(ProviderManager.java:209)
at org.acegisecurity.AbstractAuthenticationManager.au thenticate(AbstractAuthenticationManager.java:49)
org.acegisecurity.concurrent.ConcurrentSessionControllerImpl.maximumSessions is set to 100,
and we used grinder (http://grinder.sourceforge.net/) to do the load testing.</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.concurrent.SessionRegistryImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="252" opendate="2006-04-21 02:15:08" fixdate="2006-04-25 14:00:30" resolution="Fixed">
		<buginformation>
			<summary>AbstractAuthenticationToken NullPointerException</summary>
			<description>On line 144 in method getName() the return statement produces a NullPointerException when trying to use X509 Authenticaito.  Whenever doFilter in X509ProcessingFilter is called and I do not have a certificate in the request (i.e. I am not on SSL) this code throws a NullPointerException which then causes a site error.
public String getName() {
        if (this.getPrincipal() instanceof UserDetails) 
{
            return ((UserDetails) this.getPrincipal()).getUsername();
        }

        return this.getPrincipal().toString(); 
    }
If the return statement is changed to check if the principal is null first we no longer have this issue. Example: return this.getPrincipal() == null ? "" : this.getPrincipal().toString();
Also, I have security degrade to LDAP with a form entry point for users that do not have a certificate set up.  As you can imagine this also produces a NullPointerException because there is no certificate.</description>
			<version>0.8.2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.AbstractAuthenticationToken.java</file>
		</fixedFiles>
	</bug>
	<bug id="197" opendate="2006-02-21 17:41:01" fixdate="2006-04-25 14:05:59" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentSessionController should count non-expired Sessions only</summary>
			<description>With ConcurrentSession support enabled, its very common for a user to close their browser without logging out, thereby locking themselves out of the app until their session expires.  
I have added a function to my admin to "logout" an active user, bascially calling SessionInformation.expireNow() for each session beloging to him.  
But, after doing this the user still can&amp;amp;apos;t logon because ConcurrentSessionController just counts how many SessionInformation objects are returned from getAllSessions.  Until the HttpSession expires or the logged out user hits the site again (triggering a HttpSession invalidation) the user cannot login again.  
If the ConcurrentSessionController.checkAuthenticationAllowed method counted non-expired sessions instead of all sessions, this would allow the user to log back in (even though he has an abondonded HttpSession) and continue to use the system.</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.concurrent.SessionRegistryImplTests.java</file>
			<file type="M">org.acegisecurity.concurrent.ConcurrentSessionControllerImpl.java</file>
			<file type="M">org.acegisecurity.concurrent.SessionRegistryImpl.java</file>
			<file type="M">org.acegisecurity.concurrent.SessionRegistry.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">243</link>
		</links>
	</bug>
	<bug id="199" opendate="2006-02-23 16:04:59" fixdate="2006-04-25 15:11:27" resolution="Fixed">
		<buginformation>
			<summary>Contacts sample throws NestedServletException (500) instead of Access denied! (403) page</summary>
			<description>Logged on as 
Manually entered URL http://localhost:8080/contacts/secure/del.htm?contactId=2
NB - You have to manually enter the URL, but still, the behaviour doesn&amp;amp;apos;t appear to be as intended
Tomcat throws:
org.springframework.web.util.NestedServletException: Request processing failed; nested exception is org.acegisecurity.AccessDeniedException: Access is denied
...
root cause
org.acegisecurity.AccessDeniedException: Access is denied</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.ExceptionTranslationFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="is depended on by">220</link>
			<link type="Duplicate" description="is duplicated by">230</link>
		</links>
	</bug>
	<bug id="253" opendate="2006-04-26 01:12:21" fixdate="2006-04-26 03:24:23" resolution="Fixed">
		<buginformation>
			<summary>UserDetails JdbcDaoImpl should check for no auths after calling addCustomAuthorities</summary>
			<description>In org.acegisecurity.userdetails.jdbc.JdbcDaoImpl the code checks for the user having no GrantedAuthorites before ever calling addCustomAuthorities. That check should be made after subclasses have had an opprotunity to grant custom authorities.
Begining with Line 183:
        List dbAuths = authoritiesByUsernameMapping.execute(user.getUsername());
        if (dbAuths.size() == 0) 
{
            throw new UsernameNotFoundException("User has no GrantedAuthority");
        }

        GrantedAuthority[] arrayAuths = {};

        addCustomAuthorities(user.getUsername(), dbAuths);


Should be:

        List dbAuths = authoritiesByUsernameMapping.execute(user.getUsername());

        addCustomAuthorities(user.getUsername(), dbAuths);

        if (dbAuths.size() == 0) {            throw new UsernameNotFoundException("User has no GrantedAuthority");        }

        GrantedAuthority[] arrayAuths = {};</description>
			<version>1.0.0 RC1</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.userdetails.jdbc.JdbcDaoImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="256" opendate="2006-04-27 17:42:26" fixdate="2006-04-27 17:43:09" resolution="Fixed">
		<buginformation>
			<summary>Contacts Sample does not use AcegiMessageSource</summary>
			<description>AcegiSecurityExceptions thrown by the Contacts sample fail to localize, due to a missing messageSource in the middle-tier application context.</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.AcegiMessageSource.java</file>
		</fixedFiles>
	</bug>
	<bug id="258" opendate="2006-04-30 06:44:56" fixdate="2006-04-30 06:47:17" resolution="Fixed">
		<buginformation>
			<summary>Use of URI class in LdapUtils is not compatible with JDK 1.3</summary>
			<description>URI is used to parse the Ldap url, but is not available in Java 1.3.</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ldap.LdapUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="268" opendate="2006-05-15 22:32:27" fixdate="2006-05-19 08:40:22" resolution="Fixed">
		<buginformation>
			<summary>Uninitialized app context problem in HttpSessionEventPublisher </summary>
			<description>We&amp;amp;apos;re having a problem on some particular versions of Oracle app server (but not on others, e.g. OC4J 9.0.4) where the application context hasn&amp;amp;apos;t been initialized when the contextInitialized method is called. According to the Javadocs for ServletContextListener, listeners will be notified before servlets and filters have been created. We&amp;amp;apos;re using a ContextLoaderServlet so it probably shouldn&amp;amp;apos;t work at all.
I&amp;amp;apos;d like to change the class to modify the way the app context reference is set, since it isn&amp;amp;apos;t actually needed until session initialization/destruction events are generated. This would perhaps mean calling getWebApplicationContext, rather than getRequiredWebApplicationContext in the contextInitialized method (logging a warning if the app context is null), caching the servlet context  and changing getContext from
    ApplicationContext getContext() 
{
       Assert.notNull(context, "setContext(...) never called, ApplicationContext must not be null");
        return context;
    }

to 
    ApplicationContext getContext() {
       if(context == null) 
{
            setContext( WebApplicationContextUtils.getRequiredWebApplicationContext(cachedServletContext) );       
       }
       return context;
    }
I guess the alternative would be to write a servlet version, similar to the Spring context loader, but that seems unnecessary.</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.session.HttpSessionEventPublisherTests.java</file>
			<file type="M">org.acegisecurity.ui.session.HttpSessionEventPublisher.java</file>
		</fixedFiles>
	</bug>
	<bug id="267" opendate="2006-05-11 08:42:47" fixdate="2006-05-22 21:42:20" resolution="Fixed">
		<buginformation>
			<summary>NamedEntityObjectIdentity not stripping cglib ehanced class names.</summary>
			<description>There is a bug in NamedEntityObjectIdentity that is causing me problems. I checked with the version in head and it still exists there.  Assuming your class has the cglib enhanced name 
    model.Site$$EnhancerByCGLIB$$378957af  
The ClassNameUtils.getShortName methids is called turning the above into  
   model.Site$$EnhancerByCGLIB$$378957af.Site 
Before its gets passed into the getPackageName method, which then just drops off the .Site giving you back  your original class name.
The problem, after chaseing my tail for a while, turns out to be the call to getPackageName(object.getClass().getName()) is not  closed.
This 
 public NamedEntityObjectIdentity(Object object)
        throws IllegalAccessException, InvocationTargetException {
        Assert.notNull(object, "object cannot be null");
        this.classname = (getPackageName(object.getClass().getName()) == null)
            ? ClassUtils.getShortName(object.getClass())
            : getPackageName(object.getClass().getName() + "."
                + ClassUtils.getShortName(object.getClass()));
Should be
 public NamedEntityObjectIdentity(Object object)
        throws IllegalAccessException, InvocationTargetException {
        Assert.notNull(object, "object cannot be null");
        this.classname = (getPackageName(object.getClass().getName()) == null)
            ? ClassUtils.getShortName(object.getClass())
            : getPackageName(object.getClass().getName()) + "."
                + ClassUtils.getShortName(object.getClass());</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.acl.basic.NamedEntityObjectIdentity.java</file>
		</fixedFiles>
	</bug>
	<bug id="266" opendate="2006-05-09 12:32:21" fixdate="2006-05-22 21:49:51" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentSessionControllerImpl doesn&amp;apos;t permit unlimited sessions</summary>
			<description>a value of -1 for maximumSessions in class ConcurrentSessionControllerImpl will throw a ConcurrentLoginException
code fragement  should also check for -1    
if (sessionCount &amp;lt; allowableSessions) {
                    return;</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.concurrent.ConcurrentSessionControllerImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="281" opendate="2006-05-30 12:46:18" fixdate="2006-05-31 03:41:01" resolution="Fixed">
		<buginformation>
			<summary>Acegi 1.0 final - not compatible with Spring 1.2.8</summary>
			<description>Hi - Luke suggested we raise a ticket about this.
When creating a bean of class org.acegisecurity.ldap.search.FilterBasedLdapUserSearch with Spring 1.2.8, I receive the following error:
org.springframework.beans.factory.BeanDefinitionStoreException: Error registering bean with name &amp;amp;apos;userSearch&amp;amp;apos; defined in ServletContext resource [/WEB-INF/applicationContext-acegi-security-omj.xml]: Class that bean class [org.acegisecurity.ldap.search.FilterBasedLdapUserSearch] depends on not found; nested exception is java.lang.NoClassDefFoundError: org/springframework/dao/EmptyResultDataAccessEx
ception
java.lang.NoClassDefFoundError: org/springframework/dao/EmptyResultDataAccessException
        at java.lang.Class.forName0(Native Method)..
Reference Matt Raible&amp;amp;apos;s forum post about the same issue: http://forum.springframework.org/showthread.php?t=25430&amp;amp;highlight=EmptyResultDataAccessException
Thank you</description>
			<version>1.0.0</version>
			<fixedVersion>1.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ldap.search.FilterBasedLdapUserSearch.java</file>
			<file type="M">org.acegisecurity.ldap.LdapTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="303" opendate="2006-06-14 03:42:12" fixdate="2006-06-14 10:09:10" resolution="Fixed">
		<buginformation>
			<summary>LdapUserDetailsMapper should check that an attribute has actually been retrieved before attempting to map it to a role</summary>
			<description>If a particular attribute has not been retrieved from the directory (e.g. because it doesn&amp;amp;apos;t exist, or the user doesn&amp;amp;apos;t have permissions to read it), then in the code
            Attribute roleAttribute = attributes.get(roleAttributes[i]);
            NamingEnumeration attributeRoles = roleAttribute.getAll();
roleAttribute may be null and the second line will cause  a NullPointerException. A check should be made that the value isn&amp;amp;apos;t null and a debug message logged if it is.</description>
			<version>1.0.0</version>
			<fixedVersion>1.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.userdetails.ldap.LdapUserDetailsMapper.java</file>
		</fixedFiles>
	</bug>
	<bug id="308" opendate="2006-06-29 03:03:56" fixdate="2006-07-11 21:30:57" resolution="Fixed">
		<buginformation>
			<summary>Lookup of headers in SavedRequestAwareWrapper is not case insensitive</summary>
			<description>According to the servlet spec, lookups using HttpServletRequest.getHeader and getHeaders should be case insensitive.  The current implementation of SavedRequest uses a HashMap to store saved headers.  The result is that the lookup of headers by name is case sensitive when SavedRequestAwareWrapper delegates to a SavedRequest.
We use a library that relies on the User-Agent header for rendering.  We experienced problems with rendering on the first page after login.  After debugging we found that the library was not able to get the correct value for the User-Agent due to the case sensitivity of the SavedRequest implementation.  I am attaching a patch that fixes this problem.  The patch is against the 1.0.1 tag.
After redirect after login:
request.getHeader("User-Agent") returns null;
request.getHeader("user-agent") returns the correct value;
Normal Request:
request.getHeader("User-Agent") returns the correct value;
request.getHeader("user-agent") returns the correct value;</description>
			<version>1.0.0</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.acegisecurity.ui.savedrequest.SavedCookieTest.java</file>
			<file type="M">org.acegisecurity.ui.savedrequest.SavedRequest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">315</link>
		</links>
	</bug>
	<bug id="321" opendate="2006-07-17 06:52:32" fixdate="2006-09-03 10:22:56" resolution="Fixed">
		<buginformation>
			<summary>PathBasedFilterInvocationDefinitionMap ignores text after the last question mark instead of the first</summary>
			<description>In some of our legacy code, we actually have URLs that contain successURLs as a request parameter. This means it is possible to have more than one question mark in the URL. For example,
/Register?cmd=initial&amp;amp;Security_steps=All&amp;amp;Security_successUrl=https://localhost/appName/servletName?cmd=Start
Check out line 89 and 90 of PathBasedFilterInvocationDefinitionMap:
// Strip anything after a question mark symbol, as per SEC-161.
int firstQuestionMarkIndex = url.lastIndexOf("?");
Should this be changed to
int firstQuestionMarkIndex = url.indexOf("?");
so that all query parameters are ignored?</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.intercept.web.PathBasedFilterDefinitionMapTests.java</file>
			<file type="M">org.acegisecurity.intercept.web.PathBasedFilterInvocationDefinitionMap.java</file>
		</fixedFiles>
	</bug>
	<bug id="315" opendate="2006-07-08 04:09:46" fixdate="2006-09-14 07:46:34" resolution="Fixed">
		<buginformation>
			<summary>SavedRequest header names are case insensitive</summary>
			<description>HTTP header names are case insensitive. We does not take it into account in org.acegisecurity.ui.savedrequest.SavedRequest 
We should reduce the header names to canonical form in the beginning of addHeader and getHeaderValues methods.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.acegisecurity.ui.savedrequest.SavedCookieTest.java</file>
			<file type="M">org.acegisecurity.ui.savedrequest.SavedRequest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">308</link>
		</links>
	</bug>
	<bug id="350" opendate="2006-09-13 23:37:07" fixdate="2006-09-14 14:00:41" resolution="Duplicate">
		<buginformation>
			<summary>Second access to database when NullUserCache is used</summary>
			<description>I am use DaoAuthenticationProvider.
When user enter right login and wrong  password, AbstractUserDetailsAuthenticationProvider makes 2 queries to database.
This happends when this class uses NullUserCache (by default) for user caching.
In these lines we load user details from database if there is no user in the cache (and remember that in cacheWasUsed) :
        UserDetails user = this.userCache.getUserFromCache(username);
        if (user == null) {
            cacheWasUsed = false;
            try 
{
                user = retrieveUser(username,
                    (UsernamePasswordAuthenticationToken) authentication);
                    ......
            }
....
        }
But when user enter wrong password we just load user one more time:
       // This check must come here, as we don&amp;amp;apos;t want to tell users
        // about account status unless they presented the correct credentials
        try 
{
            additionalAuthenticationChecks(user,
                (UsernamePasswordAuthenticationToken) authentication);
        }
 catch (AuthenticationException exception) 
{
            // There was a problem, so try again after checking we&amp;amp;apos;re using latest data
            cacheWasUsed = false;
            user = retrieveUser(username,
                    (UsernamePasswordAuthenticationToken) authentication);
            additionalAuthenticationChecks(user,
                (UsernamePasswordAuthenticationToken) authentication);
        }</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.dao.AbstractUserDetailsAuthenticationProvider.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">328</link>
		</links>
	</bug>
	<bug id="311" opendate="2006-07-05 00:18:13" fixdate="2006-09-14 14:09:22" resolution="Fixed">
		<buginformation>
			<summary>equals(Object object) in SecurityConfig does not obey symmetry requirement of the interface contract</summary>
			<description>The SecurityConfig.equals(Object object) method violates the symmetry requirement imposed by the Object.equals(Object object) contract. If the &amp;amp;apos;other&amp;amp;apos; Object is a String, it compares that String to the attribute String stored in the SecurityConfig.
Consider the following situation:
[code]
String myString = "CONFIG";
SecurityConfig myConfig = new SecurityConfig("CONFIG");
[/code]
While [code]myConfig.equals(myString)[/code] will return true, [code]myString.equals(myConfig)[/code] will return false, violating the equals symmetry.
I&amp;amp;apos;ve checked the 1.1-SNAPSHOT (via http://www.acegisecurity.org/multiproject/acegi-security/clover/org/acegisecurity/SecurityConfig.html) and the equals method of SecurityConfig apparently has not changed.</description>
			<version>1.0.0</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.securechannel.ChannelDecisionManagerImplTests.java</file>
			<file type="M">org.acegisecurity.SecurityConfigTests.java</file>
			<file type="M">org.acegisecurity.SecurityConfig.java</file>
		</fixedFiles>
	</bug>
	<bug id="293" opendate="2006-06-02 01:06:56" fixdate="2006-09-14 14:20:27" resolution="Fixed">
		<buginformation>
			<summary>BasicAclEntryAfterInvocationCollectionFilteringProvider causes ConcurrentModificationExceptio</summary>
			<description>The BasicAclEntryAfterInvocationCollectionFilteringProvider.CollectionFilterer has been modified is may 2005 to gain performance at the cost of risking a ConcurrentModificationException. The current version now unnecessary complex. In addition, the debug message no longer prints the correct original size.</description>
			<version>1.0.0</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.afterinvocation.BasicAclEntryAfterInvocationCollectionFilteringProvider.java</file>
		</fixedFiles>
	</bug>
	<bug id="341" opendate="2006-08-25 01:31:48" fixdate="2006-09-14 14:22:00" resolution="Duplicate">
		<buginformation>
			<summary>Retrieving User after AuthenticationException</summary>
			<description>In AbstractUserDetailsAuthenticationProvider the authenticate() method calls the additionalAuthenticationChecks() method in a try block and can catch an AuthenticationException.  The code in the catch block (line 147 for rel 1.0.1) calls the retrieveUser() and additionalAuthenticationChecks() methods.  If the user details used for the call in the try block came from the cache, I understand why this makes sense.  However, if cacheWasUsed is false, the call to retrieve the user details obtains the exact same user details.
Perhaps the catch block should only repeat those method calls if cacheWasUsed is true, and throws the caught AuthenticationException if cacheWasUsed is false.</description>
			<version>1.0.0</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.dao.AbstractUserDetailsAuthenticationProvider.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">328</link>
		</links>
	</bug>
	<bug id="290" opendate="2006-05-31 19:27:39" fixdate="2006-09-14 14:27:39" resolution="Fixed">
		<buginformation>
			<summary>MethodInvocationUtils.createFromClass creates wrong MethodInvocation</summary>
			<description>The utility class MethodInvocationUtils.createFromClass  creates a SimpleMethodInvocation but uses the parameter types as the object arguments. The proper signature should be: createFromClass(Class clazz, String methodName, Class[] classArgs, Object[] args).
Impact is low because this class is not used in critical places.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.intercept.method.MethodInvocationPrivilegeEvaluatorTests.java</file>
			<file type="M">org.acegisecurity.util.MethodInvocationUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="328" opendate="2006-07-27 19:49:15" fixdate="2006-09-14 14:37:09" resolution="Fixed">
		<buginformation>
			<summary>AbstractUserDetailsAuthenticationProvider makes two hits when no cache is used</summary>
			<description>if you look at AbstractUserDetailsAuthenticationProvider.authenticate, you&amp;amp;apos;ll notice that in case of failure, Acegi suppose that it is due to a cache synchronization problem and make a second retrieveUser.
But if you use no cache, your information were already up to date and retrieveUser is still called...
I think that this snippet (l. 148-151):
 // There was a problem, so try again after checking we&amp;amp;apos;re using latest data
cacheWasUsed = false;
user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);
additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);
has to be changed to that :
if(cacheWasUsed) 
{
            // There was a problem, so try again after checking we&amp;amp;apos;re using latest data
            cacheWasUsed = false;
            user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);
            additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);
 }
 else {
            throw exception
}
It&amp;amp;apos;ll avoid an useless double check...</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.dao.AbstractUserDetailsAuthenticationProvider.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">350</link>
			<link type="Duplicate" description="is duplicated by">341</link>
		</links>
	</bug>
	<bug id="349" opendate="2006-09-12 22:49:56" fixdate="2006-09-14 14:42:26" resolution="Fixed">
		<buginformation>
			<summary>RememberMeAuthenticationToken throws IllegalArgumentException on empty authorities list</summary>
			<description>When a user is authenticated via remember me, in RememberMeAuthenticationToken:56 (called from TokenBasedRememberMeServices:190) an IllegalArgumentException is thrown if the user object has no authorities granted. This is inconsistent with other authentication schemes which allow authentications without granted authorities. I can&amp;amp;apos;t see any reason for throwing an exception in this case, because nothing is wrong with a user who is signed in and gets no authorities granted.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.rememberme.RememberMeAuthenticationTokenTests.java</file>
			<file type="M">org.acegisecurity.providers.rememberme.RememberMeAuthenticationToken.java</file>
		</fixedFiles>
	</bug>
	<bug id="330" opendate="2006-08-01 21:27:48" fixdate="2006-09-14 14:48:08" resolution="Fixed">
		<buginformation>
			<summary>UserMap should work with UserDetails, not User concrete class</summary>
			<description>The UserMap.getUser method returns a User object, however the UserMap.addUser method takes in the UserDetails interface as a parameter.so if a user-defined class that implements the UserDetails interface is used a ClassCastException is exception is thrown since the object will not be of type Uer.
The suggested change to the getUser method is return the UserDetails interface along with actually changing the implementation of the getUserMethod from:
     public User getUser(String username) throws UsernameNotFoundException {
        User result = (User) this.userMap.get(username.toLowerCase());
        if (result == null) 
{
            throw new UsernameNotFoundException("Could not find user: "
                + username);
        }
        return result;
    }
To 
    public User getUser(String username) throws UsernameNotFoundException {
        UserDetails result = (UserDetails) this.userMap.get(username.toLowerCase());
        if (result == null) 
{
            throw new UsernameNotFoundException("Could not find user: "
                + username);
        }
        return result;
    }</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.userdetails.memory.UserMap.java</file>
		</fixedFiles>
	</bug>
	<bug id="324" opendate="2006-07-20 06:04:33" fixdate="2006-09-14 18:56:19" resolution="Fixed">
		<buginformation>
			<summary>AccessDeniedHandlerImpl always throws IllegalStateException</summary>
			<description>Response status is being set after forwarding to the error page.  Logs are being filled with java.lang.IllegalStateExceptions.
Currently:
 rd.forward(request, response);
 ((HttpServletResponse) response).setStatus(HttpServletResponse.SC_FORBIDDEN);
Should be?:
((HttpServletResponse) response).setStatus(HttpServletResponse.SC_FORBIDDEN);
 rd.forward(request, response);
Stack trace:
2006-07-20 14:27:44,114 ERROR org.acegisecurity.ui.AccessDeniedHandlerImpl - Error processing org.acegisecurity.wrapper.SavedRequestAwareWrapper@52bd52bd
java.lang.IllegalStateException: ERROR: Cannot set header. Response already committed.
	at java.lang.Throwable.&amp;lt;init&amp;gt;(Throwable.java)
	at java.lang.Throwable.&amp;lt;init&amp;gt;(Throwable.java)
	at com.ibm.ws.webcontainer.srt.SRTServletResponse.setStatus(SRTServletResponse.java:931)
	at org.acegisecurity.ui.AccessDeniedHandlerImpl.handle(AccessDeniedHandlerImpl.java)
	at org.acegisecurity.ui.ExceptionTranslationFilter.handleException(ExceptionTranslationFilter.java:166)
	at org.acegisecurity.ui.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
	at org.acegisecurity.providers.anonymous.AnonymousProcessingFilter.doFilter(AnonymousProcessingFilter.java:125)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
	at org.acegisecurity.ui.rememberme.RememberMeProcessingFilter.doFilter(RememberMeProcessingFilter.java:142)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
	at org.acegisecurity.wrapper.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:81)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
	at org.acegisecurity.ui.AbstractProcessingFilter.doFilter(AbstractProcessingFilter.java:217)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
	at org.acegisecurity.ui.logout.LogoutFilter.doFilter(LogoutFilter.java:108)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
	at org.acegisecurity.context.HttpSessionContextIntegrationFilter.doFilter(HttpSessionContextIntegrationFilter.java:191)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
	at org.acegisecurity.util.FilterChainProxy.doFilter(FilterChainProxy.java:148)
	at org.acegisecurity.util.FilterToBeanProxy.doFilter(FilterToBeanProxy.java:90)</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.AccessDeniedHandlerImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="338" opendate="2006-08-22 01:40:55" fixdate="2006-09-14 19:38:05" resolution="Fixed">
		<buginformation>
			<summary>Serialization Issues for Authentication implementations</summary>
			<description>When used in a distributed environment, several Serialization issues have appeared. 
1. GrantedAuthority interface does not implement serializable, thus poses a potential problem for its implementations, when being sent over the wire.
2. Authentication implementations do not explicitly overwride the serialVersionUID, which have caused a Serialization exception when different patch versions of acegi where loaded in the VM on different ends of the wire (1.0.0 and 1.0.1).  The problem was the AnonymousAuthenticationToken object which had an extra constructor added in one and not the other, but potential exists that any future minor or patch releases of the same major could alter the structure of the class, thus preventing it to serialize to a backwards-compatable lower version.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.GrantedAuthorityImpl.java</file>
			<file type="M">org.acegisecurity.providers.rememberme.RememberMeAuthenticationToken.java</file>
			<file type="M">org.acegisecurity.providers.cas.CasAuthenticationToken.java</file>
			<file type="M">org.acegisecurity.userdetails.User.java</file>
			<file type="M">org.acegisecurity.ui.switchuser.SwitchUserGrantedAuthority.java</file>
			<file type="M">org.acegisecurity.runas.RunAsUserToken.java</file>
			<file type="M">org.acegisecurity.providers.jaas.JaasGrantedAuthority.java</file>
			<file type="M">org.acegisecurity.adapters.PrincipalAcegiUserToken.java</file>
			<file type="M">org.acegisecurity.providers.x509.X509AuthenticationToken.java</file>
			<file type="M">org.acegisecurity.providers.TestingAuthenticationToken.java</file>
			<file type="M">org.acegisecurity.GrantedAuthority.java</file>
			<file type="M">org.acegisecurity.providers.anonymous.AnonymousAuthenticationToken.java</file>
			<file type="M">org.acegisecurity.adapters.jetty.JettyAcegiUserToken.java</file>
			<file type="M">org.acegisecurity.providers.UsernamePasswordAuthenticationToken.java</file>
			<file type="M">org.acegisecurity.providers.jaas.JaasAuthenticationToken.java</file>
			<file type="M">org.acegisecurity.userdetails.ldap.LdapUserDetailsImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="348" opendate="2006-09-08 05:23:12" fixdate="2006-09-28 19:43:45" resolution="Fixed">
		<buginformation>
			<summary>CASProvider tries to autenticate on every request</summary>
			<description>I am using CAS provider with a httpinvoker based swing client, that sends _cas_stateless as
username and a ST as password (obtained directly from CAS). In the server side I use 
two filters: httpsessionintegrationFilter and basicProcessingFilter.
In the first time the basicProcessingFilter validates the ticket against CAS, and the
sessionIntegration filter puts the autentication in the session, as desired.
The next time, the client sends the same jsessionId, the httpsessionintegrationfilter 
corretly extracts the context from the previously created session but basic processing
filter tries to autenticate again (validade CAS ST AGAIN).
The line 138 of the class BasicProcessingFilter, it checks if it need to reauthenticate 
by checking (among other things) if the existingAuths username (obtained from session) is 
equals to the username that came from the HTTP Header. If they are not equal, the filter tries
to reauthenticate. Since http headers username is always equals to "cas_stateless" and
existingAuths username is equals to the auhtenticated user, they are never the same, and the 
basicprocessingfilter will try to validade the ticket again. The correct behaviour would be
to just revalidate the ticket when the session does not carry a valid authentication anymore.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.basicauth.BasicProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="depends on">53</link>
		</links>
	</bug>
	<bug id="297" opendate="2006-06-05 19:27:55" fixdate="2006-09-28 19:46:36" resolution="Fixed">
		<buginformation>
			<summary>defaultTargetUrl Scheme</summary>
			<description>Documentation regarding inclusion of http://or https:// scheme in the defaultTargetUrl :
defaultTargetUrl indicates the URL that should be used for redirection if the HttpSession attribute named ACEGI_SAVED_REQUEST_KEY does not indicate the target URL once authentication is completed successfully. eg: /. The defaultTargetUrl will be treated as relative to the web-app&amp;amp;apos;s context path, and should include the leading /. Alternatively, inclusion of a scheme name (eg http:// or https://) as the prefix will denote a fully-qualified URL and this is also supported.
Snippet of acegi configuration file:
    &amp;lt;bean id="authenticationProcessingFilter" class="org.acegisecurity.ui.webapp.AuthenticationProcessingFilter"&amp;gt;
        &amp;lt;property name="authenticationManager"&amp;gt;&amp;lt;ref local="authenticationManager"/&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name="authenticationFailureUrl"&amp;gt;&amp;lt;value&amp;gt;/login.do?error=true&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name="defaultTargetUrl"&amp;gt;&amp;lt;value&amp;gt;https://bpz.fluxweb.com/ctxroot/home.do?method=home&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name="filterProcessesUrl"&amp;gt;&amp;lt;value&amp;gt;/j_security_check&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
However the defaultTargetUrl is always prefixed with the context root (based on the debugging information below):
[app] DEBUG [TP-Processor2] AbstractProcessingFilter.successfulAuthentication(384) | Redirecting to target URL from HTTP Session (or default): /ctxroothttps://bpz.fluxweb.com/ctxroot/home.do?method=home</description>
			<version>1.0.0</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.AbstractProcessingFilter.java</file>
			<file type="M">org.acegisecurity.ui.AbstractProcessingFilterTests.java</file>
			<file type="M">org.acegisecurity.ui.webapp.SiteminderAuthenticationProcessingFilterTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">355</link>
		</links>
	</bug>
	<bug id="361" opendate="2006-09-24 05:21:56" fixdate="2006-11-12 07:23:16" resolution="Duplicate">
		<buginformation>
			<summary>&lt;auth:authorize ifNotGranted="ROLE_ANONYMOUS"&gt; doesn&amp;apos;t work sometimes</summary>
			<description>web.xml:
...........
&amp;lt;error-page&amp;gt;
  &amp;lt;error-code&amp;gt;404&amp;lt;/error-code&amp;gt;
  &amp;lt;location&amp;gt;/common/documentnotfound.do&amp;lt;/location&amp;gt;
&amp;lt;/error-page&amp;gt;
...........
If the requested page not found tomcat redirect user to the pointed url (documentnotfount.do) and in this case &amp;lt;auth:authorize ifNotGranted="ROLE_ANONYMOUS"&amp;gt; doesn&amp;amp;apos;t work.
SecurityContextHolder.getContext() = org.acegisecurity.context.SecurityContextImpl@ffffffff: Null authentication (AuthorizeTag.java: 129)
SecurityContextHolder.getContext().getAuthentication() = null (AuthorizeTag.java: 129)
granted = [] (AuthorizeTag.java: 80)
evaledIfNotGranted = ROLE_ANONYMOUS (AuthorizeTag.java: 82)
grantedCopy = [] (AuthorizeTag.java: 86)</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilter.java</file>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilterTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">305</link>
		</links>
	</bug>
	<bug id="364" opendate="2006-09-27 08:11:06" fixdate="2006-11-12 07:31:42" resolution="Fixed">
		<buginformation>
			<summary>TokenBasedRememberMeServices not properly using context path when setting cookie paths (SEC-206 only partially fixed) </summary>
			<description>SEC-206 addressed an issue to ensure the context path is properly used when setting remember me cookie paths by using the code:
cookie.setPath(request.getContextPath());
However, http://java.sun.com/j2ee/1.4/docs/api/javax/servlet/http/HttpServletRequest.html#getContextPath() states that &amp;amp;apos;For servlets in the default (root) context, this method returns "" &amp;amp;apos;.
An empty cookie path results in inconsistent behavior between ie and firefox: ie presumes "/" whereas firefox presumes the leading path for the current request.
If request.getContextPath() returns "", the cookie path should be set to "/" to properly reflect a cookie set for the root context.
This fix should be applied to both methods: makeValidCookie and makeCancelCookie of TokenBasedRememberMeServices.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="depends on">206</link>
		</links>
	</bug>
	<bug id="375" opendate="2006-10-11 05:33:20" fixdate="2006-11-12 08:05:56" resolution="Fixed">
		<buginformation>
			<summary>AuthorizedEvent published by before filter but not by after filter</summary>
			<description>All of the interceptors (filter, method, aspectj) do a before pass and an after pass on the request. 
The before and after filtering methods are shared among the filtere and are implemented in the base class AbstractSecurityInterceptor.
The method AbstractSecurityInterceptor.before publishes an AuthorizedEvent if the authorization is successful.
The method AbstractSecurityInterceptor.after 
    delegates to the afterInvocationManager
    if you use the AfterInfocationProviderManager, that invokes a List of Providers in turn.
There is no AuthorizedEvent published if the authorization succeeds.   To be consistent, the AuthorizedEvent should be published whenever the authorization succeeds. </description>
			<version>1.0.2</version>
			<fixedVersion>1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.event.authorization.AuthorizationFailureEvent.java</file>
			<file type="M">org.acegisecurity.intercept.AbstractSecurityInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="355" opendate="2006-09-19 11:44:19" fixdate="2006-11-12 09:00:09" resolution="Duplicate">
		<buginformation>
			<summary>Scheme not supported in AbstractProcessingFilter.defaultTargetUrl</summary>
			<description>The JavaDoc for AbstractProcessingFilter states that the defaultTargetUrl supports absolute URLs by starting with a scheme name (the JavaDoc says: The &amp;lt;code&amp;gt;defaultTargetUrl&amp;lt;/code&amp;gt; will be treated as relative to the web-app&amp;amp;apos;s context path, and should include the leading &amp;lt;code&amp;gt;/&amp;lt;/code&amp;gt;. Alternatively, inclusion of a scheme name (eg http:// or https://) as the prefix will denote a fully-qualified URL and this is also supported.)
However, the actual code that builds the redirect URL looks like:
            targetUrl = request.getContextPath() + getDefaultTargetUrl();
and therefore the full URL just gets appended to the contextPath.
As an aside, it would also be useful if the code for determining the targetUrl was factored out so that it could be overridden easily. 
Regards,
Damien</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.AbstractProcessingFilter.java</file>
			<file type="M">org.acegisecurity.ui.AbstractProcessingFilterTests.java</file>
			<file type="M">org.acegisecurity.ui.webapp.SiteminderAuthenticationProcessingFilterTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">297</link>
		</links>
	</bug>
	<bug id="371" opendate="2006-10-05 23:12:17" fixdate="2006-11-12 09:10:51" resolution="Fixed">
		<buginformation>
			<summary>AbstractTicketValidator should not use LogFactory.getLog(CasProxyTicketValidator.class)</summary>
			<description>The first line in org.acegisecurity.providers.cas.ticketvalidator.AbstractTicketValidator contains
LogFactory.getLog(CasProxyTicketValidator.class) 
It should probably use
LogFactory.getLog(AbstractTicketValidator.class).</description>
			<version>1.0.2</version>
			<fixedVersion>1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.cas.ticketvalidator.AbstractTicketValidator.java</file>
		</fixedFiles>
	</bug>
	<bug id="325" opendate="2006-07-22 01:51:05" fixdate="2006-11-12 09:14:21" resolution="Duplicate">
		<buginformation>
			<summary>Add support for Groups</summary>
			<description>http://forum.springframework.org/showthread.php?p=53307
&amp;lt;quote from="raible"&amp;gt;I attended a BOF at The Spring Experience where there was much debate about having a "Groups" concept in Acegi. Colin was for it, Ben against. However, in the end, I believe Ben said it&amp;amp;apos;d only take 10 minutes to add - so he&amp;amp;apos;d do it.&amp;lt;/quote&amp;gt;
&amp;lt;quote from="alex"&amp;gt;It&amp;amp;apos;s a semantic thing. People who want an "administrative" / "management" interface for security would like to see groups etc. I would not modify the GrantedAuthority concept to not recognise groups - I would merely add a GROUP table which the out-of-the-box DAOs would recognise and then generate additional GrantedAuthority[]s accordingly.&amp;lt;/quote&amp;gt;</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.3</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.security.userdetails.GroupsManager.java</file>
			<file type="M">org.springframework.security.userdetails.jdbc.JdbcUserDetailsManagerTests.java</file>
			<file type="M">org.springframework.security.userdetails.jdbc.JdbcUserDetailsManager.java</file>
			<file type="M">org.springframework.security.userdetails.jdbc.JdbcDaoImpl.java</file>
			<file type="M">org.springframework.security.PopulatedDatabase.java</file>
			<file type="M">org.springframework.security.userdetails.jdbc.JdbcDaoImplTests.java</file>
			<file type="M">org.acegisecurity.PopulatedDatabase.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">272</link>
		</links>
	</bug>
	<bug id="359" opendate="2006-09-22 15:48:18" fixdate="2006-11-12 16:05:51" resolution="Fixed">
		<buginformation>
			<summary>LogoutFilter ordering</summary>
			<description>When a user does not have a session and attempts to logout, the LogoutFilter does nothing.  The is because the Authentication object returned from the SessionContext is null
            Authentication auth = SecurityContextHolder.getContext().getAuthentication();
            if (logger.isDebugEnabled()) 
{
                logger.debug("Logging out user &amp;amp;apos;" + auth + "&amp;amp;apos; and redirecting to logout page");
            }

            if (auth != null) {
                for (int i = 0; i &amp;lt; handlers.length; i++) 
{
                    handlers[i].logout(httpRequest, httpResponse, auth);
                }
            }
This happens because the SecurityContext was not read from the Session and the filters that make it available have not executed yet.
By moving the logoutFilter to after the rememberMeFilter, the problem seems to be resolved:
httpSessionContextIntegrationFilter,authenticationProcessingFilter,basicProcessingFilter,contextHolderAwareRequestFilter,rememberMeProcessingFilter,logoutFilter,anonymousProcessingFilter,exceptionTranslationFilter,filterInvocationInterceptor
Regards,
Damien</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.logout.LogoutFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="356" opendate="2006-09-20 00:35:43" fixdate="2006-11-13 10:44:49" resolution="Fixed">
		<buginformation>
			<summary>Changes to Authentication leak into synchronous requests when using HttpSessionContextIntegrationFilter</summary>
			<description>HttpSessionContextIntegrationFilter will read an existing SecurityContext object from the session and attach it to the Http request thread by calling: SecurityContextHolder#setContext. This means that simultaneous requests get the same SecurityContext object. If one of those threads changes the authentication attached to the context (for example, to enable some "Run As" functionality such as in org.acegisecurity.intercept.AbstractSecurityInterceptor) that authentication will be seen to change in all the request threads and may enable those threads to be able to gain access that they shouldn&amp;amp;apos;t have.
</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="378" opendate="2006-10-18 18:49:01" fixdate="2006-11-13 11:56:57" resolution="Fixed">
		<buginformation>
			<summary>Authz taglib not working for group names with spaces</summary>
			<description>I am evaluating Acegi and have it setup against our corporate Active Directory. Things seems to be working fine.
But, all our groups in AD contains spaces eg. "CPHG AD ADMINS". The authz taglib does not seem to support this?
I can use eg. request.isUserInRole("CPHG AD ADMINS") and all groups are listed if I print getAuthorities() from authentication.
I tried creating a role with no spaces and it worked. 
Is there any reason not to support spaces in role/group names ?</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.taglibs.authz.AuthorizeTag.java</file>
			<file type="M">org.acegisecurity.taglibs.authz.AuthorizeTagTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="322" opendate="2006-07-19 23:15:12" fixdate="2006-11-13 12:21:59" resolution="Fixed">
		<buginformation>
			<summary>SavedRequest : ClassCastException when calling parameters.get(paramName)</summary>
			<description>If you are using WebSphere and IBM JSF, the following problem happens:
The fact that WebSphere container puts non-string array objects into the request parameter maps such as String object
causes ClassCastException when ExceptionTranslator instanciates a new SavedRequest instance, 
which executes the following code in its constructor(Line #113):
//SavedRequest class
.
.
.
// Parameters
Map parameters = request.getParameterMap();
Iterator paramNames = parameters.keySet().iterator();
while (paramNames.hasNext()) {
	String paramName = (String) paramNames.next();
	String[] paramValues = (String[]) parameters.get(paramName);
	this.addParameter(paramName, paramValues);
}
.
.
.
Since it&amp;amp;apos;s happening in the constructor, I can&amp;amp;apos;t override this behavior,so 
I have to write my own SavedRequest class that does string-array type check before casting the returned value from the parameter map.
//Custom SavedRequest class
.
.
.
// Parameters
Map parameters = request.getParameterMap();
Iterator paramNames = parameters.keySet().iterator();
while (paramNames.hasNext()) {
	String paramName = (String) paramNames.next();
	Object o =  parameters.get(paramName);
	if(o instanceof String[])
{
		String[] paramValues = (String[])o;
		this.addParameter(paramName, paramValues);
	}
	else
{
		//log
		.
		.
		.
	}
}
.
.
.
The bad thing was I also had to modify other classes which referenced the original SavedRequest object.
Do you think you can fix this issue in the next release?</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.savedrequest.SavedRequest.java</file>
		</fixedFiles>
	</bug>
	<bug id="382" opendate="2006-11-07 16:07:02" fixdate="2006-11-13 12:30:01" resolution="Fixed">
		<buginformation>
			<summary>messages.properties error in contacts samples</summary>
			<description>In acegisecurity\samples\contacts\src\main\resources, there is messages.properties file.Following is the content:
err.name.webContact.name=Name 3-50 characters is required.
err.name.webContact.email=Email 3-50 characters is required.
Here, the second name should be "email":
err.name.webContact.name=Name 3-50 characters is required.
err.email.webContact.email=Email 3-50 characters is required.</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">samples.contacts.src.main.java.sample.contact.WebContactValidator.java</file>
			<file type="M">samples.contacts.src.main.java.sample.contact.AddPermissionValidator.java</file>
		</fixedFiles>
	</bug>
	<bug id="353" opendate="2006-09-18 09:56:06" fixdate="2006-11-13 15:19:29" resolution="Duplicate">
		<buginformation>
			<summary>Acegi only checks current class interfaces against rules</summary>
			<description>A implements I
B extends A
If method definition specifies I methods ( eg. I.myMethod() ) and the invoked class is B then method is not securited.
MethodDefinitionMap 201-202
        // Add attributes explicitly defined for this method invocation&amp;amp;apos;s interfaces
        Class[] interfaces = method.getDeclaringClass().getInterfaces();</description>
			<version>1.0.0</version>
			<fixedVersion>1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionSourceEditorTests.java</file>
			<file type="D">org.springframework.security.annotation.Jsr250SecurityAnnotationAttributes.java</file>
			<file type="D">org.springframework.security.intercept.method.MethodDefinitionMap.java</file>
			<file type="M">org.springframework.security.util.SimpleMethodInvocation.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodInvocationPrivilegeEvaluatorTests.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionAttributesTests.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionSourceEditor.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodDefinitionSourceAdvisor.java</file>
			<file type="M">org.springframework.security.config.AnnotationDrivenBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.intercept.method.MockMethodDefinitionSource.java</file>
			<file type="M">org.springframework.security.OtherTargetObject.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodDefinitionSourceAdvisorTests.java</file>
			<file type="M">org.springframework.security.config.InterceptMethodsBeanDefinitionDecorator.java</file>
			<file type="M">org.springframework.security.ConfigAttributeDefinition.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionSource.java</file>
			<file type="M">org.springframework.security.intercept.method.aspectj.AspectJSecurityInterceptorTests.java</file>
			<file type="M">org.springframework.security.context.rmi.ContextPropagatingRemoteInvocationTests.java</file>
			<file type="M">org.springframework.security.annotation.MethodDefinitionSourceEditorTigerTests.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodSecurityInterceptorTests.java</file>
			<file type="M">org.springframework.security.MockJoinPoint.java</file>
			<file type="D">org.springframework.security.annotation.SecurityAnnotationAttributes.java</file>
			<file type="D">org.springframework.security.annotation.SecurityAnnotationAttributesTests.java</file>
			<file type="M">org.springframework.security.util.MethodInvocationUtils.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionAttributes.java</file>
			<file type="M">org.springframework.security.vote.BasicAclEntryVoterTests.java</file>
			<file type="M">org.springframework.security.config.BeanIds.java</file>
			<file type="D">org.springframework.security.annotation.Jsr250SecurityAnnotationAttributesTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">99</link>
		</links>
	</bug>
	<bug id="274" opendate="2006-05-24 07:20:52" fixdate="2006-11-16 12:16:59" resolution="Fixed">
		<buginformation>
			<summary>Generic Superclass Overridden Annotation Attribute not found</summary>
			<description>AdvisorChainFactoryUtils does not return a SecurityConfig for a method security via annotation attribute source for a bridge method using generics when the annotation is on the subclass.
Here is an example, complete with source and JUnit test.
Department extends Entity
BusinessServiceImpl implements BusinessService and takes a generic type that extends Entity
there is a method: public E someUserMethod3(final E entity) with no annotation
DepartmentService extends BusinessService with the method: Department someUserMethod3(final Department dept) with an annotation @Secured(
{"ROLE_USER"})
DepartmentServiceImpl extends BusinessServerImpl with the generic type Department and implements DepartmentService, it also has a method: public Department someUserMethod3(final Department dept) with a different annotation of @Secured({"ROLE_ADMIN"})

AdvisorChainFactoryUtils finds the bridge method that Java 1.5 creates to adhere to the interface BusinessService this method is: public Entity someUserMethod3(final Entity entity)
the utility does not find the annotation (because it&amp;amp;apos;s not on this class) but this means that any class that uses this class via an interface will not have security applied to it.  I have all of these classes and the JUnit test to add to SecurityAnnotationAttributesTests.  I will try to post them here, but if you need the files you can e-mail me

/********************************************************************/
New classes start here:

/********************************************************************/


package org.acegisecurity.annotation;

import org.acegisecurity.Entity;

/**
 * Notes:&amp;lt;br/&amp;gt;
 *
 * @author joes.checkernet.com
 * @version 0.0.1
 */
public class BusinessServiceImpl&amp;lt;E extends Entity&amp;gt; implements BusinessService {

    @Secured({"ROLE_USER"}
)
    public void someUserMethod1() {
    }
    @Secured(
{"ROLE_USER"})
    public void someUserMethod2() {
    }

    @Secured({"ROLE_USER", "ROLE_ADMIN"})
    public void someUserAndAdminMethod() {
    }

    @Secured({"ROLE_ADMIN"})
    public void someAdminMethod() {
    }

    public E someUserMethod3(final E entity) {
        return entity;
    }
}

package org.acegisecurity.annotation;

import org.acegisecurity.Entity;

/**
 * Notes:&amp;lt;br/&amp;gt;
 *
 * @author joes.checkernet.com
 * @version 0.0.1
 */
public class Department extends Entity {
    //~ Instance fields ========================================================

    private boolean active = true;

    //~ Constructors ===========================================================

    public Department(String name) {
        super(name);
    }

    //~ Methods ================================================================

    public boolean isActive() {
        return this.active;
    }

    void deactive() {
        this.active = true;
    }

}


package org.acegisecurity.annotation;

/**
 * Notes:&amp;lt;br/&amp;gt;
 *
 * @author joes.checkernet.com
 * @version 0.0.1
 */
public interface DepartmentService extends BusinessService {

    @Secured({"ROLE_USER"}
)
    Department someUserMethod3(Department dept);
}
package org.acegisecurity.annotation;
import org.acegisecurity.Entity;
/**

Notes:&amp;lt;br/&amp;gt;
 *
@author joes.checkernet.com
@version 0.0.1
 */
public class DepartmentServiceImpl extends BusinessServiceImpl &amp;lt;Department&amp;gt; implements DepartmentService {

    @Secured(
{"ROLE_ADMIN"}
)
    public Department someUserMethod3(final Department dept) 
{
        return super.someUserMethod3(dept);
    }
}
/********************************************************************/
Changes start here
/********************************************************************/
Changes to SecurityAnnotationAttributesTests for the JUnit test.  The first part checks that we can find the security annotation on the implementation class, the second part fails because it doesn&amp;amp;apos;t find it for the bridge method signature.
    private Log logger = LogFactory.getLog(SecurityAnnotationAttributesTests.class);
    public void testGenericsSuperclassDeclarationsAreIncludedWhenSubclassesOverride() {
        Method method = null;
        try {
            method = DepartmentServiceImpl.class.getMethod("someUserMethod3", new Class[]
{Department.class}
);
        } catch (NoSuchMethodException unexpected) 
{
            fail("Should be a superMethod called &amp;amp;apos;someUserMethod3&amp;amp;apos; on class!");
        }
        Collection attrs = this.attributes.getAttributes(method);

        if (logger.isDebugEnabled()) {
            logger.debug("attrs: ");
            logger.debug(attrs);
        }
        assertNotNull(attrs);

        // expect 1 attribute
        assertTrue("Did not find 1 attribute", attrs.size() == 1);

        // should have 1 SecurityConfig
        for (Object obj : attrs) {
            assertTrue(obj instanceof SecurityConfig);
            SecurityConfig sc = (SecurityConfig) obj;
            assertEquals("Found an incorrect role", "ROLE_ADMIN", sc.getAttribute());
        }

        Method superMethod = null;
        try {
            superMethod = DepartmentServiceImpl.class.getMethod("someUserMethod3", new Class[]{Entity.class});
        } catch (NoSuchMethodException unexpected) {            fail("Should be a superMethod called &amp;amp;apos;someUserMethod3&amp;amp;apos; on class!");        }
        Collection superAttrs = this.attributes.getAttributes(superMethod);
        if (logger.isDebugEnabled()) 
{
            logger.debug("superAttrs: ");
            logger.debug(superAttrs);
        }
        assertNotNull(superAttrs);
        // expect 1 attribute
        assertTrue("Did not find 1 attribute", superAttrs.size() == 1);
        // should have 1 SecurityConfig
        for (Object obj : superAttrs) 
{
            assertTrue(obj instanceof SecurityConfig);
            SecurityConfig sc = (SecurityConfig) obj;
            assertEquals("Found an incorrect role", "ROLE_ADMIN", sc.getAttribute());
        }
    }</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.annotation.SecurityAnnotationAttributesTests.java</file>
			<file type="M">org.acegisecurity.annotation.SecurityAnnotationAttributes.java</file>
		</fixedFiles>
	</bug>
	<bug id="395" opendate="2006-11-20 05:06:38" fixdate="2006-11-20 05:43:54" resolution="Fixed">
		<buginformation>
			<summary>HttpSessionEventPublisher causes a NullPointerException</summary>
			<description>As explained in...
http://forum.springframework.org/showthread.php?t=30766
The code naively assumes that one intance of the HttpSessionEventPublisher will be created by the container. In Websphere 5.1.1 at least, this is not true.
The code will be modified to get the ApplicationContext in an as needed basis rather than storing it in a field.</description>
			<version>1.0.0</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.session.HttpSessionEventPublisherTests.java</file>
			<file type="M">org.acegisecurity.ui.session.HttpSessionEventPublisher.java</file>
		</fixedFiles>
	</bug>
	<bug id="401" opendate="2006-11-25 13:54:40" fixdate="2006-11-25 14:47:12" resolution="Fixed">
		<buginformation>
			<summary>AclEntryVoter and BasicAclEntryVoter use startsWith for configuration attribute matching</summary>
			<description>AclEntryVoter and BasicAclEntryVoter both use String.startsWith(String) for determining whether they apply to a given secure object invocation. Instead equals(String) should be used.</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.vote.BasicAclEntryVoter.java</file>
			<file type="M">org.acegisecurity.vote.AclEntryVoter.java</file>
		</fixedFiles>
	</bug>
	<bug id="404" opendate="2006-11-29 13:52:40" fixdate="2006-12-28 07:24:19" resolution="Fixed">
		<buginformation>
			<summary>Logout when not logged in cause NullPointerException</summary>
			<description>When a user attempts to logout when they aren&amp;amp;apos;t logged in (e.g. when their session has expired) a NullPointerException occurs in TokenBasedRememberMeServices.logout(TokenBasedRememberMeServices.java:295).
The line that fails is:
        cancelCookie(request, response, "Logout of user " + authentication.getName());
I guess the cookie should still be cancelled, so the change might simply be to change the line to something like:
        cancelCookie(request, response, "Logout of user " + authentication == null ? "Unknown" : authentication.getName());
Regards,
Damien</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">433</link>
			<link type="Duplicate" description="is duplicated by">464</link>
			<link type="Duplicate" description="is duplicated by">407</link>
		</links>
	</bug>
	<bug id="407" opendate="2006-12-02 06:52:31" fixdate="2006-12-28 07:24:54" resolution="Fixed">
		<buginformation>
			<summary>Hitting LogoutFilter&amp;apos;s URL when not logged in causes NPE</summary>
			<description>After upgrading to 1.0.3, I&amp;amp;apos;m getting the following error when running
some tests:
[INFO] [talledLocalContainer] ERROR - StandardWrapperValve.invoke(260)


 Servlet.service() for servlet jsp threw exception
[INFO] [talledLocalContainer] java.lang.NullPointerException
[INFO] [talledLocalContainer]   at
org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.logout(TokenBasedRememberMeServices.java:295)
[INFO] [talledLocalContainer]   at
org.acegisecurity.ui.logout.LogoutFilter.doFilter(LogoutFilter.java:98)


Here&amp;amp;apos;s what I have in my security.xml context file:
   &amp;lt;bean id="filterChainProxy" class="org.acegisecurity.util.FilterChainProxy"&amp;gt;
       &amp;lt;property name="filterInvocationDefinitionSource"&amp;gt;
           &amp;lt;value&amp;gt;
               CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
               PATTERN_TYPE_APACHE_ANT
/**=httpSessionContextIntegrationFilter,logoutFilter,authenticationProcessingFilter,securityContextHolderAwareRequestFilter,rememberMeProcessingFilter,anonymousProcessingFilter,exceptionTranslationFilter,filterInvocationInterceptor
           &amp;lt;/value&amp;gt;
           &amp;lt;!-- Put channelProcessingFilter before
securityContextHolderAwareRequestFilter to turn on SSL switching --&amp;gt;
           &amp;lt;!-- It&amp;amp;apos;s off by default b/c Canoo WebTest doesn&amp;amp;apos;t support
SSL out-of-the-box --&amp;gt;
       &amp;lt;/property&amp;gt;
   &amp;lt;/bean&amp;gt;
   &amp;lt;bean id="httpSessionContextIntegrationFilter"
class="org.acegisecurity.context.HttpSessionContextIntegrationFilter"/&amp;gt;
   &amp;lt;bean id="logoutFilter" class="org.acegisecurity.ui.logout.LogoutFilter"&amp;gt;
       &amp;lt;constructor-arg value="/index.jsp"/&amp;gt; &amp;lt;!-- URL redirected to
after logout --&amp;gt;
       &amp;lt;constructor-arg&amp;gt;
           &amp;lt;list&amp;gt;
               &amp;lt;ref bean="rememberMeServices"/&amp;gt;
               &amp;lt;bean
class="org.acegisecurity.ui.logout.SecurityContextLogoutHandler"/&amp;gt;
           &amp;lt;/list&amp;gt;
       &amp;lt;/constructor-arg&amp;gt;
       &amp;lt;property name="filterProcessesUrl" value="/logout.jsp"/&amp;gt;
   &amp;lt;/bean&amp;gt;
The problem appears to be caused by trying to logout before you&amp;amp;apos;ve
tried to login.  This worked fine in previous releases where the
LogoutFilter was present.</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">404</link>
		</links>
	</bug>
	<bug id="357" opendate="2006-09-20 05:15:31" fixdate="2007-04-23 17:44:23" resolution="Fixed">
		<buginformation>
			<summary>SwitchUserProcessingFilter allows a null j_username</summary>
			<description>The SwitchUserProcessingFilter contains the following code.  
I can&amp;amp;apos;t see any way that the filter could do something reasonable with a null user name.   The username should be a required parameter.  If the username parameter is not supplied, then the request is malformed and should be rejected. 
 195     protected Authentication attemptSwitchUser(HttpServletRequest request)
  196         throws AuthenticationException {
  197         UsernamePasswordAuthenticationToken targetUserRequest = null;
  199         String username = request.getParameter(ACEGI_SECURITY_SWITCH_USERNAME_KEY);
  201         if (username == null) 
{
  202             username = "";
  203         }
  209         // load the user by name
  210         UserDetails targetUser = this.userDetailsService.loadUserByUsername(username);</description>
			<version>1.0.0 RC2</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.switchuser.SwitchUserProcessingFilterTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="376" opendate="2006-10-12 21:58:24" fixdate="2007-04-25 10:07:42" resolution="Fixed">
		<buginformation>
			<summary>FilterSecurityInterceptor is not  applied to /j_acegi_switch_user</summary>
			<description>FilterSecurityInterceptor is not  applied to /j_acegi_switch_user
e.g. using  /j_acegi_switch_user=SUPERUSER
Whilst it is possible to protect the url that renders the form that eventually submits to  /j_acegi_switch_user, it is possible to circumvent this using a hand-crafted url
e.g.http://localhost:9090/my-app/j_acegi_switch_user?j_username=some.user
see forum entry for more details http://forum.springframework.org/showthread.php?t=29621&amp;amp;highlight=j_acegi_switch_user</description>
			<version>1.0.2</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ui.FilterChainOrderUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="433" opendate="2007-02-11 03:19:28" fixdate="2007-05-21 18:56:10" resolution="Duplicate">
		<buginformation>
			<summary>Fix to SEC-359 has introduced a NullPointer to TokenBasedRememberMeServices.logout()</summary>
			<description>
cancelCookie(request, response, "Logout of user " + authentication.getName()); &amp;lt;-- NULL POINTER if authentication is null
Stack trace: java.lang.NullPointerException
    at org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.logout(TokenBasedRememberMeServices.java:295)
    at org.acegisecurity.ui.logout.LogoutFilter.doFilter(LogoutFilter.java:98)
    at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
    at org.acegisecurity.context.HttpSessionContextIntegrationFilter.doFilter(HttpSessionContextIntegrationFilter.java:229)
    at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
    at org.acegisecurity.securechannel.ChannelProcessingFilter.doFilter(ChannelProcessingFilter.java:138)
    at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
    at org.acegisecurity.util.FilterChainProxy.doFilter(FilterChainProxy.java:148)
    at org.acegisecurity.util.FilterToBeanProxy.doFilter(FilterToBeanProxy.java:98) </description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">404</link>
		</links>
	</bug>
	<bug id="464" opendate="2007-04-04 08:04:12" fixdate="2007-05-21 19:34:32" resolution="Duplicate">
		<buginformation>
			<summary>NPE when missing &amp;apos;j_acegi_logout&amp;apos; when not logged in</summary>
			<description>I receive a NPE Null PointerException when linking to &amp;amp;apos;j_acegi_logout&amp;amp;apos;:
    &amp;lt;a href="&amp;lt;c:url value="/j_acegi_logout"/&amp;gt;"&amp;gt;Logoff&amp;lt;/a&amp;gt;
when there is no user currently logged in
Here is the stack trace for the exception:
An Error has occurred in this application.
java.lang.NullPointerException
	at org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.logout(TokenBasedRememberMeServices.java:295)
	at org.acegisecurity.ui.logout.LogoutFilter.doFilter(LogoutFilter.java:98)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
	at org.acegisecurity.context.HttpSessionContextIntegrationFilter.doFilter(HttpSessionContextIntegrationFilter.java:229)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:274)
	at org.acegisecurity.util.FilterChainProxy.doFilter(FilterChainProxy.java:148)
	at org.acegisecurity.util.FilterToBeanProxy.doFilter(FilterToBeanProxy.java:98)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:202)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:78)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:77)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:202)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:173)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:213)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:178)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:126)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:105)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:107)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:148)
	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:869)
	at org.apache.coyote.http11.Http11BaseProtocol$Http11ConnectionHandler.processConnection(Http11BaseProtocol.java:664)
	at org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:527)
	at org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt(LeaderFollowerWorkerThread.java:80)
	at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:684)
	at java.lang.Thread.run(Thread.java:595)
My current workaround for the problem is to wrap the "logout" link with &amp;lt;authz/&amp;gt; tags:
    &amp;lt;authz:authorize ifAnyGranted="ROLE_USER,ROLE_ADMINISTRATOR"&amp;gt;
        &amp;lt;a href="&amp;lt;c:url value="/j_acegi_logout"/&amp;gt;"&amp;gt;Logoff&amp;lt;/a&amp;gt;
    &amp;lt;/authz:authorize&amp;gt;
which prevents the "Logoff" link from showing, but does not stop a user from manually entering the &amp;amp;apos;j_acegi_logout&amp;amp;apos; link themselves.
Here is the filterChainProxy config:
    &amp;lt;bean id="filterChainProxy" class="org.acegisecurity.util.FilterChainProxy"&amp;gt;
        &amp;lt;property name="filterInvocationDefinitionSource"&amp;gt;
            &amp;lt;value&amp;gt;
                CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
                PATTERN_TYPE_APACHE_ANT
                /images/**=#NONE#
                /scripts/**=#NONE#
                /styles/**=#NONE#
                /**=httpSessionContextIntegrationFilter,logoutFilter,authenticationProcessingFilter,securityContextHolderAwareRequestFilter,rememberMeProcessingFilter,anonymousProcessingFilter,exceptionTranslationFilter,filterInvocationInterceptor
            &amp;lt;/value&amp;gt;
            &amp;lt;!-- :TODO: Put channelProcessingFilter before securityContextHolderAwareRequestFilter to turn on SSL switching --&amp;gt;
            &amp;lt;!-- It&amp;amp;apos;s off by default b/c Canoo WebTest doesn&amp;amp;apos;t support SSL out-of-the-box --&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
Here is the logoutFilter config:
    &amp;lt;bean id="logoutFilter" class="org.acegisecurity.ui.logout.LogoutFilter"&amp;gt;
      &amp;lt;constructor-arg value="/"/&amp;gt; &amp;lt;!-- URL redirected to after logout --&amp;gt;
      &amp;lt;constructor-arg&amp;gt;
         &amp;lt;list&amp;gt;
              &amp;lt;ref bean="rememberMeServices"/&amp;gt;
              &amp;lt;bean class="org.acegisecurity.ui.logout.SecurityContextLogoutHandler"/&amp;gt;
         &amp;lt;/list&amp;gt;
      &amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">404</link>
		</links>
	</bug>
	<bug id="424" opendate="2007-01-09 04:39:23" fixdate="2007-05-21 19:35:46" resolution="Duplicate">
		<buginformation>
			<summary>MethodDefinitionMap - Can&amp;apos;t access inherited methods</summary>
			<description>See : http://forum.springframework.org/showthread.php?p=94634
The MethodDefinitionMap can&amp;amp;apos;t secure any inherited method. Line 123 of the java file has to be modified as follows :





Eclipse Workspace Patch 1.0
#P acegisecurity
Index: core/src/main/java/org/acegisecurity/intercept/method/MethodDefinitionMap.java
===================================================================
RCS file: /cvsroot/acegisecurity/acegisecurity/core/src/main/java/org/acegisecurity/intercept/method/MethodDefinitionMap.java,v
retrieving revision 1.6
diff -u -r1.6 MethodDefinitionMap.java


core/src/main/java/org/acegisecurity/intercept/method/MethodDefinitionMap.java	17 Nov 2005 00:56:09 -0000	1.6
+++ core/src/main/java/org/acegisecurity/intercept/method/MethodDefinitionMap.java	9 Jan 2007 14:45:34 -0000
@@ -165,7 +165,7 @@
                 + "] with attributes [" + attr + "]");
         }






Method[] methods = clazz.getDeclaredMethods();
+        Method[] methods = clazz.getMethods();
         List matchingMethods = new ArrayList();

         for (int i = 0; i &amp;lt; methods.length; i++) {</description>
			<version>1.0.4</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionSourceEditorTests.java</file>
			<file type="D">org.springframework.security.annotation.Jsr250SecurityAnnotationAttributes.java</file>
			<file type="D">org.springframework.security.intercept.method.MethodDefinitionMap.java</file>
			<file type="M">org.springframework.security.util.SimpleMethodInvocation.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodInvocationPrivilegeEvaluatorTests.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionAttributesTests.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionSourceEditor.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodDefinitionSourceAdvisor.java</file>
			<file type="M">org.springframework.security.config.AnnotationDrivenBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.intercept.method.MockMethodDefinitionSource.java</file>
			<file type="M">org.springframework.security.OtherTargetObject.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodDefinitionSourceAdvisorTests.java</file>
			<file type="M">org.springframework.security.config.InterceptMethodsBeanDefinitionDecorator.java</file>
			<file type="M">org.springframework.security.ConfigAttributeDefinition.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionSource.java</file>
			<file type="M">org.springframework.security.intercept.method.aspectj.AspectJSecurityInterceptorTests.java</file>
			<file type="M">org.springframework.security.context.rmi.ContextPropagatingRemoteInvocationTests.java</file>
			<file type="M">org.springframework.security.annotation.MethodDefinitionSourceEditorTigerTests.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodSecurityInterceptorTests.java</file>
			<file type="M">org.springframework.security.MockJoinPoint.java</file>
			<file type="D">org.springframework.security.annotation.SecurityAnnotationAttributes.java</file>
			<file type="D">org.springframework.security.annotation.SecurityAnnotationAttributesTests.java</file>
			<file type="M">org.springframework.security.util.MethodInvocationUtils.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionAttributes.java</file>
			<file type="M">org.springframework.security.vote.BasicAclEntryVoterTests.java</file>
			<file type="M">org.springframework.security.config.BeanIds.java</file>
			<file type="D">org.springframework.security.annotation.Jsr250SecurityAnnotationAttributesTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">99</link>
		</links>
	</bug>
	<bug id="438" opendate="2007-02-18 13:14:46" fixdate="2007-05-22 17:35:17" resolution="Fixed">
		<buginformation>
			<summary>exceptionMappings in ProviderManager cannot be added from subclasses</summary>
			<description>The subclasses of ProviderManager cannot add exceptionMappings to raise custom events on custom exceptions as the doAfterPropertiesSet() is passed DEFAULT_EXCEPTION_MAPPINGS instead of instance variable exceptionMappings.
Please also look at thread on the forums
http://forum.springframework.org/showthread.php?t=35052
</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.providers.ProviderManager.java</file>
		</fixedFiles>
	</bug>
	<bug id="478" opendate="2007-04-29 19:03:34" fixdate="2007-05-22 17:46:17" resolution="Fixed">
		<buginformation>
			<summary>Incorrect decoding of base64 cookie value by TokenBasedRememberMeServices.autoLogin</summary>
			<description>This bug can be observed by using the contact example application and trying to login with dianne/emu while using the "remember me option". This user mght not be remembered, as it is the case for other users. this, however, might not be reproductible under certain conditions.
The heart of the problem is that a user will not be remembered if the resulting base64 encoded value stored in in cookie has a number of significant caracters that is not an exact multiple of 4. In such condition, according to thee base64 specification, the value is padded with trailing "=". The result is a cookie value padded with "%3D", which is ok.
When the cookie value is retrieved by the autoLogin method, the trailing "=" are lost. Although on might think this should be detected by Base64.Base64.isArrayByteBase64(), it is not because this method returns true if the value contains only valid character, even if the value itself is not valid.
Workaround :
A simple workaround is to add the missing trailing "=" to the retrieved value, which can be done with the following code :
  public Authentication autoLogin(HttpServletRequest request, HttpServletResponse response) {
    Cookie[] cookies = request.getCookies();
    if ((cookies == null) || (cookies.length == 0)) 
{
      return null;
    }

    for (int i = 0; i &amp;lt; cookies.length; i++) {
      if (ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE_KEY.equals(cookies[i].getName())) {
        String cookieValue = cookies[i].getValue();
        /*************************
          PATCH BEGINS HERE
         *************************/
        for (int j = 0; j &amp;lt; cookieValue.length() % 4; j++) 
{
          cookieValue = cookieValue + "=";
        }
        /************************
        PATCH ENDS HERE
        *************************/
        if (Base64.isArrayByteBase64(cookieValue.getBytes())) {
          if (logger.isDebugEnabled()) 
{
            logger.debug("Remember-me cookie detected");
          }

Fix: 
The real fix would probably concern either Base64.decodeBase64 or Cookie.getValue</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.java</file>
		</fixedFiles>
	</bug>
	<bug id="474" opendate="2007-04-24 21:32:22" fixdate="2007-05-22 17:49:01" resolution="Fixed">
		<buginformation>
			<summary>TokenBasedRememberMeServices fail with empty password</summary>
			<description>In case of an empty password, the service fails because of the Assert.hasLength(password) in the loginSuccess method.
Fails heavily, with 500 page shown to the user.
However I could not find any contract that the password can&amp;amp;apos;t be empty. Could you please change this behaviour to simply skip cookie creation in case of an empty username/password?
Like:
		if (StringUtils.hasLength(username) &amp;amp;&amp;amp; StringUtils.hasLength(password)) 
{

			long expiryTime = System.currentTimeMillis()
					+ (getTokenValiditySeconds() * 1000);
			// And so on
		}</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices.java</file>
		</fixedFiles>
	</bug>
	<bug id="461" opendate="2007-03-30 07:19:42" fixdate="2007-05-22 17:55:02" resolution="Duplicate">
		<buginformation>
			<summary>HttpSessionContextIntegrationFilter with cloneFromHttpSession = true causes problems at login</summary>
			<description>The cloneFromHttpSession feature of the HttpSessionContextIntegrationFilter is fantastic - just what I needed, but it has a bug. 
On line 172, it checks to see if the clone feature is turned on and then asserts that the context from the session is an instance of Cloneable.  However, the context from the session might be null at this point.  The check for cloneFromHttpSession should be moved inside the next if() statement so that it only checks when the context in the session is non-null. </description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">423</link>
		</links>
	</bug>
	<bug id="459" opendate="2007-03-29 09:24:16" fixdate="2007-05-22 17:57:28" resolution="Fixed">
		<buginformation>
			<summary>Incorrect MessageSource constructor used</summary>
			<description>Here&amp;amp;apos;s one example from BasicAclEntryAfterInvocationProvider:
                if ((acls == null) || (acls.length == 0)) {
                    throw new AccessDeniedException(messages.getMessage(
                            "BasicAclEntryAfterInvocationProvider.noPermission",
                            new Object[] 
{authentication.getName(), returnedObject}
,
                            "Authentication 
{0}
 has NO permissions at all to the domain object 
{1}
"));
                }
It&amp;amp;apos;s missing the locale parameter at the end, so it&amp;amp;apos;s using an unintended constructor resulting in the string being logged verbatim without the substitutions. This makes debugging any security problems very hard. 
</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.afterinvocation.BasicAclEntryAfterInvocationProvider.java</file>
		</fixedFiles>
	</bug>
	<bug id="453" opendate="2007-03-14 07:41:55" fixdate="2007-05-22 17:59:41" resolution="Fixed">
		<buginformation>
			<summary>CasAuthenticationHandler does not log root cause of AuthenticationException.</summary>
			<description>Excerpt from org.acegisecurity.adapters.cas3.CasAuthenticationHandler&amp;amp;apos;s authenticateUsernamePasswordInternal() method:
----- excerpt begin -----
try {
  this.authenticationManager.authenticate(authenticationRequest);
} catch (final org.acegisecurity.AuthenticationException e) {
  if (log.isDebugEnabled()) 
{
    log.debug("Authentication request for " + credentials.getUsername() + "failed: " + e.toString());
  }

  return false;
}
------ excerpt end ------
Problems (both with the log.debug() call):

The log.debug call does not print the stack trace.  This could be solved by changing the log.debug() call to:
    log.debug("Authentication request for " + credentials.getUsername() + "failed: ", e);
There needs to be a space between the credentials.getUsername() and the word "failed".

</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.adapters.cas3.CasAuthenticationHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="439" opendate="2007-02-18 18:01:19" fixdate="2007-05-22 18:05:01" resolution="Fixed">
		<buginformation>
			<summary>AclEntryAfterInvocationProvider.decide() returns null when result object not applicable to the provider</summary>
			<description>Maybe I&amp;amp;apos;m confused but I&amp;amp;apos;m using ACL_AFTER_READ to control access to instances of my DomainObjectAclAware objects.  In my afterAclRead bean I define:
&amp;lt;property name="processDomainObjectClass"&amp;gt;&amp;lt;value&amp;gt;foo.DomainObjectAclAware&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;
I stepped through code while retrieving an object that was not an instance of DomainObjectAclAware and the provider returned null anyway as if I do not have access to the object.  See lines 90-96 of org.acegisecurity.afterinvocation.AclEntryAfterInvocationProvider:
                if (!getProcessDomainObjectClass().isAssignableFrom(returnedObject.getClass())) {
                    if (logger.isDebugEnabled()) 
{
                        logger.debug("Return object is not applicable for this provider, skipping");
                    }

                    return null;
                }
Shouldn&amp;amp;apos;t this return the object instead of null?</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.afterinvocation.AclEntryAfterInvocationProvider.java</file>
		</fixedFiles>
	</bug>
	<bug id="451" opendate="2007-03-13 05:09:47" fixdate="2007-05-23 11:18:22" resolution="Fixed">
		<buginformation>
			<summary>Empty context path in LogoutFilter and AbstractProcessingFilter</summary>
			<description>When context path is empty, LogoutFilter erroneously believes "/anything/before/j_acegi_logout" is a logout URL.  The requiresLogout() method should use uri.equals(request.getContextPath() + filterProcessesUrl) instead of uri.endsWith(request.getContextPath() + filterProcessesUrl), or more simple, uri.endsWith(filterProcessesUrl) to detect any URL ending with j_acegi_logout.</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.AbstractProcessingFilter.java</file>
			<file type="M">org.acegisecurity.ui.logout.LogoutFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="305" opendate="2006-06-23 10:21:23" fixdate="2007-05-23 13:05:02" resolution="Fixed">
		<buginformation>
			<summary>HttpSessionContextIntegrationFilter to retain SecurityContext when rendering error pages</summary>
			<description>This happens when you want to set up error pages as described in SRV.9.9.2 Error Pages in Java Servlet Specification
Version 2.4.
If for example want to display the current user name on an error page, the security context does not contain the authenticated user.
The reason is believed to be that HttpSessionContextIntegrationFilter is only applied once per request.
Seehttp://forum.springframework.org/showthread.php?t=21534</description>
			<version>1.0.0</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilter.java</file>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilterTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">361</link>
		</links>
	</bug>
	<bug id="411" opendate="2006-12-11 11:44:04" fixdate="2007-05-24 10:53:45" resolution="Fixed">
		<buginformation>
			<summary>SecurityContextHolderAwareRequestWrapper does not define required constructor</summary>
			<description>SecurityContextHolderAwareRequestFilter requires that any request wrapper configured for it must provide a public constructor that accepts two arguments (HttpServletRequest and PortResolver). SecurityContextHolderAwareRequestWrapper does not provide this constructor.</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.wrapper.SecurityContextHolderAwareRequestWrapperTests.java</file>
			<file type="M">org.acegisecurity.wrapper.SavedRequestAwareWrapper.java</file>
			<file type="M">org.acegisecurity.wrapper.SecurityContextHolderAwareRequestWrapper.java</file>
		</fixedFiles>
	</bug>
	<bug id="444" opendate="2007-03-04 22:25:10" fixdate="2007-05-24 12:42:26" resolution="Fixed">
		<buginformation>
			<summary>Race condition inside ConcurrentSessionControllerImpl</summary>
			<description>I was getting SessionAlreadyUsedException on rapid usage (by single user). The strack trace of the exception is below.
The problem seems to be the unsynchronized sequence of commands Inside ConcurrentSessionControllerImpl.registerSuccessfulAuthentication():
            sessionRegistry.removeSessionInformation(sessionId);
            sessionRegistry.registerNewSession(sessionId, principal);
The registerNewSession() will fail if an other thread registers the same session between these two commands.
The strack trace:
2007-03-02 16:53:46,204 DEBUG [org.acegisecurity.ui.ExceptionTranslationFilter]
(http-0.0.0.0-8080-1 Authentication exception occurred; redirecting to
authentication entry point
org.acegisecurity.concurrent.SessionAlreadyUsedException: Session
1E1B65235B4D42FF17C5F76E7287228D is already is use
        at
org.acegisecurity.concurrent.SessionRegistryImpl.registerNewSession(SessionRegistryImpl.java:121)
        at
org.acegisecurity.concurrent.ConcurrentSessionControllerImpl.registerSuccessfulAuthentication(ConcurrentSessionControllerImpl.java:142)
        at
org.acegisecurity.providers.ProviderManager.doAuthentication(ProviderManager.java:191)</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.concurrent.ConcurrentSessionControllerImpl.java</file>
			<file type="M">org.acegisecurity.concurrent.SessionRegistryImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="423" opendate="2007-01-04 01:40:23" fixdate="2007-05-24 12:54:29" resolution="Fixed">
		<buginformation>
			<summary>CLONE -SEC 356 Introduces New Bug: Changes to Authentication leak into synchronous requests when using HttpSessionContextIntegrationFilter</summary>
			<description>HttpSessionContextIntegrationFilter will read an existing SecurityContext object from the session and attach it to the Http request thread by calling: SecurityContextHolder#setContext. This means that simultaneous requests get the same SecurityContext object. If one of those threads changes the authentication attached to the context (for example, to enable some "Run As" functionality such as in org.acegisecurity.intercept.AbstractSecurityInterceptor) that authentication will be seen to change in all the request threads and may enable those threads to be able to gain access that they shouldn&amp;amp;apos;t have.
</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">461</link>
		</links>
	</bug>
	<bug id="419" opendate="2006-12-23 14:04:56" fixdate="2007-05-24 12:55:24" resolution="Fixed">
		<buginformation>
			<summary>org.acegisecurity.afterinvocation.CollectionFilterer&amp;apos;s logger error</summary>
			<description>class CollectionFilterer implements Filterer {
    //~ Static fields/initializers =====================================================================================
    protected static final Log logger = LogFactory.getLog(BasicAclEntryAfterInvocationCollectionFilteringProvider.class);
BasicAclEntryAfterInvocationCollectionFilteringProvider.class should be CollectionFilterer.class</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.afterinvocation.CollectionFilterer.java</file>
		</fixedFiles>
	</bug>
	<bug id="467" opendate="2007-04-06 20:54:13" fixdate="2007-05-24 12:57:02" resolution="Duplicate">
		<buginformation>
			<summary>New Acl package not compatible with Mysql Db</summary>
			<description>The sql statements JdbcAclService and JdbcMutableAclService are only compatible with hsqlDb but not with other DBs e.g. mysql. the "call identity()" for example query must be "SELECT LAST_INSERT_ID()" in mysql dialect.
So it would be great if you could access the ...Query properties via setter-methods and configure JdbcMutableAclService via spring beans xml.
also have a look at this thread please:
http://forum.springframework.org/archive/index.php/t-34222.html
thank you</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategy.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">422</link>
		</links>
	</bug>
	<bug id="512" opendate="2007-07-23 19:41:50" fixdate="2007-07-24 04:04:31" resolution="Fixed">
		<buginformation>
			<summary>Method FilterBasedLdapUserSearch#searchForUser(String username) creates an unsed  DirContext which never closed</summary>
			<description>The org.acegisecurity.ldap.searchFilterBasedLdapUserSearch#searchForUser(String username)  method create an DirContext in the first line. This DirContext create/use a connection to ldap server. This DirContext is only used for an debug level log output. The great problem is that this DirContext is never closed and the ldap connection is not closed or released to connection pool. </description>
			<version>1.0.3</version>
			<fixedVersion>1.0.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ldap.search.FilterBasedLdapUserSearch.java</file>
			<file type="M">org.acegisecurity.ldap.search.FilterBasedLdapUserSearchTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="522" opendate="2007-08-08 20:18:30" fixdate="2007-08-27 04:15:14" resolution="Fixed">
		<buginformation>
			<summary>LogoutFilter do not exclude query parameters in the matching test</summary>
			<description>protected boolean requiresLogout(HttpServletRequest request, HttpServletResponse response) 
{
        String uri = request.getRequestURI();
        int pathParamIndex = uri.indexOf(&amp;amp;apos;;&amp;amp;apos;);
//////////////////////////////////////
replace with :
int pathParamIndex = uri.indexOf(&amp;amp;apos;?&amp;amp;apos;);
or find the min of the index of &amp;amp;apos;?&amp;amp;apos;, &amp;amp;apos;=&amp;amp;apos;, ....
////////////////////////////////////// 
        if (pathParamIndex &amp;gt; 0) 
{
            // strip everything after the first semi-colon
            uri = uri.substring(0, pathParamIndex);
        }

        if ("".equals(request.getContextPath())) 
{
        	return uri.endsWith(filterProcessesUrl);
        }

        return uri.endsWith(request.getContextPath() + filterProcessesUrl);
}
</description>
			<version>1.0.4</version>
			<fixedVersion>1.0.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.logout.LogoutFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="502" opendate="2007-07-10 15:02:03" fixdate="2007-08-27 04:21:49" resolution="Fixed">
		<buginformation>
			<summary>LabelBasedAclVoter Tests fail </summary>
			<description>Unit tests for LabelBasedAclVoter error on loading applicationcontest,
(test resource org.acegisecurity.vote.labelBasedSecurityApplicationContext.xml).
Due to the fact the with Spring 1.2.8 (not sure about other versions), an application context uses a 
org.apache.commons.collections.map.LinkedMap which implements java.util.Map, but not 
java.util.HashMap which org.acegisecurity.vote.LabelBasedAclVoter.setLabelMap(..) expects.
Solution.
change org.acegisecurity.vote.LabelBasedAclVoter labelMap member var to be of type java.util.Map (was java.util.HashMap)
and change signature of setLabelMap(..)
from public void setLabelMap(HashMap labelMap)
to  public void setLabelMap(Map labelMap)
</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.vote.LabelBasedAclVoter.java</file>
			<file type="M">org.acegisecurity.vote.LabelBasedAclVoterTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="518" opendate="2007-08-06 02:48:28" fixdate="2007-08-27 10:47:22" resolution="Fixed">
		<buginformation>
			<summary>ehcache support should depend on net.sf.ehcache.Ehcache interface instead of concrete implementation net.sf.ehcache.Cache</summary>
			<description>EhCacheBasedUserCache (org.acegisecurity.providers.dao.cache) has a dependency of type net.sf.ehcache.Cache.
In the presence of an proper interface type (net.sf.ehcache.Ehcache) this is bad usage of IoC: it limits users to a concrete type, disallowing alternative implementations or decorators.
Since acegi is quite often used in a spring IoC context, this inflexibility is very easy to demonstrate:
------------------
  &amp;lt;bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean"/&amp;gt;
  &amp;lt;bean id="userCacheBackend" class="org.springframework.cache.ehcache.EhCacheFactoryBean"&amp;gt;
    &amp;lt;property name="cacheManager" ref="cacheManager"/&amp;gt;
    &amp;lt;property name="cacheName" value="userCache"/&amp;gt;
    &amp;lt;property name="blocking" value="true"/&amp;gt;
  &amp;lt;/bean&amp;gt;
  &amp;lt;bean id="cache" class="org.acegisecurity.providers.dao.cache.EhCacheBasedUserCache"&amp;gt;
    &amp;lt;property name="cache" ref="userCacheBackend"/&amp;gt;
  &amp;lt;/bean&amp;gt;
------------------
Note that the "blocking" property is set on bean "userCacheBackend", triggering the creation of a decorator for the backing cache.
Instantiating above context (using spring 2.1m3, acegi 1.0.4 and ehcache 1.2.3) will (of course) fail:
------------------
Exception in thread "main" org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;cache&amp;amp;apos; defined in class path resource [factories.xml]: Error setting property values; nested exception is org.springframework.beans.PropertyBatchUpdateException; nested PropertyAccessExceptions (1) are:
PropertyAccessException 1: org.springframework.beans.TypeMismatchException: Failed to convert property value of type [net.sf.ehcache.constructs.blocking.BlockingCache] to required type [net.sf.ehcache.Cache] for property &amp;amp;apos;cache&amp;amp;apos;; nested exception is java.lang.IllegalArgumentException: Cannot convert value of type [net.sf.ehcache.constructs.blocking.BlockingCache] to required type [net.sf.ehcache.Cache] for property &amp;amp;apos;cache&amp;amp;apos;: no matching editors or conversion strategy found
------------------
I&amp;amp;apos;m not familiar with acegi source, but it seems that there&amp;amp;apos;s actually no need at all to use the concrete Cache class: no specific implementation details of that type seem to be used.
Especially considering the endless "interface based dependencies" preaching by Rod (et al), this seems a bit strange for a "spring" project.</description>
			<version>1.0.4</version>
			<fixedVersion>1.0.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.acl.basic.cache.EhCacheBasedAclEntryCache.java</file>
			<file type="M">org.acegisecurity.providers.cas.cache.EhCacheBasedTicketCache.java</file>
			<file type="M">org.acegisecurity.providers.x509.cache.EhCacheBasedX509UserCacheTests.java</file>
			<file type="M">org.acegisecurity.acl.basic.cache.EhCacheBasedAclEntryCacheTests.java</file>
			<file type="M">org.acegisecurity.providers.x509.cache.EhCacheBasedX509UserCache.java</file>
			<file type="M">org.acegisecurity.providers.cas.cache.EhCacheBasedTicketCacheTests.java</file>
			<file type="M">org.acegisecurity.providers.dao.cache.EhCacheBasedUserCacheTests.java</file>
			<file type="M">org.acegisecurity.acls.jdbc.EhCacheBasedAclCache.java</file>
			<file type="M">org.acegisecurity.providers.dao.cache.EhCacheBasedUserCache.java</file>
		</fixedFiles>
	</bug>
	<bug id="506" opendate="2007-07-18 11:13:34" fixdate="2007-08-27 11:32:04" resolution="Fixed">
		<buginformation>
			<summary>DigestProcessingFilter improperly parsing Authorization request header when individual values contain commas</summary>
			<description>DigestProcessingFilter improperly parses the Authorization request header. It converts the header to an array of strings based on the assumption that the individual values don&amp;amp;apos;t contain comma.
I ran into the problem when the query string of a URL contained commas. RFC 1738 has the following to say about commas:
    Thus, only alphanumerics, the special characters "$-_.+!*&amp;amp;apos;(),", and
    reserved characters used for their reserved purposes may be used
    unencoded within a URL.
As you can see, the comma is in the list of "special characters" that may be used unencoded.
DigestProcessingFilter works correctly when I URL encode the commas but I should not be expected to encode the commas according to the RFC. Also, what about the other pieces of the Authorization header such as username, realm, etc? DigestProcessingFilter should properly handle the case when they contain commas.</description>
			<version>1.0.4</version>
			<fixedVersion>1.0.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.digestauth.DigestProcessingFilterTests.java</file>
			<file type="M">org.acegisecurity.util.StringSplitUtils.java</file>
			<file type="M">org.acegisecurity.util.StringSplitUtilsTests.java</file>
			<file type="M">org.acegisecurity.ui.digestauth.DigestProcessingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="501" opendate="2007-07-05 01:15:18" fixdate="2007-08-28 04:02:11" resolution="Fixed">
		<buginformation>
			<summary>convertUrlToLowercaseBeforeComparison in PathBasedFilterInvocationDefinitionMap  is not consistent</summary>
			<description>if convertUrlToLowercaseBeforeComparison is true the url is converted to lower case before URL comparison but the pathMatcher still use the URL defined in the configurations without using toLowerCase and this may lead insorrect result 
see this forum for more details http://forum.springframework.org/showthread.php?t=39492</description>
			<version>1.0.4</version>
			<fixedVersion>1.0.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.intercept.web.PathBasedFilterDefinitionMapTests.java</file>
			<file type="M">org.acegisecurity.intercept.web.PathBasedFilterInvocationDefinitionMap.java</file>
		</fixedFiles>
	</bug>
	<bug id="500" opendate="2007-06-28 21:11:26" fixdate="2007-08-28 23:35:59" resolution="Duplicate">
		<buginformation>
			<summary>Provide a getFilterProcessesUrl (protected or public) method in org.acegisecurity.ui.logout.LogoutFilter so that subclasses can access this parameter</summary>
			<description>Provide a getFilterProcessesUrl (protected or public) method in org.acegisecurity.ui.logout.LogoutFilter so that subclasses can access this parameter.</description>
			<version>1.0.4</version>
			<fixedVersion>1.0.5</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.logout.LogoutFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="depends on">408</link>
			<link type="Duplicate" description="duplicates">408</link>
		</links>
	</bug>
	<bug id="408" opendate="2006-12-03 14:04:17" fixdate="2007-08-28 23:37:44" resolution="Fixed">
		<buginformation>
			<summary>Add getFilterProcessesUrl() to org.acegisecurity.ui.logout.LogoutFilter</summary>
			<description>Please add a getFilterProcessesUrl() method to LogoutFilter to give sub-classes access to the filterProcessesUrl field.
For the JAMWiki project (jamwiki.org) we have a need to use a custom redirect, and therefore have created a subclass of LogoutFilter to implement a custom version of the sendRedirect() method.  Unfortunately this subclass cannot access the filterProcessesUrl field because it is private in the LogoutFilter class and there is no get method in LogoutFilter.  We have worked around the problem by extending the setFilterProcessesUrl() method in our subclass, but it would be much cleaner to just be able to call a parent getFilterProcessesUrl() method.</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.5</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.logout.LogoutFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="is depended on by">500</link>
			<link type="Duplicate" description="is duplicated by">500</link>
		</links>
	</bug>
	<bug id="484" opendate="2007-05-27 12:42:57" fixdate="2007-08-30 06:29:16" resolution="Fixed">
		<buginformation>
			<summary>SessionRegistryImpl.getAllSessions()  Bug?</summary>
			<description>
####&amp;lt;2007-5-25 084749 CST&amp;gt; &amp;lt;Error&amp;gt; &amp;lt;HTTP&amp;gt; &amp;lt;win200310834&amp;gt; &amp;lt;myserver&amp;gt; &amp;lt;ExecuteThread: &amp;amp;apos;35&amp;amp;apos; for queue: &amp;amp;apos;weblogic.kernel.Default&amp;amp;apos;&amp;gt; &amp;lt;&amp;lt;WLS Kernel&amp;gt;&amp;gt; &amp;lt;&amp;gt; &amp;lt;BEA-101020&amp;gt; &amp;lt;[ServletContext(id=18816403,name=WebContent,context-path=/ride)] Servlet failed with Exception
java.lang.Throwable
	at java.util.HashMap$HashIterator.nextEntry()Ljava.util.HashMap$Entry;(Optimized Method)
	at java.util.HashMap$KeyIterator.next()Ljava.lang.Object;(Optimized Method)
	at org.acegisecurity.concurrent.SessionRegistryImpl.getAllSessions(Ljava.lang.Object;Z)[Lorg.acegisecurity.concurrent.SessionInformation;(SessionRegistryImpl.java:80)
	at org.acegisecurity.concurrent.ConcurrentSessionControllerImpl.checkAuthenticationAllowed(Lorg.acegisecurity.Authentication;)V(ConcurrentSessionControllerImpl.java:94)
	at org.acegisecurity.providers.ProviderManager.doAuthentication(Lorg.acegisecurity.Authentication;)Lorg.acegisecurity.Authentication;(ProviderManager.java:196)
	at org.acegisecurity.AbstractAuthenticationManager.authenticate(Lorg.acegisecurity.Authentication;)Lorg.acegisecurity.Authentication;(AbstractAuthenticationManager.java:45)
	at cn.ccb.ride.admin.util.auth.SecurityAuthenticationProcessingFilter.attemptAuthentication(Ljavax.servlet.http.HttpServletRequest;)Lorg.acegisecurity.Authentication;(SecurityAuthenticationProcessingFilter.java:125)
	at org.acegisecurity.ui.AbstractProcessingFilter.doFilter(Ljavax.servlet.ServletRequest;Ljavax.servlet.ServletResponse;Ljavax.servlet.FilterChain;)V(Optimized Method)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(Ljavax.servlet.ServletRequest;Ljavax.servlet.ServletResponse;)V(Optimized Method)
	at org.acegisecurity.ui.logout.LogoutFilter.doFilter(Ljavax.servlet.ServletRequest;Ljavax.servlet.ServletResponse;Ljavax.servlet.FilterChain;)V(Optimized Method)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(Ljavax.servlet.ServletRequest;Ljavax.servlet.ServletResponse;)V(Optimized Method)
	at org.acegisecurity.context.HttpSessionContextIntegrationFilter.doFilter(Ljavax.servlet.ServletRequest;Ljavax.servlet.ServletResponse;Ljavax.servlet.FilterChain;)V(Optimized Method)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(Ljavax.servlet.ServletRequest;Ljavax.servlet.ServletResponse;)V(Optimized Method)
	at org.acegisecurity.concurrent.ConcurrentSessionFilter.doFilter(Ljavax.servlet.ServletRequest;Ljavax.servlet.ServletResponse;Ljavax.servlet.FilterChain;)V(Optimized Method)
	at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(Ljavax.servlet.ServletRequest;Ljavax.servlet.ServletResponse;)V(Optimized Method)
	at org.acegisecurity.util.FilterChainProxy.doFilter(Ljavax.servlet.ServletRequest;Ljavax.servlet.ServletResponse;Ljavax.servlet.FilterChain;)V(Optimized Method)
	at org.acegisecurity.util.FilterToBeanProxy.doFilter(Ljavax.servlet.ServletRequest;Ljavax.servlet.ServletResponse;Ljavax.servlet.FilterChain;)V(Optimized Method)
	at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run()Ljava.lang.Object;(Optimized Method)
	at weblogic.security.acl.internal.AuthenticatedSubject.doAs(Lweblogic.security.subject.AbstractSubject;Ljava.security.PrivilegedAction;)Ljava.lang.Object;(Optimized Method)
	at weblogic.security.service.SecurityManager.runAs(Lweblogic.security.acl.internal.AuthenticatedSubject;Lweblogic.security.acl.internal.AuthenticatedSubject;Ljava.security.PrivilegedAction;)Ljava.lang.Object;(Optimized Method)
	at weblogic.servlet.internal.WebAppServletContext.invokeServlet(Lweblogic.servlet.internal.ServletRequestImpl;Lweblogic.servlet.internal.ServletResponseImpl;)V(Optimized Method)
	at weblogic.servlet.internal.ServletRequestImpl.execute(Lweblogic.kernel.ExecuteThread;)V(Optimized Method)
	at weblogic.kernel.ExecuteThread.execute(Lweblogic.kernel.ExecuteRequest;)V(Optimized Method)
	at weblogic.kernel.ExecuteThread.run()V(ExecuteThread.java:178)
	at java.lang.Thread.startThreadFromVM(Ljava.lang.Thread;)V(Unknown Source)
&amp;gt; 
At the same time, getAllSessions() as followed.
    public SessionInformation[] getAllSessions(Object principal,
        boolean includeExpiredSessions) {
        Set sessionsUsedByPrincipal = (Set) principals.get(principal);
        if (sessionsUsedByPrincipal == null) 
{
            return null;
        }

        List list = new ArrayList();
        Iterator iter = sessionsUsedByPrincipal.iterator();
        while (iter.hasNext()) {
            synchronized (sessionsUsedByPrincipal) {
                String sessionId = (String) iter.next();
                SessionInformation sessionInformation = getSessionInformation(sessionId);
                if (includeExpiredSessions || !sessionInformation.isExpired()) 
{
                    list.add(sessionInformation);
                }
            }
        }
        return (SessionInformation[]) list.toArray(new SessionInformation[] {});
    }
</description>
			<version>1.0.4</version>
			<fixedVersion>1.0.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.concurrent.SessionRegistryImpl.java</file>
			<file type="M">org.acegisecurity.concurrent.SessionRegistryImplTests.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">543</link>
		</links>
	</bug>
	<bug id="398" opendate="2006-11-24 21:14:12" fixdate="2007-08-31 07:43:41" resolution="Fixed">
		<buginformation>
			<summary>HttpSessionContextIntegrationFilter/AuthenticationProcessingFilter thread concurrency issue</summary>
			<description>On a successful authentication I occassionally get redirected back to the login page rather than the requested protected resource. This is due to a thread concurrency issue.
C: GET /protected/resource
S: 302 Redirect to /login
C: GET /login
S: 200 OK
C: POST /j_acegi_security_check  // THREAD-1 (successful login)
S: 302 Redirect to /protected/resource // THREAD-1
 THREAD-1 not finished yet (not reached HttpSessionContextIntegrationFilter post doFilter() block, which means SecurityContext has not been updated with successfull authentication).
C: GET /protected/resource // THREAD-2
S: 302 Redirect to /login // THREAD-2
...
 THREAD-1 completes request and SecurityContext is updated.
Solution:
Delay the redirects using a response wrapper until after the HttpSessionContextIntegrationFilter has updated the SecurityContext.</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.context.HttpSessionContextIntegrationFilterTests.java</file>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilter.java</file>
			<file type="M">org.acegisecurity.context.HttpSessionContextIntegrationFilterTests.java</file>
			<file type="M">org.acegisecurity.ui.AbstractProcessingFilter.java</file>
			<file type="M">org.acegisecurity.ui.AbstractProcessingFilterTests.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">587</link>
			<link type="Related" description="is related to">561</link>
		</links>
	</bug>
	<bug id="549" opendate="2007-09-06 14:40:42" fixdate="2007-09-14 01:34:00" resolution="Fixed">
		<buginformation>
			<summary>AuthenticationProcessingFilter should trim white space from user name</summary>
			<description>When a user logs in with either leading or trailing white space in their user name, authentication still succeeds (we are using a org.acegisecurity.providers.ldap.authenticator.BindAuthenticator), authorities are correctly populated.  However the leading or trailing white space is never removed from the user name, so auth.getName() will include the white space.
Later when JdbcMutableAclService searches for the ACL_SID table or inserts into the ACL_SID table the unwanted white space is used in the where clause or even worse in the insert (if the SID record is being created for the user).
I&amp;amp;apos;m not 100% sure if the ACL queries are incorrect and should perform a trim() on the ACL_SID.sid column, or whether the problem is more fundamental, and the AuthenticationProcessingFilter should perform a trim() after it obtains the user name from the request.
My current thinking leads me to believe the AuthenticationProcessingFilter is at fault, and it should perform the trim() on the user name, as allowing trailing or leading white space in user names sounds like a recipe for confusion.
</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.webapp.AuthenticationProcessingFilterTests.java</file>
			<file type="M">org.acegisecurity.ui.webapp.AuthenticationProcessingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="557" opendate="2007-09-13 06:36:15" fixdate="2007-09-19 03:51:48" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException in ExceptionTranslationFilter: accessDeniedHandler is null</summary>
			<description>NullPointerException is thrown while trying to access secured content with a user which does not have a neccessary role in the Authorities set (Access Denied situation):
java.lang.NullPointerException
  at org.acegisecurity.ui.ExceptionTranslationFilter.handleException(ExceptionTranslationFilter.java:229)
  at org.acegisecurity.ui.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:176)
  at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)
  at org.acegisecurity.providers.anonymous.AnonymousProcessingFilter.doFilter(AnonymousProcessingFilter.java:125)
  at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)
  at org.acegisecurity.ui.rememberme.RememberMeProcessingFilter.doFilter(RememberMeProcessingFilter.java:142)
  at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)
  at org.acegisecurity.ui.basicauth.BasicProcessingFilter.doFilter(BasicProcessingFilter.java:173)
  at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)
  at org.acegisecurity.ui.AbstractProcessingFilter.doFilter(AbstractProcessingFilter.java:271)
  at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)
  at org.acegisecurity.ui.logout.LogoutFilter.doFilter(LogoutFilter.java:110)
  at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)
  at org.acegisecurity.context.HttpSessionContextIntegrationFilter.doFilter(HttpSessionContextIntegrationFilter.java:249)
  at org.acegisecurity.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:275)
  at org.acegisecurity.util.FilterChainProxy.doFilter(FilterChainProxy.java:149)
  at org.acegisecurity.util.FilterToBeanProxy.doFilter(FilterToBeanProxy.java:98)
  at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:202)
  ...
Seems to be caused by accessDeniedHandler being null on that line:
  229: accessDeniedHandler.handle(request, response, (AccessDeniedException) exception);
Seems that for some reason default AccessDeniedHandlerImpl is not being assigned.</description>
			<version>1.0.5</version>
			<fixedVersion>1.0.6, 2.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.acegisecurity.ui.ExceptionTranslationFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="584" opendate="2007-10-26 09:45:47" fixdate="2007-12-01 14:20:56" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentSessionControllerImpl shouldn&amp;apos;t have a default sessionRegistry set internally</summary>
			<description>It contains the code
    private SessionRegistry sessionRegistry = new SessionRegistryImpl();
which is a bad idea, since SessionRegistryImpl must be registered through the application context in order to receive "session destroyed" events. If the user fails to set the sessionRegistry property then things won&amp;amp;apos;t work properly. The ConcurrentSessionFilter may also be using a different session registry instance.</description>
			<version>1.0.0</version>
			<fixedVersion>1.0.6, 2.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.concurrent.ConcurrentSessionControllerImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="618" opendate="2007-12-06 22:31:14" fixdate="2007-12-07 03:22:46" resolution="Fixed">
		<buginformation>
			<summary>Authentication details object should be copied to successful Authentication before ConcurrentSessionController.checkAuthenticationAllowed is called</summary>
			<description>If concurrent session control is used with an authentication provider which doesn&amp;amp;apos;t copy the authentication details object to the successful authentication (e.g. CasAuthenticationProvider) then the check with the concurrent session controller on whether access is allowed takes place before the copyDetails method of AbstractAuthenticationManager is called. This isn&amp;amp;apos;t a problem with classes which extend AbstractUserDetailsAuthenticationProvider, as it copies the authentication details object itself.
The copyDetails method should probably be pulled down into ProviderManager and called before checkAuthenticationAllowed() is called. This will ensure that the details object is available even if  the provider doesn&amp;amp;apos;t set it.
It&amp;amp;apos;s also not clear that we really need an AbstractAuthenticationManager at all, given how little there is in there.</description>
			<version>1.0.5</version>
			<fixedVersion>1.0.6, 2.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.providers.ProviderManager.java</file>
			<file type="M">org.springframework.security.AbstractAuthenticationManager.java</file>
		</fixedFiles>
	</bug>
	<bug id="272" opendate="2006-05-22 22:44:38" fixdate="2008-01-14 07:57:54" resolution="Fixed">
		<buginformation>
			<summary>Provide user group support</summary>
			<description>As discussed at The Spring Experience in December 2005, the community would like a way of grouping users together and assigning those groups roles. We&amp;amp;apos;ll add this feature - which will involve an extra table.</description>
			<version>1.0.1</version>
			<fixedVersion>2.0.0 M2</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.security.userdetails.GroupsManager.java</file>
			<file type="M">org.springframework.security.userdetails.jdbc.JdbcUserDetailsManagerTests.java</file>
			<file type="M">org.springframework.security.userdetails.jdbc.JdbcUserDetailsManager.java</file>
			<file type="M">org.springframework.security.userdetails.jdbc.JdbcDaoImpl.java</file>
			<file type="M">org.springframework.security.PopulatedDatabase.java</file>
			<file type="M">org.springframework.security.userdetails.jdbc.JdbcDaoImplTests.java</file>
			<file type="M">org.acegisecurity.PopulatedDatabase.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">325</link>
			<link type="Related" description="is related to">513</link>
			<link type="Related" description="is related to">391</link>
		</links>
	</bug>
	<bug id="494" opendate="2007-06-12 20:54:54" fixdate="2008-01-17 06:29:43" resolution="Duplicate">
		<buginformation>
			<summary>Add IgnoredChannelProcessor for org.acegisecurity.securechannel.ChannelDecisionManagerImpl</summary>
			<description>when use ajax,switch http and https may cause cross domain exception.
I need:
in page  https://localhost:8443/account/login,dwr is https://localhost:8443/dwr/
in page http://localhost:8080/index,dwr is http://localhost:8080/dwr/
so I add a IgnoredChannelProcessor with key &amp;amp;apos;IGNORED_CHANNEL&amp;amp;apos;
CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
\A/struts/.*\Z=IGNORED_CHANNEL
\A/dwr/.*\Z=IGNORED_CHANNEL
\A/account/.*\Z=REQUIRES_SECURE_CHANNEL
\A/.*\Z=REQUIRES_INSECURE_CHANNEL
</description>
			<version>1.0.4</version>
			<fixedVersion>2.0.0 M2</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.securechannel.ChannelDecisionManagerImplTests.java</file>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.securechannel.ChannelDecisionManagerImpl.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">335</link>
		</links>
	</bug>
	<bug id="335" opendate="2006-08-12 15:15:26" fixdate="2008-01-17 06:47:24" resolution="Fixed">
		<buginformation>
			<summary>Add Secure/InsecureChannelProcessor supporting attribute</summary>
			<description>Most of my URLs fall into two categories: require security (REQUIRES_SECURE_CHANNEL) or require insecure (REQUIRES_INSECURE_CHANNEL). But I have a couple links which must support both HTTP/HTTPS and there is no way for me to express this exception. I recommend two new attributes:
SUPPORTS_INSECURE_CHANNEL
SUPPORTS_SECURE_CHANNEL
Then I can write my bean as follows:
&amp;lt;property name="filterInvocationDefinitionSource"&amp;gt;
  &amp;lt;value&amp;gt;
    CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON 
    \A/secure/.*\Z=REQUIRES_SECURE_CHANNEL 
    \A/myspecialcase/*\Z=SUPPORTS_SECURE_CHANNEL
    \A.*\Z=REQUIRES_INSECURE_CHANNEL
  &amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;</description>
			<version>1.0.1</version>
			<fixedVersion>2.0.0 M2</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.securechannel.ChannelDecisionManagerImplTests.java</file>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.securechannel.ChannelDecisionManagerImpl.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">494</link>
		</links>
	</bug>
	<bug id="633" opendate="2008-01-18 01:47:24" fixdate="2008-01-18 02:14:08" resolution="Fixed">
		<buginformation>
			<summary>AbstractAuthenticationToken.equals does not consider null credentials</summary>
			<description>Our single-sign-on scenarios like OpenID may not have credentials to report. Currently our RememberMeAuthenticationToken handles this issue by returning "" from getCredentials().
AbstractAuthenticationToke.equals should deal with nulls from getCredentials()</description>
			<version>1.0.6</version>
			<fixedVersion>2.0.0 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.providers.AbstractAuthenticationToken.java</file>
		</fixedFiles>
	</bug>
	<bug id="632" opendate="2008-01-17 23:14:46" fixdate="2008-01-19 00:20:02" resolution="Fixed">
		<buginformation>
			<summary>unable to use non security related Filters defined in applicationContext.xml</summary>
			<description>I use a org.springframework.web.filter.DelegatingFilterProxy to configure my application filters in my application context.
as soon as I add some http://www.springframework.org/schema/security namespace driven security, the following exception occurs :
org.springframework.security.config.SecurityConfigurationException: Filter requestFilter must implement the Ordered interface
	at org.springframework.security.config.HttpSecurityConfigPostProcessor.orderFilters(HttpSecurityConfigPostProcessor.java:186)
	at org.springframework.security.config.HttpSecurityConfigPostProcessor.configureFilterChain(HttpSecurityConfigPostProcessor.java:146)
	at org.springframework.security.config.HttpSecurityConfigPostProcessor.postProcessBeanFactory(HttpSecurityConfigPostProcessor.java:47)
	at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:541)
	at org.springframework.context.support.AbstractApplicationContext.invokeBeanFactoryPostProcessors(AbstractApplicationContext.java:524)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:348)
	at org.springframework.web.context.ContextLoader.createWebApplicationContext(ContextLoader.java:251)
	at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:190)
I tracked this down to HttpSecurityConfigPostProcessor.orderFilters using beanFactory.getBeansOfType(Filter.class)
Is there a way that HttpSecurityConfigPostProcessor can be configured to deal with only the filters in the spring-security package ?</description>
			<version>2.0.0 M1</version>
			<fixedVersion>2.0.0 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.HttpSecurityConfigPostProcessor.java</file>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.config.OrderedFilterBeanDefinitionDecorator.java</file>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandler.java</file>
			<file type="M">org.springframework.security.config.Elements.java</file>
			<file type="M">org.springframework.security.ui.FilterChainOrder.java</file>
			<file type="M">org.springframework.security.securechannel.ChannelProcessingFilter.java</file>
			<file type="M">org.springframework.security.ui.SpringSecurityFilter.java</file>
			<file type="M">org.springframework.security.ui.webapp.AuthenticationProcessingFilter.java</file>
			<file type="M">org.springframework.security.providers.x509.X509TestUtils.java</file>
			<file type="M">org.springframework.security.providers.anonymous.AnonymousProcessingFilter.java</file>
			<file type="M">org.springframework.security.wrapper.SecurityContextHolderAwareRequestFilter.java</file>
			<file type="M">org.springframework.security.concurrent.ConcurrentSessionFilter.java</file>
			<file type="D">org.springframework.security.ui.FilterChainOrderUtils.java</file>
			<file type="M">org.springframework.security.ui.cas.CasProcessingFilter.java</file>
			<file type="M">org.springframework.security.ui.basicauth.BasicProcessingFilter.java</file>
			<file type="M">org.springframework.security.ui.webapp.DefaultLoginPageGeneratingFilter.java</file>
			<file type="M">org.springframework.security.intercept.web.FilterSecurityInterceptor.java</file>
			<file type="M">org.springframework.security.context.HttpSessionContextIntegrationFilter.java</file>
			<file type="M">org.springframework.security.ui.rememberme.RememberMeProcessingFilter.java</file>
			<file type="M">org.springframework.security.ui.logout.LogoutFilter.java</file>
			<file type="M">org.springframework.security.ui.ExceptionTranslationFilter.java</file>
			<file type="M">org.springframework.security.ui.ntlm.NtlmProcessingFilter.java</file>
			<file type="M">org.springframework.security.ui.switchuser.SwitchUserProcessingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="636" opendate="2008-01-20 09:14:58" fixdate="2008-01-21 01:40:38" resolution="Fixed">
		<buginformation>
			<summary>ref attribute of PasswordEncoderParser not implemented and causes exception to occur</summary>
			<description>The implementation of PasswordEncoderParser doesn&amp;amp;apos;t seem to support the ref attribute and an exception will occur when the ref attribute is specified.
Suggested implementation and more details  : http://forum.springframework.org/showthread.php?t=48779</description>
			<version>2.0.0 M1</version>
			<fixedVersion>2.0.0 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.PasswordEncoderParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="630" opendate="2008-01-14 06:29:35" fixdate="2008-01-21 03:18:11" resolution="Fixed">
		<buginformation>
			<summary>The "properties" attribute of the &lt;user-service&gt; element doesn&amp;apos;t do anything</summary>
			<description>The properties attribute of the user-service element is included in the XML schema, but UserServiceBeanDefinitionParser never looks at it.
The attached patch implements this; as implemented, the properties attribute takes precedence over nested &amp;lt;user&amp;gt; elements.</description>
			<version>2.0.0 M1</version>
			<fixedVersion>2.0.0 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.UserServiceBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.BeanIds.java</file>
		</fixedFiles>
	</bug>
	<bug id="643" opendate="2008-01-22 03:32:21" fixdate="2008-01-22 04:33:34" resolution="Fixed">
		<buginformation>
			<summary>Namespace element http-security doesn&amp;apos;t work without RememberMeServices</summary>
			<description>If no remember-me configuration is used, the following error will be incorrectly reported by HttpSecurityConfigPostProcessor:
org.springframework.security.config.SecurityConfigurationException: More than one RememberMeServices bean found.
        at org.springframework.security.config.HttpSecurityConfigPostProcessor.injectRememberMeServicesIntoFiltersRequiringIt(HttpSecurityConfigPostProcessor.java:72)</description>
			<version>2.0.0 M1</version>
			<fixedVersion>2.0.0 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.HttpSecurityConfigPostProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="644" opendate="2008-01-22 04:12:38" fixdate="2008-01-26 10:34:01" resolution="Fixed">
		<buginformation>
			<summary>NtlmProcessingFilter broken</summary>
			<description>NtlmProcessingFilter no longer calls chain.doFilter(request, response) to progress down the filter chain.
This was broken when it was changed to subclass SpringSecurityFilter instead of HttpFilter</description>
			<version>2.0.0 M1</version>
			<fixedVersion>2.0.0 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ui.ntlm.NtlmProcessingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="662" opendate="2008-02-04 05:22:32" fixdate="2008-02-04 05:27:44" resolution="Fixed">
		<buginformation>
			<summary>ProviderManager should not pass null authenitication to ConcurrentSessionController.checkAuthenticationAllowed()</summary>
			<description>It is valid for an AuthenticationProvider to return null, but this will cause ConcurrentSessionController to throw an exception. An extra null check is needed in ProviderManager.doAuthentication</description>
			<version>2.0.0 M1</version>
			<fixedVersion>2.0.0 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.providers.ProviderManager.java</file>
		</fixedFiles>
	</bug>
	<bug id="581" opendate="2007-10-25 01:06:33" fixdate="2008-02-15 00:12:02" resolution="Fixed">
		<buginformation>
			<summary>CasAuthenticationProvider does not copy the details object into Authentication</summary>
			<description>If we want to have audit logging and check for authenticate event, with cas the user details are not copied in this first even thus we are unable to know from which ip the authenticate event is originating from (or whatever else information is carried in the details).
The WebAuthenticationDetails in the passed authentication object is copied to the CasAuthenticationToken only after it has been published (see AbstractAuthenticationManager::authenticate(Authentication)) , thus in the AuthenticationEvent you miss the servlet request where it is originating.
I did a workaround to do it as follows:
public class CasAuthenticationProvider extends org.acegisecurity.providers.cas.CasAuthenticationProvider {
    public Authentication authenticate(Authentication authentication) throws AuthenticationException 
{
        CasAuthenticationToken result =  (CasAuthenticationToken)super.authenticate(authentication);
        copyDetails(authentication, result);
        return result;
    }

    protected void copyDetails(Authentication source, CasAuthenticationToken dest) {
        if (dest.getDetails() == null) 
{
            Object details = source.getDetails();
            dest.setDetails(details);
        }
    }
}
</description>
			<version>1.0.5</version>
			<fixedVersion>1.0.7, 2.0.0 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.providers.cas.CasAuthenticationProvider.java</file>
			<file type="M">org.springframework.security.providers.cas.CasAuthenticationProviderTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="577" opendate="2007-10-16 04:57:39" fixdate="2008-02-15 00:35:43" resolution="Fixed">
		<buginformation>
			<summary>Replace SWITCH_USER_GRANTED_AUTHORITY for ROLE_PREVIOUS_ADMINISTRATOR in Javadoc</summary>
			<description>SWITCH_USER_GRANTED_AUTHORITY should be replaced in the Javadocs for ROLE_PREVIOUS_ADMINISTRATOR. The code changed long ago but the Javadoc for SwitchUserProcessingFilter has not.</description>
			<version>1.0.5</version>
			<fixedVersion>1.0.7, 2.0.0 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ui.switchuser.SwitchUserProcessingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="713" opendate="2008-03-11 02:45:06" fixdate="2008-03-11 06:02:03" resolution="Fixed">
		<buginformation>
			<summary>Annotation-driven security fails when using Spring &gt; 2.0.6</summary>
			<description>The AnnotationDrivenBeanDefinitionParser tests fail when Spring version is upgraded from 2.0.6 to 2.0.7.</description>
			<version>2.0.0 M2</version>
			<fixedVersion>2.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.AnnotationDrivenBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="717" opendate="2008-03-15 14:59:35" fixdate="2008-03-15 16:04:04" resolution="Fixed">
		<buginformation>
			<summary>Issue with User.getAuthorities() returning GrantedAuthority[]s in varying order and User.equals(Object) test failures as a result</summary>
			<description>JdbcUserDetailsManagerTests would fail during the createUserInsertsCorrectData and updateUserChangesDataCorrectlyAndClearsCache tests on certain platforms.
This was due to issues with the GrantedAuthority[] iteration order as returned by User. This problem was caused because the tests included:
private static final UserDetails joe = new User("joe", "password", true, true, true, true, AuthorityUtils.stringArrayToAuthorityArray(new String[]
{"A","C","B"}
));
In turn JdbcDaoImpl.loadUserByUsername(String) is internally using a HashSet to manage the merging of GrantedAuthority[] instances from groups, those directly-assigned to the user, and any provided via the addCustomAuthorities(String username, List authorities) method. Because HashSet does not guarantee the order in which elements are returned, some platforms would return the above authorities as A, C, B (as required by the User.equals(Object) method and tests such as JdbcUserDetailsManagerTests which use User.equals(Object)) whereas others would reorder it (to A, B, C, although other variants were possible):
java.lang.AssertionError: expected:&amp;lt;org.springframework.security.userdetails.User@234c9000: Username: joe; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: A, C, B&amp;gt; but was:&amp;lt;org.springframework.security.userdetails.User@234c9000: Username: joe; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: A, B, C&amp;gt;
The issue is not so much with JdbcDaoImpl or its corresponding test, but rather that the User.equals(Object) method and/or User.getAuthorities() should more predictably operate when the GrantedAuthority[] array ordering varies. I am unaware of any users depending on GrantedAuthority[] ordering logic, as this has never been specified in the UserDetails contract as predictable. Therefore the most appropriate solution to this issue is to specify that UserDetails.getAuthorities() must consistently return GrantedAuthority[]s in the order of their natural key, irrespective of the order in which the GrantedAuthority[]s were added to the UserDetails instance. The UserDetails.equals(Object) should ensure it uses UserDetails.getAuthorities() in its evaluations, thus simplifying implementation of the symmetry requirements associated with Object.hashCode(). The GrantedAuthority interface should also extend Comparable, to ensure implementations have a simple way of implementing the required logic.</description>
			<version>1.0.0</version>
			<fixedVersion>2.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.taglibs.authz.AuthorizeTagCustomGrantedAuthorityTests.java</file>
			<file type="M">org.springframework.security.adapters.jboss.JbossSpringSecurityLoginModuleTests.java</file>
			<file type="M">org.springframework.security.adapters.jetty.JettyAcegiUserRealmTests.java</file>
			<file type="M">org.springframework.security.providers.portlet.populator.ContainerPortletAuthoritiesPopulatorTests.java</file>
			<file type="M">org.springframework.security.adapters.resin.ResinAcegiAuthenticatorTests.java</file>
			<file type="M">org.springframework.security.adapters.catalina.CatalinaSpringSecurityUserRealmTests.java</file>
			<file type="M">org.springframework.security.userdetails.UserTests.java</file>
			<file type="M">org.springframework.security.GrantedAuthorityImpl.java</file>
			<file type="M">org.springframework.security.GrantedAuthority.java</file>
			<file type="M">org.springframework.security.userdetails.UserDetails.java</file>
			<file type="M">org.springframework.security.GrantedAuthorityImplTests.java</file>
			<file type="M">org.springframework.security.userdetails.User.java</file>
		</fixedFiles>
	</bug>
	<bug id="725" opendate="2008-03-20 04:26:57" fixdate="2008-03-23 10:40:15" resolution="Fixed">
		<buginformation>
			<summary>PasswordEncoderParser: &lt;security:password-encoder&gt; element does not pick up &amp;apos;base64&amp;apos; attribute value</summary>
			<description>In my Spring configuration I have the following fragment:
Code:
&amp;lt;security:authentication-provider&amp;gt;
    &amp;lt;security:password-encoder hash="md5" base64="true"/&amp;gt;
    ......
&amp;lt;/security:authentication-provider&amp;gt;
The problem is that even although I specified base64="true" the configuration parser does not pick it up. My PasswordEncoder is still installed with &amp;amp;apos;encodeHashAsBase64&amp;amp;apos; property &amp;amp;apos;false&amp;amp;apos;.
Analysis: After debugging I was able to locate the reason for the bug. It is located on the line 73 of class org.springframework.security.config.PasswordEncoderParser in the method parse(Element element, ParserContext parserContext)
This code goes like this:
Code:
private void parse(Element element, ParserContext parserContext) {
    ...
    if (StringUtils.hasText(ref)) 
{
            ....
    }
 else {
      Class beanClass = (Class) ENCODER_CLASSES.get(hash);
      RootBeanDefinition beanDefinition = new RootBeanDefinition(beanClass);
      beanDefinition.setSource(parserContext.extractSource(element));
      if (useBase64) {
         if (beanClass.isAssignableFrom(BaseDigestPasswordEncoder.class)) 
{
            beanDefinition.getPropertyValues().addPropertyValue("encodeHashAsBase64", "true");
         }
 else 
{
            logger.warn(ATT_BASE_64 + " isn&amp;amp;apos;t compatible with " + OPT_HASH_LDAP_SHA + " and will be ignored");
         }
      }
      passwordEncoder = beanDefinition;
  }
The problematic part is here:
if (beanClass.isAssignableFrom(BaseDigestPasswordEncod er.class)) {
beanDefinition.getPropertyValues().addPropertyValue("encodeHashAsBase64", "true");
} else {
logger.warn(ATT_BASE_64 + " isn&amp;amp;apos;t compatible with " + OPT_HASH_LDAP_SHA + " and will be ignored");
}
The condition in the &amp;amp;apos;if&amp;amp;apos; statement should be coded the other way around, i.e.
if (BaseDigestPasswordEncoder.class.isAssignableFrom(b eanClass))
{...}
 to set up "encodeHashAsBase64" properly.
Also: the warning message in the &amp;amp;apos;else&amp;amp;apos; clause of &amp;amp;apos;if&amp;amp;apos; statment above is incorrect too. No matter what algorithm you configure in your &amp;lt;securityassword-encoder&amp;gt; it always outputs &amp;amp;apos;
{sha}
&amp;amp;apos;. The reason is that insead of the runtime &amp;amp;apos;hash&amp;amp;apos; parameter the message hardcodes OPT_HASH_LDAP_SHA.</description>
			<version>2.0.0 M2</version>
			<fixedVersion>2.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.PasswordEncoderParser.java</file>
			<file type="M">org.springframework.security.config.AuthenticationProviderBeanDefinitionParserTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="99" opendate="2005-11-14 14:27:20" fixdate="2008-03-24 11:45:11" resolution="Fixed">
		<buginformation>
			<summary>MethodDefinitionMap must support superclass declared methods</summary>
			<description>As reported by Tom Dunstan, MethodDefinitionMap line 168 by default will only locate methods declared for the class, and not for superclasses (ie uses clazz.getMethods() instead of clazz.getDeclaredMethods()). Whilst this is consistent with Spring&amp;amp;apos;s transaction handling, it does present an issue for those relying on generic superclasses and wanting to define authorization configuration attributes against them. It is proposed to add a new keyword to the property editor to direct MethodDefinitionMap to use getDeclaredMethods() vs getMethods(), such that by default the existing behaviour is preserved (to be consistent with transaction services) but the superclass search behaviour can be used instead. Alternatively, we could introduce an optional prefix the method name, such as "+", which denotes "locate the matching methods in the superclass". This would have the added advantage of ensuring only patterns where you deliberately want to use getDeclaredMethods() will use that method.</description>
			<version>1.0.0</version>
			<fixedVersion>2.0.0 RC1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionSourceEditorTests.java</file>
			<file type="D">org.springframework.security.annotation.Jsr250SecurityAnnotationAttributes.java</file>
			<file type="D">org.springframework.security.intercept.method.MethodDefinitionMap.java</file>
			<file type="M">org.springframework.security.util.SimpleMethodInvocation.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodInvocationPrivilegeEvaluatorTests.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionAttributesTests.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionSourceEditor.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodDefinitionSourceAdvisor.java</file>
			<file type="M">org.springframework.security.config.AnnotationDrivenBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.intercept.method.MockMethodDefinitionSource.java</file>
			<file type="M">org.springframework.security.OtherTargetObject.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodDefinitionSourceAdvisorTests.java</file>
			<file type="M">org.springframework.security.config.InterceptMethodsBeanDefinitionDecorator.java</file>
			<file type="M">org.springframework.security.ConfigAttributeDefinition.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionSource.java</file>
			<file type="M">org.springframework.security.intercept.method.aspectj.AspectJSecurityInterceptorTests.java</file>
			<file type="M">org.springframework.security.context.rmi.ContextPropagatingRemoteInvocationTests.java</file>
			<file type="M">org.springframework.security.annotation.MethodDefinitionSourceEditorTigerTests.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodSecurityInterceptorTests.java</file>
			<file type="M">org.springframework.security.MockJoinPoint.java</file>
			<file type="D">org.springframework.security.annotation.SecurityAnnotationAttributes.java</file>
			<file type="D">org.springframework.security.annotation.SecurityAnnotationAttributesTests.java</file>
			<file type="M">org.springframework.security.util.MethodInvocationUtils.java</file>
			<file type="M">org.springframework.security.intercept.method.MethodDefinitionAttributes.java</file>
			<file type="M">org.springframework.security.vote.BasicAclEntryVoterTests.java</file>
			<file type="M">org.springframework.security.config.BeanIds.java</file>
			<file type="D">org.springframework.security.annotation.Jsr250SecurityAnnotationAttributesTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="is depended on by">428</link>
			<link type="Duplicate" description="is duplicated by">424</link>
			<link type="Duplicate" description="is duplicated by">353</link>
			<link type="Related" description="is related to">734</link>
		</links>
	</bug>
	<bug id="728" opendate="2008-03-20 22:14:55" fixdate="2008-03-30 20:52:20" resolution="Fixed">
		<buginformation>
			<summary>[patch] MessageDigestPasswordEncoder#encodePassword is platform-dependant (with fix)</summary>
			<description>MessageDigestPasswordEncoder#encodePassword uses saltedPass.getBytes() which is highly platform-dependant (it uses the platform&amp;amp;apos;s default charset).
Creating a new user account (with "strong" salt: accents, weird chars, etc.) on a Linux machine, moving the server to Mac OS X or Windows, and trying to access the same user account fails.
Fix: replace:
saltedPass.getBytes()
with:
saltedPass.getBytes(org.apache.commons.lang.CharEncoding.UTF_8)
In theory, the new String(...) a couple of lines later /should/ specify an encoding too (e.g. ISO-Latin-9, AKA ISO-8859-15). But since we are dealing with a sub-set of ASCII, there is no encoding problem here.</description>
			<version>1.0.6</version>
			<fixedVersion>2.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.providers.ldap.authenticator.LdapShaPasswordEncoder.java</file>
			<file type="M">org.springframework.security.providers.encoding.MessageDigestPasswordEncoder.java</file>
			<file type="M">org.springframework.security.providers.encoding.Md4PasswordEncoder.java</file>
		</fixedFiles>
	</bug>
	<bug id="602" opendate="2007-11-14 07:37:38" fixdate="2008-04-04 13:47:38" resolution="Fixed">
		<buginformation>
			<summary>Acl (Acls) class ObjectIdentityRetrievalStrategyImpl doesn&amp;apos;t work well with proxied objects</summary>
			<description>When using the AclEntryAfterInvocationProvider to check acl access on an object which has been instantiated by (in my case) hibernate, it is possible that hibernate will return a cglib enhanced instance of the object (or it might not).  When  ObjectIdentityRetrievalStrategyImpl then attempts to create an ObjectIdentity for it, that class name it gets is something like "com.mycompany.Foo$$EnhancerByCGLIB$$beb2e4f5", which does not match up with the class reference in the ObjectIdentity database record which is "com.mycompany.Foo", and no corresponding ACL entries will be found for the object.
I&amp;amp;apos;ve found a couple of solutions for this, the first is to deproxy the object immediately after the query using a method something like:
public static Object deproxy(Object obj)
  {
    Hibernate.initialize(obj);
    if (obj == null)
    {
      return null;
    }

    if (HibernateProxy.class.isInstance(obj))
    {
      HibernateProxy proxy = (HibernateProxy) obj;
      return proxy.getHibernateLazyInitializer().getImplementation();
    }

    return obj;
  } 
NOTE: Hibernate.initialise(object) doesn&amp;amp;apos;t work, because although it may flesh out the proxied object, it returns void, so we are still left holding onto the proxy.
I don&amp;amp;apos;t particularly like this approach, because for every factory method we need to remember to deproxy the found object, and where collections are returned, we&amp;amp;apos;d need to deproxy every object in the collection.
An alternative solution is to write a ProxyAwareObjectIdentityRetrievalStrategy implementation.  This is feasible because all (I think) classes that use an ObjectIdentityRetrievalStrategy  support dependency injection.
I&amp;amp;apos;ve had a go at this, and got the cglib enhanced case taken care of, but I also thought that the case where a Jdk proxy is returned needs to be addressed also.  I&amp;amp;apos;ve found a simple way to detect a Jdk proxy, but cannot figure how to get the class name we actually want out of it, as Jdk proxies only work on interfaces, and it&amp;amp;apos;s the InvokationHandler that does all the delegation.
class and tests will be attached.</description>
			<version>1.0.3</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.objectidentity.ObjectIdentityImpl.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="is depended on by">532</link>
		</links>
	</bug>
	<bug id="697" opendate="2008-03-06 03:44:11" fixdate="2008-04-04 14:10:23" resolution="Fixed">
		<buginformation>
			<summary>It&amp;apos;s not possible to change ACL owner</summary>
			<description>MutableAcl interface doesn&amp;amp;apos;t have a method to change ACL owner (although AclImpl has an appropriate implementation)</description>
			<version>1.0.6</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.MutableAcl.java</file>
		</fixedFiles>
	</bug>
	<bug id="676" opendate="2008-02-15 08:20:02" fixdate="2008-04-04 14:43:37" resolution="Fixed">
		<buginformation>
			<summary>Children Acls are not removed from cache when parent is deleted</summary>
			<description>Calling jdbcMutableAclService.deleteAcl(parentOid, true) should remove the parent acl and, also, its children. The records are deleted from database, but the children related entries from cache are not removed.
The element in cache was built using an ObjectIdentityImpl that received as parameters a string as class name and a Long as domain object id. But, calling JdbcAclService.findChildren() the domain objects returned are created using two strings as parameters and because of this the children are not found in cache and, thus, not removed.
A possible solution could be the creation of ObjectIdentityImpl objects in JdbcAclService.findChildren() method using a Long as the id of the domain object.
The test method demonstrating this behavior is found JdbcAclServiceTests - testDeleteAclAlsoDeletesChildren.</description>
			<version>2.0.0 M1</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclServiceTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="655" opendate="2008-01-30 15:53:17" fixdate="2008-04-04 17:18:09" resolution="Fixed">
		<buginformation>
			<summary>When inserting ACE&amp;apos;s in a parent ACL it&amp;apos;s possible to end up with a child ACL that has a stale reference to its parent</summary>
			<description>The JdbcMutableAclService in its updateAcl method evicts the ObjectIdentity from the cache. However, it should probably evict child ObjectIdentities too whose parent ACL now is no longer in cache.</description>
			<version>2.0.0 M1</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclServiceTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="is depended on by">532</link>
		</links>
	</bug>
	<bug id="589" opendate="2007-11-05 14:01:15" fixdate="2008-04-04 19:09:47" resolution="Fixed">
		<buginformation>
			<summary>BasicLookupStrategy#readAclsById(ObjectIdentity[], Sid[]), throws exception, when a warning log would do</summary>
			<description>There is a small section of code at the end org.acegisecurity.acls.jdbc.BasicLookupStrategy that iterates through all the supplied ObjectIdentities, and checks that an Acl has been found for each.  If any ObjectIdentity does not have a corresponding Acl an exception is thrown.
I would assume that in some applications there may not be an Acl for every single domain object under Acl control, as projects using this library may decide to create Acls only as needed, and the absence of an Acl means no access. This  makes an exception too strong.
I think logging a warning to a commons logger would be more suitable, some thing like
         // Now we&amp;amp;apos;re done, check every requested object identity was found 
        // and log it.
        if (LOG.isWarnEnabled()) {
          for (int i = 0; i &amp;lt; objects.length; i++) {
              if (!result.containsKey(objects[i])) 
{
                  LOG.warn("Unable to find ACL information for object identity &amp;amp;apos;"
                      + objects[i].toString() + "&amp;amp;apos;");
              }
          }
        }
        return result;
    }
NOTE: This issue should probably be added to 
http://opensource.atlassian.com/projects/spring/browse/SEC-532</description>
			<version>1.0.3</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.LookupStrategy.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategy.java</file>
			<file type="M">org.springframework.security.acls.AclService.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="is depended on by">590</link>
			<link type="Depends" description="is depended on by">532</link>
		</links>
	</bug>
	<bug id="572" opendate="2007-10-11 01:35:45" fixdate="2008-04-04 19:16:31" resolution="Fixed">
		<buginformation>
			<summary>Cannot set ACL&amp;apos;s parent to null</summary>
			<description>The setParent() method in AclImpl throws an exception if I try to set the parent to null. I cannot see why I shouldn&amp;amp;apos;t be able to do this. After all, the constructor allows me to set parent to null. 
In our app we have a tree like structure of objects which are secured using Acegi&amp;amp;apos;s ACL package (the new implementation). Permissions are inherited throughout the tree. Nodes in the tree can be moved around and can become top level nodes. This is why we would like to be able to set parent to null. The work around is to use an invisible super root node for all top level nodes. We would prefer not to have to do that.</description>
			<version>1.0.5</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.domain.AclImpl.java</file>
			<file type="M">org.springframework.security.ui.webapp.AuthenticationProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.ui.AbstractProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.ui.AbstractProcessingFilter.java</file>
			<file type="M">org.springframework.security.ui.webapp.AuthenticationProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="is depended on by">532</link>
			<link type="Duplicate" description="is duplicated by">597</link>
		</links>
	</bug>
	<bug id="530" opendate="2007-08-22 03:40:13" fixdate="2008-04-05 07:45:06" resolution="Fixed">
		<buginformation>
			<summary>ACLs: No way to insert an ACE at the first position in the ACE list</summary>
			<description>The new Acl interface specifies the method:
void insertAce(Serializable afterAceId, Permission permission, Sid sid, boolean granting)
        throws NotFoundException;
but doesn&amp;amp;apos;t specify what happens if the afterAceId is null. In fact the AclImpl adds it to the end of the list. This means there are two ways to add to the end of the list and no way to add to the start of the list. Either the null behaviour should be changed to add to the start of the list , or beforeAceIds should be used. Changing the behaviour of null seems preferable and requires only the one line change in the insertAce method of AclImpl:
this.aces.add(ace)
to
this.aces.add(0, ace);
This is vital functionality as we are intending to use the ordering to implement the order of precedence in an acl ie user denies, user grants, role denies, role grants then check parent.</description>
			<version>1.0.4</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">samples.dms.src.main.java.sample.dms.secured.SecureDocumentDaoImpl.java</file>
			<file type="M">org.springframework.security.acls.MutableAcl.java</file>
			<file type="M">org.springframework.security.acls.jdbc.AclPermissionInheritanceTests.java</file>
			<file type="M">samples.contacts.src.main.java.sample.contact.DataSourcePopulator.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclServiceTests.java</file>
			<file type="M">org.springframework.security.acls.domain.AclImplementationSecurityCheckTests.java</file>
			<file type="M">org.springframework.security.acls.AuditableAcl.java</file>
			<file type="M">org.springframework.security.acls.domain.AclImplTests.java</file>
			<file type="M">samples.contacts.src.main.java.sample.contact.ContactManagerBackend.java</file>
			<file type="M">samples.dms.src.main.java.sample.dms.secured.SecureDataSourcePopulator.java</file>
			<file type="M">org.springframework.security.acls.domain.AclImpl.java</file>
			<file type="M">org.springframework.security.acls.Acl.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="is depended on by">532</link>
		</links>
	</bug>
	<bug id="422" opendate="2007-01-02 22:02:11" fixdate="2008-04-05 09:17:29" resolution="Fixed">
		<buginformation>
			<summary>BasicLookupStrategy - computeRepeatingSql contains bad SQL</summary>
			<description>The line
+ "ACL_OBJECT_IDENTITY,ENTRIES_INHERITING, "
should be
+ "ACL_OBJECT_IDENTITY.ENTRIES_INHERITING, " (notice the dot instead of comma)</description>
			<version>1.0.4</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategy.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">467</link>
		</links>
	</bug>
	<bug id="590" opendate="2007-11-05 14:17:19" fixdate="2008-04-05 09:34:14" resolution="Fixed">
		<buginformation>
			<summary>BasicLookupStrategy#readAclsById(ObjectIdentity[], Sid[]) has a loop that sometimes terminates prematurely</summary>
			<description>The main for loop in 
org.acegisecurity.acls.jdbc.BasicLookupStrategy#readAclsById(ObjectIdentity[], Sid[])  
uses &amp;amp;apos;continue;&amp;amp;apos; when an Acl is either found to be already in the results, or is found in the cache.  But the section of code that looks up batches Acls from the database is in the loop, so if the last ObjectIdentity in the in the objects array is found in the results or cache, the loop will terminate without looking up the last batch of Acls from the database.
I&amp;amp;apos;ve written a unit test to prove this, it should be added to org.acegisecurity.acls.jdbc.LookupStrategyTest
/**

A test specifically for a bug, where if the LAST 
{@link ObjectIdentity} in 
   * the array of of Oids we are getting ACL&amp;amp;apos;s for is in the cache, the 
   * collection of {@link ObjectIdentity}
 being collected for a bulk database
lookup will not be processed due to some inapropriate &amp;lt;code&amp;gt;Continue&amp;lt;/code&amp;gt;
statements in the loop.

@throws Exception
   */
  public void testReadLastIsCachedBugFix() throws Exception
  {
    ObjectIdentity grandParentOid = new ObjectIdentityImpl("org.acegisecurity.TargetObject", new Long(104));
    ObjectIdentity parent1Oid = new ObjectIdentityImpl("org.acegisecurity.TargetObject", new Long(105));
    ObjectIdentity parent2Oid = new ObjectIdentityImpl("org.acegisecurity.TargetObject", new Long(106));
    ObjectIdentity childOid = new ObjectIdentityImpl("org.acegisecurity.TargetObject", new Long(107));

    MutableAcl grandParentAcl = jdbcMutableAclService.createAcl(grandParentOid);
    MutableAcl parent1Acl = jdbcMutableAclService.createAcl(parent1Oid);
    MutableAcl parent2Acl = jdbcMutableAclService.createAcl(parent2Oid);
    MutableAcl childAcl = jdbcMutableAclService.createAcl(childOid);
    // Specify the inheritence hierarchy
    parent1Acl.setParent(grandParentAcl);
    parent2Acl.setParent(grandParentAcl);
    childAcl.setParent(parent1Acl);
    // Now let&amp;amp;apos;s add a couple of permissions
    grandParentAcl.insertAce(null, BasePermission.READ, new PrincipalSid(auth), true);
    // Explictly save the changed ACL
    jdbcMutableAclService.updateAcl(grandParentAcl);
    jdbcMutableAclService.updateAcl(parent1Acl);
    jdbcMutableAclService.updateAcl(parent2Acl);
    jdbcMutableAclService.updateAcl(childAcl);
    // fluch cache to make sure we they are retieved from DB
    cache.removeAll();
    // first lookup only child
    Permission[] checkPermision = new Permission[] 
{BasePermission.READ}
;
    Sid[] sids = new Sid[] 
{ new PrincipalSid(auth)}
;
    ObjectIdentity[] childOids = new ObjectIdentity[] 
{childOid}
;
    Map foundAcls = lookupStrategy.readAclsById(childOids, sids);
    Acl foundChildAcl = (Acl) foundAcls.get(childOid);
    assertNotNull(foundChildAcl);
    assertTrue(foundChildAcl.isGranted(checkPermision, sids, false));
    // we now expect that the acls for child, parent1 and grandparent are cached
    // if the bug is present and we now search for all for acls, and make sure
    // that batchsize is greater than 4, and that parent2 is not the last in the 
    // oid array (it&amp;amp;apos;s the only one not cached), then having an aleady cached
    // ACL as the last in the oid array to lookup, will cause the BUG we are 
    // for testing to skip the DB lookup when the last entry to check is 
    // retireved from the cache.
    ObjectIdentity[] allOids = new ObjectIdentity[] 
{grandParentOid, parent1Oid, parent2Oid, childOid}
;
    foundAcls = lookupStrategy.readAclsById(allOids, sids);
    Acl foundParent2Acl = (Acl) foundAcls.get(parent2Oid);
    assertNotNull(foundParent2Acl);
    assertTrue(foundParent2Acl.isGranted(checkPermision, sids, false));
 }
And rewritten org.acegisecurity.acls.jdbc.BasicLookupStrategy#readAclsById(ObjectIdentity[], Sid[])  to fix it
/**

The main method.&amp;lt;p&amp;gt;WARNING: This implementation completely disregards the "sids" parameter! Every item
in the cache is expected to contain all SIDs. If you have serious performance needs (eg a very large number of
SIDs per object identity), you&amp;amp;apos;ll probably want to develop a custom 
{@link LookupStrategy}
 implementation
instead.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The implementation works in batch sizes specfied by 
{@link #batchSize}
.&amp;lt;/p&amp;gt;
     *
@param objects DOCUMENT ME!
@param sids DOCUMENT ME!
     *
@return DOCUMENT ME!
     *
@throws NotFoundException DOCUMENT ME!
@throws IllegalStateException DOCUMENT ME!
     */
    public Map readAclsById(ObjectIdentity[] objects, Sid[] sids)
        throws NotFoundException {
        Assert.isTrue(batchSize &amp;gt;= 1, "BatchSize must be &amp;gt;= 1");
        Assert.notEmpty(objects, "Objects to lookup required");

        // Map&amp;lt;ObjectIdentity,Acl&amp;gt;
        Map result = new HashMap(); // contains FULLY loaded Acl objects
        Set currentBatchToLoad = new HashSet(); // contains ObjectIdentitys
        for (int i = 0; i &amp;lt; objects.length; i++) {
            // flag to record if we have found the acl for this iteration
            boolean aclFound = false;
            // 1.) Check we don&amp;amp;apos;t already have this ACL in the results
            if (result.containsKey(objects[i])) 
{
                aclFound = true; // flag as found
            }

            // 2.) Check cache for the present ACL entry
            if (!aclFound) {
              Acl acl = aclCache.getFromCache(objects[i]);
              // Ensure any cached element supports all the requested SIDs
              // (they should always, as our base impl doesn&amp;amp;apos;t filter on SID)
              if (acl != null) {
                  if (acl.isSidLoaded(sids)) 
{
                      result.put(acl.getObjectIdentity(), acl);
                      aclFound = true; // flag as found
                  }
 else 
{
                      throw new IllegalStateException(
                          "Error: SID-filtered element detected when implementation does not perform SID filtering - have you added something to the cache manually?");
                  }
              }
            }
            // 3. Load the Acl from the database
            if (!aclFound) 
{
              currentBatchToLoad.add(objects[i]);
            }

            // Is it time to load from JDBC the currentBatchToLoad?
            if ((currentBatchToLoad.size() == this.batchSize) || ((i + 1) == objects.length)) {
                if (currentBatchToLoad.size() &amp;gt; 0) {
                    Map loadedBatch = lookupObjectIdentities((ObjectIdentity[]) currentBatchToLoad.toArray(
                                new ObjectIdentity[] {}), sids);
                    // Add loaded batch (all elements 100% initialized) to results
                    result.putAll(loadedBatch);
                    // Add the loaded batch to the cache
                    Iterator loadedAclIterator = loadedBatch.values().iterator();
                    while (loadedAclIterator.hasNext()) 
{
                        aclCache.putInCache((AclImpl) loadedAclIterator.next());
                    }
                }
                currentBatchToLoad.clear();
            }
        }
        // Now we&amp;amp;apos;re done, check every requested object identity was found 
        // and log it.
        if (LOG.isWarnEnabled()) {
          for (int i = 0; i &amp;lt; objects.length; i++) {
              if (!result.containsKey(objects[i])) 
{
                  LOG.warn("Unable to find ACL information for object identity &amp;amp;apos;"
                      + objects[i].toString() + "&amp;amp;apos;");
              }
          }
        }
        return result;
    }
Note: This should probably be added to 
http://opensource.atlassian.com/projects/spring/browse/SEC-532
NOTE: 2
This should be fixed after 
http://opensource.atlassian.com/projects/spring/browse/SEC-547
(included code contains fix for 547 and 589 also)
NOTE: 3 This bug was very difficult to replicate in our application, because it is dependent on the last ObjectIdentity being found in the cache AND there being a batch or part batch of Acls to be looked up.</description>
			<version>1.0.3</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategyTests.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategy.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclServiceTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="depends on">547</link>
			<link type="Depends" description="depends on">589</link>
		</links>
	</bug>
	<bug id="670" opendate="2008-02-10 07:55:22" fixdate="2008-04-05 09:57:09" resolution="Fixed">
		<buginformation>
			<summary>Deleting from ACL_OBJECT_IDENTITY can cause deadlocks under (load test)</summary>
			<description>While performing load testing, we found concurrent deletes from the ACL_OBJECT_IDENTITY table by the JdbcMutableAclService would cause deadlocks in the database.  This is potentially only a problem when using MS SQL server 2000, I haven&amp;amp;apos;t tested any other RDBs.
The deadlocks were found when simulating only 3 concurrent users, so was relatively easy to reproduce.
The deadlocks are caused for several reasons, I&amp;amp;apos;ll start with the most serious.
deleteAcl(ObjectIdentity objectIdentity, boolean deleteChildren) does the following:
1 find all children of the ACL
2 optionally delete these recursively  // not tested, but would cause deadlocks i think
call deleteEntries(..)
    performs a select to find Objectidentity pkey
    deletes from ACL_Entry
call deleteObjectIdentityAndOptionallyClass(..)
    performs a select to find Objectidentity pkey
    deletes from ACL_OBJECT_IDENTITY
    selects from ACL_OBJECT_IDENTITY to see if the entry deleted was the last from a particular class
    deletes from ACL_CLASS (dependent on outcome of previous select)

In MS SQL server the best practise is to perform all selects first, then do deletes, interleaving selects and deletes is a recipe for deadlocks.
After some reorganisation of the above operations, we also found another deadlock caused by the database this time internally, where 2 concurrent deletes on the ACL_OBJECT_IDENTITY table when the DB was checking the foreign key to &amp;amp;apos;parent object&amp;amp;apos;, which we had to solve with a synchronized.
I&amp;amp;apos;ve pasted our fixed code below, not that it no longer deletes from the ACL_CLASS table if the ACL_OBJECT_IDENTITY row is that last one that referenced it, as I find this a waste of time (you may not agree?), it this may cause issues with a coinciding insert into ACL_OBJECT_IDENTITY (untested and not fully thought through).  Also if deleteChildren was passed as true, I&amp;amp;apos;m sure the deadlocks would still occur.

/**

Deletes the the ACL for the specified 
{@link ObjectIdentity}. &amp;lt;br&amp;gt;  
   * NOTE: Passing deleteChildren as &amp;lt;code&amp;gt;true&amp;lt;/code&amp;gt; can cause deadlocks at
   * the database, as this uses recursion on this method resulting in 
   * select, delete, select... sequences of JDBC calls which is a recipe for
   * deadlocks (at least on MS SQL server) under heavy load.
   * 
   * @param objectIdentity
   * @param deleteChildren
   * @throws ChildrenExistException
   */
  public void deleteAcl(ObjectIdentity objectIdentity, boolean deleteChildren)
      throws ChildrenExistException
  {
    Assert.notNull(objectIdentity, "Object Identity required");
    Assert.notNull(objectIdentity.getIdentifier(),
                   "Object Identity doesn&amp;amp;apos;t provide an identifier");

    if (deleteChildren) 
    {
      // deadlock territory
      ObjectIdentity[] children = findChildren(objectIdentity);
      for (int i = 0; i &amp;lt; children.length; i++) 
      {
            deleteAcl(children[i], true);
      }
    }

    // we could have placed the find children outside the if and used it to 
    // check for children, but this has been found to cause the occasional
    // deadlock in MS SQL server, so we&amp;amp;apos;ll just let the FK do the checking for
    // us.  After all that&amp;amp;apos;s what it&amp;amp;apos;s for

    Long oidPkey = retrieveObjectIdentityPrimaryKey(objectIdentity);

    // Delete this ACL&amp;amp;apos;s ACEs in the acl_entry table
    deleteEntries(oidPkey);

    // Delete this ACL&amp;amp;apos;s acl_object_identity row
    deleteObjectIdentity(oidPkey);

    // Clear the cache
    aclCache.evictFromCache(objectIdentity);
  }

  /**
   * Deletes all ACEs defined in the acl_entry table belonging to the presented
   * ObjectIdentity
   * 
   * @param oid
   *            the rows in acl_entry to delete
   */
  protected void deleteEntries(ObjectIdentity oid)
  {
    this.deleteEntries(retrieveObjectIdentityPrimaryKey(oid));
  }

  private void deleteEntries(Long oidPKey)
  {
    jdbcTemplate.update(deleteEntryByObjectIdentityForeignKey,
                        new Object[] { oidPKey });
  }

  /**
   * Deletes a single row from acl_object_identity that is associated with the
   * presented ObjectIdentity. &amp;lt;br&amp;gt;
   * Does not delete the from the ACL_CLASS table if 
   * the {@link ObjectIdentity}
 deleted is the last of that class, as this would
require a select after a delete, which can cause deadlocks on some RDB&amp;amp;apos;s,
and potentially another thread creating an ACL may have checked that
ACL_CLASS row exist and is waiting to insert would experience problems.&amp;lt;br&amp;gt;
&amp;lt;br&amp;gt;
Also note that this method is synchronised, this is yet another deadlock
avoidance manoeuvre, here&amp;amp;apos;s why:&amp;lt;br&amp;gt;
The ACL_OBJECT_IDENTITY table has a foreign key back to itself (to support
hierarchical ACLs), and this can cause the following situation:
&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;
Thread 1 (T1) is attempting to delete row X, so obtains an exclusive
page lock on row X (and some of it close buddies)
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;
Thread 1 (T2) is attempting to delete row Y, so obtains an exclusive
page lock on row Y (and some of it close buddies)
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;
T2 now performs a table scan to ensure the FK from PARENT_OBJECT back to
ID (same table remember) is not violated by removal of row Y, but has to
wait for the exclusive lock held by T1 to be released
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;
T1 now performs a table scan to ensure the FK from PARENT_OBJECT back to
ID (same table remember) is not violated by removal of row X, but has to
wait for the exclusive lock held by T2 to be released
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Deadlock!!!  &amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
This has been observed using MS SQL Server, under load testing.


@param oidPKey The primary key of the object identity to delete
that class name if appropriate)
   */
  protected synchronized void deleteObjectIdentity(Long oidPKey)
  Unknown macro: {    // Delete the acl_object_identity row    jdbcTemplate.update(deleteObjectIdentityByPrimaryKey,                        new Object[] { oidPKey });  } 

  /**

Retrieves the primary key from the acl_object_identity table for the passed
ObjectIdentity. Unlike some other methods in this implementation, this
method will NOT create a row (use 
{@link
   * #createObjectIdentity(ObjectIdentity, Sid)}
 instead).

@param oid
to find

@return the object identity or null if not found
   */
  protected Long retrieveObjectIdentityPrimaryKey(ObjectIdentity oid)
  {
    try
    Unknown macro: {      return new Long(jdbcTemplate          .queryForLong(selectObjectIdentityPrimaryKey, new Object[] {
              oid.getJavaType().getName(), oid.getIdentifier() }));    } 
    catch (DataAccessException notFound)
    {
      return null;
    }
  }

</description>
			<version>1.0.3</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclServiceTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="754" opendate="2008-04-06 22:09:26" fixdate="2008-04-07 02:03:10" resolution="Fixed">
		<buginformation>
			<summary>Wrong byte array lenght used in Md4PasswordEncoder#encodePassword</summary>
			<description>Part of patch for bug #SEC-728 has been incorrectly applied.
The line
md4.update(passBytes, 0, saltedPass.length());
should read
md4.update(passBytes, 0, passBytes.length());
The current (2.0RC1) version is incorrect, since the number of chars in an UTF-8 string is generally NOT equal to it number of bytes!</description>
			<version>2.0.0 RC1</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.providers.encoding.Md5PasswordEncoderTests.java</file>
			<file type="M">org.springframework.security.providers.encoding.Md4PasswordEncoderTests.java</file>
			<file type="M">org.springframework.security.providers.encoding.Md4PasswordEncoder.java</file>
		</fixedFiles>
	</bug>
	<bug id="750" opendate="2008-04-04 03:52:28" fixdate="2008-04-08 04:23:46" resolution="Fixed">
		<buginformation>
			<summary>Support for JPA PersistenceContext annotation broken</summary>
			<description>When Spring Security is used, JPA annotations auto-wiring is not supported : the @PersistenceContext EntityManager is not injected in the DAO layer, which results in NullPointerExceptions
</description>
			<version>2.0.0 RC1</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.HttpSecurityConfigPostProcessor.java</file>
			<file type="M">org.springframework.security.config.ConfigUtils.java</file>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.BeanIds.java</file>
		</fixedFiles>
	</bug>
	<bug id="759" opendate="2008-04-08 23:48:52" fixdate="2008-04-11 04:26:07" resolution="Fixed">
		<buginformation>
			<summary>GrantedAuthoritiesContainer should extend Serializable</summary>
			<description>GrantedAuthority&amp;amp;apos;s are Serializable, so it makes sense to make GrantedAuthoritiesContainer serializable as well. 
GrantedAuthoritiesContainer not being serializable is currently a problem for us because we sometimes need to serialize the Authentication object, which contains a (pre-authenticated) GrantedAuthoritiesContainer as part of the authentication details.</description>
			<version>2.0.0 RC1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.GrantedAuthoritiesContainer.java</file>
		</fixedFiles>
	</bug>
	<bug id="768" opendate="2008-04-12 10:55:02" fixdate="2008-04-12 11:07:06" resolution="Fixed">
		<buginformation>
			<summary>Namespace throws IllegalStateException if no namespace filters are used and a entry-point-ref isn&amp;apos;t set</summary>
			<description>The cas client sample is an example. It doesn&amp;amp;apos;t use basic, form or OpenID login through the namespace. An error should be reported through the parserContext rather than throwing an exception.</description>
			<version>2.0.0 RC1</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="597" opendate="2007-11-07 07:19:24" fixdate="2008-04-13 17:42:07" resolution="Duplicate">
		<buginformation>
			<summary>AclImpl.setParent() throws Exception when changing parent to null</summary>
			<description>I think it should be possible to change the parent of a directory to null:
Sample Scenario:
Filebrowser that manages a directory structure (the directories are secured by acegi). Now i want to move a nested directory to Root-Level. The parent-property of the corresponding ACL has to be changed to NULL.
Solution:
Simply change:
    public void setParent(Acl newParent) 
{
        aclAuthorizationStrategy.securityCheck(this, AclAuthorizationStrategy.CHANGE_GENERAL);
        Assert.notNull(newParent, "New Parent required");
        Assert.isTrue(!newParent.equals(this), "Cannot be the parent of yourself");
        this.parentAcl = newParent;
    }

to
    public void setParent(Acl newParent) 
{
        aclAuthorizationStrategy.securityCheck(this, AclAuthorizationStrategy.CHANGE_GENERAL);
        Assert.isTrue(newParent == null || !newParent.equals(this), "Cannot be the parent of yourself");
        this.parentAcl = newParent;
    }
</description>
			<version>1.0.5</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.domain.AclImpl.java</file>
			<file type="M">org.springframework.security.ui.webapp.AuthenticationProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.ui.AbstractProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.ui.AbstractProcessingFilter.java</file>
			<file type="M">org.springframework.security.ui.webapp.AuthenticationProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">572</link>
		</links>
	</bug>
	<bug id="773" opendate="2008-04-14 15:56:05" fixdate="2008-04-18 09:54:25" resolution="Fixed">
		<buginformation>
			<summary>global-method-security fails with JPA</summary>
			<description>Enabling global-method-security with JPA @PersistenceContext annotations will fail on startup.  This is with the recent 2.0.0 release cut. 
My userDetailsService is a custom implementation that requires access to an @Repository bean with an EntityManager.
	&amp;lt;sec:http auto-config="true"&amp;gt;
        &amp;lt;sec:intercept-url pattern="/assets/**" access="IS_AUTHENTICATED_ANONYMOUSLY"/&amp;gt;
        &amp;lt;sec:intercept-url pattern="/login*" access="IS_AUTHENTICATED_ANONYMOUSLY"/&amp;gt;
        &amp;lt;sec:intercept-url pattern="/logout*" access="IS_AUTHENTICATED_ANONYMOUSLY"/&amp;gt;
        &amp;lt;sec:intercept-url pattern="/unsupported*" access="IS_AUTHENTICATED_ANONYMOUSLY"/&amp;gt;        
        &amp;lt;sec:intercept-url pattern="/password-*" access="IS_AUTHENTICATED_ANONYMOUSLY"/&amp;gt;
        &amp;lt;sec:intercept-url pattern="/**" access="ROLE_USER,ROLE_ADMIN"/&amp;gt;
        &amp;lt;sec:form-login login-page="/login.html" default-target-url="/app.html" authentication-failure-url="?login_error=1"/&amp;gt;
        &amp;lt;sec:logout logout-success-url="/logout.html"/&amp;gt;
    &amp;lt;/sec:http&amp;gt;
	&amp;lt;sec:authentication-provider user-service-ref="userDetailsService"&amp;gt;
		&amp;lt;sec:password-encoder ref="passwordEncoder" /&amp;gt;
	&amp;lt;/sec:authentication-provider&amp;gt;
	&amp;lt;sec:global-method-security secured-annotations="enabled" /&amp;gt;
The exception: 
2008-04-15 04:50:26,490 ERROR [main] org.springframework.web.context.ContextLoader: Context initialization failed 
org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;_rememberMeServicesInjectionBeanPostProcessor&amp;amp;apos;: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;org.springframework.transaction.config.internalTransactionAdvisor&amp;amp;apos;: Cannot create inner bean &amp;amp;apos;(inner bean)&amp;amp;apos; of type [org.springframework.transaction.interceptor.TransactionInterceptor] while setting bean property &amp;amp;apos;transactionInterceptor&amp;amp;apos;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;(inner bean)&amp;amp;apos;: Cannot resolve reference to bean &amp;amp;apos;transactionManager&amp;amp;apos; while setting bean property &amp;amp;apos;transactionManager&amp;amp;apos;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;transactionManager&amp;amp;apos; defined in class path resource [epicenter-webapp-beans.xml]: Cannot resolve reference to bean &amp;amp;apos;entityManagerFactory&amp;amp;apos; while setting bean property &amp;amp;apos;entityManagerFactory&amp;amp;apos;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;ehCacheManager&amp;amp;apos; defined in class path resource [epicenter-repository-beans.xml]: Initialization of bean failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;_methodDefinitionSourceAdvisor&amp;amp;apos;: Cannot create inner bean &amp;amp;apos;(inner bean)&amp;amp;apos; of type [org.springframework.security.intercept.method.aopalliance.MethodSecurityInterceptor] while setting constructor argument; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;(inner bean)&amp;amp;apos;: Cannot resolve reference to bean &amp;amp;apos;_authenticationManager&amp;amp;apos; while setting bean property &amp;amp;apos;authenticationManager&amp;amp;apos;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;_authenticationManager&amp;amp;apos;: Cannot resolve reference to bean &amp;amp;apos;org.springframework.security.providers.dao.DaoAuthenticationProvider#0&amp;amp;apos; while setting bean property &amp;amp;apos;providers&amp;amp;apos; with key [2]; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;org.springframework.security.providers.dao.DaoAuthenticationProvider#0&amp;amp;apos;: Cannot resolve reference to bean &amp;amp;apos;userDetailsService&amp;amp;apos; while setting bean property &amp;amp;apos;userDetailsService&amp;amp;apos;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;userDetailsService&amp;amp;apos;: Injection of resource fields failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;permissionRepository&amp;amp;apos;: Injection of persistence fields failed; nested exception is java.lang.NullPointerException
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:478)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$1.run(AbstractAutowireCapableBeanFactory.java:409)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:380)
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:264)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:217)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:261)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164)
	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:881)
	at org.springframework.context.support.AbstractApplicationContext.registerBeanPostProcessors(AbstractApplicationContext.java:606)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:366)
	at org.springframework.web.context.ContextLoader.createWebApplicationContext(ContextLoader.java:255)
	at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:199)
	at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:45)</description>
			<version>2.0.0</version>
			<fixedVersion>2.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.GlobalMethodSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodDefinitionSourceAdvisor.java</file>
			<file type="M">org.springframework.security.config.GlobalMethodSecurityBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="777" opendate="2008-04-15 19:18:56" fixdate="2008-04-21 03:03:02" resolution="Fixed">
		<buginformation>
			<summary>The disabled status cannot be set in &lt;user-service&gt;</summary>
			<description>UserServiceBeanDefinitionParser does parse the "disabled" attribute, but this attribute is not valid in spring-security-2.0.xsd.</description>
			<version>2.0.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.UserServiceBeanDefinitionParserTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="782" opendate="2008-04-18 10:35:41" fixdate="2008-04-21 03:51:33" resolution="Fixed">
		<buginformation>
			<summary>Incorrect UrlMatcher initialization in FilterChainProxy results in wrong lowercase/uppercase matching</summary>
			<description>When upgrading from Acegi 1.0.6 to Spring Security 2.0.0, we found that URL path matching did not work in some cases (we are still using the old definition source style since it&amp;amp;apos;s a big app and it will take time to migrate to the new simplified XML).
We narrowed this down to patterns that contained both lowercase and uppercase characters. We have disabled the flag in the object definition source that marked whether we wanted to turn both the pattern and path to lowercase before comparison.
The reason for this is that a different AntUrlPathMatcher instance is used when initializing the FilterChainProxyBean, than when the comparison is actually made. One instance has the requiresLowerCaseUrl set to true (the initial, default instance), while the second one which used the object definition source flag has requiresLowerCaseUrl set to false. Why does this happen? See subtle error:
    public void afterPropertiesSet() throws Exception {
        // Convert the FilterDefinitionSource to a filterChainMap if set
        if (fids != null) 
{
            Assert.isNull(uncompiledFilterChainMap, "Set the filterChainMap or FilterInvocationDefinitionSource but not both");
            FIDSToFilterChainMapConverter converter = new FIDSToFilterChainMapConverter(fids, applicationContext);
            setFilterChainMap(converter.getFilterChainMap()); &amp;lt;--------------- THIS SHOULD BE CALLED AFTER setMatcher(converter.getMatcher())
            setMatcher(converter.getMatcher());                            &amp;lt;---------------
            fids = null;
        }

        Assert.notNull(uncompiledFilterChainMap, "filterChainMap must be set");
    }
The reason is that setFilterChainMap calls createCompiledMap which is turn uses the matcher instance field. At this point the instance matcher has not been changed yet, so that causes the compiled map to have been compiled with the wrong matcher.
Our workaround has been to enable the CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON flag and lowercase all patterns.</description>
			<version>2.0.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.util.FilterChainProxyTests.java</file>
			<file type="M">org.springframework.security.util.FilterChainProxy.java</file>
		</fixedFiles>
	</bug>
	<bug id="776" opendate="2008-04-15 03:46:43" fixdate="2008-04-22 02:25:15" resolution="Fixed">
		<buginformation>
			<summary>Http Session created for Anonymous request</summary>
			<description>I&amp;amp;apos;m using Anonymous Authentication for the public pages on a site I&amp;amp;apos;m developing. If I go to a page that is successful an anonymous authentication token is made and the reset by the AnonymousProcessingFilter so that no HttpSession is created for that request. However, if the page I go to results in an error (like 404 or 500) an HttpSession is created with the anonymous authentication token saved within.
I think that it is because the HttpSessionContextIntegrationFilter wraps the response so that it can try and save the context on sendError/sendRedirect calls, however the AnonymousProcessingFilter isn&amp;amp;apos;t given a chance to remove the anonymous authentication token, the result is that a session is created.</description>
			<version>1.0.6</version>
			<fixedVersion>2.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.context.HttpSessionContextIntegrationFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">788</link>
		</links>
	</bug>
	<bug id="788" opendate="2008-04-21 03:16:44" fixdate="2008-04-22 02:28:53" resolution="Fixed">
		<buginformation>
			<summary>x509 authentication does not work properly</summary>
			<description>x509 authentication does not work properly
I have an application with x509 authentication configured.
First:
In RC1 release my application startup properly. In final 2.0.0 release this exception occur:
org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: No AuthenticationEntryPoint could be established.
If I write the entry point bean like this:
&amp;lt;bean id="x509EntryPoint" class="org.springframework.security.ui.x509.X509ProcessingFilterEntryPoint" /&amp;gt;
everything work properly.
I think 2.0.0 should work automatic like RC1 "OR" x509 documentation section in the reference manual should document it.
Second:
When I do the first login with x509 certificate in my application, a 403 http status code occurs.
This happens only if a http-&amp;gt;https redirection is needed. 
Example:
First page is "IS_AUTHENTICATED_ANONYMOUSLY" and HTTP. Then user goes to a secure page over HTTPS.
The browser dialog appers to select the certificate. Then a 403 occur.
If the first page is HTTPS everything work properly.
I will attach the applicationContext and the error log.
Sorry for my bad english.</description>
			<version>2.0.0</version>
			<fixedVersion>2.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParser.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">776</link>
		</links>
	</bug>
	<bug id="783" opendate="2008-04-18 17:57:50" fixdate="2008-04-25 23:40:23" resolution="Fixed">
		<buginformation>
			<summary>GlobalMethodSecurityBeanDefinitionParser should support AfterInvocationProviders</summary>
			<description>Even I define an AfterInvocationProviderManager, it can&amp;amp;apos;t be auto-wired into the MethodSecurityInterceptor when I use &amp;lt;global-method-security&amp;gt; to secure methods with @Secured. So the AfterInvocationProviders don&amp;amp;apos;t work with the @Secured annotations. I can only use &amp;lt;security:intercept-methods&amp;gt; to have my AfterInvocationProviders work!</description>
			<version>2.0.0</version>
			<fixedVersion>2.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.ConfigUtils.java</file>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandler.java</file>
			<file type="M">org.springframework.security.config.Elements.java</file>
			<file type="M">org.springframework.security.config.BeanIds.java</file>
			<file type="M">org.springframework.security.config.GlobalMethodSecurityBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="787" opendate="2008-04-21 00:58:18" fixdate="2008-04-30 18:48:48" resolution="Fixed">
		<buginformation>
			<summary>ACL SQL statements have inconsistent use of case (mixed upper and  lower).</summary>
			<description>SQL statements in ACL package have mixed upper and lower case table names.  This causes problems on case sensitive systems such as linux.</description>
			<version>2.0.0</version>
			<fixedVersion>2.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="818" opendate="2008-05-06 22:40:23" fixdate="2008-05-07 00:53:12" resolution="Fixed">
		<buginformation>
			<summary>SEC-757 fix breakes scenarios with using property placeholders in URL definitions</summary>
			<description>We are using property placeholders for configuring well known application URLs in application condex descriptor. 
for example:
	&amp;lt;bean id="applicationPropertyPlaceholderConfigurer" class="org.springframework.web.context.support.ServletContextPropertyPlaceholderConfigurer"&amp;gt;
		&amp;lt;property name="properties"&amp;gt;
			&amp;lt;value&amp;gt;
				loginPath=/login
				logoutPath=/logout
			&amp;lt;/value&amp;gt;
		&amp;lt;/property&amp;gt;
	&amp;lt;/bean&amp;gt;
 	&amp;lt;util:map id="exportSymbols"&amp;gt;
		&amp;lt;entry key="application.logoutURI" value="$
{logoutPath}"/&amp;gt;
	&amp;lt;/util:map&amp;gt;

	&amp;lt;security:http  access-decision-manager-ref="accessDecisionManager" path-type="regex" realm="TAO Realm"&amp;gt;
		&amp;lt;security:logout logout-url="${logoutPath}
"/&amp;gt;
	&amp;lt;/security:http&amp;gt;
So, we need to define real URI once, and do not bothering if it will cahnge later. But SEC-757 fix do not allow using placeholders more, becouse now spring-security checks URLs for validity. Plese, can you check URI for validity after PropertyPlaceholderConfigurer done his job.</description>
			<version>2.0.1</version>
			<fixedVersion>2.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.concurrent.ConcurrentSessionFilter.java</file>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.ui.AbstractProcessingFilter.java</file>
			<file type="M">org.springframework.security.config.ConfigUtils.java</file>
			<file type="M">org.springframework.security.ui.AccessDeniedHandlerImpl.java</file>
			<file type="M">org.springframework.security.ui.logout.LogoutFilter.java</file>
			<file type="M">org.springframework.security.util.UrlUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="817" opendate="2008-05-06 11:27:09" fixdate="2008-05-07 01:00:46" resolution="Fixed">
		<buginformation>
			<summary>NPE in org.springframework.security.config.FilterChainProxyPostProcessor</summary>
			<description>The NPE occurs in the method "FilterChainProxyPostProcessor.postProcessBeforeInitialization" when the beanName argument is null. In my case this argument is null when using beans that are configured using the @Configurable annotation and the AspectJ AnnotationBeanConfigurerAspect.
I also noticed that this NPE might happen in the other BeanPostProcessor implementations in spring-security. An easy fix would be to change the order of operands in the string comparison: beanName.equals(BeanIds.FILTER_CHAIN_PROXY) =&amp;gt; BeanIds.FILTER_CHAIN_PROXY.equals(beanName)</description>
			<version>2.0.1</version>
			<fixedVersion>2.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.MethodSecurityInterceptorPostProcessor.java</file>
			<file type="M">org.springframework.security.config.FilterChainProxyPostProcessor.java</file>
			<file type="M">org.springframework.security.config.RememberMeServicesInjectionBeanPostProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="822" opendate="2008-05-08 01:27:44" fixdate="2008-05-08 02:08:38" resolution="Fixed">
		<buginformation>
			<summary>TokenBasedRememberMeServices calculate expiryTime: explicit cat to long is needed</summary>
			<description>
public class TokenBasedRememberMeServices extends AbstractRememberMeServices {
  public void onLoginSuccess(HttpServletRequest request,
      HttpServletResponse response, Authentication successfulAuthentication) {
    String username = retrieveUserName(successfulAuthentication);
    String password = retrievePassword(successfulAuthentication);
    // If unable to find a username and password, just abort as
    // TokenBasedRememberMeServices is
    // unable to construct a valid token in this case.
    if (!StringUtils.hasLength(username) || !StringUtils.hasLength(password)) 
{
      return;
    }

    int tokenLifetime = calculateLoginLifetime(request,
        successfulAuthentication);
    long expiryTime = System.currentTimeMillis() + 1000 * tokenLifetime;
    String signatureValue = makeTokenSignature(expiryTime, username, password);
    setCookie(new String[] 
{ username, Long.toString(expiryTime),
        signatureValue }
, tokenLifetime, request, response);
    if (logger.isDebugEnabled()) 
{
      logger.debug("Added remember-me cookie for user &amp;amp;apos;" + username
          + "&amp;amp;apos;, expiry: &amp;amp;apos;" + new Date(expiryTime) + "&amp;amp;apos;");
    }
  }
}
tokenLifetime is an integer. When the tokenLifetime is 1 month =&amp;gt; value = 2678400 seconds =&amp;gt; 1000 * 2678400 &amp;gt; Integer.MAX_VALUE =&amp;gt; negative integer.
In the calculation, there should be an explicit cast to long
So 
long expiryTime = System.currentTimeMillis() + 1000 * tokenLifetime;
should be 
long expiryTime = System.currentTimeMillis() + 1000 * [B](long)[/B] tokenLifetime;</description>
			<version>2.0.1</version>
			<fixedVersion>2.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ui.rememberme.TokenBasedRememberMeServices.java</file>
			<file type="M">org.springframework.security.ui.rememberme.TokenBasedRememberMeServicesTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="809" opendate="2008-05-01 01:15:21" fixdate="2008-05-12 07:06:10" resolution="Fixed">
		<buginformation>
			<summary>Concurrent Session Control and OpenID Incompatibility</summary>
			<description>Hi,
The openid sample worked fine for me.
I tried to use the Concurrent Session Control but it doesn&amp;amp;apos;t work. 
The following post has the same bug : http://forum.springframework.org/showthread.php?p=177626
Solution proposed is to update the OpenIDAuthenticationProcessingFilter and to populate details before call to the authenticationManager, this way :
token.setDetails(authenticationDetailsSource.buildDetails(req));
Not sure what uNcode suggests is the good  way to fix it.
Could be related to 
http://jira.springframework.org/browse/SEC-618
Here is my SS configuration (really basic, based on the sample openid):
--------------------------------------
        &amp;lt;http&amp;gt;
		&amp;lt;intercept-url pattern="/**" access="ROLE_USER" /&amp;gt;
		&amp;lt;logout /&amp;gt;
		&amp;lt;openid-login login-page="/openidlogin.jsp" /&amp;gt;
		&amp;lt;concurrent-session-control max-sessions="1" exception-if-maximum-exceeded="true"/&amp;gt;
	&amp;lt;/http&amp;gt;
	&amp;lt;authentication-manager alias="authenticationManager" /&amp;gt;
	&amp;lt;user-service id="userService"&amp;gt;
		&amp;lt;user name="http://MYACCOUNT.myopenid.com/" password="notused" authorities="ROLE_SUPERVISOR,ROLE_USER" /&amp;gt;
	&amp;lt;/user-service&amp;gt;
Here is my stack trace :
--------------------------------
java.lang.IllegalArgumentException: Authentication.getDetails() required
        at org.springframework.util.Assert.notNull(Assert.java:112)
        at org.springframework.security.concurrent.SessionRegistryUtils.obtainSessionIdFromAuthentication(SessionRegistryUtils.java:52)
        at org.springframework.security.concurrent.ConcurrentSessionControllerImpl.checkAuthenticationAllowed(ConcurrentSessionControllerImpl.java:92)
        at org.springframework.security.providers.ProviderManager.doAuthentication(ProviderManager.java:199)
        at org.springframework.security.AbstractAuthenticationManager.authenticate(AbstractAuthenticationManager.java:46)
        at org.springframework.security.ui.openid.OpenIDAuthenticationProcessingFilter.attemptAuthentication(OpenIDAuthenticationProcessingFilter.java:82)
        at org.springframework.security.ui.AbstractProcessingFilter.doFilterHttp(AbstractProcessingFilter.java:249)
        at org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)
        at org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)
        at org.springframework.security.ui.logout.LogoutFilter.doFilterHttp(LogoutFilter.java:87)
        at org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)
        at org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)
        at org.springframework.security.ui.SessionFixationProtectionFilter.doFilterHttp(SessionFixationProtectionFilter.java:68)
        at org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)
        at org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)
        at org.springframework.security.context.HttpSessionContextIntegrationFilter.doFilterHttp(HttpSessionContextIntegrationFilter.java:229)
        at org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)
        at org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)
        at org.springframework.security.concurrent.ConcurrentSessionFilter.doFilterHttp(ConcurrentSessionFilter.java:97)
        at org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)
        at org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)
        at org.springframework.security.securechannel.ChannelProcessingFilter.doFilterHttp(ChannelProcessingFilter.java:116)
        at org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)
        at org.springframework.security.util.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:371)
        at org.springframework.security.util.FilterChainProxy.doFilter(FilterChainProxy.java:174)
        at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:183)
        at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:138)
</description>
			<version>2.0.0</version>
			<fixedVersion>2.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ui.openid.OpenIDAuthenticationProcessingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="826" opendate="2008-05-11 01:52:12" fixdate="2008-05-14 03:49:27" resolution="Fixed">
		<buginformation>
			<summary>Support for JPA PersistenceContext annotation broken</summary>
			<description>When using the intercept-methods tag on a bean, the dao&amp;amp;apos;s used by the userSecurityService and the protected bean are not processed by the 
PersistenceAnnotationBeanPostProcessor. This seems to be because the dao gets created before the PostProcessor and so in never seen by it. This like SEC-750 causes a null pointer when an attempt is made to authenticate the user.
I believe that this is related to SEC-750 and SEC-773 however it still occurs in 2.0.0/2.5.4
I have modified the test case form SEC-750 to demonstrate the problem. The unmodified test case runs fine on my system.
My real world case is a little more complex in that I have a userSecurityService that uses one of my service components, that in turn uses a DAO that is used by another protected service.</description>
			<version>2.0.1</version>
			<fixedVersion>2.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.security.config.HttpSecurityConfigPostProcessor.java</file>
			<file type="M">org.springframework.security.config.ConfigUtils.java</file>
			<file type="M">org.springframework.security.config.X509BeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.BeanIds.java</file>
		</fixedFiles>
	</bug>
	<bug id="837" opendate="2008-05-15 20:32:32" fixdate="2008-05-21 00:27:41" resolution="Fixed">
		<buginformation>
			<summary>SpringSecurityLdapTemplate.searchForSingleAttributeValues, no string escape for formattedFilter</summary>
			<description>When formattedFilter looks like this: (member=CN=Jozwicki\, Jakub, ou=IT, dc=example, dc=com)

please notice "\" before first comma, search doesn&amp;amp;apos;t return any results.

I don&amp;amp;apos;t know if it is MS AD specific but I had to add code replacing \ with :
String formattedFilter = MessageFormat.format(filter, params);
formattedFilter = formattedFilter.replaceAll("\\\\", "\\\\\\\\");
-------
Standalone code:
public class LDAPSearch {
	public final static void main(String[] args) throws Exception {
		Hashtable env = new Hashtable();
		env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
		env.put(Context.PROVIDER_URL, "ldap://192.168.1.191:389");
		env.put(Context.SECURITY_PRINCIPAL, "pld1jjozwic");
		env.put(Context.SECURITY_CREDENTIALS, "*******");
		DirContext ctx = new InitialDirContext(env);
		SearchControls controls = new SearchControls();
		controls.setSearchScope(SearchControls.SUBTREE_SCOPE);
		controls.setReturningObjFlag(true);
		controls.setReturningAttributes(null);
		NamingEnumeration result = ctx.search("dc=pld1,dc=net", "(member=CN=Jozwicki\\\\, Jakub, OU=IT, DC=pld1, DC=net)", controls);
		while (result.hasMoreElements()) 
{
			System.out.println(result.next()+"\n");
		}
 
	}
}
proved that  is needed.</description>
			<version>2.0.1</version>
			<fixedVersion>2.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.SpringSecurityLdapTemplateTests.java</file>
			<file type="M">org.springframework.security.ldap.populator.DefaultLdapAuthoritiesPopulatorTests.java</file>
			<file type="M">org.springframework.security.ldap.search.FilterBasedLdapUserSearchTests.java</file>
			<file type="M">org.springframework.security.ldap.SpringSecurityLdapTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="792" opendate="2008-04-22 12:01:20" fixdate="2008-05-21 02:02:05" resolution="Fixed">
		<buginformation>
			<summary>Filters should only be added to the default stack if they are labelled using custom-filter.</summary>
			<description>At the moment FilterChainProxyPostProcessor is adding any filters whose class names begin with org.springframework.security. A user may have a separate FilterChainProxy configured with different filters and these shouldn&amp;amp;apos;t be added to the namespace instance. The list of filter beans should be registered independently and added to by custom-filter and the namespace parser. This separate list should be used for the final configuration of the namespace FilterChainProxy instance.</description>
			<version>2.0.0</version>
			<fixedVersion>2.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.config.FilterChainProxyPostProcessor.java</file>
			<file type="M">org.springframework.security.config.OrderedFilterBeanDefinitionDecorator.java</file>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.RememberMeBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.ConfigUtils.java</file>
			<file type="M">org.springframework.security.config.BasicAuthenticationBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.ConcurrentSessionsBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.LogoutBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.AnonymousBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.X509BeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.BeanIds.java</file>
		</fixedFiles>
	</bug>
	<bug id="793" opendate="2008-04-22 22:36:06" fixdate="2008-05-21 02:08:40" resolution="Fixed">
		<buginformation>
			<summary>ldap-authentication-provider element parser ignores hash attribute.</summary>
			<description>The parser only handles the &amp;lt;password-encoder&amp;gt; child element. Probably the attribute should have been left out of the namespace schema, but since it&amp;amp;apos;s there we need to handle it. The workaround is to use password-encoder.</description>
			<version>2.0.0</version>
			<fixedVersion>2.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.LdapProviderBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.config.LdapProviderBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="835" opendate="2008-05-15 07:06:43" fixdate="2008-05-23 07:57:04" resolution="Fixed">
		<buginformation>
			<summary>SEC-790 changes incompatible with J2EE 1.3</summary>
			<description>The changes made for issue SEC-790 break the DefaultLoginPageGeneratingFilter under J2EE 1.3.  Line 79 in DefaultLoginPageGeneratingFilter uses the setCharacterEncoding method, which was introduced in J2EE 1.4.  The same thing can be accomplished with the setContentType method instead, with response.setContentType("text/html; charset=utf-8").</description>
			<version>2.0.1</version>
			<fixedVersion>2.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ui.webapp.DefaultLoginPageGeneratingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="850" opendate="2008-05-23 03:25:44" fixdate="2008-05-23 10:38:01" resolution="Fixed">
		<buginformation>
			<summary>custom-authentication-provider Registering Separate Bean Definitions in App Context and Providers List</summary>
			<description>I&amp;amp;apos;m seeing multiple instances of the LdapAuthenticationProvider bean when using the traditional bean config. In the namespace config I only see one instance. 
So in the samples-ldap app I&amp;amp;apos;m seeing two instances when using the traditional bean config w/ the namespace config commented out and the scope="singleton" attribute applied to the secondLdapProvider bean definition. 
In my app I&amp;amp;apos;m seeing three instances of the LdapAuthenticationProvider bean. It&amp;amp;apos;s like the prototype scope is getting applied.  There&amp;amp;apos;s one instance that&amp;amp;apos;s getting used for authentication, a second instance for a dependency injection bean, not sure about the third instance. I only want ONE shared instance of the LdapAuthenticationProvider bean.</description>
			<version>2.0.1</version>
			<fixedVersion>2.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.CustomAuthenticationProviderBeanDefinitionDecoratorTests.java</file>
			<file type="M">org.springframework.security.config.CustomAuthenticationProviderBeanDefinitionDecorator.java</file>
		</fixedFiles>
	</bug>
	<bug id="830" opendate="2008-05-13 08:58:38" fixdate="2008-05-25 10:04:27" resolution="Fixed">
		<buginformation>
			<summary>SavedRequestAwareWrapper and ParameterMethodNameResolver</summary>
			<description>This is a very simple use case, Its strange how this was ignored. I will try to create a sample war file and get it. in the mean while..
Spring : 2.5.1 (code in 2.0)
Acegi : 1.0.4
lest say we have Acegi security and a multi action controller method resolved on "action" parameter.
lets say, we try to access
/mod/order.html?action=view
and acegi saves the request into SavedRequestAwareWrapper and forwards to /login.html
After login, it goes to OrderController.view() method and forwards to view.jsp
similarly
/mod/order.html?action=viewDetail (This has more logic and data building)
to OrderController.viewDetail() to viewdetail.jsp
This is fine so far
but I have a condition in view.jsp (say for certain cust)
if (cust priv &amp;gt; ordinary) 
 &amp;lt;jsp:include page="/mod/order.html?action=viewDetail" /&amp;gt;
now, if i add this jsp include, and access this page with a customer satisfying the condition, a new request to
/mod/order.html?action=view
keeps looping after login and there is a stack over flow.
Reason:
After Login, the request /mod/order.html?action=view goes to call the 
OrderController.view(), once it dispatches to jsp, the jsp include is kicked off, and the method resolver tries to get the parameter action from the request. However, the SavedRequestAwareWrapper.getParameter returns it from the savedRequest which is "/mod/order.html?action=view" .. it keeps looping there. 
I am eager to find out how you would solve this.</description>
			<version>1.0.4</version>
			<fixedVersion>2.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.wrapper.SavedRequestAwareWrapper.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">875</link>
		</links>
	</bug>
	<bug id="856" opendate="2008-05-28 00:31:40" fixdate="2008-05-28 03:28:01" resolution="Fixed">
		<buginformation>
			<summary>GroupManager JdbcUserDetailsManager implementation: addGroupAuthority() method doesn&amp;apos;t work.</summary>
			<description>In addGroupAuthority(String groupName, GrantedAuthority authority) there is wrong parameter type in FindGroupIdQuery. Must be VARCHAR instead of INTEGER.
private class FindGroupIdQuery extends MappingSqlQuery {
        public FindGroupIdQuery(DataSource ds) 
{
            super(ds, findGroupIdSql);
            declareParameter(new SqlParameter(Types.INTEGER));
            compile();
        }

        protected Object mapRow(ResultSet rs, int rowNum) throws SQLException 
{
            return new Integer(rs.getInt(1));
        }
    }</description>
			<version>2.0.1</version>
			<fixedVersion>2.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.userdetails.jdbc.JdbcUserDetailsManager.java</file>
		</fixedFiles>
	</bug>
	<bug id="864" opendate="2008-06-03 01:52:48" fixdate="2008-06-03 01:55:38" resolution="Fixed">
		<buginformation>
			<summary>Duplicate OpenID providers being registered by HttpSecurityBeanDefinitionParser</summary>
			<description>There should only be the one. Currently a separate instance is being added to the AuthenticationManager and isn&amp;amp;apos;t being injected with a UserDetailsService</description>
			<version>2.0.1</version>
			<fixedVersion>2.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="819" opendate="2008-05-06 23:10:27" fixdate="2008-06-05 12:09:08" resolution="Fixed">
		<buginformation>
			<summary>Integer IDs are not supported despite documentation ensures they are</summary>
			<description>The documentation (reference) says that int domain object ids are supported (Chapter 23.3):
"Hopefully ObjectIdentityImpl will prove sufficient, as it provides a large number of ways in which it can be used. Most
people will have domain objects that contain a public Serializable getId() method. If the return type is
long, or compatible with long (eg an int), you will find you need not give further consideration to
ObjectIdentity issues."
Unfortunately I&amp;amp;apos;m getting assertion failures when using ints as IDs:
java.lang.IllegalArgumentException: This class requires ObjectIdentity.getIdentifier() to be a LongObject of class [java.lang.Integer] must be an instance of class java.lang.Long
	org.springframework.util.Assert.isInstanceOf(Assert.java:337)
	org.springframework.security.acls.jdbc.BasicLookupStrategy$1.setValues(BasicLookupStrategy.java:296)
	org.springframework.jdbc.core.JdbcTemplate$1.doInPreparedStatement(JdbcTemplate.java:621)
	org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:566)
	org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:616)
	org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:645)
	org.springframework.security.acls.jdbc.BasicLookupStrategy.lookupObjectIdentities(BasicLookupStrategy.java:289)
	org.springframework.security.acls.jdbc.BasicLookupStrategy.readAclsById(BasicLookupStrategy.java:421)
	org.springframework.security.acls.jdbc.JdbcAclService.readAclsById(JdbcAclService.java:114)
	org.springframework.security.acls.jdbc.JdbcAclService.readAclById(JdbcAclService.java:99)</description>
			<version>2.0.1</version>
			<fixedVersion>2.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclServiceTests.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategyTests.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategy.java</file>
			<file type="M">org.springframework.security.acls.objectidentity.ObjectIdentityImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="831" opendate="2008-05-13 20:44:19" fixdate="2008-06-05 13:57:11" resolution="Fixed">
		<buginformation>
			<summary>JdbcAclService incompatible with postgres</summary>
			<description>JdbcAclService contains the following definition:
private static final String selectAclObjectWithParent = "select obj.object_id_identity obj_id, class.class class "
        + "from acl_object_identity obj, acl_object_identity parent, acl_class class "
        + "where obj.parent_object = parent.id and obj.object_id_class = class.id "
        + "and parent.object_id_identity = ? and parent.object_id_class = ("
        + "select id FROM acl_class where acl_class.class = ?)";
Postgres cannot execute this query as it requires the AS keyword for aliasing.
The following query works in postgres:
select obj.object_id_identity AS obj_id, class.class AS class  from acl_object_identity obj, acl_object_identity parent, acl_class class where obj.parent_object = parent.id and obj.object_id_class = class.id and parent.object_id_identity = ? and parent.object_id_class = (select id FROM acl_class where acl_class.class = ?)
It would be desirable if this and other sql statements were configurable.</description>
			<version>2.0.1</version>
			<fixedVersion>2.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclService.java</file>
		</fixedFiles>
	</bug>
	<bug id="760" opendate="2008-04-09 00:53:19" fixdate="2008-06-05 17:14:26" resolution="Fixed">
		<buginformation>
			<summary>JaasAuthenticationProvider should refresh the JAAS Configuration when a loginConfig URL is set</summary>
			<description>JaasAuthenticationProvider provides a new login.config.url.X Security property when it is initialised, so that JAAS ConfigFile can retrieve the appropriate file and the loginContextNames therein.
If a second JaasAuthenticationProvider is created and initialised after ConfigFile is initialised (for example if two Spring web applications have different loginConfig files), then the second file is not picked up and creating a LoginContext fails with:
javax.security.auth.login.LoginException: No LoginModules configured for test2
	at javax.security.auth.login.LoginContext.init(LoginContext.java:256)
	at javax.security.auth.login.LoginContext.&amp;lt;init&amp;gt;(LoginContext.java:334)
	at test.Test.testConfigureJaasCase(Test.java:27)
	at test.Test.testConfigureJaas(Test.java:33)
...
The single line:
        Configuration.getConfiguration().refresh();
Needs to be added at the end of configureJaas() I believe. Can supply test case to reproduce and patch.
D</description>
			<version>1.0.6</version>
			<fixedVersion>2.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.providers.jaas.JaasAuthenticationProvider.java</file>
		</fixedFiles>
	</bug>
	<bug id="527" opendate="2007-08-20 13:46:10" fixdate="2008-06-05 23:02:59" resolution="Fixed">
		<buginformation>
			<summary>Serialization Error in ACL cacheing (new acls packages)</summary>
			<description>A java.io.NotSerializableException is thrown when the ehCache which backs EhCacheBasedAclCache decides that it needs to overflow to disk.
As a workaround I have configured the ehCache to NOT overflow to disk by setting setOverflowToDisk(boolean) to false in the spring config of the EhCacheFactoryBean.  This hides the problem and stops my logs filling up with not serializable exceptions, but shouldn&amp;amp;apos;t be considered a fix.
A snippet of the exception is shown below.
2007-08-14 13:58:55,458 ERROR [net.sf.ehcache.store.DiskStore] - &amp;lt;aclCacheCache: Failed to write element to disk &amp;amp;apos;org.acegisecurity.acls.objectidentity.ObjectIdentityImpl[Java Type: class com.my.code.MyAclProtectedObject; Identifier: 11102]&amp;amp;apos;. Initial cause was org.acegisecurity.acls.domain.AclAuthorizationStrategyImpl&amp;gt;
java.io.NotSerializableException: org.acegisecurity.acls.domain.AclAuthorizationStrategyImpl
The exception occurs because AclImpl (the class of the object being cached) implements Serializable, but not all of it&amp;amp;apos;s member variables do, and the member variables which do not implement Serializable are not declared as transient.
Member var                                                                      Serializable   
==================
Acl parentAcl                                                                    yes
AclAuthorizationStrategy aclAuthorizationStrategy           no
AuditLogger auditLogger                                                  no
List aces                                                                           yes  (but contents AccessControlEntry are not)
ObjectIdentity objectIdentity                                             yes
Serializable id                                                                    yes
Sid owner                                                                          no
Sid[] loadedSids                                                                no
boolean entriesInheriting                                                  yes
My thoughts are that the classes of serveral of these member variables (e.g. SID and AccessControlEntry) should implement serializable, but other such as AuditLogger and AclAuthorizationStratagy probably should not, and as such either be removed from the AclImpl class, or declared as transient.  If declared as transient the EhCacheBasedAclCache would need to inject these properties back into AclImpls when they are retrieved from the cache, is this always possible i.e. can we always guarantee that there will be only one AclAuthorizationStrategy being used?
I&amp;amp;apos;d be happy to help anyone resolve this problem, but will be unavailable from mid September to end October 2007.</description>
			<version>1.0.3</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.EhCacheBasedAclCacheTests.java</file>
			<file type="M">org.springframework.security.acls.Permission.java</file>
			<file type="M">org.springframework.security.acls.jdbc.EhCacheBasedAclCache.java</file>
			<file type="M">org.springframework.security.acls.domain.AccessControlEntryImpl.java</file>
			<file type="M">org.springframework.security.acls.domain.AclImplementationSecurityCheckTests.java</file>
			<file type="M">org.springframework.security.acls.AccessControlEntry.java</file>
			<file type="M">org.springframework.security.acls.domain.AccessControlEntryTests.java</file>
			<file type="M">org.springframework.security.acls.domain.AclImpl.java</file>
			<file type="M">org.springframework.security.acls.sid.Sid.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="is depended on by">532</link>
			<link type="Related" description="is related to">951</link>
		</links>
	</bug>
	<bug id="875" opendate="2008-06-09 04:05:42" fixdate="2008-06-11 04:48:59" resolution="Fixed">
		<buginformation>
			<summary>SavedRequestAwareRequestWrapper causes duplication of URL parameters</summary>
			<description>The changes for SEC-830 and SEC-857 appear to have cause an issue with duplicate parameter values appearing when getParameterValues() is called on the wrapper. This will only apply to URL parameters. When deciding how to combine the values from the saved and wrapped request (or if we should), then whether they both contain the same values should be take into account.</description>
			<version>2.0.2</version>
			<fixedVersion>2.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.wrapper.SavedRequestAwareWrapper.java</file>
			<file type="M">org.springframework.security.wrapper.SavedRequestAwareWrapperTests.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">830</link>
			<link type="Related" description="is related to">857</link>
		</links>
	</bug>
	<bug id="880" opendate="2008-06-12 04:19:58" fixdate="2008-06-12 21:59:00" resolution="Fixed">
		<buginformation>
			<summary>ArrayIndexOutOfBoundsException in AuthenticationDetailsSourceImpl</summary>
			<description>I believe that line 61 in AuthenticationDetailsSourceImpl.java should change from:
			if (parameterTypes.length == 1 &amp;amp;&amp;amp; (object == null || parameterTypes[i].isInstance(object))) {
To:
			if (parameterTypes.length == 1 &amp;amp;&amp;amp; (object == null || parameterTypes[0].isInstance(object))) {
(always use the first element of parameterTypes, not the i-th element).
Stack trace:
java.lang.ArrayIndexOutOfBoundsException: 1
	at org.springframework.security.ui.AuthenticationDetailsSourceImpl.getFirstMatchingConstructor(AuthenticationDetailsSourceImpl.java:61)
	at org.springframework.security.ui.AuthenticationDetailsSourceImpl.buildDetails(AuthenticationDetailsSourceImpl.java:30)
	at org.springframework.security.ui.preauth.j2ee.AbstractPreAuthenticatedAuthenticationDetailsSource.buildDetails(AbstractPreAuthenticatedAuthenticationDetailsSource.java:51)
	at org.springframework.security.ui.preauth.AbstractPreAuthenticatedProcessingFilter.doAuthenticate(AbstractPreAuthenticatedProcessingFilter.java:86)
	at org.springframework.security.ui.preauth.AbstractPreAuthenticatedProcessingFilter.doFilterHttp(AbstractPreAuthenticatedProcessingFilter.java:58)
	at org.springframework.security.ui.SpringSecurityFilter.doFilter(SpringSecurityFilter.java:53)</description>
			<version>2.0.2</version>
			<fixedVersion>2.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ui.AuthenticationDetailsSourceImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="890" opendate="2008-06-17 21:18:17" fixdate="2008-06-17 22:51:11" resolution="Fixed">
		<buginformation>
			<summary>RememberMeBeanDefinitionParser uses wrong name for data source</summary>
			<description>The parser attempts to use data-source-ref as the bean property name (i.e. the namespace attribute)
http://forum.springframework.org/showthread.php?t=56057</description>
			<version>2.0.2</version>
			<fixedVersion>2.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.RememberMeBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParserTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="892" opendate="2008-06-18 20:42:17" fixdate="2008-06-19 00:48:46" resolution="Fixed">
		<buginformation>
			<summary>Value of attribute create-session in schema based configuration should set property ExceptionTranslationFilter.createSessionAllowed</summary>
			<description>I am trying to set up a security configuration for a simple web service application using basic (and digest) authentication. There is a requirement that my application should never create HttpSessions, but this is violated as a result of the default value of ExceptionTranslationFilter.createSessionAllowed (true). There seems to be no way to set the value of this property when using schema based configuration.
In my opinion the attribute create-session should affect the value of ExceptionTranslationFilter.createSessionAllowed;
ifRequired: true
always: true
never: false
A relatively easy workaround is to not use schema based configuration......</description>
			<version>2.0.2</version>
			<fixedVersion>2.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="913" opendate="2008-07-09 00:53:59" fixdate="2008-07-15 00:44:44" resolution="Fixed">
		<buginformation>
			<summary>SwitchUserProcessingFilter modifies the switchFailureUrl member variable on failure</summary>
			<description>The code in redirectToFailureUrl() prepends the contextPath to the member variable every time there is a failure. If the contextPath isn&amp;amp;apos;t "" this means that the second time there is a failure the client will be redirected to an invalid page. Here&amp;amp;apos;s the faulty code:
        if (switchFailureUrl != null) 
{
            switchFailureUrl = request.getContextPath() + switchFailureUrl;
            response.sendRedirect(response.encodeRedirectURL(switchFailureUrl));
        }
 else {
Why not use the sendRedirect() method which is used for targetUrl? E.g.:
        if (switchFailureUrl != null) 
{
            sendRedirect(request, response, switchFailureUrl);
        }
 else {
This fix also means that the useRelativeContext property will actually be used also on failures. I think the user of SwitchUserProcessingFilter would expect that.</description>
			<version>2.0.3</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ui.switchuser.SwitchUserProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.ui.switchuser.SwitchUserProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">745</link>
		</links>
	</bug>
	<bug id="903" opendate="2008-07-01 17:38:31" fixdate="2008-07-15 03:52:48" resolution="Fixed">
		<buginformation>
			<summary>Wrong attribute mapping when using jdbc-user-service bean</summary>
			<description>The JdbcUserServiceBeanDefinitionParser adds the wrong property when detecting groupAuthoritiesByUsernameQuery.
It adds authoritiesByUsernameQuery instead of groupAuthoritiesByUsernameQuery.
Thus after that the JdbcDaoImpl use its default value for groupAuthoritiesByUsernameQuery instead of the one passed 
in parameter by the bean.
I guess that if authoritiesByusernameQuery is passed also, there should be a mismatch between the two queries. 
This is a side effect.
Correction tested :
In the class JdbcUserServiceBeanDefinitionParser   
if (StringUtils.hasText(groupAuthoritiesQuery)) {
   builder.addPropertyValue("enableGroups", Boolean.TRUE);
   //builder.addPropertyValue("authoritiesByUsernameQuery", groupAuthoritiesQuery);
   // should be
   builder.addPropertyValue("groupAuthoritiesByUsernameQuery", groupAuthoritiesQuery);
   // end correction
}
With that the JdbcDaoImplTests testLookupFailsIfUserHasNoGrantedAuthorities() will fail.
When looking at it, it seems that it is not functionaly correct.
</description>
			<version>2.0.3</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.JdbcUserServiceBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.config.JdbcUserServiceBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="899" opendate="2008-06-27 12:51:50" fixdate="2008-07-31 00:03:37" resolution="Fixed">
		<buginformation>
			<summary>GrantedAuthorityImpl.compareTo should handle null roles</summary>
			<description>when mixing GrantedAuthorityImpl with other more specialized implementations that return null from getAuthority, GrantedAuthorityImpl.compareTo fails with an NPE.</description>
			<version>2.0.3</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.GrantedAuthorityImplTests.java</file>
			<file type="M">org.springframework.security.GrantedAuthorityImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="923" opendate="2008-07-14 14:18:51" fixdate="2008-07-31 06:32:41" resolution="Fixed">
		<buginformation>
			<summary>OpenId integration and support for discovering relying parties</summary>
			<description>Hi,
I am using the excellent openId support in Spring Security but I noticed that with Yahoo, I keep seeing the following message on Yahoo&amp;amp;apos;s openid page:
"Warning: This website has not confirmed its identity with Yahoo! and might be fraudulent. Do not share any personal information with this website unless you are certain it is legitimate. "
I looked into this issue and found that  the reason is that Yahoo implements a feature in OpenId 2.0 where it verifies if the return_to URL is a relying party endpoint (see http://openid.net/specs/openid-authentication-2_0-12.html#realms, section 9.2.1). In this case the return_to URL is http://&amp;lt;website&amp;gt;/j_spring_openid_security_check.
I also followed the tutorial here http://blog.nerdbank.net/2008/06/why-yahoo-says-your-openid-site.html but with no success. 
I can actually see on my webserver log a Yahoo IP address hitting the following URL after I post the OpenId authentication request:
68.142.241.108 - - [15/Jul/2008:02:49:06 +0000] "GET /j_spring_openid_security_check HTTP/1.1" 302 -
after which Yahoo&amp;amp;apos;s openId page shows the warning. Note that the login works fine if I click on the "Let me in" button.
Please help.
florin</description>
			<version>2.0.3</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ui.openid.consumers.OpenID4JavaConsumer.java</file>
			<file type="M">org.springframework.security.ui.openid.consumers.MockOpenIDConsumer.java</file>
			<file type="M">org.springframework.security.ui.openid.OpenIDConsumer.java</file>
			<file type="M">org.springframework.security.ui.openid.OpenIDAuthenticationProcessingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="943" opendate="2008-07-31 06:17:52" fixdate="2008-08-05 10:09:52" resolution="Fixed">
		<buginformation>
			<summary>DefaultSpringSecurityContextSource should support escaped spaces in URL.</summary>
			<description>When working out the base name, it uses URI.getPath() when it should probably use URI.getRawPath(). Otherwise it gets confused by the returned space and assumes that there are multiple URLs in the string.</description>
			<version>2.0.3</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.DefaultSpringSecurityContextSourceTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="947" opendate="2008-08-03 17:29:25" fixdate="2008-08-05 11:18:09" resolution="Fixed">
		<buginformation>
			<summary>&lt;custom-filter before="FIRST" /&gt; causes filter to be placed last in the filters chain</summary>
			<description>With this configuration:
&amp;lt;bean id="myFilter" class="SomeFilterClass"&amp;gt;
  &amp;lt;custom-filter before="FIRST" /&amp;gt;
&amp;lt;/s:bean&amp;gt;
myFilter will be placed last in the filters chain, because of this line in OrderedFilterBeanDefinitionDecorator class:
return Integer.toString(FilterChainOrder.getOrder(before) - 1);
FilterChainOrder.getOrder(before) returns Integer.MIN_VALUE for filterName "FIRST" and then decrement (-1) causes numerical buffer overflow so that order returned becomes Integer.MAX_VALUE not MIN_VALUE.
WORKAROUND: use this instead:
&amp;lt;bean id="myFilter" class="SomeFilterClass"&amp;gt;
  &amp;lt;custom-filter before="CHANNEL_FILTER" /&amp;gt;
&amp;lt;/s:bean&amp;gt;</description>
			<version>2.0.3</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.OrderedFilterBeanDefinitionDecorator.java</file>
		</fixedFiles>
	</bug>
	<bug id="933" opendate="2008-07-23 00:31:57" fixdate="2008-08-05 22:11:14" resolution="Fixed">
		<buginformation>
			<summary>global-method-security and aop:aspectj-autoproxy throws NullPointerException in some situations</summary>
			<description>Hello, 
there is an situation where the combination of global-method-security and aop:aspectj-autoproxy throws a NullPointerException.
This happens if you have a custom UserDetailsService implementation which itself uses an secured collaborator class (DAO/Repository) to load 
user objects from the database.
I.e. You have a UserRepository with finder/update methods, and you want to secure the full repository except one finder method to load the user 
objects from the database. The UserDetailsService implementation will use that repository to load the objects.
If you don&amp;amp;apos;t use the aop:aspectj-autoproxy functionality the scenario above works without any error. But if you add aop-aspectj-autoproxy to 
the configuration (without any aspect!) you will get an nullpointerexception.
Here is the stacktrace 
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;org.springframework.security.providers.dao.DaoAuthenticationProvider#0&amp;amp;apos;: Cannot resolve reference to bean &amp;amp;apos;userDetailsService&amp;amp;apos; while setting bean property &amp;amp;apos;userDetailsService&amp;amp;apos;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;userDetailsService&amp;amp;apos; defined in class path resource [security-config.xml]: Initialization of bean failed; nested exception is java.lang.NullPointerException
	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:275)
	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:104)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1244)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1008)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:470)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$1.run(AbstractAutowireCapableBeanFactory.java:409)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:380)
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:264)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:220)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:261)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164)
	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:269)
	... 69 more
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;userDetailsService&amp;amp;apos; defined in class path resource [security-config.xml]: Initialization of bean failed; nested exception is java.lang.NullPointerException
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:478)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$1.run(AbstractAutowireCapableBeanFactory.java:409)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:380)
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:264)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:220)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:261)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164)
	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:269)
	... 82 more
Caused by: java.lang.NullPointerException
	at org.springframework.security.intercept.method.aopalliance.MethodDefinitionSourceAdvisor$MethodDefinitionSourcePointcut.matches(MethodDefinitionSourceAdvisor.java:120)
	at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:214)
	at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:253)
	at org.springframework.aop.support.AopUtils.findAdvisorsThatCanApply(AopUtils.java:287)
	at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply(AbstractAdvisorAutoProxyCreator.java:113)
	at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findEligibleAdvisors(AbstractAdvisorAutoProxyCreator.java:85)
	at org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean(AbstractAdvisorAutoProxyCreator.java:66)
	at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:345)
	at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:309)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:361)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1342)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:471)
	... 91 more
This should be fixed, or at least the should be a better error message in this situations.
Rgds
Agim
</description>
			<version>2.0.2</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.BeanIds.java</file>
			<file type="M">org.springframework.security.config.method.GlobalMethodSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.GlobalMethodSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.config.CustomAuthenticationProviderBeanDefinitionDecorator.java</file>
			<file type="M">org.springframework.security.providers.ProviderManager.java</file>
			<file type="M">org.springframework.security.config.AuthenticationManagerBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.intercept.method.aopalliance.MethodDefinitionSourceAdvisor.java</file>
			<file type="M">org.springframework.security.config.LdapProviderBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.AuthenticationProviderBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.RememberMeBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.ConfigUtils.java</file>
			<file type="M">org.springframework.security.providers.ProviderManagerTests.java</file>
			<file type="M">org.springframework.security.config.AnonymousBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.X509BeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.ui.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="896" opendate="2008-06-24 21:32:11" fixdate="2008-08-08 03:07:47" resolution="Fixed">
		<buginformation>
			<summary>Authentication tag throws NPE if custom principal property evaluates to null</summary>
			<description>Stacktrace:
java.lang.NullPointerException
	at org.springframework.security.taglibs.authz.AuthenticationTag.doEndTag(AuthenticationTag.java:123)
Caused by the following JSP code:
&amp;lt;s:authentication property="principal.customProperty"/&amp;gt;
Where the custom UserDetails property "customProperty" is set to null. To fix, change line org/springframework/security/taglibs/authz/AuthenticationTag.java:123 from 
            writeMessage(result.toString());  
to
            writeMessage(String.valueOf(result));
in order to avoid NPE where a property returns null.</description>
			<version>2.0.2</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.taglibs.authz.AuthenticationTag.java</file>
		</fixedFiles>
	</bug>
	<bug id="953" opendate="2008-08-11 04:14:13" fixdate="2008-08-11 06:23:51" resolution="Fixed">
		<buginformation>
			<summary>Query string isn&amp;apos;t ignored while url - filterchain pattern matching</summary>
			<description>While upgrading from Acegi Security 1.0.7 to Spring Security 2.0.2 I noticed that url matching doesn&amp;amp;apos;t work as it was before.
In Acegi I used the following url - filter chaing mapping:
&amp;lt;bean id="filterChainProxy" class="org.acegisecurity.util.FilterChainProxy"&amp;gt;
    &amp;lt;property name="filterInvocationDefinitionSource"&amp;gt;
	&amp;lt;value&amp;gt;
	     CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON 
	     PATTERN_TYPE_APACHE_ANT
                  j_acegi_security_check=httpSessionContextIntegrationFilter,....................			
	    j_acegi_logout=httpSessionContextIntegrationFilter,.......................
                 /*/.htm=httpSessionContextIntegrationFilter,.....................
            &amp;lt;/value&amp;gt;
  &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
I Spring Security the same mapping looks as follows:
&amp;lt;bean id="filterChainProxy" class="org.springframework.security.util.FilterChainProxy"&amp;gt;
    &amp;lt;security:filter-chain-map path-type="ant"&amp;gt;
            &amp;lt;security:filter-chain pattern="/j_spring_security_check" filters="httpSessionContextIntegrationFilter, ..............." /&amp;gt;
	&amp;lt;security:filter-chain pattern="/j_spring_security_logout" filters="httpSessionContextIntegrationFilter,....." /&amp;gt;
	&amp;lt;security:filter-chain pattern="/*/.htm" filters="httpSessionContextIntegrationFilter,....." /&amp;gt;			
    &amp;lt;/security:filter-chain-map&amp;gt;	
&amp;lt;/bean&amp;gt;
But  I received NullPointerException while performing some requests.  It appears because these requests bypass filterchain and Security Context isn&amp;amp;apos;t integrated into a session. Such situation occurs for requests which includes parameters in url.
For instance, request url &amp;amp;apos;page1.htm&amp;amp;apos; matches to pattern &amp;amp;apos;/*/.htm&amp;amp;apos; but url &amp;amp;apos;page1.htm?param=value&amp;amp;apos; doesn&amp;amp;apos;t. 
It caused by changes in url - filterchain pattern matching. In Acegi PathBasedFilterInvocationDefinitionMap ignores query string (any symbols after first &amp;amp;apos;?&amp;amp;apos;) but in Spring FilterChainProxy provides full requests url to matcher (in this case AntUrlPathMatcher) :
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException 
{

        FilterInvocation fi = new FilterInvocation(request, response, chain);
        List filters = getFilters(fi.getRequestUrl());
       .................

}

public List getFilters(String url)  {
      Iterator filterChains = filterChainMap.entrySet().iterator();
        while (filterChains.hasNext()) {
            Map.Entry entry = (Map.Entry) filterChains.next();
            Object path = entry.getKey();
            if (matcher.requiresLowerCaseUrl()) {
                url = url.toLowerCase();
                if (logger.isDebugEnabled()) 
{
                    logger.debug("Converted URL to lowercase, from: &amp;amp;apos;" + url + "&amp;amp;apos;; to: &amp;amp;apos;" + url + "&amp;amp;apos;");
                }
            }
            boolean matched = matcher.pathMatchesUrl(path, url);
             ......
}
To keep backward compatibility I offer to change doFilter() implementation to pass request url without query string into getFilters() method.
</description>
			<version>2.0.2</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.util.FilterChainProxyTests.java</file>
			<file type="M">org.springframework.security.util.FilterChainProxy.java</file>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParserTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="905" opendate="2008-07-03 15:30:00" fixdate="2008-08-12 04:15:05" resolution="Fixed">
		<buginformation>
			<summary>&lt;protect-pointcut /&gt; pointcuts do not respect method arguments</summary>
			<description>Suppose you have two methods with the same name but different parameter types along with some further methods. E.g. securing a method with one parameter with an admin role and all other methods (by using *.(..)) with a user role this leads to upredictable results. Depending on which of the two methods you secure, you either get both secured with admin role or all methods of the class are only user secured.
Digging into the sources I suppose the MapBasedDefinitionSource to be the problem. addSecureMethod(Class javaType, String mappedName, ConfigAttributeDefinition attr) only regards method names but does NOT regard parameters.
Furthermore the check for more specificality seems odd to me. If you take the order of the pointcut definitions into account, the first pointcut matching a method should win. I doubt if it is possible at all to find out if one pointcut is a subset or superset of another. SO why not take the first match?
Regards,
Ollie</description>
			<version>2.0.3</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.GlobalMethodSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.annotation.BusinessService.java</file>
			<file type="M">org.springframework.security.annotation.BusinessServiceImpl.java</file>
			<file type="M">org.springframework.security.intercept.method.MapBasedMethodDefinitionSource.java</file>
			<file type="M">org.springframework.security.intercept.method.ProtectPointcutPostProcessor.java</file>
			<file type="M">org.springframework.security.annotation.Jsr250BusinessServiceImpl.java</file>
			<file type="M">org.springframework.security.config.ConfigTestUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="936" opendate="2008-07-27 21:01:44" fixdate="2008-08-15 13:33:05" resolution="Fixed">
		<buginformation>
			<summary>NPE in AbstractFallbackMethodDefinitionSource</summary>
			<description>A NullPointerException occurs in the following code while calling mi.getThis().getClass():
    public ConfigAttributeDefinition getAttributes(Object object) throws IllegalArgumentException {
        Assert.notNull(object, "Object cannot be null");
        if (object instanceof MethodInvocation) 
{
        	MethodInvocation mi = (MethodInvocation) object;
            return getAttributes(mi.getMethod(), mi.getThis().getClass());
        }

I guess the mi.getThis() method returns null when there is no target object. This is the case, for example, when the last interceptor in the chain handles the method call instead of a &amp;amp;apos;real&amp;amp;apos; target object (like Spring&amp;amp;apos;s HttpInvokerClientInterceptor). 
I think the getAttributes() method accepts a null targetClass, so a simple mi.getThis()==null?null:mi.getThis().getClass() would fix this issue.
</description>
			<version>2.0.3</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.intercept.method.AbstractFallbackMethodDefinitionSource.java</file>
			<file type="M">org.springframework.security.intercept.method.MapBasedMethodDefinitionSource.java</file>
			<file type="M">org.springframework.security.config.GlobalMethodSecurityBeanDefinitionParserTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="832" opendate="2008-05-14 01:24:19" fixdate="2008-08-25 23:54:13" resolution="Fixed">
		<buginformation>
			<summary>NamingEnumeration.hasMore fails on MS AD with PartialResultException</summary>
			<description>Implementation of org.springframework.security.ldap.searchForSingleEntry doesn&amp;amp;apos;t work with MS AD.
When calling results.hasMore with base="" a PartialResultException is thrown. The call hasMore should
be replaced with hasMoreElements() and whole method should look like this:
public DirContextOperations searchForSingleEntry(final String base, final String filter, final Object[] params) {
        return (DirContextOperations) executeReadOnly(new ContextExecutor() {
			        public Object executeWithContext(DirContext ctx)
			            throws NamingException {
			            try {
							NamingEnumeration results = ctx.search(base, filter, params, searchControls);
							if (!results.hasMoreElements())
								throw new IncorrectResultSizeDataAccessException(1, 0);
							SearchResult searchResult = (SearchResult) results.next();
							logger.debug("searchResult="+searchResult);
							if (results.hasMoreElements()) 
{
								if (!searchResult.equals((SearchResult) results.next()))
									throw new IncorrectResultSizeDataAccessException(1, 2);
							}

							// Work out the DN of the matched entry
							StringBuffer dn = new StringBuffer(searchResult.getName());
							if (base.length() &amp;gt; 0) 
{
							    dn.append(",");
							    dn.append(base);
							}

							return new DirContextAdapter(searchResult.getAttributes(),
							        new DistinguishedName(dn.toString()), new DistinguishedName(ctx.getNameInNamespace()));
						}
			            catch (Exception e) 
{
			            	NamingException ne = new NamingException(e.getMessage());
							ne.setStackTrace(e.getStackTrace());
							throw ne;
						}
			        }
			    });		       
    }</description>
			<version>2.0.1</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.SpringSecurityLdapTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">113</link>
		</links>
	</bug>
	<bug id="908" opendate="2008-07-06 14:40:44" fixdate="2008-09-04 15:36:13" resolution="Fixed">
		<buginformation>
			<summary>BasePermission.buildFromName(name) does not find static permission in class</summary>
			<description>I am converting from Acegi 1.0.3.
This code:
     BasePermission.buildFromName(name)
With name having the value "WRITE" (a permission within BasePermission) throws this assertion error:
java.lang.IllegalArgumentException: Unknown permission &amp;amp;apos;WRITE&amp;amp;apos;
        at org.springframework.util.Assert.isTrue(Assert.java:65)
        at org.springframework.security.acls.domain.DefaultPermissionFactory.bui
ldFromName(DefaultPermissionFactory.java:108)
        at org.springframework.security.acls.domain.AbstractRegisteredPermission
.buildFromName(AbstractRegisteredPermission.java:33)
After a little debugging, the registeredPermissionsByName Map is in fact empty.
I could be wrong, but I believe the problem is that java will call the method in the superclass of BasePermission and not execute the static initializer. I could get around this problem by hacking an inner class to use the BasePermission constructor before using this method (which forces the static initializer to execute).</description>
			<version>2.0.3</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.security.acls.domain.AbstractRegisteredPermission.java</file>
			<file type="M">org.springframework.security.acls.domain.BasePermission.java</file>
			<file type="M">org.springframework.security.acls.domain.PermissionTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="960" opendate="2008-08-20 06:25:06" fixdate="2008-09-05 00:51:23" resolution="Fixed">
		<buginformation>
			<summary>DN Encoding in LDAPUserDetailsManager.changePassword() causes bind errors</summary>
			<description>Please see the write-up here:
http://forum.springframework.org/showthread.php?t=53118
This prevents changepassword operations by binding as the user.  Normally, binding as the admin to change the password will work, but certain LDAP directory servers (such as Novell eDirectory) have a policy that sets the user&amp;amp;apos;s account to expire after some small time period whenever an admin user changes a password.  However, this side-effect is undesirable when it&amp;amp;apos;s actually the user changing the password.
</description>
			<version>2.0.3</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.userdetails.ldap.LdapUserDetailsManagerTests.java</file>
			<file type="M">org.springframework.security.userdetails.ldap.LdapUserDetailsManager.java</file>
		</fixedFiles>
	</bug>
	<bug id="975" opendate="2008-09-10 01:17:26" fixdate="2008-09-12 06:08:04" resolution="Fixed">
		<buginformation>
			<summary>Namespace access-denied-page attribute does not work with property placeholders</summary>
			<description>Hello,
I am trying to use a property inside Spring security:
	&amp;lt;security:http 
		access-denied-page="$
{security.errorPage}
"
 ...&amp;gt;
		...
	&amp;lt;/security:http&amp;gt;
Where security.errorPage is a property defined in a property file loaded by a org.springframework.beans.factory.config.PropertyPlaceholderConfigurer bean.
But it is not interpreted.
Looking at org.springframework.security.config.HttpSecurityBeanDefinitionParser I got the confirmation it is not a case.
I don&amp;amp;apos;t know if it is a feature but I think it may be useful.
Philippe.</description>
			<version>2.0.3</version>
			<fixedVersion>2.0.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="996" opendate="2008-09-30 10:30:35" fixdate="2008-12-15 06:17:19" resolution="Fixed">
		<buginformation>
			<summary>AccessDeniedhandlerimpl  doesn&amp;apos;t write response code if used with errorPage</summary>
			<description>The forward to the error page will cause the response to be committed and thus the 403 error code cannot be written (the commit check was introduced as a fix for SEC-324), but the code should perhaps be written before the forward instead.</description>
			<version>2.0.3</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ui.AccessDeniedHandlerImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="992" opendate="2008-09-29 09:12:30" fixdate="2008-12-15 06:17:19" resolution="Fixed">
		<buginformation>
			<summary>SpringSecurityLdapTemplate: clearing the returningObjFlag of SearchControls contradicts contract with LdapTemplate</summary>
			<description>In method searchForSingleAttributeValues(String, String, Object[], String) of class SpringSecurityLdapTemplate, on line 168, there is this call:
ctls.setReturningObjFlag(false);
Then the search(String, String, Object[], String) method is called with a context mapper, which implies that  returnObj must be true in SearchControls. LdapTemplate checks the returningObjFlag state, and if it is false, sets it to true. It also emits an INFO log entry about the inconsistency.
The documentation of class SearchControls states for the controls argument:
"The &amp;lt;code&amp;gt;SearchControls&amp;lt;/code&amp;gt; to use in the search. If the

returnObjFlag is not set in the &amp;lt;code&amp;gt;SearchControls&amp;lt;/code&amp;gt;,
this method will set it automatically, as this is required for
the &amp;lt;code&amp;gt;ContextMapper&amp;lt;/code&amp;gt; to work.
"

Setting the returningObjFlag to false is at best superfluous, at worst some behavior of the search is desired, which cannot be achieved this way.</description>
			<version>2.0.3</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.SpringSecurityLdapTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="1031" opendate="2008-11-11 06:45:15" fixdate="2008-12-15 06:17:20" resolution="Fixed">
		<buginformation>
			<summary>LdapShaPasswordEncoder.isPasswordValid startOfHash off by one</summary>
			<description>in LdapShaPasswordEncoder.isPasswordValid the startOfHash variable is initialized to prefix.length() + 1.
This causes the first character of the hash values to be skipped in the subsequent equals invocation.
Is there some (undocumented) reason that the first character of the hash is being skipped, or is this a bug?
Example:
encPass = "
{SHA}nU4eI71bcnBGqeO0t9tXvY1u5oQ="
rawPass = "pass"
prefix = "{SHA}
"
startOfHash = 6 (should be 5: prefix.length())
encodedRawPass = "U4eI71bcnBGqeO0t9tXvY1u5oQ=" (should be "nU4eI71bcnBGqeO0t9tXvY1u5oQ=")</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.providers.ldap.authenticator.LdapShaPasswordEncoderTests.java</file>
			<file type="M">org.springframework.security.providers.ldap.authenticator.LdapShaPasswordEncoder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1037" opendate="2008-11-25 00:25:53" fixdate="2008-12-15 06:17:20" resolution="Fixed">
		<buginformation>
			<summary>LdapAuthenticationProvider doesn&amp;apos;t support messageSource updates/modifications</summary>
			<description>In order to allow localisation and personnal messages&amp;amp;apos; definition org.springframework.security.providers.ldap.LdapAuthenticationProvider should implement org.springframework.context.MessageSourceAware.
At this time it&amp;amp;apos;s not the case, so it is impossible to modify messages and use messages&amp;amp;apos; localisation for this object (see 6.1 in spring security documentation http://static.springsource.org/spring-security/site/reference/html/supporting-infrastructure.html#localization).
By the way this object also doesn&amp;amp;apos;t implement org.springframework.beans.factory.InitializingBean.</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.providers.ldap.LdapAuthenticationProvider.java</file>
		</fixedFiles>
	</bug>
	<bug id="1006" opendate="2008-10-05 20:36:47" fixdate="2008-12-15 10:08:48" resolution="Fixed">
		<buginformation>
			<summary>AccessControlListTag class Javadoc incorrect</summary>
			<description>The class-level Javadoc for AccessControlListTag incorrectly states that there must be exactly one SidRetrievalStrategy bean on the application context. While the tag will complain if multiple such beans exist, there is no issue if no SidRetrievalStrategy implementations exist. In that event AccessControlListTag simply creates a SidRetrievalStrategyImpl instance and uses that.
</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.taglibs.authz.AccessControlListTag.java</file>
		</fixedFiles>
	</bug>
	<bug id="993" opendate="2008-09-29 14:15:45" fixdate="2008-12-16 06:40:13" resolution="Fixed">
		<buginformation>
			<summary>OpenID and RememberMe broken</summary>
			<description>I&amp;amp;apos;m trying to create a remember-me cookie with an OpenID authentication. Since OpenIDAuthenticationToken doesn&amp;amp;apos;t support password, it&amp;amp;apos;s causing a NullPointerException in TokenBasedRememberMeServices.retrievePassword() - it calls toString() on the null password ("return authentication.getCredentials().toString();" line 202).
How am I supposed to use cookies with OpenID? If I create my own RememberMeServices and leave out the password then anyone can create a cookie with my OpenID and log in as me.</description>
			<version>2.0.3</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ui.rememberme.TokenBasedRememberMeServices.java</file>
			<file type="M">org.springframework.security.ui.rememberme.TokenBasedRememberMeServicesTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1014" opendate="2008-10-16 20:55:23" fixdate="2009-04-19 17:12:12" resolution="Duplicate">
		<buginformation>
			<summary>minor changes for an easy NTLM / LDAP configuration</summary>
			<description>Following changes are needed for an easy NTLM and LDAP (Active Directory) integration :
LdapAuthenticationProvider :
Either accept empty password (then LdapAuthenticationProvider can be used as is), or change scope to protected for the private LdapAuthenticator authenticator; : in that case we can easily override the authenticate() method to avoid password length check, without the need to use another LdapAuthenticator in the overriding class.
Another change is needed for NTLM : AbstractLdapAuthenticator with no password check.
PasswordComparisonAuthenticator is final and can&amp;amp;apos;t be overrided, despite the only usefull change is to comment last lines in authenticate() to remove password check.
Because of the class name, it&amp;amp;apos;s not easy to change this...
So may a new class extending LdapAuthenticationProvider  exists  ( with no password check) ?
With those 2 changes, we can use NTLM to get username, use it to query LDAP and retrieve user informations (email, name, etc..) then use such informations in a custom UserDetails implementation (via a convenient UserDetailsContextMapper) without any implementation.
Hope this can help.
Regards.
</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Refactoring</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.LdapAuthenticationProvider.java</file>
			<file type="M">org.springframework.security.ldap.authentication.BindAuthenticator.java</file>
			<file type="M">org.springframework.security.ldap.authentication.BindAuthenticatorTests.java</file>
			<file type="M">org.springframework.security.ldap.authentication.LdapAuthenticationProviderTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1117</link>
		</links>
	</bug>
	<bug id="1078" opendate="2009-01-08 19:39:49" fixdate="2009-04-26 17:04:25" resolution="Fixed">
		<buginformation>
			<summary>WebSphere2SpringSecurityPropagationInterceptor creates an auth token with null credentials - rejected by pre-auth provider</summary>
			<description>WebSphere2SpringSecurityPropagationInterceptor creates a PreAuthenticatedAuthenticationToken request with the was username, and null credentials (line 55 in WebSphere2SpringSecurityPropagationInterceptor).
Such an auth request will be rejected by corresponding provider, (PreAuthenticatedAuthenticationProvider, lines 73-80).
I suggest to change the interceptor and follow what&amp;amp;apos;s in the WebSpherePreAuthenticatedProcessingFilter: the filter return "N/A" as the credentials, which is ok, since the pre-auth provider does not check credential values.
Also, in order to unit test WAS stuff into the org.springframework.security.ui.preauth.websphere package, the WASSecurityHelper should be refactored into a non-static class - at least this would have prevented this bug. You will find attached a proposal for such a refactoring.</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.preauth.websphere.WebSpherePreAuthenticatedAuthenticationDetailsSource.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.websphere.WebSphere2SpringSecurityPropagationInterceptor.java</file>
			<file type="D">org.springframework.security.web.authentication.preauth.websphere.WASSecurityHelper.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.websphere.WebSpherePreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1143" opendate="2009-04-27 22:02:36" fixdate="2009-04-27 23:11:03" resolution="Fixed">
		<buginformation>
			<summary>Using Namespace won&amp;apos;t set sessionRegistry for form-login</summary>
			<description>When using concurrent session using namespace like :
&amp;lt;security:concurrent-session-control max-sessions="1" expired-url="/login-page.html" session-registry-ref="onlineManager"/&amp;gt;     
the onlineManager is my own sessionRegistry
I found when login it always register a new session and then remove it. I dig it found it is in AbstractProcessingFilter.java line 367:
SessionUtils.startNewSessionIfRequired(request, migrateInvalidatedSessionAttributes, sessionRegistry);
And the  AbstractProcessingFilter.java has 
    public void setSessionRegistry(SessionRegistry sessionRegistry) 
{
        this.sessionRegistry = sessionRegistry;
    }
But I can&amp;amp;apos;t find any description for form-login in spring-security-2.0.4.xsd.
I can using just bean define to solve this.But this must bei xsd problem or namespace inplement.</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.FormLoginBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.util.FieldUtils.java</file>
			<file type="M">org.springframework.security.config.HttpSecurityBeanDefinitionParserTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1141" opendate="2009-04-17 03:12:02" fixdate="2009-04-28 12:47:03" resolution="Fixed">
		<buginformation>
			<summary>ObjectIdentityImpl has incorrect hashCode implementation</summary>
			<description>The ObjectIdentityImpl class contains a bug in it&amp;amp;apos;s hashCode implementation. 2 objects which are equal to each other using the &amp;amp;apos;.equals()&amp;amp;apos; method do not neccesarily produce the same hashcode. Consider the following code:
ObjectIdentityImpl oi1 = new ObjectIdentityImpl("java.lang.String", "10");
ObjectIdentityImpl oi2 = new ObjectIdentityImpl("java.lang.String", 10);
System.out.println(oi1.equals(oi2));					//true
System.out.println(oi1.hashCode() == oi2.hashCode());	//false
System.out.println(oi1.hashCode());						//25246124
System.out.println(oi2.hashCode());						//25247673
This is due to the use of &amp;amp;apos;this.identifier.hashCode()&amp;amp;apos; (line 146 ObjectIdentityImpl), while the equals method uses &amp;amp;apos;this.getIdentifier().toString().equals(other.getIdentifier().toString()&amp;amp;apos; (line 123 ObjectIdentityImpl)</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.security.acls.objectidentity.ObjectIdentityTests.java</file>
			<file type="M">org.springframework.security.acls.objectidentity.ObjectIdentityImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="1121" opendate="2009-03-16 21:50:27" fixdate="2009-04-28 13:02:09" resolution="Fixed">
		<buginformation>
			<summary>InMemoryResource.equals() is wrong</summary>
			<description>Here is org.springframework.security.util.InMemoryResource.equals method code:
  public boolean equals(Object res) {
        if (res instanceof InMemoryResource) 
{
            return false;
        }

        return Arrays.equals(source, ((InMemoryResource)res).source);
    }

Obviously, this should be:

  public boolean equals(Object res) {
        if (!(res instanceof InMemoryResource)) {            return false;        }

        return Arrays.equals(source, ((InMemoryResource)res).source);
    }</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.util.InMemoryResource.java</file>
		</fixedFiles>
	</bug>
	<bug id="1117" opendate="2009-03-10 23:26:42" fixdate="2009-04-28 13:04:10" resolution="Fixed">
		<buginformation>
			<summary>Unable to use NtlmAwareLdapAuthenticator with LdapAuthenticationProvider due to checking for null password.  </summary>
			<description>Currently LdapAuthenticatonProvider checks for empty password in its authenticate() method (lines 225 onward). This does not allow to use NtlmAwareLdapAuthenticator as a delegate for authentication because null password will be always rejected - as is the case when using NTLM authentication - and NtlmAwareLdapAuthenticator never gets called.  
Forum thread mentioned above confirms the same problem encountered by another user (see item 2 in the top post)
Also a similiar problem exists with id: SEC-1014. </description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.LdapAuthenticationProvider.java</file>
			<file type="M">org.springframework.security.ldap.authentication.BindAuthenticator.java</file>
			<file type="M">org.springframework.security.ldap.authentication.BindAuthenticatorTests.java</file>
			<file type="M">org.springframework.security.ldap.authentication.LdapAuthenticationProviderTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1014</link>
		</links>
	</bug>
	<bug id="1070" opendate="2008-12-30 07:49:38" fixdate="2009-04-28 13:10:08" resolution="Fixed">
		<buginformation>
			<summary>AbstractRetryEntryPoint always uses RetryWithHttpEntryPoint logger</summary>
			<description>AbstractRetryEntryPoint  has a static logger defined by RetryWithHttpEntryPoint.class, instead of using a non-static getLogger(getClass()) or an abstract Log getLogger() function that would be implemented in both RetryWithHttpEntryPoint and RetryWithHttpsEntryPoint to provide the correct class for logging.
The impact is that log messages for the RetryWithHttpsEntryPoint get logged under the RetryWithHttpEntryPoint logger.</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.securechannel.AbstractRetryEntryPoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="1084" opendate="2009-01-21 01:19:20" fixdate="2009-05-05 20:46:07" resolution="Fixed">
		<buginformation>
			<summary>Retain Authentication.details when authenticating in LdapAuthenticationProvider</summary>
			<description>It seems that the LdapAuthenticationProvider looses any details set on the incomming Authentication.details property. Several other AuthenticationProviders retain these details
Unless of course this is intentional it should be trivial to improve this with simply copying the details, thus making them available to the application. 
Simple suggestion attached as patch.</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.LdapAuthenticationProvider.java</file>
			<file type="M">org.springframework.security.ldap.authentication.LdapAuthenticationProviderTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1154</link>
		</links>
	</bug>
	<bug id="1081" opendate="2009-01-17 00:09:45" fixdate="2009-05-05 20:50:49" resolution="Fixed">
		<buginformation>
			<summary>PersistentTokenBasedRememberMeServices int overflow</summary>
			<description>The PersistentTokenBasedRememberMeServices always throws RememberMeAuthenticationException if  tokenValiditySeconds is 30 days or 2592000 seconds.
Either tokenValiditySeconds needs to be a long or tokenValiditySeconds needs to multiply 1000L (getTokenValiditySeconds()*1000L).</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategyTests.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategy.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.PersistentTokenBasedRememberMeServicesTests.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.PersistentTokenBasedRememberMeServices.java</file>
		</fixedFiles>
	</bug>
	<bug id="1111" opendate="2009-02-24 16:55:58" fixdate="2009-05-05 20:51:17" resolution="Fixed">
		<buginformation>
			<summary>DefaultLoginPageGeneratingFilter does not work with messages_ko_KR.properties</summary>
			<description>(attachement is eclipse project and screenshot)
I made messages_ko_KR.properties. 
(C:\workspace\codelabor-spring-security-template\src\main\resources\org\springframework\security\messages_ko_KR.properties)
And I try default form-login with empty username and password.
500 Error occures like screenshot image.
---------------------------------------------------------------------
java.io.CharConversionException: Not an ISO 8859-1 character: 
	at javax.servlet.ServletOutputStream.print(ServletOutputStream.java:89)
---------------------------------------------------------------------
I retry login with correct username and password.
Login is sucess.
In index.jsp page, I test messageSource like this:
-------------------------------------------------------------------------
WebApplicationContext context = WebApplicationContextUtils.getRequiredWebApplicationContext(application);
MessageSource messageSource = (MessageSource) context.getBean("messageSource");
out.println(messageSource.getMessage("AbstractUserDetailsAuthenticationProvider.badCredentials", null, Locale.getDefault()));
-------------------------------------------------------------------------
index.jsp page works, like attachement image.
So my message_ko_KR.properties is good.
What&amp;amp;apos;s wroing with DefaultLoginPageGeneratingFilter?
</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.DefaultLoginPageGeneratingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.DefaultLoginPageGeneratingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1104" opendate="2009-02-09 16:09:34" fixdate="2009-05-05 21:07:47" resolution="Fixed">
		<buginformation>
			<summary>Server created by ApacheDSContainer is shutdown twice, causing a hang</summary>
			<description>I have a default ApacheDS server launched for testing via &amp;lt;ldap-server/&amp;gt; element in my spring config. This is inside a webapp, and the context is loaded through a servlet context listener (if that makes any difference).
ApacheDSContainer implements both Lifecycle and DisposableBean.  Both destroy methods get called, but neither checks the &amp;amp;apos;running&amp;amp;apos; field before trying to shut down the ApacheDS server.  The first shutdown works, but since the server is contacted over a socket, the second attempt hangs until the socket times out.
The easy fix is to just check the &amp;amp;apos;running&amp;amp;apos; field in the stop() method and don&amp;amp;apos;t do anything if the server isn&amp;amp;apos;t running.</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.server.ApacheDSContainer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1038" opendate="2008-11-25 18:55:32" fixdate="2009-05-06 01:36:55" resolution="Fixed">
		<buginformation>
			<summary>Error in JdbcMutableAclService with Postgres</summary>
			<description>When I use the Spring Security&amp;amp;apos;s ACL services with a Postgres database, I am getting the following error when I call the createAcl method in the JdbcMutableAclService class  :
Caused by: org.postgresql.util.PSQLException: ERROR: column "object_id_identity" is of type bigint but expression is of type character varying
The problem is caused in the createObjectIdentity method by object.getIdentifier().toString() because the parameter is a string or the column is a bigint in the database. 
To solve the problem, you must cast to long : 
protected void createObjectIdentity(ObjectIdentity object, Sid owner) {
  Long sidId = createOrRetrieveSidPrimaryKey(owner, true);
  Long classId = createOrRetrieveClassPrimaryKey(object.getJavaType(), true);
  jdbcTemplate.update(insertObjectIdentity,
      new Object[] 
{classId, new Long(object.getIdentifier().toString()), sidId, new Boolean(true)}
);
}
There is a thread in the forum about this problem : http://forum.springframework.org/showthread.php?t=56889
Thomas</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.security.acls.jdbc.AclPermissionInheritanceTests.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclServiceTests.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclService.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1199</link>
		</links>
	</bug>
	<bug id="1154" opendate="2009-05-05 20:21:49" fixdate="2009-05-06 20:03:00" resolution="Duplicate">
		<buginformation>
			<summary>LdapAuthenticationProvider.createSuccessfulAuthentication() returned object should include authentication.getDetails() if using useAuthenticationRequestCredentials</summary>
			<description>the createSuccessfulAuthentication(UsernamePasswordAuthenticationToken auth, UserDetails user) method from LdapAuthenticationProvider returns a new UsernamePasswordAuthenticationToken based on auth&amp;amp;apos;s password, depending on useAuthenticationRequestCredentials boolean.
In the case this happens, shouldn&amp;amp;apos;t the returned object also include auth.getDetails()? I.e., something like:
protected Authentication createSuccessfulAuthentication(UsernamePasswordAuthenticationToken authentication, UserDetails user)
{
  Object password = useAuthenticationRequestCredentials ? authentication.getCredentials() : ((Object) (user.getPassword()));
  if (useAuthenticationRequestCredentials)
  {
      UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(user, password, user.getAuthorities());
      token.setDetails(authentication.getDetails());
      return token;
  }
  return new UsernamePasswordAuthenticationToken(user, password, user.getAuthorities());
}
(as part of our current project, we are building a custom authenticationProvider which extends LdapAuthenticationProvider, and we expected this behaviour. Not very sure this should be marked as bug or as an improvement, though)</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.LdapAuthenticationProvider.java</file>
			<file type="M">org.springframework.security.ldap.authentication.LdapAuthenticationProviderTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1084</link>
		</links>
	</bug>
	<bug id="1151" opendate="2009-05-04 01:35:05" fixdate="2009-05-07 14:19:24" resolution="Fixed">
		<buginformation>
			<summary>Check on acl bounds not correct</summary>
			<description>On line 130 of AclImpl.java in trunk (line number is different in other releases) a check is performed on the upper bound of the list of access control entries.
Code is:
        if (aceIndex &amp;gt; this.aces.size()) {
should be:
        if (aceIndex &amp;gt;= this.aces.size()) {
Result is that exception out of underlying list impl is thrown.  Minor.</description>
			<version>2.0.5</version>
			<fixedVersion>3.0.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.domain.AclImpl.java</file>
			<file type="M">org.springframework.security.acls.domain.AclImplTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1300</link>
		</links>
	</bug>
	<bug id="1156" opendate="2009-05-08 22:27:29" fixdate="2009-06-14 09:33:06" resolution="Fixed">
		<buginformation>
			<summary>JdbcUserDetailsManager ignores setEnableAuthorities(false)</summary>
			<description>The methods createUser and updateUser access the authorities table, even when configured not to on the super class using setEnableAuthorities.</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.provisioning.JdbcUserDetailsManager.java</file>
			<file type="M">org.springframework.security.provisioning.JdbcUserDetailsManagerTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1187" opendate="2009-06-18 22:08:37" fixdate="2009-07-07 04:10:08" resolution="Fixed">
		<buginformation>
			<summary>AbstractUserDetailsAuthenticationProvider allows login of disabled, locked or expired users</summary>
			<description>If I look into AbstractUserDetailsAuthenticationProvider, I see the followng code:
  try 
{
                user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);
            }
 catch (UsernameNotFoundException notFound) {
                if (hideUserNotFoundExceptions) 
{
                    throw new BadCredentialsException(messages.getMessage(
                            "AbstractUserDetailsAuthenticationProvider.badCredentials", "Bad credentials"));
                }
 else 
{
                    throw notFound;
                }
            }
            Assert.notNull(user, "retrieveUser returned null - a violation of the interface contract");
        }
        preAuthenticationChecks.check(user);
        try 
{
            additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);
        }
 catch (AuthenticationException exception) {
            if (cacheWasUsed) 
{
                // There was a problem, so try again after checking
                // we&amp;amp;apos;re using latest data (ie not from the cache)
                cacheWasUsed = false;
                user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication);
### HERE ###
                additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken) authentication);
            }
 else 
{
                throw exception;
            }
        }
Isn&amp;amp;apos;t it necessary to execute the preAuthenticationChecks at ### HERE ### again?
I don&amp;amp;apos;t want that disabled, locked or expired users are able to log in. </description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider.java</file>
		</fixedFiles>
	</bug>
	<bug id="1145" opendate="2009-04-30 07:06:10" fixdate="2009-07-13 22:16:58" resolution="Fixed">
		<buginformation>
			<summary>When connecting to ldap for authentication user can login using old and new password</summary>
			<description>Login to application
Change windows password
Logout of application
Login to application using old password
This succeeds when it should not.
Login to application using new password. This succeeds and it should.
Reboot application, old password still works and still shouldn&amp;amp;apos;t.
Reboot machine, old password still works and still shouldn&amp;amp;apos;t.
Config:
&amp;lt;bean id="contextSource" class="org.springframework.security.ldap.DefaultSpringSecurityContextSource"&amp;gt;
		&amp;lt;constructor-arg value="$
{ldap.url}
"/&amp;gt;
		&amp;lt;property name="userDn" value="CN=svc-ldap-deliveries,OU=Service Accounts,DC=MYDC,DC=com"/&amp;gt; 
		&amp;lt;property name="password" value="pwd"/&amp;gt; 
		&amp;lt;property name="referral" value="follow" /&amp;gt;
	&amp;lt;/bean&amp;gt; 
	&amp;lt;bean id="secondLdapProvider"
		  class="org.springframework.security.providers.ldap.LdapAuthenticationProvider"&amp;gt;
		&amp;lt;security:custom-authentication-provider /&amp;gt; 
		&amp;lt;constructor-arg&amp;gt; 
			&amp;lt;bean class="org.springframework.security.providers.ldap.authenticator.BindAuthenticator"&amp;gt;
				&amp;lt;constructor-arg ref="contextSource"/&amp;gt; 
				&amp;lt;property name="userSearch"&amp;gt;
					&amp;lt;bean id="userSearch" class="org.springframework.security.ldap.search.FilterBasedLdapUserSearch"&amp;gt;
						&amp;lt;constructor-arg index="0" value=""/&amp;gt; 
						&amp;lt;constructor-arg index="1" value="sAMAccountName=
{0}"/&amp;gt; 
						&amp;lt;constructor-arg index="2" ref="contextSource" /&amp;gt; 
					&amp;lt;/bean&amp;gt; 
				&amp;lt;/property&amp;gt; 
			&amp;lt;/bean&amp;gt; 
		&amp;lt;/constructor-arg&amp;gt;

	 	&amp;lt;constructor-arg&amp;gt; 		
			&amp;lt;bean class="org.springframework.security.ldap.populator.DefaultLdapAuthoritiesPopulator"&amp;gt;

				&amp;lt;constructor-arg ref="contextSource" /&amp;gt; 
				&amp;lt;constructor-arg value="OU=DLS File Permissions" /&amp;gt;
				&amp;lt;property name="rolePrefix" value="ROLE_"/&amp;gt; 			
				&amp;lt;property name="convertToUpperCase" value="false"/&amp;gt; 					
				&amp;lt;property name="groupRoleAttribute" value="cn"&amp;gt;&amp;lt;/property&amp;gt;			
				&amp;lt;property name="groupSearchFilter" value="(member={0}
)"/&amp;gt;
				&amp;lt;property name="searchSubtree" value="true"&amp;gt;&amp;lt;/property&amp;gt;
			&amp;lt;/bean&amp;gt; 
		&amp;lt;/constructor-arg&amp;gt;
	&amp;lt;/bean&amp;gt;
Spring core 2.0.4 and spring ldap 1.3.0</description>
			<version>2.0.4</version>
			<fixedVersion>2.0.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.DefaultSpringSecurityContextSourceTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1077" opendate="2009-01-08 08:25:42" fixdate="2009-07-28 11:48:49" resolution="Fixed">
		<buginformation>
			<summary>AuthenticationProcessingFilter doesn&amp;apos;t redirect to target url in case of session-fixation "newSession".</summary>
			<description>When session-fixation-protection="newSession" is used then AbstractProcessingFilter processing filter doesn&amp;amp;apos;t redirect to target url. It is because of saved request clearing in session (2.0.4, trunk).</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.0 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.session.DefaultAuthenticatedSessionStrategy.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.web.session.DefaultAuthenticatedSessionStrategyTests.java</file>
		</fixedFiles>
		<links>
			<link type="Supersede" description="is superseded by">1211</link>
		</links>
	</bug>
	<bug id="1223" opendate="2009-08-19 08:28:52" fixdate="2009-08-19 08:34:50" resolution="Fixed">
		<buginformation>
			<summary>BindAuthenticator should use first successful return from bindWithDn</summary>
			<description>Regression issue. Loop should end when first non-null user is returned.</description>
			<version>3.0.0 M1</version>
			<fixedVersion>3.0.0 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.BindAuthenticator.java</file>
		</fixedFiles>
	</bug>
	<bug id="1199" opendate="2009-07-16 20:17:11" fixdate="2009-08-23 00:12:54" resolution="Duplicate">
		<buginformation>
			<summary>JdbcMutableAclService can&amp;apos;t create acl_object_identity entry in PostgreSQL</summary>
			<description>The JdbcMutableAclService fails to create acl_object_identity entry in Postgresql, because it passes string as the object_id_identity where an integer (long) type is expected (in method JdbcMutableAclService.createObjectIdentity() ). 
The result is:
org.springframework.jdbc.BadSqlGrammarException: PreparedStatementCallback; bad SQL grammar [insert into acl_object_identity (object_id_class, object_id_identity, owner_sid, entries_inheriting) values (?, ?, ?, ?)]; nested exception is org.postgresql.util.PSQLException: ERROR: column "object_id_identity" is of type bigint but expression is of type character varying
  Hint: You will need to rewrite or cast the expression.
  Position: 51
	at org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.translate(SQLErrorCodeSQLExceptionTranslator.java:276)
	at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:607)
	at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:792)
	at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:850)
	at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:858)
	at org.springframework.security.acls.jdbc.JdbcMutableAclService.createObjectIdentity(JdbcMutableAclService.java:157)
	at org.springframework.security.acls.jdbc.JdbcMutableAclService.createAcl(JdbcMutableAclService.java:108)
</description>
			<version>2.0.5</version>
			<fixedVersion>3.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.security.acls.jdbc.AclPermissionInheritanceTests.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclServiceTests.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclService.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1038</link>
		</links>
	</bug>
	<bug id="1201" opendate="2009-07-17 04:08:21" fixdate="2009-08-23 03:43:16" resolution="Fixed">
		<buginformation>
			<summary>PropertyPlaceholderConfigurer does not work for intercept-url attributes</summary>
			<description>Hello,
I need to define a property placeholder to configure the access for an intercept URL pattern:
&amp;lt;security:http&amp;gt;
  &amp;lt;security:intercept-url pattern="/**" access="ROLE_$
{access.role}
" /&amp;gt;
&amp;lt;/security:http&amp;gt;
As the HttpSecurityBeanDefinitionParser doesn&amp;amp;apos;t create BeanDefinitions for any the properties (and sub-properties) that are passed to the FilterSecurityInterceptor, the PropertyPlaceholderConfigurer can&amp;amp;apos;t substitute them. This issue looks very equal to SEC-975, but I guess it&amp;amp;apos;s a little harder to solve as the pattern-access map resides deeper in the object hierarchy.
Kind regards
Marc</description>
			<version>3.0.0 M2</version>
			<fixedVersion>3.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.access.channel.ChannelProcessingFilter.java</file>
			<file type="M">org.springframework.security.config.http.WebConfigUtils.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.access.SecurityConfig.java</file>
			<file type="M">org.springframework.security.config.http.FilterInvocationSecurityMetadataSourceBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.http.FilterSecurityMetadataSourceBeanDefinitionParserTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1224" opendate="2009-08-19 13:20:19" fixdate="2009-08-29 09:35:58" resolution="Duplicate">
		<buginformation>
			<summary>BasicLookupStrategy, JdbcAclService, and JdbcMutableAclService should support Catalog and Schema</summary>
			<description>Some systems may have security objects and normal application objects seperated in to different domains, and those domains may be defined in different database catalogs and/or schemas.
The BasicLookupStrategy, JdbcAclService, and JdbcMutableAclService classes should account for a database catalog and schema.  A developer and/or integrator should be able to specify the catalog and schema for said classes when defining the beans in their context configurations.</description>
			<version>2.0.0</version>
			<fixedVersion>3.0.0 RC1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategy.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">925</link>
		</links>
	</bug>
	<bug id="951" opendate="2008-08-09 05:58:54" fixdate="2009-08-31 06:19:14" resolution="Fixed">
		<buginformation>
			<summary>Acl Serialization Errors that cohere with parent-child-structure of Acls.</summary>
			<description>I found 2 bugs that cohere with a parent-child-structure of the acls.
1. Bug
the serialization problems occur because the object graph that is passed to the cache contains Objects the are not serializable:
the error log contians the " &amp;amp;apos;org.springframework.security.acls.jdbc.BasicLookupStrategy&amp;amp;apos; not serializable"- exception. so i wondered how this class can be part of the object graph. The answer is: The AclImpl still contains references to the private class StubAclParent that is an inner class of org.springframework.security.acls.jdbc.BasicLookupStrategy. That is the link between the serialization problems and the " &amp;amp;apos;org.springframework.security.acls.jdbc.BasicLookupStrategy&amp;amp;apos; not serializable"- exception.
How can that happen?
It is the job of the convert method to replace the stubaclparents by real acls. But this method does not work properly:
The acl-field of the aces still points to an unreal AclImpl.
to fix this the convert method could be changed like this
    private AclImpl convert(Map inputMap, Long currentIdentity) throws IllegalArgumentException, IllegalAccessException {
        Assert.notEmpty(inputMap, "InputMap required");
        Assert.notNull(currentIdentity, "CurrentIdentity required");
        // Retrieve this Acl from the InputMap
        Acl uncastAcl = (Acl) inputMap.get(currentIdentity);
        Assert.isInstanceOf(AclImpl.class, uncastAcl, "The inputMap contained a non-AclImpl");
        AclImpl inputAcl = (AclImpl) uncastAcl;
        Acl parent = inputAcl.getParentAcl();
        if ((parent != null) &amp;amp;&amp;amp; parent instanceof StubAclParent) 
{
            // Lookup the parent
            StubAclParent stubAclParent = (StubAclParent) parent;
            parent = convert(inputMap, stubAclParent.getId());
        }

        // Now we have the parent (if there is one), create the true AclImpl
        AclImpl result = new AclImpl(inputAcl.getObjectIdentity(), (Long) inputAcl.getId(), aclAuthorizationStrategy,
                auditLogger, parent, null, inputAcl.isEntriesInheriting(), inputAcl.getOwner());
        // Copy the "aces" from the input to the destination
        Field fieldAces = FieldUtils.getField(AclImpl.class, "aces");
        //try {
         fieldAces.setAccessible(true);
            List aces = (List) fieldAces.get(inputAcl);
            List acesN = new Vector();
            Iterator i = aces.iterator();
// replace the old aclImpl (that contains StubAclParents) by the new one.
            while(i.hasNext()) 
{
             AccessControlEntryImpl ace = (AccessControlEntryImpl) i.next();
             Field fieldAcl = FieldUtils.getField(AccessControlEntryImpl.class, "acl");
             fieldAcl.setAccessible(true);
             fieldAcl.set(ace, result);
             acesNew.add(ace);
            }
            fieldAces.set(result, acesNew);
        //} catch (IllegalAccessException ex) 
{
            //throw new IllegalStateException("Could not obtain or set AclImpl.ace field");
        //}

        return result;
    }
2. Bug
EhCacheBasedAclCache does not initialize the transient fields of the parent acls which causes nullpointerexceptions.</description>
			<version>2.0.0 M1</version>
			<fixedVersion>3.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.EhCacheBasedAclCacheTests.java</file>
			<file type="M">org.springframework.security.acls.jdbc.EhCacheBasedAclCache.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategy.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">527</link>
		</links>
	</bug>
	<bug id="1236" opendate="2009-09-04 05:58:44" fixdate="2009-09-05 02:27:31" resolution="Fixed">
		<buginformation>
			<summary>Using HTTP Method-specific intercept-urls causes patterns with no method to be ignored</summary>
			<description>With this configuration the URLs with /user/** pattern does not get intercepted:
&amp;lt;http&amp;gt;
	&amp;lt;http-basic/&amp;gt;
	&amp;lt;intercept-url pattern="/user/**" access="ROLE_USER"/&amp;gt;
	&amp;lt;intercept-url pattern="/teller/**" access="ROLE_TELLER" method="GET"/&amp;gt;
&amp;lt;/http&amp;gt;
this is beacause org.springframework.security.web.access.intercept.DefaultFilterInvocationSecurityMetadataSource never search for null key.
Here is the current code:
 Map&amp;lt;Object, List&amp;lt;ConfigAttribute&amp;gt;&amp;gt; requestMap = httpMethodMap.get(method);
 // If no method-specific map, use the general one stored under the null key
 if (requestMap == null) 
{
   requestMap = httpMethodMap.get(null);
 }

Because "method" is never "null", in the first line the variable "requestMap" will either, so the "if"&amp;amp;apos;s condition is never "true".
Attached is a working version of the class.</description>
			<version>3.0.0 M1</version>
			<fixedVersion>3.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.access.intercept.DefaultFilterInvocationSecurityMetadataSourceTests.java</file>
			<file type="M">org.springframework.security.web.access.intercept.DefaultFilterInvocationSecurityMetadataSource.java</file>
		</fixedFiles>
	</bug>
	<bug id="1241" opendate="2009-09-08 08:50:16" fixdate="2009-09-08 21:21:39" resolution="Fixed">
		<buginformation>
			<summary>SavedRequest not destroyed after successful authentication</summary>
			<description>SUMMARY:
After an anonymous user authenticates in order to access a protected resource, the RequestCacheAwareFilter does not destroy the saved request. 
After successfully replaying the original request for the protected resource, the saved request is no longer valid/useful and should be destroyed.
BACKGROUND:
I have a form handler registered at:
http://foo.com/app/form
A handler is defined with two methods (one for GET and one for POST). The form posts back to the same url as the GET request for the form (a relatively common practice?).
So for example:
GET: /app/form
&amp;lt;form action="/app/form" method="POST"&amp;gt; ... &amp;lt;/form&amp;gt;
The URL "/app/form" is protected by Spring Security and requires "IS_AUTHENTICATED_FULLY".
When an anonymous user  attempts to access the protected resource, they are correctly redirected to the login form. Once authentication is successful, the user is directed back to the protected resource.
Upon submitting the form, though, the POST fails, because the session still contains a cached copy of the original GET request.
Because the session still contains a copy of the original GET request, SavedRequest.doesRequestMatch (line 166) erroneously returns true. However, the requests do NOT match: the current request is a POST, whereas the saved request was a GET.
Additionally, after successfully completing the saved request after authentication, RequestCacheAwareFilter.doFilter (line 36) does not remove the saved request from the cache.
As a result, when the user attempts to POST the form, the result is the user being directed back to the GET view of the form, with no form-processing actions taking place. Debugging confirms that the requests are mapped to the handler&amp;amp;apos;s GET method.
I would consider this a critical if not blocking issue, as it prevents normal form processing to occur after authenticating. 
I am still looking, but I have not yet discovered a way to configure Spring Security to use a custom class in-place-of the RequestCacheAwareFilter - so I cannot easily extend or remove the Filter.
As a work around, I can change the form handler&amp;amp;apos;s POST methods to map to a different URL than the GET method - however, this breaks any RESTful contracts I might have wished to adhere to.
Additionally, I can configure a custom AuthenticationSuccessHandler (namely, using the SimpleUrlAuthenticationSuccessHandler instead of the SavedRequestAwareAuthenticationSuccessHandler). Doing so effectively stops the Security layer from trying to replay the original request, but this has a jarring impact on the user experience in that users always get redirected back to the default URL after authenticating.
CONCLUSION
Any other suggestions are welcome, and I am happy to provide more concrete code examples if necessary...</description>
			<version>3.0.0 M2</version>
			<fixedVersion>3.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.savedrequest.RequestCache.java</file>
			<file type="M">org.springframework.security.web.savedrequest.HttpSessionRequestCache.java</file>
		</fixedFiles>
	</bug>
	<bug id="1240" opendate="2009-09-08 02:44:09" fixdate="2009-09-08 23:13:44" resolution="Fixed">
		<buginformation>
			<summary>{ssha} is specified in the Spring Security password-encoder schema, but isn&amp;apos;t handled by code</summary>
			<description>Pretty minor, but I noticed that the 
{ssha}
 option for LDAP SSHA is an allowable value in the schema for password-encoder&amp;amp;apos;s hash attribute, but it isn&amp;amp;apos;t handled by PasswordEncoderParser.</description>
			<version>3.0.0 M2</version>
			<fixedVersion>3.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.authentication.PasswordEncoderParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="1239" opendate="2009-09-06 22:44:55" fixdate="2009-09-09 05:56:00" resolution="Fixed">
		<buginformation>
			<summary>Special characters in JAAS config file location</summary>
			<description>Given a JaasAuthenticationProvider declared like this:
    &amp;lt;bean id="krb5AuthenticationProvider"
        class="org.springframework.security.providers.jaas.JaasAuthenticationProvider"&amp;gt;
        &amp;lt;property name="loginConfig" value="classpath:/jaas.config"/&amp;gt;
        &amp;lt;property name="loginContextName" value="Krb5LoginModule"/&amp;gt;
        &amp;lt;property name="callbackHandlers"&amp;gt;
            &amp;lt;list&amp;gt;
                &amp;lt;bean class="org.springframework.security.providers.jaas.JaasNameCallbackHandler"/&amp;gt;
                &amp;lt;bean class="org.springframework.security.providers.jaas.PasswordCallbackHandler"/&amp;gt;
            &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
I get the folowing exception:
java.lang.SecurityException: D:\Tomcat%205.5.23\webapps\myapp\WEB-INF\classes\jaas.config (The system cannot find the path specified) 
The problem stems from 

the fact that there is a special character (%20 is "space") in my Tomcat location.
the way Resouce is converted to String in method private void configureJaasUsingLoop():
    String loginConfigUrl = loginConfig.getURL().toString();

</description>
			<version>2.0.5</version>
			<fixedVersion>3.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.authentication.jaas.JaasAuthenticationProvider.java</file>
			<file type="M">org.springframework.security.authentication.jaas.JaasAuthenticationProviderTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1242" opendate="2009-09-11 03:27:19" fixdate="2009-09-13 07:36:31" resolution="Fixed">
		<buginformation>
			<summary>Injecting NullRememberMeService Throws ClassCastException</summary>
			<description>





Caused by: java.lang.ClassCastException: org.springframework.security.web.authentication.NullRememberMeServices cannot be cast to org.springframework.security.web.authentication.rememberme.AbstractRememberMeServices




	at org.springframework.security.config.http.UserDetailsServiceInjectionBeanPostProcessor.postProcessBeforeInitialization(UserDetailsServiceInjectionBeanPostProcessor.java:54)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:393)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1386)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:511)




	... 46 more












	&amp;lt;security:http ...&amp;gt;




                ...




		&amp;lt;security:remember-me services-ref="rememberMeServices" /&amp;gt;




		...




	&amp;lt;/security:http&amp;gt;









	&amp;lt;bean id="rememberMeServices"




		class="org.springframework.security.web.authentication.NullRememberMeServices" /&amp;gt;





</description>
			<version>3.0.0 M2</version>
			<fixedVersion>3.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.UserDetailsServiceInjectionBeanPostProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="525" opendate="2007-08-14 03:41:20" fixdate="2009-09-15 11:28:33" resolution="Fixed">
		<buginformation>
			<summary>[PATCH] Add AccessCheckerTag based on URL resource access permissions.</summary>
			<description>I have developed a tag (AccessCheckerTag) based on URL and not in roles, which reuse objectDefinitionSource (urls + roles) and accessDecisionManager (voters) of the filterInvocationInterceptor bean, inspired in AuthorizeTag and AccessControlListTag.
jsp looks like this:
&amp;lt;authz:accesschecker url="/deletePerson.do"&amp;gt;
    &amp;lt;A HREF="&amp;lt;c:out value="$
{request.contextPath}
" /&amp;gt;/deletePerson.do?id=&amp;lt;c:out value="$
{person.id}
" /&amp;gt;"&amp;gt;Del&amp;lt;/A&amp;gt;
&amp;lt;/authz:accesschecker&amp;gt;
I consider that this tag can be useful for some cases in which before printing the html link or button it is necessary to verify if required access is had to url resource.
see: http://forum.springframework.org/showthread.php?t=42550</description>
			<version>1.0.5</version>
			<fixedVersion>3.0.0 RC1</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.taglibs.authz.AuthorizeTag.java</file>
			<file type="D">org.springframework.security.web.access.WebInvocationPrivilegeEvaluatorTests.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.util.UrlUtils.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AuthorizeTagTests.java</file>
			<file type="M">org.springframework.security.web.access.WebInvocationPrivilegeEvaluator.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1277</link>
		</links>
	</bug>
	<bug id="925" opendate="2008-07-16 05:43:27" fixdate="2009-09-30 05:32:23" resolution="Fixed">
		<buginformation>
			<summary>BasicLookupStrategy - support for schema qualifier</summary>
			<description>The current impl of this class works great - I would like to avoid writing my own custom strategy wherever possible.  The JavaDocs for BasicLookupStrategy state that it&amp;amp;apos;s not design for extension which I understand.
It would be great, however, if a property could be set in the bean config that would allow the referenced tables in the SQL to be qualified by a schema.  Projects often run into such requirements based on the conventions used by a DBA group.  In our particular case, we&amp;amp;apos;re using DB2 and the ACL tables are being created in a schema that is not the default schema.</description>
			<version>2.0.3</version>
			<fixedVersion>3.0.0 RC1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategy.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1224</link>
			<link type="Duplicate" description="is duplicated by">1308</link>
		</links>
	</bug>
	<bug id="1256" opendate="2009-10-05 13:58:16" fixdate="2009-10-06 03:41:48" resolution="Fixed">
		<buginformation>
			<summary>Cannot use bean configuration to configure a FilterSecurityMetadataSource with SpEL expressions due to hard-coded "false" value in code</summary>
			<description>I ran into this as I was trying to configure a Spring Sec stack without the security namespace in place. In 3.0.0M2 there is a hard-coded "false" for useExpressions in the FilterInvocationSecurityMetadataSourceBeanDefinitionParser, at the following line (on or about line 47):
        LinkedHashMap&amp;lt;RequestKey, List&amp;lt;ConfigAttribute&amp;gt;&amp;gt; requestMap =
        HttpSecurityBeanDefinitionParser.parseInterceptUrlsForFilterInvocationRequestMap(interceptUrls,
                convertPathsToLowerCase, false, parserContext);
I believe this code should be augmented to look for the "use-expressions" attribute on the &amp;lt;sec:filter-security-metadata-source&amp;gt; element. The resultant code would look something like the following (note, I haven&amp;amp;apos;t been able to get a compilable version of Spring Sec from source, otherwise I&amp;amp;apos;d supply a patch  ):
        boolean useExpressions = false;
        if(StringUtils.hasLength(element.getAttribute(HttpSecurityBeanDefinitionParser.ATT_USE_EXPRESSIONS))) 
{
        	useExpressions = Boolean.parseBoolean(element.getAttribute(HttpSecurityBeanDefinitionParser.ATT_USE_EXPRESSIONS));
        }
        LinkedHashMap&amp;lt;RequestKey, List&amp;lt;ConfigAttribute&amp;gt;&amp;gt; requestMap =
        HttpSecurityBeanDefinitionParser.parseInterceptUrlsForFilterInvocationRequestMap(interceptUrls,
                convertPathsToLowerCase, useExpressions, parserContext);
Note also that in order to use this code patch you&amp;amp;apos;ll have to expand the visibility of the constant reference ATT_USE_EXPRESSIONS.
Since I can&amp;amp;apos;t verify that SpEL access declarations work with this fix (although they should), I can&amp;amp;apos;t guarantee this is all-inclusive, but hopefully it&amp;amp;apos;ll be close!
Sample bean definition (although you probably don&amp;amp;apos;t need it):
	&amp;lt;bean id="filterSecurityInterceptor" class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor"&amp;gt;
	  &amp;lt;property name="authenticationManager" ref="customAuthenticationManager"/&amp;gt;
	  &amp;lt;property name="accessDecisionManager" ref="affirmativeBased"/&amp;gt;
	  &amp;lt;property name="securityMetadataSource"&amp;gt;
	    &amp;lt;security:filter-security-metadata-source use-expressions="true"&amp;gt;
			&amp;lt;security:intercept-url pattern="/login.do" access="permitAll"/&amp;gt;
			&amp;lt;security:intercept-url pattern="/home.do" access="permitAll"/&amp;gt;
			&amp;lt;security:intercept-url pattern="/account/*.do" access="hasRole(&amp;amp;apos;ROLE_USER&amp;amp;apos;) and fullyAuthenticated"/&amp;gt;
			&amp;lt;security:intercept-url pattern="/*" access="hasRole(&amp;amp;apos;ROLE_USER&amp;amp;apos;)"/&amp;gt;
	    &amp;lt;/security:filter-security-metadata-source&amp;gt;
	  &amp;lt;/property&amp;gt;
	&amp;lt;/bean&amp;gt;
You needn&amp;amp;apos;t worry about analyzing the expressions for correctness - I&amp;amp;apos;ve verified they work already using the standard &amp;lt;http use-expressions="true"&amp;gt; format. Thanks for reviewing the bug!</description>
			<version>3.0.0 M2</version>
			<fixedVersion>3.0.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandler.java</file>
			<file type="M">org.springframework.security.config.http.FilterSecurityMetadataSourceBeanDefinitionParserTests.java</file>
			<file type="D">org.springframework.security.config.http.FilterInvocationSecurityMetadataSourceBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.http.HttpConfigurationBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="547" opendate="2007-09-03 09:28:42" fixdate="2009-10-09 10:30:25" resolution="Fixed">
		<buginformation>
			<summary>acls BasicLookupStrategy user too many (&gt; 1) databasse connections</summary>
			<description>BasicLookupStrategy opens an additional connection to the database for each ACL level of ACL parent that needs to be retrieved from the database.
The error is in the private inner class ProcessResultSet (implements ResultSetExtractor) in the method extractData(ResultSet), at the end of the method
// Lookup parents, adding Acls (with StubAclParents) to "acl" map
if (parentIdsToLookup.size() &amp;gt; 0) {
    lookupPrimaryKeys(acls, parentIdsToLookup, sids);
}
lookupPrimaryKeys(acls, parentIdsToLookup, sids); creates another ProcessResultSet which as per Spring JDBC template classes grabs another connection to the database.  In a round about way this recursively uses one database connection per ACL -&amp;gt; parent ACL relationship to be looked up.
In our case we have some test data where we have an ACL with a hierarchy of 16 parents, so for each level of the hierarchy a new connection to the DB is used  Our test set up had only 10 connections in the pool, which is how we found it.
I&amp;amp;apos;m currently trying to fix this, as it&amp;amp;apos;s causing us problems.  As part of the fix I&amp;amp;apos;m writing some unit tests for BasicLookupStrategy (as there currently are none), not sure if I&amp;amp;apos;ll be able to get DB connection checking usage into the unit tests, but will investigate.
I&amp;amp;apos;ll add my fixes to this Issue when they are ready.
This issue should probably be added to 
http://opensource.atlassian.com/projects/spring/browse/SEC-532</description>
			<version>1.0.3</version>
			<fixedVersion>2.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategy.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="is depended on by">590</link>
			<link type="Depends" description="is depended on by">532</link>
		</links>
	</bug>
	<bug id="1269" opendate="2009-10-13 09:37:01" fixdate="2009-10-13 11:34:07" resolution="Fixed">
		<buginformation>
			<summary>Combining &lt;form-login&gt; and &lt;open-id&gt; fails to find entry point</summary>
			<description></description>
			<version>3.0.0 RC1</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1277" opendate="2009-10-26 14:19:26" fixdate="2009-11-03 02:01:00" resolution="Duplicate">
		<buginformation>
			<summary>The authorization tag libraries are totally wrong!</summary>
			<description>&amp;lt;security:authorize ifAllGranted="ROLE_SUPERVISOR"&amp;gt;
&amp;lt;td&amp;gt;
  &amp;lt;a href="del.htm?id=&amp;lt;c:out value="$
{contact.id}"/&amp;gt;"&amp;gt;Del&amp;lt;/a&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;/security:authorize&amp;gt;

I think it is more reasonable to protect a resource like this
&amp;lt;security:authorize ifAllAuthorised="del.htm"&amp;gt;
&amp;lt;td&amp;gt;
  &amp;lt;a href="del.htm?id=&amp;lt;c:out value="${contact.id}
"/&amp;gt;"&amp;gt;Del&amp;lt;/a&amp;gt;
&amp;lt;/td&amp;gt;
&amp;lt;/security:authorize&amp;gt;
Because the relationship between resources and roles may change in the future,
even more,the role name may change.</description>
			<version>1.0.5</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.taglibs.authz.AuthorizeTag.java</file>
			<file type="D">org.springframework.security.web.access.WebInvocationPrivilegeEvaluatorTests.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.util.UrlUtils.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AuthorizeTagTests.java</file>
			<file type="M">org.springframework.security.web.access.WebInvocationPrivilegeEvaluator.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">525</link>
		</links>
	</bug>
	<bug id="1282" opendate="2009-10-30 16:23:15" fixdate="2009-11-03 02:33:46" resolution="Fixed">
		<buginformation>
			<summary>Possible Bug - UnanimousBased Incorrectly Grants When One Of The Votes Is An Absension</summary>
			<description>Overall Spring Security is AWESOME and you guys are doing a great job!
However, I am convinced I found either a bug or Doc error in UnanimousBased AccessDecisionManager.  
The API doc says "grants access if only grant votes were received" but I am certain I got it to grant access when one of the votes was an Abstention.
Or if this is not a bug, please clarify API to say 
"grants access if only grant or abstained votes were received"
Thanks so much and keep up the great work!!
Spring Security Rocks!</description>
			<version>3.0.0 RC1</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.vote.UnanimousBased.java</file>
		</fixedFiles>
	</bug>
	<bug id="1281" opendate="2009-10-30 03:35:54" fixdate="2009-11-04 00:51:09" resolution="Fixed">
		<buginformation>
			<summary>RememberMeAuthenticationProvider is created with default "key" parameter instead of my own specified</summary>
			<description>I tried to define my own RememberMeService as shown
&amp;lt;security:remember-me 
   services-ref="rememberMeServices" 
   key="$
{app.security.key.rememberMe}"/&amp;gt;

&amp;lt;bean id="rememberMeServices" class="org.springframework.security.web.authentication.rememberme.PersistentTokenBasedRememberMeServices"&amp;gt;
        &amp;lt;property name="key" value="${app.security.key.rememberMe}
"/&amp;gt;
        &amp;lt;property name="cookieName" value="rememberme-ref"/&amp;gt;
        &amp;lt;property name="parameter" value="j_rememberme"/&amp;gt;
        &amp;lt;property name="tokenValiditySeconds" value="1209600"/&amp;gt;
        &amp;lt;property name="tokenRepository" ref="rememberMeDao"/&amp;gt;
        &amp;lt;property name="userDetailsService" ref="userDetailsDao" /&amp;gt;
&amp;lt;/bean&amp;gt;
But RememberMeAuthenticationProvider instance is created with default "SpringSecured" key instead of my own so RememberMeAuthenticationProvider.authenticate never succeeds.
</description>
			<version>3.0.0 RC1</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
			<file type="M">org.springframework.security.config.http.RememberMeBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParserTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1280" opendate="2009-10-27 12:05:44" fixdate="2009-11-04 03:21:08" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException in PersistentTokenBasedRememberMeServices when logging out twice</summary>
			<description>When remember-me is enabled in Spring Security 3.0.0 RC1, a user who attempts to log out when not already logged in will cause a NullPointerException - and probably receive a blank page as a result.
The exception is:
ava.lang.NullPointerException
	at org.springframework.security.web.authentication.rememberme.PersistentTokenBasedRememberMeServices.logout(PersistentTokenBasedRememberMeServices.java:145)
	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:98)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:80)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	at org.springframework.security.web.access.channel.ChannelProcessingFilter.doFilter(ChannelProcessingFilter.java:110)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:150)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:237)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:167)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
[...]
Logout works fine if the user is already logged in, the exception only occurs if the user is not logged in.
Obviously a well-designed web application doesn&amp;amp;apos;t show a logout link when no-one is logged in, which mitigatges the problem. However it does affect users who open multiple windows - and then log out from two or more of them.</description>
			<version>3.0.0 RC1</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.rememberme.PersistentTokenBasedRememberMeServicesTests.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.PersistentTokenBasedRememberMeServices.java</file>
		</fixedFiles>
	</bug>
	<bug id="1283" opendate="2009-11-01 07:25:44" fixdate="2009-11-04 03:40:21" resolution="Fixed">
		<buginformation>
			<summary>AuthenticationConfigBuilder.createAnonymousFilter uses httpElt instead of anonymousElt</summary>
			<description>I think lines 378-383 should refer to anonymousElt, not httpElt. As it stands,  &amp;lt;security:anonymous /&amp;gt; namespace attributes are ignored.
        if (anonymousElt != null) 
{
            grantedAuthority = httpElt.getAttribute("granted-authority");
            username = httpElt.getAttribute("username");
            key = httpElt.getAttribute("key");
            source = pc.extractSource(anonymousElt);
        }</description>
			<version>3.0.0 RC1</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParserTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1289" opendate="2009-11-09 16:58:07" fixdate="2009-11-11 01:28:10" resolution="Duplicate">
		<buginformation>
			<summary>Successful registration event</summary>
			<description>With 3.0M2 and before I used the following code to register successful registrations and save client&amp;amp;apos;s IPs
[code]
public class AuthenticationListener implements ApplicationListener {
    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        if (event instanceof AuthenticationSuccessEvent) 
{
            onAuthenticationSuccessEvent((AuthenticationSuccessEvent) event);
        }
    }
    public void onAuthenticationSuccessEvent(AuthenticationSuccessEvent authenticationSuccessEvent) 
{
        // my code
    }
}
[/code]
With 3.0RC1 there are no AuthenticationSuccessEvent events any more. I&amp;amp;apos;ve found the following comment for org.springframework.security.authentication.DefaultAuthenticationEventPublisher
"The default strategy used by &amp;lt;tt&amp;gt;ProviderManager&amp;lt;/tt&amp;gt; for publishing authentication events."
But when I looked in ProviderManager I&amp;amp;apos;ve found that the default strategy is NullEventPublisher which is created by private field&amp;amp;apos;s initializer.
I thought that it&amp;amp;apos;s possible to inject DefaultAuthenticationEventPublisher with default XML security scheme but I&amp;amp;apos;ve found no entry point to do this.</description>
			<version>3.0.0 RC1</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.authentication.AuthenticationManagerBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.config.authentication.AuthenticationManagerBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.authentication.DefaultAuthenticationEventPublisher.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1272</link>
		</links>
	</bug>
	<bug id="1272" opendate="2009-10-18 16:06:23" fixdate="2009-11-16 23:04:52" resolution="Fixed">
		<buginformation>
			<summary>&lt;authentication-manager&gt; does not register default event handler DefaultAuthenticationEventPublisher</summary>
			<description>When using the namespace configuration, creating an &amp;lt;authentication-manager&amp;gt; should automatically register a default event publisher. This allows applications to be notified about security events such as logins and login failures - for example I want these notifications so that I can write audit logs of failed logins. 
The Javadoc on org.springframework.security.authentication.ProviderManager states that such a default event publisher is automatically registered when using the namespace. It says: 
"The standard implementation is DefaultAuthenticationEventPublisher which maps common exceptions to events (in the case of authentication failure) and publishes an AuthenticationSuccessEvent if authentication succeeds. If you are using the namespace then an instance of this bean will be used automatically by the &amp;lt;http&amp;gt; configuration, so you will receive events from the web part of your application automatically."
However ProviderManager does not actually register a DefaultAuthenticationEventPublisher! It uses its private NullEventPublisher class that does nothing. That means that if you use the namespace configuration you don&amp;amp;apos;t actually receive the default events. The only way to receive those events is to manually create a ProviderManager bean and inject a DefaultAuthenticationEventPublisher bean into it.
I think that:

&amp;lt;authentication-manager&amp;gt; should use DefaultAuthenticationEventPublisher instead of NullEventPublisher
&amp;lt;authentication-manager&amp;gt; should allow the AuthenticationEventPublisher on ProviderManager to be overridden if desired

</description>
			<version>3.0.0 RC1</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.authentication.AuthenticationManagerBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.config.authentication.AuthenticationManagerBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.authentication.DefaultAuthenticationEventPublisher.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1289</link>
		</links>
	</bug>
	<bug id="1287" opendate="2009-11-06 11:58:40" fixdate="2009-11-16 23:14:34" resolution="Fixed">
		<buginformation>
			<summary>Regression with fix SEC-1022 - cannot register custom permissions w/BasicLookupStrategy</summary>
			<description>With the fix for SEC-1002 in 3.0RC1 and the removal of the static methods in BasePermission, unfortunately it is now impossible to use BasicLookupStrategy with custom permissions. This is because the PermissionFactory member of BasicLookupStrategy is private, with no accessor and no setter or constructor injection possible. While this wasn&amp;amp;apos;t available in prior versions of 3.0 either, at least in prior versions you could use the static methods to register permissions.
Can you expose the PermissionFactory member on BasicLookupStrategy, either through an overloaded constructor or setter?</description>
			<version>3.0.0 RC1</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategyTests.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="1286" opendate="2009-11-06 06:15:36" fixdate="2009-11-17 07:45:36" resolution="Fixed">
		<buginformation>
			<summary>toString misformatting for Acl.java</summary>
			<description>Line 348:
sb.append("parent: ").append((this.parentAcl == null) ? "Null" : this.parentAcl.getObjectIdentity().toString());
There should be a space after &amp;amp;apos;Null&amp;amp;apos;, as it stands you get output with "NullaclAuthorizationStrategy".
Example:
AccessControlEntryImpl[id: 3539; granting: true; sid: GrantedAuthoritySid[IS_AUTHENTICATED_ANONYMOUSLY]; permission: BasePermission[...............................R=1]; auditSuccess: false; auditFailure: false]
inheriting: true; parent: NullaclAuthorizationStrategy: org.springframework.security.acls.domain.AclAuthorizationStrategyImpl@1c7e73f; auditLogger: org.springframework.security.acls.domain.ConsoleAuditLogger@11efef0]</description>
			<version>3.0.0 RC1</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.domain.AclImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="1306" opendate="2009-11-23 15:48:19" fixdate="2009-11-24 00:50:32" resolution="Fixed">
		<buginformation>
			<summary>OpenIDAttribute class is not marked as Serializable</summary>
			<description>SEC-935 adds the OpenIDAttribute class. Because the OpenIDAuthenticationToken class (which is Serializable) has a List&amp;lt;OpenIDAttribute&amp;gt;, OpenIDAttribute should be Serializable too.
This interface should be no problem to add to the OpenIDAttribute class, because all its members are primitives or Strings and therefore already Serializable themselves.
P.S. while you&amp;amp;apos;re at it, OpenIDAttribute#toString() should probably be annotated with @Override (and in OpenIDAuthenticationStatus too).</description>
			<version>3.0.0 RC1</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.openid.OpenIDAttribute.java</file>
		</fixedFiles>
	</bug>
	<bug id="1300" opendate="2009-11-19 12:15:41" fixdate="2009-11-29 22:53:47" resolution="Duplicate">
		<buginformation>
			<summary>ArrayIndex out of bounds in AclImpl</summary>
			<description>In AclImpl#verifyAceIndexExists(...)
I think this is an "off by one" bug. I may be wrong but shouldn&amp;amp;apos;t 
this:
        if (aceIndex &amp;gt; this.aces.size()) 
{
        	throw new NotFoundException("aceIndex must correctly refer to an index of the AccessControlEntry collection");
        }

be this:

        if (aceIndex &amp;gt; this.aces.size() - 1) {        	throw new NotFoundException("aceIndex must correctly refer to an index of the AccessControlEntry collection");        }

Since I&amp;amp;apos;m getting the exception but wondered how it passed verifyAceIndexExists?:
eption Handler execution resulted in exception - forwarding to resolved error view
                                 java.lang.IndexOutOfBoundsException: Index: 2, Size: 2
        at java.util.ArrayList.RangeCheck(ArrayList.java:572)
        at java.util.ArrayList.remove(ArrayList.java:415)
        at org.springframework.security.acls.domain.AclImpl.deleteAce(AclImpl.java:131)
        at com.acme.app.springframework.security.AclSecurityServiceImpl.replaceUserPermissions(AclSecurityServiceImpl.jav</description>
			<version>2.0.5</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.domain.AclImpl.java</file>
			<file type="M">org.springframework.security.acls.domain.AclImplTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1151</link>
		</links>
	</bug>
	<bug id="1295" opendate="2009-11-16 11:45:16" fixdate="2009-11-30 08:01:14" resolution="Fixed">
		<buginformation>
			<summary>Placing Security on Roo Aspected methods fails</summary>
			<description>When using @Secured on generated Roo_Entity methods a NPE is thrown due to target and _this information being missing when AspectJ creates the Join Point over an already aspected class. this NPE is thrown in AbstractMethodSecurityMetadataSource.getAttributes as there is a check against the Target to get the class. 
Have found that this information can also be retrieved from the signature.
This is using AspectJSecurityInterceptor configuration as opposed to SpringAOP, which we know doesn&amp;amp;apos;t work with Roo at all - yet   The configuration is based on the aspects sample within Spring Security.
I have changed the following within AbstractMethodSecurityMetadataSource and it seems to work.... 
Class&amp;lt;?&amp;gt; targetClass = jp.getTarget().getClass();
To the following - though it too could just use one line and only call the signature:
            Class&amp;lt;?&amp;gt; targetClass = null;
            if(jp.getTarget() != null)
            {
                targetClass = jp.getTarget().getClass();
            }
            else
            {
                //this class has already been aspected, hence see if we can get the info from the
                //static part
                targetClass = jp.getStaticPart().getSignature().getDeclaringType();
            }
</description>
			<version>3.0.0 RC1</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.method.AbstractMethodSecurityMetadataSource.java</file>
		</fixedFiles>
	</bug>
	<bug id="1308" opendate="2009-11-24 08:14:37" fixdate="2009-11-30 08:11:03" resolution="Duplicate">
		<buginformation>
			<summary>Jdbc[Mutable]AclService  can allow (all) sql statements to be configured</summary>
			<description>I&amp;amp;apos;m providing a candidate patch for consideration. It&amp;amp;apos;s an enhancement to jdbc acl service that allows all sql statement strings to be configured by via spring. Please review and incorporate if desired.
The attached patch contains:
1) Interface for AclSQLSource (not sure if setters should really be part of this or not. I decided to include them.)
2) DefaultAclSQLSource - contains the usual Postgres SQL statements and setters for Spring configuration. Additional constructor takes a map with property and sql map entries.
3) Changes to JdbcAclService and JdbcMutableAclService to read statements from the AclSQLSource.
===
Sample configuration:
	&amp;lt;bean id="sqlSource"
		class="org.springframework.security.acls.jdbc.DefaultAclSQLSource"&amp;gt;
		&amp;lt;constructor-arg&amp;gt;
			&amp;lt;map&amp;gt;
				&amp;lt;entry key="classIdentityQuery" value="SELECT ACL_CLASS_ID_SEQ.CURRVAL FROM DUAL" /&amp;gt;
				&amp;lt;entry key="sidIdentityQuery" value="SELECT ACL_SID_ID_SEQ.CURRVAL FROM DUAL" /&amp;gt;
				&amp;lt;entry key="selectSidPrimaryKey"
					value="select id from acl_sid where principal=DECODE(?,&amp;amp;apos;TRUE&amp;amp;apos;,&amp;amp;apos;1&amp;amp;apos;,&amp;amp;apos;Y&amp;amp;apos;,&amp;amp;apos;1&amp;amp;apos;,&amp;amp;apos;1&amp;amp;apos;,&amp;amp;apos;1&amp;amp;apos;,&amp;amp;apos;FALSE&amp;amp;apos;,&amp;amp;apos;0&amp;amp;apos;,&amp;amp;apos;N&amp;amp;apos;,&amp;amp;apos;0&amp;amp;apos;,&amp;amp;apos;0&amp;amp;apos;,&amp;amp;apos;0&amp;amp;apos;) and sid=?" /&amp;gt;
				&amp;lt;entry key="insertSid"
					value="insert into acl_sid (principal, sid) values (DECODE(?,&amp;amp;apos;TRUE&amp;amp;apos;,&amp;amp;apos;1&amp;amp;apos;,&amp;amp;apos;Y&amp;amp;apos;,&amp;amp;apos;1&amp;amp;apos;,&amp;amp;apos;1&amp;amp;apos;,&amp;amp;apos;1&amp;amp;apos;,&amp;amp;apos;FALSE&amp;amp;apos;,&amp;amp;apos;0&amp;amp;apos;,&amp;amp;apos;N&amp;amp;apos;,&amp;amp;apos;0&amp;amp;apos;,&amp;amp;apos;0&amp;amp;apos;,&amp;amp;apos;0&amp;amp;apos;), ?)" /&amp;gt;
			&amp;lt;/map&amp;gt;
		&amp;lt;/constructor-arg&amp;gt;
	&amp;lt;/bean&amp;gt;
	&amp;lt;bean id="aclService"
		class="org.springframework.security.acls.jdbc.JdbcMutableAclService"&amp;gt;
		&amp;lt;constructor-arg ref="secDataSource" index="0"/&amp;gt;
		&amp;lt;constructor-arg ref="lookupStrategy" index="1"/&amp;gt;
		&amp;lt;constructor-arg ref="aclCache" index="2"/&amp;gt;
		&amp;lt;constructor-arg ref="sqlSource" index="3"/&amp;gt;
	&amp;lt;/bean&amp;gt;
===</description>
			<version>2.0.5</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.jdbc.JdbcAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.JdbcMutableAclService.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategy.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">925</link>
		</links>
	</bug>
	<bug id="1317" opendate="2009-12-07 03:54:15" fixdate="2009-12-08 01:41:26" resolution="Fixed">
		<buginformation>
			<summary>Http configuration with no internal AuthenticationProviders causes Exception</summary>
			<description>The the internal ProviderManager, which is created by the &amp;lt;http&amp;gt; namespace element (SEC-1195), fails if it has no providers. Either a null provider should be added if the provider list is empty or the use of an internal instance should be skipped completely.</description>
			<version>3.0.0 RC1</version>
			<fixedVersion>3.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.authentication.ProviderManager.java</file>
			<file type="M">org.springframework.security.authentication.ProviderManagerTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1320" opendate="2009-12-08 04:11:02" fixdate="2009-12-13 02:20:39" resolution="Fixed">
		<buginformation>
			<summary>JaasAuthenticationProvider can not find jaas realm defined inside service archive</summary>
			<description>Fix for SEC-760 causes another bug. If you deploy JAAS login module (application policy) with application, as a service archive, JaasAuthenticationProvider does not see it because of an config reset, which was a fix in SEC-760.
If line "Configuration.getConfiguration().refresh();" is removed everything works ok.</description>
			<version>2.0.3</version>
			<fixedVersion>3.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.authentication.jaas.JaasAuthenticationProvider.java</file>
		</fixedFiles>
	</bug>
	<bug id="1328" opendate="2009-12-15 04:53:47" fixdate="2009-12-18 04:05:20" resolution="Fixed">
		<buginformation>
			<summary>RedirectUtils/DefaultRedirectStrategy contextRelative redirect doesn&amp;apos;t account for url like http://context.xyz.com/context</summary>
			<description>Unfortunately in our production URL the hostname starts with same string as the context so the code that searches for the context in order to strip off everything before it finds the first occurance and leaves a chunk of URL (since the slash from the protocol helps match the slash in the context).
The current code does this:
            int len = request.getContextPath().length();
            int index = url.indexOf(request.getContextPath()) + len;
            finalUrl = url.substring(index);
I fixed it by doing: 
            url = url.replaceFirst(".*://", ""); // strip off protocol
	    int len = request.getContextPath().length();
	    int index = url.indexOf(request.getContextPath()) + len;
	    finalUrl = url.substring(index);
Since I am using spring-security-2.0.5 the only way I can fix is by copying the class and modifying it in my project to override the one in the jar. I suppose in Spring 3.0 I will be able to create my own RedirectStrategy. I know this probably will only ever impact me but I hope it is worth fixing.
Thanks.</description>
			<version>2.0.5</version>
			<fixedVersion>3.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.DefaultRedirectStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="1333" opendate="2009-12-16 10:48:51" fixdate="2009-12-18 05:30:20" resolution="Fixed">
		<buginformation>
			<summary>Invalid &amp;apos;authentication-failure-url&amp;apos; attribute results in assertion failure</summary>
			<description>If I set the &amp;amp;apos;authentication-failure-url&amp;amp;apos; attribute of a &amp;lt;openid-login&amp;gt; or &amp;lt;form-login&amp;gt; element to something like "XXX/secure/login.html".  I get a bean wiring failure whose message says "java.lang.IllegalArgumentException: [Assertion failed] - this expression must be true".
Stacktrace attached.</description>
			<version>3.0.0.RC2</version>
			<fixedVersion>3.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1342" opendate="2009-12-22 22:13:05" fixdate="2009-12-23 00:56:51" resolution="Fixed">
		<buginformation>
			<summary>intercept-url EL expressions are parsed or validated incorrectly</summary>
			<description>	&amp;lt;security:http use-expressions="true"&amp;gt;
		&amp;lt;security:access-denied-handler error-page="/authfail.html" /&amp;gt;
		&amp;lt;!-- XXX requires-channel="https" --&amp;gt;
		&amp;lt;security:intercept-url pattern="/app/**" access="hasAnyRole(&amp;amp;apos;ROLE_A&amp;amp;apos;,&amp;amp;apos;ROLE_B&amp;amp;apos;,&amp;amp;apos;ROLE_C&amp;amp;apos;,&amp;amp;apos;ROLE_D&amp;amp;apos;)" /&amp;gt;
		&amp;lt;security:intercept-url pattern="/css/**" access="isAuthenticated()" /&amp;gt;
		&amp;lt;security:intercept-url pattern="/images/logo.png" access="permitAll" /&amp;gt;
		&amp;lt;security:intercept-url pattern="/images/**" access="isAuthenticated()" /&amp;gt;
		&amp;lt;security:intercept-url pattern="/xmlhttp/**" access="isAuthenticated()" /&amp;gt;
		&amp;lt;security:intercept-url pattern="/authfail.html" access="permitAll" /&amp;gt;
		&amp;lt;security:intercept-url pattern="/login.jsp" access="permitAll" /&amp;gt;
		&amp;lt;security:intercept-url pattern="/**" access="denyAll" /&amp;gt;
		&amp;lt;security:form-login always-use-default-target="true" default-target-url="/app/index.jspx" login-page="/" /&amp;gt;
		&amp;lt;security:logout invalidate-session="true" logout-success-url="/" /&amp;gt;
		&amp;lt;security:anonymous /&amp;gt;
		&amp;lt;security:session-management&amp;gt;
			&amp;lt;security:concurrency-control max-sessions="1" /&amp;gt;
		&amp;lt;/security:session-management&amp;gt;
	&amp;lt;/security:http&amp;gt;
When the context loads, this happens:
Caused by: java.lang.IllegalArgumentException: Expected a single expression attribute for [&amp;lt;url&amp;gt;]
	at org.springframework.util.Assert.isTrue(Assert.java:65)
	at org.springframework.security.web.access.expression.ExpressionBasedFilterInvocationSecurityMetadataSource.processMap(ExpressionBasedFilterInvocationSecurityMetadataSource.java:43)
	at org.springframework.security.web.access.expression.ExpressionBasedFilterInvocationSecurityMetadataSource.&amp;lt;init&amp;gt;(ExpressionBasedFilterInvocationSecurityMetadataSource.java:30)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
	at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:126)
	... 37 more
That bit of code in o.s.s.web.access.expression.ExpressionBasedFilterInvocationSecurityMetadataSource looks like this:
    public ExpressionBasedFilterInvocationSecurityMetadataSource(UrlMatcher urlMatcher,
            LinkedHashMap&amp;lt;RequestKey, Collection&amp;lt;ConfigAttribute&amp;gt;&amp;gt; requestMap, WebSecurityExpressionHandler expressionHandler) 
{
        super(urlMatcher, processMap(requestMap, expressionHandler.getExpressionParser()));
        Assert.notNull(expressionHandler, "A non-null SecurityExpressionHandler is required");
    }

    private static LinkedHashMap&amp;lt;RequestKey, Collection&amp;lt;ConfigAttribute&amp;gt;&amp;gt; processMap(
            LinkedHashMap&amp;lt;RequestKey,Collection&amp;lt;ConfigAttribute&amp;gt;&amp;gt; requestMap, ExpressionParser parser) {
[...]
        for (Map.Entry&amp;lt;RequestKey, Collection&amp;lt;ConfigAttribute&amp;gt;&amp;gt; entry : requestMap.entrySet()) {
            RequestKey request = entry.getKey();
            Assert.isTrue(entry.getValue().size() == 1, "Expected a single expression attribute for " + request);
The Assert is line 43, where the failure happens. In the debugger, entry.getValue() has 4 entries. It is basically the expression hasAnyRole(&amp;amp;apos;ROLE_A&amp;amp;apos;,&amp;amp;apos;ROLE_B&amp;amp;apos;,&amp;amp;apos;ROLE_C&amp;amp;apos;,&amp;amp;apos;ROLE_D&amp;amp;apos;) tokenized on the commas.</description>
			<version>3.0.0.RC2</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.FilterInvocationSecurityMetadataSourceParser.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.access.SecurityConfig.java</file>
		</fixedFiles>
	</bug>
	<bug id="1346" opendate="2009-12-29 12:17:09" fixdate="2010-01-04 05:08:22" resolution="Fixed">
		<buginformation>
			<summary>SessionManagementFilter: should "return;" after "redirectStrategy.sendRedirect(request, response, invalidSessionUrl);"</summary>
			<description>java.lang.IllegalStateException: Cannot create a session after the response has been committed
	org.apache.catalina.connector.Request.doGetSession(Request.java:2313)
	org.apache.catalina.connector.Request.getSession(Request.java:2074)
	org.apache.catalina.connector.RequestFacade.getSession(RequestFacade.java:833)
	org.apache.catalina.connector.RequestFacade.getSession(RequestFacade.java:844)
	javax.servlet.http.HttpServletRequestWrapper.getSession(HttpServletRequestWrapper.java:224)
	org.springframework.security.web.savedrequest.HttpSessionRequestCache.saveRequest(HttpSessionRequestCache.java:38)
	org.springframework.security.web.access.ExceptionTranslationFilter.sendStartAuthentication(ExceptionTranslationFilter.java:177)
	org.springframework.security.web.access.ExceptionTranslationFilter.handleException(ExceptionTranslationFilter.java:158)
	org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118)
	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:95)
	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:79)
	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:55)
	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:36)
	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:188)
	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:106)
	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:80)
	org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:356)
	org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:150)
	org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:237)
	org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:167)</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.concurrent.ConcurrentSessionFilterTests.java</file>
			<file type="M">org.springframework.security.web.session.SessionManagementFilter.java</file>
			<file type="M">org.springframework.security.web.util.UrlUtils.java</file>
			<file type="M">org.springframework.security.web.session.SessionManagementFilterTests.java</file>
			<file type="M">org.springframework.security.web.session.ConcurrentSessionFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1353</link>
		</links>
	</bug>
	<bug id="1353" opendate="2010-01-06 06:10:35" fixdate="2010-01-06 07:26:21" resolution="Duplicate">
		<buginformation>
			<summary>SessionManagementFilter can invoke other filters after sending redirect</summary>
			<description>SessionManagementFilter::doFilter() fails to stop request processing in branch "No security context or authentication present" (at SessionManagementFilter.java:89). More precisely, it does not return after calling redirectStrategy.sendRedirect(), but passes to the next filter.
This causes an error if there are controllers that define methods taking a HttpSession argument, because in this case AnnotationMethodHandlerAdapter attempts to call request.getSession(), which is not permitted after a redirect had been sent.</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.concurrent.ConcurrentSessionFilterTests.java</file>
			<file type="M">org.springframework.security.web.session.SessionManagementFilter.java</file>
			<file type="M">org.springframework.security.web.util.UrlUtils.java</file>
			<file type="M">org.springframework.security.web.session.SessionManagementFilterTests.java</file>
			<file type="M">org.springframework.security.web.session.ConcurrentSessionFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1346</link>
		</links>
	</bug>
	<bug id="1357" opendate="2010-01-08 04:53:02" fixdate="2010-01-08 11:17:03" resolution="Fixed">
		<buginformation>
			<summary>Use reader context classloader when checking for web classes in namespace handler</summary>
			<description>Following discussion with Christian. In some situations (e.g. tooling), ClassUtils.getDefaultClassLoader() will fail to locate the web classes.  parserContext.getReaderContext().getBeanClassLoader() should be used instead.</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1358" opendate="2010-01-11 10:15:34" fixdate="2010-01-11 10:57:22" resolution="Fixed">
		<buginformation>
			<summary>DefaultWebInvocationPrivilegeEvaluator fails with empty context path</summary>
			<description>There is currently an assertion which checks that the context path has a length &amp;gt; 0, when in fact this is unnecessary.</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.access.DefaultWebInvocationPrivilegeEvaluator.java</file>
		</fixedFiles>
	</bug>
	<bug id="1359" opendate="2010-01-12 15:37:02" fixdate="2010-01-13 01:25:08" resolution="Fixed">
		<buginformation>
			<summary>Typo in the Reference doc appendix B</summary>
			<description>http://static.springsource.org/spring-security/site/docs/3.0.x/reference/appendix-namespace.html
In B.1.1 &amp;gt; realm
proerty should read property </description>
			<version>3.0.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.java</file>
			<file type="M">org.springframework.security.web.authentication.AbstractAuthenticationTargetUrlRequestHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1364" opendate="2010-01-12 18:38:43" fixdate="2010-01-13 01:44:03" resolution="Fixed">
		<buginformation>
			<summary>Missing markup in the reference documentation section 8.4</summary>
			<description>http://static.springsource.org/spring-security/site/docs/3.0.x/reference/core-web-filters.html#form-login-filter
In the first paragraph:
&amp;lt;form-login&amp;gt;
should be wrapped within &amp;lt;tt&amp;gt;&amp;lt;/tt&amp;gt; to appear in monospace font</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.java</file>
			<file type="M">org.springframework.security.web.authentication.AbstractAuthenticationTargetUrlRequestHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1367" opendate="2010-01-12 18:49:31" fixdate="2010-01-13 01:44:03" resolution="Fixed">
		<buginformation>
			<summary>Type in the Reference documentation in section 19.2</summary>
			<description>http://static.springsource.org/spring-security/site/docs/3.0.x/reference/taglibs.html#d4e2693
In the 1st paragraph:
"WebSecurityExpressionHandlder"
should read
"WebSecurityExpressionHandler"</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.java</file>
			<file type="M">org.springframework.security.web.authentication.AbstractAuthenticationTargetUrlRequestHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1361" opendate="2010-01-12 17:19:21" fixdate="2010-01-13 01:44:03" resolution="Fixed">
		<buginformation>
			<summary>Bad markup in Javadoc for UsernamePasswordAuthenticationFilter</summary>
			<description>In the class description of clasa
org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter
at
http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/web/authentication/UsernamePasswordAuthenticationFilter.html
The first &amp;lt;tt&amp;gt; tag is not well-balanced and the rest of the text shows up in monospace font.
"&amp;lt;tt&amp;gt;AuthenticationProcessingFilter&amp;lt;tt&amp;gt;"
should be
"&amp;lt;tt&amp;gt;AuthenticationProcessingFilter&amp;lt;/tt&amp;gt;"</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.java</file>
			<file type="M">org.springframework.security.web.authentication.AbstractAuthenticationTargetUrlRequestHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1366" opendate="2010-01-12 18:46:15" fixdate="2010-01-13 01:44:03" resolution="Fixed">
		<buginformation>
			<summary>Typo in the reference documentation section 8.4.1</summary>
			<description>http://static.springsource.org/spring-security/site/docs/3.0.x/reference/core-web-filters.html#form-login-flow-handling
In the 2nd paragraph:
"approprate"
should read
"appropriate"</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.java</file>
			<file type="M">org.springframework.security.web.authentication.AbstractAuthenticationTargetUrlRequestHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1365" opendate="2010-01-12 18:44:49" fixdate="2010-01-13 01:44:03" resolution="Fixed">
		<buginformation>
			<summary>Missing markup in the reference documentation section 8.4.1</summary>
			<description>http://static.springsource.org/spring-security/site/docs/3.0.x/reference/core-web-filters.html#form-login-flow-handling
In the 2nd paragraph:
AuthenticationSuccessHandler should be wrapped within &amp;lt;tt&amp;gt;&amp;lt;/tt&amp;gt; tags</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.java</file>
			<file type="M">org.springframework.security.web.authentication.AbstractAuthenticationTargetUrlRequestHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1360" opendate="2010-01-12 17:15:44" fixdate="2010-01-13 01:44:03" resolution="Fixed">
		<buginformation>
			<summary>Typo in the Javadoc for class AbstractAuthenticationTargetUrlRequestHandler</summary>
			<description>In the JavaDoc for class
org.springframework.security.web.authentication.AbstractAuthenticationTargetUrlRequestHandler
at
http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/web/authentication/AbstractAuthenticationTargetUrlRequestHandler.html#setTargetUrlParameter(java.lang.String)
"...as the target URL if resent."
should read
"...as the target URL if present."</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.java</file>
			<file type="M">org.springframework.security.web.authentication.AbstractAuthenticationTargetUrlRequestHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1363" opendate="2010-01-12 18:32:35" fixdate="2010-01-13 01:44:03" resolution="Fixed">
		<buginformation>
			<summary>Type in the Reference documentation in section 6.1</summary>
			<description>http://static.springsource.org/spring-security/site/docs/3.0.x/reference/core-services.html
In the 3rd paragraph:
"ProviderMananger"
should read
"ProviderManager"</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.java</file>
			<file type="M">org.springframework.security.web.authentication.AbstractAuthenticationTargetUrlRequestHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1369" opendate="2010-01-14 00:15:54" fixdate="2010-01-14 03:26:53" resolution="Fixed">
		<buginformation>
			<summary>Springbeans gets registered twice</summary>
			<description>When Spring&amp;amp;apos;s beans-overriding property is set to false (bean overriding is forbidden), errors regarding duplicated beans are thrown (from Spring).
After some debugging, I found the source of this problem in the following (and similar) lines inside the spring-security-config module.
String id = pc.getReaderContext().registerWithGeneratedName(provider);
pc.registerBeanComponent(new BeanComponentDefinition(provider, id));
The problem is, that within the method registerWithGeneratedName, the method registerBeanDefinition is called (as the name says). This is also done when calling registerBeanComponent afterwards. 
In my opinion, the solution is to replace the codelines above with:
String id = pc.getReaderContext().generateBeanName(provider);
pc.registerBeanComponent(new BeanComponentDefinition(provider, id));
The problematic code fragment can be found in different classes of the module multiple times. 
Replacing all occurrences solved the problem on our test cases. Also, all the tests of the whole Spring Security framework were passed successfully.
I attach a patch which includes the modification that i have done. 
This was created from / for the 3.0.0.RELEASE tag.
I hope, this can be helpful and will be integrated into the next release. 
Cheers
Jonas</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.authentication.AbstractUserDetailsServiceBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.method.GlobalMethodSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.http.RememberMeBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.util.InMemoryXmlApplicationContext.java</file>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
			<file type="M">org.springframework.security.config.http.HttpConfigurationBuilder.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.authentication.AuthenticationManagerBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.http.FilterInvocationSecurityMetadataSourceParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="1372" opendate="2010-01-18 03:30:48" fixdate="2010-01-18 11:09:48" resolution="Fixed">
		<buginformation>
			<summary>SessionRegistryImpl.getAllSessions returns null, Interface says it shouldn&amp;apos;t</summary>
			<description>The documentation for org.springframework.security.core.session.SessionRegistry#getAllSessions(Object, boolean) says "Returns: the matching sessions for this principal (should not return null)." However, the default implementation org.springframework.security.core.session.SessionRegistryImpl#getAllSessions(Object, boolean) returns null if "final Set&amp;lt;String&amp;gt; sessionsUsedByPrincipal = principals.get(principal)" is null.
It should, instead, return an empty list, per the interface specification and per good code practices such that methods that return lists should never return null, only empty lists when needed.</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.session.ConcurrentSessionControlStrategy.java</file>
			<file type="M">org.springframework.security.core.session.SessionRegistryImplTests.java</file>
			<file type="M">org.springframework.security.core.session.SessionRegistryImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="1380" opendate="2010-01-22 08:45:04" fixdate="2010-01-22 09:05:49" resolution="Fixed">
		<buginformation>
			<summary>"access" attribute in "intercept-url" should trim whitespace from attributes</summary>
			<description>Currently "ROLE_A, ROLE_B" will map to two attributes, the second being " ROLE_B". Whitespace should be trimmed.</description>
			<version>3.0.1</version>
			<fixedVersion>3.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.access.SecurityConfig.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1395</link>
		</links>
	</bug>
	<bug id="1388" opendate="2010-01-26 06:16:44" fixdate="2010-01-26 06:20:50" resolution="Duplicate">
		<buginformation>
			<summary>Support for custom AuthenticationDetailsSource in form-login tag.</summary>
			<description>When using the &amp;lt;form-login /&amp;gt; tag, theres no way to configure a custom AuthenticationDetailsSource.
The workaround is to reconfigure UsernamePasswordAuthenticationFilter as a custom filter and reconfigure LoginUrlAuthenticationEntryPoint with its loginFormUrl property. Spring XML becomes more polluted and some minor functionality like the &amp;lt;http&amp;gt; auto-config and the built-in form login page are lost.</description>
			<version>3.0.1</version>
			<fixedVersion></fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
			<file type="M">org.springframework.security.config.http.FormLoginBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1133</link>
		</links>
	</bug>
	<bug id="1395" opendate="2010-02-01 09:39:54" fixdate="2010-02-02 02:33:51" resolution="Duplicate">
		<buginformation>
			<summary>intercept-url access attribute should support spaces when specifying a list of authorized roles</summary>
			<description>The "extra" space in access definition is not supported, it should be allowed.
If this is the desired behavior, the xsd should be updated to reflect the constraint.













&amp;lt;security:intercept-url pattern="/app/*.action" access="ROLE_ANONYMOUS, ROLE_USER" /&amp;gt;













it produces






2010-02-02 00:17:40.500:WARN::Nested in org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;org.springframework.security.web.access.intercept.FilterSecurityInterceptor#0&amp;amp;apos;: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Unsupported configuration attributes: [ ROLE_USER]: java.lang.IllegalArgumentException: Unsupported configuration attributes: [ ROLE_USER]




        at org.springframework.security.access.intercept.AbstractSecurityInterceptor.afterPropertiesSet(AbstractSecurityInterceptor.java:153)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1460)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1398)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:512)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:450)




        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:290)




        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)




        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:287)




        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:189)




        at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:557)




        at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:842)




        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:416)





</description>
			<version>3.0.1</version>
			<fixedVersion>3.0.2</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.access.SecurityConfig.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1380</link>
		</links>
	</bug>
	<bug id="1392" opendate="2010-01-28 07:22:14" fixdate="2010-02-06 01:42:23" resolution="Fixed">
		<buginformation>
			<summary>Cannot use custom PermissionEvaluator</summary>
			<description>I created a PermissionEvaluator to use with the new security expressions. I wrote a unit test and I&amp;amp;apos;m trying to test it. If I use the default configuration, it works and denies the access to the secured method, since it is the default behavior, this is the configuration (I&amp;amp;apos;m omitting the authenticationmanager part) :
&amp;lt;sec:global-method-security pre-post-annotations="enabled"&amp;gt;
But if I change the configuration in order to add my PermissionEvaluator, I get a NullPointerException while Spring initializes, this is my new config:
    &amp;lt;sec:global-method-security pre-post-annotations="enabled"&amp;gt;
        &amp;lt;sec:expression-handler ref="expressionHandler"/&amp;gt;
    &amp;lt;/sec:global-method-security&amp;gt;
    &amp;lt;bean id="expressionHandler" class="org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler"&amp;gt;
        &amp;lt;property name="permissionEvaluator" ref="myPermissionEvaluator"/&amp;gt;
    &amp;lt;/bean&amp;gt;
Attached you&amp;amp;apos;ll see the stack-trace.
thanks</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.PermissionEvaluator.java</file>
			<file type="M">org.springframework.security.config.method.GlobalMethodSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.access.expression.method.MethodSecurityExpressionHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1390" opendate="2010-01-26 07:46:56" fixdate="2010-02-06 02:10:05" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException in OpenID4JavaConsumer.endConsumption</summary>
			<description>
Log+Exception
=====
INFO  YadisResolver                  - Yadis discovered 0 endpoints from: http://&amp;lt;domain&amp;gt;/openid?id=11001259674714705...
INFO  Discovery                      - No OpenID service endpoints discovered through Yadis; attempting HTML discovery...
INFO  HttpCache                      - Cached GET response does not match the required content type, removing.
INFO  HttpCache                      - Removing cached GET for http://&amp;lt;domain&amp;gt;/openid?id=11001259674714705...
INFO  HttpCache                      - Removing cached GET response for http://&amp;lt;domain&amp;gt;/openid?id=11001259674714705...
INFO  HtmlResolver                   - HTML discovery completed on: http://&amp;lt;domain&amp;gt;/openid?id=11001259674714705...
INFO  Discovery                      - Discovered 0 OpenID endpoints.
ERROR ConsumerManager                - No service element found to match the ClaimedID / OP-endpoint in the assertion.
ERROR ConsumerManager                - Discovered information verification failed.
java.lang.NullPointerException
	at org.springframework.security.openid.OpenID4JavaConsumer.endConsumption(OpenID4JavaConsumer.java:172)
	at org.springframework.security.openid.OpenIDAuthenticationFilter.attemptAuthentication(OpenIDAuthenticationFilter.java:152)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:199)
Code
====
call to discovered.getClaimedIdentifier() returns null in the following lines:
return new OpenIDAuthenticationToken(OpenIDAuthenticationStatus.FAILURE,
                    discovered.getClaimedIdentifier().getIdentifier(),
                    "Verification status message: [" + verification.getStatusMsg() + "]", attributes);</description>
			<version>3.0.1</version>
			<fixedVersion>3.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.openid.OpenID4JavaConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1384" opendate="2010-01-24 18:44:08" fixdate="2010-02-06 04:06:17" resolution="Fixed">
		<buginformation>
			<summary>DefaultWebInvocationPrivilegeEvaluator bypass the accessDecisionManager when authorities are empty</summary>
			<description>defaultWebInvocationPrivilegeEvaluator.isAllowed(...) always return false when authorities are empty.
Here is the simple security configuration used:
	&amp;lt;http access-decision-manager-ref="accessDecisionManager"&amp;gt;
		&amp;lt;intercept-url pattern="/images/**" filters="none" /&amp;gt;
		&amp;lt;intercept-url pattern="/scripts/**" filters="none" /&amp;gt;
		&amp;lt;intercept-url pattern="/styles/**" filters="none" /&amp;gt;
		&amp;lt;intercept-url pattern="/csmprobe.html*" filters="none" /&amp;gt;
		&amp;lt;intercept-url pattern="/login.htm*" access="ROLE_ANONYMOUS" /&amp;gt;
		&amp;lt;intercept-url pattern="/**" access="IS_AUTHENTICATED_FULLY" /&amp;gt;
		&amp;lt;form-login login-page="/login.htm"
			always-use-default-target="true"
			default-target-url="/siteSelection.htm"
			authentication-failure-url="/login.htm?login_error=1" /&amp;gt;
		&amp;lt;logout /&amp;gt;
	&amp;lt;/http&amp;gt;
	&amp;lt;ldap-server
		url="$
{ldap.url}
/$
{ldap.base}
"
		manager-dn="$
{ldap.managerDn}
"
		manager-password="$
{ldap.managerPassword}
" /&amp;gt;
	&amp;lt;authentication-manager alias="authenticationManager"&amp;gt;
		&amp;lt;ldap-authentication-provider user-search-filter="(uid=
{0}
)"
			user-search-base="$
{ldap.userSearchBase}
"
			group-search-base="$
{ldap.groups}
" /&amp;gt;
	&amp;lt;/authentication-manager&amp;gt;
	&amp;lt;beans:bean id="accessDecisionManager" class="org.springframework.security.access.vote.AffirmativeBased"&amp;gt;
		&amp;lt;beans:property name="decisionVoters"&amp;gt;
			&amp;lt;beans:list&amp;gt;
				&amp;lt;beans:bean class="org.springframework.security.access.vote.AuthenticatedVoter" /&amp;gt;
				&amp;lt;beans:bean class="org.springframework.security.access.vote.RoleVoter" /&amp;gt;
			&amp;lt;/beans:list&amp;gt;
		&amp;lt;/beans:property&amp;gt;
	&amp;lt;/beans:bean&amp;gt;
Users with no authorities have access to all pages (IS_AUTHENTICATED_FULLY) according to the filter configuration but defaultWebInvocationPrivilegeEvaluator.isAllowed(...) says the opposite. The implementation has this check: 
        if (authentication == null || authentication.getAuthorities().isEmpty()) 
{
            return false;
        }

authentication.getAuthorities().isEmpty() should be removed to allow decision voters do their work.</description>
			<version>3.0.1</version>
			<fixedVersion>3.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.access.DefaultWebInvocationPrivilegeEvaluator.java</file>
		</fixedFiles>
	</bug>
	<bug id="1404" opendate="2010-02-09 19:44:01" fixdate="2010-02-10 09:50:30" resolution="Fixed">
		<buginformation>
			<summary>Expression not expanded in intercept-url pattern</summary>
			<description>Expression is not expanded in intercept-url pattern.
Here is my configuration :






	&amp;lt;security:http&amp;gt;




		&amp;lt;security:form-login login-page="${security.admin.loginPageUrl}" login-processing-url="${security.admin.loginProcessingUrl}" default-target-url="${security.admin.loginTargetUrl}" always-use-default-target="true" /&amp;gt;




		&amp;lt;security:intercept-url pattern="${security.admin.loginPageUrl}" filters="none" /&amp;gt;




		&amp;lt;security:intercept-url pattern="/restricted/**" access="ROLE_ADMIN" /&amp;gt;




		&amp;lt;security:intercept-url pattern="/**" access="ROLE_USER" /&amp;gt;




	&amp;lt;/security:http&amp;gt;






and the error I get :






org.springframework.beans.factory.BeanDefinitionStoreException: Invalid bean definition with name &amp;amp;apos;org.springframework.security.filterChainProxy&amp;amp;apos; defined in null: Could not resolve placeholder &amp;amp;apos;security.admin.loginpageurl&amp;amp;apos;






The same expression works well in form-login#login-page attribute, but not in intercept-url#pattern attribute.
</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.http.HttpConfigurationBuilder.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.web.access.expression.WebSecurityExpressionRoot.java</file>
		</fixedFiles>
	</bug>
	<bug id="1396" opendate="2010-02-01 09:54:42" fixdate="2010-02-11 04:53:16" resolution="Fixed">
		<buginformation>
			<summary>Race condition between HttpSessionContextIntegrationFilter and SessionFixationProtectionFilter</summary>
			<description>There seems to be a race condition between processing in the HttpSessionContextIntegrationFilter and the SessionFixationProtectionFilter.
Here is our problem.
We have a web application with a fairly heavy home page that can be served quite slowly depending on the size of certain attributes associated with the user.  We are currently using Jetty 6.1.21 which supports HTTP 1.1 chunked responses.
If a user opens their browser and goes directly to the home page URL using a RememberMe token, this initial web request executes down through the filter stack and into the Spring MVC framework.  Steps 1a - 1d describe the processing of this initial request:
1a. The HttpSessionContextIntegration filter creates a new HttpSession and puts a default SecurityContext into the ThreadLocal handler.
1b. The RememberMeProcessingFilter authenticates the token and sets the user&amp;amp;apos;s Authentication object into the ThreadLocal handler.
1c. The SessionFixationProtectionFilter detects a new authentication, invalidates the existing HttpSession, and creates a new HttpSession (migrating the attributes).  It does not set the user&amp;amp;apos;s Authentication into the HttpSession  this is supposed to be done by the HttpSessionContextIntegration after all request processing is complete.
1d. The request goes into the Spring MVC framework, causing a response to start to be sent to the client using HTTP chunking.  This response includes the session id of the newly created session (created by the SessionFixationProtectionFilter).
The client begins receiving the markup, which includes various &amp;lt;script&amp;gt; elements to script files served by the web app.  Steps 2a - 2c describe the processing of this second request.  This processing takes place while the initial request is still being processed.  This second request sends over the session id created by the SessionFixationProtectionFilter for the first request.
2a. The HttpSessionContextIntegration puts a default SecurityContext into the ThreadLocal handler (since one has not yet been set into the HttpSession).
2b. The RememberMeProcessingFilter authenticates the token and sets the user&amp;amp;apos;s Authentication object into the ThreadLocal handler.
2c. The SessionFixationProtectionFilter detects another new authentication, invalidates the existing HttpSession, and creates a new HttpSession (migrating the attributes).
Processing of the initial web request is continuing through the Spring MVC framework.  We happen to use JSP for our view technology.
1e. Continued processing of a JSP page (or import) for the initial request causes an attempt to deference a variable, causing a IllegalStateException in Jetty&amp;amp;apos;s AbstractSessionManager.Session class.
I can "fix" this by extending the SessionFixationProtectionFilter and overriding 
protected void startNewSessionIfRequired(
        HttpServletRequest request, HttpServletResponse response)
{
    super.startNewSessionIfRequired(request, response);
    request.getSession().setAttribute(
            HttpSessionContextIntegrationFilter.SPRING_SECURITY_CONTEXT_KEY,
            SecurityContextHolder.getContext().getAuthentication());
}
so that the user&amp;amp;apos;s Authentication object is stored into the HttpSession before processing enters the Spring MVC framework, causing the execution of filters on the second request to not be considered a new authentication, thus preserving the validity of the session created during the initial request.
Is this the right way to do this?  It seems to keep session fixation protection working the way it is supposed to, but I&amp;amp;apos;m a little worried about what will happen with the OnRedirectUpdateSessionResponseWrapper created by the HttpSessionContextIntegrationFilter if the request processing results in a sendError() or sendRedirect().  My casual reading of HttpSessionContextIntegrationFilter seems to indicate it would still work correctly.
Any thoughts or advice would be appreciated.</description>
			<version>2.0.5</version>
			<fixedVersion>3.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.session.SessionManagementFilter.java</file>
			<file type="M">org.springframework.security.web.context.SaveContextOnUpdateOrErrorResponseWrapper.java</file>
			<file type="M">org.springframework.security.web.context.HttpSessionSecurityContextRepository.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParserTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1412" opendate="2010-02-16 13:05:28" fixdate="2010-02-17 10:44:18" resolution="Fixed">
		<buginformation>
			<summary>Login page redisplays when used with Spring 3&amp;apos;s ShallowEtagHeaderFilter</summary>
			<description>Adding ShallowEtagHeaderFilter to a web application that uses Spring Security will cause the redisplay of the Spring Security login page on the second login attempt. This was initially reported widely within the Spring Roo community and resulted in bug report ROO-579.
The problem can be seen by:
1. Active ShallowEtagHeaderFilter in a Spring Security application that has a normal login page
2. Visit the home page, attempt to access a secure page, and view the login page
3. Complete the login page, submit, and you should see the secure page (correct)
4. Logout
5. Attempt to access the same secure page again
6. The login page will display (correct)
7. Enter valid credentials and submit
   --&amp;gt; The login page will re-display (incorrect)
   --&amp;gt; What should have happened is the secure page would display, as you&amp;amp;apos;ve now authenticated
I have reproduced this with the Spring Security tutorial 3.0.1 web application WAR. I have made no changes to the WAR except modifying the web.xml to the following (I have included both filters for clarification of the order):






    &amp;lt;filter&amp;gt;




        &amp;lt;filter-name&amp;gt;springSecurityFilterChain&amp;lt;/filter-name&amp;gt;




        &amp;lt;filter-class&amp;gt;org.springframework.web.filter.DelegatingFilterProxy&amp;lt;/filter-class&amp;gt;




    &amp;lt;/filter&amp;gt;









	&amp;lt;filter&amp;gt;




		&amp;lt;filter-name&amp;gt;etagFilter&amp;lt;/filter-name&amp;gt;




		&amp;lt;filter-class&amp;gt;org.springframework.web.filter.ShallowEtagHeaderFilter&amp;lt;/filter-class&amp;gt;




	&amp;lt;/filter&amp;gt;









    &amp;lt;filter-mapping&amp;gt;




      &amp;lt;filter-name&amp;gt;springSecurityFilterChain&amp;lt;/filter-name&amp;gt;




      &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;




    &amp;lt;/filter-mapping&amp;gt;









	&amp;lt;filter-mapping&amp;gt;




		&amp;lt;filter-name&amp;gt;etagFilter&amp;lt;/filter-name&amp;gt;




		&amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;




	&amp;lt;/filter-mapping&amp;gt;






I have attached the tutorial WAR where you can see the problem by deploying to Tomcat. Simply access the "secure page", login as normal, and it will display. Then logout and click to view the "secure page" again. The login page will display. Login as normal, and on submission you will erroneously see the login page again. The problem can be avoided by disabling the ShallowEtagHeaderFilter in web.xml.</description>
			<version>3.0.1</version>
			<fixedVersion>3.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.savedrequest.DefaultSavedRequest.java</file>
			<file type="M">org.springframework.security.web.savedrequest.DefaultSavedRequestTests.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">579</link>
		</links>
	</bug>
	<bug id="1410" opendate="2010-02-15 07:28:24" fixdate="2010-02-17 10:48:24" resolution="Fixed">
		<buginformation>
			<summary>Remember Me doesn&amp;apos;t work with OpenID urls contatining "https://"</summary>
			<description>As of 3.0.1, AbstractRememberMeServices.decodeCookie() treats usernames with "http://" as a special case for compatibility with OpenID. But some OpenID providers use "https://..." in their identity urls, and cookies with such usernames are decoded incorrectly.</description>
			<version>3.0.1</version>
			<fixedVersion>3.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.rememberme.AbstractRememberMeServices.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.AbstractRememberMeServicesTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1425" opendate="2010-02-27 04:50:46" fixdate="2010-02-28 00:13:27" resolution="Fixed">
		<buginformation>
			<summary>AbstractRememberMeServices not handling properly empty cookie</summary>
			<description>Whwn empty cookie is sent to AbstractRememberMeServices, it will throw java.lang.ArrayIndexOutOfBoundsException instead of org.springframework.security.web.authentication.rememberme.InvalidCookieException
This can be fixed by adding 
if (tokens.length == 0) {
    throw new InvalidCookieException( "No cookie!?");
}
after 
String[] tokens = StringUtils.delimitedListToStringArray(cookieAsPlainText, DELIMITER);
</description>
			<version>3.0.2</version>
			<fixedVersion>3.0.3, 3.1.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.rememberme.AbstractRememberMeServices.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.AbstractRememberMeServicesTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1385" opendate="2010-01-24 21:22:54" fixdate="2010-03-04 09:33:16" resolution="Duplicate">
		<buginformation>
			<summary>AbstractRetryEntryPoint should use DefaultRedirectStrategy for redirects to support proxies</summary>
			<description>The AbstractRetryEntryPoint builds the redirect url for the redirect itself in its commence method. The problem is, that the context-path is always used.
If you run your application through a proxy with a change of the path, than the redirects leeds to a wrong url.
Example:
The app is deployed on Tomcat as ajp://localhost:8009/app1 and is accessed via a apache proxy through http://yourdomain.com/. The redirect url of a secured resource /resource.html will be http://yourdomain.com/app1/resource.html instead of the correct one http://yourdomain.com/resource.html.
Other parts of Spring Security are using the DefaultRedirectStrategy, which works as expected when setting the contextRelative to true.
I think if the AbstractRetryEntryPoint uses the same convention (DefaultRedirectStrategy), then the problem with the http-&amp;gt;https redirect in DefaultRedirectStrategy (see comment on the class) will also be fixed.
As a workaround we implemented our own RetryWithHttpsEntryPoint, which processes the contextRelative flag, and it works. But this is heavily to configure, because you cannot use the namespace configuration any more.
https://fisheye.springsource.org/browse/spring-security/web/src/main/java/org/springframework/security/web/access/channel/AbstractRetryEntryPoint.java</description>
			<version>3.0.1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.access.channel.RetryWithHttpEntryPointTests.java</file>
			<file type="M">org.springframework.security.web.access.channel.AbstractRetryEntryPoint.java</file>
			<file type="M">org.springframework.security.web.access.channel.RetryWithHttpsEntryPointTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1413</link>
		</links>
	</bug>
	<bug id="1432" opendate="2010-03-05 03:42:23" fixdate="2010-03-05 03:58:56" resolution="Fixed">
		<buginformation>
			<summary>UserMap should convert supplied maps to lower case</summary>
			<description>Since it converts a username to lower-case before doing a lookup in the map, it makes sense that the keys should also be converted when a new map is supplied.</description>
			<version>3.0.2</version>
			<fixedVersion>3.0.3, 3.1.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.authentication.UserServiceBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.config.authentication.UserServiceBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.core.userdetails.memory.UserMap.java</file>
		</fixedFiles>
	</bug>
	<bug id="1439" opendate="2010-03-11 20:02:57" fixdate="2010-03-12 01:55:28" resolution="Fixed">
		<buginformation>
			<summary>getRequest() / getResponse() is not public in org.springframework.security.web.context.HttpRequestResponseHolder</summary>
			<description>Custom SecurityContextRepository implementation relies on HttpRequestResponseHolder parameter in method  
public SecurityContext loadContext(HttpRequestResponseHolder requestResponseHolder).
Since getters and setters of HttpRequestResponseHolder properties are not public, pluggable repository mechanism is broken. 
</description>
			<version>3.0.2</version>
			<fixedVersion>3.0.3, 3.1.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.HttpRequestResponseHolder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1443" opendate="2010-03-19 01:05:05" fixdate="2010-03-22 04:28:08" resolution="Fixed">
		<buginformation>
			<summary>Jsr250Voter will return access denied for allowed roles</summary>
			<description>Method vote() from Jsr250Voter.java will return ACCESS_DENIED if the FIRST role from definition does not exists in authentication.getAuthorities() list.
 public int vote(Authentication authentication, Object object, Collection&amp;lt;ConfigAttribute&amp;gt; definition) {
        for (ConfigAttribute attribute : definition) {
           //...
            if (supports(attribute)) {
                // Attempt to find a matching granted authority
                for (GrantedAuthority authority : authentication.getAuthorities()) {
                    if (attribute.getAttribute().equals(authority.getAuthority())) 
{
                        return ACCESS_GRANTED;
                    }
                }
                // No match - deny access
                return ACCESS_DENIED; // &amp;lt;-------- will return ACCESS_DENIED too soon
            }
        } 
        return ACCESS_ABSTAIN;
    }</description>
			<version>3.0.2</version>
			<fixedVersion>3.0.3, 3.1.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.annotation.Jsr250Voter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1446" opendate="2010-03-20 10:43:49" fixdate="2010-03-23 09:38:15" resolution="Fixed">
		<buginformation>
			<summary>Malformed Base64 in Basic Authentication header causes BasicAuthenticationFilter to throw a RuntimeException</summary>
			<description>
Since Base64.decode throws a RuntimeException if it detects bad characters in the input string, org.springframework.security.web.authentication.www.BasicAuthenticationFilter.doFilter throws the RTE if the Authentication header contains malformed base 64. The effect is that http servers return 500 rather than  401.
My fix just adds an additional check by calling Base64.isBase64, and if that fails, continues processing as if the Authentication header were missing.
</description>
			<version>3.0.0</version>
			<fixedVersion>3.1.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.www.BasicAuthenticationFilter.java</file>
			<file type="M">org.springframework.security.web.authentication.www.BasicAuthenticationFilterTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1450" opendate="2010-03-24 03:46:20" fixdate="2010-03-24 09:46:49" resolution="Fixed">
		<buginformation>
			<summary>Pointcuts are incorrectly evaluated in case of generic methods</summary>
			<description>Pointcut definitions are incorrectly evaluated if generic methods are used.
For example consider the following types:
interface IActionHandler&amp;lt;T extends AbstractAction&amp;gt; {
    int foo(T action);
}
class ConcreteActionHandler implements IActionHandler&amp;lt;ConcreteAction&amp;gt;  {
    public int foo(ConcreteAction action) 
{...}
}
The following pointcut definition used in "protect-pointcut" configuration will not match the ConcreteActionHandler#foo(...) call:
execution(* IActionHandler.foo(..))
The reason is the inappropriate resolving of "most specific method" in AbstractFallbackMethodDefinitionSource. The "most specific method" is resolved by the org.springframework.util.ClassUtils#getMostSpecificMethod(...) call, which does not resolve the Java 5 bridge methods! Bridge methods should not be considered at all when ConfigAttributeDefinition-s are figured out. The org.springframework.aop.support.AopUtils#getMostSpecificMethod(...) should be used instead of ClassUtils as it resolves bridge methods correctly.
The AopUtils should be used instead of ClassUtils in the following places:
Version 2.0.5 of SpringSecurity: org.springframework.security.intercept.method.AbstractFallbackMethodDefinitionSource line 116
Version 3.0.2 of SpringSecurity: org.springframework.security.access.method.AbstractFallbackMethodSecurityMetadataSource line 32
I have tested the version 2.0.5 - it works, when AopUtils is used instead of ClassUtils.
I have not tested the version 3.0.2 - the mentioned fix is just an assumption.</description>
			<version>2.0.5</version>
			<fixedVersion>3.0.3, 3.1.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.method.AbstractFallbackMethodSecurityMetadataSource.java</file>
			<file type="M">org.springframework.security.config.method.GlobalMethodSecurityBeanDefinitionParserTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1444" opendate="2010-03-19 11:49:38" fixdate="2010-03-27 03:37:50" resolution="Fixed">
		<buginformation>
			<summary>BindAuthentiator Fails for Active Directory DN Containing Special Chars</summary>
			<description>BindAuthenticator.java (3.0.2) line 115, change userDN:
Attributes attrs = ctx.getAttributes(userDn, getUserAttributes());
to fullDn:
Attributes attrs = ctx.getAttributes(fullDn, getUserAttributes());
The reason is that when you use fullDn the DN string is generated using the LdapEncoder from Spring-LDAP.   If you use the raw userDn string that encoding isn&amp;amp;apos;t used, so special characters in a username (admittedly rare) can prevent the user from authenticating.
</description>
			<version>3.0.2</version>
			<fixedVersion>3.0.3, 3.1.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.search.FilterBasedLdapUserSearchTests.java</file>
			<file type="M">org.springframework.security.ldap.authentication.BindAuthenticator.java</file>
			<file type="M">org.springframework.security.ldap.SpringSecurityLdapTemplate.java</file>
			<file type="M">org.springframework.security.ldap.authentication.BindAuthenticatorTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1448" opendate="2010-03-20 03:59:12" fixdate="2010-03-27 05:26:48" resolution="Fixed">
		<buginformation>
			<summary>LocalVariableTableParameterNameDiscoverer doesn&amp;apos;t find Generic method parameters</summary>
			<description>I&amp;amp;apos;m using spring security to secure my service. Here is a sample secured method:
public interface Foo&amp;lt;T extends MyModel&amp;gt; {
	@PreAuthorize("hasPermission(#item, &amp;amp;apos;create&amp;amp;apos;)")
	public T create(T item);
}
In my junit test I get a NullPointerException when spring parses the EL:
java.lang.NullPointerException
	at org.springframework.security.access.expression.method.MethodSecurityEvaluationContext.addArgumentsAsVariables(MethodSecurityEvaluationContext.java:66)
	at org.springframework.security.access.expression.method.MethodSecurityEvaluationContext.lookupVariable(MethodSecurityEvaluationContext.java:48)
	at org.springframework.expression.spel.ExpressionState.lookupVariable(ExpressionState.java:122)
	at org.springframework.expression.spel.ast.VariableReference.getValueInternal(VariableReference.java:52)
	at org.springframework.expression.spel.ast.MethodReference.getValueInternal(MethodReference.java:59)
	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:93)
	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:98)
	at org.springframework.security.access.expression.ExpressionUtils.evaluateAsBoolean(ExpressionUtils.java:11)
	at org.springframework.security.access.expression.method.ExpressionBasedPreInvocationAdvice.before(ExpressionBasedPreInvocationAdvice.java:42)
	at org.springframework.security.access.prepost.PreInvocationAuthorizationAdviceVoter.vote(PreInvocationAuthorizationAdviceVoter.java:55)
	at org.springframework.security.access.vote.AffirmativeBased.decide(AffirmativeBased.java:50)
	at org.springframework.security.access.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:204)
	at org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptor.invoke(MethodSecurityInterceptor.java:65)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:202)
	at $Proxy25.create(Unknown Source)
[snip here comes the junit invocation part]
Debugging the offending code, I noticed that:
org.springframework.core.LocalVariableTableParameterNameDiscoverer#getParameterNames(Method method) returns null.
I guess it is because the method&amp;amp;apos;s parameter type is Generic. Can I fix it? Do you have any idea where in the class it&amp;amp;apos;s going "wrong" ?
I&amp;amp;apos;d be happy to fix it and submitt a patch but I&amp;amp;apos;, not sure where I have to change the code.
Cheers,
Jan
</description>
			<version>3.0.1</version>
			<fixedVersion>3.0.3, 3.1.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.method.GlobalMethodSecurityBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.access.expression.method.MethodSecurityEvaluationContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="1458" opendate="2010-04-12 20:49:50" fixdate="2010-04-16 02:15:20" resolution="Fixed">
		<buginformation>
			<summary>HttpSessionEventPublisher has static Log. it causes the log4j configuration to happen before Log4jConfigListener</summary>
			<description>Although the first listener in my web.xml is the Log4jConfigListener. the log4j configuration happens before getting there.
It happens because I also have HttpSessionEventPublisher listener that has a static Log, when the static Log is initialized it causes the log4j default configuration.
The problem is that some loggers from the default configuration are still alive even after the Log4jConfigListener is called. 
Changing the Log to not being static should solve the issue.</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.3, 3.1.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.session.HttpSessionEventPublisher.java</file>
		</fixedFiles>
	</bug>
	<bug id="1462" opendate="2010-04-19 22:13:12" fixdate="2010-04-20 04:38:06" resolution="Fixed">
		<buginformation>
			<summary>SessionFixationProtectionFilter creates new session even when the requested session id is null or invalid.</summary>
			<description>We ran into an issue where the hotspot browser on blackberry devices was not able to maintain the httpsession. We are using tomcat 6 as our web server. After investigation it was found that the tomcat is generating two Set-Cookie headers for JSESSIONID. Out of these two JSESSIONID second one is valid however the hotspot browser is picking up the wrong one (i.e. first one) and that is why it is not able to maintain the session. With further investigation it was found that the SessionFixationProtectionFilter invalidates the current session and then creates a new one if the user is authenticated during the current requests. This was causing the multiple JSESSIONID.
Though the issue seems to be with the browser and the tomcat but the SessionFixationProtectionFilter creates new session when it is not required i.e. when the requested session id is invalid or null. So we need to add an extra condition which also checks for request.isRequestedSessionIdValid() in the already exisiting condition
//existing code
if(request.getSession(false) == null || request.getAttribute(FILTER_APPLIED) != null) {
	chain.doFilter(request, response);
	return;
}
//changed code 
if(request.getSession(false) == null || request.getAttribute(FILTER_APPLIED) != null || request.isRequestedSessionIdValid() == false) {
	chain.doFilter(request, response);
	return;
}
This not only fixes the issue mentioned but also improves the performance as we are avoiding unnecessary session creation.</description>
			<version>2.0.4</version>
			<fixedVersion>3.0.3, 3.1.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="1480" opendate="2010-05-14 04:26:06" fixdate="2010-05-14 12:33:01" resolution="Fixed">
		<buginformation>
			<summary>LdapUserDetailsImpl does not override equals/hashCode</summary>
			<description>result is that namespace session management config does not work with default LdapUserDetailsImpl.</description>
			<version>3.0.2</version>
			<fixedVersion>3.0.3, 3.1.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.userdetails.LdapUserDetailsImpl.java</file>
			<file type="M">org.springframework.security.ldap.userdetails.InetOrgPersonTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1455" opendate="2010-04-06 18:54:22" fixdate="2010-05-24 23:39:42" resolution="Fixed">
		<buginformation>
			<summary>SecurityNamespaceHandler problems in OSGi environment, need to import spring-security-web packages</summary>
			<description>Imagine the following situation: there is an OSGi (in my case DM Server) environment, which contains some bundles. One of them uses the security namespace to protect some methods. This bundle has nothing to do with the web, this is the responsibility of the web bundle, which contains some web pages and expose some of the services from that bundle. . Within the web bundle, a filter-chain-map is used to protect some URLs.
The manifest of the first bundle imports some Spring Security related packages, but not org.springframework.security.web, this package is only imported by the web bundle. The SecurityNamespaceHandler seems to be a singleton, and when the org.springframework.security.web.FilterChainProxy is not available on the classpath when the SecurityNamespaceHandler is loaded for the first time (in my case, when the first bundle is started), an exception will be thrown when another bundle is using the security:http and security:filter-chain-map elements.
Workaround:
Import the org.springframework.security.web package in all bundles which do something with the security namespace.
Stacktrace:
org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: spring-security-web classes are not available. You need these to use &amp;lt;filter-chain-map&amp;gt;
Offending resource: URL [bundleentry://121.fwk7527493/WEB-INF/applicationContext.xml]
	at org.springframework.beans.factory.parsing.FailFastProblemReporter.fatal(FailFastProblemReporter.java:59)
	at org.springframework.beans.factory.parsing.ReaderContext.fatal(ReaderContext.java:68)
	at org.springframework.beans.factory.parsing.ReaderContext.fatal(ReaderContext.java:55)
	at org.springframework.security.config.SecurityNamespaceHandler.reportMissingWebClasses(SecurityNamespaceHandler.java:91)
	at org.springframework.security.config.SecurityNamespaceHandler.decorate(SecurityNamespaceHandler.java:72)
	at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.decorateIfRequired(BeanDefinitionParserDelegate.java:1372)
	at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired(BeanDefinitionParserDelegate.java:1359)
	at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.decorateBeanDefinitionIfRequired(BeanDefinitionParserDelegate.java:1339)
	at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.processBeanDefinition(DefaultBeanDefinitionDocumentReader.java:261)
	at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseDefaultElement(DefaultBeanDefinitionDocumentReader.java:154)
	at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:133)
	at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:93)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:493)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:390)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:334)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:302)
	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:143)
	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:178)
	at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:149)
	at org.springframework.osgi.context.support.OsgiBundleXmlApplicationContext.loadBeanDefinitions(OsgiBundleXmlApplicationContext.java:164)
	at org.springframework.osgi.context.support.OsgiBundleXmlApplicationContext.loadBeanDefinitions(OsgiBundleXmlApplicationContext.java:136)
	at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:130)
	at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:458)
	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.access$800(AbstractDelegatedExecutionApplicationContext.java:69)
	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext$3.run(AbstractDelegatedExecutionApplicationContext.java:269)
	at org.springframework.osgi.util.internal.PrivilegedUtils.executeWithCustomTCCL(PrivilegedUtils.java:85)
	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.startRefresh(AbstractDelegatedExecutionApplicationContext.java:247)
	at org.springframework.osgi.extender.internal.dependencies.startup.DependencyWaiterApplicationContextExecutor.stageOne(DependencyWaiterApplicationContextExecutor.java:214)
	at org.springframework.osgi.extender.internal.dependencies.startup.DependencyWaiterApplicationContextExecutor.refresh(DependencyWaiterApplicationContextExecutor.java:169)
	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.refresh(AbstractDelegatedExecutionApplicationContext.java:175)
	at org.springframework.osgi.extender.internal.activator.ContextLoaderListener$2.run(ContextLoaderListener.java:716)
	at org.springframework.core.task.SyncTaskExecutor.execute(SyncTaskExecutor.java:48)
	at org.springframework.osgi.extender.internal.activator.ContextLoaderListener.maybeCreateApplicationContextFor(ContextLoaderListener.java:781)
	at org.springframework.osgi.extender.internal.activator.ContextLoaderListener$ContextBundleListener.handleEvent(ContextLoaderListener.java:229)
	at org.springframework.osgi.extender.internal.activator.ContextLoaderListener$BaseListener.bundleChanged(ContextLoaderListener.java:172)
	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.dispatchEvent(BundleContextImpl.java:919)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:227)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:149)
	at org.eclipse.osgi.framework.internal.core.Framework.publishBundleEventPrivileged(Framework.java:1350)
	at org.eclipse.osgi.framework.internal.core.Framework.publishBundleEvent(Framework.java:1301)
	at org.eclipse.osgi.framework.internal.core.BundleHost.startWorker(BundleHost.java:362)
	at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:280)
	at com.springsource.kernel.core.internal.StandardBundleStarter.start(StandardBundleStarter.java:68)
	at com.springsource.kernel.core.internal.StandardBundleStarter.start(StandardBundleStarter.java:56)
	at sun.reflect.GeneratedMethodAccessor72.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:307)
	at org.springframework.osgi.service.importer.support.internal.aop.ServiceInvoker.doInvoke(ServiceInvoker.java:58)
	at org.springframework.osgi.service.importer.support.internal.aop.ServiceInvoker.invoke(ServiceInvoker.java:62)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
	at org.springframework.aop.support.DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)
	at org.springframework.aop.support.DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
	at org.springframework.osgi.service.importer.support.LocalBundleContextAdvice.invoke(LocalBundleContextAdvice.java:59)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
	at org.springframework.aop.support.DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)
	at org.springframework.aop.support.DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:202)
	at $Proxy60.start(Unknown Source)
	at com.springsource.kernel.install.artifact.internal.bundle.StandardBundleDriver.startBundle(StandardBundleDriver.java:177)
	at com.springsource.kernel.install.artifact.internal.bundle.StandardBundleDriver.start(StandardBundleDriver.java:158)
	at com.springsource.kernel.install.artifact.internal.bundle.StandardBundleInstallArtifact.doStart(StandardBundleInstallArtifact.java:262)
	at com.springsource.kernel.install.artifact.internal.AbstractInstallArtifact.driveDoStart(AbstractInstallArtifact.java:211)
	at com.springsource.kernel.install.artifact.internal.bundle.StandardBundleInstallArtifact.start(StandardBundleInstallArtifact.java:251)
	at com.springsource.kernel.deployer.core.internal.PipelinedApplicationDeployer.start(PipelinedApplicationDeployer.java:291)
	at com.springsource.kernel.deployer.core.internal.PipelinedApplicationDeployer.deploy(PipelinedApplicationDeployer.java:201)
	at com.springsource.kernel.deployer.management.StandardDeployer.deploy(StandardDeployer.java:62)
	at sun.reflect.GeneratedMethodAccessor88.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at com.sun.jmx.mbeanserver.ConvertingMethod.invokeWithOpenReturn(ConvertingMethod.java:167)
	at com.sun.jmx.mbeanserver.MXBeanIntrospector.invokeM2(MXBeanIntrospector.java:96)
	at com.sun.jmx.mbeanserver.MXBeanIntrospector.invokeM2(MXBeanIntrospector.java:33)
	at com.sun.jmx.mbeanserver.MBeanIntrospector.invokeM(MBeanIntrospector.java:208)
	at com.sun.jmx.mbeanserver.PerInterface.invoke(PerInterface.java:120)
	at com.sun.jmx.mbeanserver.MBeanSupport.invoke(MBeanSupport.java:262)
	at com.sun.jmx.interceptor.DefaultMBeanServerInterceptor.invoke(DefaultMBeanServerInterceptor.java:836)
	at com.sun.jmx.mbeanserver.JmxMBeanServer.invoke(JmxMBeanServer.java:761)
	at javax.management.remote.rmi.RMIConnectionImpl.doOperation(RMIConnectionImpl.java:1426)
	at javax.management.remote.rmi.RMIConnectionImpl.access$200(RMIConnectionImpl.java:72)
	at javax.management.remote.rmi.RMIConnectionImpl$PrivilegedOperation.run(RMIConnectionImpl.java:1264)
	at javax.management.remote.rmi.RMIConnectionImpl.doPrivilegedOperation(RMIConnectionImpl.java:1359)
	at javax.management.remote.rmi.RMIConnectionImpl.invoke(RMIConnectionImpl.java:788)
	at sun.reflect.GeneratedMethodAccessor87.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:305)
	at sun.rmi.transport.Transport$1.run(Transport.java:159)
	at java.security.AccessController.doPrivileged(Native Method)
	at sun.rmi.transport.Transport.serviceCall(Transport.java:155)
	at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:535)
	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:790)
	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:649)
	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
	at java.lang.Thread.run(Thread.java:619)</description>
			<version>3.0.0</version>
			<fixedVersion>3.0.3, 3.1.0.M1</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1500" opendate="2010-06-17 03:41:39" fixdate="2010-06-17 12:21:31" resolution="Fixed">
		<buginformation>
			<summary>Target-URL changes while switching between secure and insecure channel, when it was encoded according to RFC 3986</summary>
			<description>This issue is simmilar to the issue SEC-1255 "Target-URL after successfull login differes from original URL, when it was encoded according to RFC 3986"
http://jira.springframework.org/browse/SEC-1255
When switching the channel, AbstractRetryEntryPoint rebuilds the URL from its decoded parts.
So, when switching on a URL, that containes a special character (like &amp;amp;apos;?&amp;amp;apos;), which is encoded according to RFC 3986, it changes the URL.
For example, the URL "/foo%3Fbar.html", where "%3F" encodes the "?", becomes "/foo?bar.html", which is not encoded correctly, thus resulting in a 404-Error.
Encoding the rebuild URL would not work, becaus all special characters (like contained slashes for example) would be encoded than, which is, as far as I know, not correct. 
I fixed the issue in my local git repository by calling the UrlUtils, which were fixed in issue SEC-1255, for building the redirect URL.
I will apply my patch to this bug-report.
</description>
			<version>3.0.2</version>
			<fixedVersion>3.0.3, 3.1.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.access.channel.RetryWithHttpEntryPointTests.java</file>
			<file type="M">org.springframework.security.web.access.channel.AbstractRetryEntryPoint.java</file>
			<file type="M">org.springframework.security.web.util.UrlUtils.java</file>
			<file type="M">org.springframework.security.web.access.channel.RetryWithHttpsEntryPointTests.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">1413</link>
		</links>
	</bug>
	<bug id="1501" opendate="2010-06-18 05:04:02" fixdate="2010-06-25 05:48:14" resolution="Fixed">
		<buginformation>
			<summary>Documention uses incorrect package in example bean definition</summary>
			<description>The JavaDoc page for SwitchUserFilter lists an example bean definition:
 &amp;lt;bean id="switchUserProcessingFilter" class="org.springframework.security.web.authentication.SwitchUserFilter"&amp;gt;
    &amp;lt;property name="userDetailsService" ref="userDetailsService" /&amp;gt;
    &amp;lt;property name="switchUserUrl"&amp;gt;&amp;lt;value&amp;gt;/j_spring_security_switch_user&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name="exitUserUrl"&amp;gt;&amp;lt;value&amp;gt;/j_spring_security_exit_user&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;property name="targetUrl"&amp;gt;&amp;lt;value&amp;gt;/index.jsp&amp;lt;/value&amp;gt;&amp;lt;/property&amp;gt;&amp;lt;/bean&amp;gt;
The package is incorrectly stated as org.springframework.security.web.authentication; it should be org.springframework.security.web.authentication.switchuser</description>
			<version>3.0.2</version>
			<fixedVersion>3.0.3, 3.1.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.switchuser.SwitchUserFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1507" opendate="2010-07-02 00:52:38" fixdate="2010-07-02 06:14:36" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException in RoleVoter if original UserDetails#getAuthorities() is empty and if RoleHierarchy is enabled</summary>
			<description>I have a custom UserDetailsService implementation which may not provide any role for some user, i.e. the UserDetails#getAuthorities() returns is an empty Collection.
If this user try to access a secured resource with a given role (e.g. not IS_AUTHENTICATED_REMEMBERED) then the following exception occurs:
java.lang.NullPointerException
	at org.springframework.security.access.vote.RoleVoter.vote(RoleVoter.java:103)
	at org.codehaus.groovy.grails.plugins.springsecurity.AuthenticatedVetoableDecisionManager.checkOtherVoters(AuthenticatedVetoableDecisionManager.java:90)
	at org.codehaus.groovy.grails.plugins.springsecurity.AuthenticatedVetoableDecisionManager.decide(AuthenticatedVetoableDecisionManager.java:44)
	at org.springframework.security.access.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:203)
	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:106)
	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:83)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:97)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:78)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter.doFilter(RememberMeAuthenticationFilter.java:119)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:54)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:188)
	at org.codehaus.groovy.grails.plugins.springsecurity.RequestHolderAuthenticationFilter.doFilter(RequestHolderAuthenticationFilter.java:40)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:188)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.codehaus.groovy.grails.plugins.springsecurity.MutableLogoutFilter.doFilter(MutableLogoutFilter.java:79)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:79)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:149)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:237)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:167)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.codehaus.groovy.grails.web.servlet.filter.GrailsReloadServletFilter.doFilterInternal(GrailsReloadServletFilter.java:104)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.codehaus.groovy.grails.web.servlet.mvc.GrailsWebRequestFilter.doFilterInternal(GrailsWebRequestFilter.java:67)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.codehaus.groovy.grails.web.filters.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:66)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:237)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:167)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.jasig.cas.client.session.SingleSignOutFilter.doFilter(SingleSignOutFilter.java:106)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.jasig.cas.client.session.SingleSignOutFilter.doFilter(SingleSignOutFilter.java:106)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:293)
	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:849)
	at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:583)
	at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:454)
	at java.lang.Thread.run(Thread.java:619)
After looking at SEC-1325, I found that RoleHierarchyImpl.java still uses null when the authorities Collection is empty.
I have attached a patch to fix this and i have tested it against current master.
My current workaround is to provide at least the "ROLE_DUMMY" role to users.</description>
			<version>3.0.2</version>
			<fixedVersion>3.1.0.M1, 3.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl.java</file>
			<file type="M">org.springframework.security.access.hierarchicalroles.RoleHierarchyImplTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1577</link>
		</links>
	</bug>
	<bug id="1520" opendate="2010-07-20 04:47:16" fixdate="2010-07-22 22:41:27" resolution="Fixed">
		<buginformation>
			<summary>Enumerator not closed or fully-enumerated</summary>
			<description>1- SpringSecurityLdapTemplate.java, in compare (called by the LDAP password authenticator)
NamingEnumeration&amp;lt;SearchResult&amp;gt; results = ctx.search(dn, comparisonFilter, new Object[] 
{value}, ctls);
return Boolean.valueOf(results.hasMore());

should be more like this
NamingEnumeration&amp;lt;SearchResult&amp;gt; results = ctx.search(dn, comparisonFilter, new Object[] {value}
, ctls);
boolean rtn = Boolean.valueOf(results.hasMore());
try {
  results.close();
} catch (NamingException ignored) {
  // Ignore naming exception on close.
}
return rtn;
2- DefaultDirContextValidator.validateDirContext has a similar problem, but I think that class has been refactored or eliminated.</description>
			<version>2.0.5</version>
			<fixedVersion>3.1.0.M1, 3.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.SpringSecurityLdapTemplate.java</file>
			<file type="M">org.springframework.security.ldap.LdapUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1521" opendate="2010-07-22 10:57:15" fixdate="2010-07-23 02:01:47" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException in SecurityContextPersistenceFilter with null SecurityContextRepository</summary>
			<description>According to documentation in section 8.3.1, the SecurityContextPersistenceFilter should support a null SecurityContextRepository, which would prevent a SecurityContext from ever being persisted.
However, configuring a null SecurityContextRepository results in a NullPointerException. Either the documentation is incorrect or misleading, or the SecurityContextPersistenceFilter should perform null checks on the field.
	&amp;lt;bean id="securityContextPersistenceFilter"
		class="org.springframework.security.web.context.SecurityContextPersistenceFilter"&amp;gt;
		&amp;lt;property name="securityContextRepository"&amp;gt;
			&amp;lt;null /&amp;gt;
		&amp;lt;/property&amp;gt;
	&amp;lt;/bean&amp;gt;
SEVERE: Servlet.service() for servlet classes/com.turner.playon.event threw exception
java.lang.NullPointerException
	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:74)
	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:355)
	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:149)
	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:237)
	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:167)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:128)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:293)
	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:849)
	at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:583)
	at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:454)
	at java.lang.Thread.run(Thread.java:637)
</description>
			<version>3.0.2</version>
			<fixedVersion>3.1.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.SecurityContextPersistenceFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1519" opendate="2010-07-18 21:32:16" fixdate="2010-07-23 04:00:03" resolution="Complete">
		<buginformation>
			<summary>Uninitialized auditLogger and aclAuthorizationStrategy fields in EhCacheBasedAclCache </summary>
			<description>The "auditLogger" and "aclAuthorizationStrategy" fields of EhCacheBasedAclCache class are initialized by the first "putInCache" method call:
...
        if (this.aclAuthorizationStrategy == null) {
            if (acl instanceof AclImpl) 
{
                this.aclAuthorizationStrategy = (AclAuthorizationStrategy) FieldUtils.getProtectedFieldValue("aclAuthorizationStrategy", acl);
                this.auditLogger = (AuditLogger) FieldUtils.getProtectedFieldValue("auditLogger", acl);
            }
        }
...
In a clustered EhCache environment, with cache configured for replication, the problem is that if you invoke "initializeTransientFields" (through getFromCache methods) on a node before any "putInCache", both fields are null so a NullPointerException is thrown similarly to SEC-1514.
I think the solution is very simple: remove the initialization of "auditLogger" and "aclAuthorizationStrategy" from the "putInCache" method and use constructor (or method) injection of both properties.</description>
			<version>3.0.3</version>
			<fixedVersion>3.1.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.domain.EhCacheBasedAclCache.java</file>
		</fixedFiles>
	</bug>
	<bug id="1454" opendate="2010-04-06 01:00:36" fixdate="2010-07-30 07:29:54" resolution="Fixed">
		<buginformation>
			<summary>@PreAutorize(#username == principal.username) issues - when target is AOPProxy</summary>
			<description>Hi Luke/Anybody,
When used @PreAutorize(#username == principal.username) issues - when target is AOPProxy I always get an NullPointerExpression in MethodSecurityEvaluationContext addArgumentsAsVariables method. I have compiled with debug info, no issues with that. 
I have looked at the bug report which is the same case for Genrics http://jira.springframework.org/browse/SEC-1448
However, in my case my target object is wrapped in a AOPproxy(JdkDynamicProxy), but when used with AopUtils.getMostSpecificMethod(method, target) it always returns the class as $Proxy which cannot be read by the parameterDiscoverer. May be I have a wrapper of AOPProxy inside another AOPProxy which wraps my target. I guess it is a valid case. 
I could able to get around it by having custom EvaluationContext which first try run through a loop and get the target object as below 
while (candidate instanceof TargetClassAware) { // This is to ensure that we get to the final target object - most specific.
if (candidate instanceof TargetSource) {
candidate = ((TargetSource)candidate).getTarget(); 
} else if (candidate instanceof Advised){
candidate =((Advised) candidate).getTargetSource();
}
}
return AopUtils.getTargetClass(candidate);
However I still consider this as a work around and it would be nice that spring-security supports this out of the box, as it is so common that we use AOPproxy&amp;amp;apos;s as target object. 
-----------------------------------------------------------------------------------------------------------
I just copy below source code from Spring-sec MethodSecurityEvaluationContext class
private void addArgumentsAsVariables() {
Object[] args = mi.getArguments();
Object targetObject = mi.getThis();
Method method = ClassUtils.getMostSpecificMethod(mi.getMethod(), targetObject.getClass());
String[] paramNames = parameterNameDiscoverer.getParameterNames(method);
for(int i=0; i &amp;lt; args.length; i++) {
super.setVariable(paramNames[i], args[i]);
}
}
I was talking about targetObject in this method, which is the class/interface that is annotated with preAuthorize. And in my application context the bean is wrapped in multi levels of AOPproxy&amp;amp;apos;s. 
I am not sure whether it is Spring issue or Spring sec issue, because in 3.0.3 even spring sec uses AopUtils.getMostSpecificmethod(method, target) this issue will not be solved as AopUtils just looks one level not recursively until it hits the right target. 
I would open a JIRA issue, if possible with a test case.
Luke,
I told I will open JIRA with a test case, but it is difficult that I trim down my application context to make this test case. Please let me know if you cant reproduce it then i will fetch some time to create a test case. </description>
			<version>3.0.1</version>
			<fixedVersion>3.1.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.expression.method.MethodSecurityEvaluationContext.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="depends on">7074</link>
		</links>
	</bug>
	<bug id="1413" opendate="2010-02-16 15:54:50" fixdate="2010-08-10 13:21:15" resolution="Complete">
		<buginformation>
			<summary>AbstractRetryEntryPoint should use RedirectStrategy</summary>
			<description>For consistency, AbstractRetryEntryPoint should probably use RedirectStrategy as implemented in SEC-1226. Possible use cases include URL pre-processing, which users might want consistently applied.
Let me know if you agree and I am happy to supply a patch.</description>
			<version>3.0.1</version>
			<fixedVersion>3.1.0.M1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.access.channel.RetryWithHttpEntryPointTests.java</file>
			<file type="M">org.springframework.security.web.access.channel.AbstractRetryEntryPoint.java</file>
			<file type="M">org.springframework.security.web.access.channel.RetryWithHttpsEntryPointTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1385</link>
			<link type="Related" description="is related to">1500</link>
		</links>
	</bug>
	<bug id="1532" opendate="2010-08-06 06:28:52" fixdate="2010-08-11 10:34:45" resolution="Complete">
		<buginformation>
			<summary>ProtectPointcutPostProcessor should not re-attempt to match the pointcuts against methods when used with prototype beans</summary>
			<description>In our web application we use spring security combining url security as well as method security using XML configuration only.
The webapp is being deployed on a stock Tomcat 6.0.29 using JDK6.

URL-security is configured using &amp;lt;sec:intercept-url /&amp;gt; tags only.


Method-security is configured using &amp;lt;sec:protect-pointcut /&amp;gt; tags only referencing a central Pointcuts-class. The pointcut class implements dummy methods being referenced in the method security XML configuration. The reason for doing so is to have descriptive names for the pointcut expressions. The pointcut expressions are being configured using @Pointcut annotations.

The URL- and method-security XML configuration files are seperate. We don&amp;amp;apos;t use any annotation based security configuration. We recognized a very slow bootstrap performance as well as a very poor runtime performance being caused by spring security. When disabling method-security performance is as expected.
The performance difference at bootstrap is about 30 sec with method-security enabled and about 6 sec with method-security disabled.
During runtime opening pages takes a couple seconds when method-security is enabled and only a fraction of a second with method-security disabled.
The performance difference is so huge and evident that we did not even make concrete performance measurements in order to quantize the difference.
During bootstrap we made random thread dumps recognizing the same pattern over and over where the main-Threads is stuck:
"main" prio=10 tid=0x080e1800 nid=0xbcc waiting on condition [0xb73e6000]
   java.lang.Thread.State: RUNNABLE
        at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:307)

locked &amp;lt;0xa4000500&amp;gt; (a sun.misc.Launcher$AppClassLoader)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
locked &amp;lt;0xa4000500&amp;gt; (a sun.misc.Launcher$AppClassLoader)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:248)
        at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1560)
locked &amp;lt;0xa4149438&amp;gt; (a org.apache.catalina.loader.WebappClassLoader)
        at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1491)
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Class.java:247)
        at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createDelegate(ReflectionBasedReferenceTypeDelegateFactory.java:40)
        at org.aspectj.weaver.reflect.ReflectionWorld.resolveDelegate(ReflectionWorld.java:111)
        at org.aspectj.weaver.World.resolveToReferenceType(World.java:388)
        at org.aspectj.weaver.World.resolve(World.java:279)
        at org.aspectj.weaver.patterns.SimpleScope.lookupType(SimpleScope.java:57)
        at org.aspectj.weaver.bcel.AtAjAttributes$BindingScope.lookupType(AtAjAttributes.java:1680)
        at org.aspectj.weaver.patterns.WildTypePattern.lookupTypeInScope(WildTypePattern.java:716)
        at org.aspectj.weaver.patterns.WildTypePattern.resolveBindingsFromFullyQualifiedTypeName(WildTypePattern.java:703)
        at org.aspectj.weaver.patterns.WildTypePattern.resolveBindings(WildTypePattern.java:631)
        at org.aspectj.weaver.patterns.TypePattern.resolveExactType(TypePattern.java:194)
        at org.aspectj.weaver.patterns.ReferencePointcut.resolveBindings(ReferencePointcut.java:131)
        at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:196)
        at org.aspectj.weaver.tools.PointcutParser.resolvePointcutExpression(PointcutParser.java:332)
        at org.aspectj.weaver.tools.PointcutParser.parsePointcutExpression(PointcutParser.java:310)
        at org.aspectj.weaver.tools.PointcutParser.parsePointcutExpression(PointcutParser.java:288)
        at org.springframework.security.intercept.method.ProtectPointcutPostProcessor.postProcessBeforeInitialization(ProtectPointcutPostProcessor.java:103)
        ...

During runtime load we also made thread dumps randomly recognized the same pattern where the request threads are being stuck. During runtime we have another problem that other http request are being blocked. This is a production no-go.
The blocking thread:
"http-8120-6" daemon prio=10 tid=0x08e1a000 nid=0x7912 waiting on condition [0x9a8ff000]
   java.lang.Thread.State: RUNNABLE
        at java.lang.ClassLoader.loadClass(ClassLoader.java:307)

locked &amp;lt;0xa3fab6c0&amp;gt; (a sun.misc.Launcher$ExtClassLoader)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:296)
locked &amp;lt;0xa3fab678&amp;gt; (a sun.misc.Launcher$AppClassLoader)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
locked &amp;lt;0xa3fab678&amp;gt; (a sun.misc.Launcher$AppClassLoader)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:248)
        at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1560)
locked &amp;lt;0xa40cf610&amp;gt; (a org.apache.catalina.loader.WebappClassLoader)
        at org.apache.catalina.loader.WebappClassLoader.loadClass(WebappClassLoader.java:1491)
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Class.java:247)
        at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createDelegate(ReflectionBasedReferenceTypeDelegateFactory.java:40)
        at org.aspectj.weaver.reflect.ReflectionWorld.resolveDelegate(ReflectionWorld.java:111)
        at org.aspectj.weaver.World.resolveToReferenceType(World.java:388)
        at org.aspectj.weaver.World.resolve(World.java:279)
        at org.aspectj.weaver.patterns.SimpleScope.lookupType(SimpleScope.java:57)
        at org.aspectj.weaver.bcel.AtAjAttributes$BindingScope.lookupType(AtAjAttributes.java:1680)
        at org.aspectj.weaver.patterns.WildTypePattern.lookupTypeInScope(WildTypePattern.java:716)
        at org.aspectj.weaver.patterns.WildTypePattern.resolveBindingsFromFullyQualifiedTypeName(WildTypePattern.java:703)
        at org.aspectj.weaver.patterns.WildTypePattern.resolveBindings(WildTypePattern.java:631)
        at org.aspectj.weaver.patterns.TypePattern.resolveExactType(TypePattern.java:194)
        at org.aspectj.weaver.patterns.ReferencePointcut.resolveBindings(ReferencePointcut.java:131)
        at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:196)
        at org.aspectj.weaver.tools.PointcutParser.resolvePointcutExpression(PointcutParser.java:332)
        at org.aspectj.weaver.tools.PointcutParser.parsePointcutExpression(PointcutParser.java:310)
        at org.aspectj.weaver.tools.PointcutParser.parsePointcutExpression(PointcutParser.java:288)
        at org.springframework.security.intercept.method.ProtectPointcutPostProcessor.postProcessBeforeInitialization(ProtectPointcutPostProcessor.java:103)
        ...

The blocked threads:
"http-8120-5" daemon prio=10 tid=0x08e74c00 nid=0x7910 waiting for monitor entry [0x9a950000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Class.java:247)
        at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createDelegate(ReflectionBasedReferenceTypeDelegateFactory.java:40)
        at org.aspectj.weaver.reflect.ReflectionWorld.resolveDelegate(ReflectionWorld.java:111)
        ...
"http-8120-4" daemon prio=10 tid=0x08e73000 nid=0x790f waiting for monitor entry [0x9a9a1000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Class.java:247)
        at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createDelegate(ReflectionBasedReferenceTypeDelegateFactory.java:40)
        ...
"http-8120-3" daemon prio=10 tid=0x09325000 nid=0x790e waiting for monitor entry [0x9a9f2000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Class.java:247)
        at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createDelegate(ReflectionBasedReferenceTypeDelegateFactory.java:40)
        ...
"http-8120-1" daemon prio=10 tid=0x093d8400 nid=0x3f18 waiting for monitor entry [0x9af95000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at java.lang.Class.forName0(Native Method)
        at java.lang.Class.forName(Class.java:247)
        at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createDelegate(ReflectionBasedReferenceTypeDelegateFactory.java:40)
        ...
Please find attached a source code and configuration sample.
We found a couple places on the forums where the problem is being recognized but so far we did not find any JIRA issue.
Our current planned resolution is to avoid pointcut expressions for method-security at all. Instead we will use either annotations or the intercept-methods bean decorator and hope that performance increases. It would be nice though to use pointcut expressions.</description>
			<version>2.0.5</version>
			<fixedVersion>3.1.0.M1, 3.0.4</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.method.ProtectPointcutPostProcessor.java</file>
			<file type="M">org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource.java</file>
		</fixedFiles>
	</bug>
	<bug id="1133" opendate="2009-04-01 20:45:14" fixdate="2010-08-14 07:11:35" resolution="Complete">
		<buginformation>
			<summary>Allow setting authenticationDetailsSource ref via form-login namespace URL</summary>
			<description></description>
			<version>3.0.1</version>
			<fixedVersion>3.1.0.M1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
			<file type="M">org.springframework.security.config.http.FormLoginBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1388</link>
		</links>
	</bug>
	<bug id="1540" opendate="2010-08-16 12:05:09" fixdate="2010-08-18 05:20:08" resolution="Fixed">
		<buginformation>
			<summary>Namespace improperly handles method attribute when populating ChannelProcessingFilter.securityMetadataSource</summary>
			<description>The namespace improperly handles the method attribute when populating ChannelProcessingFilter.securityMetadataSource. The problems differ between 3.0.x and 3.1.x. For 3.0.x the issue is that the method is ignored. The issue for 3.1.x is that if the path is /** the method is ignored. I have attached a patch with tests and a fix for both master and 3.0.x. Note that I included a test for 3.1.x that actually works but was broke in 3.0.x in order to ensure it continues to work. While it might be wise to refactor to reuse the logic in creating the securityMetadataSource, I did not do so to limit the scope of this change.
PS: I did not look at 2.x to see if it needed corrections.</description>
			<version>3.0.3</version>
			<fixedVersion>3.1.0.M1, 3.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.MatcherType.java</file>
		</fixedFiles>
	</bug>
	<bug id="1549" opendate="2010-08-28 06:55:53" fixdate="2010-08-28 07:29:46" resolution="Fixed">
		<buginformation>
			<summary>AclPermissionCacheOptimizer should not attempt to load Acls for empty object list</summary>
			<description>BasicLookupStrategy will raise an exception if passed an empty OID list, so we shouldn&amp;amp;apos;t call it if the optimizer is passed an empty collection of objects.</description>
			<version>3.1.0.M1</version>
			<fixedVersion>3.1.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.AclPermissionCacheOptimizer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1553" opendate="2010-09-01 11:30:31" fixdate="2010-09-01 11:34:09" resolution="Fixed">
		<buginformation>
			<summary>WebAuthenticationDetails should be Serializable</summary>
			<description></description>
			<version>3.1.0.M1</version>
			<fixedVersion>3.1.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.WebAuthenticationDetails.java</file>
		</fixedFiles>
	</bug>
	<bug id="1578" opendate="2010-09-23 21:09:36" fixdate="2010-10-04 19:34:33" resolution="Complete">
		<buginformation>
			<summary>ThreadLocalSecurityContextHolderStrategy.clearContext() should use ThreadLocal.remove()</summary>
			<description>It appears that calling ThreadLocal.set(null) causes some memory problems that can be fixed as of JDK 1.5 using ThreadLocal.remove() It may be wise to update ThreadLocalSecurityContextHolderStrategy.clearContext() to use remove now that Spring Security relies on JDK 1.5. This is also consistent with other portions of Spring https://jira.springsource.org/browse/SPR-7441</description>
			<version>3.0.3</version>
			<fixedVersion>3.0.4, 3.1.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.core.context.InheritableThreadLocalSecurityContextHolderStrategy.java</file>
			<file type="M">org.springframework.security.core.context.ThreadLocalSecurityContextHolderStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="1577" opendate="2010-09-23 08:22:50" fixdate="2010-10-15 09:52:57" resolution="Duplicate">
		<buginformation>
			<summary>NPE in AuthorityUtils in combination with RoleHierarchy and User with empty authorities collection</summary>
			<description>If have the following intercept-url defined in my security config (with expressions):
&amp;lt;security:intercept-url pattern="/.*/$
{webapp.context}
/flow/welcome" access="hasRole(&amp;amp;apos;ROLE_USER&amp;amp;apos;)" /&amp;gt;
I also use role hierarchies.  After authentication the user arrives at the welcome page.  When the user hasn&amp;amp;apos;t got any authorities, I receive a NPE because in RoleHierarchyImpl, which is called by SecurityExpressionRoot, the empty authorities Set is set to null:
    public Collection&amp;lt;GrantedAuthority&amp;gt; getReachableGrantedAuthorities(Collection&amp;lt;GrantedAuthority&amp;gt; authorities) {
        if (authorities == null || authorities.isEmpty()) 
{
            return null;
        }

In AuthorityUtils, the size() method is called on the null collection:
    public static Set&amp;lt;String&amp;gt; authorityListToSet(Collection&amp;lt;GrantedAuthority&amp;gt; userAuthorities) {
        Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;String&amp;gt;(userAuthorities.size());
java.lang.NullPointerException
	at org.springframework.security.core.authority.AuthorityUtils.authorityListToSet(AuthorityUtils.java:39)
	at org.springframework.security.access.expression.SecurityExpressionRoot.getAuthoritySet(SecurityExpressionRoot.java:104)
	at org.springframework.security.access.expression.SecurityExpressionRoot.hasAnyRole(SecurityExpressionRoot.java:44)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.springframework.expression.spel.support.ReflectiveMethodExecutor.execute(ReflectiveMethodExecutor.java:58)
	at org.springframework.expression.spel.ast.MethodReference.getValueInternal(MethodReference.java:76)
	at org.springframework.expression.spel.ast.SpelNodeImpl.getTypedValue(SpelNodeImpl.java:102)&amp;lt;security:intercept-url pattern="/.*</description>
			<version>3.0.3</version>
			<fixedVersion>3.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl.java</file>
			<file type="M">org.springframework.security.access.hierarchicalroles.RoleHierarchyImplTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1507</link>
		</links>
	</bug>
	<bug id="1584" opendate="2010-10-04 04:33:41" fixdate="2010-10-27 09:41:22" resolution="Fixed">
		<buginformation>
			<summary>Path parameters should be stripped from pathInfo and servletPath before matching</summary>
			<description>RFC 2396 defines parameters which can occur in any of the path segments of a URL, after a semi-colon character. The servlet spec refers to these as "path parameters" and is not consistent on whether they should be removed from the decoded values returned by HttpServletRequest,getServletPath() and HttpServletRequest,getPathInfo(). As a result, different servlet containers treat the issue differently. Tomcat does not include path parameter values, but Websphere apparently does.
Path parameters should be removed before matching against a secured Ant path pattern (which uses the concatenated servletPath + pathInfo). They complicate the process of pattern matching and make it harder to account for all possible URL values which an attacker could submit. In practice they are rarely used within an application, though most users will be familiar with the addition of a jsessionid parameter to URLs. 
As an example, if an application defined a secured path as "/secure/*", then to account for the possibility of path parameters, the pattern would actually have to be "/secure/**", otherwise a path such as "/secure;x=y/file" could be used to bypass the match. In cases where a trailing wildcard is not used, it could be possible to add a parameter which caused a different match to take place. For example with this configuration:






&amp;lt;intercept-url path="*user.jsp" access="user" /&amp;gt;




&amp;lt;intercept-url path="/admin/**" access="admin" /&amp;gt; 






A user could potentially gain admin access by submitting a request to "/admin/securedFile.jsp;x=user.jsp".</description>
			<version>2.0.5</version>
			<fixedVersion>3.0.4, 2.0.6, 3.1.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandler.java</file>
			<file type="M">org.springframework.security.config.Elements.java</file>
			<file type="M">org.springframework.security.config.debug.DebugFilter.java</file>
			<file type="M">org.springframework.security.config.FilterChainProxyConfigTests.java</file>
			<file type="M">org.springframework.security.web.FilterChainProxy.java</file>
		</fixedFiles>
	</bug>
	<bug id="1583" opendate="2010-10-04 02:01:49" fixdate="2010-10-27 09:43:15" resolution="Fixed">
		<buginformation>
			<summary>wrong info in Docs</summary>
			<description>from Docs http://static.springsource.org/spring-security/site/docs/3.0.x/reference/ns-config.html
@PreAuthorize("hasAuthority(&amp;amp;apos;ROLE_TELLER&amp;amp;apos;)")
but "hasAuthority" is wrong. work around is to use "hasRole" instead.
&amp;lt;intercept-url pattern="/login.jsp*" access="IS_AUTHENTICATED_ANONYMOUSLY"/&amp;gt; also is not working.
java.lang.IllegalArgumentException: Failed to evaluate expression &amp;amp;apos;IS_AUTHENTICATED_ANONYMOUSLY&amp;amp;apos;
work around is to use:
&amp;lt;intercept-url pattern="/login.jsp*" access="permitAll" /&amp;gt;
</description>
			<version>3.0.3</version>
			<fixedVersion>3.0.4, 3.1.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.expression.SecurityExpressionRootTests.java</file>
			<file type="M">org.springframework.security.access.expression.SecurityExpressionRoot.java</file>
		</fixedFiles>
	</bug>
	<bug id="1543" opendate="2010-08-18 07:13:48" fixdate="2010-10-27 09:45:54" resolution="Fixed">
		<buginformation>
			<summary>IpAddressMatcher does not act like expected</summary>
			<description>When configuring a constraint like "hasIpAddress(&amp;amp;apos;X.X.X.X&amp;amp;apos;)", Spring-Security usees the class org.springframework.security.web.util.IpAddressMatcher to compare the given IP with the IP from the request.
Unfortunatly, IpAddressMatcher throws an IllegalArgumentException, when the given IP and the IP from the request are of different type. This happens for example, when the request uses an IPv6-Address, but the Address used in "hasIpAddress()" was an IPv4-Address. The unexpected outcome of this behavior is, that any IPv6-request matching the resource will only see an error-page!
I suggest, that IpAddressMatcher responds with "false", if the given Address and the Address in the Request are of different type. That would solve this issue and is also the behavior I would expect: two IP-Addresses of different type are simply always not equal!</description>
			<version>3.0.2</version>
			<fixedVersion>3.0.4, 3.1.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.util.IpAddressMatcher.java</file>
		</fixedFiles>
	</bug>
	<bug id="1607" opendate="2010-11-02 04:08:53" fixdate="2010-11-02 04:21:00" resolution="Fixed">
		<buginformation>
			<summary>Spring Security version checking reports Spring Version instead of Spring Security version</summary>
			<description></description>
			<version>3.0.4</version>
			<fixedVersion>3.0.5, 3.1.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.core.SpringSecurityCoreVersion.java</file>
		</fixedFiles>
	</bug>
	<bug id="1608" opendate="2010-11-02 04:44:29" fixdate="2010-11-02 05:20:17" resolution="Fixed">
		<buginformation>
			<summary>FirewalledRequest.reset() is not called for a resource with no filters</summary>
			<description></description>
			<version>3.0.4</version>
			<fixedVersion>3.0.5, 3.1.0.M2, 2.0.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.FilterChainProxyTests.java</file>
			<file type="M">org.springframework.security.web.FilterChainProxy.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1838</link>
			<link type="Duplicate" description="is duplicated by">1614</link>
			<link type="Relate" description="is related to">1606</link>
		</links>
	</bug>
	<bug id="1590" opendate="2010-10-12 06:30:37" fixdate="2010-11-02 12:51:12" resolution="Fixed">
		<buginformation>
			<summary>WebAuthenticatonDetails.doPopulateAdditionalInformation should be removed</summary>
			<description>I have a class that extends org.springframework.security.web.authentication.WebAuthenticationDetails class and implements org.springframework.security.core.authority.GrantedAuthoritiesContainer.
It overrides the method doPopulateAdditionalInformation to retrieve the additional information from the request headers.
When running the application I receive an illegalArgumentException thrown from Assert.notNull, with the message "Cannot pass a null GrantedAuthority collection".
Investigating this showed that the WebAuthenticationDetails constructor calls doPopulateAdditionalInformation as its last step, this does initialize my members with correct values, but after the constructor returns, my derived class constructor gets called, re-initializing the fields again, re-setting my List&amp;lt;GrantedAuthority&amp;gt; back to null.
</description>
			<version>3.0.3</version>
			<fixedVersion>3.1.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.WebAuthenticationDetails.java</file>
		</fixedFiles>
	</bug>
	<bug id="1606" opendate="2010-11-01 14:46:17" fixdate="2010-11-03 13:48:07" resolution="Complete">
		<buginformation>
			<summary>FirewalledRequest.reset() not called when Filters in the FilterChainProxy do not complete the FilterChain</summary>
			<description>When the FilterChain is not completed within FilterChainProxy, FirewalledRequest.reset() is not called. This can cause the wrong pathInfo and servletPath to be exposed when a forward or include is performed within the FilterChainProxy&amp;amp;apos;s filters and using DefaultHttpFirewall. The reason is because the pathInfo and the servletPath are still cached from the original request and reset was never called.
The following configuration will demonstrate the issue. When an invalid username/password is submitted, the request is forwarded to /login.jsp?login_error=1. However, when the JspServlet attempts to process the URL it sees the HttpServeltRequest.servletPath as RequestWrapper.strippedServletPath (/j_spring_security_check) instead of the new servletPath /login.jsp. 
&amp;lt;http auto-config="true"&amp;gt;
  &amp;lt;intercept-url pattern="/admin/secure.jsp" access="ROLE_ADMIN"/&amp;gt;
  &amp;lt;form-login login-page="/login.jsp" authentication-failure-handler-ref="afh"/&amp;gt;		
&amp;lt;/http&amp;gt;	
&amp;lt;b:bean id="afh" class="org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler"
  p:defaultFailureUrl="/login.jsp?login_error=1"  
  p:useForward="true"/&amp;gt;
&amp;lt;authentication-manager&amp;gt;
  &amp;lt;authentication-provider&amp;gt;
    &amp;lt;user-service&amp;gt;
      &amp;lt;user name="un" password="pwd" authorities="ROLE_ADMIN"/&amp;gt;
    &amp;lt;/user-service&amp;gt;
  &amp;lt;/authentication-provider&amp;gt;
&amp;lt;/authentication-manager&amp;gt;
I have not yet validated this occurs in 3.1.0.M2 but marked it as impacted to ensure it at least gets looked at.</description>
			<version>2.0.6</version>
			<fixedVersion>3.0.5, 3.1.0.M2, 2.0.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.firewall.RequestWrapperTests.java</file>
			<file type="M">org.springframework.security.web.firewall.RequestWrapper.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1633</link>
			<link type="Relate" description="relates to">1608</link>
		</links>
	</bug>
	<bug id="1614" opendate="2010-11-05 05:36:57" fixdate="2010-11-10 04:00:27" resolution="Duplicate">
		<buginformation>
			<summary>Status 404 with Apache Tiles</summary>
			<description>We use Apache Tiles 2.1.4 to render our pages. After we&amp;amp;apos;ve upgraded to Spring Security 3.0.4 we received a "HTTP Status 404" error page from tomcat when accessing some pages.
When we use a custom HttpFirewall and FirewalledRequest, which does nothing, the errors disappear.
As far as I found out all pages are impacted which are "excluded" from Spring Security&amp;amp;apos;s FilterChainProxy, as our login and logout pages for example.
I think that issue is related to SEC-1608. 
Tiles does various forwards/includes during the rendering phase which (obviously) will change the ServletPath and PathInfo
To track down the error, I&amp;amp;apos;ve developed a custom "RequestWrapper" which outputs the original and stripped version of the ServletPath and PathInfo:
Constructor - StrippedServletPath: /main - StrippedPathInfo: /login/login.htm
getServletPath() - stripPaths: true - strippedServletPath: /main - servletPath: /main
getPathInfo() - stripPaths: true - strippedPathInfo: /login/login.htm - pathInfo: /login/login.htm
getServletPath() - stripPaths: true - strippedServletPath: /main - servletPath: /main
getServletPath() - stripPaths: true - strippedServletPath: /main - servletPath: /main
getServletPath() - stripPaths: true - strippedServletPath: /main - servletPath: /main
getPathInfo() - stripPaths: true - strippedPathInfo: /login/login.htm - pathInfo: /login/login.htm
getServletPath() - stripPaths: true - strippedServletPath: /main - servletPath: /WEB-INF/layouts/plain.jsp
As you can see at the end of the request the "strippedServletPath" and "servletPath" are different while "stripPaths" is still true. Therefore the "wrong" stripped ServletPath gets returned and Tiles fails to render the response correctly.
getPathInfo() - stripPaths: true - strippedPathInfo: /login/login.htm - pathInfo: null</description>
			<version>3.0.4</version>
			<fixedVersion>3.1.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.FilterChainProxyTests.java</file>
			<file type="M">org.springframework.security.web.FilterChainProxy.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1608</link>
		</links>
	</bug>
	<bug id="1587" opendate="2010-10-07 01:19:07" fixdate="2010-11-10 05:06:31" resolution="Fixed">
		<buginformation>
			<summary>HttpSessionSecurityContextRepository should clear session context when current context is anonmous or empty</summary>
			<description>I have written a LogoutFilter which does not redirect to a logout page. It just logs out the user and goes on with the filter chain.
(it&amp;amp;apos;s needed because we have different areas and the user should be logged out when switching to another "area")
Before it comes to saving the security context with HttpSessionSecurityContextRepository the anonymousFilter sets an AnonymousAuthentication. So when it comes to saving the context, it is not saved.
This is because of this code in HttpSessionSecurityContextRepository
protected void saveContext(SecurityContext context) {
            // See SEC-776
   if (authenticationTrustResolver.isAnonymous(context.getAuthentication())) {
                if (logger.isDebugEnabled()) 
{
                    logger.debug("SecurityContext contents are anonymous - context will not be stored in HttpSession. ");
                }
                return;
    }
BTW my LogoutFilter is configured with invalidateHttpSession=false otherwise this bug wouldn&amp;amp;apos;t occur i guess.
So imho, there should be another check to see what is actually saved in the session.
regards
Janning</description>
			<version>3.0.3</version>
			<fixedVersion>3.0.5, 3.1.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.HttpSessionSecurityContextRepositoryTests.java</file>
			<file type="M">org.springframework.security.web.context.HttpSessionSecurityContextRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="1561" opendate="2010-09-07 09:21:50" fixdate="2010-11-10 05:08:38" resolution="Fixed">
		<buginformation>
			<summary>HttpSecurityContextRepository fails to store security context to a newly authenticated session</summary>
			<description>When a second (or later subsequent) authentication attempt arrives on an already authenticated session and session attribute migration is disabled the security context is not always persisted to the new session.
With an existing authenticated session, subsequent POST requests to the form-login login-processing url will destroy the old session and create a new session. Occasionally the hash code of the persisted security context does not change and so the HttpSecurityContextRepository does not "update" the context stored in the session. The problem is that the old session held the unchanged security context but the new session does not hold any security context. After successfully authenticating another authentication is required because the new session does not contain a SecurityContext.
One factor causing the HttpSecurityContextRepository to not update/store the SecurityContext is that the session id stored in the security context is the old session id, even after that session has been destroyed and a new one created to replace it. This allows the SecurityContext hashCode to remain the same even though some aspect of the SecurityContext has indeed changed.
The check to set the security context attribute in HttpSecurityContextRepository.SaveToSessionResponseWrapper.saveContext should probably include something to ensure that the current session actually does contain the context, whether it has changed or not. In the case that the context has not changed, but the session has, the context should be stored to the new session.</description>
			<version>3.0.1</version>
			<fixedVersion>3.0.5, 3.1.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.HttpSessionSecurityContextRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="1628" opendate="2010-11-20 12:35:49" fixdate="2010-11-24 07:27:00" resolution="Duplicate">
		<buginformation>
			<summary>add authentication-success-handler to &lt;remember-me&gt; tag</summary>
			<description>We are using an AuthenticationSuccessHandler to post-process login information to cache attributes into the HttpSession (we&amp;amp;apos;re using a third-party servlet that can handle some database queries by itself but needs the appropriate keys, etc.).  However, after a remember-me login, there is no way to insert a success handler to perform the appropriate initialization for the new session.
It would be helpful to have an authentication-success-handler-ref attribute on the &amp;lt;remember-me&amp;gt; tag analogous to the attribute on the &amp;lt;*-login&amp;gt; tags, triggered after the RememberMeServices handles a persistent login.
(The forum link is not my post, but there appears to be a significant desire for this feature.)</description>
			<version>3.1.0.M1</version>
			<fixedVersion>3.1.0.RC1</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.RememberMeBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1603</link>
		</links>
	</bug>
	<bug id="1418" opendate="2010-02-23 21:24:53" fixdate="2010-12-06 04:56:50" resolution="Fixed">
		<buginformation>
			<summary>equals of GrantedAuthorityImpl isn&amp;apos;t symmetric</summary>
			<description>The implementation of equals in GrantedAuthorityImpl returns true if it sees a String with the same content as its role field. So
new GrantedAuthorityImpl("ROLE_ADMIN").equals("ROLE_ADMIN") will return true, but "ROLE_ADMIN".equals(new GrantedAuthorityImpl("ROLE_ADMIN")) won&amp;amp;apos;t!
The equals method is required to be symetric, but this implementation isn&amp;amp;apos;t symmetric.
Apart from that equals should be final or test explicit for GrantedAuthorityImpl.class. Using instanceof in non-final classes with a non-final equals method is not ok.
Please read: Joshua Bloch - Effective Java - Second Edition - Item 8 Page 33 following.
I attached a SimpleGrantedAuthority.java which uses a very save implementation. This class is final. I know that GrantedAuthorityImpl has subclasses, but it should be consindered if the trivial sharing of the role field justify the equals problems. It always very difficult to design proper equals and hashCode for subclassable classes.
Since GrantedAuthorityImpl is really a value class like String, it should be really final and immutable like String itself.</description>
			<version>3.0.2</version>
			<fixedVersion>3.1.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.authentication.jaas.JaasGrantedAuthority.java</file>
			<file type="M">org.springframework.security.acls.jdbc.BasicLookupStrategyTests.java</file>
			<file type="M">org.springframework.security.taglibs.velocity.AuthzImplAuthorizeTagTest.java</file>
			<file type="M">org.springframework.security.provisioning.JdbcUserDetailsManagerTests.java</file>
			<file type="M">org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl.java</file>
			<file type="M">org.springframework.security.acls.domain.AclImplementationSecurityCheckTests.java</file>
			<file type="M">org.springframework.security.core.authority.mapping.SimpleAttributes2GrantedAuthoritiesMapper.java</file>
			<file type="M">org.springframework.security.ldap.userdetails.LdapUserDetailsManager.java</file>
			<file type="M">org.springframework.security.web.authentication.switchuser.SwitchUserGrantedAuthority.java</file>
			<file type="M">org.springframework.security.ldap.userdetails.LdapUserDetailsMapper.java</file>
			<file type="M">org.springframework.security.cas.userdetails.GrantedAuthorityFromAssertionAttributesUserDetailsService.java</file>
			<file type="M">org.springframework.security.config.ldap.LdapUserServiceBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.access.vote.ConsensusBasedTests.java</file>
			<file type="M">org.springframework.security.acls.sid.SidTests.java</file>
			<file type="M">org.springframework.security.web.authentication.AnonymousAuthenticationFilterTests.java</file>
			<file type="M">org.springframework.security.authentication.AbstractAuthenticationTokenTests.java</file>
			<file type="M">org.springframework.security.cas.authentication.CasAuthenticationProviderTests.java</file>
			<file type="M">org.springframework.security.acls.jdbc.EhCacheBasedAclCacheTests.java</file>
			<file type="M">org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapperTest.java</file>
			<file type="M">org.springframework.security.web.authentication.switchuser.SwitchUserFilterTests.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AuthorizeTagAttributeTests.java</file>
			<file type="M">org.springframework.security.authentication.anonymous.AnonymousAuthenticationProviderTests.java</file>
			<file type="M">org.springframework.security.core.authority.GrantedAuthorityImpl.java</file>
			<file type="M">org.springframework.security.provisioning.JdbcUserDetailsManager.java</file>
			<file type="D">org.springframework.security.core.authority.GrantedAuthorityImplTests.java</file>
			<file type="M">org.springframework.security.cas.authentication.CasAuthenticationTokenTests.java</file>
			<file type="M">org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator.java</file>
			<file type="M">org.springframework.security.core.userdetails.memory.UserAttribute.java</file>
			<file type="M">org.springframework.security.core.authority.mapping.MapBasedAttributes2GrantedAuthoritiesMapper.java</file>
			<file type="M">org.springframework.security.taglibs.velocity.AuthzImplAttributeTest.java</file>
			<file type="M">org.springframework.security.performance.FilterChainPerformanceTests.java</file>
			<file type="M">org.springframework.security.access.intercept.RunAsManagerImpl.java</file>
			<file type="M">org.springframework.security.acls.domain.AclImplTests.java</file>
			<file type="M">org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl.java</file>
			<file type="M">org.springframework.security.core.authority.AuthorityUtils.java</file>
			<file type="M">org.springframework.security.authentication.jaas.JaasAuthenticationProviderTests.java</file>
			<file type="M">org.springframework.security.access.intercept.RunAsImplAuthenticationProviderTests.java</file>
			<file type="M">org.springframework.security.core.userdetails.UserTests.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AuthorizeTagExpressionLanguageTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1633" opendate="2010-12-04 23:15:40" fixdate="2010-12-08 06:01:26" resolution="Duplicate">
		<buginformation>
			<summary>jsp:forward goes into a loop</summary>
			<description>I wanted to upgrade to Spring Security 2.0.6 from Spring Security 2.0.5. That is upgrade one minor version up. I use struts 1.3.10. When I replaced the 4 jar files with the ones from 2.0.6, I started getting strange error messages from Struts saying that no action path could be found. 
The following are the 4 jars that I replace with the 2.0.6 versions.
spring-security-acl-2.0.5.RELEASE.jar
spring-security-core-2.0.5.RELEASE.jar
spring-security-core-tiger-2.0.5.RELEASE.jar
spring-security-taglibs-2.0.5.RELEASE.jar
After trying various things unsuccessfully, I decided to create a bare bones functional project and try my upgrade there.
What I discovered is that 2.0.6 appears to have problems dealing with jsp forward. In 2.0.5 things work fine but 2.0.6 things go into a loop while running inside of Eclipse/Tomcat 5.5.
I create a fresh Eclipse Dynamic Web project. I add an index.jsp which has one line to perform a jsp:forward to another .jsp page. I tested with no Spring and it works as expected. I then introduce Spring Security 2.0.5 and Spring 2.5.5 into the mix and things still work as expected. (Index.jsp has intercept-url has filters=none).
I then replace the above mentioned 4 files with the 2.0.6 versions. Then when I try to navigate to the index.jsp via browser (Fire Fox 3.6.12), the tomcat server goes into a loop spewing out a very large stack trace.
I&amp;amp;apos;m attaching the eclipse project as well as the tomcat log file.
The main reason I wanted to upgrade to 2.0.6 is because for some reason, I am not able to get "access-denied-page" attribute to work on the http element.</description>
			<version>2.0.6</version>
			<fixedVersion>3.1.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.firewall.RequestWrapperTests.java</file>
			<file type="M">org.springframework.security.web.firewall.RequestWrapper.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1606</link>
		</links>
	</bug>
	<bug id="1639" opendate="2010-12-16 10:17:17" fixdate="2010-12-17 08:33:37" resolution="Complete">
		<buginformation>
			<summary>VirtualFilterChain.resetWrapper does not handle nested FilterChainProxy&amp;apos;s</summary>
			<description>Since VirtualFilterChain.resetWrapper breaks on the first FirewalledRequest it doesn&amp;amp;apos;t handle nested FilterChainProxy&amp;amp;apos;s (i.e. new RequestWrapper(new RequestWrapper(originalRequest)) ). My current thought on fixing this is to pass in the actual FirewalledRequest into the constructor of the VirtualFilterChain and call reset on it. This would ensure the correct one gets called. It also eliminates the need for looping.
A workaround is to place a Filter that calls the following reset method as the first filter for forwarded requests.
public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException {
  while (request instanceof ServletRequestWrapper) {
    if (request instanceof FirewalledRequest) 
{
      ((FirewalledRequest)request).reset();
    }
    request = ((ServletRequestWrapper)request).getRequest();
  }
}
Example Mapping 
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;fixSSFilter&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
        &amp;lt;dispatcher&amp;gt;FORWARD&amp;lt;/dispatcher&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;</description>
			<version>2.0.6</version>
			<fixedVersion>3.1.0.M2, 3.0.6, 2.0.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.FilterChainProxy.java</file>
			<file type="M">org.springframework.security.web.FilterChainProxyTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1603" opendate="2010-10-26 17:18:01" fixdate="2011-01-06 08:00:29" resolution="Complete">
		<buginformation>
			<summary>Add authentication-success-handler-ref attribute to &lt;remember-me&gt; tag</summary>
			<description>IMHO, I think it would be extremely helpful to some web developers to be able to specify a specific page to be loaded when a user is "logged in" via rememberMeServices, right out of the box. This is especially true for developers who set the always-use-default-target="true" in the &amp;lt;form-login&amp;gt; tag.  If you want the &amp;lt;remember-me&amp;gt; tag to act in the same manor, the learning curve gets pretty steep.
It would also be useful if the user&amp;amp;apos;s session always needs to be re-iniated by the web application after an expired session.  Having the target-url go to a page the tells the user their session has expired, they are being redirected to a "start page", and automatically logged-in is helpful.</description>
			<version>3.1.0.M2</version>
			<fixedVersion>3.1.0.RC1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.RememberMeBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1628</link>
		</links>
	</bug>
	<bug id="1653" opendate="2011-01-10 14:48:39" fixdate="2011-01-10 16:21:49" resolution="Complete">
		<buginformation>
			<summary>spring security sample war config &lt; remember-me / &gt; fails to properly register the requested bean</summary>
			<description>spring security config : &amp;lt; remember-me / &amp;gt; yields an error "Factory bean &amp;amp;apos;org.springframework.security.userDetailsServiceFactory&amp;amp;apos; not found".
this can be reproduced by import spring-security-samples-tutorial-3.1.0.M2.war from spring 3.1.0.M2 distribution on a freshly installed STS 2.5.1 installer from the spring website. After import -&amp;gt; war, add spring nature and enable "Load NameSpaceHandlers and XSDs from projects classpath" from project properties.</description>
			<version>3.1.0.M2</version>
			<fixedVersion>3.1.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1545" opendate="2010-08-20 09:10:00" fixdate="2011-01-21 11:26:45" resolution="Fixed">
		<buginformation>
			<summary>Missing I18N Keys in messages.properties</summary>
			<description>spring-security-core&amp;amp;apos;s default message.properties is missing at least one i18n key (LdapAuthenticationProvider.badCredentials).
I haven&amp;amp;apos;t gotten time to look for others, and it would be nice to address other potentials. Unless the bug assignee beats me to it, in the next couple days I can write a quick script that will get all the missing ones. I will then post a patch for the messages that I can do (i.e. if there isn&amp;amp;apos;t already a translation I probably cannot submit a fix for that language).
Anyone viewing this bug can easily work around this issue by providing their own message.properties as outlined in the spring security reference [1].
[1] http://static.springsource.org/spring-security/site/docs/3.0.x/reference/technical-overview.html#localization</description>
			<version>3.0.3</version>
			<fixedVersion>3.1.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.LdapAuthenticationProvider.java</file>
			<file type="M">org.springframework.security.web.authentication.session.ConcurrentSessionControlStrategy.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.x509.SubjectDnX509PrincipalExtractor.java</file>
			<file type="M">org.springframework.security.core.SpringSecurityMessageSourceTests.java</file>
			<file type="M">org.springframework.security.acls.afterinvocation.AclEntryAfterInvocationProvider.java</file>
			<file type="M">org.springframework.security.ldap.authentication.BindAuthenticator.java</file>
			<file type="M">org.springframework.security.authentication.AccountStatusUserDetailsChecker.java</file>
		</fixedFiles>
	</bug>
	<bug id="1662" opendate="2011-01-26 02:59:57" fixdate="2011-01-26 09:46:39" resolution="Fixed">
		<buginformation>
			<summary>NPE when when defining two &lt;http&gt; elements during registerFilterChainProxy</summary>
			<description>I am defining two &amp;lt;http&amp;gt; elements which apparently is permitted in Spring Security 3.1.0M2 per documentation
    &amp;lt;http auto-config="false" entry-point-ref="http403ForbiddenEntryPoint"&amp;gt;
        &amp;lt;intercept-url pattern="/api/**" access="ROLE_USER"/&amp;gt;
        &amp;lt;custom-filter ref="apikeyAuthFilter" position="FORM_LOGIN_FILTER"/&amp;gt;
    &amp;lt;/http&amp;gt;
    &amp;lt;http auto-config="false"&amp;gt;
        &amp;lt;form-login/&amp;gt;
        &amp;lt;intercept-url pattern="/**" access="ROLE_USER"/&amp;gt;
        &amp;lt;logout invalidate-session="true"/&amp;gt;
    &amp;lt;/http&amp;gt;
During startup I get an NPE, partial stack trace below.
Caused by: java.lang.NullPointerException
	at org.springframework.security.config.http.HttpSecurityBeanDefinitionParser.registerFilterChainProxy(HttpSecurityBeanDefinitionParser.java:260)
	at org.springframework.security.config.http.HttpSecurityBeanDefinitionParser.parse(HttpSecurityBeanDefinitionParser.java:89)
	at org.springframework.security.config.SecurityNamespaceHandler.parse(SecurityNamespaceHandler.java:88)
	at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1335)
	at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1325)
	at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:135)
	at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:93)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:493)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:390)
	... 37 more
Relevant code area
            for (BeanDefinition matcherBean : filterChainMap.keySet()) {
                if (existingFilterChainMap.containsKey(matcherBean)) {
                    Map&amp;lt;Integer,ValueHolder&amp;gt; args = matcherBean.getConstructorArgumentValues().getIndexedArgumentValues();
                    pc.getReaderContext().error("The filter chain map already contains this request matcher ["
---&amp;gt;                            + args.get(0).getValue() + ", " +args.get(1).getValue() + "]", source);
args is size 0 in my case
Serge</description>
			<version>3.1.0.M2</version>
			<fixedVersion>3.1.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="1592" opendate="2010-10-13 08:22:21" fixdate="2011-01-27 08:52:41" resolution="Complete">
		<buginformation>
			<summary>CAS proxy receptor requests must not pass through the filter chain</summary>
			<description>I configured spring-security-cas in my webapp for generating proxy tickets.
During ticket validation we provide a pgtUrl parameter and then the CAS server tries
to connect to our webapp (using the configured proxyReceptorUrl) to determine is this
URL is a valid end-point but it result in a 404 because the request is passed trough
the servlet but is not handled (because no controller is mapped for this URL).
If we set the grails.plugins.springsecurity.rejectIfNoRule parameter [1] to true or if I mark this
proxy receptor URL with the role "IS_AUTHENTICATED_REMEMBERED" then it works:

the ping request [2] result in a 302 (redirection to CAS because the request needs to be authenticated)
the pgtId/pgtIou request result also in a 302 (therefore without the proper XML fragment) but the mapping is stored

This works because the CAS server is not strict about the expected XML fragment,
only the a proper status code is mandatory [2].
Current workaround is to create a controller for this URL with anonymous access and
always respond with a 200 and some text.
I believe this issue is not related to Grails and may impact any webapp using
spring-security-cas and wanting to generate proxy tickets.
Furthermore, the default behaviour in cas-client [3] is already to stop processing the
request once it has been handled by the Cas20ProxyReceivingTicketValidationFilter [3].
[1] http://burtbeckwith.github.com/grails-spring-security-core/docs/manual/index.html
[2] https://source.jasig.org/cas3/tags/cas-3-3-5-1-final/cas-server-core/src/main/java/org/jasig/cas/authentication/handler/support/HttpBasedServiceCredentialsAuthenticationHandler.java
[2] https://source.jasig.org/cas3/tags/cas-3-3-5-1-final/cas-server-core/src/main/java/org/jasig/cas/util/HttpClient.java
[3] https://source.jasig.org/cas-clients/java-client/tags/cas-client-3.1.12/cas-client-core/src/main/java/org/jasig/cas/client/validation/Cas20ProxyReceivingTicketValidationFilter.java
[3] https://source.jasig.org/cas-clients/java-client/tags/cas-client-3.1.12/cas-client-core/src/main/java/org/jasig/cas/client/validation/AbstractTicketValidationFilter.java</description>
			<version>3.0.2</version>
			<fixedVersion>3.1.0.RC1, 3.0.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.cas.web.CasAuthenticationFilterTests.java</file>
			<file type="M">org.springframework.security.cas.web.CasAuthenticationFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1661" opendate="2011-01-25 13:48:23" fixdate="2011-02-01 10:49:10" resolution="Fixed">
		<buginformation>
			<summary>LDAP search base should not require JNDI escaping in addition to LDAP escaping for special characters</summary>
			<description>Having double quotes in the base dn (search base) does not work.  
The following base dn value is valid, but does not work:

OU="Admin Users",OU=TEST-NC,DC=TESTCustomers,DC=Com

</description>
			<version>3.0.1</version>
			<fixedVersion>3.1.0.RC1, 3.0.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.AbstractLdapIntegrationTests.java</file>
			<file type="M">org.springframework.security.ldap.SpringSecurityLdapTemplate.java</file>
			<file type="M">org.springframework.security.ldap.authentication.BindAuthenticatorTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1670" opendate="2011-02-03 09:45:52" fixdate="2011-02-05 04:11:47" resolution="Fixed">
		<buginformation>
			<summary>SpringSecurityLdapTemplate should use a CompositeName to remove JNDI escaping from SearchResult.getName()</summary>
			<description>SearchResult.getName() returns a CompositeName syntax, so JNDI special characters will be escaped, which we don&amp;amp;apos;t want in a pure-LDAP name. The result should be wrapped in a CompositeName() before passing to the constructor for DistinguishedName. The latter knows how to deal with CompositeNames.
</description>
			<version>3.0.5</version>
			<fixedVersion>3.1.0.RC1, 3.0.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.BindAuthenticator.java</file>
			<file type="M">org.springframework.security.ldap.SpringSecurityLdapTemplate.java</file>
			<file type="M">org.springframework.security.ldap.AbstractLdapIntegrationTests.java</file>
			<file type="M">org.springframework.security.ldap.authentication.BindAuthenticatorTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">950</link>
		</links>
	</bug>
	<bug id="1679" opendate="2011-02-14 10:32:27" fixdate="2011-02-14 13:33:45" resolution="Fixed">
		<buginformation>
			<summary>delete-cookies should trim cookie names</summary>
			<description>If multiple cookie names are supplied, with spaces in the string, then spaces won&amp;amp;apos;t be trimmed , resulting in incorrect cookie names.</description>
			<version>3.1.0.RC1</version>
			<fixedVersion>3.1.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.LogoutBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="1683" opendate="2011-02-23 12:03:51" fixdate="2011-02-28 07:45:36" resolution="Complete">
		<buginformation>
			<summary>Documentation typo for RequestHeaderAuthenticationFilter</summary>
			<description>In the JavaDoc for org.springframework.security.web.authentication.preauth.RequestHeaderAuthenticationFilter, there is a typo for the exceptionIfHeaderMissing property in the class description.</description>
			<version>3.1.0.RC1</version>
			<fixedVersion>3.1.0.RC2, 3.0.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.preauth.RequestHeaderAuthenticationFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1701" opendate="2011-03-25 00:56:02" fixdate="2011-03-25 13:19:44" resolution="Fixed">
		<buginformation>
			<summary>OpenId identifier should be trimmed</summary>
			<description>The authentication fails if a user copy&amp;amp;pastes his OpenId identity and it includes a white sprace at the end.
An additional space is often append by copy it from hmtl pages or emails.
I&amp;amp;apos;ve got this problem with 3.0.4, but I&amp;amp;apos;m sure all other versions are also affected.
Fix would look like this at OpenIDAuthenticationFilter.attemptAuthentication():
String identity = request.getParameter("openid.identity");
if (!StringUtils.hasText(identity)) {
       identity = identity.trim(); // FIX
       String claimedIdentity = obtainUsername(request);
Stracktrace:
org.springframework.security.authentication.AuthenticationServiceException: Unable to process claimed identity &amp;amp;apos;http://alice-franz.myopenid.com/ &amp;amp;apos;
	at org.springframework.security.openid.OpenIDAuthenticationFilter.attemptAuthentication(OpenIDAuthenticationFilter.java:143) ~[org.springframework.security.openid_3.0.4.RELEASE.jar:3.0.4.RELEASE]</description>
			<version>3.0.4</version>
			<fixedVersion>3.1.0.RC2, 3.0.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.openid.OpenIDAuthenticationFilterTests.java</file>
			<file type="M">org.springframework.security.openid.OpenIDAuthenticationFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1705" opendate="2011-03-31 09:06:26" fixdate="2011-03-31 14:04:15" resolution="Fixed">
		<buginformation>
			<summary>Namespace creates spurious OpenIDAuthenticationFilter bean</summary>
			<description></description>
			<version>3.0.5</version>
			<fixedVersion>3.1.0.RC2, 3.0.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1712" opendate="2011-04-08 09:08:37" fixdate="2011-04-08 09:25:10" resolution="Fixed">
		<buginformation>
			<summary>Typo in RegexRequestMatcher class javadoc</summary>
			<description>In RegexRequestMatcher class javadoc instead of "
{@code caseInsentitive}
" it should be "
{@code caseInsensitive}
"</description>
			<version>3.1.0.RC1</version>
			<fixedVersion>3.1.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.util.RegexRequestMatcher.java</file>
		</fixedFiles>
	</bug>
	<bug id="1714" opendate="2011-04-10 22:17:44" fixdate="2011-04-11 11:54:56" resolution="Fixed">
		<buginformation>
			<summary>RegexRequestMatcher&amp;apos;s matches should append question mark after path info and before query</summary>
			<description>





        if (pathInfo != null || query != null) {




            StringBuilder sb = new StringBuilder(url);









            if (pathInfo != null) {




                sb.append(pathInfo);




            }









            if (query != null) {




                sb.append(query);




            }




            url = sb.toString();




        }






should be replaced with something similar to






        if (pathInfo != null || query != null) {




            StringBuilder sb = new StringBuilder(url);









            if (pathInfo != null) {




                sb.append(pathInfo);




            }









            if (query != null) {




                sb.append("?").append(query);




            }




            url = sb.toString();




        }





</description>
			<version>3.1.0.RC1</version>
			<fixedVersion>3.1.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.util.RegexRequestMatcher.java</file>
		</fixedFiles>
	</bug>
	<bug id="1674" opendate="2011-02-08 16:35:01" fixdate="2011-04-14 07:08:51" resolution="Duplicate">
		<buginformation>
			<summary>absolute paths should be allowed for security:form-login and security:logout attributes.</summary>
			<description>absolute paths should be allowed for security:form-login and security:logout attributes.
For instance, login-page doesn&amp;amp;apos;t work with an absolute path.  But if LoginUrlAuthenticationEntryPoint.buildRedirectUrlToLoginPage&amp;amp;apos;s first lines were changed to:
protected String buildRedirectUrlToLoginPage(final HttpServletRequest request, final HttpServletResponse response, final AuthenticationException authException) {
        String loginForm = determineUrlToUseForThisRequest(request, response, authException);
        /** Allow support for absolute URIs */
        if(URI.create(loginForm).isAbsolute()) 
{
            return loginForm;
        }

        // continue on with existing logic
}
Then comes the inevitable question of why would you want to do this.  Consider that someone is using spring-mvc to build an API on domain api.test.com, but a set of non-java, front-end user pages on ui.test.com.  
So, api.test.com performs all database/backend logic.  In this circumstance, if someone were to go to api.test.com directly in their browser, I would possibly want to redirect them to ui.test.com to login (where ui.test.com has a form with method=http://api.test.com&amp;amp;apos;s/login.do or equivalent).  
So in this case, I need to specify:
&amp;lt;security:form-login login-page=http://ui.test.com/login&amp;gt;,
which won&amp;amp;apos;t work unless the above patch (or something similiar) is implemented.
</description>
			<version>3.0.5</version>
			<fixedVersion>3.1.0.RC2</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.logout.SimpleUrlLogoutSuccessHandlerTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1699" opendate="2011-03-17 19:53:31" fixdate="2011-04-14 10:05:44" resolution="Fixed">
		<buginformation>
			<summary>DefaultFilterChainValidator&amp;apos;s check if login page isn&amp;apos;t protected is broken</summary>
			<description>DefaultFilterChainValidator near the end of checkLoginPageIsntProtected method issues a call to






fsi.getAccessDecisionManager().decide(token, new Object(), attributes);






which throws exception






java.lang.ClassCastException: java.lang.Object cannot be cast to org.springframework.security.web.FilterInvocation






AccessDecisionManager is org.springframework.security.access.vote.AffirmativeBased and when it asks
org.springframework.security.web.access.expression.WebExpressionVoter to vote passing Object instead of FilterInvocation, ClassCastException is thrown.
Probably either AffirmativeBased AccessDecisionManager should first check if voter(s) support Object.class before giving them chance to vote, or DefaultFilterChainValidator should pass in FilterInvocation when checking in web environment.</description>
			<version>3.1.0.RC1</version>
			<fixedVersion>3.1.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.DefaultFilterChainValidator.java</file>
		</fixedFiles>
	</bug>
	<bug id="1700" opendate="2011-03-23 13:01:30" fixdate="2011-04-20 06:50:44" resolution="Fixed">
		<buginformation>
			<summary>IOException in JaasAuthenticationProvider when loginConfig is a classpath resource in JBoss 5.1.0.GA</summary>
			<description>Here is a snippet of my security config file showing my declaration of the JaasAuthenticationProvider:
&amp;lt;b:bean id="jaasAuthenticationProvider" class="org.springframework.security.authentication.jaas.JaasAuthenticationProvider"&amp;gt;
    &amp;lt;b:property name="loginConfig" value="classpath:auth.conf" /&amp;gt;
    ...
&amp;lt;/b:bean&amp;gt;
Here is the exception thrown when starting up the application:
org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;jaasAuthenticationProvider&amp;amp;apos; defined in class path resource [applicationContext-security.xml]: Invocation of init method failed; nested exception is java.io.IOException: File resolution not supported for nested resource: ZipEntryHandler@30251001[path=application.ear/application-main-4.5.0.jar/auth.conf context=file:/C:/tools/jboss-5.1.0.GA/server/default/deploy/ real=file:/C:/tools/jboss-5.1.0.GA/server/default/deploy/application.ear/application-main-4.5.0.jar/auth.conf]
        at org.springframework.beans.factory.access.SingletonBeanFactoryLocator.useBeanFactory(SingletonBeanFactoryLocator.java:389)
Digging through the Spring code, I found that the exception is being thrown from the getFile() method of VfsUtils, which is called from VfsResource.getFile(). Apparently under JBoss, the classpath resource is resolved to a VfsResource. The first line of the method JaasAuthenticationProvider.convertLoginConfigToUrl() calls loginConfig.getFile().getAboslutePath(). Looking at the code in VfsUtils, it appears that the version of the JBoss VFS used with JBoss 5 doesn&amp;amp;apos;t support the getFile() method, and throws the IOException noted above.
Even if it weren&amp;amp;apos;t for this problem, the code in JaasAuthenticationProvider.convertLoginConfigToUrl() appears to assume that the loginConfig is a file in the file system. Any other type of resource looks as though it would not work.
To test this theory, I wrote a subclass of JaasAuthenticationProvider, and replaced the convertLoginConfigToUrl method with the following code:
    private String convertLoginConfigToUrl() throws IOException 
{
        return getLoginConfig().getURL().toString();
    }

This solved my problem.</description>
			<version>3.0.5</version>
			<fixedVersion>3.1.0.RC2, 3.0.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.authentication.jaas.JaasGrantedAuthority.java</file>
			<file type="M">org.springframework.security.ldap.userdetails.LdapUserDetailsImpl.java</file>
			<file type="M">org.springframework.security.core.context.SecurityContextImpl.java</file>
			<file type="M">org.springframework.security.core.authority.GrantedAuthoritiesContainerImpl.java</file>
			<file type="M">org.springframework.security.core.session.SessionInformation.java</file>
			<file type="M">org.springframework.security.web.authentication.switchuser.SwitchUserGrantedAuthority.java</file>
			<file type="M">org.springframework.security.access.intercept.RunAsUserToken.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails.java</file>
			<file type="M">org.springframework.security.provisioning.MutableUser.java</file>
			<file type="M">org.springframework.security.web.authentication.WebAuthenticationDetails.java</file>
			<file type="M">org.springframework.security.authentication.jaas.JaasAuthenticationToken.java</file>
			<file type="M">org.springframework.security.authentication.AuthenticationDetails.java</file>
			<file type="M">org.springframework.security.remoting.rmi.ContextPropagatingRemoteInvocation.java</file>
			<file type="M">org.springframework.security.cas.authentication.CasAuthenticationToken.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationToken.java</file>
			<file type="M">org.springframework.security.authentication.rcp.RemoteAuthenticationException.java</file>
			<file type="M">org.springframework.security.core.authority.GrantedAuthorityImpl.java</file>
			<file type="M">org.springframework.security.core.userdetails.User.java</file>
			<file type="M">org.springframework.security.authentication.RememberMeAuthenticationToken.java</file>
			<file type="M">org.springframework.security.ldap.userdetails.InetOrgPerson.java</file>
			<file type="M">org.springframework.security.authentication.UsernamePasswordAuthenticationToken.java</file>
			<file type="M">org.springframework.security.ldap.userdetails.Person.java</file>
			<file type="M">org.springframework.security.core.SpringSecurityCoreVersion.java</file>
			<file type="M">org.springframework.security.cas.authentication.CasAssertionAuthenticationToken.java</file>
			<file type="M">org.springframework.security.core.authority.SimpleGrantedAuthority.java</file>
			<file type="M">org.springframework.security.openid.OpenIDAuthenticationToken.java</file>
			<file type="M">org.springframework.security.authentication.jaas.JaasAuthenticationProvider.java</file>
		</fixedFiles>
	</bug>
	<bug id="1722" opendate="2011-04-21 23:38:03" fixdate="2011-05-03 03:39:57" resolution="Fixed">
		<buginformation>
			<summary>HttpSession Destroyed/Created Event API confusion</summary>
			<description>The api doc of HttpSessionCreatedEvent says:
"Published by the HttpSessionEventPublisher when a HttpSession is destroyed by the container"
is the HttpSessionDestroyedEvent should been fire when HttpSession is destroyed by the container?
http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/index.html</description>
			<version>3.0.0</version>
			<fixedVersion>3.1.0.RC2, 3.0.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.session.HttpSessionCreatedEvent.java</file>
		</fixedFiles>
	</bug>
	<bug id="1752" opendate="2011-05-21 19:43:32" fixdate="2011-05-23 11:07:29" resolution="Fixed">
		<buginformation>
			<summary>Null character appended to TextEncryptor.decrypt(String) results</summary>
			<description>The following test fails:






@Test




public void test() {




	TextEncryptor encryptor = Encryptors.queryableText("password", "salt");




	String encrypted = encryptor.encrypt("6048b75ed560785c");




	String decrypted = encryptor.decrypt(encrypted);




	assertEquals("6048b75ed560785c", decrypted);




}






This is because the value of the decrypted variable has a null byte (%00) at the end.  To get the test to pass, I called trim():






@Test




public void test() {




	TextEncryptor encryptor = Encryptors.queryableText("password", "salt");




	String encrypted = encryptor.encrypt("6048b75ed560785c");




	String decrypted = encryptor.decrypt(encrypted).trim();




	assertEquals("6048b75ed560785c", decrypted);




}






I&amp;amp;apos;m not sure why this is happening at this stage, or the appropriate resolution.  The AesBytesEncryptor is using AES with PKCS5 which should care for padding handling for both encrypt/decrypt operations. I&amp;amp;apos;m puzzled as to why a null byte is being tacked on.
This problem manifested itself in the Greenhouse reference application as a OAuth Signature Verification Failure.  The NUL (%00) byte is the culprit.</description>
			<version>3.1.0.RC2</version>
			<fixedVersion>3.1.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.crypto.codec.Utf8.java</file>
		</fixedFiles>
	</bug>
	<bug id="1751" opendate="2011-05-21 18:43:29" fixdate="2011-05-23 13:31:44" resolution="Fixed">
		<buginformation>
			<summary>Encryptors.queryableText(String String) is not useable in present state</summary>
			<description>The role of Encryptors.queryableText(String, String) is to allow for data to be encrypted for storage, then for the data to be queried against in its encrypted form.  A good example of the need for this is the storage of OAuth Consumer Keys.  Such keys should be encrypted when stored, and need to be queried when applications request authorization.
For this to work, the same message e.g. "6048b75ed560785c" must produce the same cipher text each time e.g. "5e37a66db5d48321050d17365d4f4e6fd217caade54d777bbecf6a458036e34b6fcbf0bebf2aa2a03ca5d5171ba5de7a"
. Unfortunately, this is not happening beyond container restarts since the "shared" initialization vector is initialized each time a queryable TextEncryptor instance is constructed.
The following simple test case demonstrates the issue:






	@Test




	public void test() {




		TextEncryptor encryptor = Encryptors.queryableText("password", "salt");




		System.out.println(encryptor.encrypt("6048b75ed560785c"));




		System.out.println(encryptor.encrypt("6048b75ed560785c"));




	}






Each time this test case is run, across all VM instances, the cipher text should be the same.  If you run it more than once, you&amp;amp;apos;ll see the cipher text change.  This is not correct behavior.
The fix is most likely to not apply an iV at all for a "queryable" TextEncryptor.</description>
			<version>3.1.0.RC2</version>
			<fixedVersion>3.1.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.crypto.encrypt.AesBytesEncryptor.java</file>
			<file type="M">org.springframework.security.crypto.encrypt.Encryptors.java</file>
		</fixedFiles>
	</bug>
	<bug id="1733" opendate="2011-05-05 05:18:24" fixdate="2011-06-07 04:17:47" resolution="Fixed">
		<buginformation>
			<summary>IpAddressMatcher doesn&amp;apos;t match 0-bit subnet mask correctly</summary>
			<description>I&amp;amp;apos;m using IpAddressMatcher for address matching outside Spring Security.
Network 0.0.0.0/0 should match to any IP address, but only matches to 0.0.0.0. If mask is given as "0", the matches() method handles the mask as if it was not given at all (or was given as 32). Perhaps differentiate the situations by assigning nMaskBits a null value if it&amp;amp;apos;s not defined at all?
It would also be nice to have a version of the matches() method that takes a String network address instead of a HttpServletRequest as a parameter.
Attached is a diff from my fix.</description>
			<version>3.1.0.RC1</version>
			<fixedVersion>3.1.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.util.IpAddressMatcher.java</file>
			<file type="M">org.springframework.security.web.util.IpAddressMatcherTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1764" opendate="2011-06-13 11:22:07" fixdate="2011-06-14 15:54:56" resolution="Complete">
		<buginformation>
			<summary>z/OS Password Encoding Error</summary>
			<description>Package: org.springframework.security.authentication.encoding
LdapShaPasswordEncoding.java
Fix - line 104:  has been tested with "org.springframework.security.core_3.0.3.RELEASE" on z/OS 1.12
was:        return prefix + new String(Base64.encode(hash));
change:  return prefix + new String(Base64.encode(hash), "UTF-8");
MD4PasswordEncoder.java  also looks like it has same issue.</description>
			<version>3.0.5</version>
			<fixedVersion>3.0.6, 3.1.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.crypto.codec.Utf8.java</file>
			<file type="M">org.springframework.security.authentication.encoding.MessageDigestPasswordEncoder.java</file>
			<file type="M">org.springframework.security.authentication.encoding.Md4PasswordEncoder.java</file>
			<file type="M">org.springframework.security.authentication.encoding.LdapShaPasswordEncoder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1768" opendate="2011-06-17 07:53:44" fixdate="2011-06-18 07:01:30" resolution="Fixed">
		<buginformation>
			<summary>Using the "*" wildcard in intercept-method does not include implemented interfaces</summary>
			<description>Created on behalf of client, with the following use case:
1.  Bean is secured via the intercept-methods tag.
2.  The method attributed of the protect tag is set to "*"
3.  Bean implements an interface and is annotated with @Transactional.
4.  None of the methods on the interface are protected unless the interface is explicitly defined in the method attribute.
In this case only the methods on the bean, not the interface are secured when the method is "".  They feel that in addition to the methods declared on the bean, all implemented interface methods should also be secured when the "" is specified for the method.
Attached is a sample test case illustrating the behavior.</description>
			<version>3.0.5</version>
			<fixedVersion>3.0.6, 3.1.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.method.AbstractMethodSecurityMetadataSource.java</file>
			<file type="M">org.springframework.security.config.TestBusinessBeanImpl.java</file>
			<file type="M">org.springframework.security.config.method.InterceptMethodsBeanDefinitionDecorator.java</file>
			<file type="M">org.springframework.security.config.method.InterceptMethodsBeanDefinitionDecoratorTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1771" opendate="2011-06-25 14:40:21" fixdate="2011-07-04 08:10:59" resolution="Fixed">
		<buginformation>
			<summary>TokenBasedRememberMeServices won&amp;apos;t work with erased credentials</summary>
			<description>TokenBasedRememberMeServices attempts to obtain the user&amp;amp;apos;s password from the Authentication object, after it has been erased by the ProviderManager, meaning that remember-me won&amp;amp;apos;t work. It will probably need to load it from the UserDetailsService when the password isn&amp;amp;apos;t directly available.</description>
			<version>3.1.0.RC2</version>
			<fixedVersion>3.1.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices.java</file>
		</fixedFiles>
	</bug>
	<bug id="1782" opendate="2011-07-11 14:14:22" fixdate="2011-07-11 17:54:33" resolution="Fixed">
		<buginformation>
			<summary>Incorrect Javadoc in LdapAuthenticationProvider</summary>
			<description>This page:
http://static.springsource.org/spring-security/site/docs/3.0.x/apidocs/org/springframework/security/ldap/authentication/LdapAuthenticationProvider.html
Has instructions for wiring up a BindAuthenticator. But the package name of the BindAuthenticator has changed recently. So the package name is now wrong.
In the text BindAuthenticator is here:
org.springframework.security.authentication.ldap.authenticator.BindAuthenticator
But in the latest version it&amp;amp;apos;s actually here:
org.springframework.security.ldap.authentication.BindAuthenticator</description>
			<version>3.0.5</version>
			<fixedVersion>3.0.6, 3.1.0.RC3</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.LdapAuthenticationProvider.java</file>
		</fixedFiles>
	</bug>
	<bug id="1770" opendate="2011-06-24 03:06:11" fixdate="2011-07-13 12:59:39" resolution="Fixed">
		<buginformation>
			<summary>SessionRegistry and refreshLastRequest</summary>
			<description>It seems that refreshLastRequest(String sessionId) in the SessionRegistry class is not called by the security framework anywhere, but refreshLastRequest() is called on the SessionInformation object instead. It took me a few minutes to figure out why the last refresh date wasn&amp;amp;apos;t being updated on my custom session registry.</description>
			<version>3.1.0.RC2</version>
			<fixedVersion>3.0.6, 3.1.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.session.ConcurrentSessionFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1772" opendate="2011-06-27 05:09:52" fixdate="2011-07-13 14:16:43" resolution="Complete">
		<buginformation>
			<summary>Unneeded URL decode in SimpleUrlLogoutSuccessHandler</summary>
			<description>URLDecoder.decode(targetUrl, "UTF-8") call is not needed in org.springframework.security.web.authentication.logout.SimpleUrlLogoutSuccessHandler and it breaks URLs with GET parameters escaped in them.
p.s. also isUseReferer() is missing.</description>
			<version>3.0.5</version>
			<fixedVersion>3.1.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.AbstractAuthenticationTargetUrlRequestHandler.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">213</link>
		</links>
	</bug>
	<bug id="1792" opendate="2011-07-29 06:57:15" fixdate="2011-07-29 08:07:26" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException in RunAsUserToken#toString() when originalAuthentication is null</summary>
			<description></description>
			<version>3.0.5</version>
			<fixedVersion>3.0.6, 3.1.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.intercept.RunAsUserTokenTests.java</file>
			<file type="M">org.springframework.security.access.intercept.RunAsUserToken.java</file>
		</fixedFiles>
	</bug>
	<bug id="1741" opendate="2011-05-12 03:35:44" fixdate="2011-08-19 10:34:05" resolution="Fixed">
		<buginformation>
			<summary>ContextPropagatingRemoteInvocation should not be able to pass a SecurityContext object</summary>
			<description>Various potential attacks have been reported which rely on the deserialization of the SecurityContext/Authentication combination used by this class.
Realistically, a remote client should be limited to providing simple user/credentials information which is not automatically deserialized into instances of framework classes. The Authentication object should only be created in the server VM.</description>
			<version>2.0.6</version>
			<fixedVersion>3.0.6, 3.1.0.RC3, 2.0.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.remoting.rmi.ContextPropagatingRemoteInvocation.java</file>
			<file type="M">org.springframework.security.remoting.rmi.ContextPropagatingRemoteInvocationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1750" opendate="2011-05-20 12:08:16" fixdate="2011-08-19 10:36:55" resolution="Fixed">
		<buginformation>
			<summary>AbstractSecurityInterceptor should replace the SecurityContext when doing RunAs replacement, rather than just the Authentication within the context</summary>
			<description>Since the SecurityContext may be shared between different threads, there is a limited possibility of escalating permissions when a RunAsManager is used to modify the context.</description>
			<version>2.0.6</version>
			<fixedVersion>3.0.6, 3.1.0.RC3, 2.0.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.intercept.InterceptorStatusTokenTests.java</file>
			<file type="M">org.springframework.security.access.intercept.AbstractSecurityInterceptor.java</file>
			<file type="M">org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptorTests.java</file>
			<file type="M">org.springframework.security.access.intercept.InterceptorStatusToken.java</file>
		</fixedFiles>
	</bug>
	<bug id="1790" opendate="2011-07-25 08:02:24" fixdate="2011-08-19 10:46:03" resolution="Fixed">
		<buginformation>
			<summary>URL spring-security-redirect parameters vulnerable to CRLF injection by default.</summary>
			<description>AbstractAuthenticationTargetUrlRequestHandler#determineTargetUrl(HttpServletRequest, HttpServletResponse) calls URLDecoder.decode, and the result is directly feed to DefaultRedirectStrategy by default, which does not filter line feeds, injecting a custom header after "Location"
Request:
GET
/mywebapp/logout/spring-security-redirect=%0d%0a%20SomeCustomInjectedHeader%3ainjected_
by_wvs HTTP/1.1
Response:
HTTP/1.1 302 Moved Temporarily
Date: Tue, 19 Jul 2011 15:28:57 GMT
Location: xxxxxxxxxxxxxxx
SomeCustomInjectedHeader: injected_by_wvs
Content-Length: 0
Connection: close
Content-Type: text/plain; charset=UTF-8
You need to restrict CR(0x13) and LF(0x10) from the user input or properly encode the output in order to prevent the injectino of custom HTTP headers.</description>
			<version>3.0.5</version>
			<fixedVersion>3.0.6, 3.1.0.RC3, 2.0.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.firewall.DefaultHttpFirewall.java</file>
		</fixedFiles>
	</bug>
	<bug id="1795" opendate="2011-08-10 21:39:37" fixdate="2011-08-19 11:47:46" resolution="Complete">
		<buginformation>
			<summary>Changing ACL parent causes a NPE</summary>
			<description>Changing the the parent ACL of an AclImpl when it has a parent already causes a NullpointException in AclImpl.equals(.)
The unit test (paste into AclImplTests.java) proves it.
@Test
  public void testChangeParent() throws Exception
  {
    AclImpl parentAcl = new AclImpl(objectIdentity, 1L, mockAuthzStrategy, mockAuditLogger);
    AclImpl childAcl = new AclImpl(objectIdentity, 2L, mockAuthzStrategy, mockAuditLogger);
    AclImpl changeParentAcl = new AclImpl(objectIdentity, 3L, mockAuthzStrategy, mockAuditLogger);

    // This works
    childAcl.setParent(parentAcl);
    childAcl.setParent(null);                        // setting to null first avoids NPE
    childAcl.setParent(changeParentAcl);

    // This causes an NPE
    childAcl.setParent(parentAcl);
  }</description>
			<version>3.0.5</version>
			<fixedVersion>3.0.6, 3.1.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.domain.AclImpl.java</file>
			<file type="M">org.springframework.security.acls.domain.AclImplTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1804" opendate="2011-08-25 01:20:42" fixdate="2011-09-09 09:41:19" resolution="Fixed">
		<buginformation>
			<summary>User is said to be immutable but eraseCredentials() remove password resulting in UserDetailsManager side effect </summary>
			<description>Since spring-security 3.0.6 (which is released to maven repo but not marked as it in JIRA), org.springframework.security.core.userdetails.User.eraseCredentials() is called by org.springframework.security.core.AuthenticationException.AuthenticationException(String, Object) after an authentication failure.
As I use an InMemory org.springframework.security.core.userdetails.UserDetailsService implementation which retrieves a User using UserDetailsService#loadUserByUsername, the in-memory User has its password cleared on such authentication failure. So after an authentication failure, I cannot logged in anymore because the User password is null.
User class claim to be immutable but eraseCredentials() erased the password member resulting in side effects. It should really be immutable or indicated in javadoc that UserDetailsService#loadUserByUsername must return a copy of the User.</description>
			<version>3.0.6</version>
			<fixedVersion>3.0.7</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.provisioning.InMemoryUserDetailsManager.java</file>
			<file type="M">org.springframework.security.core.userdetails.User.java</file>
			<file type="M">org.springframework.security.core.userdetails.UserDetails.java</file>
		</fixedFiles>
	</bug>
	<bug id="1838" opendate="2011-10-12 06:23:28" fixdate="2011-10-13 07:39:01" resolution="Duplicate">
		<buginformation>
			<summary>FirewalledRequest.reset() is not called if there are no matching filters</summary>
			<description>FilterChainProxy.doFilter() determines the list of filters that have to be applied to a request. If there are filters, this method delegates to VirtualFilterChain.doFilter(), which will reset the firewall request wrapper at the end of the chain.
The problem occurs, if there are no filters: FilterChainProxy.doFilter() is creating an instance of FirewalledRequest nevertheless, which it passes on to the original chain. But it does not call the "reset" method this FirewalledRequest object.
This situation occurs, if you map "/" in web.xml to the Spring Security Filter Chain, but the Spring Security Filter Chain only handles "/some/" and "/thing/*". With this mapping, there are URLs like "/status" which are passed to the security chain proxy, but which are not covered by a filter list. The effect is bug is, that the servlet which is mapped to "/status" will get an invalid pathInfo and servletPath.
The resolution should be quite simple: If FilterChainProxy.doFilter() has an empty filter list for a given URL, it must not pass the firewalled request to the original chain but the original request. The line "chain.doFilter(fwRequest, response);" should be changed into "chain.doFilter(servletRequest, response);".
I don&amp;amp;apos;t know if Spring Security 3 is affected too, because we are using 2.0.x.</description>
			<version>2.0.7</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.FilterChainProxyTests.java</file>
			<file type="M">org.springframework.security.web.FilterChainProxy.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1608</link>
		</links>
	</bug>
	<bug id="1802" opendate="2011-08-23 02:06:16" fixdate="2011-10-21 09:26:43" resolution="Fixed">
		<buginformation>
			<summary>RFC 1738 / 3986 compliant schemes will not be recognized as valid schemes.</summary>
			<description>org.springframework.security.web.util.UrlUtils.isAbsoluteUrl(String) checks whether the given URL is absolute. It will be done by checking the URL is starting  with a valid scheme. But some valid schemes (RFC 1738 / 3986) will not be accepted (e.g. http1). In general all schemes containing digits will be rejected.</description>
			<version>3.0.5</version>
			<fixedVersion>3.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.util.UrlUtils.java</file>
			<file type="M">org.springframework.security.web.util.UrlUtilsTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1836" opendate="2011-10-07 10:03:52" fixdate="2011-10-31 16:26:26" resolution="Fixed">
		<buginformation>
			<summary>NPE when authorizing using JspAuthorizeTag</summary>
			<description>When using Spring security setup as enclosed in attachment, since I started to use attribute &amp;amp;apos;method&amp;amp;apos; in intercept-url tags, I run into trouble when using JSP &amp;lt;authorize&amp;gt; tag WITH url attribute filled but WITHOUT method attribute filled (like &amp;lt;security:authorize url="someUrl"&amp;gt;).
In that case, URL patterns with HTTP method set (as showed in my applicationContext-security.xml attachment) are compared against DummyRequest without HTTP method filled (created for the &amp;lt;authorize&amp;gt; tag), which causes NPE.
Sorry, I&amp;amp;apos;m in a time pressure now so I can&amp;amp;apos;t explain is more deeply but I believe this stacktrace fragment (which comens from authorization for &amp;lt;security:authorize url="/image-bundles/"&amp;gt; tag) explains it all:
Caused by: java.lang.NullPointerException: Name is null
	at java.lang.Enum.valueOf(Enum.java:195)
	at org.springframework.http.HttpMethod.valueOf(HttpMethod.java:1)
	at org.springframework.security.web.util.AntPathRequestMatcher.matches(AntPathRequestMatcher.java:83)
	at org.springframework.security.web.access.intercept.DefaultFilterInvocationSecurityMetadataSource.getAttributes(DefaultFilterInvocationSecurityMetadataSource.java:86)
	at org.springframework.security.web.access.DefaultWebInvocationPrivilegeEvaluator.isAllowed(DefaultWebInvocationPrivilegeEvaluator.java:90)
	at org.springframework.security.taglibs.authz.AbstractAuthorizeTag.authorizeUsingUrlCheck(AbstractAuthorizeTag.java:207)
	at org.springframework.security.taglibs.authz.AbstractAuthorizeTag.authorize(AbstractAuthorizeTag.java:107)
	at org.springframework.security.taglibs.authz.JspAuthorizeTag.doStartTag(JspAuthorizeTag.java:54)
	at freemarker.ext.jsp.TagTransformModel$TagWriter.onStart(TagTransformModel.java:360)
	at freemarker.core.Environment.visit(Environment.java:296)
	at freemarker.core.UnifiedCall.accept(UnifiedCall.java:130)
	at freemarker.core.Environment.visit(Environment.java:210)
	at freemarker.core.MixedContent.accept(MixedContent.java:92)
	at freemarker.core.Environment.visit(Environment.java:210)
	at freemarker.core.Environment.process(Environment.java:190)
	at freemarker.template.Template.process(Template.java:237)
	at freemarker.ext.servlet.FreemarkerServlet.process(FreemarkerServlet.java:452)
	at freemarker.ext.servlet.FreemarkerServlet.doGet(FreemarkerServlet.java:391)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:621)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:722)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:304)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)
	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:684)
	at org.apache.catalina.core.ApplicationDispatcher.doInclude(ApplicationDispatcher.java:593)
	at org.apache.catalina.core.ApplicationDispatcher.include(ApplicationDispatcher.java:530)
	at org.apache.tiles.servlet.context.ServletTilesRequestContext.include(ServletTilesRequestContext.java:260)
	at org.apache.tiles.context.TilesRequestContextWrapper.include(TilesRequestContextWrapper.java:97)
	at org.apache.tiles.freemarker.context.FreeMarkerTilesRequestContext.dispatch(FreeMarkerTilesRequestContext.java:66)
	at org.apache.tiles.renderer.impl.TemplateAttributeRenderer.write(TemplateAttributeRenderer.java:44)
	at org.apache.tiles.renderer.impl.AbstractBaseAttributeRenderer.render(AbstractBaseAttributeRenderer.java:106)
	at org.apache.tiles.renderer.impl.ChainedDelegateAttributeRenderer.write(ChainedDelegateAttributeRenderer.java:76)
	at org.apache.tiles.renderer.impl.AbstractBaseAttributeRenderer.render(AbstractBaseAttributeRenderer.java:106)
	at org.apache.tiles.impl.BasicTilesContainer.render(BasicTilesContainer.java:670)
	at org.apache.tiles.impl.BasicTilesContainer.render(BasicTilesContainer.java:336)
	at org.apache.tiles.template.InsertAttributeModel.renderAttribute(InsertAttributeModel.java:210)
	at org.apache.tiles.template.InsertAttributeModel.end(InsertAttributeModel.java:126)
	at org.apache.tiles.freemarker.template.InsertAttributeFMModel.execute(InsertAttributeFMModel.java:89)
</description>
			<version>3.1.0.RC3</version>
			<fixedVersion>3.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.taglibs.authz.AbstractAuthorizeTag.java</file>
		</fixedFiles>
	</bug>
	<bug id="1820" opendate="2011-09-20 13:11:50" fixdate="2011-10-31 16:28:20" resolution="Fixed">
		<buginformation>
			<summary>NPE in OpenID4JavaConsumer.fetchAxAttributes</summary>
			<description>I am not sure what more details I need to provide - please let me know.






java.lang.NullPointerException




    org.springframework.security.openid.OpenID4JavaConsumer.fetchAxAttributes(OpenID4JavaConsumer.java:205)




    org.springframework.security.openid.OpenID4JavaConsumer.endConsumption(OpenID4JavaConsumer.java:184)




    org.springframework.security.openid.OpenIDAuthenticationFilter.attemptAuthentication(OpenIDAuthenticationFilter.java:143)




    org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:199)




    org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:340)




    org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:187)




    org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:340)




    org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:105)




    org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:340)




    org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:80)




    org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:340)




    org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:175)




    org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:237)




    org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:167)





</description>
			<version>3.1.0.RC2</version>
			<fixedVersion>3.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.openid.OpenID4JavaConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1833" opendate="2011-10-05 08:29:21" fixdate="2011-10-31 16:44:05" resolution="Fixed">
		<buginformation>
			<summary>HttpSessionSecurityContextRepository is missing setter for securityContextClass in 3.1.0 RC3</summary>
			<description>This setter used to be there in 3.0.x and is still referenced in the Javadoc for generateNewContext()</description>
			<version>3.1.0.RC3</version>
			<fixedVersion>3.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.HttpSessionSecurityContextRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="1848" opendate="2011-11-01 00:33:36" fixdate="2011-11-01 06:32:52" resolution="Fixed">
		<buginformation>
			<summary>AbstractLdapAuthenticator must escape username</summary>
			<description>AbstractLdapAuthenticator.getUserDns() must escape provided username before fomatting it into userDnFormat. It should use LdapEncoder.nameEncode().</description>
			<version>3.0.7</version>
			<fixedVersion>3.0.8, 3.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.BindAuthenticatorTests.java</file>
			<file type="M">org.springframework.security.ldap.authentication.AbstractLdapAuthenticator.java</file>
		</fixedFiles>
	</bug>
	<bug id="1857" opendate="2011-11-10 01:18:11" fixdate="2011-12-05 13:25:28" resolution="Fixed">
		<buginformation>
			<summary>ContextPropagatingRemoteInvocation does not correctly propagate the principal</summary>
			<description>ContextPropagatingRemoteInvocation was changed so that the principal and credentials were propagated via the toString method (see https://jira.springsource.org/browse/SEC-1741), as follows: 
principal = currentUser.getPrincipal().toString(); 
credentials = currentUser.getCredentials().toString(); 
However, this only works if the toString method actually returns the principals name and in the case of principal of type org.springframework.security.core.userdetails.User it returns a description of the User object, not the name.
I suggest the solution is as follows (it works for me at least): 
principal = currentUser.getName(); 
credentials = currentUser.getCredentials().toString();
Any more info required just let me know.</description>
			<version>3.0.7</version>
			<fixedVersion>3.0.8, 3.1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.remoting.rmi.ContextPropagatingRemoteInvocation.java</file>
		</fixedFiles>
	</bug>
	<bug id="1878" opendate="2011-12-21 13:16:46" fixdate="2011-12-29 13:22:04" resolution="Fixed">
		<buginformation>
			<summary>DefaultFilterChainValidator throws UnsupportedOperationException</summary>
			<description>If the expression used in the access attribute of the intercept-url element references a request element not supported by the new [1] org.springframework.security.web.FilterInvocation$DummyRequest class AND a custom-filter is defined, then the filterChainProxy bean will fail to be created [2]. This is a regression from 3.0.6.RELEASE. 
For example: 
   &amp;lt;security:custom-filter ref="myAuthFilter" position="FIRST" /&amp;gt;
   &amp;lt;security:intercept-url pattern="/**"  access="request.parameterMap['test'] == null ? permitAll : permitAll" /&amp;gt; 
will fail with the stack trace below[2].
There is an easy (hacky) workaround...just check the for request.contextPath = &amp;amp;apos;/cp&amp;amp;apos; (assuming you don&amp;amp;apos;t really have a /cp path!)...this works because contextPath is supported by the DummyRequest.  
 &amp;lt;security:intercept-url pattern="/**"  access="request.contextPath == &amp;amp;apos;/cp&amp;amp;apos; ? denyAll : request.parameterMap['test'] == null ? permitAll : permitAll" /&amp;gt;
I have attached simple maven project that will exercise this bug. To reproduce, download, unzip the intercpet-url-access-bug.zip attachment, and run mvn jetty:run. 
[1] https://fisheye.springsource.org/browse/spring-security/web/src/main/java/org/springframework/security/web/FilterInvocation.java?r2=93438defffe5c339026469afa09dad60b2928a4f&amp;amp;r1=052537c8b04182595e92abd1e1949b0ff7e731b4
[2] 
SEVERE: Context initialization failed
org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;org.springframework.security.filterChainProxy&amp;amp;apos;: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Failed to evaluate expression &amp;amp;apos;request.parameterMap['test'] == null ? permitAll : permitAll&amp;amp;apos;
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1455)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:519)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456)
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:294)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:225)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:291)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:585)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:913)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:464)
	at org.springframework.web.context.ContextLoader.createWebApplicationContext(ContextLoader.java:282)
	at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:204)
	at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:47)
	at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4206)
	at org.apache.catalina.core.StandardContext.start(StandardContext.java:4705)
	at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1057)
	at org.apache.catalina.core.StandardHost.start(StandardHost.java:840)
	at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1057)
	at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:463)
	at org.apache.catalina.core.StandardService.start(StandardService.java:525)
	at org.apache.catalina.core.StandardServer.start(StandardServer.java:754)
	at org.apache.catalina.startup.Catalina.start(Catalina.java:595)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:592)
	at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:289)
	at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:414)
Caused by: java.lang.IllegalArgumentException: Failed to evaluate expression &amp;amp;apos;request.parameterMap['test'] == null ? permitAll : permitAll&amp;amp;apos;
	at org.springframework.security.access.expression.ExpressionUtils.evaluateAsBoolean(ExpressionUtils.java:13)
	at org.springframework.security.web.access.expression.WebExpressionVoter.vote(WebExpressionVoter.java:34)
	at org.springframework.security.web.access.expression.WebExpressionVoter.vote(WebExpressionVoter.java:18)
	at org.springframework.security.access.vote.AffirmativeBased.decide(AffirmativeBased.java:62)
	at org.springframework.security.config.http.DefaultFilterChainValidator.checkLoginPageIsntProtected(DefaultFilterChainValidator.java:170)
	at org.springframework.security.config.http.DefaultFilterChainValidator.validate(DefaultFilterChainValidator.java:35)
	at org.springframework.security.web.FilterChainProxy.afterPropertiesSet(FilterChainProxy.java:148)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1514)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1452)
	... 27 more
Caused by: org.springframework.expression.spel.SpelEvaluationException: EL1021E:(pos 8): A problem occurred whilst attempting to access the property &amp;amp;apos;parameterMap&amp;amp;apos;: &amp;amp;apos;Unable to access property &amp;amp;apos;parameterMap&amp;amp;apos; through getter&amp;amp;apos;
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:201)
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:72)
	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:57)
	at org.springframework.expression.spel.ast.OpEQ.getValueInternal(OpEQ.java:37)
	at org.springframework.expression.spel.ast.OpEQ.getValueInternal(OpEQ.java:1)
	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:135)
	at org.springframework.expression.spel.ast.Ternary.getValueInternal(Ternary.java:47)
	at org.springframework.expression.spel.ast.SpelNodeImpl.getTypedValue(SpelNodeImpl.java:102)
	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:97)
	at org.springframework.security.access.expression.ExpressionUtils.evaluateAsBoolean(ExpressionUtils.java:11)
	... 35 more
Caused by: org.springframework.expression.AccessException: Unable to access property &amp;amp;apos;parameterMap&amp;amp;apos; through getter
	at org.springframework.expression.spel.support.ReflectivePropertyAccessor$OptimalPropertyAccessor.read(ReflectivePropertyAccessor.java:499)
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:196)
	... 44 more
Caused by: java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:592)
	at org.springframework.expression.spel.support.ReflectivePropertyAccessor$OptimalPropertyAccessor.read(ReflectivePropertyAccessor.java:495)
	... 45 more
Caused by: java.lang.UnsupportedOperationException
	at org.springframework.security.web.DummyRequest.getParameterMap(FilterInvocation.java:334)
	... 50 more
</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.DefaultFilterChainValidator.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1886</link>
		</links>
	</bug>
	<bug id="1870" opendate="2011-12-14 09:00:50" fixdate="2011-12-29 13:49:21" resolution="Fixed">
		<buginformation>
			<summary>HttpSessionDestroyedEvent#getSecurityContexts() broken</summary>
			<description>The implementation of HttpSessionDestroyedEvent#getSecurityContexts() is broken. See the code snippet from the source below. The code retrieves the names of the session attributes which are Strings and test the Strings to be instances of SecurityContext in the loop. Strings are most likely not SecurityContexts, so the result of the method is always an empty list.






Enumeration&amp;lt;String&amp;gt; attributes = session.getAttributeNames();









ArrayList&amp;lt;SecurityContext&amp;gt; contexts = new ArrayList&amp;lt;SecurityContext&amp;gt;();









while(attributes.hasMoreElements()) {




    Object attribute = attributes.nextElement();




    if (attribute instanceof SecurityContext) {




        contexts.add((SecurityContext) attribute);




    }




}





</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.session.HttpSessionDestroyedEvent.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1951</link>
		</links>
	</bug>
	<bug id="1868" opendate="2011-12-14 03:37:05" fixdate="2011-12-30 09:07:32" resolution="Fixed">
		<buginformation>
			<summary>SecurityNamespaceHandler should not log an error if the web classes are not available</summary>
			<description>Currently the SecurityNamespaceHandler logs an error if the FilterChainProxy is not available on the classpath.
This should be turned back to an if instead of a try/catch and it should definitely not log an error message </description>
			<version>3.1.0</version>
			<fixedVersion>3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandler.java</file>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandlerTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1934</link>
		</links>
	</bug>
	<bug id="1880" opendate="2011-12-27 04:46:51" fixdate="2011-12-30 09:39:07" resolution="Complete">
		<buginformation>
			<summary>Mislead exception text "Use logout-url or success-handler-ref, but not both"</summary>
			<description>In org.springframework.security.config.http.LogoutBeanDefinitionParser there is an mistake in exception message composing. 
Instead of: "Use " + ATT_LOGOUT_URL + " or " + ATT_LOGOUT_HANDLER + ", but not both"
Should be: "Use " + ATT_LOGOUT_SUCCESS_URL + " or " + ATT_LOGOUT_HANDLER + ", but not both"</description>
			<version>3.0.7</version>
			<fixedVersion>3.0.8, 3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.LogoutBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="1735" opendate="2011-05-09 11:01:31" fixdate="2011-12-30 14:47:48" resolution="Fixed">
		<buginformation>
			<summary>Logged out immediately after logging in on some browsers</summary>
			<description>This bug is closely related to SEC-1587.
I start at my log in screen, log into the system, see the logged in view and then the next navigation I make I end up being redirect back to the login screen.
It happens periodly, not every time.  It happens the most when using Internet Explorer 6.
After I debugged the problem I figured out that the httpSession.removeAttribute(SPRING_SECURITY_CONTEXT_KEY); call in HttpSessionSecurityContextRepository was destroying my newly created authentication object.
Here&amp;amp;apos;s how it happens:
1. Browser requests jsf.js.faces during the loading of the login screen.  This request passes through the httpSessionContextIntegrationFilter along with all .faces requests.
2. Browser holds on to connection after getting the javascript file.  (Browsers do this as an optimization to prevent lots of new tcp connects)
3. I log into my app from the login page.  This adds the security context to the session.
4. Browser makes another javascript request from the open connection which causes the thread working on jsf.js.faces to finish up (come back out through the filters)
5. On the request thread of jsf.js.faces the original security context had a null authenication so httpSession.removeAttribute(SPRING_SECURITY_CONTEXT_KEY); is called which wipes up the new authenication.
I&amp;amp;apos;ve worked around the problem by created my own version of HttpSessionSecurityContextRepository and just changing the lines:
                if (httpSession != null) 
{
                    // SEC-1587 A non-anonymous context may still be in the session
                    httpSession.removeAttribute(SPRING_SECURITY_CONTEXT_KEY);
                }
                return;

to

                if (httpSession != null &amp;amp;&amp;amp; contextHashBeforeChainExecution != -1) {                    // SEC-1587 A non-anonymous context may still be in the session                    httpSession.removeAttribute(SPRING_SECURITY_CONTEXT_KEY);                }
                return;
This means that the security context is only reset if there was one at the beginning of the request. (Hash of -1 means no authenication)</description>
			<version>3.0.5</version>
			<fixedVersion>3.0.8, 3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.HttpSessionSecurityContextRepositoryTests.java</file>
			<file type="M">org.springframework.security.web.context.HttpSessionSecurityContextRepository.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">2742</link>
		</links>
	</bug>
	<bug id="1885" opendate="2012-01-04 08:51:17" fixdate="2012-01-07 12:06:28" resolution="Complete">
		<buginformation>
			<summary>Adding &lt;debug/&gt; causes NoSuchMethodException when FilterChainProxy&amp;apos;s relies on beans that have Autowired Constructors</summary>
			<description>An example would be if a configuration used &amp;lt;debug/&amp;gt; and a custom AuthenticationProvider or UserDetailsService which had an Autowired constructor one might get an exception similar to NoSuchMethodException MyCustomAuthenticationProvider.&amp;lt;init&amp;gt;()</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.util.InMemoryXmlApplicationContext.java</file>
			<file type="M">org.springframework.security.config.debug.SecurityDebugBeanFactoryPostProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1948</link>
			<link type="Duplicate" description="is duplicated by">1911</link>
		</links>
	</bug>
	<bug id="1927" opendate="2012-03-01 08:54:29" fixdate="2012-03-11 16:38:33" resolution="Complete">
		<buginformation>
			<summary>SessionManagementFilter does not add space between ID and session ID</summary>
			<description>The class org.springframework.security.web.session.SessionManagementFilter logs a wrong session ID in one of the debug log entries. In line 91 there is a missing space between the word &amp;amp;apos;ID&amp;amp;apos; in the log message and the value:
logger.debug("Requested session ID" + request.getRequestedSessionId() + " is invalid.");
That leads to e.g. the following line:
"Requested session IDBD230F0B1B30002A89B47B182FD2874E is invalid."
If the reader of such a line is not mindful enough, he would looking for a session IDBD230F0B1B30002A89B47B182FD2874E which doesn&amp;amp;apos;t exists. It should be read:
"Requested session ID BD230F0B1B30002A89B47B182FD2874E is invalid."</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.session.SessionManagementFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1893" opendate="2012-01-18 20:22:44" fixdate="2012-03-11 20:11:56" resolution="Complete">
		<buginformation>
			<summary>Default https 8443 port mappings redirection</summary>
			<description>Port-mappings does not work properly,
when it setup in spring xml configuration such as:
&amp;lt;ss:port-mappings&amp;gt;
    &amp;lt;ss:port-mapping http="8181" https="8080"/&amp;gt;
&amp;lt;/ss:port-mappings&amp;gt;
with:
&amp;lt;ss:form-login login-page="/access/login.html"
            username-parameter="username"
            password-parameter="password"
            login-processing-url="/app/loginuser"
            default-target-url="/app/" /&amp;gt;
Spring security redirected me to url (https://localhost:8443/access/login.html must be https://localhost:8080/access/login.html) with 8443 port (by default in the org/springframework/security/web/PortMapperImpl.java) when I try to access protected page.
I edited PortMapperImpl.java:
    public PortMapperImpl() 
{
        httpsPortMappings = new HashMap&amp;lt;Integer, Integer&amp;gt;();
        httpsPortMappings.put(Integer.valueOf(8080), Integer.valueOf(8080));
    }

and redirection is working now to 8080 https.
I think that when &amp;lt;ss:port-mappings&amp;gt;...&amp;lt;/ss:port-mappings&amp;gt; setted,
PortMapperImpl.java:
private final Map&amp;lt;Integer, Integer&amp;gt; httpsPortMappings;
"httpsPortMappings" not cleaned properly, and previously key value are available.</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
			<file type="M">org.springframework.security.config.http.FormLoginBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.http.HttpConfigurationBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1901" opendate="2012-01-29 13:13:44" fixdate="2012-03-17 09:32:29" resolution="Fixed">
		<buginformation>
			<summary>Forwarding to /j_spring_security_check results in 404</summary>
			<description>In a JSF environment, RequestDispatcher is used to forward request to /j_spring_security_check to do user login. In Spring Security 3.1.0, doing so results in 404 error. The same code works fine with 3.0.7.
Currently I use a custom filter to invoke UsernamePasswordAuthenticationFilter directly to work around the problem. As such, I suspect FilterChainProxy is not run when the request is forwarded.</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.debug.DebugFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1934" opendate="2012-03-06 01:03:12" fixdate="2012-03-17 09:46:08" resolution="Duplicate">
		<buginformation>
			<summary>NamspaceHandler logs error if web module not present</summary>
			<description>The SecurityNamespaceHandler in the config module tries to load FilterChainProxy (which it probably shouldn&amp;amp;apos;t anyway?) although one might not have included the Spring Security web module as one might only want to use global methd security in the first place. The pom.xml of the config module actually states the web module to be optional but apparently the code is not.
Of course Spring Security works just fine without the web module present but logging an error is at least irritating then.</description>
			<version>3.1.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandler.java</file>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandlerTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1868</link>
		</links>
	</bug>
	<bug id="1911" opendate="2012-02-07 19:58:34" fixdate="2012-03-17 09:48:22" resolution="Duplicate">
		<buginformation>
			<summary>&lt;security:debug/&gt; enables SecurityDebugBeanFactoryPostProcessor which ignores &lt;context:annotation-config/&gt;</summary>
			<description>    &amp;lt;bean id="customBasedAuthenticationProvider" class="com.test.admin.auth.CustomBasedAuthenticationProvider"&amp;gt;
    	&amp;lt;property name="configBean" ref="annotationBean" /&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;context:annotation-config/&amp;gt;
    &amp;lt;security:debug/&amp;gt; 
     &amp;lt;security:authentication-manager&amp;gt;
        &amp;lt;security:authentication-provider ref="customBasedAuthenticationProvider"&amp;gt;
        &amp;lt;/security:authentication-provider&amp;gt;
    &amp;lt;/security:authentication-manager&amp;gt;

configBean

@Component("annotationBean")
@Scope(BeanDefinition.SCOPE_SINGLETON)
public class AnnotationConfigBean implements InitializingBean {
	@Autowired
	public AutowiredBean bean;
	/* (non-Javadoc)

@see org.springframework.beans.factory.InitializingBean#afterPropertiesSet()
	 */
	@Override
	public void afterPropertiesSet() throws Exception 
{
		if(bean==null)
			throw new RuntimeException("noconfigbean");
		
	}

}

autowiredBean

@Component
public class AutowiredBean {
}
when injecting  annotationBean into customBasedAuthenticationProvider the @Autowired AutowiredBean is not set on the annotationBean. This occurs only when  &amp;lt;security:debug/&amp;gt;  is enabled.</description>
			<version>3.1.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.util.InMemoryXmlApplicationContext.java</file>
			<file type="M">org.springframework.security.config.debug.SecurityDebugBeanFactoryPostProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1885</link>
		</links>
	</bug>
	<bug id="1948" opendate="2012-04-05 16:29:15" fixdate="2012-04-15 10:12:51" resolution="Duplicate">
		<buginformation>
			<summary>Custom AbstractUserDetailsAuthenticationProvider Does not process annotations</summary>
			<description>I have a custom class derived from AbstractUserDetailsAuthenticationProvider which needs to use a custom dao (UserDao).  Within this provider I have an @Autowired UserDao field which does not get autowired.  UserDao is successfully autowired into other beans in the same context (all beans reside within the root context).
The hack to get it to work is to manually inject the userDao via xml configuration.  When that happens though, other annotations within UserDao (in this case @Transactional) are also removed.
For more information see:  http://stackoverflow.com/a/10036529/80286
</description>
			<version>3.1.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.util.InMemoryXmlApplicationContext.java</file>
			<file type="M">org.springframework.security.config.debug.SecurityDebugBeanFactoryPostProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1885</link>
		</links>
	</bug>
	<bug id="1951" opendate="2012-04-19 12:48:50" fixdate="2012-04-19 13:10:21" resolution="Duplicate">
		<buginformation>
			<summary>HttpSessionDestroyedEvent#getSecurityContexts always return empty</summary>
			<description>Looking into the source code of HttpSessionDestroyedEvent.java on line 52:
Object attribute = attributes.nextElement();
This should be: session.getAttribute(attributes.nextElement())
Thanks
</description>
			<version>3.1.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.session.HttpSessionDestroyedEvent.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1870</link>
		</links>
	</bug>
	<bug id="1900" opendate="2012-01-25 11:19:35" fixdate="2012-04-22 20:23:49" resolution="Complete">
		<buginformation>
			<summary>sec:authorize ifAllGranted does not work if Authorities are deprecated GrantedAuthorityImpl</summary>
			<description>&amp;lt;sec:authorize ifAllGranted="ROLE_ADMIN"&amp;gt;
did not work for me after upgrading to 3.1.0 
reason: i added some role manually in my own UserDetails like this:
  GrantedAuthority granted = new GrantedAuthorityImpl(rolle.toString());
  authorities.add(granted);
GrantedAuthorityImpl is deprecated and ifAllGranted, too. But i think it is still a bug.
You can fix it by using simpleGrantedAuthority
GrantedAuthority granted = new SimpleGrantedAuthority(rolle.toString());
authorities.add(granted);
the bug is somewhere in the Collection class in an equals method. It checks if the containing element is of class SimpleGrantedAuthority.
</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.taglibs.authz.AuthorizeTagCustomGrantedAuthorityTests.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AbstractAuthorizeTag.java</file>
		</fixedFiles>
	</bug>
	<bug id="1886" opendate="2012-01-05 10:55:29" fixdate="2012-06-16 15:56:43" resolution="Duplicate">
		<buginformation>
			<summary>UnsupportedOperationException is thrown by DefaultFilterChainValidator if voter invokes an unsupported method</summary>
			<description>The DefaultFilterChainValidator prevents the application context from starting up if a custom AccessDecisionVoter attempts to access an unsupported method of the DummyRequest, for example the #getRemoteAddr(). There is no way to turn off this validation when using &amp;lt;http&amp;gt; config.






Stack Trace






Caused by: java.lang.UnsupportedOperationException




	at org.springframework.security.web.DummyRequest.getRemoteAddr(FilterInvocation.java:358)




	at com.foo.security.vote.IPRestrictionAccessVoter.vote(IPRestrictionAccessVoter.java:80)




	at com.foo.security.vote.IPRestrictionAccessVoter.vote(IPRestrictionAccessVoter.java:37)




	at org.springframework.security.access.vote.UnanimousBased.decide(UnanimousBased.java:77)




	at org.springframework.security.config.http.DefaultFilterChainValidator.checkLoginPageIsntProtected(DefaultFilterChainValidator.java:170)




	at org.springframework.security.config.http.DefaultFilterChainValidator.validate(DefaultFilterChainValidator.java:35)




	at org.springframework.security.web.FilterChainProxy.afterPropertiesSet(FilterChainProxy.java:148)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1514)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1452)




	... 155 more





</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.DefaultFilterChainValidator.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1878</link>
		</links>
	</bug>
	<bug id="1968" opendate="2012-05-30 10:21:06" fixdate="2012-06-27 13:53:17" resolution="Fixed">
		<buginformation>
			<summary>PreAuthenticatedProcessingFilter does not clear out the security context causing user to unintentionally remain authenticated</summary>
			<description>When the pre-authenticated user is null, the previously authenticated user&amp;amp;apos;s security context remains, and as such, the previous user remains authenticated.
It seems like the AbstractPreAuthenticatedProcessingFilter should clear out the security context in doAuthenticate if the principal is null.  I can override the getPreAuthenticatedPrincipal call to do this (if I return  null for the principal), but it seems that this is not something the user should have to manage.  And, it seems like a side-effect / hack to put something like that in a method that should just be getting the principal, and doAuthenticate itself is private.  This is dangerous because later in the chain, in AbstractSecurityInterceptor.beforeInvocation(Object object) the security context is not null, even though it should be, and so, no exception is thrown from:
        if (SecurityContextHolder.getContext().getAuthentication() == null) 
{
            credentialsNotFound(messages.getMessage("AbstractSecurityInterceptor.authenticationNotFound",
                    "An Authentication object was not found in the SecurityContext"), object, attributes);
        }

It could also possibly be argued that the security context should be cleared in AbstractPreAuthenticatedFilter.requiresAuthentication in the session invalidation on a principal change - namely in here:
        if (invalidateSessionOnPrincipalChange) {
            HttpSession session = request.getSession(false);
            if (session != null) 
{
                logger.debug("Invalidating existing session");
                session.invalidate();
                request.getSession();
            }
        }
I have attached a test application that demonstrates this in the simplest format I could come up with. Basically the pre-authentication occurs by grabbing a username from a request parameter, and then it displays the logged in user&amp;amp;apos;s username on the home page.
So if I go to http://localhost:8080/security/?username=bob the application will display &amp;amp;apos;Hello bob&amp;amp;apos;.  If I hit http://localhost:8080/security/?username=jimi, it will switch to saying &amp;amp;apos;Hello jimi&amp;amp;apos;, but if I do http://localhost:8080/security/?username= it will remain at &amp;amp;apos;Hello jimi&amp;amp;apos; (or whatever the previously authenticated user was), instead of requiring authentication.
However, if in getPreAuthenticatedPrincipal() I call SecurityContextHolder.clearContext(), then hitting http://localhost:8080/security/?username= will result in taking me to the login page which I think is the desired behavior if the user is not pre-authenticated - indicated by getPreAuthenticatedPrincipal() returning null.</description>
			<version>3.0.7</version>
			<fixedVersion>3.0.8, 3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1958</link>
		</links>
	</bug>
	<bug id="1965" opendate="2012-05-27 13:58:31" fixdate="2012-06-28 11:12:07" resolution="Fixed">
		<buginformation>
			<summary>Passivity DefaultWebSecurityExpressionHandler no longer implements WebSecurityExpressionHandler</summary>
			<description>The DefaultWebSecurityExpressionHandler no longer implements WebSecurityExpressionHandler which causes issues when using spring-webflow&amp;amp;apos;s AbstractAuthorizeTag which looks up the WebExpressionHandler for authorize statements. We should probably also look into getting webflow to use the provided AbstractAuthorizeTag (I haven&amp;amp;apos;t had time to investigate why they might have their own copy of this tag).</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.access.expression.DefaultWebSecurityExpressionHandler.java</file>
			<file type="M">org.springframework.security.web.access.expression.WebSecurityExpressionHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1980" opendate="2012-06-25 08:13:33" fixdate="2012-07-10 12:34:23" resolution="Fixed">
		<buginformation>
			<summary>Misleading warning about incorrect redirect URL</summary>
			<description>We&amp;amp;apos;ve started using SpEL expressions to avoid duplicating URL patterns between security.xml and our MVC controller mappings.
E.g.






&amp;lt;form-login 




    login-page="#{T(com.acme.Sitemap).LOGIN}" 




    authentication-failure-url="#{T(com.acme.Sitemap).AUTH_ERROR}"/&amp;gt;






Now we keep seeing spurious warnings like






FailFastProblemReporter - Configuration problem: #{ T(com.acme.Sitemap).AUTH_ERROR} is not a valid redirect URL (must start with &amp;amp;apos;/&amp;amp;apos; or http(s))






This appears to be caused by WebConfigUtils.validateHttpRedirect() which checks for a &amp;amp;apos;$&amp;amp;apos; placeholder character but not for a &amp;amp;apos;#&amp;amp;apos; SpEL character.
</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.WebConfigUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1958" opendate="2012-05-04 02:07:52" fixdate="2012-07-12 06:04:05" resolution="Duplicate">
		<buginformation>
			<summary>authentication successful even if it&amp;apos;s not in AbstractPreAuthenticatedProcessingFilter</summary>
			<description>Consider scenario using AbstractPreAuthenticatedProcessingFilter with setCheckForPrincipalChanges(true).
1. on first page request authentication is successful and everything is ok
2. on next page request authentication failed, getPreAuthenticatedPrincipal returns null. Method doAuthenticate in current implementation does this:






        if (principal == null) {




            if (logger.isDebugEnabled()) {




                logger.debug("No pre-authenticated principal found in request");




            }









            return;




        }






This means that no AuthenticationException is raised and no check to continueFilterChainOnUnsuccessfulAuthentication is made.</description>
			<version>3.1.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1968</link>
		</links>
	</bug>
	<bug id="1850" opendate="2011-11-01 09:39:54" fixdate="2012-07-18 13:16:44" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentSessionFilter should be by default injected with the same logout handlers as LogoutFilter when using namespace config</summary>
			<description>I have an app configured to prevent concurrent sessions:
                &amp;lt;sec:session-management session-fixation-protection="migrateSession"&amp;gt;
                           &amp;lt;sec:concurrency-control max-sessions="1" expired-url="/sessionExpired.do" session-registry-ref="sessionRegistry"/&amp;gt;
                &amp;lt;/sec:session-management&amp;gt;
Also we are using remember me functionality:
                &amp;lt;sec:remember-me key="someKey" services-ref="rememberMeServices"  /&amp;gt;
now with this config the logout filter is injected with both SecurityContextLogoutHandler and our TokenBasedRememberMeServices bean which implements LogoutHandler.This is the expected config and it correctly executes both handlers (where in this case, remember me cookie will be canceled by TokenBasedRememberMeServices)  ..
However, if the user exceeds his max sessions and the ConcurrentSessionFilter logouts the user, it uses the default SecurityContextLogoutHandler which is declared inside:
                private LogoutHandler[] handlers = new LogoutHandler[] 
{new SecurityContextLogoutHandler()}
;
I think ConcurrentSessionFilter should be injected with the same logout handlers as LogoutFilter so the user will be properly logged out (i.e clearing remeber me cookie for example)...</description>
			<version>3.0.7</version>
			<fixedVersion>3.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.http.LogoutBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.http.HttpConfigurationBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1964" opendate="2012-05-21 05:05:29" fixdate="2012-07-18 14:41:30" resolution="Fixed">
		<buginformation>
			<summary>PersistentTokenBasedRememberMeServices provides improper error message with non existent series</summary>
			<description>Sometimes I have a error in my logs about toke series: "Querying token for series &amp;amp;apos;qF0PD5V64BRvlxTHU577ZQ==&amp;amp;apos; returned more than one value. Series should be unique"
Looks like series generator generates not unique values and it causes some problems later.
Also the class logic is not clear for me. 
1. In case of broken tokens they are never removed from the database because JdbcTokenRepositoryImpl returns null but PersistentTokenBasedRememberMeServices does nothing in this case:






PersistentTokenBasedRememberMeServices.java






        if (token == null) {




            // No series match, so we can&amp;amp;apos;t authenticate using this cookie




            throw new RememberMeAuthenticationException("No persistent token found for series id: " + presentedSeries);




        }






2. I have a lot browsers. At least 3 but when I have incorrect token in one browser, for example, all other marked as broken:






PersistentTokenBasedRememberMeServices.java






        if (!presentedToken.equals(token.getTokenValue())) {




            // Token doesn&amp;amp;apos;t match series value. Delete all logins for this user and throw an exception to warn them.




            tokenRepository.removeUserTokens(token.getUsername());









            throw new CookieTheftException(messages.getMessage("PersistentTokenBasedRememberMeServices.cookieStolen",




                    "Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack."));




        }






Why all my tokens are removed if only one is broken?
3. If token is expired it&amp;amp;apos;s not removed from DB:






PersistentTokenBasedRememberMeServices.java






        if (token.getDate().getTime() + getTokenValiditySeconds()*1000L &amp;lt; System.currentTimeMillis()) {




            throw new RememberMeAuthenticationException("Remember-me login has expired");




        }






At this moment my database has a lot of broken tokens.
</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImplTests.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">2103</link>
		</links>
	</bug>
	<bug id="2011" opendate="2012-07-19 06:31:23" fixdate="2012-07-19 08:22:03" resolution="Fixed">
		<buginformation>
			<summary>SessionFixationProtectionStrategy Javadoc states to inject SessionRegistry but does not contain that field</summary>
			<description>The SessionFixationProtectionStrategy Javadoc says:






If concurrent session control is in use, then a SessionRegistry must be injected. 






However, this feature is offered by the subclass ConcurrentSessionControlStrategy. Another reference to the session registry is in the org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy.onAuthentication(Authentication, HttpServletRequest, HttpServletResponse) Javadoc:






The sessionRegistry will be updated with the new session information.






Once again, this is done by the org.springframework.security.web.authentication.session.ConcurrentSessionControlStrategy.onAuthentication(Authentication, HttpServletRequest, HttpServletResponse) instead.</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy.java</file>
			<file type="M">org.springframework.security.web.authentication.session.ConcurrentSessionControlStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="2013" opendate="2012-07-19 13:57:39" fixdate="2012-07-19 14:16:15" resolution="Fixed">
		<buginformation>
			<summary>AbstractAuthenticationProcessingFilter is missing space in log message</summary>
			<description>I have custom FORM_LOGIN_FILTER class (extends UsernamePasswordAuthenticationFilter). When I have (expected) SessionAuthenticationException I see the following log messages:
2012-07-19 16:38:50,311 [btpool0-4] DEBUG FormAuthenticationFilter - Authentication request failed: org.springframework.security.web.authentication.session.SessionAuthenticationException: Only concurrent sessions for the same principal are allowed
2012-07-19 16:38:50,311 [btpool0-4] DEBUG FormAuthenticationFilter - Updated SecurityContextHolder to contain null Authentication
2012-07-19 16:38:50,311 [btpool0-4] DEBUG FormAuthenticationFilter - Delegating to authentication failure handlerorg.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler@5226e4c9
As you can see "Delegating to authentication failure handlerorg.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler@5226e4c9" message has no space.
The missing space is in the AbstractAuthenticationProcessingFilter class (see Reference URL).</description>
			<version>3.0.7</version>
			<fixedVersion>3.0.8, 3.1.2</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2012" opendate="2012-07-19 09:13:36" fixdate="2012-07-20 13:36:12" resolution="Fixed">
		<buginformation>
			<summary>Javadoc for UserDetails.getPassword() says that the password is never null; however it may be</summary>
			<description>The Javadoc for org.springframework.security.core.userdetails.UserDetails.getPassword() says:






Returns the password used to authenticate the user. Cannot return null.









Returns:




the password (never null)






However, if the concrete implementation of UserDetails also implements org.springframework.security.core.CredentialsContainer (and this is the case for org.springframework.security.core.userdetails.User, for instance), then the password may actually be null if the credentials have been deleted by a call to org.springframework.security.core.CredentialsContainer.eraseCredentials(). See org.springframework.security.core.userdetails.User.eraseCredentials(), for instance.</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.core.userdetails.UserDetails.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">1493</link>
		</links>
	</bug>
	<bug id="1917" opendate="2012-02-17 01:06:19" fixdate="2012-07-25 14:28:27" resolution="Duplicate">
		<buginformation>
			<summary>DefaultAuthenticationEventPublisher is never used when an AccountStatusException is thrown</summary>
			<description>The ProviderManager created by http namespace coded in 
org.springframework.security.config.http.HttpSecurityBeanDefinitionParser#createAuthenticationManager does not register a DefaultAuthenticationEventPublisher to the bean registration. This, in combination with the AccountStatusException handling in org.springframework.security.authentication.ProviderManager#authenticate where the exception is always rethrown, renders the DefaultAuthenticationEventPublisher of the parent ProviderManager invisible.
If you consider also that the org.springframework.security.core.AuthenticationException#getAuthentication has been deprecated, I cannot find a way to retrieve the cause and the identity of the failed authentication.</description>
			<version>3.1.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.authentication.ProviderManager.java</file>
			<file type="M">org.springframework.security.authentication.ProviderManagerTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1940</link>
		</links>
	</bug>
	<bug id="1940" opendate="2012-03-10 00:49:16" fixdate="2012-07-30 12:13:32" resolution="Fixed">
		<buginformation>
			<summary>ProviderManager does not publish AccountStatusException</summary>
			<description>When using a simple configuration, an authentication provider throwing a LockedException doesn&amp;amp;apos;t cause an AuthenticationFailureLockedEvent to be published. The writeup&amp;amp;apos;s in the Spring forum reference. I can&amp;amp;apos;t be sure this is a bug, but it seems too weird to be expected behavior.</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.authentication.ProviderManager.java</file>
			<file type="M">org.springframework.security.authentication.ProviderManagerTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1917</link>
			<link type="Relate" description="is related to">546</link>
		</links>
	</bug>
	<bug id="1919" opendate="2012-02-20 02:03:21" fixdate="2012-07-31 15:04:04" resolution="Fixed">
		<buginformation>
			<summary>AuthenticationServiceException logged on DEBUG level</summary>
			<description>When LDAP server is not available AuthenticationServiceException should be logged on the ERROR level not on DEBUG.</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.java</file>
			<file type="M">org.springframework.security.ldap.authentication.LdapAuthenticationProvider.java</file>
			<file type="M">org.springframework.security.authentication.AuthenticationServiceException.java</file>
			<file type="M">org.springframework.security.ldap.authentication.LdapAuthenticationProviderTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2020" opendate="2012-07-30 11:10:31" fixdate="2012-07-31 15:05:57" resolution="Fixed">
		<buginformation>
			<summary>Using http@authentication-manager-ref prevents authentication-manager@erase-credential from working</summary>
			<description>In






&amp;lt;sec:http realm="sample-realm" authentication-manager-ref="sampleAuthenticationManager"




      pattern="/sample"&amp;gt;




      &amp;lt;sec:intercept-url pattern="/sample/*" access="ROLE_ADMIN" /&amp;gt;




      &amp;lt;sec:http-basic /&amp;gt;




&amp;lt;/sec:http&amp;gt;









&amp;lt;sec:authentication-manager id="sampleAuthenticationManager" erase-credentials="false"&amp;gt;




    &amp;lt;sec:authentication-provider ref="sampleAuthenticationProvider" /&amp;gt;




&amp;lt;/sec:authentication-manager&amp;gt;






HttpSecurityBeanDefinitionParser wraps "sampleAuthenticationManager" inside a new instance but forgets to pass the value associated to "erase-credentials".






private BeanReference createAuthenticationManager(Element element, ParserContext pc,




            ManagedList&amp;lt;BeanReference&amp;gt; authenticationProviders) {




        String parentMgrRef = element.getAttribute(ATT_AUTHENTICATION_MANAGER_REF);




        BeanDefinitionBuilder authManager = BeanDefinitionBuilder.rootBeanDefinition(ProviderManager.class);




        authManager.addConstructorArgValue(authenticationProviders);









        if (StringUtils.hasText(parentMgrRef)) {




            authManager.addConstructorArgValue(new RuntimeBeanReference(parentMgrRef));




[...]






Credentials get always erased even with erase-credentials="false" in the parent.</description>
			<version>3.1.1</version>
			<fixedVersion>3.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.HttpSecurityBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="2016" opendate="2012-07-20 11:57:28" fixdate="2012-07-31 15:06:35" resolution="Fixed">
		<buginformation>
			<summary>LDAP-based unit tests for spring-security-config project fail</summary>
			<description>When I execute a Run As-&amp;gt;JUnit Test from the "spring-security-config" project off the master branch, 9 out of the 105 tests fail.  All of them fail in a similar manner; not able to find a DN in the embedded ApacheDS server.
When discussing on the forum, Rob W. added that "this is a problem that exists with the test setup in Eclipse. The issue has to do with having multiple *.ldif files available on the classpath."
Here&amp;amp;apos;s the stack trace:






org.springframework.ldap.NameNotFoundException: [LDAP: error code 32 - NO_SUCH_OBJECT: failed for SearchRequest




baseDn : &amp;amp;apos;0.9.2342.19200300.100.1.1=ben,2.5.4.11=people,0.9 .2342.19200300.100.1.25=springframework,0.9.2342.1 9200300.100.1.25=org&amp;amp;apos;




filter : &amp;amp;apos;(2.5.4.0=*)&amp;amp;apos;




scope : base object




typesOnly : false




Size Limit : no limit




Time Limit : no limit




Deref Aliases : deref Always




attributes :




: Attempt to search under non-existant entry: uid=ben,ou=people,dc=springframework,dc=org]; nested exception is javax.naming.NameNotFoundException: [LDAP: error code 32 - NO_SUCH_OBJECT: failed for SearchRequest




baseDn : &amp;amp;apos;0.9.2342.19200300.100.1.1=ben,2.5.4.11=people,0.9 .2342.19200300.100.1.25=springframework,0.9.2342.1 9200300.100.1.25=org&amp;amp;apos;




filter : &amp;amp;apos;(2.5.4.0=*)&amp;amp;apos;




scope : base object




typesOnly : false




Size Limit : no limit




Time Limit : no limit




Deref Aliases : deref Always




attributes :




: Attempt to search under non-existant entry: uid=ben,ou=people,dc=springframework,dc=org]; remaining name &amp;amp;apos;uid=ben,ou=people&amp;amp;apos;




at org.springframework.ldap.support.LdapUtils.convert LdapException(LdapUtils.java:174)




at org.springframework.ldap.core.LdapTemplate.execute WithContext(LdapTemplate.java:810)




at org.springframework.ldap.core.LdapTemplate.execute ReadOnly(LdapTemplate.java:793)




at org.springframework.ldap.core.LdapTemplate.lookup( LdapTemplate.java:834)




at org.springframework.security.config.ldap.LdapServe rBeanDefinitionParserTests.embeddedServerCreationC ontainsExpectedContextSourceAndData(LdapServerBean DefinitionParserTests.java:32)




at sun.reflect.NativeMethodAccessorImpl.invoke0(Nativ e Method)




at sun.reflect.NativeMethodAccessorImpl.invoke(Native MethodAccessorImpl.java:39)




at sun.reflect.DelegatingMethodAccessorImpl.invoke(De legatingMethodAccessorImpl.java:25)




at java.lang.reflect.Method.invoke(Method.java:597)




at org.junit.runners.model.FrameworkMethod$1.runRefle ctiveCall(FrameworkMethod.java:44)




at org.junit.internal.runners.model.ReflectiveCallabl e.run(ReflectiveCallable.java:15)




at org.junit.runners.model.FrameworkMethod.invokeExpl osively(FrameworkMethod.java:41)




at org.junit.internal.runners.statements.InvokeMethod .evaluate(InvokeMethod.java:20)




at org.junit.internal.runners.statements.RunAfters.ev aluate(RunAfters.java:31)




at org.junit.runners.BlockJUnit4ClassRunner.runChild( BlockJUnit4ClassRunner.java:76)




at org.junit.runners.BlockJUnit4ClassRunner.runChild( BlockJUnit4ClassRunner.java:50)




at org.junit.runners.ParentRunner$3.run(ParentRunner. java:193)




at org.junit.runners.ParentRunner$1.schedule(ParentRu nner.java:52)




at org.junit.runners.ParentRunner.runChildren(ParentR unner.java:191)




at org.junit.runners.ParentRunner.access$000(ParentRu nner.java:42)




at org.junit.runners.ParentRunner$2.evaluate(ParentRu nner.java:184)




at org.junit.runners.ParentRunner.run(ParentRunner.ja va:236)




at org.eclipse.jdt.internal.junit4.runner.JUnit4TestR eference.run(JUnit4TestReference.java:50)




at org.eclipse.jdt.internal.junit.runner.TestExecutio n.run(TestExecution.java:38)




at org.eclipse.jdt.internal.junit.runner.RemoteTestRu nner.runTests(RemoteTestRunner.java:467)




at org.eclipse.jdt.internal.junit.runner.RemoteTestRu nner.runTests(RemoteTestRunner.java:683)




at org.eclipse.jdt.internal.junit.runner.RemoteTestRu nner.run(RemoteTestRunner.java:390)




at org.eclipse.jdt.internal.junit.runner.RemoteTestRu nner.main(RemoteTestRunner.java:197)




Caused by: javax.naming.NameNotFoundException: [LDAP: error code 32 - NO_SUCH_OBJECT: failed for SearchRequest




baseDn : &amp;amp;apos;0.9.2342.19200300.100.1.1=ben,2.5.4.11=people,0.9 .2342.19200300.100.1.25=springframework,0.9.2342.1 9200300.100.1.25=org&amp;amp;apos;




filter : &amp;amp;apos;(2.5.4.0=*)&amp;amp;apos;




scope : base object




typesOnly : false




Size Limit : no limit




Time Limit : no limit




Deref Aliases : deref Always




attributes :




: Attempt to search under non-existant entry: uid=ben,ou=people,dc=springframework,dc=org]; remaining name &amp;amp;apos;uid=ben,ou=people&amp;amp;apos;




at com.sun.jndi.ldap.LdapCtx.mapErrorCode(LdapCtx.jav a:3066)




at com.sun.jndi.ldap.LdapCtx.processReturnCode(LdapCt x.java:2987)




at com.sun.jndi.ldap.LdapCtx.processReturnCode(LdapCt x.java:2794)




at com.sun.jndi.ldap.LdapCtx.c_lookup(LdapCtx.java:10 11)




at com.sun.jndi.toolkit.ctx.ComponentContext.p_lookup (ComponentContext.java:526)




at com.sun.jndi.toolkit.ctx.PartialCompositeContext.l ookup(PartialCompositeContext.java:159)




at com.sun.jndi.toolkit.ctx.PartialCompositeContext.l ookup(PartialCompositeContext.java:148)




at javax.naming.InitialContext.lookup(InitialContext. java:392)




at org.springframework.ldap.core.LdapTemplate$10.exec uteWithContext(LdapTemplate.java:836)




at org.springframework.ldap.core.LdapTemplate.execute WithContext(LdapTemplate.java:807)




... 26 more 





</description>
			<version>3.1.1</version>
			<fixedVersion>3.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.ldap.LdapServerBeanDefinitionParserTests.java</file>
			<file type="M">org.springframework.security.config.ldap.LdapUserServiceBeanDefinitionParserTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2017" opendate="2012-07-23 08:36:44" fixdate="2012-08-01 14:34:26" resolution="Fixed">
		<buginformation>
			<summary>ActiveDirectoryLdapAuthenticationProvider.doAuthentication() does not catch IncorrectResultSizeException</summary>
			<description>The mentioned method uses Spring LDAP Template to search for the given user in AD. However, if the given user does not exist at all in the directory, the template throws IncorrectResultSizeException and not NamingException, as expected.






Sample stack-trace in Tomcat:




org.springframework.dao.IncorrectResultSizeDataAccessException: Incorrect result size: expected 1, actual 0




	org.springframework.security.ldap.SpringSecurityLdapTemplate.searchForSingleEntryInternal(SpringSecurityLdapTemplate.java:239)




	org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider.searchForUser(ActiveDirectoryLdapAuthenticationProvider.java:258)




	org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider.doAuthentication(ActiveDirectoryLdapAuthenticationProvider.java:114)




	org.springframework.security.ldap.authentication.AbstractLdapAuthenticationProvider.authenticate(AbstractLdapAuthenticationProvider.java:61)





</description>
			<version>3.1.1</version>
			<fixedVersion>3.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProviderTests.java</file>
			<file type="M">org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider.java</file>
		</fixedFiles>
	</bug>
	<bug id="2022" opendate="2012-08-01 15:29:48" fixdate="2012-08-02 07:55:21" resolution="Complete">
		<buginformation>
			<summary>sec:accesscontrollist hasPermission no longer supports list of values</summary>
			<description></description>
			<version>3.1.1</version>
			<fixedVersion>3.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.taglibs.authz.AccessControlListTagTests.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AccessControlListTag.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">2023</link>
			<link type="Relate" description="is related to">1560</link>
		</links>
	</bug>
	<bug id="2023" opendate="2012-08-01 15:31:00" fixdate="2012-08-02 07:55:48" resolution="Fixed">
		<buginformation>
			<summary>sec:accesscontrollist hasPermission no longer supports integer bitmasks</summary>
			<description></description>
			<version>3.1.1</version>
			<fixedVersion>3.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.taglibs.authz.AccessControlListTagTests.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AccessControlListTag.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">2022</link>
			<link type="Relate" description="is related to">1560</link>
		</links>
	</bug>
	<bug id="2027" opendate="2012-08-07 10:43:29" fixdate="2012-08-07 15:07:28" resolution="Complete">
		<buginformation>
			<summary>FilterChainProxy clearing context causes forwards to clear authentication from the session</summary>
			<description>SEC-1950 added a finally block to the FilterChainProxy doFilter method.
As a result, it seems that when attempting to render a model and view, the forward from tomcat (using 7.0.28) to get the JSP will be allowed.  However, when the SecurityContextPersistenceFilter calls saveContext from its doFilter method, the context is removed from the session as the context after chain execution now has a null authentication object.
With a second forward in place (using sitemesh) the attempt to get the decorator JSP is denied and the user is redirected back to the login page.
I debugged under eclipse, put a break point at the following:

doFilter in the security context persistence filter
wrapRequest (tomcat - ApplicationDispatcher) -&amp;gt; forward
save context (from the finally block of do filter of security context persistence filter)

Observed:

do filter is called, which then calls chain.doFilter to continue the chain after creating the session
wrap request is called (signalling the forward is occuring to get the jsp)
save context is then called which removes the context from the session as it now has a null authentication object

The next request is redirected back to the login page since no authentication attribute exists in the session.
Reverted to spring security 3.1.0 and things work fine.
I have a hard time believing that the change under SEC-1950 was implemented without attempting to render a single model and view, so this may be something funky about our application.  However, given that reverted to 3.1.0 allows everything to function correctly, I figured it was worth creating this issue.
Of note: our JSPs are located in our web application as opposed to statically served so they required authentication.  Perhaps this is abnormal configuration?</description>
			<version>3.1.1</version>
			<fixedVersion>3.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.FilterChainProxyTests.java</file>
			<file type="M">org.springframework.security.web.FilterChainProxy.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">1950</link>
		</links>
	</bug>
	<bug id="2005" opendate="2012-07-13 13:50:16" fixdate="2012-08-07 15:08:57" resolution="Fixed">
		<buginformation>
			<summary>SecurityContext should be persisted immediately when the response is committed</summary>
			<description>Summary of findings
Spring Security should persist the SecurityContext immediately if any of the following methods are invoked since they commit the response and can hand control back to the client immediately. This is similar to SEC-398.

HttpServletResponse.flushBuffer()
HttpServletResponse.getWriter().close()
HttpServletResponse.getWriter().flush()
HttpServletRespose.getOutputStream().close()
HttpServletRespose.getOutputStream().flush()

Original description
During stress/loadtesting of our web application we are experiencing some severe-error issues regarding the freshness of a spring-security security context.
The referenced forum post contains a bit more detail but here is a summary.
A single loadtest client (during high tomcat-7/server load) can execute a "login" establishing a security context and a subsequent API call requiring a security context will fail.  The loadtest client (grinder/jython single threaded (per client)) uses a CommonsHttpInvokerRequestExecutor sending and receiving hessian content over a "typical" http request/response.
The login request is handled by our login service bean which establishes a spring security context.  That security context is persisted in spring-security scope in a "finally" block of SecurityContextPersistenceFilter.doFilter.  
However, the underlying components (take your pick here... tomcat-7 Connector thread, java input/output streams, etc...) have sent the http response content-length number of bytes across the wire and therefore completed the HTTP request and response pair.
The completion of the HTTP request is realized by the loadtest client (and any client I suppose) and moves on to the next HTTP request expecting the proper cookie handling and security context to be applied to the next request.  
This next HTTP request is accepted by the appserver and processed by spring and further spring-security before the finally block on the previous request has executed.  Therefore the spring security context is not available in this subsequent request.  
If I place a client-side delay (100ms or so), that is typically enough time to ensure that the complete spring stack has executed and the spring security context is valid.
We also have this semantically similar issue during "logout".  Prior to logout, we make a call to our server that requires a security context (the last API call of our loadtest workflow).  This call appears "complete" to our clients because the http reqeust/response is complete.  So we continue our loadtest workflow sending a "logout" command.  This clears the spring security context before the finally block of the previous call has executed therefore the completion of the previous request throws an exception because the session is invalid.
Once again, if we place a 100ms delay prior to the logout, no race condition occurs and things work as expected.</description>
			<version>3.0.7</version>
			<fixedVersion>3.0.8, 3.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.HttpSessionSecurityContextRepositoryTests.java</file>
			<file type="M">org.springframework.security.web.context.SaveContextOnUpdateOrErrorResponseWrapper.java</file>
		</fixedFiles>
	</bug>
	<bug id="1975" opendate="2012-06-21 04:32:07" fixdate="2012-08-09 08:17:01" resolution="Fixed">
		<buginformation>
			<summary>AuthenticationSimpleHttpInvokerRequestExecutor and AnonymousAuthenticationToken</summary>
			<description>Hi,
I am working with AuthenticationSimpleHttpInvokerRequestExecutor to add http basic authentication to HTTPInvoker requests. When using the AnonymousAuthenticationFilter to create an AnonymousAuthenticationToken the request executor will extract "anonymousUser" and some randomly generated credentials. In the backend, I have no chance to generate meaningful UserDetails for "anonymousUser".
So wouldn&amp;amp;apos;t it be better to check in prepareConnection() if the Authentication is a UsernamePasswordAuthenticationToken, since these are anyway the only usable tokens for http basic authentication?</description>
			<version>3.0.7</version>
			<fixedVersion>3.0.8, 3.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.remoting.httpinvoker.AuthenticationSimpleHttpInvokerRequestExecutorTests.java</file>
			<file type="M">org.springframework.security.remoting.httpinvoker.AuthenticationSimpleHttpInvokerRequestExecutor.java</file>
		</fixedFiles>
	</bug>
	<bug id="2055" opendate="2012-09-19 05:00:44" fixdate="2012-09-21 13:17:06" resolution="Fixed">
		<buginformation>
			<summary>SaveContextServletOutputStream should delegate flush and close methods to wrapped ServletOutputStream</summary>
			<description>In flush() and close() methods, SaveContextServletOutputStream calls super.flush() and super.close() respectively. These methods do nothing in superclass. Instead,this.delegate.flush() and this.delegate.close() should be called to ensure proper flushing and closing by the wrapped output stream</description>
			<version>3.1.2</version>
			<fixedVersion>3.0.8, 3.1.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.HttpSessionSecurityContextRepositoryTests.java</file>
			<file type="M">org.springframework.security.web.context.SaveContextOnUpdateOrErrorResponseWrapper.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">2041</link>
		</links>
	</bug>
	<bug id="2038" opendate="2012-08-28 09:09:14" fixdate="2012-09-21 13:25:59" resolution="Complete">
		<buginformation>
			<summary>initFilterBean() is not called within AbstractPreAuthenticatedProcessingFilter</summary>
			<description>AbstractPreAuthenticatedProcessingFilter overrides afterPropertiesSet() method thus initFilterBean() from GenericFilterBean is never called. I guess it should by the contract.</description>
			<version>3.1.2</version>
			<fixedVersion>3.0.8, 3.1.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2036" opendate="2012-08-21 03:50:36" fixdate="2012-09-21 13:26:36" resolution="Fixed">
		<buginformation>
			<summary>CookieClearingLogoutHandler doesn&amp;apos;t work with IE for default context</summary>
			<description>The CookieClearingLogoutHandler uses request.getContextPath() to unset the cookie(s). 






 for (String cookieName : cookiesToClear) {




            Cookie cookie = new Cookie(cookieName, null);




            cookie.setPath(request.getContextPath());




            cookie.setMaxAge(0);




            response.addCookie(cookie);




        }






So in default context this method return "" (empty string).
The empty cookie path semantic is expected as "/" by browsers. They all interpret it except IE.
In my case, I use Simple Hash-Based RememberMe Token that can&amp;amp;apos;t be unset and so, users can&amp;amp;apos;t logout from IE.</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.logout.CookieClearingLogoutHandlerTests.java</file>
			<file type="M">org.springframework.security.web.authentication.logout.CookieClearingLogoutHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="2057" opendate="2012-09-19 14:58:36" fixdate="2012-10-03 12:15:05" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentSessionFilter documentation incorrectly states it doesn&amp;apos;t rely on SecurityContextHolder, results in null to all logout handlers Authentication object</summary>
			<description>According to the docs here:
http://static.springsource.org/spring-security/site/docs/3.1.x/reference/springsecurity-single.html#d0e3278
The location of the filter is:
"2) ConcurrentSessionFilter, because it doesn&amp;amp;apos;t use any SecurityContextHolder functionality..."
But as you can see in this line here, it is used. 
https://github.com/SpringSource/spring-security/blob/master/web/src/main/java/org/springframework/security/web/session/ConcurrentSessionFilter.java#L133
It never gets populated due to the location in the filter chain and the Authentication object is always null.
</description>
			<version>3.0.7</version>
			<fixedVersion>3.0.8, 3.1.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.SecurityFilters.java</file>
		</fixedFiles>
	</bug>
	<bug id="2045" opendate="2012-09-06 11:28:44" fixdate="2012-10-04 09:48:58" resolution="Fixed">
		<buginformation>
			<summary>AbstractAuthorizeTag cannot specify which WebInvocationPrivilegeEvaluator</summary>
			<description>AbstractAuthorizeTag uses the first WebInvocationPrivilegeEvaluator which causes problems when evaluating the url attribute and having multiple &amp;lt;http&amp;gt; elements.</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.WebAttributes.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AbstractAuthorizeTag.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2101</link>
			<link type="Duplicate" description="is duplicated by">3073</link>
		</links>
	</bug>
	<bug id="2025" opendate="2012-08-05 09:10:29" fixdate="2012-10-05 16:41:30" resolution="Fixed">
		<buginformation>
			<summary>HttpSessionSecurityContextRepository restores authentication to the new session if session is invalidated from another thread</summary>
			<description>HttpSessionSecurityContextRepository restores authentication to the session if session is invalidated from another thread if SecurityContextPersistenceFilter execution takes significant amount of time.
I am using Spring + JSF + DWR framework + GWT event service (ajax push). In any time there is at least one thread waiting at the server side for push events. This request is handled by SecurityContextPersistenceFilter which remembers the authentication at the moment of request&amp;amp;apos;s arriving to the server. If during the processing of this filter the session is being invalidated (by clicking logout in another tab of invalidating session by id from admin area) then HttpSessionSecurityContextRepository put the outdated authentication to the new session(which is created by JSF framework, so the session is changed during the processing of SecurityContextPersistenceFilter ).
This easily reproducable if some processing delay is inserted to SecurityContextPersistenceFilter.
SaveToSessionResponseWrapper should remember the initial HttpSession and check if the original session was invalidated so it won&amp;amp;apos;t set the current authentication to the new session.</description>
			<version>3.0.7</version>
			<fixedVersion>3.0.8, 3.1.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="1939" opendate="2012-03-09 12:18:19" fixdate="2012-10-07 09:39:56" resolution="Fixed">
		<buginformation>
			<summary>SwitchUserFilter is outputting false error logging.</summary>
			<description>The code introduced in SEC-1763 calls code expecting an exception to be thrown.  It catches the exception in some cases as noop but logs it as an error.  This happens the first time a user logins as using the SwitchUserFilter.  
SwitchUserFilter:296:
        try 
{
            // SEC-1763. Check first if we are already switched.
            currentAuth = attemptExitUser(request);
        }
 catch (AuthenticationCredentialsNotFoundException e) 
{
            currentAuth = SecurityContextHolder.getContext().getAuthentication();
        }

See how it calls attemptExitUser(request).  If it is the first time being switched, an exception will be called and treated as a no-op.
Here&amp;amp;apos;s attemptExitUser():
        if (original == null) 
{
            logger.error("Could not find original user Authentication object!");
            throw new AuthenticationCredentialsNotFoundException(messages.getMessage(
                    "SwitchUserFilter.noOriginalAuthentication",
                    "Could not find original Authentication object"));
        }

That logger.error statement should be removed.</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.switchuser.SwitchUserFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2031" opendate="2012-08-13 03:14:40" fixdate="2012-10-07 10:07:54" resolution="Fixed">
		<buginformation>
			<summary>PreInvocationAuthorizationAdviceVoter checks in support(Class&lt;?&gt;) for super and not for child class</summary>
			<description>The method PreInvocationAuthorizationAdviceVoter.support(Class&amp;lt;?&amp;gt; clazz) checks if clazz is a super class of MethodInvocation and not if its a subclass.</description>
			<version>3.0.7</version>
			<fixedVersion>3.0.8, 3.1.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.prepost.PreInvocationAuthorizationAdviceVoter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2067" opendate="2012-10-19 06:51:45" fixdate="2012-10-19 07:49:38" resolution="Duplicate">
		<buginformation>
			<summary>Security context incorrectly removed from session when asynchronous servlet used</summary>
			<description>Take the following sample servlet:






@Override




protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {




	req.startAsync();




	new Thread("AsyncThread") {




		@Override




		public void run() {




			try {




				TimeUnit.SECONDS.sleep(1);




				resp.getOutputStream().flush();




			} catch (Exception e) {




				e.printStackTrace();




			}




		}




	}.start();




}






As you can see it does nothing except flushing after one second in a separate thread. However this servlet is secured by Spring Security so the resp.getOutputStream() stream is actually an instance of org.springframework.security.web.context.SaveContextOnUpdateOrErrorResponseWrapper.SaveContextServletOutputStream.
This class calls org.springframework.security.web.context.HttpSessionSecurityContextRepository.SaveToSessionResponseWrapper.saveContext() on flush(). That&amp;amp;apos;s where the bug is  This method under certain conditions removes security context from session:






httpSession.removeAttribute(springSecurityContextKey)






This method was heavily rewritten lately (see: See SEC-776, SEC-1587 and SEC-1735) so I can&amp;amp;apos;t tell where the actually bug lies. All I see is that since it can&amp;amp;apos;t find security context in thread local holder (we are flushing from a different thread), it removes the context from the session as well. Basically asynchronous servlet logs me out from the application.
I extracted the error and prepared sample, simplistic application exposing that bug (attached). I actually run into it when using Atmosphere Comet library together with Spring Security, but this application shows exact same error.
Extract and call mvn tomcat7:run. Only one Java class, browse to localhost:8080, login using admin/admin and follow instructions to reproduce.</description>
			<version>3.1.3</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servletapi.HttpServlet3RequestFactory.java</file>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilterTests.java</file>
			<file type="M">org.springframework.security.web.FilterInvocation.java</file>
			<file type="M">org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilterTests.java</file>
			<file type="M">org.springframework.security.web.context.request.async.SecurityContextCallableProcessingInterceptor.java</file>
			<file type="M">org.springframework.security.web.context.request.async.SecurityContextCallableProcessingInterceptorTests.java</file>
			<file type="M">org.springframework.security.web.context.SaveContextOnUpdateOrErrorResponseWrapper.java</file>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.java</file>
			<file type="M">org.springframework.security.config.http.SecurityFilters.java</file>
			<file type="M">org.springframework.security.web.savedrequest.DefaultSavedRequest.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.AbstractRememberMeServicesTests.java</file>
			<file type="M">org.springframework.security.config.http.HttpConfigurationBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1998</link>
		</links>
	</bug>
	<bug id="2072" opendate="2012-11-02 13:53:59" fixdate="2012-11-02 14:58:00" resolution="Fixed">
		<buginformation>
			<summary>&lt;security:anonymous&gt; no longer supports multiple authories</summary>
			<description>Description from the forum:
Hi. I&amp;amp;apos;m using this configuration






&amp;lt;security:anonymous granted-authority="ROLE_INVITADO,ROLE_PROFILE_INVITADO,ROLE_GRUPO_PUBLICO" username="invitado" /&amp;gt;






So the guest has 3 roles. Up until spring 3.1.1.RELEASE if I did






SecurityContextHolder.getContext().getAuthentication().getAuthorities()






I got 3 authorities (as expected).
In Spring 3.1.2.RELEASE I get only one authority and it&amp;amp;apos;s value is






"ROLE_INVITADO,ROLE_PROFILE_INVITADO,ROLE_GRUPO_PUBLICO"






So those 3 comma separated values are not being split in 3.1.2 as they were in 3.1.1.
I&amp;amp;apos;m not sure if it was originally intended to support mutiple roles separating them by comma or not. Was it? Is it now? Any othe way to set that up? Is this a bug in 3.1.2?
I don&amp;amp;apos;t see this change in the version changes, maybe it was an unintended consecuence of some other change.</description>
			<version>3.1.2</version>
			<fixedVersion>3.1.4, 3.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">1909</link>
		</links>
	</bug>
	<bug id="2066" opendate="2012-10-16 14:40:46" fixdate="2012-11-09 12:41:10" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentModificationException when intercepting method pointcut</summary>
			<description>A ConcurrentModificationException is thrown while intercepting a method pointcut. This seems to be on the same lines as the bug: https://jira.springsource.org/browse/SPR-5687






Stack trace:




java.util.ConcurrentModificationException




        at java.util.HashMap$AbstractMapIterator.checkConcurrentMod(HashMap.java:122)




        at java.util.HashMap$AbstractMapIterator.makeNext(HashMap.java:127)




        at java.util.HashMap$KeyIterator.next(HashMap.java:200)




        at org.aspectj.apache.bcel.util.NonCachingClassLoaderRepository$SoftHashMap.clear(NonCachingClassLoaderRepository.java:152)




        at org.aspectj.apache.bcel.util.NonCachingClassLoaderRepository.clear(NonCachingClassLoaderRepository.java:228)




        at org.aspectj.weaver.reflect.Java15AnnotationFinder.getAnnotations(Java15AnnotationFinder.java:223)




        at org.aspectj.weaver.reflect.ReflectionBasedResolvedMemberImpl.unpackAnnotations(ReflectionBasedResolvedMemberImpl.java:213)




        at org.aspectj.weaver.reflect.ReflectionBasedResolvedMemberImpl.hasAnnotation(ReflectionBasedResolvedMemberImpl.java:169)




        at org.aspectj.weaver.JoinPointSignature.hasAnnotation(JoinPointSignature.java:82)




        at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:102)




        at org.aspectj.weaver.patterns.ExactAnnotationTypePattern.matches(ExactAnnotationTypePattern.java:96)




        at org.aspectj.weaver.patterns.SignaturePattern.matchesAnnotations(SignaturePattern.java:717)




        at org.aspectj.weaver.patterns.SignaturePattern.matchesExactly(SignaturePattern.java:371)




        at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:319)




        at org.aspectj.weaver.patterns.KindedPointcut.matchInternal(KindedPointcut.java:202)




        at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:134)




        at org.aspectj.weaver.internal.tools.PointcutExpressionImpl.getShadowMatch(PointcutExpressionImpl.java:239)




        at org.aspectj.weaver.internal.tools.PointcutExpressionImpl.matchesExecution(PointcutExpressionImpl.java:105)




        at org.aspectj.weaver.internal.tools.PointcutExpressionImpl.matchesMethodExecution(PointcutExpressionImpl.java:96)




        at org.springframework.security.intercept.method.ProtectPointcutPostProcessor.attemptMatch(ProtectPointcutPostProcessor.java:118)




        at org.springframework.security.intercept.method.ProtectPointcutPostProcessor.postProcessBeforeInitialization(ProtectPointcutPostProcessor.java:106)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:394)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1413)




        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.configureBean(AbstractAutowireCapableBeanFactory.java:315)




        at org.springframework.beans.factory.wiring.BeanConfigurerSupport.configureBean(BeanConfigurerSupport.java:146)




        at org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect.configureBean(AnnotationBeanConfigurerAspect.aj:59)




        at org.springframework.beans.factory.aspectj.AbstractDependencyInjectionAspect.ajc$before$org_springframework_beans_factory_aspectj_AbstractDependencyInjectionAspect$1$e854fa65(AbstractDependencyInjectionAspect.aj:80)





</description>
			<version>2.0.5</version>
			<fixedVersion>3.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.method.ProtectPointcutPostProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="1998" opendate="2012-07-08 20:35:03" fixdate="2012-12-03 09:37:58" resolution="Complete">
		<buginformation>
			<summary>Support for Servlet 3.0/3.1 asynchronous request processing</summary>
			<description>Similar to SPR-8517 Spring Security should support Asynch Servlet request processing
Note: SEC-2067 has a sample application that should be validated against when fixing this issue</description>
			<version>3.1.3</version>
			<fixedVersion>3.2.0.M1</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servletapi.HttpServlet3RequestFactory.java</file>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilterTests.java</file>
			<file type="M">org.springframework.security.web.FilterInvocation.java</file>
			<file type="M">org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilterTests.java</file>
			<file type="M">org.springframework.security.web.context.request.async.SecurityContextCallableProcessingInterceptor.java</file>
			<file type="M">org.springframework.security.web.context.request.async.SecurityContextCallableProcessingInterceptorTests.java</file>
			<file type="M">org.springframework.security.web.context.SaveContextOnUpdateOrErrorResponseWrapper.java</file>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.java</file>
			<file type="M">org.springframework.security.config.http.SecurityFilters.java</file>
			<file type="M">org.springframework.security.web.savedrequest.DefaultSavedRequest.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.AbstractRememberMeServicesTests.java</file>
			<file type="M">org.springframework.security.config.http.HttpConfigurationBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">2077</link>
			<link type="Duplicate" description="is duplicated by">2067</link>
			<link type="Relate" description="is related to">2111</link>
		</links>
	</bug>
	<bug id="2084" opendate="2012-11-25 14:29:58" fixdate="2012-12-03 13:19:42" resolution="Complete">
		<buginformation>
			<summary>NullPointerException for intercept-url without specified method</summary>
			<description>There is a NullPointerException when Spring Security attempts to find which Http methods that are allowed for a resource whose intercept-url does not have any specific method. 

Unzip the provided project
Execute "mvn jetty:run"
Navigate to http://localhost:8080/application.wadl in a browser
Enter the credentials "user" / "secret"

Expected result:
A generated wadl file such as the provided application.3.0.7.wadl (see the root folder of the attached .zip file).
Actual result:
java.lang.NullPointerException: Name is null
	at java.lang.Enum.valueOf(Enum.java:235)
	at org.springframework.http.HttpMethod.valueOf(HttpMethod.java:1)
	at org.springframework.security.web.util.AntPathRequestMatcher.matches(AntPathRequestMatcher.java:83)
	at org.springframework.security.web.access.intercept.DefaultFilterInvocationSecurityMetadataSource.getAttributes(DefaultFilterInvocationSecurityMetadataSource.java:86)
	at org.springframework.security.web.access.DefaultWebInvocationPrivilegeEvaluator.isAllowed(DefaultWebInvocationPrivilegeEvaluator.java:90)
	at org.springframework.security.web.access.DefaultWebInvocationPrivilegeEvaluator.isAllowed(DefaultWebInvocationPrivilegeEvaluator.java:67)
	at com.jayway.security.WADLGenerator.createResource(WADLGenerator.java:39)
	at com.sun.jersey.server.wadl.WadlBuilder.generateResource(WadlBuilder.java:330)
	at com.sun.jersey.server.wadl.WadlBuilder.generateResource(WadlBuilder.java:326)
	at com.sun.jersey.server.wadl.WadlBuilder.generate(WadlBuilder.java:108)
	at com.sun.jersey.server.impl.wadl.WadlApplicationContextImpl.getApplication(WadlApplicationContextImpl.java:111)
	at com.sun.jersey.server.impl.wadl.WadlApplicationContextInjectionProxy.getApplication(WadlApplicationContextInjectionProxy.java:63)
	at com.sun.jersey.server.impl.wadl.WadlResource.getWadl(WadlResource.java:95)
[...]
Note:
The above steps work in the 3.0.7 version of Spring Security. Simply

Change the org.springframework.security.version in the pom.xml to 3.0.7.RELEASE
Update the spring security schema location in the securityContext.xml to http://www.springframework.org/schema/security/spring-security-3.0.4.xsd
Visit http://localhost:8080/application.wadl (log in using the credentials above)
The result is the application.3.0.7.wadl file in the root folder of the attached zip file

The NPE may (or may not) be another manifestation of the issue that was reported in https://jira.springsource.org/browse/SEC-1836 ?</description>
			<version>3.1.3</version>
			<fixedVersion>3.1.4, 3.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.util.AntPathRequestMatcher.java</file>
			<file type="M">org.springframework.security.web.util.AntPathRequestMatcherTests.java</file>
			<file type="M">org.springframework.security.web.util.RegexRequestMatcherTests.java</file>
			<file type="M">org.springframework.security.web.util.RegexRequestMatcher.java</file>
		</fixedFiles>
	</bug>
	<bug id="2096" opendate="2012-12-13 06:37:32" fixdate="2012-12-18 13:17:54" resolution="Fixed">
		<buginformation>
			<summary>Dependency on spring-*-SNAPSHOT</summary>
			<description>The 3.2 release&amp;amp;apos;s poms point to spring-*SNAPSHOT jars</description>
			<version>3.2.0.M1</version>
			<fixedVersion>3.2.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.core.SpringSecurityCoreVersion.java</file>
		</fixedFiles>
	</bug>
	<bug id="2101" opendate="2012-12-19 03:38:46" fixdate="2012-12-27 13:19:49" resolution="Duplicate">
		<buginformation>
			<summary>AbstractAuthorizeTag.getPrivilegeEvaluator() always returns first WebInvocationPrivilegeEvaluator found</summary>
			<description>When using the authorize tag like this:






&amp;lt;sec:authorize method="POST" url="/data/hosts"&amp;gt;....&amp;lt;/sec:authorize&amp;gt;






...the AbstractAuthorizeTag.getPrivilegeEvaluator() method is requested to return an evaluator. But this method will always return the first it finds even if more than one is found. This is especially a problem if one or more of the &amp;amp;apos;sections&amp;amp;apos; of privileges are aimed at something else than a HTML access(fx. JSON API).
I have this in my springsecuritycontext.xml:






&amp;lt;http request-matcher-ref="jsonMatcher" create-session="stateless" authentication-manager-ref="apiAuthMgr"&amp;gt;




        &amp;lt;intercept-url pattern="/data/**" access="ROLE_API_USER" /&amp;gt;




        &amp;lt;http-basic /&amp;gt;




    &amp;lt;/http&amp;gt;




    




    &amp;lt;http authentication-manager-ref="siteAuthMgr"&amp;gt;




        &amp;lt;intercept-url  method="PUT" pattern="/data/**" access="ROLE_IT-infrastruktur" /&amp;gt;




        &amp;lt;intercept-url  method="POST" pattern="/data/**" access="ROLE_IT-infrastruktur" /&amp;gt;




        &amp;lt;intercept-url  method="DELETE" pattern="/data/**" access="ROLE_IT-infrastruktur" /&amp;gt;




        &amp;lt;intercept-url  method="GET" pattern="/data/credentials**" access="ROLE_IT-infrastruktur" /&amp;gt;




        &amp;lt;form-login/&amp;gt;




    &amp;lt;/http&amp;gt;




.......






This work flawlessly in regards to using the correct authentication-manager based on the request-matcher, but when it comes to the authorize-tag it will always try to match on the first section, because AbstractAuthorizeTag.getPrivilegeEvaluator() always returns the first one:






private WebInvocationPrivilegeEvaluator getPrivilegeEvaluator() throws IOException {




        ApplicationContext ctx = WebApplicationContextUtils.getRequiredWebApplicationContext(getServletContext());




        Map&amp;lt;String, WebInvocationPrivilegeEvaluator&amp;gt; wipes = ctx.getBeansOfType(WebInvocationPrivilegeEvaluator.class);









        if (wipes.size() == 0) {




            throw new IOException(




                    "No visible WebInvocationPrivilegeEvaluator instance could be found in the application "




                            + "context. There must be at least one in order to support the use of URL access checks in &amp;amp;apos;authorize&amp;amp;apos; tags.");




        }









        return (WebInvocationPrivilegeEvaluator) wipes.values().toArray()[0];   &amp;lt;---- PROBLEM (Line 340)




    }





</description>
			<version>3.1.2</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.WebAttributes.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AbstractAuthorizeTag.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2045</link>
		</links>
	</bug>
	<bug id="2111" opendate="2013-01-02 07:32:35" fixdate="2013-01-28 11:56:27" resolution="Fixed">
		<buginformation>
			<summary>Disable auto save of SecurityContext when response committed after startAsync invoked</summary>
			<description>Updated Description
Previously Spring Security would disable automatically saving the SecurityContext when the Thread was different than the Thread that created the SaveContextOnUpdateOrErrorResponseWrapper. This worked for many cases, but could cause issues when a timeout occurred. The problem is that a Thread can be reused to process the timeout since the Threads are pooled. This means that a timeout of a request trigger an apparent logout as described in the following workflow:

The SecurityContext was established on the SecurityContextHolder
An Async request was made
The SecurityContextHolder would be cleared out
The Async request times out
The Async request would be dispatched back to the container upon
        timing out. If the container reused the same Thread to process the
        timeout as the original request, Spring Security would attempt to
        save the SecurityContext when the response was committed. Since the
        SecurityContextHolder was still cleared out it removes the
        SecurityContext from the HttpSession

Spring Security should prevent the SecurityContext from automatically being saved when the response is committed as soon as ServletRequest#startAsync() or   ServletRequest#startAsync(ServletRequest,ServletResponse) is called as apposed to looking at the Thread equality.
Original Description
I still see the same behavior on DeferredResult controllers. (after some time there is an auto logout)
It doesn&amp;amp;apos;t always happen as it used to before 3.2.0.M1 .
Logs are just before logging out occurs and are related to an AJAX call to a deferredResult method.











Logs:




2013-01-01 16:20:08,019 DEBUG yContextPersistenceFilter:97 - SecurityContextHolder now cleared, as request processing completed




...




2013-01-01 16:21:32,649 DEBUG eToSessionResponseWrapper:140 - Skip saving SecurityContext since processing the HttpServletResponse on a different Thread than the original HttpServletRequest




...




2013-01-01 16:22:01,650 DEBUG SecurityContextRepository:269 - SecurityContext is empty or contents are anonymous - context will not be stored in HttpSession.




...




2013-01-01 16:22:03,660 DEBUG AntPathRequestMatcher :116 - Checking match of request : &amp;amp;apos;/deferred&amp;amp;apos;; against &amp;amp;apos;/resources/**&amp;amp;apos;




...




2013-01-01 16:22:03,661 DEBUG SecurityContextRepository:139 - HttpSession returned null object for SPRING_SECURITY_CONTEXT




2013-01-01 16:22:03,661 DEBUG SecurityContextRepository:85 - No SecurityContext was available from the HttpSession: org.apache.catalina.session.StandardSessionFacade@5b3cc94b. A new one will be created.




...




2013-01-01 16:22:03,664 DEBUG ymousAuthenticationFilter:102 - Populated SecurityContextHolder with anonymous token: &amp;amp;apos;org.springframework.security.authentication.AnonymousAuthenticationToken@90541710: Principal: anonymousUser; Credentials: [PROTECTED]; Authenticated: true; Details: org.springframework.security.web.authentication.WebAuthenticationDetails@166c8: RemoteIpAddress: 0:0:0:0:0:0:0:1; SessionId: 6D46ACB5AEA101C58A838529A3F6ED1D; Granted Authorities: ROLE_ANONYMOUS&amp;amp;apos;




...




2013-01-01 16:22:03,667 DEBUG FilterSecurityInterceptor:310 - Previously Authenticated: org.springframework.security.authentication.AnonymousAuthenticationToken@90541710: Principal: anonymousUser; Credentials: [PROTECTED]; Authenticated: true; Details: org.springframework.security.web.authentication.WebAuthenticationDetails@166c8: RemoteIpAddress: 0:0:0:0:0:0:0:1; SessionId: 6D46ACB5AEA101C58A838529A3F6ED1D; Granted Authorities: ROLE_ANONYMOUS




...




2013-01-01 16:22:03,668 DEBUG AffirmativeBased :65 - Voter: org.springframework.security.web.access.expression.WebExpressionVoter@52d9eb97, returned: -1




...




2013-01-01 16:22:03,668 DEBUG xceptionTranslationFilter:165 - Access is denied (user is anonymous); redirecting to authentication entry point




org.springframework.security.access.AccessDeniedException: Access is denied





</description>
			<version>3.2.0.M1</version>
			<fixedVersion>3.2.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.HttpSessionSecurityContextRepositoryTests.java</file>
			<file type="M">org.springframework.security.web.context.SaveContextOnUpdateOrErrorResponseWrapper.java</file>
			<file type="M">org.springframework.security.web.context.HttpSessionSecurityContextRepository.java</file>
			<file type="M">org.springframework.security.web.context.SaveContextOnUpdateOrErrorResponseWrapperTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">1998</link>
		</links>
	</bug>
	<bug id="2136" opendate="2013-02-25 06:00:52" fixdate="2013-02-28 09:09:20" resolution="Fixed">
		<buginformation>
			<summary>Injecting Bean in a class used in custom PermissionEvaluator leads to NoSuchBeanDefinitionException</summary>
			<description>Autowiring a bean in a class used in a custom PermissionEvaluator leads to NoSuchBeanDefinitionException. If the @Autowire annotation is commented in code, the context loads correctly (but tests obviously then fail).
This is similar to referenced post in spring forums.











public class TestEntityPermission extends AbstractPermission {









    @Autowired // comment this and context loads




    private TestEntityService testEntityService;




    




    public boolean isAllowed(Authentication authentication, Object targetDomainObject,




            String permissionType) {




        //...




    }




}









public class DefaultPermissionEvaluator implements PermissionEvaluator {









    private Map&amp;lt;String, Permission&amp;gt; permissionNameToPermissionMap = new HashMap&amp;lt;&amp;gt;();









	private boolean checkPermissionByDomainObject(Authentication authentication,




            Object targetDomainObject, String permissionValue) {




        String permissionType = getPermissionType(permissionValue);




        String permissionName = getPermissionTarget(permissionValue);




        verifyPermissionIsDefined(permissionName);




        Permission permission = permissionNameToPermissionMap.get(permissionName);




        return permission.isAllowed(authentication, targetDomainObject, permissionType);




    }









}






Attached is a sample App (maven) with the according test case.</description>
			<version>3.1.3</version>
			<fixedVersion>3.2.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.method.GlobalMethodSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.access.expression.method.ExpressionBasedAnnotationAttributeFactory.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">292</link>
			<link type="Relate" description="relates to">10353</link>
		</links>
	</bug>
	<bug id="2140" opendate="2013-02-28 09:56:15" fixdate="2013-02-28 10:04:39" resolution="Fixed">
		<buginformation>
			<summary>AclAuthorizationStrategyImpl javadoc should list actions in correct order</summary>
			<description></description>
			<version>3.1.3</version>
			<fixedVersion>3.2.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.domain.AclAuthorizationStrategyImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="2143" opendate="2013-03-05 05:00:19" fixdate="2013-03-06 09:01:57" resolution="Fixed">
		<buginformation>
			<summary>Error message still mentioning version 3.1</summary>
			<description>The error message in the SecurityNamespaceHandler.parse() method still mentions Spring Security Version 3.1 if an old xsd is used.</description>
			<version>3.2.0.M1</version>
			<fixedVersion>3.2.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandler.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">2145</link>
		</links>
	</bug>
	<bug id="2087" opendate="2012-11-28 14:57:49" fixdate="2013-04-25 07:00:00" resolution="Fixed">
		<buginformation>
			<summary>GlobalMethodSecurityBeanDefinitionParser.AuthenticationManagerDelegator attempts to get a bean using the concrete implementation</summary>
			<description>In the authenticate method of the AuthenticationManagerDelegator inner class, it is attempted to get a bean of class org.springframework.security.authentication.ProviderManager.
In the Eclipse Virgo container when the AuthenticationManager is referenced as a service, the ProviderManager will be wrapped inside a Proxy class and the following Exception will be thrown:
Failed to call secure method org.springframework.beans.factory.BeanNotOfRequiredTypeException: Bean named &amp;amp;apos;authenticationManager&amp;amp;apos; must be of type [org.springframework.security.authentication.ProviderManager], but was actually of type [$Proxy94]
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:360)
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)
at org.springframework.security.config.method.GlobalMethodSecurityBeanDefinitionParser$AuthenticationManagerDelegator.authenticate(GlobalMethodSecurityBeanDefinitionParser.java:386)
The bean should be looked up by the org.springframework.security.authentication.AuthenticationManager interface.
The following change works properly for the described scenario.
Original code (at line 386):
try {
   delegate = beanFactory.getBean(authMgrBean, ProviderManager.class);
} catch (NoSuchBeanDefinitionException e) {
Changed to:
try {
   delegate = beanFactory.getBean(authMgrBean, AuthenticationManager.class);
} catch (NoSuchBeanDefinitionException e) {</description>
			<version>3.1.3</version>
			<fixedVersion>3.1.4, 3.2.0</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.method.GlobalMethodSecurityBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.method.GlobalMethodSecurityBeanDefinitionParserTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2187" opendate="2013-06-24 08:12:30" fixdate="2013-07-05 08:36:05" resolution="Fixed">
		<buginformation>
			<summary>OpenIDAuthenticationFilter should encode URL parameters</summary>
			<description>OpenIDAuthenticationFilter has the ability to propagate existing query parameters on the request through the return_to URL submitted as part of the OpenID authentication process. However, these values are not encoded as application/x-www-form-urlencoded, leading to potential ambiguities later on if these values contain reserved characters.</description>
			<version>3.0.7</version>
			<fixedVersion>3.2.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.openid.OpenIDAuthenticationFilter.java</file>
			<file type="M">org.springframework.security.openid.OpenIDAuthenticationFilterTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2191" opendate="2013-07-02 10:30:53" fixdate="2013-07-05 11:11:30" resolution="Complete">
		<buginformation>
			<summary>AuthenticationManagerBuilder requires a ObjectPostProcessor</summary>
			<description>In order to function properly, AuthenticationManagerBuilder requires an ObjectPostProcessor other than QUIESCENT_POSTPROCESSOR. We should provide a way to make use of AuthenticationManagerBuilder easier.
For example instead of:






@Configuration




@EnableGlobalMethodSecurity(prePostEnabled=true)




public class SampleWebSecurityConfig {









  @Bean




  public AuthenticationManager authenticationManager() throws Exception {




    return new AuthenticationManagerBuilder()




        .inMemoryAuthentication()




          .withUser("user").password("password").roles("USER").and()




        .build();




  }




}






We should support:






@Configuration




@EnableGlobalMethodSecurity(prePostEnabled=true)




public class SampleWebSecurityConfig {









  @Autowired




  public void authenticationManager(AuthenticationManagerBuilder auth) throws Exception {




    auth




        .inMemoryAuthentication()




          .withUser("user").password("password").roles("USER");




  }




}





</description>
			<version>3.2.0.M2</version>
			<fixedVersion>3.2.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configuration.EnableWebSecurity.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.java</file>
			<file type="M">org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity.java</file>
			<file type="M">org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder.java</file>
			<file type="M">org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="2215" opendate="2013-07-16 04:51:40" fixdate="2013-07-16 20:47:48" resolution="Fixed">
		<buginformation>
			<summary>Injecting AuthenticationManager to SecurityContextHolderAwareRequestFilter</summary>
			<description>I am trying to use servletApi() of Spring Security 3.2 M2 at my embedded Jetty 9.x application but could not be successful. AuthenticationManager seems null at SecurityContextHolderAwareRequestFilter. And because of this HttpServlet3RequestFactory is created with null authenticationManager. 
Here is the implementation of my Security Config:






@Configuration




@EnableWebSecurity




public class SecurityConfig extends WebSecurityConfigurerAdapter {














   @Override




   protected void registerAuthentication(AuthenticationManagerBuilder auth) throws Exception {




      auth




         .inMemoryAuthentication()




         .withUser("user").password("password").roles("USER")




         .and();




   }









   @Bean




   @Override




   public AuthenticationManager authenticationManagerBean()  throws Exception {




      return super.authenticationManagerBean();




   }














   @Override




   protected void configure(HttpSecurity http) throws Exception {




      http




//         .exceptionHandling().and()




         .sessionManagement()




            .sessionCreationPolicy(SessionCreationPolicy.ifRequired)




            .sessionRegistry(new StarSessionRegistry()).and().and()




         .securityContext().and()




//         .requestCache().and()




//         .anonymous().and()




         .servletApi().and()




//         .apply(new DefaultLoginPageConfigurer&amp;lt;HttpSecurity&amp;gt;()).and()




//         .logout()




//         .and()




         .authorizeUrls()




         .antMatchers("/login").permitAll()




         .antMatchers("/**").authenticated();




   }




}






As a workaround I have implemented a custom beanpostprocessor which is injecting an authenticationManager. 
I am very new to Spring Security but I have checked test cases and sample applications but could not find something useful. </description>
			<version>3.2.0.M2</version>
			<fixedVersion>3.2.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.LogoutConfigurer.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.ServletApiConfigurer.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.ExceptionHandlingConfigurer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2198" opendate="2013-07-10 06:14:37" fixdate="2013-07-19 14:36:12" resolution="Complete">
		<buginformation>
			<summary>http.httpBasic() does not properly default the AuthenticationEntryPoint</summary>
			<description>The following code should use BasicAuthenticationEntryPoint






@Override




protected void configure(HttpSecurity http) throws Exception {




    http




        .authorizeUrls()




            .anyRequest().authenticated()




            .and()




        .httpBasic();       




}






A workaround for now is:











@Bean




public BasicAuthenticationEntryPoint entryPoint() {




    BasicAuthenticationEntryPoint basicAuthEntryPoint = new BasicAuthenticationEntryPoint();




    basicAuthEntryPoint.setRealmName("My Realm");




    return basicAuthEntryPoint;




}









@Override




protected void configure(HttpSecurity http) throws Exception {









    http




        .exceptionHandling()




            .authenticationEntryPoint(entryPoint())




            .and()




        .authorizeUrls()




            .anyRequest().authenticated()




            .and()




        .httpBasic();       




}










</description>
			<version>3.2.0.M2</version>
			<fixedVersion>3.2.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.HttpBasicConfigurer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2222" opendate="2013-07-19 23:43:50" fixdate="2013-07-20 05:50:12" resolution="Fixed">
		<buginformation>
			<summary>Javadoc error - WebSecurityConfigurerAdapter.registerAuthentication &amp; EnableWebSecurity refer to wrong parameter</summary>
			<description>The example for WebSecurityConfigurerAdapter.registerAuthentication and EnableWebSecurity refer to &amp;amp;apos;registry&amp;amp;apos; rather than &amp;amp;apos;auth&amp;amp;apos;.</description>
			<version>3.2.0.M2</version>
			<fixedVersion>3.2.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configuration.EnableWebSecurity.java</file>
		</fixedFiles>
	</bug>
	<bug id="2223" opendate="2013-07-21 12:28:59" fixdate="2013-07-22 09:36:13" resolution="Fixed">
		<buginformation>
			<summary>FirewallRequest#reset() has incomplete javadoc</summary>
			<description></description>
			<version>3.1.4</version>
			<fixedVersion>3.2.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.firewall.FirewalledRequest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2237</link>
		</links>
	</bug>
	<bug id="2205" opendate="2013-07-15 13:16:31" fixdate="2013-07-22 14:39:54" resolution="Complete">
		<buginformation>
			<summary>Create UserDetailsServiceDelegator</summary>
			<description>Ordering issues can cause the UserDetailsService to be null. To resolve this, a UserDetailsServiceDelegator should be created. An example workaround can be found below:






@Configuration




@EnableWebSecurity




public class SecurityConfig extends WebSecurityConfigurerAdapter {




    private UserDetailsServiceDelegator userDetailsService = new UserDetailsServiceDelegator();









    @Bean




    @Override




    public UserDetailsService userDetailsServiceBean() throws Exception {




        return userDetailsService;




    }














    @Override




    protected void registerAuthentication(




            AuthenticationManagerBuilder auth) throws Exception {




        userDetailsService.setBuilder(auth);




        ...




    }




    




    static final class UserDetailsServiceDelegator implements UserDetailsService {




        private AuthenticationManagerBuilder delegateBuilder;




        private UserDetailsService delegate;




        private final Object delegateMonitor = new Object();









        private void setBuilder(AuthenticationManagerBuilder authentication) {




            this.delegateBuilder = authentication;




        }









        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { 




            if(delegate != null) {




                return delegate.loadUserByUsername(username);




            }









            synchronized(delegateMonitor) {




                if (delegate == null) {




                    delegate = this.delegateBuilder.getDefaultUserDetailsService();




                    this.delegateBuilder = null;




                }




            }









            return delegate.loadUserByUsername(username);




        }




    }




}





</description>
			<version>3.2.0.M2</version>
			<fixedVersion>3.2.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2237" opendate="2013-07-30 07:13:08" fixdate="2013-07-30 07:26:22" resolution="Duplicate">
		<buginformation>
			<summary>API documentation for FirewalledRequest.reset() incomplete</summary>
			<description>The API documentation of the method FirewalledRequest.reset is incomplete and ends immendiately before giving the most important piece of information:
Right now, the last setence reads like this:
"An implementation can thus choose to modify the state of the request for the security infrastructure, while still maintaining the [!]"
The important information is what is still maintained. This is missing right now.</description>
			<version>3.2.0.M2</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.firewall.FirewalledRequest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2223</link>
		</links>
	</bug>
	<bug id="2137" opendate="2013-02-26 05:34:54" fixdate="2013-08-15 13:07:27" resolution="Fixed">
		<buginformation>
			<summary>Session fixation protection cannot be disabled when concurrent session control is enabled</summary>
			<description>Related to: SEC-2002
Blocked by: SEC-2135
Please see the following snippet from our application&amp;amp;apos;s security config:






...




    &amp;lt;session-management invalid-session-url="/web/login/timedOut"




                        session-fixation-protection="none"




                        session-authentication-error-url=""&amp;gt;




        &amp;lt;concurrency-control expired-url="/web/login/expired"




                             max-sessions="5"




                             error-if-maximum-exceeded="false"




                             session-registry-alias="sessionRegistry" /&amp;gt;




    &amp;lt;/session-management&amp;gt;




...






The presence of &amp;lt;concurrency-control&amp;gt; causes a ConcurrentSessionControlStrategy to be created. Since this extends SessionFixationProtectionStrategy it forces the enabling of session migration, even if session fixation protection is set to "none". I have verified this by looking at the code. This is pretty big problem, and the documentation certainly does not indicate that this was intentional.
A change to how this whole system works was proposed in SEC-2135. The resolution for that enhancement request will also fix this bug. However, the bug probably needs to exist for tracking and historical purposes.</description>
			<version>3.1.0</version>
			<fixedVersion>3.2.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.SessionManagementConfigurer.java</file>
			<file type="M">org.springframework.security.web.authentication.session.ConcurrentSessionControlStrategy.java</file>
			<file type="M">org.springframework.security.config.http.HttpConfigurationBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="2280" opendate="2013-08-24 21:24:59" fixdate="2013-08-24 21:31:25" resolution="Complete">
		<buginformation>
			<summary>Fix SessionFixationConfigurer#changeSessionId Javadoc</summary>
			<description>The Javadoc for SessionFixationConfigurer#changeSessionId() was copied and pasted from SessionFixationConfigurer#none() and never updated. It is incorrect. This commit fixes that. It also adds a newline at the end of the file, which the file was missing, causing Git to complain.
Pull request https://github.com/SpringSource/spring-security/pull/42</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.SessionManagementConfigurer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2276" opendate="2013-08-22 06:47:55" fixdate="2013-08-24 21:32:23" resolution="Complete">
		<buginformation>
			<summary>Delay storing the CsrfToken until the CsrfToken is accessed</summary>
			<description>Rather than adding the CsrfToken to the HttpSession immediately, we can delay adding the CsrfToken until the token is accessed on the servlet request. This ensures that only a request that is just prior to CSRF will create the session.</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servlet.support.csrf.CsrfRequestDataValueProcessorTests.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfToken.java</file>
			<file type="D">org.springframework.security.web.csrf.CsrfTokenTests.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfTokenRepository.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfFilterTests.java</file>
			<file type="M">org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.SessionManagementConfigurerServlet31Tests.java</file>
			<file type="M">org.springframework.security.web.csrf.HttpSessionCsrfTokenRepositoryTests.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2376</link>
		</links>
	</bug>
	<bug id="2103" opendate="2012-12-24 20:12:01" fixdate="2013-08-24 21:41:26" resolution="Fixed">
		<buginformation>
			<summary>Querying token for series: thread dump for info level </summary>
			<description>In case of empty remember me tokens JdbcTokenRepositoryImpl writes thread dump to log file that is not required because it&amp;amp;apos;s clear from context:






        catch(EmptyResultDataAccessException zeroResults) {




            if(logger.isInfoEnabled()) {




                logger.info("Querying token for series &amp;amp;apos;" + seriesId + "&amp;amp;apos; returned no results.", zeroResults);




            }




        }






Is it possible to change level to debug or remove thread dump (better for me)?</description>
			<version>3.1.2</version>
			<fixedVersion>3.1.5, 3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImplTests.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">1964</link>
		</links>
	</bug>
	<bug id="2272" opendate="2013-08-21 05:10:58" fixdate="2013-08-27 14:47:18" resolution="Fixed">
		<buginformation>
			<summary>CsrfRequestDataValueProcessor should support Spring 4.2.0M2+</summary>
			<description>RequestDataValueProcessor was changed non-passively in Spring 4.0.0.M2 so we should make changes to CsrfRequestDataValueProcessor to support both versions. See https://jira.springsource.org/browse/SPR-10041</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.CsrfBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configuration.CsrfWebMvcConfiguration.java</file>
			<file type="M">org.springframework.security.web.servlet.support.csrf.CsrfRequestDataValueProcessorTests.java</file>
			<file type="M">org.springframework.security.web.servlet.support.csrf.CsrfRequestDataValueProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">10041</link>
		</links>
	</bug>
	<bug id="2295" opendate="2013-08-29 08:15:52" fixdate="2013-08-29 14:52:20" resolution="Fixed">
		<buginformation>
			<summary>Remove ERROR log when Spring Security is embedded into an UberJar</summary>
			<description>We embed Spring Security and Spring DI into a common Uber-Jar as part of a Dropwizard application.
We use the Gradle Shadow plugin to do this (the Gradle version of the Maven Shade plugin).
However, as soon as we add an implementation version to the generated JAR
Spring Security logs an ERROR at start up:
e.g.
ERROR [2013-08-29 15:09:23,322] org.springframework.security.core.SpringSecurityCoreVersion: *** Spring Major version &amp;amp;apos;3&amp;amp;apos; expected, but you are running with version: 1.1.4-SNAPSHOT. Please check your classpath for unwanted jar files.
This error should be changed to either a WARN or an INFO. 
It is very unnerving for customers to see an ERROR like this at start up and they will raise support tickets or alert sysadmins.
Alternatively, there should be a way to disable this check programmatically or via configuration.
See reproducible test case:
https://github.com/jacek99/dropwizard-spring-di-security-onejar-example
git clone it and then using Gradle 1.6 or higher execute
gradle runShadow
You will see the error on the screen.</description>
			<version>3.1.4</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.core.SpringSecurityCoreVersionTests.java</file>
			<file type="M">org.springframework.security.core.SpringSecurityCoreVersion.java</file>
		</fixedFiles>
	</bug>
	<bug id="2296" opendate="2013-08-30 08:56:00" fixdate="2013-08-31 10:06:39" resolution="Fixed">
		<buginformation>
			<summary>HttpServletRequest.login should throw ServletException if already authenticated</summary>
			<description>http://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login%28java.lang.String,%20java.lang.String%29</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servletapi.HttpServlet3RequestFactory.java</file>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilterTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2308" opendate="2013-09-06 03:49:14" fixdate="2013-09-13 15:54:41" resolution="Complete">
		<buginformation>
			<summary>DefaultSpringSecurityContextSource should accept empty Base DNs</summary>
			<description>If DefaultSpringSecurityContextSource is constructed through DefaultSpringSecurityContextSource(List&amp;lt;String&amp;gt; urls, String baseDn) with an empty string for baseDn,it fails as follows in line 127






            if (trimmedUrl.contains(trimmedBaseDn)) {




                throw new IllegalArgumentException("LDAP URL string must not include the base DN! &amp;amp;apos;" + trimmedUrl + "&amp;amp;apos;");




            }











This check is over-eager if the Base DN is empty. This is the case with at least one of our customers, where their directory has an anonymous base.
I suggest to amend that check with a condition that trimmedBaseDn is longer than zero.</description>
			<version>3.1.4</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.DefaultSpringSecurityContextSource.java</file>
			<file type="M">org.springframework.security.ldap.DefaultSpringSecurityContextSourceTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2246" opendate="2013-08-06 02:17:01" fixdate="2013-09-20 14:06:07" resolution="Complete">
		<buginformation>
			<summary>HttpSessionRequestCache.getRequest performs cast to concrete DefaultSavedRequest instead of interface SavedRequest</summary>
			<description>org.springframework.security.web.savedrequest.HttpSessionRequestCache.getRequest loads the SavedRequest object form session. The method signature is using the correct SavedRequest interface. The implementation performs a cast to DefaultSavedRequest. 
Using a custom implementation of the interface SavedRequest in the security context causes ClassCastException when the method is used to load the SavedRequest.
The interface should be used for cast since the method getRequest itself is not using any method of the concrete default implementation.</description>
			<version>3.1.4</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.savedrequest.HttpSessionRequestCacheTests.java</file>
			<file type="M">org.springframework.security.web.savedrequest.HttpSessionRequestCache.java</file>
		</fixedFiles>
	</bug>
	<bug id="2301" opendate="2013-09-03 06:30:17" fixdate="2013-09-20 14:06:07" resolution="Complete">
		<buginformation>
			<summary>GlobalMethodSecurityConfiguration&amp;apos;s DefaultWebSecurityExpressionHandler has null BeanResolver</summary>
			<description>
this blog post got me started with java config, and everything worked fine until i tried to use @PreAuthorize annotation that uses my custom authentication service (via @myCustomService) expression. I get an error that
No bean resolver registered in the context to resolve access to bean myCustomService
Looking at M2 and RC1 source code, it seems that when WebSecurity is created in WebSecurityConfiguration and the default DefaultWebSecurityExpressionHandler is used and it has no BeanResolver set (from AbstractSecurityExpressionHandler).
Might this be a bug in the java based configuration?</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">2303</link>
		</links>
	</bug>
	<bug id="2304" opendate="2013-09-03 07:55:08" fixdate="2013-09-20 14:06:08" resolution="Complete">
		<buginformation>
			<summary>GlobalMethodSecurityConfiguration has two methods for the Expression Handler</summary>
			<description></description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="2328" opendate="2013-09-15 14:22:07" fixdate="2013-09-24 09:37:27" resolution="Complete">
		<buginformation>
			<summary>Java configuration missing hasAnyRole</summary>
			<description>Java configuration for restricting access to a URI has methods hasAuthority, hasAnyAuthority, and hasRole. It is missing hasAnyRole. This is not a big deal since you can work around it with hasAnyAuthority, but it&amp;amp;apos;s still not consistent with using string expressions in access or annotations.</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2302" opendate="2013-09-03 06:46:16" fixdate="2013-09-25 15:32:34" resolution="Complete">
		<buginformation>
			<summary>Allow filters to register in front of SpringSecurityFilterChain</summary>
			<description>With an AbstractSecurityWebApplicationInitializer in place its imposible to register an other filter in front of SpringSecurityFilterChain.</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2336" opendate="2013-09-19 22:54:04" fixdate="2013-09-26 07:08:30" resolution="Complete">
		<buginformation>
			<summary>WebSecurityConfigurerAdapter#registerAuthentication incorrectly states exposed Beans</summary>
			<description>Updated
I was fooled by this java doc in WebSecurityConfigurerAdapter#registerAuthentication:
"The resulting
{@link AuthenticationManager}
will be exposed as a Bean as will the last populated 
{@link UserDetailsService}
that is created with the
{@link AuthenticationManagerBuilder}

Original
This issue links to SEC-2205, I have simple @Configuration like this:






SecurityConfig.java











@Configuration




@EnableWebSecurity




@EnableGlobalMethodSecurity(prePostEnabled = true)




public class SecurityConfig extends WebSecurityConfigurerAdapter {









    @Override




    public void configure(WebSecurity web) throws Exception {




        web




                .ignoring()




                .antMatchers("/resources/**", "/favicon.ico");




    }









    @Override




    protected void registerAuthentication(AuthenticationManagerBuilder auth) throws Exception {




        auth




                .inMemoryAuthentication()




                .withUser("user").password("password").roles("USER").and()




                .withUser("admin").password("password").roles("USER", "ADMIN");









    }









    @Bean




    @Override




    public AuthenticationManager authenticationManagerBean()




            throws Exception {




        return super.authenticationManagerBean();




    }









    @Override




    protected void configure(HttpSecurity http) throws Exception {




        http




                .authorizeRequests()




                .antMatchers("/admin**").hasRole("ADMIN")




                .anyRequest().authenticated()




                .and()




                .formLogin()




                .loginPage("/signin")




                .permitAll()




                .and()




                .logout()




                .logoutUrl("/signout");




    }









}






And then simple Junit test, which actually uses SecurityRequestPostProcessors approach from (SEC-2015), but here for demonstration puroposes I have only autowired UserDetailsService:






SecurityFilterTest.java






@RunWith(SpringJUnit4ClassRunner.class)




@WebAppConfiguration




@ContextConfiguration(classes = SecurityConfig.class)




public class SecurityFilterTest {









    @Autowired




    private FilterChainProxy springSecurityFilterChain;









    @Autowired




    private WebApplicationContext wac;









    private MockMvc mockMvc;









    @Autowired




    private UserDetailsService userDetailsService;









    @Before




    public void setup() {




        this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac)




                .addFilters(this.springSecurityFilterChain).build();




    }









    @Test




    public void requiresAuthentication() throws Exception {




        mockMvc.perform(get("/hello"))




                .andExpect(status().isMovedTemporarily())




                .andExpect(redirectedUrl("http://localhost/signin"));




    }




}






This results:






stacktrace






Caused by: org.springframework.beans.factory.BeanCreationException: Could not autowire field: private org.springframework.security.core.userdetails.UserDetailsService




....




SecurityFilterTest.userDetailsService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [org.springframework.security.core.userdetails.UserDetailsService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}






</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2303" opendate="2013-09-03 07:53:51" fixdate="2013-10-06 15:35:06" resolution="Complete">
		<buginformation>
			<summary>WebSecurity&amp;apos;s default expression handler does not have the bean resolver set</summary>
			<description>Similar to SEC-2301</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.builders.WebSecurity.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">2301</link>
		</links>
	</bug>
	<bug id="2306" opendate="2013-09-05 07:59:52" fixdate="2013-10-06 15:35:12" resolution="Complete">
		<buginformation>
			<summary>Session Fixation protection can improperly log warning about not being protected</summary>
			<description></description>
			<version>3.1.4</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.session.AbstractSessionFixationProtectionStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="2376" opendate="2013-10-23 16:47:58" fixdate="2013-10-24 10:51:19" resolution="Duplicate">
		<buginformation>
			<summary>Document/Fix CSRF behavior with pre-auth</summary>
			<description>3.2.0.RC1 with &amp;lt;http auto-config="true"&amp;gt;  with &amp;lt;csrf/&amp;gt; and a preauth filter
When a user first accesses a pre-authed site
1. the CSRF token is added to the session.
2. The pre-auth filter creates the Authentication and related security context
3. The SessionManagementFilter then runs, and since its a new auth and session it calls &amp;amp;apos;CsrfAuthenticationStrategy&amp;amp;apos; which removes the CSRF token from the session.
4. The return view now has an invalid CSRF token in any forms.
A 2nd GET creates a new CSRF token, and then everything works normally.
--------------------------------
I posted my workaround in the forum, but it would nice to:
1. Document the behavior/workaround in
http://docs.spring.io/spring-security/site/docs/3.2.x-SNAPSHOT/reference/html/csrf.html
so that others don&amp;amp;apos;t have the same issue.
2. Offer a better way (or workaround) to remove the CsrfAuthenticationStrategy from the session management.
Is defining my own custom CSRF filter and repository a "cleaner" workaround to defining my own session management filter?
Or is updating the xsd, and doing something like &amp;lt;csrf auth-strategy="disable"/&amp;gt; a possibility?
</description>
			<version>3.2.0.RC1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servlet.support.csrf.CsrfRequestDataValueProcessorTests.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfToken.java</file>
			<file type="D">org.springframework.security.web.csrf.CsrfTokenTests.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfTokenRepository.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfFilterTests.java</file>
			<file type="M">org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.SessionManagementConfigurerServlet31Tests.java</file>
			<file type="M">org.springframework.security.web.csrf.HttpSessionCsrfTokenRepositoryTests.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2276</link>
		</links>
	</bug>
	<bug id="2382" opendate="2013-10-30 09:16:58" fixdate="2013-10-30 10:12:31" resolution="Complete">
		<buginformation>
			<summary>AutowireBeanFactoryObjectPostProcessor does not work with BeanNameAutoProxyCreator</summary>
			<description>When using Spring Security with BeanNameAutoProxyCreator the following error is produced because the beanName passed in by AutowireBeanFactoryObjectPostProcessor is null.






SEVERE: Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListener




org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;springSecurityFilterChain&amp;amp;apos; defined in class org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration: Instantiation of bean failed; nested exception is org.springframework.beans.factory.BeanDefinitionStoreException: Factory method [public javax.servlet.Filter org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.springSecurityFilterChain() throws java.lang.Exception] threw exception; nested exception is java.lang.IllegalArgumentException: &amp;amp;apos;name&amp;amp;apos; must not be null




    at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:581)




    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1025)




    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:921)




    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:487)




    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:458)




    at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:295)




    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:223)




    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:292)




    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:194)




    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:628)




    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:932)




    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:479)




    at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:389)




    at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:294)




    at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:112)




    at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4887)




    at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5381)




    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)




    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1559)




    at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1549)




    at java.util.concurrent.FutureTask.run(FutureTask.java:262)




    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)




    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)




    at java.lang.Thread.run(Thread.java:744)




Caused by: org.springframework.beans.factory.BeanDefinitionStoreException: Factory method [public javax.servlet.Filter org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.springSecurityFilterChain() throws java.lang.Exception] threw exception; nested exception is java.lang.IllegalArgumentException: &amp;amp;apos;name&amp;amp;apos; must not be null




    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:181)




    at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:570)




    ... 23 more




Caused by: java.lang.IllegalArgumentException: &amp;amp;apos;name&amp;amp;apos; must not be null




    at org.springframework.util.Assert.notNull(Assert.java:112)




    at org.springframework.beans.factory.BeanFactoryUtils.transformedBeanName(BeanFactoryUtils.java:72)




    at org.springframework.beans.factory.support.AbstractBeanFactory.transformedBeanName(AbstractBeanFactory.java:1018)




    at org.springframework.beans.factory.support.AbstractBeanFactory.getAliases(AbstractBeanFactory.java:602)




    at org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator.getAdvicesAndAdvisorsForBean(BeanNameAutoProxyCreator.java:90)




    at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:359)




    at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:322)




    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:409)




    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1488)




    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:388)




    at org.springframework.security.config.annotation.configuration.AutowireBeanFactoryObjectPostProcessor.postProcess(AutowireBeanFactoryObjectPostProcessor.java:56)




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.getHttp(WebSecurityConfigurerAdapter.java:141)




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.init(WebSecurityConfigurerAdapter.java:247)




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.init(WebSecurityConfigurerAdapter.java:49)




    at intouchapp.config.SecurityConfig$$EnhancerByCGLIB$$7c2e17f3.init(&amp;lt;generated&amp;gt;)




    at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.init(AbstractConfiguredSecurityBuilder.java:352)




    at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.doBuild(AbstractConfiguredSecurityBuilder.java:305)




    at org.springframework.security.config.annotation.AbstractSecurityBuilder.build(AbstractSecurityBuilder.java:40)




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.springSecurityFilterChain(WebSecurityConfiguration.java:85)




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerByCGLIB$$4da93da.CGLIB$springSecurityFilterChain$0(&amp;lt;generated&amp;gt;)




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerByCGLIB$$4da93da$$FastClassByCGLIB$$841a1210.invoke(&amp;lt;generated&amp;gt;)




    at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228)




    at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:286)




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerByCGLIB$$4da93da.springSecurityFilterChain(&amp;lt;generated&amp;gt;)




    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




    at java.lang.reflect.Method.invoke(Method.java:606)




    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:160)




    ... 24 more





</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.configuration.AutowireBeanFactoryObjectPostProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="2350" opendate="2013-10-04 10:23:43" fixdate="2013-11-15 11:44:03" resolution="Fixed">
		<buginformation>
			<summary>Warning when using 3.2.0.RC2 with Spring Framework 4.0</summary>
			<description>When starting an application running Spring Framework 4.0 and Spring Security 3.2.0.RC2, the following message is logged:
12:19:08.129 [localhost-startStop-1]   WARN  org.springframework.security.core.SpringSecurityCoreVersion org.springframework.security.core.SpringSecurityCoreVersion.performVersionChecks(SpringSecurityCoreVersion.java:53): *** Spring Major version &amp;amp;apos;3&amp;amp;apos; expected, but you are running with version: 4.0.0.BUILD-SNAPSHOT. Please check your classpath for unwanted jar files.
Spring Security should certainly warn if Spring Framework is older than supported, but it should not warn if Spring Framework is newer that expected. At the very least, 3.2.0 should support Spring Framework 4.</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.core.SpringSecurityCoreVersionTests.java</file>
			<file type="M">org.springframework.security.core.SpringSecurityCoreVersion.java</file>
		</fixedFiles>
	</bug>
	<bug id="2165" opendate="2013-05-07 01:17:59" fixdate="2013-11-15 12:59:33" resolution="Fixed">
		<buginformation>
			<summary>Can not parameterize remember me "token-validity-seconds"</summary>
			<description>A property expression is not resolved for attribute "token-validity-seconds". Other expressions in the very same file are resolved however. The xml file is included into this ticket.
Providing the markup:
&amp;lt;s:remember-me key="optimus-remember-me" use-secure-cookie="true" token-validity-seconds="$
{security.rememberme.ttl}"/&amp;gt;

Will result in the exception:

Caused by: org.xml.sax.SAXParseException: cvc-datatype-valid.1.2.1: &amp;amp;apos;${security.rememberme.ttl}
&amp;amp;apos; is not a valid value for &amp;amp;apos;integer&amp;amp;apos;.
	at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.createSAXParseException(ErrorHandlerWrapper.java:195)
	at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.error(ErrorHandlerWrapper.java:131)
	at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:384)
	at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:318)
	at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator$XSIErrorReporter.reportError(XMLSchemaValidator.java:423)
	at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.reportSchemaError(XMLSchemaValidator.java:3188)
	at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.processOneAttribute(XMLSchemaValidator.java:2783)
	at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.processAttributes(XMLSchemaValidator.java:2720)
	at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.handleStartElement(XMLSchemaValidator.java:2072)
	at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.emptyElement(XMLSchemaValidator.java:731)
	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.scanStartElement(XMLNSDocumentScannerImpl.java:377)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2756)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:647)
	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.next(XMLNSDocumentScannerImpl.java:140)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:511)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:808)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737)
	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119)
	at com.sun.org.apache.xerces.internal.parsers.DOMParser.parse(DOMParser.java:232)
	at com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl.parse(DocumentBuilderImpl.java:284)
	at org.springframework.beans.factory.xml.DefaultDocumentLoader.loadDocument(DefaultDocumentLoader.java:75)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:388)
	... 66 more
It works okay when providing a an integer constant.</description>
			<version>3.1.4</version>
			<fixedVersion>3.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.RememberMeBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="2327" opendate="2013-09-15 10:50:43" fixdate="2013-11-20 14:59:26" resolution="Fixed">
		<buginformation>
			<summary>Document SecurityExpressionRoot</summary>
			<description>None of the methods in SecurityExpressionRoot have any API documentation. Without reading the code, it&amp;amp;apos;s not clear what some of them do. For example, it&amp;amp;apos;s not clear that hasRole and hasAuthority are just synonyms and don&amp;amp;apos;t do anything different.
Normally I&amp;amp;apos;d look for help in the reference documentation for the root expressions, but it&amp;amp;apos;s missing most of the methods (probably hasn&amp;amp;apos;t been updated since 3.0, and maybe earlier).
The documentation for this class (Javadoc) and the expressions (reference) could be improved a good deal.</description>
			<version>3.1.4</version>
			<fixedVersion>3.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.expression.SecurityExpressionRoot.java</file>
			<file type="M">org.springframework.security.access.expression.SecurityExpressionOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="2410" opendate="2013-11-22 03:57:41" fixdate="2013-11-22 11:11:57" resolution="Fixed">
		<buginformation>
			<summary>AclFormattingUtils.printBinary does not handle negative</summary>
			<description>When printBinary in invoked with negative argument i it will either throw StringIndexOutOfBoundsException or return wrong result. All versions are affected.
Problem is in Integer.toString(i, 2) which is prepending minus sign in the front of the string for negative numbers.
Solution is to replace that call by Integer.toBinaryString
Attached are diff with patch and two simple tests that are failing with current implementation.</description>
			<version>3.1.4</version>
			<fixedVersion>3.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.AclFormattingUtilsTests.java</file>
			<file type="M">org.springframework.security.acls.domain.AclFormattingUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="2418" opendate="2013-11-27 13:10:41" fixdate="2013-12-02 10:02:10" resolution="Complete">
		<buginformation>
			<summary>[patch] toString method in LdapUserDetailsImpl never prints "Not granted any authorities"</summary>
			<description>In my application, my LDAP users have zero granted authorities, but the toString method does not print "Not granted any authorities", this is because the authorities collection is a non-null empty collection.</description>
			<version>3.2.0.RC2</version>
			<fixedVersion>3.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.userdetails.LdapUserDetailsImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="2386" opendate="2013-11-04 07:00:26" fixdate="2013-12-04 13:53:49" resolution="Fixed">
		<buginformation>
			<summary>DEBUG statement with Failed to perform build and stacktrace should be stated as OK</summary>
			<description>Seems to me though that if this really is ignorable, an exception should be logged later, when there really is a problem






2013-11-04 14:51:57.631 DEBUG 13456 --- [ost-startStop-1] s.s.c.a.a.b.AuthenticationManagerBuilder : Failed to perform build. Returning null









java.lang.IllegalArgumentException: A parent AuthenticationManager or a list of AuthenticationProviders is required




at org.springframework.security.authentication.ProviderManager.checkState(ProviderManager.java:117)




at org.springframework.security.authentication.ProviderManager.&amp;lt;init&amp;gt;(ProviderManager.java:106)




at org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder.performBuild(AuthenticationManagerBuilder.java:221)





</description>
			<version>3.2.0.RC2</version>
			<fixedVersion>3.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="2367" opendate="2013-10-17 09:50:04" fixdate="2013-12-04 14:19:52" resolution="Fixed">
		<buginformation>
			<summary>ProviderManager doesn&amp;apos;t report InternalAuthenticationServiceExceptions</summary>
			<description>If the ProviderManager has multiple AuthenticationProviders and one of the earlier providers throws an InternalAuthenticationServiceException then it will not be reported if a later provider throws any kind of AuthenticationException.
I experienced this when the errors that were occurring from a misconfigured LDAP provider were masked by the UsernameNotFoundException from the subsequent dao provider.
Given the javadocs for InternalAuthenticationServiceException it sounds like these errors should be logged even if a subsequent authentication provider succeeds (or fails).  Perhaps ProviderManager.authenticate() should have a special case for handling IASEs like it does for {{AccountStatusException}}s.</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.authentication.ProviderManager.java</file>
			<file type="M">org.springframework.security.authentication.ProviderManagerTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2422" opendate="2013-12-02 03:02:25" fixdate="2013-12-11 15:54:56" resolution="Complete">
		<buginformation>
			<summary>Session timeout not detected when enable CSRF protection</summary>
			<description>settings is following:






    &amp;lt;sec:http auto-config="true" use-expressions="true"&amp;gt;




        &amp;lt;sec:session-management 




            invalid-session-url="/error/sessionError"




            session-authentication-strategy-ref="sessionAuthenticationStrategy" /&amp;gt;




    &amp;lt;/sec:http&amp;gt;






Detected the session time-out when called GET method, but not detected session time-out  when called POST method.
When called POST method, occurred the CSRF token error.
This behavior are best practice in the spring security?
Also When called POST method, i wanted to detect the session time-out.
If wanted to detect the session timeout when called POST method, what should I do?</description>
			<version>3.2.0.RC2</version>
			<fixedVersion>3.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.CsrfConfigurer.java</file>
			<file type="M">org.springframework.security.config.http.HttpConfigurationBuilder.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.SessionManagementConfigurer.java</file>
			<file type="M">org.springframework.security.web.csrf.InvalidCsrfTokenException.java</file>
			<file type="M">org.springframework.security.config.http.CsrfBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2439" opendate="2013-12-12 13:45:14" fixdate="2013-12-13 13:48:37" resolution="Complete">
		<buginformation>
			<summary>HttpSessionCsrfTokenRepository setHeaderName uses parameterName</summary>
			<description>In HttpSessionCsrfTokenRepository, setHeaderName should use headerName, not parameterName (probably a copy/paste bug):






    /**




     * Sets the header name that the {@link CsrfToken} is expected to appear on




     * and the header that the response will contain the {@link CsrfToken}.




     *




     * @param parameterName




     *            the new parameter name to use




     */




    public void setHeaderName(String parameterName) {




        Assert.hasLength(parameterName, "parameterName cannot be null or empty");




        this.parameterName = parameterName;




    }





</description>
			<version>3.2.0.RC2</version>
			<fixedVersion>3.2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.csrf.HttpSessionCsrfTokenRepositoryTests.java</file>
			<file type="M">org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="2457" opendate="2013-12-21 12:12:42" fixdate="2014-01-29 12:38:32" resolution="Duplicate">
		<buginformation>
			<summary>Warning "Method &amp;apos;setFilterProcessesUrl&amp;apos; is marked deprecated" on http-login and http-logout tag</summary>
			<description>&amp;lt;security:form-login login-page=&amp;amp;apos;/login&amp;amp;apos; default-target-url="/" authentication-failure-url="/loginfailed" /&amp;gt;
&amp;lt;security:logout logout-success-url="/" invalidate-session="true" logout-url="/logout" /&amp;gt;
Warning appear on each line : "Method &amp;amp;apos;setFilterProcessesUrl&amp;amp;apos; is marked deprecated"
Is there now a new recommended way to do this?
I have not seen anything in the documentation about it.</description>
			<version>3.2.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
			<file type="M">org.springframework.security.config.http.FormLoginBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.authentication.logout.LogoutFilter.java</file>
			<file type="M">org.springframework.security.config.http.LogoutBeanDefinitionParser.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2455</link>
		</links>
	</bug>
	<bug id="2455" opendate="2013-12-18 01:35:17" fixdate="2014-01-29 13:36:10" resolution="Fixed">
		<buginformation>
			<summary>form@login-processing-url and logout@logout-url produce warnings</summary>
			<description>On upgrading to 3.2.0 RELEASE, we encountered this warning in the &amp;lt;http&amp;gt; block in the namespace configuration. 
&amp;lt;form-login&amp;gt; and &amp;lt;logout&amp;gt;
The warning says that setFilterProcessesUrl (which is inherited from AbstractAuthenticationProcessingFilter whose subclass be used by http@form-login and http@logout) is deprecated. Did we miss on replacing the deprecated method with the new method to be used? Can we remove this method altogether? Or is this warning here to stay? What does this warning mean?</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
			<file type="M">org.springframework.security.config.http.FormLoginBeanDefinitionParser.java</file>
			<file type="M">org.springframework.security.web.authentication.logout.LogoutFilter.java</file>
			<file type="M">org.springframework.security.config.http.LogoutBeanDefinitionParser.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2457</link>
		</links>
	</bug>
	<bug id="2461" opendate="2014-01-09 09:09:34" fixdate="2014-02-09 19:48:46" resolution="Fixed">
		<buginformation>
			<summary>Multiple WebSecurityConfiguration instances cause null springSecurityFilterChain</summary>
			<description>See SpringApplicationHierarchyTests within https://github.com/rwinch/spring-boot/tree/SEC-2461</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configuration.sec2377.b.Sec2377BConfig.java</file>
		</fixedFiles>
	</bug>
	<bug id="2392" opendate="2013-11-08 08:31:06" fixdate="2014-02-13 13:41:15" resolution="Fixed">
		<buginformation>
			<summary>Unexpectedly long key created by KeyBasedPersistenceTokenService.allocateToken()</summary>
			<description>The method allocateToken in KeyBasedPersistenceTokenService creates a token with an unexpectedly long key.
The reason for this is that the attribute pseudoRandomNumberBits (default = 256) is not converted to a number of bytes in the method generatePseudoRandomNumber() :






    private String generatePseudoRandomNumber() {




        byte[] randomizedBits = new byte[pseudoRandomNumberBits];




        secureRandom.nextBytes(randomizedBits);




        return new String(Hex.encode(randomizedBits));




    }






This string is then concatenated to others to create the final key of the Token :






        String content = Long.toString(creationTime) + ":" + pseudoRandomNumber + ":" + extendedInformation;









        // Compute key




        String sha512Hex = Sha512DigestUtils.shaHex(content + ":" + serverSecret);




        String keyPayload = content + ":" + sha512Hex;




        String key = Utf8.decode(Base64.encode(Utf8.encode(keyPayload)));





</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.core.token.KeyBasedPersistenceTokenService.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">2491</link>
		</links>
	</bug>
	<bug id="2492" opendate="2014-02-15 11:00:29" fixdate="2014-02-15 12:42:10" resolution="Complete">
		<buginformation>
			<summary>ExpressionUrlAuthorizationConfigurer.interceptUrl Javadoc incorrect</summary>
			<description>Looks like refactoring garbage. As stated in javadoc comment method could be chained, but now it is private.</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2499" opendate="2014-02-28 05:03:46" fixdate="2014-03-06 19:19:02" resolution="Fixed">
		<buginformation>
			<summary>GlobalMethodSecurityBeanDefinitionParser cannot refer to expressionHandler in parent context</summary>
			<description>This appears to have been introduced in 3.2.x, as it was working fine in 3.1.x.  If you define the referenced expressionHandler bean in the root WebApplicationContext, you get the stacktrace below:
org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named &amp;amp;apos;expressionHandler&amp;amp;apos; is defined
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:638)
	at org.springframework.security.config.method.GlobalMethodSecurityBeanDefinitionParser$LazyInitBeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry(GlobalMethodSecurityBeanDefinitionParser.java:455)
...
Would it make sense to just skip the post-processing case in this case?  As it would be trying to change the bean definition of a bean that it doesn&amp;amp;apos;t actually control.</description>
			<version>3.2.1</version>
			<fixedVersion>3.2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.method.GlobalMethodSecurityBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="2511" opendate="2014-03-06 19:56:22" fixdate="2014-03-06 20:01:45" resolution="Fixed">
		<buginformation>
			<summary>Remove double ALLOW-FROM from X-Frame-Options header</summary>
			<description></description>
			<version>3.2.1</version>
			<fixedVersion>3.2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.header.writers.frameoptions.AbstractRequestParameterAllowFromStrategyTests.java</file>
			<file type="M">org.springframework.security.web.header.writers.frameoptions.WhiteListedAllowFromStrategyTests.java</file>
			<file type="M">org.springframework.security.web.header.writers.frameoptions.RegExpAllowFromStrategyTests.java</file>
			<file type="M">org.springframework.security.web.header.writers.frameoptions.AbstractRequestParameterAllowFromStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="2515" opendate="2014-03-10 03:57:44" fixdate="2014-03-10 12:39:27" resolution="Complete">
		<buginformation>
			<summary>Stackoverflow with @Bean AuthenticationManager</summary>
			<description>This comes from an invalid configuration that tries to expose the AuthenticationManager as a Bean when no authentication has been configured. For example:






@EnableWebSecurity




@Configuration




public class StackOverflowSecurityConfig extends WebSecurityConfigurerAdapter {




    @Override




    @Bean




    public AuthenticationManager authenticationManagerBean()




            throws Exception {




        return super.authenticationManagerBean();




    }




}






The stacktrace when trying to authenticate is this:






Exception in thread "http-nio-8080-exec-1" java.lang.StackOverflowError




	at ch.qos.logback.classic.Logger.isDebugEnabled(Logger.java:490)




	at ch.qos.logback.classic.Logger.isDebugEnabled(Logger.java:486)




	at org.apache.commons.logging.impl.SLF4JLocationAwareLog.isDebugEnabled(SLF4JLocationAwareLog.java:67)




	at org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:144)




	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter$AuthenticationManagerDelegator.authenticate(WebSecurityConfigurerAdapter.java:421)




	at org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:177)




	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter$AuthenticationManagerDelegator.authenticate(WebSecurityConfigurerAdapter.java:421)




	at org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:177)




	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter$AuthenticationManagerDelegator.authenticate(WebSecurityConfigurerAdapter.java:421)




	at org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:177)




	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter$AuthenticationManagerDelegator.authenticate(WebSecurityConfigurerAdapter.java:421)




	at org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:177)




	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter$AuthenticationManagerDelegator.authenticate(WebSecurityConfigurerAdapter.java:421)




	at org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:177)




	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter$AuthenticationManagerDelegator.authenticate(WebSecurityConfigurerAdapter.java:421)




	at org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:177)




	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter$AuthenticationManagerDelegator.authenticate(WebSecurityConfigurerAdapter.java:421)




	at org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:177)




	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter$AuthenticationManagerDelegator.authenticate(WebSecurityConfigurerAdapter.java:421)




	at org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:177)




	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter$AuthenticationManagerDelegator.authenticate(WebSecurityConfigurerAdapter.java:421)




	at org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:177)









...






Here&amp;amp;apos;s an example project: https://github.com/scratches/sparklr-boot/tree/feature/password
We should provide a better error message when this is misconfigured.</description>
			<version>3.2.1</version>
			<fixedVersion>3.2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.java</file>
			<file type="M">org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="2507" opendate="2014-03-05 13:21:48" fixdate="2014-03-10 12:39:50" resolution="Complete">
		<buginformation>
			<summary>WebExpressionVoter - supported secured object class</summary>
			<description>It&amp;amp;apos;s probably a typo - WebExpressionVoter has the following method:






public boolean supports(Class&amp;lt;?&amp;gt; clazz) {




    return clazz.isAssignableFrom(FilterInvocation.class);




}






I think it should be:






public boolean supports(Class&amp;lt;?&amp;gt; clazz) {




    return FilterInvocation.class.isAssignableFrom(clazz);




}






because WebExpressionVoter should support subclasses of FilterInvocation.</description>
			<version>3.2.1</version>
			<fixedVersion>3.1.6, 3.2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.access.expression.WebExpressionVoter.java</file>
			<file type="M">org.springframework.security.web.access.expression.WebExpressionVoterTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1890" opendate="2012-01-10 02:47:52" fixdate="2014-03-13 07:09:44" resolution="Complete">
		<buginformation>
			<summary>BCryptPasswordEncoder throws IllegalArgumentException: Encoded password cannot be null or empty if password is empty (i.e. not encoded)</summary>
			<description>Example stacktrace:






java.lang.IllegalArgumentException: Encoded password cannot be null or empty




org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder.matches(BCryptPasswordEncoder.java:77) 




org.springframework.security.authentication.dao.DaoAuthenticationProvider$1.isPasswordValid(DaoAuthenticationProvider.java:148) 




org.springframework.security.authentication.dao.DaoAuthenticationProvider.additionalAuthenticationChecks(DaoAuthenticationProvider.java:84) 




org.springframework.security.authentication.dao.AbstractUserDetailsAuthenticationProvider.authenticate(AbstractUserDetailsAuthenticationProvider.java:149) 




org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:156) 




org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:174) 




org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.attemptAuthentication(UsernamePasswordAuthenticationFilter.java:94) 




org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:195) 





</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.crypto.bcrypt.BCryptPasswordEncoderTests.java</file>
			<file type="M">org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder.java</file>
		</fixedFiles>
	</bug>
	<bug id="2177" opendate="2013-06-12 06:49:56" fixdate="2014-03-18 13:49:59" resolution="Fixed">
		<buginformation>
			<summary>DefaultRedirectStrategy could be less vulnerable to open redirect phishing attacks</summary>
			<description>We have the the following configuration of the
org.springframework.security.web.authentication.AuthenticationSuccessHandler






  &amp;lt;bean id="simpleUrlAuthenticationSuccessHandler"




        class="org.springframework.security.web.authentication.SimpleUrlAuthenticationSuccessHandler"&amp;gt;




    &amp;lt;property name="targetUrlParameter" value="continue"/&amp;gt;




    &amp;lt;property name="defaultTargetUrl" value="/"/&amp;gt;




    &amp;lt;property name="redirectStrategy"&amp;gt;




      &amp;lt;bean class="org.springframework.security.web.DefaultRedirectStrategy"&amp;gt;




        &amp;lt;property name="contextRelative" value="true"/&amp;gt;




      &amp;lt;/bean&amp;gt;




    &amp;lt;/property&amp;gt;




  &amp;lt;/bean&amp;gt;






We were hoping that setting redirectStrategy to be context relative would help us deal with open redirect vulnerability. It works fine for forged URLs like:
http://example.com/login?continue=http://unsecure.com
because user wont leave our service. Unfortunately, it works only for one occurrence of scheme declaration. The following URL
http://example.com/login?continue=http://http://unsecure.com
will still perform a redirect request to the outer service. This behaviour could be easily extended by changing the following line of org.springframework.security.web.DefaultRedirectStrategy






url = url.substring(url.indexOf("://") + 3); // strip off scheme






to 






url = url.substring(url.lastIndexOf("://") + 3); // strip off scheme





</description>
			<version>3.1.2</version>
			<fixedVersion>3.2.3, 4.0.0.M1</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.DefaultRedirectStrategyTests.java</file>
			<file type="M">org.springframework.security.web.DefaultRedirectStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="2531" opendate="2014-03-24 11:55:51" fixdate="2014-03-24 13:37:22" resolution="Complete">
		<buginformation>
			<summary>IllegalAccessError: $Proxy95 cannot access its superinterface AuthenticationConfiguration$LazyBean</summary>
			<description>In a Spring Boot environment the following error occurs:






Caused by: java.lang.IllegalAccessError: class org.springframework.security.config.annotation.authentication.configuration.$Proxy95 cannot access its superinterface org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration$LazyBean




    at java.lang.reflect.Proxy.defineClass0(Native Method) ~[na:1.7.0_51]




    at java.lang.reflect.Proxy.getProxyClass0(Proxy.java:639) ~[na:1.7.0_51]




    at java.lang.reflect.Proxy.newProxyInstance(Proxy.java:722) ~[na:1.7.0_51]




    at org.springframework.aop.framework.JdkDynamicAopProxy.getProxy(JdkDynamicAopProxy.java:121) ~[spring-aop-4.0.2.RELEASE.jar:4.0.2.RELEASE]




    at org.springframework.aop.framework.ProxyFactoryBean.getProxy(ProxyFactoryBean.java:368) ~[spring-aop-4.0.2.RELEASE.jar:4.0.2.RELEASE]




    at org.springframework.aop.framework.ProxyFactoryBean.getSingletonInstance(ProxyFactoryBean.java:322) ~[spring-aop-4.0.2.RELEASE.jar:4.0.2.RELEASE]




    at org.springframework.aop.framework.ProxyFactoryBean.getObject(ProxyFactoryBean.java:246) ~[spring-aop-4.0.2.RELEASE.jar:4.0.2.RELEASE]




    at org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.lazyBean(AuthenticationConfiguration.java:118) ~[spring-security-config-3.2.2.RELEASE.jar:3.2.2.RELEASE]




    at org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.getAuthenticationMangerBean(AuthenticationConfiguration.java:122) ~[spring-security-config-3.2.2.RELEASE.jar:3.2.2.RELEASE]




    at org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.getAuthenticationManager(AuthenticationConfiguration.java:81) ~[spring-security-config-3.2.2.RELEASE.jar:3.2.2.RELEASE]




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.authenticationManager(WebSecurityConfigurerAdapter.java:229) ~[spring-security-config-3.2.2.RELEASE.jar:3.2.2.RELEASE]




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.getHttp(WebSecurityConfigurerAdapter.java:171) ~[spring-security-config-3.2.2.RELEASE.jar:3.2.2.RELEASE]




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.init(WebSecurityConfigurerAdapter.java:276) ~[spring-security-config-3.2.2.RELEASE.jar:3.2.2.RELEASE]




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.init(WebSecurityConfigurerAdapter.java:61) ~[spring-security-config-3.2.2.RELEASE.jar:3.2.2.RELEASE]




    at org.springframework.boot.actuate.autoconfigure.ManagementSecurityAutoConfiguration$ManagementWebSecurityConfigurerAdapter$$EnhancerBySpringCGLIB$$5efb9bce.init(&amp;lt;generated&amp;gt;) ~[spring-core-4.0.2.RELEASE.jar:1.0.0.RC5]




    at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.init(AbstractConfiguredSecurityBuilder.java:369) ~[spring-security-config-3.2.2.RELEASE.jar:3.2.2.RELEASE]




    at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.doBuild(AbstractConfiguredSecurityBuilder.java:322) ~[spring-security-config-3.2.2.RELEASE.jar:3.2.2.RELEASE]




    at org.springframework.security.config.annotation.AbstractSecurityBuilder.build(AbstractSecurityBuilder.java:39) ~[spring-security-config-3.2.2.RELEASE.jar:3.2.2.RELEASE]




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.springSecurityFilterChain(WebSecurityConfiguration.java:92) ~[spring-security-config-3.2.2.RELEASE.jar:3.2.2.RELEASE]




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerBySpringCGLIB$$45bb83f.CGLIB$springSecurityFilterChain$1(&amp;lt;generated&amp;gt;) ~[spring-core-4.0.2.RELEASE.jar:3.2.2.RELEASE]




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerBySpringCGLIB$$45bb83f$$FastClassBySpringCGLIB$$5f404d1f.invoke(&amp;lt;generated&amp;gt;) ~[spring-core-4.0.2.RELEASE.jar:3.2.2.RELEASE]




    at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228) ~[spring-core-4.0.2.RELEASE.jar:4.0.2.RELEASE]




    at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:312) ~[spring-context-4.0.2.RELEASE.jar:4.0.2.RELEASE]




    at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerBySpringCGLIB$$45bb83f.springSecurityFilterChain(&amp;lt;generated&amp;gt;) ~[spring-core-4.0.2.RELEASE.jar:3.2.2.RELEASE]




    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_51]




    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_51]




    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_51]




    at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_51]




    at org.springsource.loaded.ri.ReflectiveInterceptor.jlrMethodInvoke(ReflectiveInterceptor.java:1265) ~[springloaded-1.2.0.BUILD-20140322.044242-8.jar:1.2.0.BUILD-SNAPSHOT]




    at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:166) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE]





</description>
			<version>3.2.2</version>
			<fixedVersion>3.2.3, 4.0.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">2549</link>
		</links>
	</bug>
	<bug id="2533" opendate="2014-03-25 10:58:59" fixdate="2014-03-25 11:05:55" resolution="Fixed">
		<buginformation>
			<summary>Global AuthenticationManagerBuilder#eraseCredentials=false does not work</summary>
			<description>The following configuration still clears out the credentials since nothing is associating the configuration from the parent (global configuration) to the child (HttpSecurity&amp;amp;apos;s authentication used for formLogin, openid, etc support) AuthenticationManager:






@EnableWebSecurity




@Configuration




public class SecurityConfig extends WebSecurityConfigurerAdapter {




    @Autowired




    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {




        auth




            .eraseCredentials(false)




            .inMemoryAuthentication()




                .withUser("user").password("password").roles("USER")




    }




}





</description>
			<version>3.2.2</version>
			<fixedVersion>3.2.3, 4.0.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="2570" opendate="2014-04-20 18:11:52" fixdate="2014-04-21 05:52:48" resolution="Duplicate">
		<buginformation>
			<summary>LogoutConfigurer supports GET by default when CSRF is enabled</summary>
			<description>Since commit 5082a046 for SEC-2311, the default LogoutRequestMatcher supports all HTTP methods regardless of the CSRF configuration.
You can see in the LogoutConfigurer.java code below that a POST only matcher is created, but not used:






    @SuppressWarnings("unchecked")




    private RequestMatcher getLogoutRequestMatcher(H http) {




        if(logoutRequestMatcher != null) {




            return logoutRequestMatcher;




        }




        if(http.getConfigurer(CsrfConfigurer.class) != null) {




            this.logoutRequestMatcher = new AntPathRequestMatcher(this.logoutUrl, "POST");




        }




        return new AntPathRequestMatcher(this.logoutUrl);




    }





</description>
			<version>3.2.3</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.LogoutConfigurer.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2543</link>
		</links>
	</bug>
	<bug id="2549" opendate="2014-04-07 01:34:51" fixdate="2014-04-24 12:35:22" resolution="Complete">
		<buginformation>
			<summary>java.lang.IllegalAccessError: class org.springframework.security.config.annotation.authentication.configuration.$Proxy90 cannot access its superinterface &lt;omitted&gt;.AuthenticationConfiguration$LazyBean</summary>
			<description>Is it possible to change the visibility of LazyBean marker interface to `public`?
We are planning to pull up spring dependencies as JBoss EAP "module" (shared libraries) to be shared among all of our applications.
Each "module" has its own isolated ClassLoader, and is parallel to the war "module" ClassLoader, so we have to emulate the class loading hierarchy ourselves for compatibility.
The problem is that the aggregated ClassLoader (delegates to "module" classLoader and then the applications&amp;amp;apos;s ClassLoader) cannot sees the private LazyBean marker.</description>
			<version>3.2.3</version>
			<fixedVersion>3.2.4, 4.0.0.M1</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.java</file>
			<file type="M">org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2604</link>
			<link type="Relate" description="relates to">2531</link>
		</links>
	</bug>
	<bug id="2571" opendate="2014-04-22 08:06:18" fixdate="2014-04-24 14:36:53" resolution="Complete">
		<buginformation>
			<summary>Failures in UserDetailsService should produce errors in the console</summary>
			<description></description>
			<version>3.2.3</version>
			<fixedVersion>3.2.4, 4.0.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.authentication.dao.DaoAuthenticationProvider.java</file>
			<file type="M">org.springframework.security.authentication.dao.DaoAuthenticationProviderTests.java</file>
		</fixedFiles>
		<links>
			<link type="Supersede" description="supersedes">2340</link>
		</links>
	</bug>
	<bug id="2543" opendate="2014-04-02 10:08:49" fixdate="2014-05-02 09:31:05" resolution="Fixed">
		<buginformation>
			<summary>Logout Does Not Require POST even though CSRF is enabled</summary>
			<description>The documentation says "Adding CSRF will update the LogoutFilter to only use HTTP POST. This ensures that log out requires a CSRF token and that a malicious user cannot forcibly log out your users.": http://docs.spring.io/spring-securit...e/#csrf-logout
However, in my testing, I can still logout with a GET to /logout using the following Java-based security configuration:






SecurityConfig.java






@Configuration




@EnableWebMvcSecurity




public class SecurityConfig extends WebSecurityConfigurerAdapter {




    @Override




    protected void configure(final AuthenticationManagerBuilder auth)




            throws Exception {




        auth.inMemoryAuthentication()//




                .withUser("user").password("password").roles("USER")//




                .and()//




                .withUser("admin").password("password").roles("USER", "ADMIN");




    }









    @Override




    protected void configure(final HttpSecurity http) throws Exception {




        http.authorizeRequests()//




                .antMatchers("/admin/**").hasRole("ADMIN")//




                .antMatchers("/**").permitAll().and()//




                .formLogin();




    }




}





</description>
			<version>3.2.3</version>
			<fixedVersion>3.2.4, 4.0.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.LogoutConfigurer.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2570</link>
		</links>
	</bug>
	<bug id="2578" opendate="2014-04-28 20:03:45" fixdate="2014-05-02 13:07:02" resolution="Fixed">
		<buginformation>
			<summary>HttpSessionSecurityContextRepository should traverse HttpServletResponseWrapper</summary>
			<description></description>
			<version>3.2.3</version>
			<fixedVersion>3.2.4, 4.0.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.HttpSessionSecurityContextRepositoryTests.java</file>
			<file type="M">org.springframework.security.web.context.HttpSessionSecurityContextRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="2606" opendate="2014-05-21 04:35:52" fixdate="2014-05-21 04:50:50" resolution="Complete">
		<buginformation>
			<summary>ApacheDSServerIntegrationTests should scan for available port</summary>
			<description></description>
			<version>3.2.3</version>
			<fixedVersion>3.2.4, 4.0.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.AbstractLdapIntegrationTests.java</file>
			<file type="M">org.springframework.security.ldap.ApacheDSServerIntegrationTests.java</file>
			<file type="M">org.springframework.security.ldap.DefaultSpringSecurityContextSourceTests.java</file>
			<file type="M">org.springframework.security.ldap.SpringSecurityLdapTemplateITests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2472" opendate="2014-01-28 10:08:41" fixdate="2014-05-21 15:03:04" resolution="Complete">
		<buginformation>
			<summary>Can&amp;apos;t use recommended BCryptPasswordEncoder for PasswordComparisonAuthenticator on a Ldap Authenticator</summary>
			<description>According to the Spring Security Reference for version 3.2, we should use BCryptPasswordEncoder for encrypting passwords.  The class org.springframework.security.ldap.authentication.AbstractLdapAuthenticator has a method setPasswordEncoder that takes a single parameter of type org.springframework.security.authentication.encoding.PasswordEncoder, which is an interface that is deprecated.  All known classes that implement that interface are deprecated and represent various encryption algorithms that are no longer recommended.  org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder (the recommended encoder) does not implement that deprecated interface, it implements org.springframework.security.crypto.password.PasswordEncoder (tricky because the interface name is the same, but belongs to a different package as the deprecated interface).  The parameter type on the method setPasswordEncoder in the class org.springframework.security.ldap.authentication.AbstractLdapAuthenticator needs to be changed to org.springframework.security.crypto.password.PasswordEncoder.</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.4, 4.0.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.authentication.configurers.ldap.LdapAuthenticationProviderConfigurer.java</file>
			<file type="M">org.springframework.security.ldap.authentication.PasswordComparisonAuthenticator.java</file>
			<file type="M">org.springframework.security.ldap.authentication.PasswordComparisonAuthenticatorTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2056" opendate="2012-09-19 10:06:02" fixdate="2014-05-22 07:28:40" resolution="Complete">
		<buginformation>
			<summary>CVE-2012-5055 DaoAuthenticationProvider can reveal which usernames are valid</summary>
			<description>Description:
Spring Security&amp;amp;apos;s DaoAuthenticationProvider authenticates users by utilizing the PasswordEncoder interface to compare the submitted password with the actual password. If a user is not found, the comparison is skipped which, depending on the PasswordEncoder implementation, can result in a significant difference in the amount of time required to attempt to authenticate an actual user versus a user that does not exist. This opens up the possibility of a side channel attack that would enable a malicious user to determine if a username is valid.
Example:
The DaoAuthenticationProvider allows setting of the PasswordEncoder for password validation:






DaoAuthenticationProvider provider = new DaoAuthenticationProvider();




provider.setPasswordEncoder(new BCryptPasswordEncoder());









// Authentication or failure to authenticate an actual user takes ~84ms




Authentication existingUser = new UsernamePasswordAuthenticationToken("existingUser", "password");




provider.authentication(existingUser);









// Failure to authenticate a user that does not exist takes ~0ms




Authentication missingUser = new UsernamePasswordAuthenticationToken("missingUser", "password");




provider.authentication(missingUser);






The difference between the amount of time it takes to authenticate an existing user and a user that does not exist can reveal if a username is valid or not.
Mitigation:
Applications which use DaoAuthenticationProvider and a PasswordEncoder other than PlainTextEncoder are likely to be vulnerable.
All users may mitigate this issue by upgrading to Spring Security 3.1.3+, 3.0.8+, or 2.0.8+.
Fix:
DaoAuthenticationProvider now performs PasswordEncoder.isPasswordValid when a user is not found.
Credit:
The issue was discovered by Nicholas Goodwin.</description>
			<version>2.0.7</version>
			<fixedVersion>2.0.8, 3.0.8, 3.1.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.authentication.dao.DaoAuthenticationProvider.java</file>
			<file type="M">org.springframework.security.authentication.dao.DaoAuthenticationProviderTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2604" opendate="2014-05-20 23:53:54" fixdate="2014-05-23 06:09:25" resolution="Duplicate">
		<buginformation>
			<summary>Spring Security not working with configurations in Parent Application Contect</summary>
			<description>Hi,
In your web application, we have three layers of application context. 
1. Spring MVC Context
2. Web Application Context
3. Parent Application Context.
WebApplicationContext is parent of SpringMVCContext.
ParentApplicationContext is parent of WebApplicationContext.
We are using JavaConfig in our application.
Now, we want to use Authorization feature Spring Security in our application. To use this we configured below in Parent Context
1. Authentication Manager
2. Authentication Provider
3. UserDetailsService
We have defined these beans in the class which extends from GlobalSecurityConfiguration. This class is annotated with @GlobalMethodSecurity.
We&amp;amp;apos;ve overriden the configure(AuthenticationManagerBuilder) and added AuthenticationProvider in AuthenticationBuilder to build the AuthenticationManager.






protected void configure(AuthenticationManagerBuilder auth) throws Exception {









        auth.authenticationProvider(preAuthenticatedAuthenticationProvider());









    }






We have exposed the AuthenticationManager as below






   @Bean(name="authenticationManager")




    public AuthenticationManager authenticationManagerBean() throws Exception {




        return authenticationManager();




    }






And, we have configured the required filter bean in SpringMVCContext. 
Filter gets the reference of the AuthenticationManager which is configured in ParentContext. However, it throws below exception and application does not work.






Caused by: java.lang.IllegalAccessError: org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration$LazyBean




      at java.lang.reflect.Proxy.defineClass0(Native Method)




      at java.lang.reflect.Proxy.getProxyClass0(Proxy.java:625)




      at java.lang.reflect.Proxy.newProxyInstance(Proxy.java:702)




      at org.springframework.aop.framework.JdkDynamicAopProxy.getProxy(JdkDynamicAopProxy.java:121)




      at org.springframework.aop.framework.ProxyFactoryBean.getProxy(ProxyFactoryBean.java:368)




      at org.springframework.aop.framework.ProxyFactoryBean.getSingletonInstance(ProxyFactoryBean.java:322)




      at org.springframework.aop.framework.ProxyFactoryBean.getObject(ProxyFactoryBean.java:246)




      at org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.lazyBean(AuthenticationConfiguration.java:119)




      at org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.getAuthenticationMangerBean(AuthenticationConfiguration.java:123)




      at org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.getAuthenticationManager(AuthenticationConfiguration.java:81)




      at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.authenticationManager(WebSecurityConfigurerAdapter.java:229)




      at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.getHttp(WebSecurityConfigurerAdapter.java:171)




      at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.init(WebSecurityConfigurerAdapter.java:276)




      at org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.init(WebSecurityConfigurerAdapter.java:61)




      at com.deere.dsfj.jdorderspringmvcweb.config.SpringWebSecurityConfig$$EnhancerBySpringCGLIB$$1ccbdc0f.init(&amp;lt;generated&amp;gt;)




      at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.init(AbstractConfiguredSecurityBuilder.java:369)




      at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.doBuild(AbstractConfiguredSecurityBuilder.java:322)




      at org.springframework.security.config.annotation.AbstractSecurityBuilder.build(AbstractSecurityBuilder.java:39)




      at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.springSecurityFilterChain(WebSecurityConfiguration.java:92)




      at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerBySpringCGLIB$$a1372076.CGLIB$springSecurityFilterChain$1(&amp;lt;generated&amp;gt;)




      at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerBySpringCGLIB$$a1372076$$FastClassBySpringCGLIB$$a530ca1c.invoke(&amp;lt;generated&amp;gt;)




      at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228)




      at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:312)




      at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerBySpringCGLIB$$a1372076.springSecurityFilterChain(&amp;lt;generated&amp;gt;)




      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:60)




      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)




      at java.lang.reflect.Method.invoke(Method.java:611)




      at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:166)




      ... 113 more






Please suggest
</description>
			<version>3.2.3</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.java</file>
			<file type="M">org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2549</link>
		</links>
	</bug>
	<bug id="2651" opendate="2014-06-12 14:45:54" fixdate="2014-06-12 14:48:11" resolution="Complete">
		<buginformation>
			<summary>Update Thymeleaf to use Spring 4 variants in samples</summary>
			<description>The update to Spring 4 caused failures in Thymeleaf&amp;amp;apos;s automatic inclusion of Spring Security&amp;amp;apos;s CSRF. We should update the Thymeleaf dependencies to match the Spring version. </description>
			<version>4.0.0.M1</version>
			<fixedVersion>4.0.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.samples.mvc.config.CustomMvcConfig.java</file>
			<file type="M">org.springframework.security.samples.mvc.config.WebMvcConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="2656" opendate="2014-06-17 12:52:05" fixdate="2014-06-18 07:12:25" resolution="Complete">
		<buginformation>
			<summary>Exception on using &lt;sec:frame-options&gt; with strategy whitelist</summary>
			<description>Using &amp;lt;sec:frame-options&amp;gt; does not work at all with strategy whitelist or regexp. It end up with an exception like:






17-Jun-2014 21:30:40.113 SEVERE [localhost-startStop-1] org.springframework.web.context.ContextLoader.initWebApplicationContext Context initialization failed




 org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;org.springframework.security.filterChains&amp;amp;apos;: Cannot resolve reference to bean &amp;amp;apos;org.springframework.security.web.DefaultSecurityFilterChain#0&amp;amp;apos; while setting bean property &amp;amp;apos;sourceList&amp;amp;apos; with key [0]; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;org.springframework.security.web.DefaultSecurityFilterChain#0&amp;amp;apos;: Cannot create inner bean &amp;amp;apos;(inner bean)#7696e4d2&amp;amp;apos; of type [org.springframework.security.web.header.HeaderWriterFilter] while setting constructor argument with key [2]; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;(inner bean)#7696e4d2&amp;amp;apos;: Cannot create inner bean &amp;amp;apos;(inner bean)#2c88d3d1&amp;amp;apos; of type [org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter] while setting constructor argument with key [0]; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;(inner bean)#2c88d3d1&amp;amp;apos;: Could not resolve matching constructor (hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:336)




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:108)




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveManagedList(BeanDefinitionValueResolver.java:359)




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:157)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1456)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1197)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475)




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304)




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:684)




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:760)




	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482)




	at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:403)




	at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:306)




	at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:106)




	at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4750)




	at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5170)




	at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)




	at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:724)




	at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:700)




	at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:697)




	at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:919)




	at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1704)




	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:471)




	at java.util.concurrent.FutureTask.run(FutureTask.java:262)




	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)




	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)




	at java.lang.Thread.run(Thread.java:744)




Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;org.springframework.security.web.DefaultSecurityFilterChain#0&amp;amp;apos;: Cannot create inner bean &amp;amp;apos;(inner bean)#7696e4d2&amp;amp;apos; of type [org.springframework.security.web.header.HeaderWriterFilter] while setting constructor argument with key [2]; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;(inner bean)#7696e4d2&amp;amp;apos;: Cannot create inner bean &amp;amp;apos;(inner bean)#2c88d3d1&amp;amp;apos; of type [org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter] while setting constructor argument with key [0]; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;(inner bean)#2c88d3d1&amp;amp;apos;: Could not resolve matching constructor (hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveInnerBean(BeanDefinitionValueResolver.java:290)




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:129)




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveManagedList(BeanDefinitionValueResolver.java:359)




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:157)




	at org.springframework.beans.factory.support.ConstructorResolver.resolveConstructorArguments(ConstructorResolver.java:632)




	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:140)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1114)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1017)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:504)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475)




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304)




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195)




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:328)




	... 30 more




Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;(inner bean)#7696e4d2&amp;amp;apos;: Cannot create inner bean &amp;amp;apos;(inner bean)#2c88d3d1&amp;amp;apos; of type [org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter] while setting constructor argument with key [0]; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;(inner bean)#2c88d3d1&amp;amp;apos;: Could not resolve matching constructor (hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveInnerBean(BeanDefinitionValueResolver.java:290)




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:129)




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveManagedList(BeanDefinitionValueResolver.java:359)




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:157)




	at org.springframework.beans.factory.support.ConstructorResolver.resolveConstructorArguments(ConstructorResolver.java:632)




	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:140)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1114)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1017)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:504)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475)




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveInnerBean(BeanDefinitionValueResolver.java:276)




	... 44 more




Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;(inner bean)#2c88d3d1&amp;amp;apos;: Could not resolve matching constructor (hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)




	at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:239)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1114)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1017)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:504)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475)




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveInnerBean(BeanDefinitionValueResolver.java:276)




	... 54 more






because of an error in HeadersBeanDefinitionParser.
A war file is attached to reproduce it.</description>
			<version>3.2.4</version>
			<fixedVersion>3.2.5, 4.0 Backlog</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.HeadersBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="2683" opendate="2014-07-15 08:05:10" fixdate="2014-07-18 11:58:00" resolution="Complete">
		<buginformation>
			<summary>Spelling Mistake in AuthenticationPrincipalArgumentResolver</summary>
			<description>In AuthenticationPrincipalArgumentResolver, line 109, assignable is misspelled as "assiable" in the Exception reason.</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.5, 4.0.0.M2</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.bind.support.AuthenticationPrincipalArgumentResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="2595" opendate="2014-05-17 09:18:19" fixdate="2014-07-25 14:05:46" resolution="Complete">
		<buginformation>
			<summary>@EnableGlobalMethodSecurity creates JDK dynamic proxies instead of using AspectJ advices</summary>
			<description>The following config creates JDK proxies for secured beans preprocessed with an AspectJ compiler, thus rendering AnnotationSecurityAspect useless.
@EnableGlobalMethodSecurity(mode=AdviceMode.ASPECTJ, securedEnabled=true)
class SecurityConfig 
{...}

The AspectJMethodSecurityInterceptor that AnnotationSecurityAspect requires appears to only be instantiated by GlobalMethodSecurityBeanDefinitionParser. This implies that AnnotationSecurityAspect is only usable in XML config mode (but not Java config mode).
The attached Gradle project demonstrates this problem.</description>
			<version>3.2.3</version>
			<fixedVersion>3.2.5, 4.0.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityAspectJAutoProxyRegistrar.java</file>
			<file type="M">org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2698</link>
			<link type="Relate" description="is related to">3005</link>
			<link type="Relate" description="is related to">3045</link>
		</links>
	</bug>
	<bug id="2698" opendate="2014-08-09 09:03:11" fixdate="2014-08-11 07:09:25" resolution="Duplicate">
		<buginformation>
			<summary>@EnableGlobalMethodSecurity is not respecting mode = AdviceMode.ASPECTJ</summary>
			<description>Long description in link to Stackoverflow.
XML Configuration like this:
	&amp;lt;security:global-method-security mode="aspectj" proxy-target-class="false" pre-post-annotations="enabled"&amp;gt;
		&amp;lt;security:expression-handler ref="expressionHandler" /&amp;gt;
	&amp;lt;/security:global-method-security&amp;gt;
The AnnotationSecurityAspect is configured by GlobalMethodSecurityBeanDefinitionParser at line 251
With a Javaconfig Class like this:
@Configuration
@EnableGlobalMethodSecurity(mode = AdviceMode.ASPECTJ, prePostEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration
{
	@Override
	protected MethodSecurityExpressionHandler createExpressionHandler ( )
	{ 
          ...
	}
}
The AnnotationSecurityAspect is not configured. Spring-Security will create some AutoProxy AOP Classes which is bad as I wanted to use aspectj with compile-time-weaving
</description>
			<version>4.0.0.M1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityAspectJAutoProxyRegistrar.java</file>
			<file type="M">org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2595</link>
			<link type="Relate" description="is related to">3005</link>
			<link type="Relate" description="is related to">3045</link>
		</links>
	</bug>
	<bug id="2697" opendate="2014-08-07 03:28:01" fixdate="2014-08-15 12:28:40" resolution="Complete">
		<buginformation>
			<summary>Invalid warning logged when using Spring 3.2.10.RELEASE</summary>
			<description>I&amp;amp;apos;m using Spring Framework (version 3.2.10.RELEASE).
During application startup I&amp;amp;apos;m getting following warning:

org.springframework.security.core.SpringSecurityCoreVersion - **** You are advised to use Spring 3.2.8.RELEASE or later with this version. You are running: 3.2.10.RELEASE
It seems that versions are compared using String.compareTo().
Using this method "3.2.10.RELEASE" is lower then "3.2.8.RELEASE".</description>
			<version>3.2.4</version>
			<fixedVersion>3.2.5, 4.0.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.core.SpringSecurityCoreVersionTests.java</file>
			<file type="M">org.springframework.security.core.SpringSecurityCoreVersion.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2727</link>
		</links>
	</bug>
	<bug id="2688" opendate="2014-07-24 14:40:02" fixdate="2014-08-15 14:08:37" resolution="Complete">
		<buginformation>
			<summary>CVE-2014-3527 CAS Service Can Impersonate Another CAS Service When Using Proxy Tickets</summary>
			<description>When using Spring Security&amp;amp;apos;s CAS Proxy ticket authentication a malicious CAS Service could trick another CAS Service into authenticating a proxy ticket that was not associated. This is due to the fact that the proxy ticket authentication uses the information from the HttpServletRequest which is populated based upon untrusted information within the HTTP request. 
This means if there are access control restrictions on which CAS services can authenticate to one another, those restrictions can be bypassed.
If users are not using CAS Proxy tickets and not basing access control decisions based upon the CAS Service, then there is no impact to users.
Mitigation:
Users of affected versions should apply the following mitigation:

Users of 3.2.x should upgrade to 3.2.5
Users of 3.1.x should upgrade to 3.1.7

Credit:
This issue was identified by David Ohsie and brought to our attention by the CAS Development team.</description>
			<version>3.1.0</version>
			<fixedVersion>3.1.7, 3.2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.test.context.support.WithSecurityContextTestExecutionListener.java</file>
			<file type="M">org.springframework.security.cas.web.authentication.ServiceAuthenticationDetailsSource.java</file>
			<file type="M">org.springframework.security.cas.ServiceProperties.java</file>
			<file type="M">org.springframework.security.cas.web.authentication.DefaultServiceAuthenticationDetails.java</file>
			<file type="M">org.springframework.security.cas.web.ServicePropertiesTests.java</file>
			<file type="M">org.springframework.security.cas.web.authentication.DefaultServiceAuthenticationDetailsTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2719" opendate="2014-09-11 08:00:26" fixdate="2014-09-16 08:58:12" resolution="Fixed">
		<buginformation>
			<summary>authenticated().withRoles(...) is order-sensitive</summary>
			<description>The following test always fails for me.






	




@Test




	public void usuarioLogadoAcessaPagina() throws Exception {




		mvc.perform(get("/").with(user("fulano").roles("USER", "SELLER")))




			.andExpect(authenticated().withRoles("SELLER", "USER"))




			.andExpect(authenticated().withRoles("USER", "SELLER"));			




	}





 </description>
			<version>4.0.0.M2</version>
			<fixedVersion>4.0.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.java</file>
		</fixedFiles>
	</bug>
	<bug id="2727" opendate="2014-09-26 07:05:25" fixdate="2014-09-26 07:11:30" resolution="Duplicate">
		<buginformation>
			<summary>Spring security version check reports incorrectly.</summary>
			<description>When using spring core version 3.2.10 or greater the spring security version check reports a warning message about minimum version incorrectly.
To recreate run spring core 3.2.11 with spring security 3.2.4.
The issue is in the compare statement of:






if (springVersion.compareTo(MIN_SPRING_VERSION) &amp;lt; 0) {




     logger.warn("**** You are advised to use Spring " + MIN_SPRING_VERSION +  " or later with this version. You are running: " + springVersion);




}





</description>
			<version>3.2.4</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.core.SpringSecurityCoreVersionTests.java</file>
			<file type="M">org.springframework.security.core.SpringSecurityCoreVersion.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2697</link>
		</links>
	</bug>
	<bug id="2751" opendate="2014-10-23 11:50:15" fixdate="2014-10-23 12:00:08" resolution="Duplicate">
		<buginformation>
			<summary>AbstractPreAuthenticatedProcessingFilter assumes principal is a string</summary>
			<description>I am using pre-authentication alongside form login. I ran into a problem similar to this user:
https://jira.spring.io/browse/SEC-1983?focusedCommentId=93727&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-93727
In working around this problem, I noticed this code inside 
AbstractPreAuthenticatedProcessingFilter.requiresAuthentication():
if (currentUser.getName().equals(principal)) 
{
            return false;
 }

In my case, principal is an instance of UserDetails. So comparing an instance of String to an instance of UserDetails always returned false.
I had to change the above code to this:
if (currentUser.getPrincipal().equals(principal)) {
            return false;
}
</description>
			<version>3.2.5</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2078</link>
		</links>
	</bug>
	<bug id="2615" opendate="2014-05-30 12:44:56" fixdate="2014-11-18 15:00:13" resolution="Complete">
		<buginformation>
			<summary>accesscontrollist tag documentation incorrectly states hasPermission is an or</summary>
			<description>Updated Description
In 3.1 the accesscontrollist tag began performing an and on the permissions. This may have been accidental, but I think that it is more intuitive &amp;amp; secure for it to behave this way. When compared to hasAnyRole and hasRoles the hasPermission tag implies it is an and. If users end up needing OR support, then the authorize tag can be used along with the hasPermission expression. For example:






&amp;lt;sec:authorize access="hasPermission(#domain, &amp;amp;apos;read&amp;amp;apos;) or hasPermission(#domain, &amp;amp;apos;write&amp;amp;apos;) "&amp;gt;






In general, the authorize tag should be preferred as it is the more powerful way of performing authorization checks.
Original
According to section 4.4 of the Spring Security reference guide:
It checks a comma-separated list of required permissions for a specified domain object. If the current user has any of those permissions, then the tag body will be evaluated. If they dont, it will be skipped.
http://docs.spring.io/spring-security/site/docs/3.2.4.RELEASE/reference/htmlsingle/#the-accesscontrollist-tag
However, the tag seems to check that the user must have all the permissions listed in the hasPermission attribute.
It looks like SEC-1560 introduced the problem.  I believe that means it impacts versions 3.1 through the current version.
I&amp;amp;apos;m attaching a diff that I believe will get the tag working as documented again.</description>
			<version>3.1.0</version>
			<fixedVersion>4.0.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.taglibs.authz.AuthorizeTagTests.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AccessControlListTag.java</file>
		</fixedFiles>
	</bug>
	<bug id="2705" opendate="2014-08-18 13:38:34" fixdate="2014-11-19 10:06:56" resolution="Fixed">
		<buginformation>
			<summary>ExpressionBasedMessageSecurityMetadataSourceFactory configures null TrustResolver on DefaultMessageSecurityExpressionHandler</summary>
			<description>





15:32:03 [http-nio-8080-exec-9] StompSubProtocolHandler[ERROR] - Failed to send STOMP message from client to application MessageChannel in session 1a2vx7mq. Sending STOMP ERROR to client.




org.springframework.messaging.MessageDeliveryException: Failed to send message to ExecutorSubscribableChannel[clientInboundChannel]




	at org.springframework.messaging.support.AbstractMessageChannel.send(AbstractMessageChannel.java:117)




	at org.springframework.messaging.support.AbstractMessageChannel.send(AbstractMessageChannel.java:94)




	at org.springframework.web.socket.messaging.StompSubProtocolHandler.handleMessageFromClient(StompSubProtocolHandler.java:249)




	at org.springframework.web.socket.messaging.SubProtocolWebSocketHandler.handleMessage(SubProtocolWebSocketHandler.java:307)




	at org.springframework.web.socket.handler.WebSocketHandlerDecorator.handleMessage(WebSocketHandlerDecorator.java:75)




	at org.springframework.web.socket.handler.LoggingWebSocketHandlerDecorator.handleMessage(LoggingWebSocketHandlerDecorator.java:55)




	at org.springframework.web.socket.handler.ExceptionWebSocketHandlerDecorator.handleMessage(ExceptionWebSocketHandlerDecorator.java:69)




	at org.springframework.web.socket.sockjs.transport.session.AbstractSockJsSession.delegateMessages(AbstractSockJsSession.java:218)




	at org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession.handleMessage(WebSocketServerSockJsSession.java:194)




	at org.springframework.web.socket.sockjs.transport.handler.SockJsWebSocketHandler.handleTextMessage(SockJsWebSocketHandler.java:92)




	at org.springframework.web.socket.handler.AbstractWebSocketHandler.handleMessage(AbstractWebSocketHandler.java:43)




	at org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter.handleTextMessage(StandardWebSocketHandlerAdapter.java:112)




	at org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter.access$000(StandardWebSocketHandlerAdapter.java:42)




	at org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter$3.onMessage(StandardWebSocketHandlerAdapter.java:82)




	at org.springframework.web.socket.adapter.standard.StandardWebSocketHandlerAdapter$3.onMessage(StandardWebSocketHandlerAdapter.java:79)




	at org.apache.tomcat.websocket.WsFrameBase.sendMessageText(WsFrameBase.java:375)




	at org.apache.tomcat.websocket.WsFrameBase.processDataText(WsFrameBase.java:472)




	at org.apache.tomcat.websocket.WsFrameBase.processData(WsFrameBase.java:275)




	at org.apache.tomcat.websocket.WsFrameBase.processInputBuffer(WsFrameBase.java:116)




	at org.apache.tomcat.websocket.server.WsFrameServer.onDataAvailable(WsFrameServer.java:55)




	at org.apache.tomcat.websocket.server.WsHttpUpgradeHandler$WsReadListener.onDataAvailable(WsHttpUpgradeHandler.java:194)




	at org.apache.coyote.http11.upgrade.AbstractServletInputStream.onDataAvailable(AbstractServletInputStream.java:194)




	at org.apache.coyote.http11.upgrade.AbstractProcessor.upgradeDispatch(AbstractProcessor.java:95)




	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:650)




	at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:222)




	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1566)




	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1523)




	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)




	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)




	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)




	at java.lang.Thread.run(Thread.java:724)




Caused by: java.lang.IllegalArgumentException: Failed to evaluate expression &amp;amp;apos;authenticated&amp;amp;apos;




	at org.springframework.security.access.expression.ExpressionUtils.evaluateAsBoolean(ExpressionUtils.java:13)




	at org.springframework.security.messaging.access.expression.MessageExpressionVoter.vote(MessageExpressionVoter.java:53)




	at org.springframework.security.messaging.access.expression.MessageExpressionVoter.vote(MessageExpressionVoter.java:37)




	at org.springframework.security.access.vote.AffirmativeBased.decide(AffirmativeBased.java:62)




	at org.springframework.security.access.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:208)




	at org.springframework.security.messaging.access.intercept.ChannelSecurityInterceptor.preSend(ChannelSecurityInterceptor.java:70)




	at org.springframework.messaging.support.AbstractMessageChannel$ChannelInterceptorChain.applyPreSend(AbstractMessageChannel.java:147)




	at org.springframework.messaging.support.AbstractMessageChannel.send(AbstractMessageChannel.java:103)




	... 30 more




Caused by: org.springframework.expression.spel.SpelEvaluationException: EL1021E:(pos 0): A problem occurred whilst attempting to access the property &amp;amp;apos;authenticated&amp;amp;apos;: &amp;amp;apos;Unable to access property &amp;amp;apos;authenticated&amp;amp;apos; through getter&amp;amp;apos;




	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:214)




	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:92)




	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:81)




	at org.springframework.expression.spel.ast.SpelNodeImpl.getTypedValue(SpelNodeImpl.java:126)




	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:296)




	at org.springframework.security.access.expression.ExpressionUtils.evaluateAsBoolean(ExpressionUtils.java:11)




	... 37 more




Caused by: org.springframework.expression.AccessException: Unable to access property &amp;amp;apos;authenticated&amp;amp;apos; through getter




	at org.springframework.expression.spel.support.ReflectivePropertyAccessor$OptimalPropertyAccessor.read(ReflectivePropertyAccessor.java:634)




	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:209)




	... 42 more




Caused by: java.lang.reflect.InvocationTargetException




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:606)




	at org.springframework.expression.spel.support.ReflectivePropertyAccessor$OptimalPropertyAccessor.read(ReflectivePropertyAccessor.java:630)




	... 43 more




Caused by: java.lang.NullPointerException




	at org.springframework.security.access.expression.SecurityExpressionRoot.isAnonymous(SecurityExpressionRoot.java:88)




	at org.springframework.security.access.expression.SecurityExpressionRoot.isAuthenticated(SecurityExpressionRoot.java:92)




	... 48 more










</description>
			<version>4.0.0.M2</version>
			<fixedVersion>4.0.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.messaging.access.expression.DefaultMessageSecurityExpressionHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="2768" opendate="2014-11-19 09:56:54" fixdate="2014-11-19 10:07:04" resolution="Fixed">
		<buginformation>
			<summary>DefaultMessageSecurityExpressionHandler does not set PermissionEvaluator</summary>
			<description></description>
			<version>4.0.0.M2</version>
			<fixedVersion>4.0.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.messaging.access.expression.DefaultMessageSecurityExpressionHandlerTests.java</file>
			<file type="M">org.springframework.security.messaging.access.expression.DefaultMessageSecurityExpressionHandler.java</file>
			<file type="M">org.springframework.security.messaging.access.expression.MessageSecurityExpressionRoot.java</file>
		</fixedFiles>
	</bug>
	<bug id="2769" opendate="2014-11-19 09:57:40" fixdate="2014-11-19 10:07:12" resolution="Fixed">
		<buginformation>
			<summary>DefaultMessageSecurityExpressionHandler does not set RoleHierarchy</summary>
			<description></description>
			<version>4.0.0.M2</version>
			<fixedVersion>4.0.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.messaging.access.expression.DefaultMessageSecurityExpressionHandlerTests.java</file>
			<file type="M">org.springframework.security.messaging.access.expression.DefaultMessageSecurityExpressionHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="2574" opendate="2014-04-23 09:38:33" fixdate="2014-11-19 14:50:57" resolution="Fixed">
		<buginformation>
			<summary>Default JavaConfig SessionRegistryImpl does not receive SessionDestroyedEvents</summary>
			<description>SessionManagementConfigurer creates a default SessionRegistryImpl directly, without wiring it as a Spring bean. So, the SessionRegistryImpl does not receive SessionDestroyedEvents and does not maintain an accurate list of current sessions.
Once consequence of this is that concurrency control will work off inaccurate data, and in the worst case prevents users from ever logging in a second time with maximumSessions(1) and maxSessionPreventsLogin(true).
A workaround is for an application to define its own @Bean sessionRegistry(), and use it with "ConcurrencyControlConfigurer.sessionRegistry(sessionRegistry())". But this shouldn&amp;amp;apos;t be necessary.</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.6, 4.0.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.SessionManagementConfigurer.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="2794" opendate="2014-12-16 02:47:18" fixdate="2014-12-16 07:44:33" resolution="Duplicate">
		<buginformation>
			<summary>AbstractPreAuthenticatedProcessingFilter requires authentication check failure</summary>
			<description>In the AbstractPreAuthenticatedProcessingFilter.requiresAuthentication(HttpServletRequest request) method which is private, there is the following code:
        Object principal = getPreAuthenticatedPrincipal(request);
        if (currentUser.getName().equals(principal)) 
{
            return false;
        }

This assumes that the overriden method of getPreAuthenticatedPrincipal(request) will always return a String, when in fact it could be any object. This needs to change to either:
		String principal = request.getUserPrincipal().getName();
		if (currentUser.getName().equals(principal)) 
{
			return false;
		}
or provide an abstract method (or at least a protected/public method) in order to do the comparison - see attachment. My getPreAuthenticatedPrincipal(request) returns a FederationPrincipal, and not a String. The only way to deal with it at the moment is to completely copy the AbstractPreAuthenticatedProcessingFilter, and change the tiny bit of code above.</description>
			<version>4.0.0.RC1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2078</link>
		</links>
	</bug>
	<bug id="2497" opendate="2014-02-23 14:04:01" fixdate="2014-12-16 07:46:58" resolution="Duplicate">
		<buginformation>
			<summary>checkForPrincipalChanges limited to String Principal</summary>
			<description>In AbstractPreAuthenticatedProcessingFilter,
method requiresAuthentication , Principal are assumed to be String 
 if (currentUser.getName().equals(principal)) 
should be
  if (currentUser.getPrincipal().equals(principal)) </description>
			<version>3.2.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2078</link>
		</links>
	</bug>
	<bug id="2815" opendate="2015-01-13 14:32:24" fixdate="2015-01-20 12:30:38" resolution="Complete">
		<buginformation>
			<summary>@EnableGlobalMethodSecurity prevents postprocessing of DataSource bean</summary>
			<description>Adding `@EnableGlobalMethodSecurity` annotation to my extension of `WebSecurityConfigurerAdapter` prevents embedded database initialization in integration testing.
The problem is very nicely summarized here -&amp;gt; https://gist.github.com/dsyer/ebeb25d5afbdd9242cd5</description>
			<version>3.2.5</version>
			<fixedVersion>3.2.6, 4.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Supersede" description="supersedes">2661</link>
		</links>
	</bug>
	<bug id="2822" opendate="2015-01-19 12:39:20" fixdate="2015-01-20 14:23:01" resolution="Complete">
		<buginformation>
			<summary>IllegalStateException: Cannot apply DaoAuthenticationConfigurer to already built object</summary>
			<description>Created by request from Rob Winch.
When initializing global authentication by injecting AuthenticationManagerBuilder you may get this exception






org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration&amp;amp;apos;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire method: public void org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.setFilterChainProxySecurityConfigurer(org.springframework.security.config.annotation.ObjectPostProcessor,java.util.List) throws java.lang.Exception; nested exception is org.springframework.beans.factory.BeanExpressionException: Expression parsing failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;demo.SecurityConfig&amp;amp;apos;: Injection of autowired dependencies failed; nested exception is java.lang.IllegalStateException: Cannot apply org.springframework.security.config.annotation.authentication.configurers.userdetails.DaoAuthenticationConfigurer@62f10514 to already built object




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:334)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1202)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:476)




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:303)




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:299)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:194)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:762)




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:757)




	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:480)




	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:691)




	at org.springframework.boot.SpringApplication.run(SpringApplication.java:321)




	at org.springframework.boot.test.SpringApplicationContextLoader.loadContext(SpringApplicationContextLoader.java:98)




	at org.springframework.test.context.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:68)




	at org.springframework.test.context.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:86)




	at org.springframework.test.context.DefaultTestContext.getApplicationContext(DefaultTestContext.java:72)




	at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:170)




	at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(ServletTestExecutionListener.java:110)




	at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:212)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:200)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:252)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:254)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:217)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:83)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)




	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)




	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:68)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:163)




	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)




	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)




Caused by: org.springframework.beans.factory.BeanCreationException: Could not autowire method: public void org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.setFilterChainProxySecurityConfigurer(org.springframework.security.config.annotation.ObjectPostProcessor,java.util.List) throws java.lang.Exception; nested exception is org.springframework.beans.factory.BeanExpressionException: Expression parsing failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;demo.SecurityConfig&amp;amp;apos;: Injection of autowired dependencies failed; nested exception is java.lang.IllegalStateException: Cannot apply org.springframework.security.config.annotation.authentication.configurers.userdetails.DaoAuthenticationConfigurer@62f10514 to already built object




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:649)




	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88)




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:331)




	... 40 common frames omitted




Caused by: org.springframework.beans.factory.BeanExpressionException: Expression parsing failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;demo.SecurityConfig&amp;amp;apos;: Injection of autowired dependencies failed; nested exception is java.lang.IllegalStateException: Cannot apply org.springframework.security.config.annotation.authentication.configurers.userdetails.DaoAuthenticationConfigurer@62f10514 to already built object




	at org.springframework.context.expression.StandardBeanExpressionResolver.evaluate(StandardBeanExpressionResolver.java:164)




	at org.springframework.beans.factory.support.AbstractBeanFactory.evaluateBeanDefinitionString(AbstractBeanFactory.java:1365)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:964)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:949)




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:606)




	... 42 common frames omitted




Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;demo.SecurityConfig&amp;amp;apos;: Injection of autowired dependencies failed; nested exception is java.lang.IllegalStateException: Cannot apply org.springframework.security.config.annotation.authentication.configurers.userdetails.DaoAuthenticationConfigurer@62f10514 to already built object




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:334)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1202)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:476)




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:303)




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:299)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:523)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:512)




	at org.springframework.security.config.annotation.web.configuration.AutowiredWebSecurityConfigurersIgnoreParents.getWebSecurityConfigurers(AutowiredWebSecurityConfigurersIgnoreParents.java:52)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:606)




	at org.springframework.expression.spel.support.ReflectiveMethodExecutor.execute(ReflectiveMethodExecutor.java:112)




	at org.springframework.expression.spel.ast.MethodReference.getValueInternal(MethodReference.java:129)




	at org.springframework.expression.spel.ast.MethodReference.access$000(MethodReference.java:49)




	at org.springframework.expression.spel.ast.MethodReference$MethodValueRef.getValue(MethodReference.java:342)




	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:88)




	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:120)




	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:242)




	at org.springframework.context.expression.StandardBeanExpressionResolver.evaluate(StandardBeanExpressionResolver.java:161)




	... 46 common frames omitted




Caused by: java.lang.IllegalStateException: Cannot apply org.springframework.security.config.annotation.authentication.configurers.userdetails.DaoAuthenticationConfigurer@62f10514 to already built object




	at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.add(AbstractConfiguredSecurityBuilder.java:192)




	at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.apply(AbstractConfiguredSecurityBuilder.java:125)




	at org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder.apply(AuthenticationManagerBuilder.java:296)




	at org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder.userDetailsService(AuthenticationManagerBuilder.java:193)




	at demo.SecurityConfig.configureGlobal(SecurityConfig.java:39)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:606)




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:642)




	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88)




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:331)




	... 68 common frames omitted





</description>
			<version>3.2.5</version>
			<fixedVersion>3.2.6, 4.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2793</link>
			<link type="Relate" description="relates to">12646</link>
		</links>
	</bug>
	<bug id="2819" opendate="2015-01-17 14:39:10" fixdate="2015-01-21 08:35:15" resolution="Complete">
		<buginformation>
			<summary> SimpDestinationMessageMatcher(String pattern, SimpMessageType type) never passes type param to this() constructor</summary>
			<description>





SimpDestinationMessageMatcher.java






public SimpDestinationMessageMatcher(String pattern, SimpMessageType type) {




        this(pattern, null, new AntPathMatcher());




}






Always passes null as SimpMessageType parameter instead of type param therefore ignoring it completely.</description>
			<version>4.0.0.RC1</version>
			<fixedVersion>4.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.messaging.util.matcher.SimpDestinationMessageMatcherTests.java</file>
			<file type="M">org.springframework.security.messaging.util.matcher.SimpMessageTypeMatcher.java</file>
			<file type="M">org.springframework.security.messaging.util.matcher.SimpDestinationMessageMatcher.java</file>
		</fixedFiles>
	</bug>
	<bug id="2793" opendate="2014-12-12 07:34:38" fixdate="2015-01-27 11:55:24" resolution="Duplicate">
		<buginformation>
			<summary>Spring Boot Requires "extends WebSecurityConfigurerAdapter"</summary>
			<description>Spring Boot causes ordering issues if using configureGlobal and the class configuring it does not extend WebSecurityConfigurerAdapter. This should be fixed to leverage the @Enable* annotations to eagerly initialize these classes.</description>
			<version>3.2.5</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2822</link>
		</links>
	</bug>
	<bug id="2831" opendate="2015-01-28 04:36:20" fixdate="2015-02-04 10:05:59" resolution="Complete">
		<buginformation>
			<summary>RegexRequestMatcher/AntPathRequestMatcher should not throw exception with invalid HTTP method in the request</summary>
			<description>Observed behavior
Unknown HTTP method will cause IllegalArgumentException in LogoutFilter &amp;gt; AntPathRequestMatcher. Stack trace:






java.lang.IllegalArgumentException: No enum constant org.springframework.http.HttpMethod.PROPFIND




	at java.lang.Enum.valueOf(Enum.java:236)




	at org.springframework.http.HttpMethod.valueOf(HttpMethod.java:27)




	at org.springframework.security.web.util.matcher.AntPathRequestMatcher.matches(AntPathRequestMatcher.java:125)




	at org.springframework.security.web.authentication.logout.LogoutFilter.requiresLogout(LogoutFilter.java:122)




	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:94)




...






This issue is more severe as this will fail on any request with unknown HTTP method (i.e. not just request to logout filter processing URI).
Note that this is not a feature request to support custom HTTP methods, but really a bug report about incorrect handling of unknown HTTP method.
Expected behavior
Request with unknown HTTP method MUST NOT end with internal server error. Such request should just not be matched if a required HTTP method is specified.
How to reproduce
Use any web application with LogoutFilter processing configured:






curl -XANY_METHOD http://host:port/context/any-path 





</description>
			<version>3.2.5</version>
			<fixedVersion>3.2.6, 4.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.util.matcher.AntPathRequestMatcher.java</file>
			<file type="M">org.springframework.security.web.util.matcher.RegexRequestMatcher.java</file>
			<file type="M">org.springframework.security.web.util.matcher.AntPathRequestMatcherTests.java</file>
			<file type="M">org.springframework.security.web.util.matcher.RegexRequestMatcherTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">3160</link>
		</links>
	</bug>
	<bug id="2791" opendate="2014-12-10 15:01:05" fixdate="2015-02-04 13:58:26" resolution="Complete">
		<buginformation>
			<summary>Chrome/safari: cookie not set AbstractRememberMeServices should have a setter for cookie version</summary>
			<description>RememberMe cookie is not set in chrome and safari because only Expires field is set, not max age and they both ignore cookies.
MaxAge is only set in jetty when version is &amp;gt;= 1.</description>
			<version>3.2.5</version>
			<fixedVersion>3.2.6, 4.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.rememberme.AbstractRememberMeServices.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.AbstractRememberMeServicesTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2845" opendate="2015-02-10 00:42:45" fixdate="2015-02-18 08:02:38" resolution="Complete">
		<buginformation>
			<summary>Exception when using AbstractSecurityWebSocketMessageBrokerConfigurer with anonymous authentication</summary>
			<description>When using an AbstractSecurityWebSocketMessageBrokerConfigurer and trying to use messaging with an anonymous authentication (i.e. not logged in), i see the following exception:






org.springframework.messaging.MessageDeliveryException: Failed to send message to ExecutorSubscribableChannel[clientInboundChannel];




nested exception is org.springframework.security.authentication.AuthenticationCredentialsNotFoundException: An Authentication object was not found in the SecurityContext






thrown here: https://github.com/spring-projects/spring-security/blob/master/core/src/main/java/org/springframework/security/access/intercept/AbstractSecurityInterceptor.java#L200
a wild guess would be that an anonymous authentication is not put into the message headers, so the SecurityContextChannelInterceptor does not populate the SecurityContext and then again AbstractSecurityInterceptor just gets null instead of an anonymous Authentication.
but i am sure you got a better idea whats going on there (or if i am just missing sth.) 
thanks, zyro</description>
			<version>4.0.0.RC1</version>
			<fixedVersion>4.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.messaging.context.SecurityContextChannelInterceptor.java</file>
			<file type="M">org.springframework.security.messaging.context.SecurityContextChannelInterceptorTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2078" opendate="2012-11-09 01:12:03" fixdate="2015-02-24 14:45:28" resolution="Complete">
		<buginformation>
			<summary>Pre-authentication fails when using check for principal change and using non String principals</summary>
			<description>The problem occurs when using pre-authentication with "check for principal change" set and the class there extends org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter using non String principals but e.g. java.security.Principal.
The problem is that the authentication manager will always authenticate even the principal has no changed, this can give problems with the authentication provider, and performance in the code.
The error is in line 145 in the AbstractPreAuthenticatedProcessingFilter class, the code:
  if (currentUser.getName().equals(principal)) 
{
    return false;
  }

should be changed to something like:
  if (principal instanceof Principal) 
{
    return !currentUser.getName().equals(((Principal)principal).getName());
  }
  else 
{
    return !currentUser.getName().equals(principal.toString());
  }

The original code will only function when the passed principal parameter is of the type String. The code suggested will function for all type of objects there either implements the java.security.Principal interface or override the toString method.</description>
			<version>3.1.3</version>
			<fixedVersion>3.2.6, 4.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2497</link>
			<link type="Duplicate" description="is duplicated by">2751</link>
			<link type="Duplicate" description="is duplicated by">2794</link>
			<link type="Relate" description="is related to">3051</link>
		</links>
	</bug>
	<bug id="2832" opendate="2015-01-28 06:36:14" fixdate="2015-02-24 15:35:27" resolution="Complete">
		<buginformation>
			<summary>CSRF Request attributes not updated on authentication</summary>
			<description>The CsrfFilter sets request attributes on each request, exposing the current CsrfToken for later use.  However, if authentication happens during this request, the SessionManagementFilter will cause the CsrfAuthenticationStrategy to fire which will generate a new token.  However, the request attributes are not updated.  As a result, if there is a form being rendered in the response using the CsrfRequestDataValueProcessor, it will use the old CsrfToken instead of the newly generated one.  As a result, when the form is submitted, the request will fail due to CSRF protection.</description>
			<version>3.2.5</version>
			<fixedVersion>3.2.6, 4.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.csrf.CsrfAuthenticationStrategyTests.java</file>
			<file type="M">org.springframework.security.web.csrf.CsrfAuthenticationStrategy.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">2404</link>
		</links>
	</bug>
	<bug id="2879" opendate="2015-02-24 21:11:23" fixdate="2015-02-24 21:21:11" resolution="Complete">
		<buginformation>
			<summary>JdbcTokenRepositoryImpl updateToken should use lastUsed arg</summary>
			<description></description>
			<version>3.2.5</version>
			<fixedVersion>3.2.6, 4.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImplTests.java</file>
			<file type="M">org.springframework.security.web.authentication.rememberme.JdbcTokenRepositoryImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="2900" opendate="2015-03-09 06:33:32" fixdate="2015-03-09 07:09:03" resolution="Duplicate">
		<buginformation>
			<summary>Active-directory based login stopped working</summary>
			<description>Active-directory based login in my project works fine with version 3.2.5.
With 3.2.6 it does not anymore, without any exception.
I am using a "FilteringAuthenticationProvider" to decide if the AD-controller is hit with an auth. request or not. I will include the code here.
&amp;lt;beans:bean id="filteringLdapProvider" class="com.example.FilteringAuthenticationProvider"&amp;gt;
	&amp;lt;beans:constructor-arg ref="adAuthenticationProvider" /&amp;gt;
&amp;lt;/beans:bean&amp;gt;
&amp;lt;authentication-manager alias="authenticationManager"&amp;gt;
	&amp;lt;authentication-provider ref="filteringLdapProvider" /&amp;gt;
	&amp;lt;authentication-provider user-service-ref="myUserDetailsService"&amp;gt;
		&amp;lt;password-encoder ref="passwordEncoder" /&amp;gt;
	&amp;lt;/authentication-provider&amp;gt;
&amp;lt;/authentication-manager&amp;gt;
&amp;lt;beans:bean id="adAuthenticationProvider" class="org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider"&amp;gt;
	&amp;lt;beans:constructor-arg value="the.domain" /&amp;gt;
	&amp;lt;beans:constructor-arg value="ldap://the.host/" /&amp;gt;
&amp;lt;/beans:bean&amp;gt;
import javax.inject.Inject;
import com.example.service.UserService;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.validator.GenericValidator;
import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.authentication.WebAuthenticationDetails;
import org.springframework.stereotype.Component;
@Component
public class FilteringAuthenticationProvider implements AuthenticationProvider {
	// http://stackoverflow.com/questions/21381893/use-different-authenticationprovider-depending-on-username-and-remote-ip-address/
	private static Logger			logger		= Logger.getLogger(FilteringAuthenticationProvider.class);
	private AuthenticationProvider	delegate	= null;
	@Inject
	private UserService				userService;
	public FilteringAuthenticationProvider() {
	}
	public FilteringAuthenticationProvider(final AuthenticationProvider delegate) 
{
		this.delegate = delegate;
	}


	@Override
	public Authentication authenticate(final Authentication authentication) throws AuthenticationException {
		final Object details = authentication.getDetails();
		final String username = authentication.getPrincipal().toString();
		String remoteAddress = null;
		if (details instanceof WebAuthenticationDetails) 
{
			remoteAddress = ((WebAuthenticationDetails) details).getRemoteAddress();
		}

		if (matches(remoteAddress, username)) {
			final boolean isWindowsLoginEnabled = userService.isWindowsLoginEnabled(username);
			if (isWindowsLoginEnabled) 
{
				logger.info("Delegating user &amp;amp;apos;" + username + "&amp;amp;apos; to ActiveDirectoryLdapAuthenticationProvider");
				return delegate.authenticate(authentication);
			}
 else 
{
				return null;
			}
		}
		return null;
	}
	private boolean matches(final String remoteAddress, final String username) {
		if (!GenericValidator.isEmail(username)) 
{
			return true;
		}

		return false;
	}
	@Override
	public boolean supports(final Class&amp;lt;?&amp;gt; authentication) 
{
		return authentication.equals(UsernamePasswordAuthenticationToken.class);
	}
}</description>
			<version>3.2.6</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProviderTests.java</file>
			<file type="M">org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2897</link>
		</links>
	</bug>
	<bug id="2882" opendate="2015-02-26 07:11:42" fixdate="2015-03-10 09:52:54" resolution="Complete">
		<buginformation>
			<summary>DefaultLoginPageGeneratingFilter grabs /**/login</summary>
			<description>I have the following Groovy security configuration in a Spring Boot web app:






@Configuration




@EnableWebSecurity




class SecurityConfig extends WebSecurityConfigurerAdapter {









    @Override




    protected void configure(HttpSecurity http) throws Exception {




        http.




            authorizeRequests().




                antMatchers("/scratch/secured").hasRole("USER").




                antMatchers("/**").permitAll().




                anyRequest().authenticated().




            and().




            formLogin();




    }




}






This does get me the built-in login form at /login, but it also hijacks /foo/something/login. DefaultLoginPageGeneratingFilter#matches appears to treat the url as a suffix instead of as an absolute path. Even though the context path should be /foo/something/login, the conditional at 262 evaluates to true, and the endsWith comparison is used. I can&amp;amp;apos;t get Eclipse to dump the contents of request.getContextPath() right there during debugging.</description>
			<version>4.0.0.RC1</version>
			<fixedVersion>4.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.DefaultLoginPageGeneratingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">2227</link>
		</links>
	</bug>
	<bug id="2897" opendate="2015-03-06 07:14:44" fixdate="2015-03-10 14:43:09" resolution="Fixed">
		<buginformation>
			<summary>ActiveDirectoryLdapAuthenticationProvider should use bindPrincipal not username</summary>
			<description>Shouldn&amp;amp;apos;t the lines
return SpringSecurityLdapTemplate.searchForSingleEntryInternal(context, searchControls,
                   searchRoot, searchFilter, new Object[]
{username}
);
actually be
return SpringSecurityLdapTemplate.searchForSingleEntryInternal(context, searchControls,
                   searchRoot, searchFilter, new Object[]
{bindPrincipal}
);
?
This currently breaks our authentication.</description>
			<version>3.2.6</version>
			<fixedVersion>3.2.7, 4.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProviderTests.java</file>
			<file type="M">org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2895</link>
			<link type="Duplicate" description="is duplicated by">2900</link>
			<link type="Relate" description="is related to">1915</link>
		</links>
	</bug>
	<bug id="2908" opendate="2015-03-17 07:20:28" fixdate="2015-03-20 13:31:53" resolution="Complete">
		<buginformation>
			<summary>Example given in javadoc doesn&amp;apos;t work</summary>
			<description>The code below is copied from the javadoc of HttpSecurity HttpSecurity .requestMatcher(RequestMatcher requestMatcher):






 @Configuration




 @EnableWebSecurity




 public class RequestMatchersSecurityConfig extends WebSecurityConfigurerAdapter {









     @Override




     protected void configure(HttpSecurity http) throws Exception {




         http




             .requestMatchers()




                 .antMatchers("/api/**")




                 .and()




             .requestMatchers()




                 .antMatchers("/oauth/**")




                 .and()




             .authorizeRequests()




                 .antMatchers("/**").hasRole("USER").and()




                 .httpBasic();




     }









     @Override




     protected void configure(AuthenticationManagerBuilder auth)




             throws Exception {




         auth




             .inMemoryAuthentication()




                 .withUser("user")




                     .password("password")




                     .roles("USER");




     }




 }






the request matcher only matches /oauth/** exptected an OrMatcher on /api/** and /oauth/**






2015-03-17 14:55:10.448  INFO 35782 --- [           main] o.s.s.web.DefaultSecurityFilterChain     : Creating filter chain: OrRequestMatcher [requestMatchers=[Ant [pattern=&amp;amp;apos;/oauth/**&amp;amp;apos;]]], [org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@6956e01, org.springframework.security.web.context.SecurityContextPersistenceFilter@4708993a, org.springframework.security.web.header.HeaderWriterFilter@448d9973, org.springframework.security.web.csrf.CsrfFilter@624f1602, org.springframework.security.web.authentication.logout.LogoutFilter@79b04c7, org.springframework.security.web.authentication.www.BasicAuthenticationFilter@306eb59c, org.springframework.security.web.savedrequest.RequestCacheAwareFilter@292e39db, org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@501cc8a5, org.springframework.security.web.authentication.AnonymousAuthenticationFilter@3c690707, org.springframework.security.web.session.SessionManagementFilter@1516d73d, org.springframework.security.web.access.ExceptionTranslationFilter@110f9f2f, org.springframework.security.web.access.intercept.FilterSecurityInterceptor@364adedd]











Notice OrRequestMatcher [requestMatchers=[Ant [pattern=&amp;amp;apos;/oauth/**&amp;amp;apos;]]] in log.</description>
			<version>3.2.5</version>
			<fixedVersion>4.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.builders.HttpSecurity.java</file>
		</fixedFiles>
	</bug>
	<bug id="2895" opendate="2015-03-04 14:57:47" fixdate="2015-03-20 13:43:23" resolution="Duplicate">
		<buginformation>
			<summary>Active Directory based configuration no longer works in 3.2.6</summary>
			<description>Hi. I upgraded to org.springframework.security:spring-security-ldap:3.2.6.RELEASE to authenticate users against my ldap server.
Config yml:






ldap:




  domain: myldapdomain.net




  url: ldaps://172.XX.X.XX:690






Spring boot groovy config:






@Configuration




@EnableWebMvcSecurity




public class WebSecurityConfig extends WebSecurityConfigurerAdapter {









   @Value(&amp;amp;apos;${ldap.domain}&amp;amp;apos;)




   private String DOMAIN




   @Value(&amp;amp;apos;${ldap.url}&amp;amp;apos;)




   private String URL




...









   @Override




   protected void configure(AuthenticationManagerBuilder authManagerBuilder) throws Exception {




      authManagerBuilder.authenticationProvider(activeDirectoryLdapAuthenticationProvider())




            .userDetailsService(userDetailsService())




   }









   @Bean




   public AuthenticationManager authenticationManager() {




      return new ProviderManager(Arrays.asList(activeDirectoryLdapAuthenticationProvider()))




   }









   @Bean




   public AuthenticationProvider activeDirectoryLdapAuthenticationProvider() {




      ActiveDirectoryLdapAuthenticationProvider provider =




            new ActiveDirectoryLdapAuthenticationProvider(DOMAIN, URL)




      provider.setConvertSubErrorCodesToExceptions(true)




      provider.setUseAuthenticationRequestCredentials(true)




      return provider




   }




}






With 2.3.5 I can type only my AD username, and this works.
With 2.3.6, using only my AD username I get this message in the logs, and fails:






javax.naming.PartialResultException: Unprocessed Continuation Reference(s); remaining name &amp;amp;apos;dc=myldapdomain,dc=net&amp;amp;apos;






If, however, I login as myuser@myldapdomain.net I can login correctly.
Is there a new configuration parameter I should set? Thanks!</description>
			<version>3.2.6</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProviderTests.java</file>
			<file type="M">org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2897</link>
		</links>
	</bug>
	<bug id="2913" opendate="2015-03-25 07:34:19" fixdate="2015-03-25 19:44:15" resolution="Complete">
		<buginformation>
			<summary>Default JavaConfig session fixation AuthenticationStrategy has NullEventPublisher</summary>
			<description>Debugging into a ChangeSessionIdAuthenticationStrategy in a working app I noticed that the applicationEventPublisher was a no-op. Seems like maybe it didn&amp;amp;apos;t get configured somewhere in Spring Security Javaconfig?</description>
			<version>3.2.6</version>
			<fixedVersion>3.2.7, 4.0.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.SessionManagementConfigurer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2919" opendate="2015-03-25 21:24:22" fixdate="2015-04-17 09:12:49" resolution="Fixed">
		<buginformation>
			<summary>DefaultLoginGeneratingFilter incorrectly used if login-url="/login"</summary>
			<description>If an application specifies form-login@login-url="/login" then the DefaultLoginGeneratingFilter is incorrectly used. This means that the custom login page cannot be specified with the URL "/login". For example:






&amp;lt;http ...&amp;gt;




	&amp;lt;form-login login-page="/login" ... /&amp;gt;




&amp;lt;/http&amp;gt;






Workaround
Using a different URL
One workaround is to use a different URL for the login page. For example, one could use "/authenticate".
Using a BeanDefinitionRegistryPostProcessor
Alternatively, the following BeanDefinitionRegistryPostProcessor will fix the issue by removing the DefaultLoginPageGeneratingFilter. To use it simply ensure to register the BeanDefinitionRegistryPostProcessor as a Bean.






import java.util.Iterator;




import java.util.List;









import org.springframework.beans.BeansException;




import org.springframework.beans.factory.config.BeanDefinition;




import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;




import org.springframework.beans.factory.support.BeanDefinitionRegistry;




import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;




import org.springframework.security.web.DefaultSecurityFilterChain;




import org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter;









public class Sec2919PostProcessor implements BeanDefinitionRegistryPostProcessor {




	@Override




	public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)




			throws BeansException {




		String[] beanDefinitionNames = registry.getBeanDefinitionNames();




		for(String name : beanDefinitionNames) {




			BeanDefinition beanDefinition = registry.getBeanDefinition(name);




			if(beanDefinition.getBeanClassName().equals(DefaultSecurityFilterChain.class.getName())) {




				List&amp;lt;Object&amp;gt; filters = (List&amp;lt;Object&amp;gt;) beanDefinition.getConstructorArgumentValues().getArgumentValue(1, List.class).getValue();




				Iterator&amp;lt;Object&amp;gt; iFilters = filters.iterator();




				while(iFilters.hasNext()) {




					Object f = iFilters.next();




					if(f instanceof BeanDefinition) {




						BeanDefinition bean = (BeanDefinition) f;




						if(bean.getBeanClassName().equals(DefaultLoginPageGeneratingFilter.class.getName())) {




							iFilters.remove();




						}




					}




				}




			}




		}




	}









	@Override




	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)




			throws BeansException {




	}




}





</description>
			<version>4.0.0</version>
			<fixedVersion>4.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2949</link>
		</links>
	</bug>
	<bug id="2930" opendate="2015-04-06 04:39:46" fixdate="2015-04-21 07:21:46" resolution="Fixed">
		<buginformation>
			<summary>Review hasRole/hasAuthority documentation in SecurityExpressionOperations</summary>
			<description>1. After the changes from SEC-2758 the hasRole/hasAuthority methods are not 100% synonyms.
2. hasAuthority(String) is described as a synonym for itself</description>
			<version>4.0.0.RC2</version>
			<fixedVersion>4.0.1</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.expression.SecurityExpressionOperations.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">2758</link>
		</links>
	</bug>
	<bug id="2851" opendate="2015-02-16 13:09:03" fixdate="2015-04-21 13:05:02" resolution="Complete">
		<buginformation>
			<summary>java.lang.NoClassDefFoundError: org/springframework/dao/DataAccessException on configuring http.rememberMe()</summary>
			<description>I use spring-boot-starter-security 1.1.8.RELEASE + mongodb. When I try to configure `http.rememberMe().tokenRepository(tokenRepository).tokenValiditySeconds(60*60*24);` Spring throws an exception:






Caused by: java.lang.NoClassDefFoundError: org/springframework/dao/DataAccessException




	at org.springframework.security.config.annotation.web.configurers.RememberMeConfigurer.createPersistentRememberMeServices(RememberMeConfigurer.java:316)




	at org.springframework.security.config.annotation.web.configurers.RememberMeConfigurer.createRememberMeServices(RememberMeConfigurer.java:289)




	at org.springframework.security.config.annotation.web.configurers.RememberMeConfigurer.getRememberMeServices(RememberMeConfigurer.java:259)




	at org.springframework.security.config.annotation.web.configurers.RememberMeConfigurer.init(RememberMeConfigurer.java:196)




	at org.springframework.security.config.annotation.web.configurers.RememberMeConfigurer.init(RememberMeConfigurer.java:76)




	at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.init(AbstractConfiguredSecurityBuilder.java:367)




	at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.doBuild(AbstractConfiguredSecurityBuilder.java:320)




	at org.springframework.security.config.annotation.AbstractSecurityBuilder.build(AbstractSecurityBuilder.java:39)




	at org.springframework.security.config.annotation.web.builders.WebSecurity.performBuild(WebSecurity.java:293)




	at org.springframework.security.config.annotation.web.builders.WebSecurity.performBuild(WebSecurity.java:74)




	at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.doBuild(AbstractConfiguredSecurityBuilder.java:329)




	at org.springframework.security.config.annotation.AbstractSecurityBuilder.build(AbstractSecurityBuilder.java:39)




	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.springSecurityFilterChain(WebSecurityConfiguration.java:92)




	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerBySpringCGLIB$$19a4159a.CGLIB$springSecurityFilterChain$2(&amp;lt;generated&amp;gt;)




	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerBySpringCGLIB$$19a4159a$$FastClassBySpringCGLIB$$207e7f32.invoke(&amp;lt;generated&amp;gt;)






Temporary solution: add  "org.springframework:spring-tx" dependency. But I dont use SQL so I don&amp;amp;apos;t need spring-tx. Please decouple spring-security and spring-tx
</description>
			<version>3.2.5</version>
			<fixedVersion>3.2.8, 4.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.rememberme.PersistentTokenBasedRememberMeServices.java</file>
		</fixedFiles>
	</bug>
	<bug id="2935" opendate="2015-04-08 11:54:05" fixdate="2015-04-22 14:14:27" resolution="Complete">
		<buginformation>
			<summary>Security context held between multiple MVC requests in one test</summary>
			<description>I&amp;amp;apos;m using the new Spring Security test integration features in my Mock MVC tests and noticed that in tests where there are two MVC calls but with different Authentication, the Authentication set in the first MVC call is still present on the second MVC call.
For example, the first call has only the required update permission and the second call has only the required read permission. The second still has the update permission and can&amp;amp;apos;t do the read.
In order to work around this I created a ResultHandler that will call TestSecurityContext.clearContext().</description>
			<version>4.0.0</version>
			<fixedVersion>4.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessorsTestSecurityContextTests.java</file>
			<file type="M">org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">2941</link>
			<link type="Relate" description="is related to">3083</link>
		</links>
	</bug>
	<bug id="2949" opendate="2015-04-28 04:40:07" fixdate="2015-04-28 18:53:46" resolution="Duplicate">
		<buginformation>
			<summary>Custom Login not working in Spring 4.0</summary>
			<description>i created a simple spring mvc project and added a custom login page. The custom login works fine with 3.2.7 but the same custom login does not work when i upgrade to 4.0.0.Release. </description>
			<version>4.0.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.AuthenticationConfigBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2919</link>
		</links>
	</bug>
	<bug id="2960" opendate="2015-05-04 08:13:31" fixdate="2015-05-04 08:16:19" resolution="Duplicate">
		<buginformation>
			<summary>Bad Spring Security XSD Version Error Message</summary>
			<description>When applicationContext.xml includes an old Spring Security XSD, the error message is misleading, indicating that version 3.2 needs to be used (I was using 3.2), when 4.0+ actually needs to be used.
The Reference URL indicates the erroneous line.
Note that this has been a problem in the past:
https://jira.spring.io/browse/SEC-2145
Perhaps it&amp;amp;apos;s worth considering a dynamically-created error message?</description>
			<version>4.0.1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandler.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2948</link>
		</links>
	</bug>
	<bug id="2948" opendate="2015-04-27 13:16:16" fixdate="2015-07-09 21:21:01" resolution="Complete">
		<buginformation>
			<summary>Incorrect message when upgrading to 4.0.x with the wrong xml schema declarations</summary>
			<description>During migration from 3.2.x to 4.0.1 I came across the following error message when using the 4.0.1 library with an XML config file with 3.2 schema declarations...






SEVERE: Exception sending context initialized event to listener instance of class org.springframework.web.context.ContextLoaderListener




org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: You cannot use a spring-security-2.0.xsd or spring-security-3.0.xsd or spring-security-3.1.xsd schema with Spring Security 3.2. Please update your schema declarations to the 3.2 schema.




Offending resource: class path resource [foo/bar/spring/spring-security.xml]






The error message needs to be updated to...
You cannot use a spring-security-2.0.xsd or spring-security-3.0.xsd or spring-security-3.1.xsd or spring-security-3.2.xsd schema with Spring Security 4.0. Please update your schema declarations to the 4.0 schema.
XML Declarations that cause the error...






&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;




&amp;lt;beans xmlns="http://www.springframework.org/schema/beans"




    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"




    xmlns:aop="http://www.springframework.org/schema/aop"




    xmlns:context="http://www.springframework.org/schema/context"




    xmlns:security="http://www.springframework.org/schema/security"




    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd




    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd




    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd




    http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.2.xsd"




    &amp;gt;





</description>
			<version>4.0.1</version>
			<fixedVersion>4.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandler.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">2960</link>
			<link type="Duplicate" description="is duplicated by">2990</link>
		</links>
	</bug>
	<bug id="3035" opendate="2015-07-11 10:19:06" fixdate="2015-07-11 13:36:47" resolution="Duplicate">
		<buginformation>
			<summary>SecurityContextHolderAwareRequestWrapper#isUserInRole adds role prefix to already prefixed role</summary>
			<description>SecurityContextHolderAwareRequestWrapper#isUserInRole adds role prefix even if passed role already has one.
Currently calling request.isUserInRole("ROLE_ADMIN") fails because ROLE_ADMIN becomes ROLE_ROLE_ADMIN in SecurityContextHolderAwareRequestWrapper#isGranted method.</description>
			<version>4.0.1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestWrapperTests.java</file>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestWrapper.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">3020</link>
		</links>
	</bug>
	<bug id="2988" opendate="2015-05-28 02:05:06" fixdate="2015-07-13 20:52:15" resolution="Complete">
		<buginformation>
			<summary>OnMissingBeanCondition is defined in OnBeanCondition.java</summary>
			<description>OnBeanCondition.java defines a class named OnMissingBeanCondition
github source</description>
			<version>4.0.0</version>
			<fixedVersion>4.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.security.config.annotation.web.configuration.OnBeanCondition.java</file>
		</fixedFiles>
	</bug>
	<bug id="3034" opendate="2015-07-10 01:05:22" fixdate="2015-07-13 21:59:38" resolution="Complete">
		<buginformation>
			<summary>AclPermissionEvaluator.resolvePermission fails with Turkish Locale</summary>
			<description>When a permission name like "write" is passed into AclPermissionEvaluator.resolvePermission method, it first tries to resolve it as is. If not, it then calls permString.toUpperCase() and tries so. However, lowercase "write" is changed into "WRTE" (I with dotted above) when system&amp;amp;apos;s default Locale is tr_TR. Hence, it is not resolved among BasePermissions.
Obvious solution is calling permString.toUpperCase() with Locale.US input parameter.</description>
			<version>4.0.0</version>
			<fixedVersion>3.2.7, 4.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.acls.AclPermissionEvaluator.java</file>
			<file type="M">org.springframework.security.acls.AclPermissionEvaluatorTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2493" opendate="2014-02-19 08:11:40" fixdate="2015-07-14 11:37:14" resolution="Complete">
		<buginformation>
			<summary>Javadoc for DefaultLdapAuthoritiesPopulator lists wrong class name &amp; incorrect property</summary>
			<description>http://docs.spring.io/spring-security/site/docs/3.2.0.RELEASE/apidocs/org/springframework/security/ldap/userdetails/DefaultLdapAuthoritiesPopulator.html
shows






&amp;lt;bean id="ldapAuthoritiesPopulator"




       class="org.springframework.security.authentication.ldap.populator.DefaultLdapAuthoritiesPopulator"&amp;gt;




   &amp;lt;constructor-arg ref="contextSource"/&amp;gt;




   &amp;lt;constructor-arg value="ou=groups"/&amp;gt;




   &amp;lt;property name="groupRoleAttribute" value="ou"/&amp;gt;




 &amp;lt;!-- the following properties are shown with their default values --&amp;gt;




   &amp;lt;property name="searchSubTree" value="false"/&amp;gt;




   &amp;lt;property name="rolePrefix" value="ROLE_"/&amp;gt;




   &amp;lt;property name="convertToUpperCase" value="true"/&amp;gt;




 &amp;lt;/bean&amp;gt;






but should be






&amp;lt;bean id="ldapAuthoritiesPopulator"




       class="org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator"&amp;gt;




   &amp;lt;constructor-arg ref="contextSource"/&amp;gt;




   &amp;lt;constructor-arg value="ou=groups"/&amp;gt;




   &amp;lt;property name="groupRoleAttribute" value="ou"/&amp;gt;




 &amp;lt;!-- the following properties are shown with their default values --&amp;gt;




   &amp;lt;property name="searchSubTree" value="false"/&amp;gt;




   &amp;lt;property name="rolePrefix" value="ROLE_"/&amp;gt;




   &amp;lt;property name="convertToUpperCase" value="true"/&amp;gt;




 &amp;lt;/bean&amp;gt;






</description>
			<version>3.2.0</version>
			<fixedVersion>3.2.8, 4.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator.java</file>
		</fixedFiles>
	</bug>
	<bug id="2931" opendate="2015-04-07 01:13:20" fixdate="2015-07-14 11:42:10" resolution="Complete">
		<buginformation>
			<summary>CsrfFilter JavaDoc incomplete and session less token repository appreciated </summary>
			<description>The Java Doc for CsrfFilter says:
Typically the CsrfTokenRepository implementation chooses to store the CsrfToken in HttpSession with HttpSessionCsrfTokenRepository. This is preferred to storing the token in a cookie which. "
That last part does not look like a sentence .
It would also be great to have a CsrfTokenRepository implementation not based on a servlet container session to allow for stateless web apps. </description>
			<version>4.0.1</version>
			<fixedVersion>3.2.8, 4.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.csrf.CsrfFilter.java</file>
		</fixedFiles>
	</bug>
	<bug id="2973" opendate="2015-05-11 18:40:40" fixdate="2015-07-14 13:12:42" resolution="Complete">
		<buginformation>
			<summary>SecurityContext should be persisted when the response body reaches the content length</summary>
			<description>I was struggling with the same kind of issue that was fixed by SEC-2005
in my app, i have a specialized SecurityContextRepository that is load/saving some extra information related to the context into a cookie
Everything works fine, the loading and the saving methods are called nicely, except that for the saving the call was happening long after the commit of the response (so&amp;amp;apos; don&amp;amp;apos;t reach the client).
Then, I have tried to trace down the problem and figured out that the internal private class SaveContextPrintWriter in SaveContextOnUpdateOrErrorResponseWrapper.java sounds to be the cause of the problem
This internal class is using a delegation pattern to allow to save the context when intentionally flushing or closing the PrintWriter from the caller. 
(flush or close are causing the commit of the response)
The problem is that the PrintWriter might also call internally its flush method when you are writing in it and there is a long buffer pending. This internal call cannot be intercepted by the delegation pattern. As it is out of the control, the only way to enforce a context save is to add an explicit call to doSaveContext() on every  write*, print*, format*, append* of the internal private class SaveContextPrintWriter, before calling the delegated method  
by the way, the append methods must also be changed to return this (and not the delegated writer). It helps to keep the wrapped PrintWriter if the caller is doing thing like
new SaveContextPrintWriter(response.getPrintWriter).append("111").append("222").flush();
finally, what is applicable for SaveContextPrintWriter must also be applied to SaveContextServletOutputStream = every write method must fist call the doSaveContext()
example of change 






    public PrintWriter append(CharSequence csq) {




            doSaveContext();




            delegate.append(csq);




            return this;




        }






</description>
			<version>3.2.2</version>
			<fixedVersion>3.2.8, 4.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.SaveContextOnUpdateOrErrorResponseWrapper.java</file>
		</fixedFiles>
	</bug>
	<bug id="3019" opendate="2015-06-25 11:54:24" fixdate="2015-07-16 09:13:46" resolution="Complete">
		<buginformation>
			<summary>BasicAuthenticationFilter ignores remember-me authentication</summary>
			<description>Repro:

Configure an application to use httpBasic auth and rememberMe authentication.
Notice that no remember-me cookie is set by the server, even on a successful authentication

Problem: the RememberMeServices and other related configuration set up by the rememberMe() configurer is never propagated to the BasicAuthenticationFilter&amp;amp;apos;s setRememberMeServices method. BasicAuthenticationFilter retains it&amp;amp;apos;s default NullRememberMeServices instance assigned at construction time, which means that all remember-me operations are a no-op.
Workaround:

Here is a gist of the changes that were necessary to propagate the remember me configuration through to the BasicAuthenticationFilter using a Spring Security ObjectPostProcessor: https://gist.github.com/cbeams/f3c36caae7046b03609a. (Note that it was also attempted to use a BeanPostProcessor, but this caused lifecycle issues due to dependence on other Spring beans.)

With this configuration in place, everything works as expected for remember-me authentication.
Documentation:

If and when this issue is fixed, i.e. BasicAuthenticationFilter begins to respect rememberMe settings, the first sentence of this section of the Spring Security documentation should be removed: http://docs.spring.io/spring-security/site/docs/4.0.1.RELEASE/reference/htmlsingle/#remember-me-impls

</description>
			<version>4.0.1</version>
			<fixedVersion>3.2.8, 4.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.HttpBasicConfigurer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2990" opendate="2015-05-28 21:11:54" fixdate="2015-07-16 09:18:42" resolution="Duplicate">
		<buginformation>
			<summary>Fix SecurityNamespaceHandler exception message</summary>
			<description>Migrating an application from Spring Security 3.2.x to 4.0.x raised this exception:
      org.springframework.beans.factory.parsing.BeanDefinitionParsingException:
      Configuration problem: You cannot use a spring-security-2.0.xsd or
      spring-security-3.0.xsd or spring-security-3.1.xsd schema with
      Spring Security 3.2. Please update your schema declarations to the
      3.2 schema.  Offending resource: ServletContext resource
[/WEB-INF/applicationContext-security.xml]
It appears that the exception message in config/src/main/java/org/springframework/security/config/SecurityNamespaceHandler.java needs to be updated.</description>
			<version>4.0.1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.SecurityNamespaceHandler.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2948</link>
			<link type="Duplicate" description="is duplicated by">3010</link>
		</links>
	</bug>
	<bug id="3020" opendate="2015-06-26 08:22:36" fixdate="2015-07-16 12:34:02" resolution="Complete">
		<buginformation>
			<summary>HttpServletRequest.isUserInRole("ROLE_&lt;anything&gt;") returns false with defaults</summary>
			<description>I&amp;amp;apos;m just trying to upgrade from Spring Security 3.1 to 4.0.1 and have discovered a breaking change in the behaviour of request.isUserInRole().
In Spring 3.1 the following was returning true and now returns false:
request.isUserInRole("ROLE_REMEMBER_ME")
In Spring 4.0.1 I had to change it to the following:
request.isUserInRole("REMEMBER_ME")</description>
			<version>4.0.1</version>
			<fixedVersion>4.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestWrapperTests.java</file>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestWrapper.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">3035</link>
			<link type="Duplicate" description="is duplicated by">3055</link>
			<link type="Relate" description="relates to">2926</link>
		</links>
	</bug>
	<bug id="3045" opendate="2015-07-17 12:48:38" fixdate="2015-07-17 13:44:29" resolution="Complete">
		<buginformation>
			<summary>EnableGlobalMethodSecurity mode=ASPECTJ creates proxies if InfrastructureAdvisorAutoProxyCreator is Added</summary>
			<description>If InfrastructureAdvisorAutoProxyCreator exists, then Spring Security will create proxies for security related classes when @EnableGlobalMethodSecurity(mode=ASPECTJ, ....
This is due to the fact that GlobalMethodSecurityConfiguration creates a MethodSecurityMetadataSourceAdvisor.
Instead we should conditionally create MethodSecurityMetadataSourceAdvisor in an ImportBeanDefintionRegistrar only when using proxies for Spring Security.</description>
			<version>3.2.7</version>
			<fixedVersion>4.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.method.configuration.GlobalMethodSecurityConfiguration.java</file>
			<file type="M">org.springframework.security.config.annotation.method.configuration.GlobalMethodSecuritySelector.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">2595</link>
			<link type="Relate" description="relates to">3005</link>
			<link type="Relate" description="relates to">2698</link>
			<link type="Supersede" description="supersedes">3005</link>
		</links>
	</bug>
	<bug id="2964" opendate="2015-05-06 07:11:39" fixdate="2015-07-22 09:33:31" resolution="Complete">
		<buginformation>
			<summary>CsrfTokenArgumentResolver has improperly formatted javadoc</summary>
			<description>CsrfTokenArgumentResolver has broken javadoc, see http://docs.spring.io/spring-security/site/docs/4.0.1.RELEASE/apidocs/org/springframework/security/web/method/annotation/CsrfTokenArgumentResolver.html
The source code snippet of RestController is missing.</description>
			<version>4.0.1</version>
			<fixedVersion>4.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.method.annotation.CsrfTokenArgumentResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="3055" opendate="2015-07-25 00:43:22" fixdate="2015-07-25 06:36:07" resolution="Duplicate">
		<buginformation>
			<summary>request.isUserInRole add an extra "ROLE_"</summary>
			<description>When calling the request.isUserInRole, the underling class: SecurityContextHolderAwareRequestWrapper:isGranted adds an extra "ROLE_" prefix so calling the request.isUserInRole("ROLE_TEST"); will cause too : ROLE_ROLE_TEST.
</description>
			<version>4.0.1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestWrapperTests.java</file>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestWrapper.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">3020</link>
		</links>
	</bug>
	<bug id="3056" opendate="2015-07-28 01:18:36" fixdate="2015-08-03 10:30:19" resolution="Complete">
		<buginformation>
			<summary>Fix JavaDoc errors for JDK8</summary>
			<description>Due to more strict javadoc checks in Java 8 one currently cannot build spring-security with javadoc via a plain ./gradlew install as a fallback one has to skip javadoc generation ./gradlew install -x javadoc.
Since the JavaDoc errors are all within BCrypt.java it should be very easy to fix.
With those javadoc tags fixed one can build the spring-security with Java 8 without any problems.






D:\dev\repos\spring\spring-security\crypto\src\main\java\org\springframework\security\crypto\bcrypt\BCrypt.java:34: error: self-closing element not allowed




 * String pw_hash = BCrypt.hashpw(plain_password, BCrypt.gensalt()); &amp;lt;br /&amp;gt;




                                                                     ^




D:\dev\repos\spring\spring-security\crypto\src\main\java\org\springframework\security\crypto\bcrypt\BCrypt.java:41: error: self-closing element not allowed




 * if (BCrypt.checkpw(candidate_password, stored_hash))&amp;lt;br /&amp;gt;




                                                       ^




D:\dev\repos\spring\spring-security\crypto\src\main\java\org\springframework\security\crypto\bcrypt\BCrypt.java:42: error: self-closing element not allowed




 * &amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;System.out.println("It matches");&amp;lt;br /&amp;gt;




                                                            ^




D:\dev\repos\spring\spring-security\crypto\src\main\java\org\springframework\security\crypto\bcrypt\BCrypt.java:43: error: self-closing element not allowed




 * else&amp;lt;br /&amp;gt;




       ^




D:\dev\repos\spring\spring-security\crypto\src\main\java\org\springframework\security\crypto\bcrypt\BCrypt.java:44: error: self-closing element not allowed




 * &amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;System.out.println("It does not match");&amp;lt;br /&amp;gt;




                                                                   ^




D:\dev\repos\spring\spring-security\crypto\src\main\java\org\springframework\security\crypto\bcrypt\BCrypt.java:51: error: self-closing element not allowed




 * String strong_salt = BCrypt.gensalt(10)&amp;lt;br /&amp;gt;




                                          ^




D:\dev\repos\spring\spring-security\crypto\src\main\java\org\springframework\security\crypto\bcrypt\BCrypt.java:52: error: self-closing element not allowed




 * String stronger_salt = BCrypt.gensalt(12)&amp;lt;br /&amp;gt;





</description>
			<version>3.2.9</version>
			<fixedVersion>4.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.expression.SecurityExpressionOperations.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.HeadersConfigurer.java</file>
			<file type="M">org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource.java</file>
			<file type="M">org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter.java</file>
			<file type="M">org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl.java</file>
			<file type="M">org.springframework.security.messaging.util.matcher.SimpDestinationMessageMatcher.java</file>
			<file type="M">org.springframework.security.web.authentication.session.RegisterSessionAuthenticationStrategy.java</file>
			<file type="M">org.springframework.security.ldap.userdetails.DefaultLdapAuthoritiesPopulator.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.FormLoginConfigurer.java</file>
			<file type="M">org.springframework.security.access.vote.AbstractAccessDecisionManager.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.ExceptionHandlingConfigurer.java</file>
			<file type="M">org.springframework.security.core.token.TokenService.java</file>
			<file type="M">org.springframework.security.messaging.access.expression.ExpressionBasedMessageSecurityMetadataSourceFactory.java</file>
			<file type="M">org.springframework.security.config.annotation.authentication.ProviderManagerBuilder.java</file>
			<file type="M">org.springframework.security.core.session.SessionRegistryImpl.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.LogoutConfigurer.java</file>
			<file type="M">org.springframework.security.web.authentication.switchuser.SwitchUserFilter.java</file>
			<file type="M">org.springframework.security.web.header.writers.XXssProtectionHeaderWriter.java</file>
			<file type="M">org.springframework.security.messaging.access.intercept.ChannelSecurityInterceptor.java</file>
			<file type="M">org.springframework.security.config.annotation.web.HttpSecurityBuilder.java</file>
			<file type="M">org.springframework.security.web.util.ThrowableAnalyzer.java</file>
			<file type="M">org.springframework.security.test.web.support.WebTestUtils.java</file>
			<file type="M">org.springframework.security.config.annotation.authentication.configurers.userdetails.UserDetailsServiceConfigurer.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.AbstractAuthenticationFilterConfigurer.java</file>
			<file type="M">org.springframework.security.config.annotation.web.messaging.MessageSecurityMetadataSourceRegistry.java</file>
			<file type="M">org.springframework.security.concurrent.DelegatingSecurityContextRunnable.java</file>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.java</file>
			<file type="M">org.springframework.security.ldap.userdetails.NestedLdapAuthoritiesPopulator.java</file>
			<file type="M">org.springframework.security.openid.OpenIDAuthenticationFilter.java</file>
			<file type="M">org.springframework.security.web.header.writers.frameoptions.RegExpAllowFromStrategy.java</file>
			<file type="M">org.springframework.security.ldap.search.LdapUserSearch.java</file>
			<file type="M">org.springframework.security.web.method.annotation.AuthenticationPrincipalArgumentResolver.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.AbstractInterceptUrlConfigurer.java</file>
			<file type="M">org.springframework.security.core.parameters.AnnotationParameterNameDiscoverer.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.JeeConfigurer.java</file>
			<file type="M">org.springframework.security.ldap.DefaultSpringSecurityContextSource.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.HttpBasicConfigurer.java</file>
			<file type="M">org.springframework.security.remoting.dns.DnsResolver.java</file>
			<file type="M">org.springframework.security.access.intercept.package-info.java</file>
			<file type="M">org.springframework.security.web.csrf.InvalidCsrfTokenException.java</file>
			<file type="M">org.springframework.security.authentication.encoding.ShaPasswordEncoder.java</file>
			<file type="M">org.springframework.security.core.token.KeyBasedPersistenceTokenService.java</file>
			<file type="M">org.springframework.security.config.annotation.authentication.configurers.provisioning.JdbcUserDetailsManagerConfigurer.java</file>
			<file type="M">org.springframework.security.access.hierarchicalroles.RoleHierarchy.java</file>
			<file type="M">org.springframework.security.web.FilterChainProxy.java</file>
			<file type="M">org.springframework.security.config.annotation.web.builders.HttpSecurity.java</file>
			<file type="M">org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler.java</file>
			<file type="M">org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy.java</file>
			<file type="M">org.springframework.security.acls.AclEntryVoter.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.openid.OpenIDLoginConfigurer.java</file>
			<file type="M">org.springframework.security.web.bind.support.AuthenticationPrincipalArgumentResolver.java</file>
			<file type="M">org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AbstractAuthorizeTag.java</file>
			<file type="M">org.springframework.security.messaging.context.AuthenticationPrincipalArgumentResolver.java</file>
			<file type="M">org.springframework.security.core.annotation.AuthenticationPrincipal.java</file>
			<file type="M">org.springframework.security.data.repository.query.SecurityEvaluationContextExtension.java</file>
			<file type="M">org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter.java</file>
			<file type="M">org.springframework.security.task.DelegatingSecurityContextTaskExecutor.java</file>
			<file type="M">org.springframework.security.web.PortMapperImpl.java</file>
			<file type="M">org.springframework.security.web.authentication.session.ChangeSessionIdAuthenticationStrategy.java</file>
			<file type="M">org.springframework.security.core.userdetails.memory.UserAttribute.java</file>
			<file type="M">org.springframework.security.config.annotation.authentication.configurers.provisioning.UserDetailsManagerConfigurer.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer.java</file>
			<file type="M">org.springframework.security.config.authentication.PasswordEncoderParser.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration.java</file>
			<file type="M">org.springframework.security.web.savedrequest.SavedRequestAwareWrapper.java</file>
			<file type="M">org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler.java</file>
			<file type="M">org.springframework.security.web.access.channel.ChannelProcessingFilter.java</file>
			<file type="M">org.springframework.security.crypto.bcrypt.BCrypt.java</file>
			<file type="M">org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.java</file>
			<file type="M">org.springframework.security.samples.servletapi.mvc.ServletApiController.java</file>
			<file type="M">org.springframework.security.concurrent.DelegatingSecurityContextExecutorService.java</file>
			<file type="M">org.springframework.security.config.annotation.authentication.configurers.provisioning.InMemoryUserDetailsManagerConfigurer.java</file>
			<file type="M">org.springframework.security.concurrent.DelegatingSecurityContextScheduledExecutorService.java</file>
			<file type="M">org.springframework.security.authentication.jaas.AbstractJaasAuthenticationProvider.java</file>
			<file type="M">org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl.java</file>
			<file type="M">org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder.java</file>
			<file type="M">org.springframework.security.web.access.expression.DefaultWebSecurityExpressionHandler.java</file>
			<file type="M">org.springframework.security.config.annotation.SecurityConfigurerAdapter.java</file>
			<file type="M">org.springframework.security.config.annotation.web.servlet.configuration.WebMvcSecurityConfiguration.java</file>
			<file type="M">org.springframework.security.test.context.support.WithUserDetails.java</file>
			<file type="M">org.springframework.security.authentication.jaas.JaasAuthenticationProvider.java</file>
			<file type="M">org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer.java</file>
		</fixedFiles>
	</bug>
	<bug id="3073" opendate="2015-08-18 09:47:26" fixdate="2015-08-18 09:58:33" resolution="Duplicate">
		<buginformation>
			<summary>JSPAuthorizeTag authorizeUsingUrlCheck only compares against first WebInvocationPrivilegeEvaluator</summary>
			<description>In AbstractAuthorizeTag, authorizeUsingUrlCheck calls getPrivilegeEvaluator which on line 347 returns the first WebInvocationPrivilegeEvaluator ignoring others. 
An application might have multiple WebInvocationPrivilegeEvaluators for instance if there is one &amp;lt;http&amp;gt; config for the main ui of the application and one for a built in REST service. 
Example REST &amp;lt;http&amp;gt; config:
 &amp;lt;http pattern="/api/**" create-session="stateless" use-expressions="true"&amp;gt;
    	&amp;lt;intercept-url pattern="/api/**" access="hasRole(&amp;amp;apos;ROLE_REST&amp;amp;apos;)"/&amp;gt;
    	&amp;lt;http-basic/&amp;gt;
    &amp;lt;/http&amp;gt; 
Thus a JSP authorize url check such as:
&amp;lt;sec:authorize url="/secureAction"&amp;gt;
will only be evaluated against the first &amp;lt;http&amp;gt; config.
In some cases, such as when the main &amp;lt;http&amp;gt; config contains a catchall (&amp;lt;intercept-url pattern="/**" access="isAuthenticated()" /&amp;gt;), the order of the &amp;lt;http&amp;gt; configs can not be changed yielding no way to conduct url evaluations.
It seems like all WebInvocationPrivilegeEvaluators should be considered.</description>
			<version>3.2.8</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.WebAttributes.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AbstractAuthorizeTag.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilterTests.java</file>
			<file type="M">org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2045</link>
		</links>
	</bug>
	<bug id="2956" opendate="2015-04-30 15:59:07" fixdate="2015-08-19 14:08:02" resolution="Complete">
		<buginformation>
			<summary>Improve AnnotationParameterNameDiscoverer Performance</summary>
			<description>Hi
After profiling (well sampling) my code I have noticed that AnnotationParameterNameDiscoverer taking up a large portion of time is taken up by 





AnnotationParameterNameDiscoverer.ParameterNameFactory.findAnnotationsAt()






For 10k requests which takes 24seconds, about 5.7 seconds was spent in that method 
Here is an example of a method that will take a long time to run






@RequestMapping(value = "/c/{c}/bar", method = RequestMethod.PUT, params = {"!redirectTarget"})




  @PreAuthorize("hasPermission(#c, &amp;amp;apos;c&amp;amp;apos;) and hasRole(&amp;amp;apos;sec.awsome&amp;amp;apos;)")




  public Response something(




      @PathVariable String c,




      @RequestParam("k") String k,




      @RequestBody byte[] content,




      @RequestParam(value="f", required=false) String f,




      @RequestHeader(value="Content-Type", required=false, defaultValue="application/octet-stream") String mimeType,




      @RequestHeader(required=false) Map&amp;lt;String, String&amp;gt; headers




      ) throws Exception {




         //do almost nothing.




      }






while here is an example of something that runs quickly.






    @RequestMapping(value = "/c/{c}/s", method = RequestMethod.GET)




    @PreAuthorize("hasPermission(#c, &amp;amp;apos;c&amp;amp;apos;) and hasRole(&amp;amp;apos;sec.can.dance&amp;amp;apos;)")




    public AnnotatedStateResponse getState(




        @PathVariable String collection) throws Exception {




        //not much stuff




    }






That takes considerably less time and almost not time (less than a second ) is spent in that findAnnotationsAt method.
Looking at the code I realise what the problem is I will guid you though it now:






    private static final ParameterNameFactory&amp;lt;Method&amp;gt; METHOD_METHODPARAM_FACTORY = new ParameterNameFactory&amp;lt;Method&amp;gt;() {




       .......




        public Annotation[] findAnnotationsAt(Method method, int index) {




            //THIS TAKES A LONG TIME AND IS CALLED MANY TIMES!




            return method.getParameterAnnotations()[index];




        }




    };






Now the part that calls it:






/**




     * Gets the parameter names or null if not found.




     *




     * @param parameterNameFactory the {@link ParameterNameFactory} to use




     * @param t the {@link AccessibleObject} to find the parameter names on (i.e. Method or Constructor)




     * @return the parameter names or null




     */




    private &amp;lt;T extends AccessibleObject&amp;gt; String[] lookupParameterNames(




            ParameterNameFactory&amp;lt;T&amp;gt; parameterNameFactory, T t) {




        int parameterCount = parameterNameFactory.getParamCount(t);




        String[] paramNames = new String[parameterCount];




        boolean found = false;




        for (int i = 0; i &amp;lt; parameterCount; i++) {




            //HERE is the part of the problem!




            Annotation[] annotations = parameterNameFactory.findAnnotationsAt(t, i);




            String parameterName = findParameterName(annotations);




            if (parameterName != null) {




                found = true;




                paramNames[i] = parameterName;




            }




        }




        return found ? paramNames : null;




    }






the problem is if we have say 6 parameters we will call 





findAnnotationsAt(t, i)





 6 times, each time it calls that it will use reflection to get the annotations on the methods 





method.getParameterAnnotations()





. Of course the more methods the more costly 





method.getParameterAnnotations()





 is.
Lets look at it in big O notations. If 





method.getParameterAnnotations()





 costs the number of parameters lets call that n, the complexity is:
O(n*n)
I would recommend that we avoid calling 





method.getParameterAnnotations()





 multiple times.
I think we should also consider caching the result of 





method.getParameterAnnotations()





</description>
			<version>3.2.4</version>
			<fixedVersion>4.1.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.core.parameters.AnnotationParameterNameDiscoverer.java</file>
		</fixedFiles>
	</bug>
	<bug id="2709" opendate="2014-08-24 09:04:53" fixdate="2015-08-20 08:41:39" resolution="Complete">
		<buginformation>
			<summary>WithSecurityContextTestExecutionListener should override getOrder() instead of using @Order</summary>
			<description>WithSecurityContextTestExecutionListener currently declares @Order; however, since AbstractTestExecutionListener implements Ordered, providing a default value of Ordered.LOWEST_PRECEDENCE for getOrder(), WithSecurityContextTestExecutionListener&amp;amp;apos;s @Order declaration will be ignored by the AnnotationAwareOrderComparator.
Thus, WithSecurityContextTestExecutionListener should override getOrder() with an appropriate value in order to ensure proper ordering within the set of all default TestExecutionListeners.</description>
			<version>4.0.0.M2</version>
			<fixedVersion>4.1.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.test.context.support.WithSecurityContextTestExecutionListener.java</file>
		</fixedFiles>
	</bug>
	<bug id="2757" opendate="2014-10-30 03:30:03" fixdate="2015-10-01 21:18:50" resolution="Complete">
		<buginformation>
			<summary>AD attribute &amp;apos;sn&amp;apos; required when creating LdapUserDetails</summary>
			<description>Does &amp;amp;apos;sn&amp;amp;apos; need to be required when creating LdapUserDetails?
We have a few test users in Active Directory that does not have this attribute set. When those users try to login, it fails on this method in Person.java:






Person.java






public LdapUserDetails createUserDetails() {




    Person p = (Person) super.createUserDetails();




    Assert.hasLength(p.sn);




    Assert.notNull(p.cn);




    Assert.notEmpty(p.cn);




    // TODO: Check contents for null entries




    return p;




}






https://github.com/spring-projects/spring-security/blob/master/ldap/src/main/java/org/springframework/security/ldap/userdetails/Person.java#L129
It is this line that is causing us problem:






Assert.hasLength(p.sn);






There might be a good reason that &amp;amp;apos;sn&amp;amp;apos; is required that I&amp;amp;apos;m not aware of, but if not it would be great if this assert could be removed.
This is the stacktrace we get. We&amp;amp;apos;re using spring-security-ldap indirectly through Grails spring-security-ldap plugin (v2.0-RC2):






2014-10-29 15:17.02,875 [ajp-nio-8021-exec-3] ERROR StackTrace - Full Stack Trace:java.lang.IllegalArgumentException: [Assertion failed] - this String argument must have length; it must not be null or empty




        at org.springframework.util.Assert.hasLength(Assert.java:136)




        at org.springframework.util.Assert.hasLength(Assert.java:148)




        at org.springframework.security.ldap.userdetails.Person$Essence.createUserDetails(Person.java:129)




        at org.springframework.security.ldap.userdetails.InetOrgPersonContextMapper.mapUserFromContext(InetOrgPersonContextMapper.java:37)




        at org.springframework.security.ldap.authentication.AbstractLdapAuthenticationProvider.authenticate(AbstractLdapAuthenticationProvider.java:63)




        at org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:156)




        at org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.attemptAuthentication(UsernamePasswordAuthenticationFilter.java:94)




        at grails.plugin.springsecurity.web.authentication.RequestHolderAuthenticationFilter.attemptAuthentication(RequestHolderAuthenticationFilter.java:76)




        at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:211)




        at grails.plugin.springsecurity.web.authentication.RequestHolderAuthenticationFilter.doFilter(RequestHolderAuthenticationFilter.java:49)




        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




        at grails.plugin.springsecurity.web.authentication.logout.MutableLogoutFilter.doFilter(MutableLogoutFilter.java:82)




        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




        at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87)




        at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




        at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192)




        at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160)




        at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:344)




        at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:261)




        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)




        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)




        at org.codehaus.groovy.grails.web.servlet.mvc.GrailsWebRequestFilter.doFilterInternal(GrailsWebRequestFilter.java:69)




        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)




        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)




        at org.codehaus.groovy.grails.web.filters.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:67)




        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)




        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)




        at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88)




        at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




        at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:344)




        at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:261)




        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239)




        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)




        at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:219)




        at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106)




        at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:142)




        at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79)




        at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:610)




        at org.apache.catalina.valves.RemoteIpValve.invoke(RemoteIpValve.java:676)




        at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88)




        at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:537)




        at org.apache.coyote.ajp.AbstractAjpProcessor.process(AbstractAjpProcessor.java:827)




        at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:658)




        at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1566)




        at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1523)




        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)




        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)




        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)




        at java.lang.Thread.run(Thread.java:745)2014-10-29 15:17.02,928 [ajp-nio-8021-exec-3] ERROR StackTrace - Full Stack Trace:java.lang.IllegalArgumentException: [Assertion failed] - this String argument must have length; it must not be null or empty




        at grails.plugin.springsecurity.web.authentication.RequestHolderAuthenticationFilter.attemptAuthentication(RequestHolderAuthenticationFilter.java:76)




        at grails.plugin.springsecurity.web.authentication.RequestHolderAuthenticationFilter.doFilter(RequestHolderAuthenticationFilter.java:49)




        at grails.plugin.springsecurity.web.authentication.logout.MutableLogoutFilter.doFilter(MutableLogoutFilter.java:82)




        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)




        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)




        at java.lang.Thread.run(Thread.java:745)





</description>
			<version>4.0.0.M2</version>
			<fixedVersion>4.1.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.ldap.userdetails.Person.java</file>
		</fixedFiles>
	</bug>
	<bug id="3122" opendate="2015-10-08 14:00:10" fixdate="2015-10-08 15:38:43" resolution="Duplicate">
		<buginformation>
			<summary>DelegatingSecurityContextScheduledExecutorService only sets SecurityContext at first run of a scheduled task - subsequent runs do not have the SecurityContext set</summary>
			<description>When using DelegatingSecurityContextScheduledExecutorService to set a security context for a scheduled task, it works perfectly fine for the first task execution, but subsequent executions are (re-)scheduled by the same thread which was used to execute the task for the first time - this is done in ReschedulingRunnable.run()
Thread.currentThread() is used to set the originalThread variable in DelegatingSecurityContextRunnable - therefore DelegatingSecurityContextRunnable thinks it&amp;amp;apos;s being executed in the original thread and does skip the set security context.
This means originalThread variable (in DelegatingSecurityContextRunnable) does contain the wrong value for all executions except the first one. Therefore all subsequent executions do fail because no security context is set ...






@Scheduled(cron="*/30 * * * * *", zone="UTC")




	public void myScheduledTask() {




//call to secured method




}









@Override




    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {




        taskRegistrar.setScheduler(taskExecutor());




    }




 




    public Executor taskExecutor() {




        ScheduledExecutorService delegateExecutor = Executors.newSingleThreadScheduledExecutor();




        SecurityContext schedulerContext = createSchedulerSecurityContext();




        return new DelegatingSecurityContextScheduledExecutorService(delegateExecutor, schedulerContext);




    }




 




    private SecurityContext createSchedulerSecurityContext() {




        SecurityContext context = SecurityContextHolder.createEmptyContext();




 




        Collection&amp;lt;GrantedAuthority&amp;gt; authorities = AuthorityUtils.createAuthorityList("ROLE_USER");




        Authentication authentication = new UsernamePasswordAuthenticationToken(




                "user",




                "user",




                authorities




        );




        context.setAuthentication(authentication);




 




        return context;




    }





</description>
			<version>4.0.2</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilterTests.java</file>
			<file type="M">org.springframework.security.concurrent.DelegatingSecurityContextCallableTests.java</file>
			<file type="M">org.springframework.security.concurrent.DelegatingSecurityContextRunnable.java</file>
			<file type="M">org.springframework.security.concurrent.DelegatingSecurityContextRunnableTests.java</file>
			<file type="M">org.springframework.security.concurrent.DelegatingSecurityContextCallable.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">3109</link>
		</links>
	</bug>
	<bug id="2941" opendate="2015-04-22 13:59:41" fixdate="2015-10-21 21:11:11" resolution="Complete">
		<buginformation>
			<summary>Default RequestPostProcessor overrides additional DefaultRequestPostProcessor</summary>
			<description>Spring Security&amp;amp;apos;s Default RequestPostProcessor implementations override additional RequestPostProcessor implementations.
For example the following fails:






mvc = MockMvcBuilders.webAppContextSetup(context)




		.apply(springSecurity())




		.defaultRequest(get("/").with(user("default")))




		.build();









mvc




	.perform(get("/admin/abc").with(user("user1").roles("ADMIN","USER")))




	.andExpect(status().isNotFound())




	.andExpect(authenticated().withUsername("user1"));









mvc




	.perform(get("/admin/abc"))




	.andExpect(status().isForbidden())




	.andExpect(authenticated().withUsername("default"));





</description>
			<version>4.0.0</version>
			<fixedVersion>4.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.test.web.servlet.request.Sec2935Tests.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">12945</link>
			<link type="Relate" description="relates to">2935</link>
		</links>
	</bug>
	<bug id="3132" opendate="2015-10-23 15:24:42" fixdate="2015-10-23 17:53:21" resolution="Complete">
		<buginformation>
			<summary>securityBuilder cannot be null</summary>
			<description>If a custom SecurityConfigurerAdapter tries to apply additional SecurityConfigurerAdapter, then it will cause the following error






org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;springSecurityFilterChain&amp;amp;apos; defined in class org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [javax.servlet.Filter]: Factory method &amp;amp;apos;springSecurityFilterChain&amp;amp;apos; threw exception; nested exception is java.lang.IllegalStateException: securityBuilder cannot be null




	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:599)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1123)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1018)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:510)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482)




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:305)




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:301)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:196)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:295)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:196)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:772)




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:834)




	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:537)




	at org.springframework.context.annotation.AnnotationConfigApplicationContext.&amp;lt;init&amp;gt;(AnnotationConfigApplicationContext.java:84)




	at org.springframework.security.config.http.customconfigurer.CustomHttpSecurityConfigurerTests.loadContext(CustomHttpSecurityConfigurerTests.java:114)




	at org.springframework.security.config.http.customconfigurer.CustomHttpSecurityConfigurerTests.customConfiguerPermitAll(CustomHttpSecurityConfigurerTests.java:73)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:497)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)




	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)




	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)




	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)




	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)




	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)




Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [javax.servlet.Filter]: Factory method &amp;amp;apos;springSecurityFilterChain&amp;amp;apos; threw exception; nested exception is java.lang.IllegalStateException: securityBuilder cannot be null




	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:189)




	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:588)




	... 41 more




Caused by: java.lang.IllegalStateException: securityBuilder cannot be null




	at org.springframework.security.config.annotation.SecurityConfigurerAdapter.getBuilder(SecurityConfigurerAdapter.java:65)




	at org.springframework.security.config.annotation.web.configurers.AbstractAuthenticationFilterConfigurer.updateAuthenticationDefaults(AbstractAuthenticationFilterConfigurer.java:360)




	at org.springframework.security.config.annotation.web.configurers.AbstractAuthenticationFilterConfigurer.init(AbstractAuthenticationFilterConfigurer.java:226)




	at org.springframework.security.config.annotation.web.configurers.FormLoginConfigurer.init(FormLoginConfigurer.java:211)




	at org.springframework.security.config.annotation.web.configurers.AbstractAuthenticationFilterConfigurer.init(AbstractAuthenticationFilterConfigurer.java:1)




	at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.add(AbstractConfiguredSecurityBuilder.java:206)




	at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.apply(AbstractConfiguredSecurityBuilder.java:130)




	at org.springframework.security.config.annotation.web.builders.HttpSecurity.getOrApply(HttpSecurity.java:1191)




	at org.springframework.security.config.annotation.web.builders.HttpSecurity.formLogin(HttpSecurity.java:836)




	at org.springframework.security.config.http.customconfigurer.CustomConfigurer.init(CustomConfigurer.java:54)




	at org.springframework.security.config.http.customconfigurer.CustomConfigurer.init(CustomConfigurer.java:1)




	at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.init(AbstractConfiguredSecurityBuilder.java:371)




	at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.doBuild(AbstractConfiguredSecurityBuilder.java:325)




	at org.springframework.security.config.annotation.AbstractSecurityBuilder.build(AbstractSecurityBuilder.java:41)




	at org.springframework.security.config.annotation.web.builders.WebSecurity.performBuild(WebSecurity.java:287)




	at org.springframework.security.config.annotation.web.builders.WebSecurity.performBuild(WebSecurity.java:1)




	at org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.doBuild(AbstractConfiguredSecurityBuilder.java:334)




	at org.springframework.security.config.annotation.AbstractSecurityBuilder.build(AbstractSecurityBuilder.java:41)




	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration.springSecurityFilterChain(WebSecurityConfiguration.java:105)




	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerBySpringCGLIB$$d1e9db75.CGLIB$springSecurityFilterChain$6(&amp;lt;generated&amp;gt;)




	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerBySpringCGLIB$$d1e9db75$$FastClassBySpringCGLIB$$325a4508.invoke(&amp;lt;generated&amp;gt;)




	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228)




	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:318)




	at org.springframework.security.config.annotation.web.configuration.WebSecurityConfiguration$$EnhancerBySpringCGLIB$$d1e9db75.springSecurityFilterChain(&amp;lt;generated&amp;gt;)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:497)




	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162)




	... 42 more















</description>
			<version>3.2.8</version>
			<fixedVersion>3.2.9, 4.0.3, 4.1.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.AbstractConfiguredSecurityBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="3109" opendate="2015-09-18 14:19:14" fixdate="2015-10-26 22:27:19" resolution="Fixed">
		<buginformation>
			<summary>Concurrent/ThreadPoolTaskScheduler don&amp;apos;t work with DelegatingSecurityContextExecutor</summary>
			<description>We have a setup with Spring Boot with scheduling. To use method security with background jobs we want to use the DelegatingSecurityContextScheduledExecutorService like described here: http://www.petrikainulainen.net/programming/spring-framework/spring-from-the-trenches-invoking-a-secured-method-from-a-scheduled-job/ (see "Spring Security 3.2: It Is Almost Like Magic!").
I suspect this stopped working with SEC-3031, because now DelegatingSecurityContextRunnable/Callable doesn&amp;amp;apos;t set/clear the security context if run on the same thread as they were created.
As Concurrent/TheadPoolTaskScheduler uses a ReschedulingRunnable for the trigger mechanic (we use cron triggers), so the rescheduling is done on the pool thread. So random subsequent calls executed on the same pool thread might fail, because the SecurityContext is not set.
Getting DelegatingSecurityContextExecutor to set the enableOnOriginalThread property on DelegatingSecurityContextRunnable to true would fix that issue.</description>
			<version>3.2.8</version>
			<fixedVersion>3.2.9, 4.0.3, 4.1.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilterTests.java</file>
			<file type="M">org.springframework.security.concurrent.DelegatingSecurityContextCallableTests.java</file>
			<file type="M">org.springframework.security.concurrent.DelegatingSecurityContextRunnable.java</file>
			<file type="M">org.springframework.security.concurrent.DelegatingSecurityContextRunnableTests.java</file>
			<file type="M">org.springframework.security.concurrent.DelegatingSecurityContextCallable.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">3122</link>
			<link type="Relate" description="is related to">3031</link>
		</links>
	</bug>
	<bug id="3108" opendate="2015-09-18 08:48:30" fixdate="2015-10-27 19:00:38" resolution="Fixed">
		<buginformation>
			<summary>DigestAuthenticationFilter should use SecurityContextHolder.createEmptyContext()</summary>
			<description>When using Digest authentication and there are concurrent requests from the same session, it is possible that the Authentication object returned by SessionContextHolder.getContext().getAuthentication() does not have its authorities set. Then, e.g. HttpServletRequest.isUserInRole() returns sometimes incorrectly false even if the user actually has that role.
This happens because with Digest authentication, constructing the Authentication object is done in two steps, but the incomplete Authentication object is made visible to another threads after first step.
Consider the following scenario:

User logs in to the system, a session is created, JSESSIONID is set, and user uses the system for some time.
User makes request 1 to the server. This request has a header "Authorization: Digest ..."
DigestAuthenticationFilter starts the authentication process and places an incomplete Authentication object (without authorities) into SecurityContext.
Simultaneously with request 1, the same user makes request 2 to the server. This request does not have "Authorization: Digest ..." header, so no re-authentication is done. While processing request 2, request.isUserInRole() returns now false, because the Authentication object in SecurityContext does not have any authorities. User gets incorrectly a 403 Forbidden response.
Request 1 continues the authentication process, and in AbstractSecurityInterceptor, a fully populated Authentication object is created and put into SecurityContext.

I could set createAuthenticatedToken = true in DigestAuthenticationFilter, but the comment on the set method says that user flags like isEnabled() or isAccountNonExpired() are not checked in that case, so this is not a solution.</description>
			<version>4.0.2</version>
			<fixedVersion>3.2.9, 4.0.3, 4.1.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.authentication.www.DigestAuthenticationFilter.java</file>
			<file type="M">org.springframework.security.web.authentication.www.DigestAuthenticationFilterTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="2190" opendate="2013-07-02 05:02:45" fixdate="2015-10-29 16:31:03" resolution="Complete">
		<buginformation>
			<summary>Support WebApplicationContext in any ServletContext attribute</summary>
			<description>When using the new way of configuring the DispatcherServlet in the web.xml without the ContextLoaderListener (3.2.0 core), the AbstractAuthorizeTag cannot find the configured WebContext because it is not associated with the default contextAttribute WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE.
The SpringSecurityFilterChain solved this problem by adding a contextAttribute init-param.
web.xml :






  &amp;lt;filter&amp;gt;




    &amp;lt;filter-name&amp;gt;springSecurityFilterChain&amp;lt;/filter-name&amp;gt;




    &amp;lt;filter-class&amp;gt;org.springframework.web.filter.DelegatingFilterProxy&amp;lt;/filter-class&amp;gt;




    &amp;lt;init-param&amp;gt;




      &amp;lt;param-name&amp;gt;contextAttribute&amp;lt;/param-name&amp;gt;




      &amp;lt;param-value&amp;gt;org.springframework.web.servlet.FrameworkServlet.CONTEXT.springapp&amp;lt;/param-value&amp;gt;




    &amp;lt;/init-param&amp;gt;




  &amp;lt;/filter&amp;gt;









  &amp;lt;servlet&amp;gt;




    &amp;lt;servlet-name&amp;gt;springapp&amp;lt;/servlet-name&amp;gt;




    &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;




    &amp;lt;init-param&amp;gt;




      &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;




      &amp;lt;param-value&amp;gt;




        /WEB-INF/springapp-security-config.xml




        /WEB-INF/springapp-servlet-config.xml




      &amp;lt;/param-value&amp;gt;




    &amp;lt;/init-param&amp;gt;




    &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;




  &amp;lt;/servlet&amp;gt;




  &amp;lt;servlet-mapping&amp;gt;




    &amp;lt;servlet-name&amp;gt;springapp&amp;lt;/servlet-name&amp;gt;




    &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;




  &amp;lt;/servlet-mapping&amp;gt;






Error on a jsp acces :






javax.servlet.jsp.JspException: java.lang.IllegalStateException: No WebApplicationContext found: no ContextLoaderListener registered?] with root cause




java.lang.IllegalStateException: No WebApplicationContext found: no ContextLoaderListener registered?




	at org.springframework.web.context.support.WebApplicationContextUtils.getRequiredWebApplicationContext(WebApplicationContextUtils.java:90)




	at org.springframework.security.taglibs.authz.AbstractAuthorizeTag.getExpressionHandler(AbstractAuthorizeTag.java:315)




	at org.springframework.security.taglibs.authz.AbstractAuthorizeTag.authorizeUsingAccessExpression(AbstractAuthorizeTag.java:172)




	at org.springframework.security.taglibs.authz.AbstractAuthorizeTag.authorize(AbstractAuthorizeTag.java:105)




	at org.springframework.security.taglibs.authz.JspAuthorizeTag.doStartTag(JspAuthorizeTag.java:54)




	at org.apache.jsp.WEB_002dINF.jsp.home.home_jsp._jspx_meth_sec_005fauthorize_005f0(home_jsp.java:187)




	at org.apache.jsp.WEB_002dINF.jsp.home.home_jsp.access$3(home_jsp.java:177)




	at org.apache.jsp.WEB_002dINF.jsp.home.home_jsp$Helper.invoke0(home_jsp.java:254)




	at org.apache.jsp.WEB_002dINF.jsp.home.home_jsp$Helper.invoke(home_jsp.java:278)




	at org.apache.jsp.tag.webtemplate.default_tag.doTag(default_tag.java:206)




	at org.apache.jsp.WEB_002dINF.jsp.home.home_jsp._jspx_meth_template_005fdefault_005f0(home_jsp.java:115)




	at org.apache.jsp.WEB_002dINF.jsp.home.home_jsp._jspService(home_jsp.java:86)




	at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70)




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:728)




	at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:432)




	at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:390)




	at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:334)




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:728)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)




	at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:749)




	at org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:487)




	at org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:412)




	at org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:339)




	at org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:238)




	at org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:264)




	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1208)




	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:992)




	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:939)




	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:856)




	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:936)




	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:827)




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:621)




	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:812)




	at javax.servlet.http.HttpServlet.service(HttpServlet.java:728)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:305)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)




	at com.somesofts.bookmyevent.web.common.filter.SessionDebugFilter.doFilter(SessionDebugFilter.java:108)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:330)




	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:118)




	at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:84)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:113)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:103)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:113)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter.doFilter(RememberMeAuthenticationFilter.java:139)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:150)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:45)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:184)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:105)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:50)




	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.session.ConcurrentSessionFilter.doFilter(ConcurrentSessionFilter.java:125)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:87)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.access.channel.ChannelProcessingFilter.doFilter(ChannelProcessingFilter.java:144)




	at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:342)




	at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:192)




	at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:160)




	at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346)




	at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:259)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)




	at com.somesofts.bookmyevent.web.common.filter.CacheDebugFilter.doFilter(CacheDebugFilter.java:54)




	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:243)




	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:210)




	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:222)




	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:123)




	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:472)




	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:171)




	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:99)




	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:936)




	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:118)




	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:407)




	at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1004)




	at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:589)




	at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:312)




	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)




	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)




	at java.lang.Thread.run(Thread.java:722)





</description>
			<version>3.2.0.RC1</version>
			<fixedVersion>3.2.9, 4.0.3, 4.1.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.support.SecurityWebApplicationContextUtils.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AbstractAuthorizeTagTests.java</file>
			<file type="M">org.springframework.security.web.session.HttpSessionEventPublisher.java</file>
			<file type="M">org.springframework.security.web.session.HttpSessionEventPublisherTests.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AccessControlListTagTests.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AccessControlListTag.java</file>
			<file type="M">org.springframework.security.taglibs.authz.AbstractAuthorizeTag.java</file>
		</fixedFiles>
	</bug>
	<bug id="3135" opendate="2015-10-27 17:44:05" fixdate="2015-10-29 17:59:21" resolution="Complete">
		<buginformation>
			<summary>authorizeRequests().antMatchers(&lt;any-method&gt;).authenticated() fails</summary>
			<description>When chaining ant matchers, the last one needs a URL pattern else it throws exception.






protected void configure(HttpSecurity http) throws Exception {




	.authorizeRequests()




	.antMatchers(GET, SECURE_PATTERNS).authenticated()




	.antMatchers(POST).hasAnyRole("ADMIN") 




	.antMatchers(DELETE).hasAnyRole("ADMIN") 




	.antMatchers(PUT).hasAnyRole("ADMIN") 




	// the last one needs a URL, else throws exception




	.antMatchers(PATCH, WILDCARD_PATTERN).hasAnyRole("ADMIN").and()




	.httpBasic()




	.and().csrf().disable()




	.userDetailsService(userDetailsService); 




}





</description>
			<version>4.0.2</version>
			<fixedVersion>3.2.9, 4.0.3, 4.1.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.AbstractRequestMatcherRegistry.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.AuthorizeRequestsTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="3128" opendate="2015-10-17 14:59:41" fixdate="2015-10-29 20:02:57" resolution="Complete">
		<buginformation>
			<summary>RoleVoter throws NPE with null Authentication</summary>
			<description>Using AccessDecisionManager manually(just like how webflow integrates with security) is causing NPE if no `Authentication` is present:






Authentication authentication = SecurityContextHolder.getContext().getAuthentication();




manager.decide(authentication, object, configAttributes);












java.lang.NullPointerException




	at org.springframework.security.access.vote.RoleVoter.extractAuthorities(RoleVoter.java:119)




	at org.springframework.security.access.vote.RoleVoter.vote(RoleVoter.java:99)




	at org.springframework.security.access.vote.AffirmativeBased.decide(AffirmativeBased.java:62)






While I could handle null `Authentication` in my class calling `accessDecisionManager` it&amp;amp;apos;s a bit wrong that security core is throwing NPE. I didn&amp;amp;apos;t test if `RoleVoter` is only voter throwing NPE. Not sure if you&amp;amp;apos;d ever see this in a real web app but I wanted to add a test and see how my stuff behaves when there is no existing authentication in a sec context.
Maybe voter should actually throw a proper exception or vote `ACCESS_DENIED` or `ACCESS_ABSTAIN`. I could throw `AccessDeniedException` from my class but, imho throwing that specific exception is security&amp;amp;apos;s job.
</description>
			<version>3.2.8</version>
			<fixedVersion>3.2.9, 4.0.3, 4.1.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.access.vote.RoleVoterTests.java</file>
			<file type="M">org.springframework.security.access.vote.RoleVoter.java</file>
		</fixedFiles>
	</bug>
	<bug id="3082" opendate="2015-08-20 02:52:54" fixdate="2015-10-29 21:57:40" resolution="Fixed">
		<buginformation>
			<summary>SavedRequest parameters are treated as case-insensitive</summary>
			<description>The DefaultSavedRequest stores parameters in a case-insensitive TreeMap, but with a normal HttpServletRequest parameter names are case-sensitive.
Basically, this TreeMap should not use a case-insensitive comparator: https://github.com/spring-projects/spring-security/blob/c79bceab03555df0825b5d0c96fc9bc38eb88b9a/web/src/main/java/org/springframework/security/web/savedrequest/DefaultSavedRequest.java#L65
Someone already noticed this mistake in the past, see the comment at the test class: https://github.com/spring-projects/spring-security/blob/c79bceab03555df0825b5d0c96fc9bc38eb88b9a/web/src/test/java/org/springframework/security/web/savedrequest/DefaultSavedRequestTests.java#L35
Header names should be case-insensitive, so that&amp;amp;apos;s fine.</description>
			<version>3.2.8</version>
			<fixedVersion>3.2.9, 4.0.3, 4.1.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.savedrequest.DefaultSavedRequest.java</file>
			<file type="M">org.springframework.security.web.savedrequest.DefaultSavedRequestTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="3147" opendate="2015-11-12 18:00:06" fixdate="2015-11-12 21:23:42" resolution="Fixed">
		<buginformation>
			<summary>Include the error parameter into authentication-failure-url when login-page is customized</summary>
			<description>If XML Config used, parameter that indicate error does not include into authentication-failure-url.
[XML Config]

login-page : /loginForm
authentication-failure-url : /loginForm

[Java Config]

login-page : /loginForm
authentication-failure-url : /loginForm?error

I think should be include error parameter (?error) into authentication-failure-url.</description>
			<version>4.0.3</version>
			<fixedVersion>3.2.10, 4.0.4, 4.1.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.http.FormLoginBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="3160" opendate="2015-11-23 15:51:56" fixdate="2015-11-29 02:57:29" resolution="Duplicate">
		<buginformation>
			<summary>Invalid HTTP verb throws 500 not 400</summary>
			<description>Had a few cases of a bad client request which doesn&amp;amp;apos;t match a valid HTTP verb, i would expect this to be returned as a 400 Bad Request, instead our access log showed as a 500.






java.lang.IllegalArgumentException: No enum constant 




               at java.lang.Enum.valueOf(Enum.java:238)




                at org.springframework.http.HttpMethod.valueOf(HttpMethod.java:27)




                at org.springframework.security.web.util.matcher.AntPathRequestMatcher.matches(AntPathRequestMatcher.java:125)




                at org.springframework.security.web.access.intercept.DefaultFilterInvocationSecurityMetadataSource.getAttributes(DefaultFilterInvocationSecurityMetadataSource.java:86)




                at org.springframework.security.access.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:174)




                at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecur















</description>
			<version>3.2.5</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.util.matcher.AntPathRequestMatcher.java</file>
			<file type="M">org.springframework.security.web.util.matcher.RegexRequestMatcher.java</file>
			<file type="M">org.springframework.security.web.util.matcher.AntPathRequestMatcherTests.java</file>
			<file type="M">org.springframework.security.web.util.matcher.RegexRequestMatcherTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">2831</link>
		</links>
	</bug>
	<bug id="3159" opendate="2015-11-22 00:38:42" fixdate="2015-11-29 03:00:53" resolution="Complete">
		<buginformation>
			<summary>Java doc inaccurate on HttpSecurity#headers</summary>
			<description></description>
			<version>4.0.0</version>
			<fixedVersion>4.1.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.builders.HttpSecurity.java</file>
		</fixedFiles>
	</bug>
	<bug id="3158" opendate="2015-11-19 08:59:37" fixdate="2015-12-04 04:17:43" resolution="Complete">
		<buginformation>
			<summary>findRequiredWebApplicationContext requires Spring 4.2.x</summary>
			<description>Inside AbstractAuthorizeTag the static method SecurityWebApplicationContextUtils.findRequiredWebApplicationContext(...) is called, which in turn calls
WebApplicationContextUtils.findWebApplicationContext(...)
which does not exist in spring-framework 4.1.x (it can be found in the master branch only).</description>
			<version>4.0.3</version>
			<fixedVersion>4.0.4, 4.1.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.web.context.support.SecurityWebApplicationContextUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="3170" opendate="2015-12-14 15:45:38" fixdate="2015-12-15 15:55:24" resolution="Complete">
		<buginformation>
			<summary>Custom RememberMeServices that does not implement LogoutHandler fails</summary>
			<description>the issue
When your RememberMe service does not implement LogoutHandler the RememberMeConfigurer sets a null logout handler RememberMeConfigurer:287 and the LogoutFilter accepts it just fine LogoutConfigurer:87 later causing an NPE when executing the handlers LogoutFilter:111. This is definitely not expected behaviour.
Steps to reproduce:
1) Create a spring boot app
2) Create a class that implements RememberMeServices but not LogoutHandler
3) Configure HttpSecurity to use it:






protected void configure(HttpSecurity http) throws Exception {




http()




				.rememberMe()




				.rememberMeServices(rememberMeServices()) 






4) Try to login then logout of your app. 
Proposed solution
LogoutConfigurer should never accept null handlers. A null check in the addLogoutHandler method should be sufficient. Also make RememberMeServices extend LogoutHandler so that users are aware of the dependency later on.






public LogoutConfigurer&amp;lt;H&amp;gt; addLogoutHandler(LogoutHandler logoutHandler) {




                Assert.notNull(logoutHandler, "logoutHandler cannot be null");




		this.logoutHandlers.add(logoutHandler);




		return this;




}





</description>
			<version>4.0.3</version>
			<fixedVersion>4.1.0 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.security.config.annotation.web.configurers.RememberMeConfigurer.java</file>
			<file type="M">org.springframework.security.config.annotation.web.configurers.LogoutConfigurer.java</file>
		</fixedFiles>
	</bug>
</bugrepository>