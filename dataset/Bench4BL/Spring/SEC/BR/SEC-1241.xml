<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Fri Dec 23 11:34:00 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SEC-1241/SEC-1241.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SEC-1241] SavedRequest not destroyed after successful authentication</title>
                <link>https://jira.spring.io/browse/SEC-1241</link>
                <project id="10040" key="SEC">Spring Security</project>
                    <description>&lt;p&gt;SUMMARY:&lt;/p&gt;

&lt;p&gt;After an anonymous user authenticates in order to access a protected resource, the RequestCacheAwareFilter does not destroy the saved request. &lt;/p&gt;

&lt;p&gt;After successfully replaying the original request for the protected resource, the saved request is no longer valid/useful and should be destroyed.&lt;/p&gt;



&lt;p&gt;BACKGROUND:&lt;/p&gt;

&lt;p&gt;I have a form handler registered at:&lt;br/&gt;
&lt;a href=&quot;http://foo.com/app/form&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://foo.com/app/form&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A handler is defined with two methods (one for GET and one for POST). The form posts back to the same url as the GET request for the form (a relatively common practice?).&lt;/p&gt;

&lt;p&gt;So for example:&lt;/p&gt;

&lt;p&gt;GET: /app/form&lt;/p&gt;

&lt;p&gt;&amp;lt;form action=&quot;/app/form&quot; method=&quot;POST&quot;&amp;gt; ... &amp;lt;/form&amp;gt;&lt;/p&gt;


&lt;p&gt;The URL &quot;/app/form&quot; is protected by Spring Security and requires &quot;IS_AUTHENTICATED_FULLY&quot;.&lt;/p&gt;


&lt;p&gt;When an anonymous user  attempts to access the protected resource, they are correctly redirected to the login form. Once authentication is successful, the user is directed back to the protected resource.&lt;/p&gt;

&lt;p&gt;Upon submitting the form, though, the POST fails, because the session still contains a cached copy of the original GET request.&lt;/p&gt;

&lt;p&gt;Because the session still contains a copy of the original GET request, SavedRequest.doesRequestMatch (line 166) erroneously returns true. However, the requests do NOT match: the current request is a POST, whereas the saved request was a GET.&lt;/p&gt;

&lt;p&gt;Additionally, after successfully completing the saved request after authentication, RequestCacheAwareFilter.doFilter (line 36) does not remove the saved request from the cache.&lt;/p&gt;

&lt;p&gt;As a result, when the user attempts to POST the form, the result is the user being directed back to the GET view of the form, with no form-processing actions taking place. Debugging confirms that the requests are mapped to the handler&apos;s GET method.&lt;/p&gt;


&lt;p&gt;I would consider this a critical if not blocking issue, as it prevents normal form processing to occur after authenticating. &lt;/p&gt;

&lt;p&gt;I am still looking, but I have not yet discovered a way to configure Spring Security to use a custom class in-place-of the RequestCacheAwareFilter - so I cannot easily extend or remove the Filter.&lt;/p&gt;


&lt;p&gt;As a work around, I can change the form handler&apos;s POST methods to map to a different URL than the GET method - however, this breaks any RESTful contracts I might have wished to adhere to.&lt;/p&gt;

&lt;p&gt;Additionally, I can configure a custom AuthenticationSuccessHandler (namely, using the SimpleUrlAuthenticationSuccessHandler instead of the SavedRequestAwareAuthenticationSuccessHandler). Doing so effectively stops the Security layer from trying to replay the original request, but this has a jarring impact on the user experience in that users always get redirected back to the default URL after authenticating.&lt;/p&gt;


&lt;p&gt;CONCLUSION&lt;/p&gt;

&lt;p&gt;Any other suggestions are welcome, and I am happy to provide more concrete code examples if necessary...&lt;/p&gt;</description>
                <environment>Tomcat 6.0.18, Java 1.6, OS X 10.5</environment>
        <key id="27904">SEC-1241</key>
            <summary>SavedRequest not destroyed after successful authentication</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="1" iconUrl="https://jira.spring.io/images/icons/priorities/blocker.png">Blocker</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="luke">Luke Taylor</assignee>
                                    <reporter username="jcarlson">Jarrod Carlson</reporter>
                        <labels>
                    </labels>
                <created>Tue, 8 Sep 2009 08:50:16 +0000</created>
                <updated>Sat, 6 Feb 2016 06:12:01 +0000</updated>
                            <resolved>Tue, 8 Sep 2009 21:21:39 +0000</resolved>
                                    <version>3.0.0 M2</version>
                                    <fixVersion>3.0.0 RC1</fixVersion>
                                    <component>Web</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>6</watches>
                                                                <comments>
                            <comment id="46607" author="luke" created="Tue, 8 Sep 2009 21:20:46 +0000"  >&lt;p&gt;Thanks for the report. This looks like a failure in HttpSessionRequestCache to remove the saved request after a match.&lt;/p&gt;

&lt;p&gt;Please note that this area is still under development (see &lt;a href=&quot;https://jira.spring.io/browse/SEC-1167&quot; title=&quot;Introduce more flexible SavedRequest handling&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SEC-1167&quot;&gt;&lt;del&gt;SEC-1167&lt;/del&gt;&lt;/a&gt;) and the intention is to make the saved request handling system pluggable.&lt;/p&gt;

&lt;p&gt;Regarding &quot;the requests do NOT match: the current request is a POST, whereas the saved request was a GET&quot;, that is intentional in order to match requests which were orginally POSTs (it is only possible to redirect a request as a GET).&lt;/p&gt;</comment>
                            <comment id="46613" author="jcarlson" created="Wed, 9 Sep 2009 02:50:16 +0000"  >&lt;p&gt;I&apos;m not sure I understand your statement about matching requests... My point was that the SavedRequest.doesRequestMatch() method will return TRUE when the current request is a POST and the saved request is a GET. It is unclear to me why this method would condsider the two requests as a match. Could you describe a legitimate case where the saved request is a GET and the current request is a POST?&lt;/p&gt;

&lt;p&gt;I would expect that in the case of the current request being a POST and the saved request being a GET, the method would return false (the saved request cannot be used).&lt;/p&gt;

&lt;p&gt;Hopefully, with the fix applied in this ticket, this scenario will not arise, but I&apos;m still curious as to why the two requests being compared could still be considered a match?&lt;/p&gt;</comment>
                            <comment id="46615" author="luke" created="Wed, 9 Sep 2009 03:03:17 +0000"  >&lt;p&gt;Any situation where the original request is a POST is a legitimate case:&lt;/p&gt;

&lt;p&gt;1. User submits a POST request to /secure&lt;br/&gt;
2. Request is saved and user redirected to login&lt;br/&gt;
3. User logs in and is redirected to the original URL &quot;/secure&quot;&lt;br/&gt;
4. Browser issues a &quot;GET&quot; request for &quot;/secure&quot;&lt;/p&gt;

&lt;p&gt;In this case what we want is for the original &quot;POST&quot; request to be substituted for the current request, therefore a match is required.&lt;/p&gt;</comment>
                            <comment id="46617" author="jcarlson" created="Wed, 9 Sep 2009 04:38:55 +0000"  >&lt;p&gt;Ah, but the case you describe is the reverse of the problem I experienced. In your example, the saved request is a POST and the current request is a GET.&lt;/p&gt;

&lt;p&gt;My problem specifically focused on the opposite scenario, where the saved request is a GET and the current request is a POST.&lt;/p&gt;

&lt;p&gt;Like I mentioned, this scenario shouldn&apos;t happen if the saved requests are properly destroyed when their usefulness expires, but my question remains: are there cases such as the one I describe, and should these be detected as NOT a match (if they can in fact legitimately occur)?&lt;/p&gt;</comment>
                            <comment id="46618" author="luke" created="Wed, 9 Sep 2009 04:53:56 +0000"  >&lt;p&gt;No, you&apos;re probably right. I can&apos;t think of any situation where an incoming POST request should match a saved GET request, so the default SavedRequest implementation should probably take that into account. The wonderful thing about working on Spring Security though is that you&apos;re never quite sure what some people will end up using it for  and what scenarios they&apos;ll come up with &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;Changing SavedRequest to an interface and making RequestCache pluggable will allow all this to be customized if necessary.&lt;/p&gt;</comment>
                            <comment id="50940" author="absorbb" created="Mon, 8 Feb 2010 20:47:55 +0000"  >&lt;p&gt;2.0.5 version also has this bug. It is very important because most production projects still use 2.0.5.&lt;br/&gt;
2.0.5 version has another class hierarchy. So SecurityContextHolderAwareRequestFilter and SecurityContextHolderAwareRequestWrapper are responsible for such behavior in 2.0.&lt;br/&gt;
You can easily workaround this problem by setting servlet-api-provision=&quot;false&quot; attribute in &amp;lt;http&amp;gt; definition. This will completely exclude SecurityContextHolderAwareRequestFilter(SERVLET_API_SUPPORT_FILTER) from filter chain. But who really need it?!&lt;/p&gt;</comment>
                            <comment id="86331" author="ohadr" created="Sat, 22 Dec 2012 11:21:35 +0000"  >&lt;p&gt;I understand the problem,  and the solution.&lt;/p&gt;

&lt;p&gt;However, I have a problem due to this solution. I wrote it in the Spring Security forum:&lt;br/&gt;
&lt;a href=&quot;http://forum.springsource.org/showthread.php?133566-2-opened-tabs-after-login-Spring-does-not-redirect-to-the-protected-resource&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://forum.springsource.org/showthread.php?133566-2-opened-tabs-after-login-Spring-does-not-redirect-to-the-protected-resource&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Any ideas?&lt;/p&gt;</comment>
                            <comment id="124143" author="issuemaster" created="Sat, 6 Feb 2016 06:12:01 +0000"  >&lt;p&gt;This issue has been migrated to &lt;a href=&quot;https://github.com/spring-projects/spring-security/issues/1489&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/spring-projects/spring-security/issues/1489&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 8 Sep 2009 21:20:46 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10280" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>19690</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i02upr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>16685</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10381" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Ranking</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>15702</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>