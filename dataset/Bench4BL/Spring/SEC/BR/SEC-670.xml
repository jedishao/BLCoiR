<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Fri Dec 23 10:06:18 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SEC-670/SEC-670.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SEC-670] Deleting from ACL_OBJECT_IDENTITY can cause deadlocks under (load test)</title>
                <link>https://jira.spring.io/browse/SEC-670</link>
                <project id="10040" key="SEC">Spring Security</project>
                    <description>&lt;p&gt;While performing load testing, we found concurrent deletes from the ACL_OBJECT_IDENTITY table by the JdbcMutableAclService would cause deadlocks in the database.  This is potentially only a problem when using MS SQL server 2000, I haven&apos;t tested any other RDBs.&lt;/p&gt;

&lt;p&gt;The deadlocks were found when simulating only 3 concurrent users, so was relatively easy to reproduce.&lt;/p&gt;

&lt;p&gt;The deadlocks are caused for several reasons, I&apos;ll start with the most serious.&lt;/p&gt;

&lt;p&gt;deleteAcl(ObjectIdentity objectIdentity, boolean deleteChildren) does the following:&lt;/p&gt;

&lt;p&gt;1 find all children of the ACL&lt;br/&gt;
2 optionally delete these recursively  // not tested, but would cause deadlocks i think&lt;/p&gt;

&lt;p&gt;call deleteEntries(..)&lt;br/&gt;
    performs a select to find Objectidentity pkey&lt;br/&gt;
    deletes from ACL_Entry&lt;/p&gt;

&lt;p&gt;call deleteObjectIdentityAndOptionallyClass(..)&lt;br/&gt;
    performs a select to find Objectidentity pkey&lt;br/&gt;
    deletes from ACL_OBJECT_IDENTITY&lt;br/&gt;
    selects from ACL_OBJECT_IDENTITY to see if the entry deleted was the last from a particular class&lt;br/&gt;
    deletes from ACL_CLASS (dependent on outcome of previous select)&lt;/p&gt;

&lt;p&gt;&amp;#8211;&lt;/p&gt;

&lt;p&gt;In MS SQL server the best practise is to perform all selects first, then do deletes, interleaving selects and deletes is a recipe for deadlocks.&lt;/p&gt;

&lt;p&gt;After some reorganisation of the above operations, we also found another deadlock caused by the database this time internally, where 2 concurrent deletes on the ACL_OBJECT_IDENTITY table when the DB was checking the foreign key to &apos;parent object&apos;, which we had to solve with a synchronized.&lt;/p&gt;

&lt;p&gt;I&apos;ve pasted our fixed code below, not that it no longer deletes from the ACL_CLASS table if the ACL_OBJECT_IDENTITY row is that last one that referenced it, as I find this a waste of time (you may not agree?), it this may cause issues with a coinciding insert into ACL_OBJECT_IDENTITY (untested and not fully thought through).  Also if deleteChildren was passed as true, I&apos;m sure the deadlocks would still occur.&lt;/p&gt;

&lt;p&gt;&amp;#8211;&lt;/p&gt;

&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Deletes the the ACL for the specified 
{@link ObjectIdentity}. &amp;lt;br&amp;gt;  &lt;br/&gt;
   * NOTE: Passing deleteChildren as &amp;lt;code&amp;gt;true&amp;lt;/code&amp;gt; can cause deadlocks at&lt;br/&gt;
   * the database, as this uses recursion on this method resulting in &lt;br/&gt;
   * select, delete, select... sequences of JDBC calls which is a recipe for&lt;br/&gt;
   * deadlocks (at least on MS SQL server) under heavy load.&lt;br/&gt;
   * &lt;br/&gt;
   * @param objectIdentity&lt;br/&gt;
   * @param deleteChildren&lt;br/&gt;
   * @throws ChildrenExistException&lt;br/&gt;
   */&lt;br/&gt;
  public void deleteAcl(ObjectIdentity objectIdentity, boolean deleteChildren)&lt;br/&gt;
      throws ChildrenExistException&lt;br/&gt;
  {&lt;br/&gt;
    Assert.notNull(objectIdentity, &quot;Object Identity required&quot;);&lt;br/&gt;
    Assert.notNull(objectIdentity.getIdentifier(),&lt;br/&gt;
                   &quot;Object Identity doesn&apos;t provide an identifier&quot;);&lt;br/&gt;
 &lt;br/&gt;
    if (deleteChildren) &lt;br/&gt;
    {&lt;br/&gt;
      // deadlock territory&lt;br/&gt;
      ObjectIdentity[] children = findChildren(objectIdentity);&lt;br/&gt;
      for (int i = 0; i &amp;lt; children.length; i++) &lt;br/&gt;
      {
            deleteAcl(children[i], true);
      }&lt;br/&gt;
    }&lt;br/&gt;
    &lt;br/&gt;
    // we could have placed the find children outside the if and used it to &lt;br/&gt;
    // check for children, but this has been found to cause the occasional&lt;br/&gt;
    // deadlock in MS SQL server, so we&apos;ll just let the FK do the checking for&lt;br/&gt;
    // us.  After all that&apos;s what it&apos;s for&lt;br/&gt;
&lt;br/&gt;
    Long oidPkey = retrieveObjectIdentityPrimaryKey(objectIdentity);&lt;br/&gt;
    &lt;br/&gt;
    // Delete this ACL&apos;s ACEs in the acl_entry table&lt;br/&gt;
    deleteEntries(oidPkey);&lt;br/&gt;
&lt;br/&gt;
    // Delete this ACL&apos;s acl_object_identity row&lt;br/&gt;
    deleteObjectIdentity(oidPkey);&lt;br/&gt;
    &lt;br/&gt;
    // Clear the cache&lt;br/&gt;
    aclCache.evictFromCache(objectIdentity);&lt;br/&gt;
  }&lt;br/&gt;
&lt;br/&gt;
  /**&lt;br/&gt;
   * Deletes all ACEs defined in the acl_entry table belonging to the presented&lt;br/&gt;
   * ObjectIdentity&lt;br/&gt;
   * &lt;br/&gt;
   * @param oid&lt;br/&gt;
   *            the rows in acl_entry to delete&lt;br/&gt;
   */&lt;br/&gt;
  protected void deleteEntries(ObjectIdentity oid)&lt;br/&gt;
  {
    this.deleteEntries(retrieveObjectIdentityPrimaryKey(oid));
  }&lt;br/&gt;
&lt;br/&gt;
  private void deleteEntries(Long oidPKey)&lt;br/&gt;
  {&lt;br/&gt;
    jdbcTemplate.update(deleteEntryByObjectIdentityForeignKey,&lt;br/&gt;
                        new Object[] { oidPKey });&lt;br/&gt;
  }&lt;br/&gt;
  &lt;br/&gt;
  /**&lt;br/&gt;
   * Deletes a single row from acl_object_identity that is associated with the&lt;br/&gt;
   * presented ObjectIdentity. &amp;lt;br&amp;gt;&lt;br/&gt;
   * Does not delete the from the ACL_CLASS table if &lt;br/&gt;
   * the {@link ObjectIdentity}
&lt;p&gt; deleted is the last of that class, as this would&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;require a select after a delete, which can cause deadlocks on some RDB&apos;s,&lt;/li&gt;
	&lt;li&gt;and potentially another thread creating an ACL may have checked that&lt;/li&gt;
	&lt;li&gt;ACL_CLASS row exist and is waiting to insert would experience problems.&amp;lt;br&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;br&amp;gt;&lt;/li&gt;
	&lt;li&gt;Also note that this method is synchronised, this is yet another deadlock&lt;/li&gt;
	&lt;li&gt;avoidance manoeuvre, here&apos;s why:&amp;lt;br&amp;gt;&lt;/li&gt;
	&lt;li&gt;The ACL_OBJECT_IDENTITY table has a foreign key back to itself (to support&lt;/li&gt;
	&lt;li&gt;hierarchical ACLs), and this can cause the following situation:&lt;/li&gt;
	&lt;li&gt;&amp;lt;ol&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt;&lt;/li&gt;
	&lt;li&gt;Thread 1 (T1) is attempting to delete row X, so obtains an exclusive&lt;/li&gt;
	&lt;li&gt;page lock on row X (and some of it close buddies)&lt;/li&gt;
	&lt;li&gt;&amp;lt;/li&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt;&lt;/li&gt;
	&lt;li&gt;Thread 1 (T2) is attempting to delete row Y, so obtains an exclusive&lt;/li&gt;
	&lt;li&gt;page lock on row Y (and some of it close buddies)&lt;/li&gt;
	&lt;li&gt;&amp;lt;/li&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt;&lt;/li&gt;
	&lt;li&gt;T2 now performs a table scan to ensure the FK from PARENT_OBJECT back to&lt;/li&gt;
	&lt;li&gt;ID (same table remember) is not violated by removal of row Y, but has to&lt;/li&gt;
	&lt;li&gt;wait for the exclusive lock held by T1 to be released&lt;/li&gt;
	&lt;li&gt;&amp;lt;/li&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt;&lt;/li&gt;
	&lt;li&gt;T1 now performs a table scan to ensure the FK from PARENT_OBJECT back to&lt;/li&gt;
	&lt;li&gt;ID (same table remember) is not violated by removal of row X, but has to&lt;/li&gt;
	&lt;li&gt;wait for the exclusive lock held by T2 to be released&lt;/li&gt;
	&lt;li&gt;&amp;lt;/li&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt;Deadlock!!! &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; &amp;lt;/li&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;/ol&amp;gt;&lt;/li&gt;
	&lt;li&gt;This has been observed using MS SQL Server, under load testing.&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@param oidPKey The primary key of the object identity to delete&lt;/li&gt;
	&lt;li&gt;that class name if appropriate)&lt;br/&gt;
   */&lt;br/&gt;
  protected synchronized void deleteObjectIdentity(Long oidPKey)
  &lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    // Delete the acl_object_identity row    jdbcTemplate.update(deleteObjectIdentityByPrimaryKey,                        new Object[] { oidPKey });  }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;  /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Retrieves the primary key from the acl_object_identity table for the passed&lt;/li&gt;
	&lt;li&gt;ObjectIdentity. Unlike some other methods in this implementation, this&lt;/li&gt;
	&lt;li&gt;method will NOT create a row (use 
{@link
   * #createObjectIdentity(ObjectIdentity, Sid)}
&lt;p&gt; instead).&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@param oid&lt;/li&gt;
	&lt;li&gt;to find&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@return the object identity or null if not found&lt;br/&gt;
   */&lt;br/&gt;
  protected Long retrieveObjectIdentityPrimaryKey(ObjectIdentity oid)&lt;br/&gt;
  {&lt;br/&gt;
    try
    &lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {      return new Long(jdbcTemplate          .queryForLong(selectObjectIdentityPrimaryKey, new Object[] {
              oid.getJavaType().getName(), oid.getIdentifier() }));    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    catch (DataAccessException notFound)&lt;/p&gt;
    {
      return null;
    }
&lt;p&gt;  }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;





</description>
                <environment>ubuntu feisty, Java HotSpot(TM) Client VM (build 1.6.0_01-b06, mixed mode, sharing)&lt;br/&gt;
tomcat 5.5.16&lt;br/&gt;
MS SQL Server 2000</environment>
        <key id="20537">SEC-670</key>
            <summary>Deleting from ACL_OBJECT_IDENTITY can cause deadlocks under (load test)</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://jira.spring.io/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="balex">Ben Alex</assignee>
                                    <reporter username="svanders">Simon van der Sluis</reporter>
                        <labels>
                    </labels>
                <created>Sun, 10 Feb 2008 07:55:22 +0000</created>
                <updated>Sat, 6 Feb 2016 06:35:05 +0000</updated>
                            <resolved>Sat, 5 Apr 2008 09:57:09 +0000</resolved>
                                    <version>1.0.3</version>
                                    <fixVersion>2.0.0</fixVersion>
                                    <component>ACLs</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                <comments>
                            <comment id="34385" author="balex" created="Fri, 4 Apr 2008 19:19:18 +0000"  >&lt;p&gt;Fix typos.&lt;/p&gt;</comment>
                            <comment id="34399" author="balex" created="Sat, 5 Apr 2008 09:57:09 +0000"  >&lt;p&gt;Simon, thanks for another bug report and patch. It&apos;s very much appreciated.&lt;/p&gt;

&lt;p&gt;Tests pass, although I had to remove the test that previously tested the deletion of acl_class entries, given this behavior is no longer offered.&lt;/p&gt;

&lt;p&gt;A new property was added, JdbcMutableAclService.foreignKeysInDatabase (with associated mutator). The JavaDocs explain its operation:&lt;/p&gt;

&lt;p&gt;&quot;@param foreignKeysInDatabase if false this class will perform additional FK constrain checking, which may cause deadlocks (the default is true, so deadlocks are avoided but the database is expected to enforce FKs)&quot;&lt;/p&gt;

&lt;p&gt;Modified JdbcAclServiceTests.testDeleteAclWithChildrenThrowsException() so it correctly tests the JdbcMutableAclService.foreignKeysInDatabase = false behavior.&lt;/p&gt;

&lt;p&gt;Tests (spring-security-acl, Contacts sample and DMS sample) all pass with these changes. No attempt was made to load test, though.&lt;/p&gt;

&lt;p&gt;SVN commit 2876 and 2877.&lt;/p&gt;</comment>
                            <comment id="126671" author="issuemaster" created="Sat, 6 Feb 2016 06:35:05 +0000"  >&lt;p&gt;This issue has been migrated to &lt;a href=&quot;https://github.com/spring-projects/spring-security/issues/930&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/spring-projects/spring-security/issues/930&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 4 Apr 2008 19:19:18 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10280" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>20193</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i05a1j:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>30833</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10381" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Ranking</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>27901</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>