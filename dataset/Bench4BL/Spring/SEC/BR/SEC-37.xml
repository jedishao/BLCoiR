<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Fri Dec 23 11:28:44 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SEC-37/SEC-37.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SEC-37] HttpSessionContextIntegrationFilter concurrent request handling</title>
                <link>https://jira.spring.io/browse/SEC-37</link>
                <project id="10040" key="SEC">Spring Security</project>
                    <description>&lt;p&gt;See &lt;a href=&quot;http://forum.springframework.org/viewtopic.php?t=7104&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://forum.springframework.org/viewtopic.php?t=7104&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Basically if more than one request comes into a web container for the same browser, both requests will be for the same jsessionid. If the requests finish in a different order from which they are received, any authentication action that occurs in the faster-to-complete request will be overwritten by the slower-to-complete request.&lt;/p&gt;

&lt;p&gt;The fix is to only ever write to HttpSession if the SecurityContextHolder.getContext() has actually changed during the request. As such, in the above case the slower-to-complete request will not have changed its SecurityContextHolder and therefore would not have overwritten the faster-to-complete request&apos;s modification of SecurityContextHolder and thus persistence in HttpSession.&lt;/p&gt;

&lt;p&gt;I have no problem with this change, it makes sense, we just need to ensure test coverage carefully checks its correct operation.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12051">SEC-37</key>
            <summary>HttpSessionContextIntegrationFilter concurrent request handling</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="balex">Ben Alex</assignee>
                                    <reporter username="balex">Ben Alex</reporter>
                        <labels>
                    </labels>
                <created>Fri, 22 Jul 2005 22:36:05 +0000</created>
                <updated>Sat, 6 Feb 2016 06:32:01 +0000</updated>
                            <resolved>Thu, 20 Oct 2005 18:25:48 +0000</resolved>
                                                    <fixVersion>0.9.0</fixVersion>
                                    <component>Core</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="15063" author="balex" created="Thu, 20 Oct 2005 18:25:48 +0000"  >&lt;p&gt;Decided to implement it via a hashCode() method on SecurityContextImpl.  Using an object reference as suggested in the thread resulted in the object being referenced being modified by reference, so using a hashCode int was safer.&lt;/p&gt;</comment>
                            <comment id="35311" author="bryanloof" created="Sat, 3 May 2008 03:32:01 +0000"  >&lt;p&gt;I discovered this Closed defect by surprise, looking through ACEGI source, when I wanted to find out why my changed Authentication was not being written to the session. I understand the general idea that you want to only write the security context if it has changed; I even commend it. But the use of hash code to accomplish the purpose doesn&apos;t seem right, at least if it&apos;s the only mechanism:&lt;/p&gt;

&lt;p&gt;1) Hash codes, by definition, are a compressed value; that is, multiple states of an object can map to the same hash. I don&apos;t see how, in general, hash codes can be used to judge whether an object has changed &amp;#8211; they&apos;re just identifying when two things are definitely not the same.&lt;/p&gt;

&lt;p&gt;2) If you say, well, if you don&apos;t override hash code, then it&apos;s just the pointer value (is it? I don&apos;t know), so it works anyway, I have two concerns:&lt;br/&gt;
  a) there might be target systems (e.g. 64 bit) for which there is some small probability of that not being true &lt;br/&gt;
  b) If an acegi user implements hashCode for his/her Authentication, then that assurance goes away, and you&apos;re relying on the hashcode always reflecting changes. Mostly, it will, if properly implemented. But occasionally, it won&apos;t, regardless of the quality of the implementation. This seems like an invitation to elusive bugs. Also, there is no warning, in the Javadoc for Authentication or SecurityContext, that one should consider this issue when overriding hashCode().&lt;/p&gt;

&lt;p&gt;Any thoughts? Thanks.&lt;/p&gt;</comment>
                            <comment id="35313" author="balex" created="Sat, 3 May 2008 08:15:01 +0000"  >&lt;p&gt;From a HSCIF perspective, we&apos;re only interested if the SecurityContext instance is different from the existing SecurityContext instance. This is because a different instance would indicate a modification that should be persisted to HttpSession (assuming there are not properties on HSCIF indicating we should not persist, as would be the case in situations such as BASIC authentication). &lt;/p&gt;

&lt;p&gt;It is true that we expect Authentication to provide a hashCode() that is not based on memory address but rather a hash of the relevant instance fields. It is also true that the existing Authentication might have a hashCode() equal to x and even after modifying it, the new hashCode() is still equal to x. However, that seems extraordinarily unlikely for a correct implementation of hashCode() that delegates to the hashCode() method of each instance field as part of its computation.&lt;/p&gt;

&lt;p&gt;As an aside, the most common usage scenario is the SecurityContext contains an AnonymousAuthenticationToken, which is varied to another Authentication instance when somebody logs in. Custom instances can consider extending AbstractAuthenticationToken if they&apos;d like a hashCode() method that includes most common authentication instance fields.&lt;/p&gt;

&lt;p&gt;You&apos;ll be pleased to know we have a unit test that actually goes off and creates dozens of threads and does various modification logic. In the years we&apos;ve been using that test, they&apos;ve never failed due to different objects returning the same hash code.&lt;/p&gt;

&lt;p&gt;The real issue is what is the alternative? As noted in my comment of 21 October 2005, we cannot simply use Object.equals(Object) because we&apos;d need to clone the SecurityContext in order to undertake a proper comparison. That would impose considerable cloning costs at runtime (if we cloned via the typical byte array copying method) or complicate existing implementations (if we required them to provide an acceptable clone method instead).&lt;/p&gt;

&lt;p&gt;Hope this gives some background. Can I ask whether you encountered an actual issue with your custom Authentication object not being persisted by HSCIF and were unable to correct it by using an existing Authentication instance as a guide to implementation (or extending AbstractAuthenticationToken)?&lt;/p&gt;</comment>
                            <comment id="35315" author="bryanloof" created="Sat, 3 May 2008 09:02:00 +0000"  >&lt;p&gt;I encountered an actual issue because I had modified my custom Authentication object, and had not overridden hashCode, so of course my change to the object was undetectable. I implemented a proper hashCode() and the problem went away. The only remaining behavioral problem was, I concede, prospective &amp;#8211; the remote possibility of a situation in which the Authentication would not be persisted. I admit that I do not routinely override hashCode/equals on objects for which I have no expectation of comparing or mapping. Perhaps that is an unusual and inappropriate practice on my part. But if it&apos;s not, the behavior does come as a surprise to a coder, and it might be worthwhile to allude to the issue in Javadocs.&lt;/p&gt;

&lt;p&gt;As for alternatives, one can imagine making the whole issue explicit with setChanged/isChanged method on the SecurityContext and/or Authentication.  That would at least give some opportunity to explain in the Javadocs, and give an opportunity for custom objects to explicitly call out changes. It would also break back compatibility with these interfaces, though, so I can understand why you&apos;d not be eager to do it. The next best thing would be to simply put an isChanged method on SecurityContextImpl. Have the default implementation do what it does now, and allow me to override with whatever I want to use (which would be the explicit transient changed flag I describe above). Right now this decision is made in the middle of a long method, and I am loathe to copy the whole method in an overridden version, just to change this one thing. &lt;/p&gt;

&lt;p&gt;That approach of splitting out this decision to a separate method in the Impl would not break back compatibility or change current behavior, it would just open up a way for application programmers to control this decision more explicitly.&lt;/p&gt;

&lt;p&gt;I take some reassurance from the tests that you describe, but perhaps not enough for my situation: high-volume systems with high availability requirements.  The interesting question for me is, how often might I expect to see such a failure in one of my installations?&quot;  If the answer is &quot;when the sun burns out,&quot; or  even &quot;once every 10 years,&quot; then I&apos;m fine with it. But even &quot;once every 6 months&quot; would present me with an unacceptable reliability problem. Bottom line at this point is that I don&apos;t have the data to make the calculation, but of course I&apos;d like to take an approach in which, having identified the issue, I&apos;ve taken steps to protect myself from it, rather than waiting and hoping it won&apos;t bite me, or putting a lot of effort into trying to guess how vulnerable I might be, and hoping I got it right.&lt;/p&gt;</comment>
                            <comment id="35317" author="bryanloof" created="Sat, 3 May 2008 13:14:41 +0000"  >&lt;p&gt;To respond and elaborate further, while I agree the clone business is untenable, I am quite tempted by something like:&lt;/p&gt;

&lt;p&gt;if (context != null) {&lt;br/&gt;
    if (context == previousContext) &lt;/p&gt;
{
        if (context.isChanged(previousContextHashCode))
            // update session 
        }
&lt;p&gt;    } else if (!context.equals(previousContext)) &lt;/p&gt;
{
        // update session
    }
&lt;p&gt;} else  if (previousContext != null) {&lt;br/&gt;
    // remove session&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;I think this is getting toward the true nature of things: if it&apos;s a different object, the interesting question is whether the new object is equal to the old object (or you could just write it anyway, if it&apos;s not important to detect equality in this case). If it&apos;s the same object, then rely on the implementation to tell you that it has changed in place, with the hashcode-comparison as a backstop implementation if the application developer hasn&apos;t chosen to override with some more deterministic indicator of in-place changes.&lt;/p&gt;
</comment>
                            <comment id="126338" author="issuemaster" created="Sat, 6 Feb 2016 06:32:01 +0000"  >&lt;p&gt;This issue has been migrated to &lt;a href=&quot;https://github.com/spring-projects/spring-security/issues/292&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/spring-projects/spring-security/issues/292&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 3 May 2008 03:32:01 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10280" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>20786</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i02rkn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>16176</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10381" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Ranking</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>15276</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>