<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Fri Dec 23 01:37:52 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/LDAP-101/LDAP-101.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[LDAP-101] allow eager invalidation of dirty (pooled) connections</title>
                <link>https://jira.spring.io/browse/LDAP-101</link>
                <project id="10071" key="LDAP">Spring LDAP</project>
                    <description>&lt;p&gt;If a search fails due to a connection fault, the connection should be assumed invalid. In the pooling context source implementation (single context models are similarly affected) if a connection fails it should be removed from the pool. Under current behaviour, this is only possible through validation on borrow and return, which are a certain performance hit. Worse, if the pool is heavily loaded, even with test-on-idle semantics a dirty connection may never be removed from the pool, just reused by many pool clients.&lt;/p&gt;

&lt;p&gt;Suggested solution: mark on the context that it has failed, as early as possible. For example, in the LdapTemplate#search NamingException catch block (line 295 in v1.2.1). Could be implemented using a mixin interface, for example FailureAwareDirContext. If the exception was a non-transient one (e.g. CommunicationException rather than SizeLimitExceededException) then mark on the context that it has failed. When it is returned to the pool (e.g. in DelegatingContext#close or PoolingContextSource#returnObject) check if the DirContext implements this interface, check its status and invalidate it if necessary.&lt;/p&gt;

&lt;p&gt;This solution will not provide retry for clients of the pool, but will at least prevent dirty contexts staying too long in the pool.&lt;/p&gt;</description>
                <environment></environment>
        <key id="20598">LDAP-101</key>
            <summary>allow eager invalidation of dirty (pooled) connections</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="8">Complete</resolution>
                                        <assignee username="marthursson">Mattias Hellborg Arthursson</assignee>
                                    <reporter username="joekearney">Joe Kearney</reporter>
                        <labels>
                    </labels>
                <created>Thu, 14 Feb 2008 20:25:25 +0000</created>
                <updated>Fri, 5 Feb 2016 21:17:36 +0000</updated>
                            <resolved>Wed, 11 Sep 2013 02:03:53 +0000</resolved>
                                    <version>1.2.1</version>
                                    <fixVersion>2.0.0.M1</fixVersion>
                                        <due></due>
                            <votes>2</votes>
                                    <watches>6</watches>
                                            <timeestimate seconds="0">0d</timeestimate>
                            <timespent seconds="14400">0.5d</timespent>
                                <comments>
                            <comment id="32315" author="joekearney" created="Thu, 21 Feb 2008 05:32:53 +0000"  >&lt;p&gt;Improvement to suggested solution: give protected access to the pool. This would give access to, in particular, invalidate() and evict().&lt;/p&gt;</comment>
                            <comment id="33902" author="marthursson" created="Tue, 25 Mar 2008 21:31:33 +0000"  >&lt;p&gt;Seems you have a resonable solution. Would you be willing to provide a patch?&lt;/p&gt;</comment>
                            <comment id="34005" author="joekearney" created="Thu, 27 Mar 2008 06:24:24 +0000"  >&lt;p&gt;I would be willing to, but it will take a couple of weeks to get around to it I&apos;m afraid.&lt;/p&gt;

&lt;p&gt;Incidentally, I take back my comment that giving protected access to the pool would solve the problem - it wouldn&apos;t. This needs to be fixed in org.springframework.ldap.pool.DelegatingContext#close(), which should call invalidateObject() as appropriate.&lt;/p&gt;</comment>
                            <comment id="34039" author="marthursson" created="Thu, 27 Mar 2008 22:03:19 +0000"  >&lt;p&gt;Well, we&apos;re not very close to any new release right now, so time is not that critical.&lt;/p&gt;</comment>
                            <comment id="36772" author="marthursson" created="Tue, 17 Jun 2008 19:29:22 +0000"  >&lt;p&gt;Any progress on this? We&apos;re getting closer to release now, so if this would be included we need to have it pretty soon or postpone it for next release.&lt;/p&gt;</comment>
                            <comment id="37190" author="joekearney" created="Tue, 1 Jul 2008 04:56:19 +0000"  >&lt;p&gt;Hi Mattias, Eric,&lt;/p&gt;

&lt;p&gt;The solution I used for this is fairly hacky, and works around the problem rather than solving it in the Spring-LDAP code, so I can&apos;t really submit a patch. I will describe as well as possible what I think can be done, and I hope this will be enough for you to put together a solution easily.&lt;/p&gt;

&lt;p&gt;My workaround was as follows:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;At creation (in the context source) wrap the DirContext in a proxy that catches all throwables on any method invocation.&lt;/li&gt;
	&lt;li&gt;If the caught exception is not in a set of transient exceptions (explanation later), mark the proxy as &quot;invalid&quot;, i.e. set a flag.&lt;/li&gt;
	&lt;li&gt;Enforce that the pool tests on borrow and return (don&apos;t need to bother with idle), and in validation test whether the DirContext is our FailureAwareDirContextHandler invocation handler, then test the flag as a shortcut before running any real validation (if any).&lt;/li&gt;
	&lt;li&gt;This means that by the time close() is called on the context (through LdapTemplate:309, closeContextAndNamingEnumeration()), the proxy already knows to ensure test failure.&lt;/li&gt;
	&lt;li&gt;Even running with no real validation (running a fast ldap query), any dirty connection will only live for at most one bad operation before being evicted by the flag.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Transient exceptions are exceptions thrown by the DirContext&apos;s methods that &lt;b&gt;definitely&lt;/b&gt; do not require the connection to be closed and rebuilt. A conservative list is:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;NameNotFoundException&lt;/li&gt;
	&lt;li&gt;SizeLimitExceededException&lt;/li&gt;
	&lt;li&gt;TimeLimitExceededException&lt;br/&gt;
Note that these will all be javax.naming exceptions, since we wrap the real DirContext before the rest of Spring gets a look-in.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;What I would suggest:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Add an invalidate() method (maybe through a FailureAwareContext/PooledObject interface or something, maybe something similar already exists for this?) to org.springframework.ldap.pool.DelegatingContext to simply flag when called.&lt;/li&gt;
	&lt;li&gt;In the finally block in LdapTemplate#search(...), if an exception is caught (ex != null) and the exception is not transient (as above) then check whether the context is one of these (interface or concrete type) and invalidate().&lt;/li&gt;
	&lt;li&gt;Alter DelegatingContext#close to query the flag before returnObject(), calling invalidateObject() instead as appropriate.&lt;/li&gt;
	&lt;li&gt;When LdapTemplate#closeContextAndNamingEnumeration is called for the context, close will not blindly return the possibly dirty context back to the pool.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I hope this helps, and with any luck it shouldn&apos;t require more than a few lines of code. Please contact me if I can help any more, I&apos;ll try to reply a little quicker this time!&lt;/p&gt;</comment>
                            <comment id="59331" author="ulsa" created="Sat, 16 Oct 2010 01:49:43 +0000"  >&lt;p&gt;Is this still relevant?&lt;/p&gt;</comment>
                            <comment id="70834" author="cvanes" created="Wed, 28 Sep 2011 05:24:10 +0000"  >&lt;p&gt;Is this likely to be included in an upcoming release? We&apos;re facing the same problem.&lt;/p&gt;</comment>
                            <comment id="79362" author="cvanes" created="Mon, 28 May 2012 03:58:46 +0000"  >&lt;p&gt;Any further update on this?&lt;/p&gt;</comment>
                            <comment id="93487" author="marthursson" created="Wed, 11 Sep 2013 02:03:53 +0000"  >&lt;p&gt;In the end I decided to completely handle this inside of the pooling part of the library; &lt;tt&gt;LdapTemplate&lt;/tt&gt; doesn&apos;t know and doesn&apos;t care about connections or their validity.&lt;/p&gt;

&lt;p&gt;Turned out not to be too complicated really: building on the suggestions in this thread, we now create generated proxies (implementing a new &lt;tt&gt;FailureAwareContext&lt;/tt&gt; interface) around all pooled &lt;tt&gt;DirContext&lt;/tt&gt; instances and automatically invalidate the instances when they are closed based on exceptions thrown during their usage.&lt;/p&gt;

&lt;p&gt;The only way in which my solution differs to the suggestions here is that in the end I decided against the &lt;b&gt;transient&lt;/b&gt; approach and used the exact opposite instead. This means that the &lt;tt&gt;PoolingContextSource&lt;/tt&gt; is configured with &lt;b&gt;non-transient&lt;/b&gt; Exceptions, i.e. the Exceptions that should cause eager invalidation are explicitly configured rather than implicitly assumed, which feels like a safer approach. &lt;/p&gt;

&lt;p&gt;I could really only find one Exception that should be considered non-transient out of the box, and that is &lt;tt&gt;javax.naming.CommunicationException&lt;/tt&gt;. This is the default if nothing is particularly configured. For specific requirements the &lt;tt&gt;nonTransientExceptions&lt;/tt&gt; property of &lt;tt&gt;PoolingContextSource&lt;/tt&gt; should be used, but if you guys have suggestions on other Exceptions that should cause eager invalidation int the default configuration, please let me know asap.&lt;/p&gt;</comment>
                            <comment id="123538" author="rwinch" created="Fri, 5 Feb 2016 21:17:36 +0000"  >&lt;p&gt;This issue has been migrated to &lt;a href=&quot;https://github.com/spring-projects/spring-ldap/issues/141&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/spring-projects/spring-ldap/issues/141&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 25 Mar 2008 21:31:33 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10280" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>12963</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i04zbz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>29098</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10381" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Ranking</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>24036</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>