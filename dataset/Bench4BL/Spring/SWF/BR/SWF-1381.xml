<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Fri Dec 23 06:07:04 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SWF-1381/SWF-1381.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SWF-1381] FlowExecutionImpl: handleException ignores result of another handleException</title>
                <link>https://jira.spring.io/browse/SWF-1381</link>
                <project id="10050" key="SWF">Spring Web Flow</project>
                    <description>&lt;p&gt;method handleException of class org.springframework.webflow.engine.impl.FlowExecutionImpl calls recursively if another exception during processing of original exception happens, but&lt;br/&gt;
no further check about result of exception handling (from recursive method) will be done. As result effort of another exception handling call will be ignored and oldest exception will rethrown &lt;/p&gt;

&lt;p&gt;&amp;lt;code&amp;gt;&lt;br/&gt;
boolean handled = false;&lt;br/&gt;
		try {&lt;br/&gt;
			if (tryStateHandlers(exception, context) || tryFlowHandlers(exception, context)) &lt;/p&gt;
{
				handled = true;
			}
&lt;p&gt;		} catch (FlowExecutionException newException) &lt;/p&gt;
{
			// exception handling itself resulted in a new FlowExecutionException, try to handle it
			handleException(newException, context);
		}
&lt;p&gt;		if (!handled) {&lt;br/&gt;
			if (logger.isDebugEnabled()) &lt;/p&gt;
{
				logger.debug(&quot;Rethrowing unhandled flow execution exception&quot;);
			}
&lt;p&gt;			throw exception;&lt;br/&gt;
		}&lt;br/&gt;
&amp;lt;/code&amp;gt;&lt;/p&gt;

&lt;p&gt;One of possible solution is to give method return value or to store variable handled in ThreadLocal, finally do not forget to re-throw latest not original exception if handling completely failed.&lt;/p&gt;</description>
            <key id="32710">SWF-1381</key>
            <summary>FlowExecutionImpl: handleException ignores result of another handleException</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://jira.spring.io/images/icons/priorities/minor.png">Minor</priority>
                        <status id="5" iconUrl="https://jira.spring.io/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rstoya05-aop">Rossen Stoyanchev</assignee>
                                    <reporter username="andriy.vyedyeneyev@gmx.at">Andriy Vyedyeneyev</reporter>
                        <labels>
                    </labels>
                <created>Thu, 12 Aug 2010 11:00:53 +0000</created>
                <updated>Thu, 2 Sep 2010 03:08:34 +0000</updated>
                            <resolved>Tue, 31 Aug 2010 12:24:23 +0000</resolved>
                                    <version>2.1</version>
                                    <fixVersion>2.2.0.RC1</fixVersion>
                                    <component>Core: Flow Executor</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="57045" author="rstoya05-aop" created="Tue, 24 Aug 2010 01:44:04 +0000"  >&lt;p&gt;Please confirm or correct my understanding of the scenario:  &lt;br/&gt;
1. exception A is raised but exception handling results in exception B&lt;br/&gt;
2. recursive exception handling for B succeeds and therefore handleException() returns normally&lt;br/&gt;
3. back in the top-level handleException() exception A is re-thrown because handled=false&lt;/p&gt;



</comment>
                            <comment id="57069" author="andriy.vyedyeneyev@gmx.at" created="Tue, 24 Aug 2010 09:44:24 +0000"  >&lt;p&gt;correct. Step 3 should not rethrow exception A, because it&apos;s already handled&lt;/p&gt;</comment>
                            <comment id="57070" author="rstoya05-aop" created="Tue, 24 Aug 2010 10:27:27 +0000"  >&lt;p&gt;So given that exception B was handled, then no exception should be re-thrown at all. I agree with that.&lt;/p&gt;

&lt;p&gt;Also from the original comment: &quot;finally do not forget to re-throw latest not original exception if handling completely failed&quot;. If exception B is not handled then exception B will be re-thrown so this should work. Or did you mean something else?&lt;/p&gt;</comment>
                            <comment id="57078" author="andriy.vyedyeneyev@gmx.at" created="Tue, 24 Aug 2010 14:49:54 +0000"  >&lt;p&gt;actually if recursive call handleException(newException, context);  fails then exception B will be thrown and not catched, so the rest of the method is ok. &lt;br/&gt;
Without changing method signature following snippet should do the job&lt;br/&gt;
// start&lt;/p&gt;

&lt;p&gt;try {&lt;br/&gt;
if (tryStateHandlers(exception, context) || tryFlowHandlers(exception, context)) {&lt;br/&gt;
 it&apos;s handled --&amp;gt; quit&lt;br/&gt;
 return;&lt;br/&gt;
}&lt;br/&gt;
} catch (FlowExecutionException newException) {&lt;br/&gt;
// exception handling itself resulted in a new FlowExecutionException, try to handle it&lt;br/&gt;
handleException(newException, context);&lt;br/&gt;
// quit without exception -&amp;gt; handled -&amp;gt; quit&lt;br/&gt;
return;&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;if (logger.isDebugEnabled()) {&lt;br/&gt;
logger.debug(&quot;Rethrowing unhandled flow execution exception&quot;);&lt;br/&gt;
}&lt;br/&gt;
throw exception;&lt;/p&gt;

&lt;p&gt;// end &lt;/p&gt;</comment>
                            <comment id="57103" author="rstoya05-aop" created="Tue, 24 Aug 2010 22:08:35 +0000"  >&lt;p&gt;Yes that makes sense. I will create some unit tests and experiment this fix.&lt;/p&gt;</comment>
                            <comment id="57380" author="rstoya05-aop" created="Tue, 31 Aug 2010 12:24:23 +0000"  >&lt;p&gt;I&apos;ve added a couple of test cases:&lt;br/&gt;
1. FlowExecutionImplTests.testExceptionHandledByNestedExceptionHandler() - demonstrates this issue&lt;br/&gt;
2. FlowExecutionImplTests.testExceptionHandledAvoidEndlessRecursion() - causes endless recursion&lt;/p&gt;

&lt;p&gt;The fix for #1 is very similar to the one proposed. &lt;br/&gt;
The endless recursion is handled through a simple test preventing more than 5 levels of recursion.&lt;/p&gt;</comment>
                            <comment id="57388" author="andriy.vyedyeneyev@gmx.at" created="Tue, 31 Aug 2010 15:08:14 +0000"  >&lt;p&gt;5 levels of recursion sounds for me a bit limited, i will explain my use case. &lt;/p&gt;

&lt;p&gt;1. Inside of flow execution(which is subflow) happens event, this event can&apos;t be processed by active flow (no transitions in state, no global transitions), so it should be routed to outer flow, &lt;br/&gt;
2. in outer flow event will be fired again to check if there is a handler, if no handler defined (no global transition)  then  1.) else 3.)&lt;br/&gt;
3. handle event and continue&lt;/p&gt;

&lt;p&gt;so if we have 5 as maximal recursion level, this algorithm will be limited to only 5 subflows. &lt;/p&gt;

&lt;p&gt;actually i think that probability of exception handler deadlock (the only point why we need 5 as limitation imo) is equal to probability of event ha  &lt;br/&gt;
ndler deadlock, and spring web flow as far as i know has no limits on recursive handle events. Both cases are error cases and should be handled in same way.&lt;/p&gt;

&lt;p&gt;my proposition let recursion be without limits, or try to detect cycles (may be overkill)&lt;/p&gt;</comment>
                            <comment id="57403" author="rstoya05-aop" created="Wed, 1 Sep 2010 02:26:22 +0000"  >&lt;p&gt;You make a good point that this should be left to the application. Indeed even if we stop &quot;infinite&quot; recursion throwing a FlowExecutionException at that point is arguably not any better than the StackOverflowException that would occur otherwise.&lt;/p&gt;

&lt;p&gt;I wonder though if the above scenario does apply to the exception handling recursion check though? If a NoMatchingTransitionException is raised in a subflow, then the flow execution attempts to find a matching exception handler. If there is no match, the exception is re-thrown (and bubbles up outside of web flow). If there is a match the exception handler is invoked. A second level of recursion will only occur if the exception handler itself fails and another matching exception handler is found for the new exception. &lt;/p&gt;


</comment>
                            <comment id="57475" author="andriy.vyedyeneyev@gmx.at" created="Thu, 2 Sep 2010 02:28:16 +0000"  >&lt;p&gt; Exactly, subflow will find exception handler, and during handling, which includes transition to end state and reactivation of event in outer flow, can happen exception.  &lt;/p&gt;</comment>
                            <comment id="57480" author="rstoya05-aop" created="Thu, 2 Sep 2010 03:08:34 +0000"  >&lt;p&gt;Okay, I&apos;ve backed out the test case and the check for endless recursion in handleException. &lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 24 Aug 2010 01:44:04 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i041vz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>23680</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>