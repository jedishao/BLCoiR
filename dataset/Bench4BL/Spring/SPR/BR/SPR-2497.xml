<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 19:18:29 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-2497/SPR-2497.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-2497] Transaction suspend returns connection to pool for closure causing resume to throw exception</title>
                <link>https://jira.spring.io/browse/SPR-2497</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;Please refer to posting &lt;a href=&quot;http://forum.springframework.org/showpost.php?p=74520&amp;amp;postcount=13&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://forum.springframework.org/showpost.php?p=74520&amp;amp;postcount=13&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I&apos;m utilizing Spring&apos;s transaction interceptor to manage my transactions and JtaTransactionManager as I have distributed transactions that need to occur. But the real problem is with suspend/resume and the DataSourceUtils class. It appears that there is some recursion happening. &lt;/p&gt;

&lt;p&gt;My data source is getting wrapped in a TransactionAwareDataSourceProxy in the iBatis SqlClientMapFactoryBean. &lt;/p&gt;

&lt;p&gt;When a request is made in the SqlMapClientTemplate execute method, a request is made for a connection. This is accomplished with a call to DataSourceUtils.getConnection(getDataSource()). The call to getDataSource()  returns the TransactionAwareDataSourceProxy and passes it into the getConnection method. A call is then made to doGetConnection(dataSource). The line of code is as follows:&lt;/p&gt;

&lt;p&gt;ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);&lt;/p&gt;

&lt;p&gt;This call returns null as it is the first request. The line of code executed is a logging statement:&lt;/p&gt;
</description>
            <key id="14853">SPR-2497</key>
            <summary>Transaction suspend returns connection to pool for closure causing resume to throw exception</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="cmathrusse">Chris Mathrusse</reporter>
                        <labels>
                    </labels>
                <created>Mon, 28 Aug 2006 04:27:40 +0000</created>
                <updated>Tue, 19 Jun 2012 03:51:18 +0000</updated>
                            <resolved>Sun, 3 Sep 2006 20:07:55 +0000</resolved>
                                    <version>1.2.8</version>
                    <version>2.0 RC2</version>
                    <version>2.0 RC3</version>
                                    <fixVersion>2.0 RC4</fixVersion>
                    <fixVersion>1.2.9</fixVersion>
                                    <component>Transaction</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="19228" author="cmathrusse" created="Mon, 28 Aug 2006 04:46:19 +0000"  >&lt;p&gt;Sorry, it posted before I completed. (Fat fingers...)&lt;/p&gt;

&lt;p&gt;The logging statement shows the retrieval of the Connection, then the connection is retrieved.&lt;/p&gt;

&lt;p&gt;Connection con = dataSource.getConnection();&lt;/p&gt;

&lt;p&gt;The getConnection() call is made on the TransactionAwareDataSourceProxy which in turn makes a call to DataSourceUtils.doGetConnection() and the whole process is started again, except that this time the dataSource passed in is an instance of PoolingDataSource. (Bitronix) This is where the recursion starts, 2 connectionHolders are created, one for the TransactionAwareDataSourceProxy and one for the PoolingDataSource. In effect, two Connections are retrieved and bound to ConnectionHolders.&lt;/p&gt;

&lt;p&gt;When the Transaction is suspended, these ConnectionHolders are removed from the synched resources, effectively suspending them within the suspend method in JtaTransactionManager. The synchronizations are enumerated and suspended. The first TransactionSynchronization contains the PoolingDataSource. The suspend method unbinds the data source and performs the following evaluation:&lt;/p&gt;

&lt;p&gt;if (this.connectionHolder.hasConnection() &amp;amp;&amp;amp; !this.connectionHolder.isOpen()) {&lt;/p&gt;

&lt;p&gt;The connectionHolder has a connection and it is open so the block never gets executed, keeping the connection active.&lt;br/&gt;
The next TransactionSynchronization contains the TranactionAwareDataSourceProxy. When suspend is invoked on it The same thing happens except this time the even though the method hasConnection() returns true, the method isOpen() returns false as the resourceCount in the connectionHolder has been decremented by the call to &lt;br/&gt;
TransactionSynchronizationManager.unbindResource(this.dataSource);&lt;/p&gt;

&lt;p&gt;Because this is true the if block is executed and the connection is released, returning it to the connection pool. When the transaciton is resumed, the connectionHolders are bound once again, but one connectionHolder has a handle to a connection that is closed.&lt;/p&gt;</comment>
                            <comment id="19254" author="juergen.hoeller" created="Tue, 29 Aug 2006 07:46:41 +0000"  >&lt;p&gt;Thanks for pointing this out... There seems to be some some issue with the order of suspension there. We&apos;ll resolve this for 2.0 RC4.&lt;/p&gt;

&lt;p&gt;For the time being, consider setting your SqlMapClientFactoryBean&apos;s &quot;useTransactionAwareDataSource&quot; property to &quot;false&quot;. This will expose the raw DataSource to iBATIS, not incurring conflicts between two layers of DataSources with a synchronized Connection each.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="19255" author="cmathrusse" created="Tue, 29 Aug 2006 08:58:57 +0000"  >&lt;p&gt;I did what you sugested but unfortunately there is the same problem, the connection gets returned to the datasource. The reason for this is that even though there is only on ConnectionHolder allocated now and it&apos;s reference count gets incremented and decremented correctly, but when the transaction is suspended the connection is returned to the DataSource.&lt;/p&gt;

&lt;p&gt;Going from SqlMapClientTemplate.execute() method, the Connection is retrieved using DataSourceUtils, the work is performed in doInSqlMapClient() method, and then the finally block is executed, calling DataSourceUtils.releaseConnection. (which calls doReleaseConnection) Here the ConnectionHolder is retrieved, and a test is made to see if the connection should be closed:&lt;/p&gt;

&lt;p&gt;      if (conHolder != null &amp;amp;&amp;amp; conHolder.hasConnection() &amp;amp;&amp;amp; connectionEquals(conHolder.getConnection(), con)) &lt;/p&gt;
{
        // It&apos;s the transactional Connection: Don&apos;t close it.
        conHolder.released();
        return;
      }

&lt;p&gt;Each time doReleaseConnection is called from the SqlMapClientTemplate. In the above code, the if statement equates to true each time, thus calling released() method on the connection holder. This decrements the COnnectionHolder variable referenceCount. Because this count is incremented each time doReleaseConnection is called the referenceCount is always zero after the SQL statement is executed. &lt;/p&gt;

&lt;p&gt;When the transaction is suspended a test is made to see if the ConnectionHolder has an active Connection by evaluating the referenceCount variable. Because referenceCount is equal to 0, the Connection is returned to the DataSource and effectively closed.&lt;/p&gt;</comment>
                            <comment id="19256" author="juergen.hoeller" created="Tue, 29 Aug 2006 09:07:19 +0000"  >&lt;p&gt;Thanks for pointing this out! This indeed happens with JTA synchronization and multiple levels of synchronization (which is rather rare - but as you point out, it&apos;s the default scenario in the iBATIS case). I&apos;ve fixed this to have a lower synchronization order for the higher level of nesting, that is, to close the TransactionAwareDataSourceProxy&apos;s Connection handle before the underlying Connection.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="19257" author="juergen.hoeller" created="Tue, 29 Aug 2006 09:19:31 +0000"  >&lt;p&gt;Regarding a Connection close on suspend in general: This is actually correct behavior in case of a JTA transaction (as long as that closed handle isn&apos;t accessed anymore, which it shouldn&apos;t if you switch &quot;useTransactionAwareDataSource&quot; to &quot;false&quot; - and shouldn&apos;t anymore in general with this fix I&apos;ve just committed to CVS). After resume, Spring simply fetches a new Connection handle from the DataSource - it should simply receive a fresh Connection handle that&apos;s enlisted with the same XA transaction (this is the responsibility of the JTA-aware DataSource that has to be used there). Some JTA providers, such as JBoss, even require you to return the Connection handle before you suspend a JTA transaction, and reobtain it after resume.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="19258" author="juergen.hoeller" created="Tue, 29 Aug 2006 09:22:14 +0000"  >&lt;p&gt;(P.S.: &quot;require&quot; in case of JBoss - and potentially other servers - means that things won&apos;t work properly when a Connection handle is not returned on suspend. We &lt;b&gt;must&lt;/b&gt; close the handle to return it there.)&lt;/p&gt;</comment>
                            <comment id="19265" author="cmathrusse" created="Tue, 29 Aug 2006 13:36:05 +0000"  >&lt;p&gt;I did as you said, useTransactionAwareDataSource = false, and re-ran the application. I saw a large number of connections requested from the DataSource, each still operating within the current transaction, but I still received a &quot;Connection is already closed&quot; Exception message. &lt;/p&gt;

&lt;p&gt;I understand what you are saying pertaining to the Connection, that as long as the Handle no longer has the actual connection a new connection will be retrieved from the data source. This makes sense because the next retrieved connection would be participating in the transaction. But I guess what confuses me is that I am seeing a request to the DataSource to actually close the connection. If I&apos;m not mistaken this should not occure. The connection should not ever close as commit needs to be called on it when the transaction commits or rolls back (whichever). The connection must remain open and not given out to another request as it is participating in the transaction that was suspended.&lt;/p&gt;

&lt;p&gt;I would like to pickup your modifications so I can compile and retest with them. Are your changes committed to head or another branch?&lt;/p&gt;

&lt;p&gt;Thanks for the help...&lt;/p&gt;</comment>
                            <comment id="19266" author="cmathrusse" created="Tue, 29 Aug 2006 13:53:50 +0000"  >&lt;p&gt;I may have spoken too soon. It looks as if it might be working correctly, but my transaction is rolling back due to a NullPointerException that appears to be in our application codeline. I&apos;m going to spend some more time reviewing it to ensure that my transaction does commit. &lt;/p&gt;

&lt;p&gt;I would still like to pull your changes into our app, if I can get them that is. Please let me know the branch or revision so I can sync and build.&lt;/p&gt;

&lt;p&gt;Thanks again...&lt;/p&gt;</comment>
                            <comment id="19314" author="juergen.hoeller" created="Wed, 30 Aug 2006 09:29:46 +0000"  >&lt;p&gt;The changes are available in CVS HEAD (which is the basis for all current 2.0 releases). They should also be in the next nightly build (which will hopefully be available tomorrow - we recently had trouble with our nightly build server).&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="19322" author="juergen.hoeller" created="Thu, 31 Aug 2006 01:20:59 +0000"  >&lt;p&gt;FYI, a new nightly build is now available. Feel free to give it a try!&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="19323" author="cmathrusse" created="Thu, 31 Aug 2006 03:42:53 +0000"  >&lt;p&gt;I&apos;ve downloaded it and placed in into my classpath but can&apos;t seem to get my app to run. It appears that something has changed in the way that the context.xml files are parsed. The parser is complaining about the attribute singleton on several of my bean definitions.&lt;/p&gt;

&lt;p&gt;Attribute &apos;singleton&apos; is not allowed to appear in element &apos;bean&apos;&lt;/p&gt;


&lt;p&gt;I&apos;m not certatin as to why the parser is complaining about this attribute. The schema says that the singletattribute is allowed and XML Spy states that my file is valid. &lt;/p&gt;

&lt;p&gt;Any suggestions?&lt;/p&gt;</comment>
                            <comment id="19324" author="cmathrusse" created="Thu, 31 Aug 2006 04:02:43 +0000"  >&lt;p&gt;I found it. It appears the latest release no longer supports the attribute singleton. Instead I changed the attribute to scope=&quot;prototype&quot;. The parser no longer complains.&lt;/p&gt;

&lt;p&gt;I&apos;ll keep you posted about my progress.&lt;/p&gt;</comment>
                            <comment id="19333" author="juergen.hoeller" created="Thu, 31 Aug 2006 23:37:50 +0000"  >&lt;p&gt;Indeed, we removed the &quot;singleton&quot; attribute from the 2.0 DTD and XSD files, to avoid the confusion about what happens when you specify both (we&apos;ve seen that a number of times). scope=&quot;...&quot; is the preferred syntax and is explicitly enforced for 2.0 configuration formats now. Note that the old spring-beand.dtd (as used by Spring 1.2) is still supported and still supports &quot;singleton&quot; (and doesn&apos;t have &quot;scope&quot; yet).&lt;/p&gt;

&lt;p&gt;Please let me know how transaction suspension works for you now, once you&apos;ve found out &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="19342" author="cmathrusse" created="Fri, 1 Sep 2006 03:41:29 +0000"  >&lt;p&gt;I&apos;ve done my testing with the latest nightly build and the transaction suspension appears to be working correctly. I also reverted my configuration to utilize the TransactionAwareDataDourceProxy calss once again and I am pleased to say that everything works. The transaction is suspended correctly, a new Transaction is started, work is performed and committed, and the suspended transaction is resumed without any exceptions.&lt;/p&gt;

&lt;p&gt;Thanks for making the changes so quickly. Just for my info, where was the change made?&lt;/p&gt;</comment>
                            <comment id="19364" author="juergen.hoeller" created="Sun, 3 Sep 2006 20:07:55 +0000"  >&lt;p&gt;The only change required to fix this was in DataSourceUtils. I&apos;ve introduced a &quot;getConnectionSynchronizationOrder&quot; method that determines lower synchronization for delegating handles (so that the uppermost handle is closed first, with the underlying Connection closed last). This ensures that &quot;close&quot; calls always come in the correct order, no matter in which order the sychronization registrations came in.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        10 years, 17 weeks, 3 days ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 29 Aug 2006 07:46:41 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>false</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i00w0n:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5232</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>