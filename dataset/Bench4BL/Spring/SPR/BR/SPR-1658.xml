<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 20:44:05 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-1658/SPR-1658.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-1658] Transaction completion is done in different thread in WebLogic.</title>
                <link>https://jira.spring.io/browse/SPR-1658</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;Current implementation of TransactionSychronizationManager assumes that completion of transaction will occur in the same thread that registered notification and it uses ThreadLocal variable for this purpose.&lt;br/&gt;
This is not the case in WebLogic 8,1, where completion is notified sometimes (occurs rarely) in different thread. I&apos;m not sure if this is bug or explicit design in WebLogic.&lt;br/&gt;
For sure WebLogic does parallel XA two-phase commit using two threads (for two XAResource&apos;s), but sometimes it does also transaction notifications in different thread...&lt;/p&gt;

&lt;p&gt;Such behaviour obsoletes purpose of using ThreadLocal variables for this task...&lt;/p&gt;

&lt;p&gt;Below is the stacktrace we have registered &lt;b&gt;when&lt;/b&gt; completion is done in different thread.&lt;/p&gt;

&lt;p&gt;        at org.springframework.transaction.support.AbstractPlatformTransactionManager.invokeAfterCompletion(AbstractPlatformTransactionManager.java:725)&lt;br/&gt;
        at org.springframework.transaction.jta.JtaTransactionManager.access$000(JtaTransactionManager.java:181)&lt;br/&gt;
        at org.springframework.transaction.jta.JtaTransactionManager$JtaAfterCompletionSynchronization.afterCompletion(JtaTransactionManager.java:921)&lt;br/&gt;
        at weblogic.transaction.internal.ServerSCInfo.callAfterCompletions(ServerSCInfo.java:853)&lt;br/&gt;
        at weblogic.transaction.internal.ServerTransactionImpl$CallAfterCompletionsAction.run(ServerTransactionImpl.java:2808)&lt;br/&gt;
        at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:321)&lt;br/&gt;
        at weblogic.security.service.SecurityManager.runAs(SecurityManager.java:121)&lt;br/&gt;
        at weblogic.transaction.internal.ServerTransactionImpl.callAfterCompletions(ServerTransactionImpl.java:2785)&lt;br/&gt;
        at weblogic.transaction.internal.ServerTransactionImpl.afterCommittedStateHousekeeping(ServerTransactionImpl.java:2687)&lt;br/&gt;
        at weblogic.transaction.internal.ServerTransactionImpl.setCommitted(ServerTransactionImpl.java:2719)&lt;br/&gt;
        at weblogic.transaction.internal.ServerTransactionImpl.localCommit(ServerTransactionImpl.java:1889)&lt;br/&gt;
        at weblogic.transaction.internal.ServerTransactionImpl.localCommit(ServerTransactionImpl.java:1177)&lt;br/&gt;
        at weblogic.transaction.internal.SubCoordinatorImpl.startCommit(SubCoordinatorImpl.java:226)&lt;br/&gt;
        at weblogic.transaction.internal.CoordinatorImpl_WLSkel.invoke(Unknown Source)&lt;br/&gt;
        at weblogic.rmi.internal.BasicServerRef.invoke(BasicServerRef.java:477)&lt;br/&gt;
        at weblogic.rmi.internal.BasicServerRef$1.run(BasicServerRef.java:420)&lt;br/&gt;
        at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:363)&lt;br/&gt;
        at weblogic.security.service.SecurityManager.runAs(SecurityManager.java:147)&lt;br/&gt;
        at weblogic.rmi.internal.BasicServerRef.handleRequest(BasicServerRef.java:415)&lt;br/&gt;
        at weblogic.rmi.internal.BasicExecuteRequest.execute(BasicExecuteRequest.java:30)&lt;br/&gt;
        at weblogic.kernel.ExecuteThread.execute(ExecuteThread.java:219)&lt;br/&gt;
        at weblogic.kernel.ExecuteThread.run(ExecuteThread.java:178)&lt;/p&gt;

&lt;p&gt;I suspect this can be cause for many different problems as TransactionSynchronization is used widely in Spring.&lt;/p&gt;

&lt;p&gt;Proposed fix is to implement static global per-jvm map where the key is not a thread but transaction identifier.&lt;/p&gt;

&lt;p&gt;I could not find workaround or setting in WL to disable this feature, but even then I would not do it for performance reasons...&lt;/p&gt;</description>
            <key id="13260">SPR-1658</key>
            <summary>Transaction completion is done in different thread in WebLogic.</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="tawek">Tomasz Wysocki</reporter>
                        <labels>
                    </labels>
                <created>Wed, 1 Feb 2006 22:19:05 +0000</created>
                <updated>Tue, 19 Jun 2012 03:54:21 +0000</updated>
                            <resolved>Fri, 3 Mar 2006 07:31:47 +0000</resolved>
                                    <version>1.2.6</version>
                                    <fixVersion>1.2.7</fixVersion>
                    <fixVersion>2.0 M3</fixVersion>
                                    <component>Transaction</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="16416" author="juergen.hoeller" created="Sun, 12 Feb 2006 09:18:24 +0000"  >&lt;p&gt;What exactly fails for you here? The interesting upper part of the stacktrace is missing &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Using ThreadLocals for resource handling should not be a problem, as long as Spring remains in full control over completion of the synchronizations. This should work properly in all cases, actually, since we perform all ThreadLocal handling within Spring&apos;s own transaction scope. Note that it is sufficient to reset the resource holder state here, not necessarily the actual ThreadLocal. On next access, the empty ThreadLocal is simply reused for the next resource holder.&lt;/p&gt;

&lt;p&gt;The only potentially problematic case that I see here is an existing JTA / EJB CMT transaction that calls into a Spring-defined transaction scope. In this case, our JtaTransactionManager will apply the special handling that shows in the stacktrace above, trying to register afterCompletion callbacks with the outer JTA transaction (as far as possible). However, even that should work properly, since we pass the TransactionSynchronization List into the JTA Synchronization instance, not relying on TransactionSynchronizationManager from then on.&lt;/p&gt;

&lt;p&gt;So I suspect that the problem is within a specific TransactionSynchronization&apos;s afterCompletion implementation. All our standard afterCompletion callbacks do not access ThreadLocals (or at least, not rely on them being present). The only problem I&apos;ve spotted on reviewing these is in DataSourceUtils&apos;s ConnectionSynchronization, where a potential problem might arise if a Connection handle is still open at the time of the beforeCompletion call. I&apos;ve addressed this to properly reset the state of the ConnectionHolder in such a case; however, that would just have failed on &lt;em&gt;next&lt;/em&gt; access. So I wonder which other afterCompletion impl might fail here...&lt;/p&gt;

&lt;p&gt;Hence, please submit more details on your scenario - in particular on the actual synchronizations called!&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="16488" author="juergen.hoeller" created="Sat, 18 Feb 2006 06:29:38 +0000"  >&lt;p&gt;The general rule here is: Do not access TransactionSynchronizationManager in an afterCompletion implementation, unless you absolutely have to. Prefer cleanup in beforeCompletion instead: This is the proper place to remove thread-bound resources (in most cases, anyway).&lt;/p&gt;

&lt;p&gt;As I mentioned above, the only case in Spring itself where we have to potentially deal with a resource cleanup in afterCompletion is for a JDBC Connection. Even that is a rare case, though; that only really happens with Hibernate accessing a Spring-synchronized JDBC Connection in specific scenarios.&lt;/p&gt;

&lt;p&gt;So in your case, I would simply put that unbind code into the beforeCompletion method of your TransactionSynchronization. Do you see anything that stops you from performing the cleanup early there? In normal scenarios, no application code can touch your exposed resource after the beforeCompletion phase...&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="16642" author="juergen.hoeller" created="Fri, 3 Mar 2006 07:31:47 +0000"  >&lt;p&gt;Assuming that this is clarified for the time being. TransactionSynchronizationManager cleanup (and any custom ThreadLocal cleanup) has to happen in beforeCompletion, which we do in all scenarios in Spring itself now, and which also is the recommendation for custom TransactionSynchronization implementations.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        10 years, 43 weeks, 6 days ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 12 Feb 2006 09:18:24 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>false</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i04vlz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>28495</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>