<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 21:32:14 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-12080/SPR-12080.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-12080] Add support for transaction bound application events</title>
                <link>https://jira.spring.io/browse/SPR-12080</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;Spring provides an &lt;tt&gt;ApplicationEventPublisher&lt;/tt&gt; API that can be used to publish events to other application components. By default, the events are published synchronously using a &lt;tt&gt;SimpleApplicationEventMulticaster&lt;/tt&gt; when invoking &lt;tt&gt;ApplicationEventPublisher.publishEvent(&#8230;)&lt;/tt&gt; directly.&lt;/p&gt;

&lt;p&gt;In user applications the events publish very often signal the outcome of a business action (e.g. &quot;user created&quot;). Thus it&apos;s crucial that these events are only published &lt;b&gt;if&lt;/b&gt; the transaction succeeds and thus also &lt;b&gt;after&lt;/b&gt; the transactions has concluded.&lt;/p&gt;

&lt;p&gt;In &lt;a href=&quot;https://github.com/olivergierke/spring-tx-events&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;this repository&lt;/a&gt; I built a proof of concept implementation of an &lt;tt&gt;ApplicationEventMulticaster&lt;/tt&gt; that registers a &lt;tt&gt;TransactionSynchronization&lt;/tt&gt; for &lt;tt&gt;ApplicationEvents&lt;/tt&gt; of a certain type (&lt;tt&gt;TransactionBoundApplicationEvent&lt;/tt&gt; in my case). This way, the immediate multicasting is delayed to after the transaction commit.&lt;/p&gt;

&lt;p&gt;This basically works and can be seen in action in the Spring RESTBucks example (&lt;a href=&quot;https://github.com/olivergierke/spring-restbucks/blob/master/src/main/java/org/springsource/restbucks/Restbucks.java#L73&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;necessary configuration&lt;/a&gt;, the &lt;a href=&quot;https://github.com/olivergierke/spring-restbucks/blob/master/src/main/java/org/springsource/restbucks/payment/OrderPaidEvent.java#L34&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;transaction-bound event&lt;/a&gt; and &lt;a href=&quot;https://github.com/olivergierke/spring-restbucks/blob/master/src/main/java/org/springsource/restbucks/payment/PaymentServiceImpl.java#L72&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;event throwing code&lt;/a&gt;). There are a few things that could be changed, added on top or improved:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Instead of the type-based detection of transaction-bound events could be augmented by inspecting the event object for a dedicated annotation.&lt;/li&gt;
	&lt;li&gt;Currently the special &lt;tt&gt;TransactionAwareApplicationEventMulticaster&lt;/tt&gt; has to be configured manually currently. However, it could probably registered automatically if the Spring transaction module is on the classpath. (I can also imagine Boot doing that kind of auto-configuration for now).&lt;/li&gt;
&lt;/ul&gt;
</description>
            <key id="59300">SPR-12080</key>
            <summary>Add support for transaction bound application events</summary>
                <type id="2" iconUrl="https://jira.spring.io/images/icons/issuetypes/newfeature.png">New Feature</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="8">Complete</resolution>
                                        <assignee username="snicoll">St&#233;phane Nicoll</assignee>
                                    <reporter username="olivergierke">Oliver Gierke</reporter>
                        <labels>
                    </labels>
                <created>Thu, 14 Aug 2014 08:21:15 +0000</created>
                <updated>Tue, 26 May 2015 01:14:45 +0000</updated>
                            <resolved>Tue, 10 Feb 2015 05:40:11 +0000</resolved>
                                                    <fixVersion>4.2 RC1</fixVersion>
                                    <component>Core</component>
                    <component>Transaction</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>13</watches>
                                                                <comments>
                            <comment id="107700" author="jnizet" created="Sat, 13 Sep 2014 14:24:36 +0000"  >&lt;p&gt;This is something that CDI provides and that is really missing in Spring, IMHO.&lt;/p&gt;

&lt;p&gt;Nevertheless, I&apos;d like to suggest another approach for several reasons:&lt;/p&gt;

&lt;p&gt;1. Neither the event producer nor the event itself should decide when then observing methods should be notified. Some observers of a given event might want to participate in the transaction, while others might want to be notified of the same event only after commit&lt;br/&gt;
2. Being forced to extend a Spring class to implement the event, and to provide a source for the event, is not user-friendly. Providing `this` (the current bean instance) as the source is even dangerous, IMHO, since the event observer might call back the source and bypass the proxies around the bean&lt;br/&gt;
3. Being forced to implement a Spring interface to listen to events is not user-friendly. Especially given that it only allows a component to listen to a &lt;b&gt;single&lt;/b&gt; event type. A bean should be able to listen to several event types.&lt;/p&gt;

&lt;p&gt;Here&apos;s a repo where I implement what I have in mind, and which is quite close to what CDI does. The README explains the design goals and show how to use it. The implementation works fine and should be fast at firing events. I don&apos;t know the internals of Spring well enough to know if a bean postprocessor is the best way to support this functionality, though. The implementation depends on Guava, but could easily be modified to have no dependency other than Spring. I just wanted an easy way to have a cache.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Ninja-Squad/spring-events&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/Ninja-Squad/spring-events&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The project builds and tests pass with Java 6, 7 and 8. More details are available in the javadoc, that can be generated using `./gradlew javadoc`.&lt;/p&gt;</comment>
                            <comment id="107701" author="olivergierke" created="Sat, 13 Sep 2014 17:50:45 +0000"  >&lt;p&gt;1. Do you have an example for when it&apos;s really necessary to let the observer decide whether it wants to process an even in-transaction or outside it? I really had a hard time coming up with something reasonable. I think usually the point in time you publish the event you really know which approach you need as the opposite one would create inconsistencies or not even reasonable (as the observer might not even see data not yet commited). Your consumer example is duplicating intent here as activating asynchronous event handling effectively requires after-transaction semantics. That looks like an invitation for bugs to some degree.&lt;/p&gt;

&lt;p&gt;2. The reason that is, is that the Spring ApplicationEvent publishing mechanism is currently expecting &lt;tt&gt;ApplicationEvent&lt;/tt&gt; being the base class for all events. This is very unlikely to change and switching to completely different strategy is going to make the code accepted highly unlikely. Me using &lt;tt&gt;this&lt;/tt&gt; is more of a testing issue here. Usually the source of the event is the aggregate root that caused the event.&lt;/p&gt;

&lt;p&gt;3. Using a dedicated subtype to distinguish between transaction-bound and standard events is just one way and doesn&apos;t make it too different from the current way where you have to extend &lt;tt&gt;ApplicationEvent&lt;/tt&gt;. As indicated in the original description other detection mechanisms like an annotation are thinkable. Also, as indicated in 1, I doubt that more flexibility is necessary but I&apos;ll change my mind once we come up with a good scenario that requires it.&lt;/p&gt;

&lt;p&gt;Generally speaking, the approach I provided didn&apos;t have the goal to copy the CDI eventing mechanism but rather extend the current application event mechanism in an idiomatic way. Trying to force a completely different design down Spring&apos;s throat is neither going to work nor likely to be accepted.&lt;/p&gt;

&lt;p&gt;As indicated in the current model creates dependencies to Spring on the producer and consumer side of things but a mitigating layer could easily be written on top of that. So I think extending the current mechanism with the general capability of hooking into transaction boundaries is a good step. Developers accepting the dependency can the use it as is. Purists trying to avoid it can then build whatever they want on top of that.&lt;/p&gt;</comment>
                            <comment id="107702" author="jnizet" created="Sun, 14 Sep 2014 00:54:58 +0000"  >&lt;p&gt;First of all, thanks for reading and considering my comment.&lt;/p&gt;

&lt;p&gt;1. Yes. In a real, complex application we&apos;re building (with CDI, not Spring), each time we ask a customer to reduce its electric consumption, we fire an event which&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;causes a billing record to be produced (transactional - failing to produce the billing record must prevent the electric request to be produced)&lt;/li&gt;
	&lt;li&gt;causes a monitoring task and alerts to be generated (transactional)&lt;/li&gt;
	&lt;li&gt;causes email, voice and text messages to be sent (not transactional and asynchronous, because the web services are not transactional anyway, and because we don&apos;t want these long, blocking web service calls to prevent the response to be sent).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;To me, the main point of an event mechanism is to have loose coupling between the producer and the consumers of the event. The producer shouldn&apos;t know and care about who the consumers are, and how they need to consume the event, IMHO. Regarding my example, sure this asynchronous event requires after-transaction semantics. But the reverse is not always true: you could want an after-transaction event without asynchronous consumption. And as soon as you&apos;re using asynchronous methods, yes, you need to think about transaction semantics. This doesn&apos;t look more like an invitation to bugs than being able to call an asynchronous method directly from within a transaction.&lt;/p&gt;

&lt;p&gt;2. I know and understand this. But this looks, to me, like legacy design, that doesn&apos;t match with the annotation-based strategy generally preferred in Spring nowadays. Just like old inheritance-based MVC controllers (MultiActionController, etc.) were replaced by RequestMapping-annotated methods, and PostConstruct-annotated methods are now preferred to implementing InitializingBean. The fact that a component can only listen to one kind of event is really something that bothers me in the current design. Many much more important parts of Spring were completely overhauled in the past to rely on annotations and loose-coupling. Events could follow the same route.&lt;/p&gt;

&lt;p&gt;I understand that my proposition doesn&apos;t fit into the current event model, but the beauty of Spring is that it&apos;s open and flexible enough to allow me to use my code without waiting for official Spring support. I just wanted to provide food for thought. If Spring starts considering improvements to its event model, I&apos;d prefer it to go my suggested way, rather than to patch the current poor (IMO) model.&lt;/p&gt;</comment>
                            <comment id="111539" author="snicoll" created="Mon, 12 Jan 2015 23:51:01 +0000"  >&lt;p&gt;Annotation-based event listener is on the agenda for 4.2 (see &lt;a href=&quot;https://github.com/snicoll/spring-framework/commit/1bb2a206fc1f5889f793bd5034d44660c161d61d&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;1bb2a20&lt;/a&gt; and my &lt;tt&gt;event&lt;/tt&gt; branch of my fork). Removing the need for an &lt;tt&gt;ApplicationEvent&lt;/tt&gt; is not on the agenda however and I must say I am still a bit confused as how we could approach this. Jean-Baptiste, this addresses your point 3 but not (yet) point 2.&lt;/p&gt;

&lt;p&gt;As for who decides what, I find very disturbing that an event could cause the current transaction to fail; events are processed synchronously by default but you can configure a &lt;tt&gt;TaskExecutor&lt;/tt&gt; to run them asynchronously. Even if it was invoked synchronously, I would find it acceptable that the actual exception thrown by an event listener is not thrown back at me (which is what you use to rollback the current transaction I assume). Decoupling means decoupling, not decoupled components that could rollback a transaction they&apos;re not supposed to have access to...&lt;/p&gt;

&lt;p&gt;If we take that out for a second (I guess you&apos;ll disagree since that&apos;s your current design &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; ), then events &lt;b&gt;can&lt;/b&gt; be transactional or we don&apos;t really care. There are two says to tackle this.&lt;/p&gt;

&lt;h4&gt;&lt;a name=&quot;Theproducersenda%22transactionalevent%22&quot;&gt;&lt;/a&gt;The producer send a &quot;transactional event&quot;&lt;/h4&gt;

&lt;p&gt;Either with a base class or by adding a &lt;tt&gt;@TransactionalEvent&lt;/tt&gt; &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/help_16.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; on the &lt;tt&gt;ApplicationEvent&lt;/tt&gt; type. Either way, we can configure the &lt;em&gt;phase&lt;/em&gt; at which the event should be fired (through admittedly, I haven&apos;t found a use  case for getting the event only if the transaction rollbacks for instance). This puts the event listener completely in the blind: it receives an event (at the right time) and processes it. &lt;/p&gt;

&lt;p&gt;Of course this should only happen if a transaction is actually running.&lt;/p&gt;

&lt;h4&gt;&lt;a name=&quot;Thereceiverrequesta%22transactionalevent%22&quot;&gt;&lt;/a&gt;The receiver request a &quot;transactional event&quot;&lt;/h4&gt;

&lt;p&gt;We could easily flag a receiver to be transactional if we  wanted to &lt;tt&gt;TransationalEventListener&lt;/tt&gt; ?) and register the proper &lt;tt&gt;TransactionSynchronization&lt;/tt&gt; callback when we loop over the listeners. This would require to break &lt;tt&gt;SmartApplicationListener&lt;/tt&gt; probably to give us the extra info. If we put the use case of rollbacking the current transaction aside, I don&apos;t really see how that would make sense. The listener should consume and process the event and should not decide &quot;when&quot; to receive it.&lt;/p&gt;

&lt;p&gt;Putting your &quot;billing record&quot; use case on the table again, this looks like something you could (should) do without the event infrastructure.&lt;/p&gt;

&lt;p&gt;Thoughts?&lt;/p&gt;

</comment>
                            <comment id="111541" author="jnizet" created="Tue, 13 Jan 2015 00:54:24 +0000"  >&lt;p&gt;Being forced to extend a Spring class for the event is not ideal, but it&apos;s not the most bothering thing. I can live with that.&lt;/p&gt;

&lt;p&gt;To me, not being able to cause a transaction to rollback from a synchronous event would really be a showstopper, though, and I don&apos;t think it&apos;s viable anyway. In a typical Spring + JPA/Hibernate application, you want your event listener to be able to access the database, and see its state as it is in the current transaction. You&apos;re thus de facto in the current transaction. And if you blindly catch exceptions thrown from the listener method (potentially by JPA/Hibernate) as if nothing happened, you&apos;ll be in a situation where the main method continues executing, but with a persistence context/hibernate session that is not usable anyway, since JPA/Hibernate exceptions are not recoverable and leave the context/session in an inconsistent state.&lt;/p&gt;

&lt;p&gt;Sure, I could implement my billing record use-case without the event infrastructure. But it wouldn&apos;t be as elegant, would be tightly coupled, and would introduce hard to remove circular dependencies between modules: the billing module needs to access the operation module to get details about the operation to bill, and the operation module needs to access the billing module to inform it that a new operation must be billed. This is easily and elegantly solved by using synchronous events that participate in the current transaction and allow it to rollback.&lt;/p&gt;

&lt;p&gt;Again, I&apos;m not inventing a new wheel here. Synchronous events throwing exceptions and causing the transaction to rollback exist in CDI. And not only that: that&apos;s the *&lt;b&gt;default&lt;/b&gt;* behavior. Quote from the spec:&lt;/p&gt;

&lt;p&gt;&amp;gt; Observer methods may throw exceptions:&lt;br/&gt;
&amp;gt;    If the observer method is a transactional observer method, any exception is caught and logged by the container.&lt;br/&gt;
&amp;gt;    Otherwise, the exception aborts processing of the event. No other observer methods of that event will be called. The BeanManager.fireEvent() or Event.fire() method rethrows the exception. If the exception is a checked exception, it is wrapped and rethrown as an (unchecked) ObserverException.&lt;/p&gt;

&lt;p&gt;And again, being able to process the same event in two different ways, and thus to decide that at the listener side is a real usecase to me. Once again, that&apos;s how it&apos;s done in CDI and that has proven to be useful and practical. See &lt;a href=&quot;http://docs.oracle.com/javaee/6/api/javax/enterprise/event/Observes.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://docs.oracle.com/javaee/6/api/javax/enterprise/event/Observes.html&lt;/a&gt;. &lt;/p&gt;</comment>
                            <comment id="111543" author="snicoll" created="Tue, 13 Jan 2015 02:23:16 +0000"  >&lt;p&gt;I do know how CDI works &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Again, that&apos;s just an opinion and I am happy to open the discussion to a wider group. &lt;/p&gt;</comment>
                            <comment id="112143" author="snicoll" created="Mon, 2 Feb 2015 01:57:49 +0000"  >&lt;p&gt;Here is a &lt;a href=&quot;https://github.com/snicoll/spring-framework/commit/ece621f8cb324cf675454fdc31d650fc128f15b6&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;first cut of the implementation&lt;/a&gt; (you can look at that branch to check other related commits). It definitely needs some review for corner cases and I want to triple check the potential side effect of using &lt;tt&gt;@TransactionalEventListener&lt;/tt&gt; together with &lt;tt&gt;@Transactional&lt;/tt&gt; in the after completion phase. &lt;/p&gt;

&lt;p&gt;Of course, a first look at the current proposal would be great, please let me know if you find anything suspicious. &lt;/p&gt;</comment>
                            <comment id="112173" author="olivergierke" created="Mon, 2 Feb 2015 13:10:46 +0000"  >&lt;p&gt;Awesome, St&#233;phane, I very much like what I see! Great work! Added a few minor comments to the commit but basically it&apos;s a very much improved successor of what I originally imagined and should actually also cover the use cases &lt;a href=&quot;https://jira.spring.io/secure/ViewProfile.jspa?name=jnizet&quot; class=&quot;user-hover&quot; rel=&quot;jnizet&quot;&gt;Jean-Baptiste Nizet&lt;/a&gt; outlined, right? Although it will only cover the simple after-commit use case, I&apos;ll go ahead and update Spring RESTBucks to use that new stuff in a branch and see how this works out. Will keep you posted!&lt;/p&gt;</comment>
                            <comment id="112332" author="snicoll" created="Fri, 6 Feb 2015 09:49:56 +0000"  >&lt;p&gt;Thanks Ollie! The code has ben revisited and is available on my branch:&lt;br/&gt;
&lt;a href=&quot;https://github.com/snicoll/spring-framework/commits/event&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/snicoll/spring-framework/commits/event&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jira.spring.io/secure/ViewProfile.jspa?name=jnizet&quot; class=&quot;user-hover&quot; rel=&quot;jnizet&quot;&gt;Jean-Baptiste Nizet&lt;/a&gt; would you mind looking at it as well?&lt;/p&gt;</comment>
                            <comment id="112346" author="jnizet" created="Sat, 7 Feb 2015 00:09:57 +0000"  >&lt;p&gt;Sorry for not having taken the time to review this sooner.&lt;/p&gt;

&lt;p&gt;I won&apos;t comment on the internals of the implementation, because you&apos;re much more qualified than me on this. But this looks great regarding the end-user API. So, to recap, please correct me if I&apos;m wrong:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;an event can be any class, or event a generic type (i.e. Foo&amp;lt;Bar&amp;gt; can be treated differentiated from Foo&amp;lt;Baz&amp;gt;)&lt;/li&gt;
	&lt;li&gt;you can annotate any method with a single argument of a Spring bean with @EventListener. In this case the method is called when the event is published, the return type is treated as a new event, and any exception is wrapped into a runtime exception and thrown. The method can also be annotated with Async for the event to be handled asynchronously&lt;/li&gt;
	&lt;li&gt;for more transactional semantics, any such method can be annotated with @TransactionalEventListener. The same rules apply, except the listener is called, immediately, before commit, after commit or after rollback depending on the phase attribute of the annotation.&lt;/li&gt;
	&lt;li&gt;this annotation can also be used to define meta-annotations&lt;/li&gt;
	&lt;li&gt;you publish an event by calling a method of the Spring application context.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If all that is correct, it all looks great to me, except I would find it cleaner if there was an interface, implemented by an injectable bean, that could be used to publish events. I could of course define such an interface and such a bean myself, so that&apos;s not a big problem:&lt;/p&gt;

&lt;p&gt;    @Autowired&lt;br/&gt;
    private EventPublisher eventPublisher;&lt;/p&gt;

&lt;p&gt;    public void someServiceMethod() &lt;/p&gt;
{
        eventPublisher.publish(new UserRegistered(userId);
    }</comment>
                            <comment id="112377" author="snicoll" created="Mon, 9 Feb 2015 06:26:32 +0000"  >&lt;p&gt;That&apos;s ok. There&apos;s no &lt;em&gt;immediate&lt;/em&gt; phase for &lt;tt&gt;@TransactionalEventListener&lt;/tt&gt;, just use &lt;tt&gt;@EventListener&lt;/tt&gt; if you want to listen to the event immediately. &lt;/p&gt;

&lt;p&gt;There is an interface to publish an event and it already exists (it was just extended a bit). just inject &lt;tt&gt;ApplicationEventPublisher&lt;/tt&gt; in your code and you&apos;ll get that publish method. The context implements the interface so it&apos;s always available .&lt;/p&gt;</comment>
                            <comment id="114315" author="olivergierke" created="Wed, 8 Apr 2015 02:31:38 +0000"  >&lt;p&gt;I just created &lt;a href=&quot;https://github.com/olivergierke/spring-examples/blob/90c29a48df88a3128446b034170087260f6a26a3/4.2/src/main/java/example/events/EventsSample.java#L80&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;an example&lt;/a&gt; for this and wondered why we have &lt;tt&gt;BEFORE_COMMIT&lt;/tt&gt; but no &lt;tt&gt;BEFORE_ROLLBACK&lt;/tt&gt;?&lt;/p&gt;</comment>
                            <comment id="114325" author="snicoll" created="Wed, 8 Apr 2015 04:42:57 +0000"  >&lt;p&gt;No reason. Except this: why would you use that? You know the current transaction is going to rollback...&lt;/p&gt;</comment>
                            <comment id="114326" author="olivergierke" created="Wed, 8 Apr 2015 04:49:31 +0000"  >&lt;p&gt;I saw there&apos;s not even a method in &lt;tt&gt;TransactionSynchronization&lt;/tt&gt; to support this. I was just puzzled by asymmetry. I can imagine notifying someone about the fact that an event has been triggered but the event publishing code rolling back. Just wanted to make sure it&apos;s not an oversight.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="49006">SPR-10633</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10151">
                    <name>Relate</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="56768">SPR-11622</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        1 year, 37 weeks, 1 day ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 13 Sep 2014 14:24:36 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>false</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>snicoll</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i07s6f:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>45437</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>