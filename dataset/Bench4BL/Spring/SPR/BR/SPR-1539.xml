<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 19:28:24 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-1539/SPR-1539.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-1539] Spring 1.2.6 version of DataSourceUtils.suspend() method causes an IllegalArgumentException to be thrown when using inner transaction with PROPOGATION_REQUIRES_NEW.</title>
                <link>https://jira.spring.io/browse/SPR-1539</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;DataSourceUtils.suspend() has been changed in version 1.2.6 to release a connection on suspend if the application doesn&apos;t keep a handle to it anymore. If working with more than one connection in a transaction this can cause problems with the TransactionSynchronizationManager in the AbstractPlatformTransactionManager.suspend(Object) method.&lt;/p&gt;

&lt;p&gt;If you have two transactions running, one within the other with a propogation of &quot;PROPOGATION_REQUIRES_NEW&quot;, then when the inner transaction runs, the connections in the suspendedSynchronizations list within the AbstractPlatformTransactionManager.suspend(Object) are released on suspension in DataSourceUtils.suspend(), (since 1.2.6). If the inner transaction is running within a loop then on the second run of the loop, the AbstractPlatformTransactionManager.suspend(Object) will try to release the connections again using DataSourceUtils.suspend(), resulting in  IllegalArgumentException : Active Connection is required.&lt;/p&gt;

&lt;p&gt;The following pseudo-code below can reproduce the exception.&lt;/p&gt;

&lt;p&gt;        // Set up two Data Sources to two different databases....&lt;/p&gt;

&lt;p&gt;        LazyConnectionDataSourceProxy dataSourceA = ................&lt;br/&gt;
        ..............&lt;br/&gt;
        ...............&lt;/p&gt;

&lt;p&gt;        LazyConnectionDataSourceProxy dataSourceB = ................&lt;br/&gt;
        ..............&lt;br/&gt;
        ...............&lt;/p&gt;


&lt;p&gt;        // Set up a Jdbc template for each Datasource....&lt;br/&gt;
        final JdbcTemplate jdbcTemplateA = new JdbcTemplate(dataSourceA);&lt;br/&gt;
        final JdbcTemplate jdbcTemplateB = new JdbcTemplate(dataSourceB);&lt;/p&gt;


&lt;p&gt;        // Set up Transaction Template on dataSourceA with PROPAGATION_REQUIRES_NEW....&lt;/p&gt;

&lt;p&gt;        DataSourceTransactionManager dstm = new DataSourceTransactionManager(dataSourceA);&lt;br/&gt;
        ptm.afterPropertiesSet();	        &lt;br/&gt;
        final TransactionTemplate transactionTemplate = new TransactionTemplate();&lt;br/&gt;
        transactionTemplate.setTransactionManager(dstm);&lt;br/&gt;
        transactionTemplate.setPropagationBehavior( TransactionTemplate.PROPAGATION_REQUIRES_NEW );&lt;br/&gt;
        transactionTemplate.afterPropertiesSet();&lt;/p&gt;

&lt;p&gt;        // Execeute outer transaction.........&lt;br/&gt;
        transactionTemplate.execute( new TransactionCallbackWithoutResult() {&lt;br/&gt;
    		public void doInTransactionWithoutResult(TransactionStatus status) {&lt;/p&gt;

&lt;p&gt;                                          Execute a query using both connections.........                         &lt;br/&gt;
		jdbcTemplateA.execute( &quot;select top 1 * from TableA&quot;); &lt;br/&gt;
                                           jdbcTemplateB.execute( &quot;select top 1 * from TableB&quot; );&lt;/p&gt;

&lt;p&gt;                                          // Loop round inner transaction - exception is thrown in second loop............&lt;br/&gt;
               	                     for (int j=0; j &amp;lt; 2; j++) {         		&lt;br/&gt;
               		         transactionTemplate.execute( new TransactionCallbackWithoutResult() {&lt;br/&gt;
    					public void doInTransactionWithoutResult(TransactionStatus status) {}&lt;br/&gt;
    				});&lt;br/&gt;
               	}&lt;br/&gt;
    	    }		&lt;br/&gt;
        } );&lt;/p&gt;</description>
            <key id="12940">SPR-1539</key>
            <summary>Spring 1.2.6 version of DataSourceUtils.suspend() method causes an IllegalArgumentException to be thrown when using inner transaction with PROPOGATION_REQUIRES_NEW.</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="1" iconUrl="https://jira.spring.io/images/icons/priorities/blocker.png">Blocker</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="willparker">William Parker</reporter>
                        <labels>
                    </labels>
                <created>Wed, 14 Dec 2005 21:23:01 +0000</created>
                <updated>Tue, 19 Jun 2012 03:54:40 +0000</updated>
                            <resolved>Wed, 21 Dec 2005 22:43:51 +0000</resolved>
                                    <version>1.2.6</version>
                                    <fixVersion>1.2.7</fixVersion>
                    <fixVersion>2.0 M1</fixVersion>
                                    <component>Core</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                <comments>
                            <comment id="15841" author="juergen.hoeller" created="Wed, 21 Dec 2005 22:43:51 +0000"  >&lt;p&gt;Thanks for the report! This is an unfortunate bug that slipped into 1.2.6... It&apos;s easy enough to fix, though:&lt;/p&gt;

&lt;p&gt;Patch Spring 1.2.6&apos;s DataSourceUtils, line 339, to the following:&lt;/p&gt;

&lt;p&gt;  if (this.connectionHolder.hasConnection() &amp;amp;&amp;amp; !this.connectionHolder.isOpen()) {&lt;/p&gt;

&lt;p&gt;I.e. add the this.connectionHolder.hasConnection() check there.&lt;/p&gt;

&lt;p&gt;Call &quot;build alljars&quot; in the root of your Spring distribution to generate updated jars.&lt;/p&gt;

&lt;p&gt;The upcoming Spring 2.0 M1 release (today) will contain this fix, as well as a likely 1.2.7 update release (in January).&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="16148" author="shorecode" created="Wed, 25 Jan 2006 05:23:37 +0000"  >&lt;p&gt;I think I might be experiencing a similar issue (no nested Transaction though) but am&lt;br/&gt;
not sure if it is caused by the same fix.  &lt;/p&gt;

&lt;p&gt;Start TX1&lt;br/&gt;
       Access DataSourceX&lt;br/&gt;
      Call service Z that is TX_NOT_SUPPORTED, which causes TX1 to be suspended.&lt;br/&gt;
      Complete Z service call and get result, which should cause TX1 to be resumed.&lt;br/&gt;
      Access same DataSourceX.&lt;br/&gt;
      Call service Z again that is TX_NOT_SUPPORTED, which will cause TX1 to be suspended again.&lt;br/&gt;
      This bombs with IllegalArgumentException: Active Connection is required.&lt;/p&gt;

&lt;p&gt;Strange thing though is that if I try it again (brand new TX2) after&lt;br/&gt;
failing, it will not bomb and all is good.  &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="16149" author="juergen.hoeller" created="Wed, 25 Jan 2006 07:21:24 +0000"  >&lt;p&gt;This sounds like an issue with the same root cause, so it should be fixed in 2.0 M1 as well.&lt;/p&gt;

&lt;p&gt;Could you please give 2.0 M1or a recent 2.0 M2 nightly snapshot a try and let me know whether it works for you there?&lt;/p&gt;

&lt;p&gt;FYI, we&apos;ll release a 1.2.7 release any day now, among other things containing this fix. It would be good to verify your scenario before, though.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="16308" author="rhoepner" created="Fri, 3 Feb 2006 02:55:40 +0000"  >&lt;p&gt;I could only get rid of this problem, when i completely disabled the release(...) on the connection holder&lt;/p&gt;

&lt;p&gt;		public void suspend() {&lt;br/&gt;
			if (this.holderActive) {&lt;br/&gt;
				TransactionSynchronizationManager.unbindResource(this.dataSource);&lt;br/&gt;
//				if (this.connectionHolder.hasConnection() &amp;amp;&amp;amp; !this.connectionHolder.isOpen()) &lt;/p&gt;
{
//					// Release Connection on suspend if the application doesn&apos;t keep
//					// a handle to it anymore. We will fetch a fresh Connection if the
//					// application accesses the ConnectionHolder again after resume,
//					// assuming that it will participate in the same transaction.
//					releaseConnection(this.connectionHolder.getConnection(), this.dataSource);
//					this.connectionHolder.setConnection(null);
//				}
&lt;p&gt;			}&lt;br/&gt;
		}&lt;/p&gt;

&lt;p&gt;because it blows up the number of database connections i might possably use in one jta transaction. &lt;/p&gt;

&lt;p&gt;If i have a sequence like this&lt;/p&gt;

&lt;p&gt;1) REQUIRES_NEW&lt;br/&gt;
   2) REQUIRED&lt;br/&gt;
      3) NOT_SUPPORTED&lt;br/&gt;
   4) REQUIRED&lt;/p&gt;

&lt;p&gt;the database operations performed during 4. have no chance to run on the same database connection like 2. (JDBCTemplate will always release referenceCount to 0 in ResourceHolderSupport).&lt;br/&gt;
This results in a new database connection participating in the jta transaction. It might be commited (depends on the jta implementation, oracle does, jotm does not) as it will be enlisted as &lt;br/&gt;
XAResource in the javax.transaction.Transaction, but who wants to commit lot&apos;s of database connections, if one would be sufficient. Not talking about isolation...&lt;/p&gt;

&lt;p&gt;By the way, great framework!&lt;/p&gt;

&lt;p&gt;Reinhard&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        10 years, 47 weeks, 6 days ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 21 Dec 2005 22:43:51 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>true</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i04vrr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>28521</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>