<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 18:27:20 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-1671/SPR-1671.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-1671] Option to expose empty value instead of NullValueInNestedPathException</title>
                <link>https://jira.spring.io/browse/SPR-1671</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;When using nested paths such as &quot;organisation.address.state&quot; with a property editor for State intended to convert a String ID to a State object and back again, if address is null, a &apos;NullValueInNestedPathException&apos; is thrown from BeanWrapperImpl.  Is this the intended behaviour ?  &lt;/p&gt;

&lt;p&gt;Obviously if part of the nested path is null it is impossible to traverse the object graph to determine what property editor to use for the actual State property.  However, if address is null then State is sure to be null also, so a generic handler of nulls could be possibly be applied.&lt;/p&gt;

&lt;p&gt;The current workaround is to manually populate empty objects in the object graph in formBackingObject().  This does however require that these &apos;empty&apos; placeholder objects need to be cleaned up before a save to prevent complications with incorrect data being pushed to the database.&lt;/p&gt;</description>
            <key id="13278">SPR-1671</key>
            <summary>Option to expose empty value instead of NullValueInNestedPathException</summary>
                <type id="4" iconUrl="https://jira.spring.io/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://jira.spring.io/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="3">Duplicate</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="robmonie">Rob Monie</reporter>
                        <labels>
                    </labels>
                <created>Sun, 5 Feb 2006 09:50:52 +0000</created>
                <updated>Tue, 19 Jun 2012 02:28:19 +0000</updated>
                            <resolved>Thu, 26 Nov 2009 14:44:51 +0000</resolved>
                                    <version>1.2.6</version>
                                                    <component>Web</component>
                        <due></due>
                            <votes>38</votes>
                                    <watches>37</watches>
                                                                <comments>
                            <comment id="16405" author="juergen.hoeller" created="Sun, 12 Feb 2006 05:35:33 +0000"  >&lt;p&gt;This is actually intended behavior: BeanWrapper does not support handling properties that have an incomplete nested path.&lt;br/&gt;
We do not consider such a non-existent nested value to be null by default, in contrast to (for example) the JSP EL.&lt;/p&gt;

&lt;p&gt;However, you should be able to register property editors for such paths. They just shouldn&apos;t get applied in case of a null value in the path...&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="16423" author="robmonie" created="Sun, 12 Feb 2006 12:45:32 +0000"  >&lt;p&gt;Thanks Juergen.  I know this isn&apos;t the place to be asking questions but i&apos;m a little confused as to the intended way of dealing with this.  As soon as I try to bind a nested path with a null value in any position other than the final object in the graph, a NullValueInNestedPathException is thrown.  Regardless of whether this is the intended behaviour of BeanWrapper, this seems odd.  I am definately able to register property editors for these types of paths but if a null value exists in the path, an exception is thrown well before the property editor can be applied.   &lt;/p&gt;

&lt;p&gt;Are you confirming that my workaround described above is the recommended way of approaching this problem or am I missing something that would negate the need for populating empty placeholder objects to enable traversal of the object graph ?  This topic isn&apos;t covered in any of the books or reference material I have available to me.&lt;/p&gt;</comment>
                            <comment id="16565" author="juergen.hoeller" created="Wed, 22 Feb 2006 21:00:54 +0000"  >&lt;p&gt;I guess this mainly applies to retrieving the current value of a property, doesn&apos;t it - since we really can&apos;t do much about an attempt to &lt;em&gt;set&lt;/em&gt; a nested property with a null value in the path.&lt;/p&gt;

&lt;p&gt;So essentially, you&apos;d like to be able to treat a &apos;NullValueInNestedPathException&apos; such that a plain empty value is exposed instead? Similar to what the &amp;lt;c:out&amp;gt; tag does in JSTL?&lt;/p&gt;

&lt;p&gt;We could only support that for specific output mechanisms, for example the &amp;lt;spring:bind&amp;gt; tag. And even there it should be optional, since else there&apos;s the risk of swallowing an exception that you might not be aware of. The problem is that a subsequent attempt to set that field will fail - and of course that&apos;s what the &amp;lt;spring:bind&amp;gt; tag is there for in the first place.&lt;/p&gt;

&lt;p&gt;Hence, I&apos;d argue that you should use the JSTL &amp;lt;c:out&amp;gt; tag whereever you&apos;d like to treat incomplete nested paths simply as empty String values...&lt;/p&gt;

&lt;p&gt;In general, pre-populating the object graph to actually have the accessed fields in there is the recommended solution. I do see that it can be a nuisance to clean up the object graph afterwards. Nevertheless, this looks like the only proper way that cleanly allows for populating fields as well.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="16569" author="robmonie" created="Wed, 22 Feb 2006 23:02:30 +0000"  >&lt;p&gt;Thanks Juergen. I appreciate your response!&lt;/p&gt;

&lt;p&gt;Rob&lt;/p&gt;</comment>
                            <comment id="20485" author="pmularien" created="Fri, 27 Oct 2006 00:50:30 +0000"  >&lt;p&gt;+1 vote for fixing this issue. It is a nuisance to have to populate an object (especially a complex one) with empty object trees, only to have to clean them up later. I actually disagree with Juergen:&lt;/p&gt;

&lt;p&gt;&quot;Hence, I&apos;d argue that you should use the JSTL &amp;lt;c:out&amp;gt; tag whereever you&apos;d like to treat incomplete nested paths simply as empty String values... &quot;&lt;/p&gt;

&lt;p&gt;Instead, I would expect that spring:bind would take its cue on behavior &lt;em&gt;from&lt;/em&gt; the JSTL out tag, and instead simply log a warning if the requested bind path is null/not present, and set the BindStatus to null. This way references to &quot;status.foo&quot; will simply resolve (as consistent with JSTL semantics) to null/empty, and output within the &amp;lt;spring:bind&amp;gt; would function as expected, without errors.&lt;/p&gt;

&lt;p&gt;I would put this suggestion for improvement under the heading of &quot;the &lt;span class=&quot;error&quot;&gt;&amp;#91;Spring&amp;#93;&lt;/span&gt; framework should predictably and non-destructively handle simple error conditions in pages&quot;. It would remove unneeded complexity (referenced by Rob) from the developer of the controller, and would improve consistency with other tags in JSTL.&lt;/p&gt;

&lt;p&gt;I&apos;d be happy to contribute a patch if Juergen agrees with this behavior.&lt;/p&gt;</comment>
                            <comment id="20488" author="juergen.hoeller" created="Fri, 27 Oct 2006 03:33:39 +0000"  >&lt;p&gt;As outlined above, the problem is not so much the retrieval of a value for display - we could quite easily use a fallback to an empty String there, similar to the JSTL&apos;s &amp;lt;c:out&amp;gt;. The problem is rather that &amp;lt;spring:bind&amp;gt;&apos;s main purpose is to populate the target field on submit of the page - and if the bind path contains a null value, this is gonna fail in any case... Hence, such a fallback would only make sense for read-only fields that the user cannot edit. But why wouldn&apos;t you simply use &amp;lt;c:out&amp;gt; or some other standard means to display such a field? Just for consistency with the code for read-write fields?&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="20492" author="pmularien" created="Fri, 27 Oct 2006 04:43:29 +0000"  >&lt;p&gt;Right, display is (should be) trivial, and should function (or be configurable to function) like c:out. Right now, if I try to &amp;lt;spring:bind&amp;gt; a nested path expression that traverses a relationship where an intervening object is currently null (the &quot;address&quot; portion of the example in the bug report), I get a NullValueInNestedPathException thrown. This is thrown by the getPropertyValue method of BeanWrapperImpl. &lt;/p&gt;

&lt;p&gt;In the reverse case, which you mention (setting property), it is again BeanWrapperImpl which throws NullValueInNestedPath within the setPropertyValue method.&lt;/p&gt;

&lt;p&gt;So the enhancement on the &amp;lt;spring:bind&amp;gt; side (getPropertyValue) is relatively trivial - BindTag would need to be enhanced to catch NullValueInNestedPath and set the status model object to null.&lt;/p&gt;

&lt;p&gt;Handling setPropertyValue&apos;s throwing of the exception would have to take place in the databinder code. The question is - who is responsible for creation of the intervening object (&quot;address&quot;, in this case)? If we assume that there were an obvious API, then the databinder could (be configured to), upon receiving of NullValueInNestedPath from the setPropertyValue API, create the intervening object(s) and try again.&lt;/p&gt;

&lt;p&gt;One sees this technique being applied in several suggestions in the forums in the use case of array and list items not existing, where the pattern established by commons&apos; ListUtils.lazyList is used.&lt;/p&gt;

&lt;p&gt;Creating the intervening objects could easily be accomplished by use of a property editor, calling setValue on the property editor with a value of null - this could trigger the property editor author to ensure that his/her property editor returns a new object &amp;#8211; this is consistent with behavior established in the JavaBeans contract.&lt;/p&gt;</comment>
                            <comment id="21641" author="superpuma" created="Fri, 5 Jan 2007 00:14:36 +0000"  >&lt;p&gt;I&apos;d certainly like to see this fixed. I came across this issue looking for a solution for my current problem with NullValueInNestedPathException.&lt;/p&gt;

&lt;p&gt;In my case I&apos;ve been trying to bind values to a domain object. I didn&apos;t use the bind tag, just set the name attribute on the input field. I&apos;ll look into bind tag next. But it seems that this won&apos;t solve the problem anyway.&lt;/p&gt;

&lt;p&gt;It&apos;s impossible to bind values that originally contained null. So, these values cannot be updated without some kind of workaround... Although I came across this quite recently and might now have the full picture, I can&apos;t really see the rationale for the current implementation. Populating all non-leaf nodes prior to rendering would probably be the solution. This is just such a hassle, when it seems that an easier solution could be implemented.&lt;/p&gt;</comment>
                            <comment id="21648" author="adressin" created="Fri, 5 Jan 2007 05:14:16 +0000"  >&lt;p&gt;&quot;This is actually intended behavior: BeanWrapper does not support handling properties that have an incomplete nested path. &quot;&lt;/p&gt;

&lt;p&gt;I am interested in why this is intended. Other web frameworks with binding capabilities will instantiate the nested object graph as needed while binding. Why should the binding process care if a nested property was not explicitly instantiated? In my opinion it is VERY annoying to have to manage the creation of nested object graphs... esp. in large cases. My hope is that I can leave the object creation to the binding process, and handle any application-specific issues with the binded data to the validation process.&lt;/p&gt;</comment>
                            <comment id="22111" author="samxxu" created="Wed, 7 Feb 2007 18:15:01 +0000"  >&lt;p&gt;It makes me crazy.  so strange!&lt;/p&gt;</comment>
                            <comment id="22113" author="robmonie" created="Wed, 7 Feb 2007 19:35:32 +0000"  >&lt;p&gt;As Juergen said, it makes sense to return null or an empty string rather than throwing an exception for display purposes although it will cause problems if you try to then bind against this field on form submission.  I can&apos;t think of any way a framework could reliably instantiate objects in the graph for binding against unless they were limited to a no arg constructor or BeanWrapper imposed some other approach for instantiating objects.  This might work for some apps but most of the apps i&apos;ve worked on have required far more than simple model objects that can be instantiated in this way.&lt;/p&gt;

&lt;p&gt;Since originally submitting this issue my colleagues and I have done a significant amount of work in this area writing an open source extension to Spring MVC called Spring Layout and have come up with some ways of managing these sorts of things but there&apos;s always some compromise in flexibility if you want simplicity.  One approach that we use in our tags is to render any fields that throw a NullValueInNestedPathException as disabled.  This also prevents the field from being submitted so Spring won&apos;t attempt to bind the fields to the command. &lt;/p&gt;</comment>
                            <comment id="22117" author="sbtourist" created="Wed, 7 Feb 2007 20:22:00 +0000"  >&lt;p&gt;&amp;gt; I can&apos;t think of any way a framework could reliably instantiate objects in the graph for binding against&lt;/p&gt;

&lt;p&gt;In the past I&apos;ve worked with some Apache Cocoon committers for solving the same kind of problem in the Cocoon Form binding framework: it was resolved by providing a factory interface to implement and associate to the property path that has to be instantiated in a custom way. &lt;/p&gt;

&lt;p&gt;We could do the same in the BeanWrapper: associate factory objects to property paths and let the bean wrapper call them when an object in the path is null and need to be created.&lt;/p&gt;

&lt;p&gt;What do you think?&lt;/p&gt;

&lt;p&gt;Cheers,&lt;/p&gt;

&lt;p&gt;Sergio B.&lt;/p&gt;</comment>
                            <comment id="22119" author="robmonie" created="Wed, 7 Feb 2007 20:34:05 +0000"  >&lt;p&gt;That sounds like a great idea to me.  We usually use a factory for instantiating model objects for various reasons so i&apos;d imagine that if we could register this against the bean wrapper we&apos;d have a lot of smiling faces around the office.  I&apos;m thinking aloud here so I could be talking rubbish but if it was smart enough to also deal with paths that include collections and add items to lists etc it would be a godsend.&lt;/p&gt;

&lt;p&gt;Imagine I have a graph something like &apos;user.addresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.city&apos; and I add a field to the form bound against &apos;user.addresses&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;.city&apos; but that doesn&apos;t exist in the model yet.  Currently we need to add pre binding to check for this kind of thing and put empty placeholders in so we have something to bind against.  If BeanWrapper could catch the null value in nested path exception, invoke the factory method registered for that path and populate the graph for binding things would be so much cleaner.&lt;/p&gt;</comment>
                            <comment id="35603" author="bmodali" created="Mon, 12 May 2008 02:48:43 +0000"  >&lt;p&gt;I can&apos;t wait for this to be fixed. This issue is a big annoyance, especially if you have nested object graphs and using hibernate for persistance as LazyList workaround mentioned above cannot be used on domain classes persisted by hibernate. Hibernate throws concurrent object modification exceptions if i lazily instantiate a collection in my domain class definition.&lt;/p&gt;

&lt;p&gt;So i ended up using VOs and using lazy lists in them and mapping nested VOs back to my domain object graph after form post just to workaround Spring MVC&apos;s data binding restrictions. Having done so, i had to create &apos;VO&apos; versions of my business logic validators.&lt;/p&gt;

&lt;p&gt;very annoying indeed.&lt;/p&gt;</comment>
                            <comment id="36513" author="derek" created="Thu, 5 Jun 2008 21:15:33 +0000"  >&lt;p&gt;I&apos;d vote for this again if I could &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Instead, I&apos;ll propose a solution: How about &quot;borrowing&quot; Groovy&apos;s safe dereferrencing syntax (the ?. operator)  ?&lt;/p&gt;

&lt;p&gt;This would maintain compatibility for existing code (which shouldn&apos;t contain such an operator) and allow developers to choose the behaviour they want in new code.&lt;/p&gt;

&lt;p&gt;For anyone who doesn&apos;t know Groovy, this syntax allows access to deep nested paths without risk of a null pointer exception.&lt;br/&gt;
If the reference before the operator is a null reference, the evaluation of the current expression stops, and null is returned.&lt;br/&gt;
(paraphrased from Groovy In Action page 184)&lt;/p&gt;

&lt;p&gt;So for example, the existing syntax:&lt;br/&gt;
&amp;lt;form:select path=&quot;supervisor.id&quot;&amp;gt; ...&lt;br/&gt;
would still cause a null pointer exception if the supervisor property of the command object is null&lt;/p&gt;

&lt;p&gt;But with the safe dereferencing syntax:&lt;br/&gt;
&amp;lt;form:select path=&quot;supervisor?.id&amp;gt; ...&lt;br/&gt;
there would be no problem.&lt;/p&gt;

</comment>
                            <comment id="37633" author="eightbit" created="Wed, 16 Jul 2008 03:09:44 +0000"  >&lt;p&gt;This issue has annoyed me for a long time. I just cracked open the BeanWrapperImpl looking for some sort of hook where I could add my own factory if necessary and noticed how well locked down it is. Any work around for me at this point would be too much of a hack.&lt;/p&gt;

&lt;p&gt;I would be so happy if something was included in 3.0 to address this.&lt;/p&gt;

&lt;p&gt;Thank you!&lt;/p&gt;</comment>
                            <comment id="41909" author="sheesh-kebab" created="Tue, 6 Jan 2009 06:43:27 +0000"  >&lt;p&gt;I second everyone on this thread - &lt;/p&gt;

&lt;p&gt;this is an absolutely retarded issue that I also run into with SpringMVC from the get go. No self respecting, productive, and serious web framework these days requires developers to provide a preinstantiated nested object graph to populate on form submission (this is so 90&apos;s!). The work around with editors won&apos;t work in all situations and just adds to code clutter. &lt;/p&gt;

&lt;p&gt;This problem has to be addressed. &lt;/p&gt;

&lt;p&gt;In lieu of this fix,  overwriting the crap BeanWrapperImpl is really the only way to go for me if I were to stick with Spring Web.&lt;/p&gt;
</comment>
                            <comment id="41910" author="cmpich" created="Tue, 6 Jan 2009 09:03:49 +0000"  >&lt;p&gt;I&apos;d like to see the object graph being created on the fly if a nested object is null.&lt;br/&gt;
I don&apos;t want to pre-populate my domain objects to make spring be able to populate the object graph.&lt;br/&gt;
Adding object creation of composite attributes in my domain objects would ruin the whole the business &lt;br/&gt;
models. Somteimes, it is essential that an attribute is null and not an &apos;empty&apos; shell.&lt;/p&gt;

&lt;p&gt;By default, an object should be created via the default constructor or a factory class that knows how&lt;br/&gt;
to instantiate the object in question. &lt;br/&gt;
At least, for the data-binding of form submission this is the behaviour I&apos;d wish to have.&lt;/p&gt;

&lt;p&gt;Is there a compelling reason for not doing this?&lt;/p&gt;</comment>
                            <comment id="45895" author="robrudin" created="Mon, 3 Aug 2009 05:47:37 +0000"  >&lt;p&gt;Will this be addressed in 3.0 RC1? I noticed it&apos;s been bumped a few times, including from 3.0 M3. Just wondering whether it&apos;ll actually be resolved in 3.0 RC1 or not. &lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10020">
                    <name>Related</name>
                                            <outwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="17058">SPR-3565</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="21794">SPR-4728</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="27701">SPR-6032</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13686">SPR-1860</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="15007">SPR-2607</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        7 years, 21 weeks, 3 days ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 12 Feb 2006 05:35:33 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>true</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i016o7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6958</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>