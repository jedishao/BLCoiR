<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 17:54:48 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-1487/SPR-1487.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-1487] ApplicationContext Circular Dependency Problem</title>
                <link>https://jira.spring.io/browse/SPR-1487</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;Spring ApplicationContext throws an exception, claiming a circular dependency, in a very simple scenario:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;two classes, One and Two&lt;/li&gt;
	&lt;li&gt;One has a single constructor argument of type Two&lt;/li&gt;
	&lt;li&gt;Two has a single property of type One&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The following context XML works:&lt;/p&gt;

&lt;p&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;br/&gt;
&amp;lt;!DOCTYPE beans PUBLIC &quot;-//SPRING//DTD BEAN//EN&quot; &quot;http://www.springframework.org/dtd/spring-beans.dtd&quot;&amp;gt;&lt;br/&gt;
&amp;lt;beans&amp;gt;&lt;br/&gt;
  &amp;lt;bean id=&quot;two&quot; class=&quot;Two&quot;&amp;gt;&lt;br/&gt;
    &amp;lt;property name=&quot;one&quot;&amp;gt;&amp;lt;ref local=&quot;one&quot;/&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt;
  &amp;lt;/bean&amp;gt;&lt;br/&gt;
  &amp;lt;bean id=&quot;one&quot; class=&quot;One&quot;&amp;gt;&lt;br/&gt;
    &amp;lt;constructor-arg&amp;gt;&amp;lt;ref local=&quot;two&quot;/&amp;gt;&amp;lt;/constructor-arg&amp;gt;&lt;br/&gt;
  &amp;lt;/bean&amp;gt;&lt;br/&gt;
&amp;lt;/beans&amp;gt;&lt;/p&gt;

&lt;p&gt;Just reversing the bean definitions results in a total different situation:&lt;/p&gt;

&lt;p&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;br/&gt;
&amp;lt;!DOCTYPE beans PUBLIC &quot;-//SPRING//DTD BEAN//EN&quot; &quot;http://www.springframework.org/dtd/spring-beans.dtd&quot;&amp;gt;&lt;br/&gt;
&amp;lt;beans&amp;gt;&lt;br/&gt;
  &amp;lt;bean id=&quot;one&quot; class=&quot;One&quot;&amp;gt;&lt;br/&gt;
    &amp;lt;constructor-arg&amp;gt;&amp;lt;ref local=&quot;two&quot;/&amp;gt;&amp;lt;/constructor-arg&amp;gt;&lt;br/&gt;
  &amp;lt;/bean&amp;gt;&lt;br/&gt;
  &amp;lt;bean id=&quot;two&quot; class=&quot;Two&quot;&amp;gt;&lt;br/&gt;
    &amp;lt;property name=&quot;one&quot;&amp;gt;&amp;lt;ref local=&quot;one&quot;/&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt;
  &amp;lt;/bean&amp;gt;&lt;br/&gt;
&amp;lt;/beans&amp;gt;&lt;/p&gt;

&lt;p&gt;The following exception is thrown:&lt;/p&gt;

&lt;p&gt;Nov 21, 2005 1:37:15 PM org.springframework.beans.factory.support.DefaultListableBeanFactory preInstantiateSingletons&lt;br/&gt;
INFO: Pre-instantiating singletons in factory [org.springframework.beans.factory.support.DefaultListableBeanFactory defining beans &lt;span class=&quot;error&quot;&gt;&amp;#91;one,two&amp;#93;&lt;/span&gt;; root of BeanFactory hierarchy]&lt;br/&gt;
Nov 21, 2005 1:37:15 PM org.springframework.beans.factory.support.AbstractBeanFactory destroySingletons&lt;br/&gt;
INFO: Destroying singletons in factory &lt;/p&gt;
{org.springframework.beans.factory.support.DefaultListableBeanFactory defining beans [one,two]; root of BeanFactory hierarchy}
&lt;p&gt;Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;one&apos; defined in class path resource &lt;span class=&quot;error&quot;&gt;&amp;#91;context.xml&amp;#93;&lt;/span&gt;: Can&apos;t resolve reference to bean &apos;two&apos; while setting property &apos;constructor argument&apos;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;two&apos; defined in class path resource &lt;span class=&quot;error&quot;&gt;&amp;#91;context.xml&amp;#93;&lt;/span&gt;: Can&apos;t resolve reference to bean &apos;one&apos; while setting property &apos;one&apos;; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &apos;one&apos;: Requested bean is currently in creation (circular reference when autowiring constructor?)&lt;br/&gt;
org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;two&apos; defined in class path resource &lt;span class=&quot;error&quot;&gt;&amp;#91;context.xml&amp;#93;&lt;/span&gt;: Can&apos;t resolve reference to bean &apos;one&apos; while setting property &apos;one&apos;; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &apos;one&apos;: Requested bean is currently in creation (circular reference when autowiring constructor?)&lt;br/&gt;
org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name &apos;one&apos;: Requested bean is currently in creation (circular reference when autowiring constructor?)&lt;br/&gt;
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:186)&lt;br/&gt;
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:147)&lt;br/&gt;
	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:176)&lt;br/&gt;
	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:105)&lt;br/&gt;
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1012)&lt;br/&gt;
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:823)&lt;br/&gt;
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:345)&lt;br/&gt;
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:226)&lt;br/&gt;
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:147)&lt;br/&gt;
	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:176)&lt;br/&gt;
	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:105)&lt;br/&gt;
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.resolveConstructorArguments(AbstractAutowireCapableBeanFactory.java:713)&lt;br/&gt;
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:611)&lt;br/&gt;
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:329)&lt;br/&gt;
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:226)&lt;br/&gt;
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:147)&lt;br/&gt;
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:275)&lt;br/&gt;
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:318)&lt;br/&gt;
	at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:81)&lt;br/&gt;
	at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:66)&lt;br/&gt;
	at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:57)&lt;br/&gt;
	at Test.main(Test.java:7)&lt;/p&gt;

&lt;p&gt;So first of all, the order of bean definitions is in fact significant. Second, Spring fails to construct the object graph in this simple case. Note, I was using the following simple test program:&lt;/p&gt;

&lt;p&gt;public class Test {&lt;br/&gt;
  public static void main(String[] args) &lt;/p&gt;
{
    BeanFactory factory = new ClassPathXmlApplicationContext(&quot;context.xml&quot;);
    Two two = (Two) factory.getBean(&quot;two&quot;);
    System.out.println(two);
    System.out.println(two.getOne());
  }
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;Using an XmlBeanFactory works, independent of the order of those two bean elements in the XML.&lt;/p&gt;

&lt;p&gt;public class Test {&lt;br/&gt;
  public static void main(String[] args) &lt;/p&gt;
{
    XmlBeanFactory factory = new XmlBeanFactory(new ClassPathResource(&quot;context.xml&quot;));
    Two two = (Two) factory.getBean(&quot;two&quot;);
    System.out.println(two);
    System.out.println(two.getOne());
  }
&lt;p&gt;}&lt;/p&gt;</description>
            <key id="12774">SPR-1487</key>
            <summary>ApplicationContext Circular Dependency Problem</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="cocoa.ch">Simon Raess</reporter>
                        <labels>
                    </labels>
                <created>Mon, 21 Nov 2005 04:12:07 +0000</created>
                <updated>Tue, 19 Jun 2012 03:54:32 +0000</updated>
                            <resolved>Tue, 10 Jan 2006 03:11:42 +0000</resolved>
                                    <version>1.2.5</version>
                    <version>1.2.6</version>
                                    <fixVersion>1.2.7</fixVersion>
                    <fixVersion>2.0 M2</fixVersion>
                                    <component>Core</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="15529" author="juergen.hoeller" created="Thu, 24 Nov 2005 09:28:01 +0000"  >&lt;p&gt;The difference between the BeanFactory and ApplicationContext behavior here simply comes from the fact that a BeanFactory does by default not pre-initialize its singletons. So the first bean to initialize there is &quot;two&quot;, because that&apos;s what you call &quot;getBean&quot; for: It doesn&apos;t matter whether &quot;two&quot; is the first bean definition in the file; it&apos;s always gonna be initialized first in that case.&lt;/p&gt;

&lt;p&gt;The order is only significant for the startup of bean instances in an ApplicationContext, which pre-initializes all its singletons, in the order of bean definitions.&lt;/p&gt;

&lt;p&gt;You do have a point there in that the circular reference resolution mechanism depends on the initialization order. We do not guarantee circular reference resolution for such a scenario in the first place, though: The general rule is to not use circular references at all, in particular not in combination with constructor injection.&lt;/p&gt;

&lt;p&gt;Essentially, the current algorithm stats with creating the first bean instance and then tries to resolve its references from there on. If the first bean needs a constructor reference to some other bean, that other bean will be created. Now if that other beans wants a reference back to the first bean, no such reference can be retrieved - not even an incompletely initialized one -, since the first bean hasn&apos;t been constructed yet.&lt;/p&gt;

&lt;p&gt;It&apos;s essentially a question of lifecycle: A passed-in reference usually has to be fully initialized. That can&apos;t be guaranteed for a circular reference, so the current algorithm just gives that guarantee for the first bean (the first one to be initialized) then, letting the second bean have an incompletely initialized reference back to the first bean - which only works if the first bean has already been constructed at that point.&lt;/p&gt;

&lt;p&gt;The only way around the current behavior is to initialize the non-constructor bean first. However, the ApplicationContext doesn&apos;t know this upfront, as it only discovers actual circular references once it starts to initialize a bean... Unfortunately, I don&apos;t see a clean way to adapt the algorithm in that respect.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="15594" author="lfreyberg" created="Tue, 29 Nov 2005 03:41:28 +0000"  >&lt;p&gt;The underlying problem will not go away if both beans use setter injection; you just end up in a situation where the dependencies may be satisfied at a reference level, but not at an initialization level.&lt;/p&gt;

&lt;p&gt;Consider the following dependency graph where all beans are singletons and are aggressively loaded (i.e. in an ApplicationContext):&lt;/p&gt;

&lt;p&gt;    A --&amp;gt; B --&amp;gt; C --&amp;gt; D ...... --&amp;gt; Z&lt;br/&gt;
              ^_______________|&lt;/p&gt;

&lt;p&gt;While the current algorithm will cope with this, it will not guarantee that all of the beans are fully initialized before they are set as dependencies; More specifically B may only be partially initialized when it is set on Z; Meaning that if Z depends on any data in B set by spring, it may fail in a inconsistent state, silently.&lt;/p&gt;

&lt;p&gt;The obvious solution is not to use circular dependencies in bean properties, but in reality, with large projects this is not very practical - it may not be known that such a dependency exists if the graph is deep enough. &lt;/p&gt;

&lt;p&gt;An init-method won&apos;t solve the problem as it will be called after all of the properties on Z have been set, but before B has finished. Z could also initialize itself in a lazy manner, but this is also not always applicable.&lt;/p&gt;

&lt;p&gt;Another solution is to use a BeanFactoryPostProcessor to call an init method in Z after all the beans in the factory have been created. The problem with this is that you may not know that you have a circular dependency, your application may start but may also be in a non-deterministic state.&lt;/p&gt;

&lt;p&gt;At the very least, the BeanFactory should be modified to log a warning when it finds a circular dependency to indicate that a bean is going to be set with a dependency that is not fully initialized. This should be pretty simple as the bean factory knows that it has found a circular dependency and is going ahead with construction / initialization regardless, and it would allow users to take corrective action:&lt;/p&gt;

&lt;p&gt;...from AbstractAutowireCapableBeanFactory line 339:&lt;/p&gt;

&lt;p&gt;        // Eagerly cache singletons to be able to resolve circular references&lt;br/&gt;
        // even when triggered by lifecycle interfaces like BeanFactoryAware.&lt;br/&gt;
        if (isSingletonCurrentlyInCreation(beanName)) &lt;/p&gt;
{
            addSingleton(beanName, bean);
        }

&lt;p&gt;Furthermore, the spring documentation should be updated to reflect that this situation is possible - at the moment I cannot find any references to it, which means a code trawl to find the problem, which is significantly hampered by the fact that it happens silently. All you get is corruption in you setter or init method but your application may still start.&lt;/p&gt;

&lt;p&gt;Lee&lt;/p&gt;</comment>
                            <comment id="16044" author="juergen.hoeller" created="Tue, 10 Jan 2006 03:11:42 +0000"  >&lt;p&gt;I&apos;ve added an debug-level log message that indicates every time a non-fully-initialized singleton bean is returned from getBean. This in particular applies to other beans that point back to the currently initialized bean. So if there&apos;s any failure caused by a non-fully initialized reference, it should be immediately obvious from the log messages that came right before the exception.&lt;/p&gt;

&lt;p&gt;Unfortunately, we arguably can&apos;t raise the log level beyond debug, since circular references might be entirely deliberate - and we don&apos;t want so spam anybody&apos;s info/debug log with messages that are not relevant for the scenario. Hence, I&apos;m afraid it has to remain at debug level.&lt;/p&gt;

&lt;p&gt;I&apos;ve also added an &quot;allowCircularReferences&quot; flag to AbstractAutowireCapableBeanFactory, similar to DefaultListableBeanFactory&apos;s existing &quot;allowBeanDefinitionOverriding&quot; flag. It is on by default but can be turned off to suppress the eager exposure of singleton references - as a consequence, causing every circular reference to fail immediately. So if want to enforce avoiding them, consider turning this flag off.&lt;/p&gt;

&lt;p&gt;Note that those flags are currently only exposed at the BeanFactory level. To use them with an ApplicationContext, you&apos;d have to use a GenericApplicationContext or subclass your ApplicationContext&apos;s &quot;createBeanFactory&quot; method.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="20881" author="zhihong_w" created="Wed, 15 Nov 2006 12:10:23 +0000"  >&lt;p&gt;To solve the problem, we can somehow indicate in the configuration file that bean two&apos;s reference to bean one does not require bean one to be fully intialized. e.g.&lt;/p&gt;

&lt;p&gt;&amp;lt;bean id=&quot;two&quot; class=&quot;Two&quot;&amp;gt;&lt;br/&gt;
    &amp;lt;property name=&quot;one&quot;&amp;gt;&amp;lt;ref local=&quot;one&quot; require-fully-initialized=&quot;false&quot; /&amp;gt;&amp;lt;/property&amp;gt;&lt;br/&gt;
 &amp;lt;/bean&amp;gt;&lt;/p&gt;

&lt;p&gt;By do this, ApplicationContext knows that bean two&apos;s reference to one is not necessary for it&apos;s intialization. Thus the ApplicationContext can safely set the reference to one or delay setting of this reference.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        10 years, 7 weeks, 1 day ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 24 Nov 2005 09:28:01 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>true</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i020hj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>11788</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>