<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 21:13:57 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-2981/SPR-2981.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-2981] Spring performance is insufficient for intensive work at short scopes</title>
                <link>https://jira.spring.io/browse/SPR-2981</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;When making large numbers of instantiations, in particular at short scopes such as within an HTTP request, Spring core performance can become a bottleneck. Note that this appears to be an orthogonal problem to that referred to in &lt;a href=&quot;https://jira.spring.io/browse/SPR-2772&quot; title=&quot;Poor performance creating non-singleton beans with many threads&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPR-2772&quot;&gt;&lt;del&gt;SPR-2772&lt;/del&gt;&lt;/a&gt; since this affects singleton and non-singleton beans alike, even (and, actually especially) in a single-threaded context. This is suggested also by the fact that this speed test is affected relatively little by the change from Spring 1.2.8 to 2.0.1 (slows by around 4%)&lt;/p&gt;

&lt;p&gt;There is a test project in our SVN tagged at &lt;a href=&quot;https://saffron.caret.cam.ac.uk/svn/projects/TestRSAC/tags/J-ServletUtil-1.2&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://saffron.caret.cam.ac.uk/svn/projects/TestRSAC/tags/J-ServletUtil-1.2&lt;/a&gt; which demonstrates the issue. A modest-sized container (30 beans with varying numbers of properties from 1 to 13) is fired up in various versions of Spring, and is subjected to repeated cycles of a fetch of the most derived bean followed by a call to destroySingletons(). This stabilises in the region of 8ms per instantiation of the bean set (for these 30 beans, on a fairly modest laptop). This would obviously be an unacceptable per-request overhead if occuring on each HTTP cycle.&lt;/p&gt;

&lt;p&gt;It&apos;s worth comparing this much lower figure with that of the 6-bean container in &lt;a href=&quot;https://jira.spring.io/browse/SPR-2772&quot; title=&quot;Poor performance creating non-singleton beans with many threads&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPR-2772&quot;&gt;&lt;del&gt;SPR-2772&lt;/del&gt;&lt;/a&gt; - I think much of the difference lies in the considerably greater number of properties (some of which require conversion) on the beans in this test, which is more representative of a real-world container. For comparison purposes a run with a SINGLE leaf bean instantiates the container in only 22 microseconds, more than 400 times faster - demonstrating that the overhead is really a per-bean one, and strongly penalising beans with larger and more complex property sets.&lt;/p&gt;

&lt;p&gt;Profiling suggests that around 30% of the time is being lost in Sun introspection code, and a further 30% in instantiation of BeanWrapperImpl objects, which appear to be fabricated in a complete fresh set for every property set. Synchronisation also seems to be a significant part of the overhead. Even with removal of those first two two sources of overhead, the lag from this test instantation still couldn&apos;t be overwhelmingly expected to be &amp;lt;1ms, which is still somewhat dubious.&lt;/p&gt;

&lt;p&gt;This is the main reason for development of &quot;RSAC&quot;, a lightweight &quot;Spring core&quot; workalike, which sacrifices a good deal of Spring&apos;s flexibility (multi-threaded access, dynamic modifications to container heirarchy) in order to focus on the core cases of instantiations of and access to a set of beans bound to a single thread (typically within an HTTP request). Request-scope IoC has proved a big architectural benefit for the coherence and portability of RSF, and it would be marvellous if at some point we could stop maintaining RSAC and have similar capabilities within the Spring core &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/tongue.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; - post 2.0 it now seems conceivable that this could become packaged as some new kind of Scope within Spring.&lt;/p&gt;

&lt;p&gt;General notes on RSAC at &lt;a href=&quot;http://www2.caret.cam.ac.uk/rsfwiki/Wiki.jsp?page=RSAC&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www2.caret.cam.ac.uk/rsfwiki/Wiki.jsp?page=RSAC&lt;/a&gt; - the key points are that most of Spring core is implemented (with the notable exceptions of constructor injection and autowiring), and since it relies on genuine Spring core for reading BeanDefinitions it is immune to upgrades in the container file format. RSAC is generally around 50-80x faster at Spring proper at instantiating the TestRSAC context file. Raw numbers follow:&lt;/p&gt;

&lt;p&gt;Results (1.8Ghz Pentium M, SpeedStep engaged, JDK 1.4.2, Windows 2000)&lt;/p&gt;

&lt;p&gt;Main container (requestscope.xml, 30 beans)&lt;/p&gt;

&lt;p&gt;Spring 1.2.8:  &lt;br/&gt;
               1000 instantations in 24695 ms: 24.695ms/instance&lt;br/&gt;
               10000 instantations in 239705 ms: 23.970ms/instance&lt;br/&gt;
Spring 2.0.1:  1000 instantations in 25296 ms: 25.296ms/instance&lt;br/&gt;
RSAC 1.2:&lt;br/&gt;
               1000 instantations in 631 ms: 0.631ms/instance&lt;br/&gt;
               10000 instantations in 4066 ms: 0.407ms/instance&lt;br/&gt;
               100000 instantations in 38085 ms: 0.381ms/instance&lt;/p&gt;

&lt;p&gt;               (SpeedStep disengaged, maximum CPU)               &lt;br/&gt;
Spring 1.2.8:  1000 instantations in 8232 ms: 8.232ms/instance&lt;br/&gt;
RSAC 1.2:      10000 instantations in 1342 ms: 0.134ms/instance&lt;/p&gt;

&lt;p&gt;Tiny container (tinyrequestscope.xml, 1 bean, maximum CPU)&lt;/p&gt;

&lt;p&gt;Spring 1.2.8:  1000000 instantations in 21701 ms: 0.022ms/instance&lt;br/&gt;
RSAC 1.2:      10000000 instantations in 16044 ms: 0.0016ms/instance&lt;/p&gt;</description>
            <key id="15759">SPR-2981</key>
            <summary>Spring performance is insufficient for intensive work at short scopes</summary>
                <type id="4" iconUrl="https://jira.spring.io/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="bosmon">Antranig Basman</reporter>
                        <labels>
                            <label>performance</label>
                    </labels>
                <created>Mon, 25 Dec 2006 09:52:29 +0000</created>
                <updated>Tue, 19 Jun 2012 03:50:10 +0000</updated>
                            <resolved>Wed, 28 Mar 2007 21:37:27 +0000</resolved>
                                    <version>2.0.1</version>
                                    <fixVersion>2.0.4</fixVersion>
                                    <component>Core</component>
                        <due></due>
                            <votes>2</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="21535" author="juergen.hoeller" created="Mon, 1 Jan 2007 06:48:53 +0000"  >&lt;p&gt;Just to be clear on where those numbers come from: Do you - by any chance - create a &lt;b&gt;new&lt;/b&gt; ApplicationContext for each request? You shouldn&apos;t, in particular with Spring 2.0&apos;s scope mechanism, but since you&apos;re testing on 1.2.8 as well... I assume you don&apos;t, though, according to your description. Of course, the startup and shutdown overhead is not really relevant then, so it shouldn&apos;t be benchmarked either. Only the actual bean creation overhead in a fully initialized ApplicationContext really matters to you, I suppose.&lt;/p&gt;

&lt;p&gt;The main reason I&apos;m wondering is because you referred to 30% of the time spent in Sun introspection code. This is odd, in particular for an existing ApplicationContext, since it should cache all the introspection results. Are you maybe having the Spring framework classes in the system class loader (or shared server class loader), while running the ApplicationContext in a special class loader (such as a web application&apos;s class loader)? Then the introspection results wouldn&apos;t be cached, since it wouldn&apos;t be safe in terms of ClassLoader cleanup... Putting the Spring framework classes into the application class loader helps to get around that.&lt;/p&gt;

&lt;p&gt;We definitely do strive to optimize the performance of prototype bean creation, in particular now with Spring 2.0&apos;s focus on non-singleton scopes. I&apos;ve scheduled this for 2.1 RC1 (to be released in April), for which I plan to give the entire bean creation code a thorough overhaul. Before that, I will already try to sneak some optimizations in for 2.0.3.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="21537" author="bosmon" created="Mon, 1 Jan 2007 10:46:07 +0000"  >&lt;p&gt;Thanks for your very rapid, and thoughtful response, Juergen, as always!&lt;/p&gt;

&lt;p&gt;Yes, that is right - I was doing my absolute best to strip down my usage of the container code, so all of these numbers are derived from the same ApplicationContext - all that Spring sees is alternating requests for destroySingletons() and fetch of the &quot;most derived bean&quot;. Yes, I am primarily interested in pure instantiation costs, rather than any per-container overhead. &lt;/p&gt;

&lt;p&gt;In terms of ClassLoaders, these tests were run in a simple command-line environment which would have placed both Spring and the application code into the same System classloader (by my understanding) and so the caching should have been operating. Informal testing showed something like the same performance in webapps also, I will continue doing some more tests just to make sure the caching is on - although I fear this would only  improve performance by around 30%. &lt;/p&gt;

&lt;p&gt;Yes, the introspection results should and probably are being cached, but the Sun javax.beans code that is tripped via the PropertyEditor framework seems to have truly grotty performance characteristics (I remember seeing a large amount of time disappearing in completely fruitless Class.forName() calls for example). The thing that concerned me looking at the situation was how integral PropertyEditor &amp;amp; co were bound to the container infrastructure, and wondered given this how completely the performance issues could be resolved - I wrote to you on this topic about a year back, but in the meantime had to continue with the RSAC strategy.&lt;/p&gt;

&lt;p&gt;It&apos;s possible that in some &quot;ultimate&quot; solution we might be able to simply retain the PropertyEditor interface backed by a ground-up reimplementation of  javax.beans and Sun reflection (I have been investigating the performance of CGLib&apos;s FastClass/FastMember, for example, and insisted that they kept in this feature for CGLib 3, which they had believed was little used! CGLib reflection seems to still be around 10x as fast as JDK reflection, despite the improvements going to JDK 1.4 and 1.5). But this sounds a little &quot;extreme&quot; for general use - all the same, excited to hear you are considering aggressive performance optimisations for 2.1 - look forward it!&lt;/p&gt;


&lt;p&gt;As a complete side-note, the issue of cross-ClassLoader caching had been something I worried about for a long time, and there seems to be no good answer to it out there yet. On the whole yes, the best answer to it at the moment seems to be to make sure not to do it! &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/tongue.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; WeakHashMap behaves &lt;b&gt;far&lt;/b&gt; too poorly for use in a generalised introspection cache since it locks on every access. It seems there would be some running to be made with a cunning datastructure implementing a kind of Map full of Weak references, but with particularly &lt;b&gt;poor&lt;/b&gt; guarantees as to completeness and consistency which are traded for extremely fast lookup costs, but I have not had time to try and implement this yet, or hear of anyone else who has. Especially going towards OSGi though, this might be something we might have to think about, since in such an environment pretty much the &lt;b&gt;default&lt;/b&gt; case is that Spring code will be in a different ClassLoader to the client, and it would still be nice to be able to do something sensible wrt. introspection caching.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Antranig.&lt;/p&gt;</comment>
                            <comment id="22939" author="juergen.hoeller" created="Wed, 28 Mar 2007 21:37:27 +0000"  >&lt;p&gt;We have very significant performance improvements for non-singleton beans in Spring 2.0.4 now, with prototype bean creation being about 6 times faster than in Spring 2.0.3, and even much more than that if constructor resolution is involved (i.e. if a non-default constructor is used, in particular in case multiple overloaded constructors).&lt;/p&gt;

&lt;p&gt;This should be available in tonight&apos;s 2.0.4 snapshot (&lt;a href=&quot;http://www.springframework.org/snapshots&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.springframework.org/snapshots&lt;/a&gt;). Please give it a try and let us know how it works for you...&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="23688" author="bosmon" created="Sun, 13 May 2007 23:18:24 +0000"  >&lt;p&gt;Thanks Juergen - I have now performed further testing with the latest Spring release (2.0.5) against the latest release of RSAC (1.2.1) and the new test project is now tagged at &lt;a href=&quot;https://saffron.caret.cam.ac.uk/svn/projects/TestRSAC/tags/J-ServletUtil-1.2.1&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://saffron.caret.cam.ac.uk/svn/projects/TestRSAC/tags/J-ServletUtil-1.2.1&lt;/a&gt; (following excerpts are in the README.txt file there).&lt;/p&gt;

&lt;p&gt;There have indeed been really significant performance improvements since 2.0.1 - this is great! Here are the raw numbers (note that these were done on a much faster machine than the tests above, and a different JDK)&lt;/p&gt;

&lt;p&gt;More recent tests (3.2Ghz P4, JDK 1.5.0-b6, Windows 2000)&lt;/p&gt;

&lt;p&gt;Main container (requestscope.xml, 30 beans)&lt;/p&gt;

&lt;p&gt;RSAC 1.2.1:    &lt;br/&gt;
               10000 instantations in 1609 ms: 0.161ms/instance&lt;br/&gt;
               100000 instantations in 14453 ms: 0.145ms/instance&lt;br/&gt;
Spring 1.2.8   10000 instantations in 31812 ms: 3.181ms/instance&lt;br/&gt;
Spring 2.0.1:  10000 instantations in 59641 ms: 5.964ms/instance&lt;br/&gt;
Spring 2.0.5:  &lt;br/&gt;
               1000 instantations in 1156 ms: 1.156ms/instance&lt;br/&gt;
               10000 instantations in 8110 ms: 0.811ms/instance&lt;br/&gt;
               100000 instantations in 75937 ms: 0.759ms/instance&lt;/p&gt;

&lt;p&gt;The bottom line figure is that whilst Spring 2.0.1 was around 2x as slow as Spring 1.2.8, Spring 2.0.5 is around 4x faster - i.e. the improvements around 2.0.4 have produced a relative speedup of around 8x. A fair proportion of these perhaps due to the new more aggressive use of  &quot;TypedStringValue&quot;, and I also see a number of Concurrent maps around the place where we once had synchronization. All excellent stuff!&lt;/p&gt;

&lt;p&gt;This puts Spring 2.0.5 now only around 5x slower than RSAC at instantiating the test container which has closed the gap enormously, but I fear is still insufficient for this purpose. The headline figure is the ~ 0.8ms consumed in instantiating around 30 beans - considering this is a pretty modern machine and a modest container size, the risk is very palpable that the instantiation may take over 1ms which I think is (perhaps beyond?) the upper limit of acceptability for a web request overhead.&lt;/p&gt;

&lt;p&gt;This is really great progress, but I hope that more optimisations are possible/in the offing - in the meantime would it be possible to reopen this JIRA?&lt;/p&gt;

&lt;p&gt;(hprof is really pretty darn inaccurate, but it may be significant that it claims that this stack trace is responsible for around 10% of traces:&lt;br/&gt;
TRACE 300363:&lt;br/&gt;
	java.lang.AbstractStringBuilder.expandCapacity(AbstractStringBuilder.java:99)&lt;br/&gt;
	java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:393)&lt;br/&gt;
	java.lang.StringBuffer.append(StringBuffer.java:225)&lt;/p&gt;

&lt;p&gt;org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveManagedList(BeanDefinitionValueResolver.java:281)&lt;br/&gt;
)&lt;/p&gt;

&lt;p&gt;(Note that we are only talking about singleton construction here, for the time being)&lt;/p&gt;

&lt;p&gt;Cheers,&lt;br/&gt;
Antranig.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="16727">SPR-3426</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                            <issuelinktype id="10020">
                    <name>Related</name>
                                            <outwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="15362">SPR-2772</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        9 years, 33 weeks, 3 days ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 1 Jan 2007 06:48:53 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>true</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i04qtj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>27719</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>