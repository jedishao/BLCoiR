<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 20:51:10 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-272/SPR-272.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-272] JTA transaction doesn&apos;t work in 1.1 RC2</title>
                <link>https://jira.spring.io/browse/SPR-272</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;Today I just tried to upgrade the spring lib to 1.1 rc2 from 1.02. To my surprise, the JTA starts to fail after I replaced the old spring.jar. After I switch back to 1.02, everything works again (no code change).&lt;/p&gt;

&lt;p&gt;I use spring in within SLSB CMT which is demarcated as Required, tx attribute of the spring interceptted method is PROPAGATION_REQUIRES_NEW. The call failed no matter there is a tx started by the ejb client or not.&lt;/p&gt;

&lt;p&gt;Here is the error I got with 1.1 rc2:&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;8/19/04 18:46:57:109 EDT&amp;#93;&lt;/span&gt; 52f8054b SystemOut     U ERROR &lt;span class=&quot;error&quot;&gt;&amp;#91;ORB.thread.pool:2&amp;#93;&lt;/span&gt; (AbstractPlatformTransactionManager.java:521) - Rollback exception overridden by synchronization exception&lt;br/&gt;
java.lang.NullPointerException&lt;br/&gt;
	at org.springframework.orm.hibernate.SessionFactoryUtils$SpringSessionSynchronization.beforeCommit(SessionFactoryUtils.java:620)&lt;br/&gt;
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.triggerBeforeCommit(AbstractPlatformTransactionManager.java:500)&lt;br/&gt;
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:364)&lt;br/&gt;
	at org.springframework.transaction.interceptor.TransactionAspectSupport.doCommitTransactionAfterReturning(TransactionAspectSupport.java:241)&lt;br/&gt;
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:66)&lt;br/&gt;
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:139)&lt;br/&gt;
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:152)&lt;br/&gt;
	at $Proxy0.logInboundRequest(Unknown Source)&lt;br/&gt;
	at &lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;8/19/04 18:46:57:109 EDT&amp;#93;&lt;/span&gt; 52f8054b JTSXA         W Current thread is already associated with another transaction.&lt;/p&gt;

&lt;p&gt;I took a look at the source and found the session object is null after executing the following line in SessionFactoryUtils. &lt;/p&gt;

&lt;p&gt;Session session = (this.jtaTransaction != null) ?&lt;br/&gt;
this.sessionHolder.getSession(this.jtaTransaction) : this.sessionHolder.getSession();&lt;/p&gt;

&lt;p&gt;While during the whole debug tracing, all session objects seem to bound use the DEFAULT_KEY - which is just a blank object.&lt;/p&gt;

&lt;p&gt;I&apos;m using spring&apos;s JtaTransactionManager to set the TransactionManagerLookup, maybe there are some additional steps needed in this new version?&lt;/p&gt;</description>
            <key id="10479">SPR-272</key>
            <summary>JTA transaction doesn&apos;t work in 1.1 RC2</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="1" iconUrl="https://jira.spring.io/images/icons/priorities/blocker.png">Blocker</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="victorwon">Victor</reporter>
                        <labels>
                    </labels>
                <created>Thu, 19 Aug 2004 10:25:46 +0000</created>
                <updated>Tue, 24 Aug 2004 20:45:30 +0000</updated>
                            <resolved>Tue, 24 Aug 2004 20:45:30 +0000</resolved>
                                    <version>1.1 RC2</version>
                                    <fixVersion>1.1 final</fixVersion>
                                    <component>Transaction</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="10807" author="victorwon" created="Thu, 19 Aug 2004 10:29:07 +0000"  >&lt;p&gt;Forgot to mention that I&apos;m using Hibernate 2.1.4&lt;/p&gt;</comment>
                            <comment id="10808" author="juergen.hoeller" created="Thu, 19 Aug 2004 18:35:32 +0000"  >&lt;p&gt;Thanks for reporting this issue - it&apos;s indeed severe!&lt;/p&gt;

&lt;p&gt;The code in question assumes that if a JTA Transaction object is available, that Transaction object is used for Session registration. I&apos;ve just gone through the execution paths: This is always the case when the Session gets opened during a transaction. However, that assumption does not apply with a pre-bound Session, like in the case of OpenSessionInViewFilter/Interceptor: Do you happen to use one of those?&lt;/p&gt;

&lt;p&gt;The fix should be quite straightforward: First check for a Session for the current JTA Transaction object, then for a generally bound Session. This should work with any Session binding strategy. So the code in SessionFactoryUtils line 618-619 should be replaced with the following:&lt;/p&gt;

&lt;p&gt;  Session session = null;&lt;br/&gt;
  if (this.jtaTransaction != null) &lt;/p&gt;
{
    session = this.sessionHolder.getSession(this.jtaTransaction);
  }
&lt;p&gt;  if (session == null) &lt;/p&gt;
{
    session = this.sessionHolder.getSession();
  }

&lt;p&gt;Can you check whether that solves the issue for you? I believe it should, but of course we should double-check this.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="10810" author="victorwon" created="Fri, 20 Aug 2004 01:56:09 +0000"  >&lt;p&gt;Yes, I do use sort of OpenSessionInView pattern but without the filters - I inherit my session bean from spring&apos;s abstract stateless session bean and load the spring managed class via onEjbCreate(), then demarcate the class to join ejb&apos;s tx. This way I can benefit from both EJB&apos;s distribute capability and spring&apos;s fantasic aop and hibernate support.&lt;/p&gt;

&lt;p&gt;I just recompiled the spring 1.1rc2 with the new code patch. But now I got the NullPointerException in another place:&lt;/p&gt;

&lt;p&gt;java.lang.NullPointerException&lt;br/&gt;
	at org.springframework.orm.hibernate.SessionFactoryUtils.doClose(SessionFactoryUtils.java:548)&lt;br/&gt;
	at org.springframework.orm.hibernate.SessionFactoryUtils.closeSessionOrRegisterDeferredClose(SessionFactoryUtils.java:537)&lt;br/&gt;
	at org.springframework.orm.hibernate.SessionFactoryUtils.access$300(SessionFactoryUtils.java:85)&lt;br/&gt;
	at org.springframework.orm.hibernate.SessionFactoryUtils$SpringSessionSynchronization.beforeCompletion(SessionFactoryUtils.java:658)&lt;br/&gt;
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.triggerBeforeCompletion(AbstractPlatformTransactionManager.java:516)&lt;br/&gt;
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.commit(AbstractPlatformTransactionManager.java:365)&lt;br/&gt;
	at org.springframework.transaction.interceptor.TransactionAspectSupport.doCommitTransactionAfterReturning(TransactionAspectSupport.java:241)&lt;br/&gt;
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:66)&lt;br/&gt;
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:139)&lt;br/&gt;
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:152)&lt;/p&gt;

&lt;p&gt;Maybe in doClose() we need to ignore if the session passed in is null?&lt;br/&gt;
After I made that change to doClose, the NullPointerException was gone, and my first &quot;RequiresNew&quot; method sucessfully committed. However, my second method, marked as &quot;MANDATORY&quot;, failed with the following exception:&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;8/20/04 10:13:07:953 EDT&amp;#93;&lt;/span&gt; 5e812f68 SystemOut     U DEBUG &lt;span class=&quot;error&quot;&gt;&amp;#91;ORB.thread.pool:1&amp;#93;&lt;/span&gt; (JDBCExceptionReporter.java:36) - SQL Exception&lt;br/&gt;
com.ibm.websphere.ce.cm.StaleConnectionException: class com.ibm.ejs.cm.proxy.OracleConnectionProxy is closed&lt;br/&gt;
	at com.ibm.ejs.cm.proxy.OracleConnectionProxy.prepareStatement(OracleConnectionProxy.java:206)&lt;br/&gt;
	at net.sf.hibernate.impl.BatcherImpl.getPreparedStatement(BatcherImpl.java:249)&lt;br/&gt;
	at net.sf.hibernate.impl.BatcherImpl.getPreparedStatement(BatcherImpl.java:223)&lt;br/&gt;
	at net.sf.hibernate.impl.BatcherImpl.prepareQueryStatement(BatcherImpl.java:65)&lt;br/&gt;
	at net.sf.hibernate.loader.Loader.prepareQueryStatement(Loader.java:704)&lt;/p&gt;

&lt;p&gt;Once I commented out the first &quot;RequiresNew&quot; method, execution entered the second one with no error but failed when the 2nd method tried to call another &quot;RequiresNew&quot; method. The exception is :&lt;/p&gt;

&lt;p&gt;java.lang.IllegalStateException: Already value &lt;span class=&quot;error&quot;&gt;&amp;#91;org.springframework.orm.hibernate.SessionHolder@11fdef6f&amp;#93;&lt;/span&gt; for key &lt;span class=&quot;error&quot;&gt;&amp;#91;net.sf.hibernate.impl.SessionFactoryImpl@324d2f76&amp;#93;&lt;/span&gt; bound to thread &lt;span class=&quot;error&quot;&gt;&amp;#91;ORB.thread.pool:2&amp;#93;&lt;/span&gt;&lt;br/&gt;
	at org.springframework.transaction.support.TransactionSynchronizationManager.bindResource(TransactionSynchronizationManager.java:137)&lt;br/&gt;
	at org.springframework.orm.hibernate.SessionFactoryUtils$SpringSessionSynchronization.resume(SessionFactoryUtils.java:613)&lt;/p&gt;

&lt;p&gt;Any idea?&lt;/p&gt;

&lt;p&gt;Thanks in advance, and to be frank I really enjoys spring (although I&apos;m very new to it). Had it not for the distribute requirement in my project, I&apos;d prefer to abandon ejb totally.&lt;/p&gt;</comment>
                            <comment id="10812" author="juergen.hoeller" created="Fri, 20 Aug 2004 06:58:58 +0000"  >&lt;p&gt;There&apos;s indeed a further fix necessary. Replace your beforeCompletion method with the following:&lt;/p&gt;

&lt;p&gt;public void beforeCompletion() {&lt;br/&gt;
  if (this.jtaTransaction != null) {&lt;br/&gt;
    // Typically in case of a suspended JTA transaction:&lt;br/&gt;
    // Remove the Session for the current JTA transaction, but keep the holder.&lt;br/&gt;
    Session session = this.sessionHolder.removeSession(this.jtaTransaction);&lt;br/&gt;
    if (session != null) {&lt;br/&gt;
      if (this.sessionHolder.isEmpty()) &lt;/p&gt;
{
        TransactionSynchronizationManager.unbindResource(this.sessionFactory);
      }
&lt;p&gt;      closeSessionOrRegisterDeferredClose(session, this.sessionFactory);&lt;br/&gt;
      return;&lt;br/&gt;
    }&lt;br/&gt;
  }&lt;br/&gt;
  if (this.newSession) {&lt;br/&gt;
    TransactionSynchronizationManager.unbindResource(this.sessionFactory);&lt;br/&gt;
    if (this.hibernateTransactionCompletion) &lt;/p&gt;
{
      closeSessionOrRegisterDeferredClose(this.sessionHolder.getSession(), this.sessionFactory);
    }
&lt;p&gt;  }&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;Unfortunately, our test suite didn&apos;t cover that scenario before: JtaTransactionManager with a registered Hibernate TransactionManagerLookup. Therefore, the bug in the 1.1 codebase didn&apos;t get noticed: It was a side effect of the new suspension-capable synchronization with plain JTA transactions.&lt;/p&gt;

&lt;p&gt;I&apos;ve just added corresponding test cases which all pass with my current version. I&apos;ll commit this promptly; it will be visible in public CVS in a couple of hours. You can give that version a try then, or patch your 1.1 RC2 with the above. In any case, please let me know whether it works for you now!&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="10813" author="victorwon" created="Fri, 20 Aug 2004 09:47:30 +0000"  >&lt;p&gt;Yeah! That does work for me. Everything is running smoothly on my current code base with the above 2 patches.&lt;/p&gt;

&lt;p&gt;However, it failed again with the following exception if I change my ejb descriptor from REQUIRED to REQUIRES_NEW, any idea?&lt;/p&gt;

&lt;p&gt;com.ibm.websphere.ce.cm.StaleConnectionException: class com.ibm.ejs.cm.proxy.OracleConnectionProxy is closed&lt;/p&gt;

&lt;p&gt;	at com.ibm.ejs.container.util.ExceptionUtil.mapCSIException(ExceptionUtil.java:37)&lt;br/&gt;
	at com.ibm.ejs.container.EJSContainer.postInvoke(EJSContainer.java:1948)&lt;br/&gt;
	at com.cot.esd.soa.EJSRemoteStatelessServiceProviderRemote_9df618cc.performService(EJSRemoteStatelessServiceProviderRemote_9df618cc.java:37)&lt;br/&gt;
	at com.cot.esd.soa._EJSRemoteStatelessServiceProviderRemote_9df618cc_Tie.performService(_EJSRemoteStatelessServiceProviderRemote_9df618cc_Tie.java:159)&lt;br/&gt;
	at com.cot.esd.soa._EJSRemoteStatelessServiceProviderRemote_9df618cc_Tie._invoke(_EJSRemoteStatelessServiceProviderRemote_9df618cc_Tie.java:99)&lt;br/&gt;
	at com.ibm.CORBA.iiop.ExtendedServerDelegate.dispatch(ExtendedServerDelegate.java:532)&lt;br/&gt;
	at com.ibm.CORBA.iiop.ORB.process(ORB.java:2450)&lt;br/&gt;
	at com.ibm.CORBA.iiop.OrbWorker.run(OrbWorker.java:186)&lt;br/&gt;
	at com.ibm.ejs.oa.pool.ThreadPool$PooledWorker.run(ThreadPool.java:104)&lt;/p&gt;</comment>
                            <comment id="10814" author="victorwon" created="Fri, 20 Aug 2004 09:49:01 +0000"  >&lt;p&gt;Forgot to mention my code base is still rc2, not the latest cvs.&lt;/p&gt;</comment>
                            <comment id="10815" author="juergen.hoeller" created="Fri, 20 Aug 2004 10:03:32 +0000"  >&lt;p&gt;Hmm, don&apos;t know what your latest exception could originate from... Maybe try this with just EJB CMT, or just Spring transactions?&lt;/p&gt;

&lt;p&gt;In general, note that you can rely on plain EJB CMT too, without Spring&apos;s JtaTransactionManager: HibernateTemplate will still synchronize with the JTA transaction, even detecting transaction suspension (i.e. REQUIRES_NEW), as long as your Hibernate configuraton includes a TransactionManagerLookup.&lt;/p&gt;

&lt;p&gt;That direct synchronization with JTA including support for transaction suspension is the new feature that introduced the side effects that we addressed above &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; With the patches, it should work in every JTA scenario now: both with and without Spring transaction demarcation.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="10816" author="victorwon" created="Fri, 20 Aug 2004 12:16:15 +0000"  >&lt;p&gt;Juergen, thanks for comment. But as I indicated before I need both ejb and spring tx - EJB with CMT provides easy way for distributed app (my client app will have to call the server remotely from another physical box); Spring is fast and most important let me demarcate different tx types on the pojo manager classes (I don&apos;t want to slow down and complicate my server by creating multiple EJBs, especially I&apos;m still using websphere 4 which only supports EJB 1.1).&lt;/p&gt;

&lt;p&gt;I&apos;ve got the spring working with ejb well as long as the ejb don&apos;t start its own tx. Even when ejb starts its own tx, there does seem to be errors as long as the ejb client is not using spring. My problem only occured when in the same container JVM:&lt;br/&gt;
1) use spring managed pojo to start a tx&lt;br/&gt;
2) call an local ejb from within that pojo&lt;br/&gt;
3) ejb starts a new tx&lt;br/&gt;
4) the spring managed pojo called by ejb tries to participate the tx&lt;br/&gt;
At stage 4) I&apos;ll get an exception when hibernate tries to prepare statement - saying it tries to enlist the connection with more than 1 transaction. The error won&apos;t happen if the ejb is remote, or there is no tx started in stage 1).&lt;/p&gt;

&lt;p&gt;I saw another issue that pretty much similar - &lt;a href=&quot;http://opensource.atlassian.com/projects/spring/browse/SPR-206&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://opensource.atlassian.com/projects/spring/browse/SPR-206&lt;/a&gt; - it&apos;s been addressed in 1.1, right? Maybe I tried too hard to bind spring with ejb. &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/tongue.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Any suggestion will be much appreciated.&lt;/p&gt;

&lt;p&gt;Victor&lt;/p&gt;



</comment>
                            <comment id="10817" author="juergen.hoeller" created="Fri, 20 Aug 2004 21:11:58 +0000"  >&lt;p&gt;&lt;a href=&quot;https://jira.spring.io/browse/SPR-206&quot; title=&quot;SessionFactoryUtils doesn&amp;#39;t handle EJB CMT RequiresNew correctly&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPR-206&quot;&gt;&lt;del&gt;SPR-206&lt;/del&gt;&lt;/a&gt; was that new feature with direct Hibernate/JTA synchronization that caused the current trouble &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Interestingly, noone noticed in 1.1 RC1... As I said, it should work now in all cases.&lt;/p&gt;

&lt;p&gt;Of course, using EJBs as remote facades is a viable strategy. However, I still recommend &lt;b&gt;either&lt;/b&gt; EJB CMT &lt;b&gt;or&lt;/b&gt; Spring transaction management: Simply turn your EJBs to BMT if you want to demarcate your transactions in Spring. You EJBs will then serve as pure remote entry points and don&apos;t interfer with transaction management anymore.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="10819" author="victorwon" created="Sat, 21 Aug 2004 01:42:29 +0000"  >&lt;p&gt;Yeah, I was thinking about BMT, the situation is - I need an stateless session bean to do some business in a new tx, if anything fail during the ejb execution, the tx should be rolled back - this can easily be done by CMT Requires_New, but with BMT and a spring requires_new facade inside there is a catch - if the network went down after finishing the spring managed call and before or during the BMT ejb returning the response to the client, the server side tx will NOT be able to rollback. &lt;/p&gt;

&lt;p&gt;Right now, to make it fail-safe I have to either mark CMT as Required and start a NEW tx from the client or use BMT and start a NEW tx from the client - both need client coding to suspend current tx(if any) and start NEW tx. Since the client is not always under my control and the web team(client) may not like or ready to use spring, the client coding will be more complicated than we expect.&lt;/p&gt;

&lt;p&gt;Probably this is just my problem and shouldn&apos;t be discussed here, but I just wish that spring could take one step further to make a perfect integration with ejb - you&apos;re already so close to it. &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
</comment>
                            <comment id="10825" author="victorwon" created="Mon, 23 Aug 2004 03:12:58 +0000"  >&lt;p&gt;Hmmm, BMT doesn&apos;t seem to work.&lt;/p&gt;

&lt;p&gt;After I changed the ejb descriptor to use &amp;lt;transaction-type&amp;gt;Bean&amp;lt;/transaction-type&amp;gt;, I got errors below:&lt;/p&gt;

&lt;p&gt;com.ibm.websphere.ce.cm.StaleConnectionException: class com.ibm.ejs.cm.proxy.OracleConnectionProxy is closed&lt;br/&gt;
	at com.ibm.ejs.cm.proxy.OracleConnectionProxy.prepareStatement(OracleConnectionProxy.java:206)&lt;br/&gt;
	at net.sf.hibernate.impl.BatcherImpl.getPreparedStatement(BatcherImpl.java:249)&lt;br/&gt;
...&lt;/p&gt;

&lt;p&gt;The situation is I started a thread which uses spring to start a new tx, and inside ejb (stateless) I set spring managed methods to PROPERGATION_REQUIRED or PROPAGATION_REQUIRES_NEW. The first spring managed method inside ejb is alway running ok (no matter what propergation) without any complain, but the second one(placed right after first one finishes excution, in the same ejb method) is always fail with above exception no matter what propergation being set. &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;After I reset the ejb to CMT and RequiresNew, everything back to normal (During the test I only changed descriptors, no code change at all).&lt;/p&gt;

&lt;p&gt;Any idea? TIA.&lt;/p&gt;</comment>
                            <comment id="10826" author="victorwon" created="Mon, 23 Aug 2004 03:42:15 +0000"  >&lt;p&gt;In addition, I also tried BMT with no tx started in client side - everything runs smoothly with no exception at all(no matter what propergation set in spring).&lt;/p&gt;</comment>
                            <comment id="10834" author="juergen.hoeller" created="Tue, 24 Aug 2004 20:45:30 +0000"  >&lt;p&gt;I&apos;d like to close this for the time being, as the basic issue has been resolved. If you find out anything further, please create a new enhancement request!&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        12 years, 19 weeks, 2 days ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 19 Aug 2004 18:35:32 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>false</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i01srj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>10537</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>