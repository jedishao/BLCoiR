<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 17:59:23 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-2270/SPR-2270.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-2270] SessionFactoryUtils JtaSessionSynchronization.beforeCompletion swallowing exception</title>
                <link>https://jira.spring.io/browse/SPR-2270</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;We are using Spring 1.2.5 with Weblogic 8.1.4 along with Hibernate 3.1.3 and container managed transactions. When an exception is thrown within the JtaSessionSynchronization.beforeCompletion method, the exception is swallowed by a catch clause. The catch clause simply logs and calls transactionManager.setRollBackOnly. The problem is that in certain cases we would like this exception to be propogated back to the client caller.&lt;/p&gt;

&lt;p&gt;We were wondering why it is necessary to catch all Throwables and call setRollbackOnly? In this case the exception will be a RuntimeException which if uncaught will cause the container to roll back anyway.&lt;/p&gt;

&lt;p&gt;In our own environment we have changed the method from:&lt;/p&gt;

&lt;p&gt;public void beforeCompletion() {&lt;br/&gt;
	try &lt;/p&gt;
{
		boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();
		this.springSessionSynchronization.beforeCommit(readOnly);
	}&lt;br/&gt;
	catch (Throwable ex) {&lt;br/&gt;
		logger.error(&quot;beforeCommit callback threw exception&quot;, ex);&lt;br/&gt;
		try {
			this.jtaTransactionManager.setRollbackOnly();
		}&lt;br/&gt;
		catch (SystemException ex2) {
			logger.error(&quot;Could not set JTA transaction rollback-only&quot;, ex2);
		}&lt;br/&gt;
	}&lt;br/&gt;
	// Unbind the SessionHolder from the thread early, to avoid issues&lt;br/&gt;
	// with strict JTA implementations that issue warnings when doing JDBC&lt;br/&gt;
	// operations after transaction completion (e.g. Connection.getWarnings).&lt;br/&gt;
	this.beforeCompletionCalled = true;&lt;br/&gt;
	this.springSessionSynchronization.beforeCompletion();&lt;br/&gt;
}&lt;br/&gt;
&lt;br/&gt;
to:&lt;br/&gt;
&lt;br/&gt;
public void beforeCompletion() {&lt;br/&gt;
	try {		boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();		this.springSessionSynchronization.beforeCommit(readOnly);	}
&lt;p&gt;	finally &lt;/p&gt;
{
		//Unbind the SessionHolder from the thread early, to avoid issues
		// with strict JTA implementations that issue warnings when doing JDBC
		// operations after transaction completion (e.g. Connection.getWarnings).
		this.beforeCompletionCalled = true;
		this.springSessionSynchronization.beforeCompletion();
	}

&lt;p&gt;}&lt;/p&gt;


&lt;p&gt;For discussion see: &lt;a href=&quot;http://forum.springframework.org/showthread.php?t=26565&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://forum.springframework.org/showthread.php?t=26565&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;

&lt;p&gt;-karl&lt;/p&gt;
</description>
            <key id="14480">SPR-2270</key>
            <summary>SessionFactoryUtils JtaSessionSynchronization.beforeCompletion swallowing exception</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="kbaum">Karl Baum</reporter>
                        <labels>
                    </labels>
                <created>Sun, 9 Jul 2006 23:36:01 +0000</created>
                <updated>Tue, 19 Jun 2012 03:52:47 +0000</updated>
                            <resolved>Sat, 22 Jul 2006 04:00:11 +0000</resolved>
                                    <version>1.2.8</version>
                                    <fixVersion>2.0 RC3</fixVersion>
                                    <component>Data</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="18716" author="juergen.hoeller" created="Sat, 22 Jul 2006 04:00:11 +0000"  >&lt;p&gt;Thanks for pointing this out! I have addressed this - our JTA Synchronization adapters now let a RuntimeException/Error through in beforeCompletion. However, they do still call setRollbackOnly in this case, to make sure that the transaction coordinator behaves correctly. Unfortunately, the JTA 1.0.1 spec does not define the behavior for an exception thrown from beforeCompletion! This has been rectified in JTA 1.1, but that&apos;s only introduced with Java EE 5...&lt;/p&gt;

&lt;p&gt;So with the new behavior, we are relying on the JTA provider not falling over when a JTA Synchronization throws an exception from beforeCompletion, but I guess that&apos;s a pretty safe bet. Still, it&apos;s not defined in the JTA 1.0.1 spec, so there might be some provider that messes up completely in such a scenario... We&apos;ll see. That might be enough reason to &lt;b&gt;not&lt;/b&gt; backport this refinement to 1.2.9, though.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="20692" author="kbaum" created="Thu, 9 Nov 2006 00:51:55 +0000"  >&lt;p&gt;Hi Juergen.  It appears that with weblogic 8.1 sp4, calling  jta.setRollbackOnly() causes the vague AppSetRollbackOnlyException even if we do not trap the RuntimeException.  &lt;/p&gt;

&lt;p&gt;weblogic.transaction.internal.AppSetRollbackOnlyException&lt;br/&gt;
        at weblogic.transaction.internal.TransactionImpl.setRollbackOnly()V(TransactionImpl.java:504)&lt;br/&gt;
        at weblogic.transaction.internal.TransactionManagerImpl.setRollbackOnly()V(TransactionManagerImpl.java:337)&lt;br/&gt;
        at weblogic.transaction.internal.TransactionManagerImpl.setRollbackOnly()V(TransactionManagerImpl.java:331)&lt;br/&gt;
        at org.springframework.transaction.jta.UserTransactionAdapter.setRollbackOnly()V(UserTransactionAdapter.java:86)&lt;br/&gt;
        at org.springframework.orm.hibernate3.SessionFactoryUtils$JtaSessionSynchronization.setRollbackOnlyIfPossible()V(SessionFactoryUtil&lt;br/&gt;
s.java:1030)&lt;br/&gt;
        at org.springframework.orm.hibernate3.SessionFactoryUtils$JtaSessionSynchronization.beforeCompletion()V(SessionFactoryUtils.java:10&lt;br/&gt;
08)&lt;br/&gt;
        at weblogic.transaction.internal.ServerSCInfo.callBeforeCompletions(Lweblogic.transaction.internal.TransactionImpl;)V(ServerSCInfo.&lt;br/&gt;
java:1010)&lt;br/&gt;
        at weblogic.transaction.internal.ServerSCInfo.startPrePrepareAndChain(Lweblogic.transaction.internal.ServerTransactionImpl;I)V(Serv&lt;br/&gt;
erSCInfo.java:115)&lt;/p&gt;

&lt;p&gt;I removed the catch blocks from the code and we are able to to see the actual causing exception on the client GUI side.&lt;/p&gt;

&lt;p&gt;public void beforeCompletion() {&lt;br/&gt;
    try &lt;/p&gt;
{
        boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();
        this.springSynchronization.beforeCommit(readOnly);
    }
&lt;p&gt; finally &lt;/p&gt;
{
        // Unbind the SessionHolder from the thread early, to avoid issues
        // with strict JTA implementations that issue warnings when doing JDBC
        // operations after transaction completion (e.g. Connection.getWarnings).
        this.beforeCompletionCalled = true;
        this.springSynchronization.beforeCompletion();
    }
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;It seems we cannot depend on the behaviour of each J2EE provider in this case.  I think it makes sense to make the jta Synchronization implementation object configurable.  Then spring could possibly supply a Weblogic81Synchronization implementation.  The problem is that the hibernate SessionFactoryUtils class is static which makes this kind of thing not very configurable.  &lt;/p&gt;

&lt;p&gt;Let me know what you think.&lt;/p&gt;

&lt;p&gt;Thanks for your help.&lt;/p&gt;

&lt;p&gt;-karl&lt;/p&gt;
</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        10 years, 8 weeks ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 22 Jul 2006 04:00:11 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>true</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i01emv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>8248</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>