<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 20:18:05 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-2722/SPR-2722.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-2722] PROPAGATION_NOT_SUPPORTED updates enlisted into PROPAGATION_REQUIRES_NEW transaction</title>
                <link>https://jira.spring.io/browse/SPR-2722</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;We are integrating Spring into an existing system.  Since some of the code in the legacy system does manual programmatic transaction management, we need to suspend the Spring transaction in order to call it.  However, we also need to be able to invoke transactional Spring services from within this legacy context, so in certain edge cases we will have transactional stuff invoked from code where no Spring transaction is active, yet database updates will be necessary.&lt;/p&gt;

&lt;p&gt;To do this, we first suspend the Spring transaction using PROPAGATION_NOT_SUPPORTED.  Then, we get a connection from the pool, do some straight JDBC and then programmatically commit/rollback and release the connection.  This all works fine, however, if this code also needs to invoke a Spring-enabled transactional service, the JDBC work done within the context of the PROPAGATION_NOT_SUPPORTED &apos;transaction&apos; gets enlisted and committed by the transactional service.  This happens if either PROPAGATION_REQUIRES_NEW or PROPAGATION_REQUIRED is used.&lt;/p&gt;

&lt;p&gt;I have a junit test case which illustrates this nicely and I will attach it to this issue.&lt;/p&gt;</description>
            <key id="15238">SPR-2722</key>
            <summary>PROPAGATION_NOT_SUPPORTED updates enlisted into PROPAGATION_REQUIRES_NEW transaction</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="gtaylor">Greg Taylor</reporter>
                        <labels>
                    </labels>
                <created>Tue, 17 Oct 2006 02:22:52 +0000</created>
                <updated>Tue, 19 Jun 2012 03:50:48 +0000</updated>
                            <resolved>Mon, 30 Oct 2006 04:21:59 +0000</resolved>
                                    <version>1.2.6</version>
                    <version>1.2.7</version>
                    <version>2.0 final</version>
                                    <fixVersion>2.0.1</fixVersion>
                    <fixVersion>1.2.9</fixVersion>
                                    <component>Transaction</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="20316" author="gtaylor" created="Tue, 17 Oct 2006 02:25:27 +0000"  >&lt;p&gt;Here is the test case.  Unzip the file and update the runTest.bat file to point to the appropriate libs.  Apache commons libs are used, along with Spring (any version it seems) and JUnit.  Oracle is used as well, unfortunately.  You can edit the appContext.xml file found in the .jar to update the data source.&lt;/p&gt;</comment>
                            <comment id="20317" author="gtaylor" created="Tue, 17 Oct 2006 02:27:05 +0000"  >&lt;p&gt;Sorry, forgot to mention that you will need a table in whatever database you use.&lt;/p&gt;

&lt;p&gt;create table TEST&lt;br/&gt;
( ID NUMBER NOT NULL,&lt;br/&gt;
 NAME VARCHAR(40) )&lt;/p&gt;</comment>
                            <comment id="20490" author="juergen.hoeller" created="Fri, 27 Oct 2006 03:53:13 +0000"  >&lt;p&gt;This is probably caused by transaction synchronization being active even for the suspended transaction, and the newly started inner transaction using those synchronized resources.&lt;/p&gt;

&lt;p&gt;Please give the following a try: Specify &quot;SYNCHRONIZATION_ON_ACTUAL_TRANSACTION&quot; on your transaction manager definition.&lt;/p&gt;

&lt;p&gt;  &amp;lt;property name=&quot;transactionSynchronizationName&quot; value=&quot;SYNCHRONIZATION_ON_ACTUAL_TRANSACTION&quot;/&amp;gt;&lt;/p&gt;

&lt;p&gt;And see whether the inner transaction is properly isolated then. I would expect that it is.&lt;/p&gt;

&lt;p&gt;If this works for you, we should consider deactivating transaction synchronization for any NOT_SUPPORTED scope by default...&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="20538" author="juergen.hoeller" created="Mon, 30 Oct 2006 04:21:59 +0000"  >&lt;p&gt;After some further analysis, I&apos;ve decided to go forward with my suggestion above. Our default transaction managers do &lt;b&gt;not&lt;/b&gt; activate transaction synchronization for PROPAGATION_NOT_SUPPORTED (and, for completeness, PROPAGATION_NEVER) anymore. This is also scheduled for backporting to Spring 1.2.9.&lt;/p&gt;

&lt;p&gt;NOT_SUPPORTED has never been specified to activate transaction synchronization in the first place, so the previous behavior can be considered as misbehavior, even if it did not cause any problems unless another nested transaction was triggered within the NOT_SUPPORTED scope (which is rather unusual).&lt;/p&gt;

&lt;p&gt;Still, please do let me know whether &quot;SYNCHRONIZATION_ON_ACTUAL_TRANSACTION&quot; (as suggested above) does work for you on Spring 1.2.8 / 2.0...&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="20585" author="gtaylor" created="Wed, 1 Nov 2006 09:18:19 +0000"  >&lt;p&gt;Sorry for the late response.  Yes, SYNCHRONIZATION_ON_ACTUAL_TRANSACTION does correctly isolate the NOT_SUPPORTED work.  However, it also has the effect of giving me a new connection each time DataSourceUtil.getConnection is called, so the previous nice behaviour of a single connection being used throughout the NOT_SUPPORTED work is lost along with my ability to manage the transaction completely in code.&lt;/p&gt;

&lt;p&gt;The ideal solution in my (admittedly weird) situation would be to have the previous synchronization behaviour, but have the nested transaction suspend the outer &apos;non transaction&apos; &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/warning.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; and revert it to use the previous connection once the nested transaction is finished.  I understand that would be a bit strange, though, so I understand why you would want to disable transaction sync for NOT_SUPPORTED scopes.  Do you think my ideal solution would be a possibility?&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Greg.&lt;/p&gt;</comment>
                            <comment id="20592" author="juergen.hoeller" created="Wed, 1 Nov 2006 19:34:12 +0000"  >&lt;p&gt;Good point. Synchronized resources, even if not transactional, still to provide value there in some scenarios... just like in the SUPPORTS case.&lt;/p&gt;

&lt;p&gt;After some further analysis, I&apos;ve separated the entire synchronization suspend/resume code from actual transaction suspension. It also applies for all &quot;empty&quot; transaction scopes now if transaction synchronization is found to be active: This means that REQUIRED and REQUIRES_NEW will cause a suspension of any current synchronizations that might have been created during SUPPORTS or NOT_SUPPORTED, to be resumed after the inner transaction. This seems to be intuitive and straightforward - and most important of it all, correct in terms of resource isolation.&lt;/p&gt;

&lt;p&gt;So any nesting of REQUIRED, REQUIRES_NEW, SUPPORTS and NOT_SUPPORTED is fully supported now, no matter how deep the nesting is (previously it only worked for two levels in case of transaction synchronization being active - hence you hit the limit because of the three levels in your scenario), and even with synchronized resources for the &quot;empty&quot; transaction scopes (in case of SYNCHRONIZATION_ALWAYS; can still be turned off through SYNCHRONIZATION_ON_ACTUAL_TRANSACTION).&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="20598" author="juergen.hoeller" created="Thu, 2 Nov 2006 00:14:01 +0000"  >&lt;p&gt;FYI, this is committed to CVS now and should be available in the next nightly snapshot (&lt;a href=&quot;http://www.springframework.org/snapshots&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.springframework.org/snapshots&lt;/a&gt;). Feel free to give it an early try...&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="20611" author="gtaylor" created="Thu, 2 Nov 2006 07:45:41 +0000"  >&lt;p&gt;I tried it and it works perfectly.  Thanks for the quick turnaround and open-mindedness!  You guys deserve all the kudos you get.&lt;/p&gt;

&lt;p&gt;Regards,&lt;br/&gt;
Greg.&lt;/p&gt;</comment>
                            <comment id="20612" author="juergen.hoeller" created="Thu, 2 Nov 2006 07:52:27 +0000"  >&lt;p&gt;Good to hear that it works for you - thanks for the quick testing &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="20629" author="gtaylor" created="Fri, 3 Nov 2006 06:24:16 +0000"  >&lt;p&gt;Juergen,&lt;/p&gt;

&lt;p&gt;While I have your attention on this, I&apos;d like to run this by you as I think there might be some benefit to the Spring framework from our experiences.  I think (and I may be wrong here) it is far more common for Spring to be used in new development than for it to be integrated into large existing systems, so perhaps the latter hasn&apos;t been as high of a priority.&lt;/p&gt;

&lt;p&gt;The bigger picture is that I am working integration of Spring-enabled transactional services into a large existing J2EE web application.  The existing app is using straight JDBC and has no explicit transaction management.  The services we are defining are making use of Spring JDBC and declarative transactions.&lt;/p&gt;

&lt;p&gt;What we want is to have the transactional services participate in the legacy transactional context.  What we DON&apos;T want is to refactor all the (sometimes nasty) legacy code so that it can call the Spring services and preserve transactional integrity.  The problem is that we need to get the legacy java.sql.Connection object into the Spring transactional context.  This doesn&apos;t seem to be possible at present without hacking, or at least using some Spring classes that were not intended for public use, such as TransactionSynchronizationManager and ConnectionHolder.  Also, if transaction synchronization is active, as we would need it to be to belong to the same transaction, when you exit the Spring transactional context, the connection will be closed.  Dealing with this will require some nastier hacks, unless we integrate Spring transactions into the entire legacy codebase, which is highly invasive.&lt;/p&gt;

&lt;p&gt;So, are you aware of any intended ways that we could do something like this?  Having looked at the Javadoc and a lot of the code, I can&apos;t see any obvious intentional way.  If not, do you see any value in possibly adding this type of functionality in a future release to assist integration of Spring into legacy apps?  If you think this is worthy, I can definitely enter a feature request.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Greg.&lt;/p&gt;</comment>
                            <comment id="21429" author="juergen.hoeller" created="Fri, 22 Dec 2006 05:40:38 +0000"  >&lt;p&gt;Just noticed that I never replied to your last comment...&lt;/p&gt;

&lt;p&gt;Integrating with existing transactional contexts is certainly not a mainstream usage of Spring, but it should nevertheless be quite smooth: TransactionSynchronizationManager is available for direct use in advanced applications, as is the ConnectionHolder class for a transactional JDBC Connection. In your scenario, you could simply create a ConnectionHolder for your existing transactional Connection, switch the holder&apos;s &quot;transactionActive&quot; flag on, and bind the holder instance to the thread via TransactionSynchronizationManager, using the DataSource (that the Connection was obtained from) as key. When you&apos;re done, unbind the holder from the thread using TransactionSynchronizationManager again (ideally in a finally block). The DataSource doesn&apos;t actually have to be the exact one that created the Connection; it just needs to match the DataSource that the Spring-based DAOs use to access the same database.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="22035" author="juergen.hoeller" created="Mon, 5 Feb 2007 09:40:56 +0000"  >&lt;p&gt;FYI, I&apos;ve made (another) Spring 1.2.9 release candidate snapshot available at:&lt;br/&gt;
&lt;a href=&quot;http://static.springframework.org/downloads/nightly&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://static.springframework.org/downloads/nightly&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The current candidate is the 20070205 snapshot, which is finally scheduled for release this Friday unless any issues are found.&lt;br/&gt;
Please give this snapshot a try in a 1.2.8-based application, if you happen to have any, and let me know whether it works for you!&lt;/p&gt;

&lt;p&gt;Thanks for your efforts,&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12035" name="TxPropagationTest.zip" size="8333" author="gtaylor" created="Tue, 17 Oct 2006 02:25:27 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        9 years, 47 weeks, 3 days ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Fri, 27 Oct 2006 03:53:13 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>false</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i00vjr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5156</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>