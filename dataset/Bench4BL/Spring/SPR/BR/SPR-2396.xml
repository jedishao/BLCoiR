<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 18:58:22 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-2396/SPR-2396.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-2396] AbstractTransactionalSpringContextTests does not handle preventTransaction() in tearDown() correctly</title>
                <link>https://jira.spring.io/browse/SPR-2396</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;In onSetup() the condition used to detect that a transaction should not be started is:&lt;/p&gt;

&lt;p&gt;if (this.transactionManager == null) {&lt;br/&gt;
else if (this.transactionDefinition == null) {&lt;/p&gt;

&lt;p&gt;But in onTearDown() there is not such guard. onTearDown always invokes endTransaction(). endTransaction will check if there is a null transactionStatus, but this value can be set if a transaction was started by the test itself via startNewTransaction.&lt;/p&gt;

&lt;p&gt;This causes problems with test of the form:&lt;/p&gt;

&lt;p&gt;public class TransactionsTest extends AbstractAspectjJpaTests { &lt;/p&gt;

&lt;p&gt;    ...&lt;/p&gt;

&lt;p&gt;    @Override&lt;br/&gt;
    public void runBare() throws Throwable &lt;/p&gt;
{
        preventTransaction();
        super.runBare();
    }

&lt;p&gt;    public void testRollback() {&lt;br/&gt;
        TransactionEntityForTest entity;&lt;/p&gt;
        {
            startNewTransaction();
            entity = new TransactionEntityForTest();
            sharedEntityManager.persist(entity);
            endTransaction();
        }

&lt;p&gt;        try &lt;/p&gt;
{
            startNewTransaction();
            sharedEntityManager.persist(entity);
            fail(&quot;expected exception&quot;);
            endTransaction();
        }
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
            System.err.println(&quot;***&quot; + e);
            transactionManager.rollback(transactionStatus);
        }
&lt;p&gt;    }&lt;br/&gt;
} &lt;/p&gt;

&lt;p&gt;At the end of the test methods, spring will still try to commit the transaction because of what I described above. This results in an exception:&lt;/p&gt;

&lt;p&gt;		if (defStatus.isCompleted()) &lt;/p&gt;
{
			throw new IllegalTransactionStateException(
					&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;);
		}

&lt;p&gt;If the onTearDown() used the same guard as the onSetupUp, then AbstractTransactionalSpringContextTests.commit() would never have been called.&lt;/p&gt;</description>
            <key id="14712">SPR-2396</key>
            <summary>AbstractTransactionalSpringContextTests does not handle preventTransaction() in tearDown() correctly</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="memelet">Barry Kaplan</reporter>
                        <labels>
                    </labels>
                <created>Tue, 8 Aug 2006 23:47:34 +0000</created>
                <updated>Tue, 19 Jun 2012 03:50:59 +0000</updated>
                            <resolved>Thu, 10 Aug 2006 03:42:41 +0000</resolved>
                                    <version>2.0 RC2</version>
                                    <fixVersion>2.0 RC3</fixVersion>
                                    <component>Core</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="18990" author="juergen.hoeller" created="Thu, 10 Aug 2006 03:30:52 +0000"  >&lt;p&gt;I have added a corresponding check (transactionStatus != null &amp;amp;&amp;amp; !transactionStatus.isCompleted) to avoid that IllegalTransactionStateException... However, I wonder why you arrived there in the first place. As far as I see, this can only happen if you called startNewTransaction and committed or rolled back the transaction directly via the transaction manager, rather than calling endTransaction. Do you have any specific reason why you are doing things that way?&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="18991" author="springboy" created="Thu, 10 Aug 2006 03:33:00 +0000"  >&lt;p&gt;Assigned to Juergen since he has already evidently committed some code to address this.&lt;/p&gt;</comment>
                            <comment id="19006" author="memelet" created="Fri, 11 Aug 2006 01:53:05 +0000"  >&lt;p&gt;At the catch block fo the test above, hibernate has thrown an exception related to the primary key violation.  If I use endTransaction&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;it will invoke transactionManager.commit. In AbstractPlatformTransactionManager.commit&lt;/li&gt;
	&lt;li&gt;defStatus is /not/ marked as rollbackOnly (should it be?), so processCommit is called&lt;/li&gt;
	&lt;li&gt;which leads to JtaTransactionManager.doCommit&lt;/li&gt;
	&lt;li&gt;doCommit will executed txObject.getUserTransaction().commit(), which results in catching RollbackException and rethrowing UnexpectedRollbackException&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In production, I would have an aspect wrapped around the method call which would handle rollback. But since this test case is managing the transactions itself, it needs perform the rollback. Is this not correct?&lt;/p&gt;
</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        10 years, 20 weeks, 6 days ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 10 Aug 2006 03:30:52 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>true</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i04ulj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>28331</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>