<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 19:12:57 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-2425/SPR-2425.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-2425] getBeanNamesForType with includeFactories = true causes inconsistent construction semantics</title>
                <link>https://jira.spring.io/browse/SPR-2425</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;The construction semantics for getBeanNamesForType are inconsistent, in that any user in the container may cause an alteration in startup behaviour by issuing a query with the includeFactories = true parameter.&lt;/p&gt;

&lt;p&gt;The relevant code is in DefaultListableBeanFactory - should it fail on the first branch, it will attempt to make a match on bean type based on a query for the factory itself:&lt;/p&gt;

&lt;p&gt;		// In case of FactoryBean, try to match FactoryBean itself next.&lt;br/&gt;
					beanName = FACTORY_BEAN_PREFIX + beanName;&lt;br/&gt;
				}&lt;br/&gt;
				// Match raw bean instance (might be raw FactoryBean).&lt;br/&gt;
				if ((includePrototypes || rbd.isSingleton()) &amp;amp;&amp;amp; isBeanTypeMatch(beanName, type)) &lt;/p&gt;
{
					result.add(beanName);
				}

&lt;p&gt;and/or from &quot;AbstractBeanFactory.getType&quot;:&lt;br/&gt;
		// Check bean class whether we&apos;re dealing with a FactoryBean.&lt;br/&gt;
			if (FactoryBean.class.isAssignableFrom(beanClass) &amp;amp;&amp;amp; !isFactoryDereference(name)) &lt;/p&gt;
{
				// If it&apos;s a FactoryBean, we want to look at what it creates, not the factory class.
				FactoryBean factoryBean = (FactoryBean) getBean(FACTORY_BEAN_PREFIX + beanName);
				return factoryBean.getObjectType();
			}

&lt;p&gt;This will cause the factory bean to be &quot;incompletely constructed&quot; - it will have dependencies delivered, but will not be used to deliver its product. This means that the bean in question will not be constructed properly during startup of the container in general (assuming it has lazy-init=&quot;false&quot;), unless it is explicitly demanded as a dependency by another bean. There seem to be a number of ways out of this - either any fetch of a FactoryBean should fully construct both itself and product, &lt;b&gt;or&lt;/b&gt; the container should detect such partially constructed factories during the rest of its startup, and continue to fully construct them then.&lt;/p&gt;

&lt;p&gt;Right now I have to make sure that neither myself nor any of my users issue such a query during startup, i.e. this represents an unpleasant race condition. The possibility for construct &lt;b&gt;order&lt;/b&gt; perturbation is fine, and any correct bean container should be prepared for this, but construct &lt;b&gt;result&lt;/b&gt; perturbation is not.&lt;/p&gt;</description>
            <key id="14760">SPR-2425</key>
            <summary>getBeanNamesForType with includeFactories = true causes inconsistent construction semantics</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="bosmon">Antranig Basman</reporter>
                        <labels>
                    </labels>
                <created>Mon, 14 Aug 2006 05:49:50 +0000</created>
                <updated>Tue, 19 Jun 2012 03:50:55 +0000</updated>
                            <resolved>Thu, 17 Aug 2006 07:19:11 +0000</resolved>
                                    <version>1.2.8</version>
                                    <fixVersion>2.0 RC4</fixVersion>
                                    <component>Core</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="19049" author="juergen.hoeller" created="Mon, 14 Aug 2006 11:35:25 +0000"  >&lt;p&gt;I&apos;m not sure what kind of partial construction of FactoryBeans you&apos;re referring to here. A getBean call for a FactoryBean will fully instantantiate and configure the FactoryBean instances. In the above case, we only call getObjectType on that FactoryBean instance, which is perfectly fine - since the FactoryBean should not rely on a getObject call! A FactoryBean is supposed to initialize itself based on standard bean mechanisms such as bean properties and init methods. getObject and getObjectType constitute runtime access methods that are &lt;b&gt;not&lt;/b&gt; a guaranteed part of the initialization cycle.&lt;/p&gt;

&lt;p&gt;Hence, I would argue that the behavior that you outlined is expected and correct. Please correct me if I misunderstood your scenario...&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="19054" author="bosmon" created="Mon, 14 Aug 2006 12:10:25 +0000"  >&lt;p&gt;It&apos;s not so much that the FactoryBean &lt;b&gt;depends&lt;/b&gt; on the the getObject call, but that this is what the container naturally issues (at least at an &quot;as if&quot; level) if the query mentioned above is not performed first. The real problem is that the getObjectType &lt;del&gt;&amp;gt; get-of&lt;/del&gt;&amp;amp;bean induced by the query prevents the more complete instantiation of the factory product that is &quot;going to occur&quot; in the absence of the query. Therefore the current semantics constitute a somewhat spooky &quot;action at a distance&quot; whereby an inhabitant of the bean container can change the semantics of other, unrelated beans by issuing what at first sight should be a side-effect-free query. &lt;/p&gt;

&lt;p&gt;Whilst I appreciate that your argument (declaration? &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/tongue.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;) that getObject is not in your view part of the initialization cycle of a FactoryBean, the only documentation that I can find relevant to this point is the following comment from FactoryBean:&lt;/p&gt;

&lt;p&gt;If this method returns &amp;lt;code&amp;gt;null&amp;lt;/code&amp;gt;, the factory will consider&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;the FactoryBean as not fully initialized and throw a corresponding&lt;/li&gt;
	&lt;li&gt;FactoryBeanNotInitializedException.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So if as you say getObject is &lt;b&gt;not&lt;/b&gt; part of the initialization cycle, why would a null return cause the container to deduce that the bean is &quot;not fully initialized&quot;? In any case, getObject (for a singleton) &lt;b&gt;is&lt;/b&gt; what the container as default will issue in the absence of interference from the query. And if it is not part of the initialization cycle, why will it issue it by default at startup? Would it therefore not be more consistent for the default behaviour for a FactoryBean found in the container without a dependent to agree with the query result above, i.e. full construction of the bean but &lt;b&gt;no&lt;/b&gt; call to getObject?&lt;/p&gt;

&lt;p&gt;I appreciate that going for the last mentioned approach would cause a &lt;b&gt;massive&lt;/b&gt; failure of backwards compatibility, so could we not restore consistency by fixing up the query behaviour (which query is much more recent in vintage) instead?&lt;/p&gt;</comment>
                            <comment id="19099" author="juergen.hoeller" created="Thu, 17 Aug 2006 04:12:38 +0000"  >&lt;p&gt;Actually, the contract for a FactoryBean&apos;s getObject method changed slightly in Spring 2.0. Quoting the javadoc:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;If this FactoryBean is not fully initialized yet at the time of&lt;/li&gt;
	&lt;li&gt;the call (for example because it is involved in a circular reference),&lt;/li&gt;
	&lt;li&gt;throw a corresponding 
{@link FactoryBeanNotInitializedException}
&lt;p&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;That change is a consequence of null being a valid return value for getObject now, in case that the FactoryBean intends to deliberately produce a null reference.&lt;/p&gt;

&lt;p&gt;That difference aside, all of this indicates that &quot;getObject()&quot; is just an accessor for the current state of the object. If it was a fixed part of the initialization procedure, it would always produce an object - it would never return null or throw a &quot;not initialized yet&quot; exception. Only accessors (that expose the current state but are not responsible for building it) do the latter.&lt;/p&gt;

&lt;p&gt;So I would still argue that a proper FactoryBean implementation needs to rely on standard bean facilities (constructors, bean properties, standard bean callbacks) to initialize itself, with getObject and getObjectType just doing their best on the basis of the present state. It must support getObjectType calls before getObject calls - dependent on the other bean definitions, right, but still a valid and expected usage scenario that shouldn&apos;t confuse the bean. All of Spring&apos;s pre-built FactoryBeans should demonstrate that implementation strategy, so can serve as a role model.&lt;/p&gt;

&lt;p&gt;Essentially, the &quot;getObject()&quot; is called &lt;b&gt;every time&lt;/b&gt; that the FactoryBean&apos;s object is referenced. That method needs to expose a proper object based on the FactoryBean&apos;s state every time (either the same instance or a new instance, based on whether it indicates a singleton or a prototype). It cannot, however, rely on a single &quot;getObject()&quot; call occuring at startup - this just doesn&apos;t match the intent of the method, which is being called if an actual reference to the object is needed (as opposed to just checking the object&apos;s type).&lt;/p&gt;

&lt;p&gt;As a further indication - completely independent from the type checking scenario -, consider a FactoryBean definition that is never actually accessed by the application. Such a FactoryBean will be fully initialized according to the standard bean contract, but it&apos;s getObject method will &lt;b&gt;never&lt;/b&gt; be called - since noone expressed a reference to it!&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="19100" author="bosmon" created="Thu, 17 Aug 2006 04:37:38 +0000"  >&lt;p&gt;Just to quote your final point, which I believe is key:&lt;/p&gt;


&lt;p&gt;&quot;As a further indication - completely independent from the type checking scenario -, consider a FactoryBean definition that is never actually accessed by the application. Such a FactoryBean will be fully initialized according to the standard bean contract, but it&apos;s getObject method will &lt;b&gt;never&lt;/b&gt; be called - since noone expressed a reference to it! &quot;&lt;/p&gt;


&lt;p&gt;This is actually the whole basis of my bug report, since what you claim for current Spring behaviour is not the case (at least as of 1.2.8, and all other 1.2.x versions I have tried - I suspect actually even since much earlier). A FactoryBean definition for a singleton that is never accessed by the application &lt;b&gt;will&lt;/b&gt; have its getObject method called during container startup. I agree that if this did not occur, the behaviour in the face of the query we are discussing would thus be consistent and there would be no &quot;bug&quot;.&lt;/p&gt;

&lt;p&gt;I had always taken this behaviour which I have relied on since early versions of Spring was symptomatic of the semantics that within Spring, singleton factories had a &quot;special status&quot; with regards construction. It appears from your explanation above that this was never your intention. &lt;/p&gt;

&lt;p&gt;If you are happy to modify the current implementation so that it agrees with your belief expressed in the final paragraph, this bug can be closed, although for me this would be an irritating breaking change - I would much prefer that the implementation were modified in the &lt;b&gt;other&lt;/b&gt; direction, i.e. that all singleton FactoryBeans will &lt;b&gt;continue&lt;/b&gt; to produce their products at startup regardless of whether they have been queried or not. One way or the other though, I believe this behaviour needs to be changed.&lt;/p&gt;

&lt;p&gt;(Just to comment on your interior points, yes it makes perfect sense for the bean to be able to answer getObjectType calls before getObject calls, and I agree with all your points re standard bean facilities wrt. FactoryBeans - but the point at issue here is that I don&apos;t believe it is entirely &quot;reasonable&quot; to impose a model whereby getObject() is entirely side-effect free, and under the current model these side-effects occur inconsistently)&lt;/p&gt;</comment>
                            <comment id="19102" author="juergen.hoeller" created="Thu, 17 Aug 2006 07:19:11 +0000"  >&lt;p&gt;My apologies - you are right, of course. It&apos;s even the case in the current 2.0 codebase. That&apos;s what one gets when I write a comment right before going into dinner break... &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;That said, this is rather embarrassing - since it is not actually intended that way. DefaultListableBeanFactory&apos;s &quot;preInstantiateSingletons()&quot; method (which is responsible for this early getObject call on FactoryBeans) hasn&apos;t changed in a long while, back to the old Spring 1.0 days... long before the introduction of &quot;getBeanNamesOfType&quot; (which happened late in the 1.1 phase).&lt;/p&gt;

&lt;p&gt;Hence, I have removed the early getObject call there. &quot;Pre-instantiating&quot; a FactoryBean now just means instantiating the FactoryBean instance according to standard bean rules, with &quot;getObject&quot; and &quot;getObjectType&quot; just being pure accessors called for an actual reference / actual type check. Fortunately, our entire test suite still passes (except for one AOP-related test that checks the exact invocation numbers on the FactoryBean instance, which are now less).&lt;/p&gt;

&lt;p&gt;This new behavior will apply for Spring 2.0 only, though. We will do a Spring 1.2.9 release some time in September, but that one must not introduce &lt;b&gt;any&lt;/b&gt; potential for backwards compatibility issues. Still, I do not expect any severe compatibility issues from 1.2 to 2.0 there, since FactoryBeans have been implemented in that style for a long time... It&apos;s just that the BeanFactory&apos;s exact handling of FactoryBeans was a little outdated.&lt;/p&gt;

&lt;p&gt;Thanks for pointing this out, and thanks for insisting on your point &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        10 years, 20 weeks ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 14 Aug 2006 11:35:25 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>false</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i04uiv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>28319</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>