<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 19:28:39 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-1535/SPR-1535.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-1535]  Spring 1.3 JMS listener </title>
                <link>https://jira.spring.io/browse/SPR-1535</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;        Spring 1.3 Release Candidate ship with a sophisticated JMS listener solution: properly supporting concurrent reception, possibly also transactional reception. &lt;/p&gt;

&lt;p&gt;	But, here&apos;s an interesting conflict between JMS and J2EE that has been popularly discovered. Could you please take a look to find out the work around solution for it? &lt;/p&gt;

&lt;p&gt;	Appreciate your care on this critical issue with Spring 1.3 JMS listener!&lt;/p&gt;

&lt;p&gt;	You can&apos;t run an implementor of MessageListener in a J2EE container. J2EE 1.3 says not to do it in the EJB container. J2EE 1.4 says not to do it in the Web container either. Basically, you can&apos;t use it in any container that controls thread creation, which is any container except an application client container.&lt;/p&gt;

&lt;p&gt;&quot;Note: A MessageListener can only be used in the client container. (The J2EE specification forbids the use of the JMS MessageListener mechanism for the asynchronous receipt of messages in the EJB and Web containers.)&quot; &lt;/p&gt;

&lt;p&gt;	The section &quot;J2EE.6.7 Java&#8482; Message Service (JMS) 1.0 Requirements&quot; of the J2EE specification gives a list of methods that must not be called in Web and EJB containers. This is enforced in WebSphere Application Server by throwing a javax.jms.IllegalStateException.&lt;/p&gt;

&lt;p&gt;	Here is a relevant part from J2EE 1.3 specification:&lt;a href=&quot;http://java.sun.com/j2ee/j2ee-1_3-fr-spec.pdf&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://java.sun.com/j2ee/j2ee-1_3-fr-spec.pdf&lt;/a&gt; section 6.7:&lt;/p&gt;

&lt;p&gt;message listeners. The use of this message listener facility may be &lt;br/&gt;
limited by the restrictions on the use of threads in various &lt;br/&gt;
containers. In EJB containers, for instance, it is typically not &lt;br/&gt;
possible to create threads. The following methods must not be used by &lt;br/&gt;
application components executing in containers that prevent them &lt;br/&gt;
from creating threads: &lt;br/&gt;
. &lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;javax.jms.Session method setMessageListener&lt;/li&gt;
	&lt;li&gt;javax.jms.Session method getMessageListener&lt;/li&gt;
	&lt;li&gt;javax.jms.Session method run&lt;/li&gt;
	&lt;li&gt;javax.jms.QueueConnection method createConnectionConsumer&lt;/li&gt;
	&lt;li&gt;javax.jms.TopicConnection method createConnectionConsumer&lt;/li&gt;
	&lt;li&gt;javax.jms.TopicConnection method createDurableConnectionConsumer&lt;/li&gt;
	&lt;li&gt;javax.jms.MessageConsumer method getMessageListener&lt;/li&gt;
	&lt;li&gt;javax.jms.MessageConsumer method setMessageListener&lt;br/&gt;
. &lt;br/&gt;
In addition, use of the following methods on javax.jms.Connection&lt;br/&gt;
objects by applications in web and EJB containers may interfere with the&lt;br/&gt;
connection management functions of the container and must not be used:&lt;/li&gt;
	&lt;li&gt;setExceptionListener&lt;/li&gt;
	&lt;li&gt;stop&lt;/li&gt;
	&lt;li&gt;setClientID&lt;br/&gt;
A J2EE container may throw a JMSException if the application component &lt;br/&gt;
violates these restrictions. ....&quot;  &lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;	WebSphere Application Server 5 and 6 don&apos;t allow MessageListeners to be used in either container. When you try, you get an error like this:&lt;/p&gt;

&lt;p&gt;javax.jms.IllegalStateException: Method setMessageListener not permitted&lt;br/&gt;
at com.ibm.ejs.jms.JMSCMUtils.methodNotPermittedException(JMSCMUtils.java:202)&lt;br/&gt;
at com.ibm.ejs.jms.JMSMessageConsumerHandle.setMessageListener(JMSMessageConsumerHandle.java:193)&lt;br/&gt;
at MyMessageListenerImpl.connect(MyMessageListenerImpl.java:39)&lt;br/&gt;
. . .&lt;/p&gt;

&lt;p&gt;	So WebSphere Application Server doesn&apos;t actually prevent you from deploying a class that implements MessageListener, but when you try to run your code, WAS prevents the MessageConsumer.setMessageListener(MessageListener) method from running by throwing an IllegalStateException. For details, see IBM WMQ FAQ answer #92 and IBM Technote #1114239.&lt;/p&gt;

&lt;p&gt;	So when you get this error, the problem isn&apos;t a bug in your code, it&apos;s your entire approach. In a nutshell, if you want to run a MessageListener in J2EE, don&apos;t implement a MessageListener, implement a (can you guess?) messsage-driven bean (the JMS kind, which implements MessageListener). And if you don&apos;t like using EJBs? Get used to it. MDBs work in J2EE; MessageListeners don&apos;t.&lt;/p&gt;


&lt;p&gt;	BTW, here is the code snippet which is based on Spring 1.3 MessageListener, the code does not work on WebSphere Application Server 6: it throws javax.jms.IllegalStateException at the highlighted code below. &lt;/p&gt;


&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt;   public class MessageHandlerDAO implements MessageListener,&lt;br/&gt;
&amp;gt;   InitializingBean {&lt;br/&gt;
&amp;gt;   protected final Log log = LogFactory.getLog(getClass());&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;   private Type1MessageHandler type1MessageHandler;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;   private Type2MessageHandler type2MessageHandler;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;   private Type3MessageHandler type3MessageHandler;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;   private JmsTemplate102 jmsTemplate;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;   private QueueConnection conn;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;   private String username;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;   private String password;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;   public MessageHandlerDAO() &lt;/p&gt;
{
&amp;gt;    log.info(&quot;Creating MessageHandlerDAO().................&quot;);
&amp;gt;   }
&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt;   /**&lt;br/&gt;
&amp;gt;    * listening method.&lt;br/&gt;
&amp;gt;    */&lt;br/&gt;
&amp;gt;   public void onMessage(Message message) {&lt;br/&gt;
&amp;gt;    log.info(&quot;onMessage()....................&quot;);&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;    TextMessage msg = null;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;    try {&lt;br/&gt;
&amp;gt;     if (message instanceof TextMessage) {&lt;br/&gt;
&amp;gt;      msg = (TextMessage) message;&lt;br/&gt;
&amp;gt;      if(log.isDebugEnabled())&lt;br/&gt;
&amp;gt;       log.debug(&quot;Reading message: &quot; + msg.getText());&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;      MessageParser messageParser = new PortalXMLMessageParser();&lt;br/&gt;
&amp;gt;      GeneralMessage gm = messageParser.parse(msg.getText());&lt;br/&gt;
&amp;gt;      if(gm == null)&lt;/p&gt;
{
&amp;gt;       log.info(&quot;message format not right!&quot;);
&amp;gt;       return;
&amp;gt;      }
&lt;p&gt;&amp;gt;      String type = gm.getType();&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;      if (MessageHandlerDAO.isNonBlank(type)) {&lt;br/&gt;
&amp;gt;       if (type.equals(&quot;1&quot;)) {&lt;br/&gt;
&amp;gt;        if (type1MessageHandler.handle(gm)) &lt;/p&gt;
{
&amp;gt;         if(log.isDebugEnabled())
&amp;gt;          log.debug(&quot;Successfully deal with the message!&quot;
&amp;gt;           + &quot; (The message type is : 1&quot;);
&amp;gt;        }
&lt;p&gt; else &lt;/p&gt;
{
&amp;gt;         if(log.isDebugEnabled())
&amp;gt;          log.debug(&quot;Fail to deal with the message!&quot;
&amp;gt;           + &quot; (The message type is : 1&quot;);
&amp;gt;        }
&lt;p&gt;&amp;gt;       } else if (type.equals(&quot;2&quot;)) {&lt;br/&gt;
&amp;gt;        if (type2MessageHandler.handle(gm)) &lt;/p&gt;
{
&amp;gt;         if(log.isDebugEnabled())
&amp;gt;          log.debug(&quot;Successfully deal with the message!&quot;
&amp;gt;           + &quot; (The message type is : 2&quot;);
&amp;gt;        }
&lt;p&gt; else &lt;/p&gt;
{
&amp;gt;         if(log.isDebugEnabled())
&amp;gt;          log.debug(&quot;Fail to deal with the message!&quot;
&amp;gt;           + &quot; (The message type is : 2&quot;);
&amp;gt;        }
&lt;p&gt;&amp;gt;       } else if (type.equals(&quot;3&quot;)) {&lt;br/&gt;
&amp;gt;        if (type3MessageHandler.handle(gm)) &lt;/p&gt;
{
&amp;gt;         if(log.isDebugEnabled())
&amp;gt;          log.debug(&quot;Successfully deal with the message!&quot;
&amp;gt;           + &quot; (The message type is : 3&quot;);
&amp;gt;        }
&lt;p&gt; else &lt;/p&gt;
{
&amp;gt;         if(log.isDebugEnabled())
&amp;gt;          log.debug(&quot;Fail to deal with the message!&quot;
&amp;gt;           + &quot; (The message type is : 3&quot;);
&amp;gt;        }
&lt;p&gt;&amp;gt;       }&lt;br/&gt;
&amp;gt;      } else &lt;/p&gt;
{
&amp;gt;       log.info(&quot;Unknow the message type!&quot;);
&amp;gt;      }
&lt;p&gt;&amp;gt;     } else &lt;/p&gt;
{
&amp;gt;      log.error(&quot;This message type is not correct : &quot;
&amp;gt;        + message.getClass().getName());
&amp;gt;     }
&lt;p&gt;&amp;gt;    } catch (JMSException jmse) &lt;/p&gt;
{
&amp;gt;     log.error(&quot;JMSException&quot;, jmse);
&amp;gt;    }
&lt;p&gt;&amp;gt;   }&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;   public void afterPropertiesSet() throws Exception &lt;/p&gt;
{
&amp;gt;    initial();
&amp;gt;   }
&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt;   public void destroy() {&lt;br/&gt;
&amp;gt;    try &lt;/p&gt;
{
&amp;gt;     conn.close();
&amp;gt;     log.info(&quot;JMS Connection close successfully!&quot;);
&amp;gt;    }
&lt;p&gt; catch (JMSException e) &lt;/p&gt;
{
&amp;gt;     log.error(&quot;Message Exception&quot;, e);
&amp;gt;    }&lt;br/&gt;
&amp;gt;   }&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;   public void initial() {&lt;br/&gt;
&amp;gt;       log.info(&quot;initial()...................&quot;);&lt;br/&gt;
&amp;gt;    try {
&amp;gt;   //   conn = jmsTemplate.getConnectionFactory().createConnection(
&amp;gt;   //     username, password);
&amp;gt;     Context context = new InitialContext();
&amp;gt;     QueueConnectionFactory qcf =
&amp;gt;      (QueueConnectionFactory) context.lookup(&quot;ConnectionFactory&quot;);
&amp;gt;     context.close();
&amp;gt;     conn = qcf.createQueueConnection();
&amp;gt;     context = new InitialContext();
&amp;gt;     Queue queue = (Queue) context.lookup(&quot;queue/wftopic&quot;);
&amp;gt;     context.close();
&amp;gt;     QueueSession session = conn
&amp;gt;       .createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
&amp;gt;     QueueReceiver receiver = session.createReceiver(queue);
&amp;gt;     receiver.setMessageListener(this);
&amp;gt;     conn.start();
&amp;gt;
&amp;gt;   //            conn =
&amp;gt;   jmsTemplate.getConnectionFactory().createConnection();
&amp;gt;   //   conn.createSession(false, javax.jms.Session.AUTO_ACKNOWLEDGE)
&amp;gt;   //     .createConsumer(jmsTemplate.getDefaultDestination())
&amp;gt;   //     .setMessageListener(this);
&amp;gt;   //   conn.start();
&amp;gt;    } catch (Exception e) {&amp;gt;     log.error(&quot;Message Exception&quot;, e);&amp;gt;    }
&lt;p&gt;&amp;gt;    log.info(&quot;Listening to the message................, &quot; +&lt;br/&gt;
&amp;gt;   Thread.currentThread().getName());&lt;br/&gt;
&amp;gt;   }&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;   public static boolean isBlank(String input) {&lt;br/&gt;
&amp;gt;    if ((input == null) || (input.length() == 0)) &lt;/p&gt;
{
&amp;gt;     return true;
&amp;gt;    }
&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt;    return input.trim().length() == 0;&lt;br/&gt;
&amp;gt;   }&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;   public static boolean isNonBlank(String input) &lt;/p&gt;
{
&amp;gt;    return !isBlank(input);
&amp;gt;   }
&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt;   public void setType1MessageHandler(Type1MessageHandler&lt;br/&gt;
&amp;gt;   type1MessageHandler) &lt;/p&gt;
{
&amp;gt;    this.type1MessageHandler = type1MessageHandler;
&amp;gt;   }
&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt;   public void setType2MessageHandler(Type2MessageHandler&lt;br/&gt;
&amp;gt;   type2MessageHandler) &lt;/p&gt;
{
&amp;gt;    this.type2MessageHandler = type2MessageHandler;
&amp;gt;   }
&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt;   public void setType3MessageHandler(Type3MessageHandler&lt;br/&gt;
&amp;gt;   type3MessageHandler) &lt;/p&gt;
{
&amp;gt;    this.type3MessageHandler = type3MessageHandler;
&amp;gt;   }
&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt;   public void setJmsTemplate(JmsTemplate102 jmsTemplate) &lt;/p&gt;
{
&amp;gt;    this.jmsTemplate = jmsTemplate;
&amp;gt;   }
&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt;   public void setPassword(String password) &lt;/p&gt;
{
&amp;gt;    this.password = password;
&amp;gt;   }
&lt;p&gt;&amp;gt;&lt;br/&gt;
&amp;gt;   public void setUsername(String username) &lt;/p&gt;
{
&amp;gt;    this.username = username;
&amp;gt;   }
&lt;p&gt;&amp;gt;   }&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;br/&gt;
&amp;gt;&lt;/p&gt;</description>
            <key id="12923">SPR-1535</key>
            <summary> Spring 1.3 JMS listener </summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="2" iconUrl="https://jira.spring.io/images/icons/priorities/critical.png">Critical</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="llipc">ray</reporter>
                        <labels>
                    </labels>
                <created>Tue, 13 Dec 2005 22:45:18 +0000</created>
                <updated>Tue, 19 Jun 2012 03:54:16 +0000</updated>
                            <resolved>Wed, 21 Dec 2005 09:11:42 +0000</resolved>
                                    <version>2.0 M1</version>
                                    <fixVersion>2.0 M1</fixVersion>
                                    <component>JMS</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="15824" author="juergen.hoeller" created="Wed, 21 Dec 2005 09:11:42 +0000"  >&lt;p&gt;As explained in various places already, Spring 2.0&apos;s message listener container support does address this issue already. The DefaultMessageListenerContainer that we ship there uses plain JMS API as allowed within J2EE, so it should work perfectly well on WebSphere. Effectively, it performs the MessageListener invocation itself, using a synchronous receive loop in the background; hence it avoids to register the MessageListener directly with the JMS provider.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        11 years, 2 weeks, 1 day ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Wed, 21 Dec 2005 09:11:42 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>false</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i04w3b:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>28573</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>