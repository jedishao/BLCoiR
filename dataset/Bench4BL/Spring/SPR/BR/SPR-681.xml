<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 18:31:33 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-681/SPR-681.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-681] LocalSessionFactoryBean violates contract of the FactoryBean interface</title>
                <link>https://jira.spring.io/browse/SPR-681</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;There are actually a number of related issues I&apos;m dealing with, but the biggie that I &lt;b&gt;know&lt;/b&gt; is a bug is that LocalSessionFactoryBean.getObject() returns null if the afterPropertiesSet method is never called.  This is a violation of the FactoryBean interface, which explicitly states that getObject() should never return null.&lt;/p&gt;

&lt;p&gt;Let me go through how I figured this out, because there are actually a couple of issues here.  In my app, I am programmatically registering a singleton Hibernate LocalSessionFactoryBeans in a BeanFactoryPostProcessor using ConfigurableBeanFactory.registerSingleton.  The first problem is, when I do so, the afterPropertiesSet method is not automatically called.  This may be the desired behavior, but if so I feel this should be explicitly documented in the registerSingleton method&apos;s JavaDoc.  The second problem is, I get the stack trace below, which isn&apos;t exactly an intuitive error message.  The third problem is what I already mentioned, that the getObject() method is returning null when in fact it should not be.&lt;/p&gt;

&lt;p&gt;Fixing the third problem should take care of fixing the second problem.  The solution to problem #3 will of course be either to A) have LocalSessionFactoryBean.getObject() throw an exception if afterPropertiesSet is not called or the solution I prefer, B) automatically call afterPropertiesSet if getObject is called and this.sessionFactory == null.&lt;/p&gt;

&lt;p&gt;So, to summarize, I recommend&lt;br/&gt;
1) the documentation of ConfigurableBeanFactory.registerSingleton be updated to explicitly state that beans registered programmatically in this way do not receive bean lifecycle callbacks, and&lt;br/&gt;
2) Change LocalSessionFactoryBean.getObject() to read as follows:&lt;/p&gt;

&lt;p&gt;    public Object getObject() {&lt;br/&gt;
	// if afterPropertiesSet has not been called as expected&lt;br/&gt;
        if (this.sessionFactory == null) {&lt;br/&gt;
	    // call it automatically for the user, rather than throw an&lt;br/&gt;
	    // exception.  if the configuration of the returned sessionFactory&lt;br/&gt;
	    // is deficient for some reason (e.g. the properties haven&apos;t been&lt;br/&gt;
	    // all set yet), the user will certainly get an error when they&lt;br/&gt;
	    // attempt to use the sessionFactory, and it will probably be more&lt;br/&gt;
	    // informative than any error we could throw here anyway&lt;br/&gt;
	    if (logger.isWarnEnabled()) &lt;/p&gt;
{
                logger.warn(&quot;The &quot; + LocalSessionFactoryBean.getClass().getName() +
		    &quot;.afterPropertiesSet method was not manually called to properly &quot; +
		    &quot;initialize this bean.  The method has been called automatically, &quot; +
		    &quot;but the fact that the afterPropertiesSet method was not called &quot; +
		    &quot;may indicate a problem with the way this bean was accessed&quot;);
	    }
&lt;p&gt;	    try &lt;/p&gt;
{
	        afterPropertiesSet();
	    }
&lt;p&gt;	    catch (Exception e) &lt;/p&gt;
{
	        throw new BeanCreationException(&quot;Unable to create Hibernate SessionFactory.  &quot; +
		    &quot;Were all the properties of the &quot; +
		    LocalSessionFactoryBean.getClass().getName() +
		    &quot; set correctly?&quot;;
	    }
&lt;p&gt;	}&lt;br/&gt;
        return this.sessionFactory;&lt;br/&gt;
    }&lt;/p&gt;</description>
            <key id="11094">SPR-681</key>
            <summary>LocalSessionFactoryBean violates contract of the FactoryBean interface</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="sgarlatm">Matthew Sgarlata</reporter>
                        <labels>
                    </labels>
                <created>Thu, 3 Feb 2005 04:46:12 +0000</created>
                <updated>Sun, 27 Feb 2005 22:55:09 +0000</updated>
                            <resolved>Sun, 27 Feb 2005 20:54:45 +0000</resolved>
                                                    <fixVersion>1.1.5</fixVersion>
                                    <component>Core</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="12226" author="sgarlatm" created="Thu, 3 Feb 2005 04:47:48 +0000"  >&lt;p&gt;Oops, let&apos;s try again with indentation:&lt;/p&gt;

&lt;p&gt;    public Object getObject() {&lt;br/&gt;
        // if afterPropertiesSet has not been called as expected&lt;br/&gt;
        if (this.sessionFactory == null) {&lt;br/&gt;
            // call it automatically for the user, rather than throw an&lt;br/&gt;
            // exception.  if the configuration of the returned sessionFactory&lt;br/&gt;
            // is deficient for some reason (e.g. the properties haven&apos;t been&lt;br/&gt;
            // all set yet), the user will certainly get an error when they&lt;br/&gt;
            // attempt to use the sessionFactory, and it will probably be more&lt;br/&gt;
            // informative than any error we could throw here anyway&lt;br/&gt;
            if (logger.isWarnEnabled()) &lt;/p&gt;
{
                    logger.warn(&quot;The &quot; + LocalSessionFactoryBean.getClass().getName() +
                &quot;.afterPropertiesSet method was not manually called to properly &quot; +
                &quot;initialize this bean.  The method has been called automatically, &quot; +
                &quot;but the fact that the afterPropertiesSet method was not called &quot; +
                &quot;may indicate a problem with the way this bean was accessed&quot;);
            }
&lt;p&gt;            try &lt;/p&gt;
{
                afterPropertiesSet();
            }
&lt;p&gt;            catch (Exception e) &lt;/p&gt;
{
                throw new BeanCreationException(&quot;Unable to create Hibernate SessionFactory.  &quot; +
                &quot;Were all the properties of the &quot; +
                LocalSessionFactoryBean.getClass().getName() +
                &quot; set correctly?&quot;;
            }
&lt;p&gt;	}&lt;br/&gt;
        return this.sessionFactory;&lt;br/&gt;
    }&lt;/p&gt;

&lt;p&gt;And here&apos;s the stack trace:&lt;/p&gt;

&lt;p&gt;org.springframework.beans.factory.FactoryBeanCircularReferenceException: Error creating bean with name &apos;devSessionFactory&apos;: FactoryBean returned null object: not fully initialized due to circular bean reference?&lt;br/&gt;
	at org.springframework.beans.factory.support.AbstractBeanFactory.getObjectForSharedInstance(AbstractBeanFactory.java:713)&lt;br/&gt;
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:186)&lt;br/&gt;
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:145)&lt;br/&gt;
	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:504)&lt;br/&gt;
	at com.spider.scoreboard.database.pool.PoolManager.getSessionFactory(PoolManager.java:103)&lt;br/&gt;
	at com.spider.scoreboard.database.pool.PoolManager.getHibernateTemplate(PoolManager.java:107)&lt;br/&gt;
	at com.spider.scoreboard.ScoreboardCommandlineLauncher.main(ScoreboardCommandlineLauncher.java:39)&lt;br/&gt;
	at com.spider.scoreboard.framework.Launcher.launch(Launcher.java:54)&lt;br/&gt;
	at com.spider.scoreboard.ScoreboardCommandlineLauncher.main(ScoreboardCommandlineLauncher.java:45)&lt;/p&gt;</comment>
                            <comment id="12293" author="juergen.hoeller" created="Sun, 13 Feb 2005 07:49:53 +0000"  >&lt;p&gt;Well, calling afterPropertiesSet() is part of LocalSessionFactoryBean&apos;s initialization contract. If you don&apos;t call that method, the FactoryBean instance will de facto be in an incomplete state, just like when you forget to call a setter.&lt;/p&gt;

&lt;p&gt;The contract for FactoryBean&apos;s getObject() method only applies to fully initialized FactoryBean instances. Of course it would be nice to detect incomplete initialization and throw a nice exception in such a case. I&apos;ll rework LocalSessionFactoryBean and other out-of-the-box FactoryBeans in that fashion.&lt;/p&gt;

&lt;p&gt;The problem with lazy initialization when afterPropertiesSet hasn&apos;t been called explicitly is that the getObject() method would have to be synchronized (to avoid concurrent initialization triggered by different callers). While this is not a problem for dependency injection, it is a problem when using the BeanFactory as service locator (with frequent, concurrent getObject() calls.)&lt;/p&gt;

&lt;p&gt;Point taken that ConfigurableBeanFactory&apos;s registerSingleton method should clearly state that it does not call any initialization method. It assumes that the passed-in instance is already fully initialized.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="12294" author="juergen.hoeller" created="Sun, 13 Feb 2005 08:04:01 +0000"  >&lt;p&gt;It&apos;s arguably unnecessary to add such initialization checks to all FactoryBean implementations. The BeanFactory will catch a null value anyway and throw a &quot;FactoryBean returned null object: probably not fully initialized&quot; exception (which I have just slighly reworded to consider causes other than a circular bean reference).&lt;/p&gt;

&lt;p&gt;I tend towards adding a corresponding comment to FactoryBean&apos;s javadoc: It should not return null, but if it does, this is considered as not fully initialized and will lead to a corresponding exception (which is what happens in current BeanFactory implementations; we would simply make this part of the definition).&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="12302" author="sgarlatm" created="Mon, 14 Feb 2005 02:10:49 +0000"  >&lt;p&gt;I agree these two actions should be taken:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Update ConfigurableBeanFactory.registerSingleton JavaDoc to note no initialization is performed (are any lifecycle callbacks performed?  probably should explicitly address all callbacks, such as the destruction callback)&lt;/li&gt;
	&lt;li&gt;Reword FactoryBean.getObject to indicate that if the FactoryBean cannot create an object with the getObject method for some reason, the preferred behavior is to throw a BeanCreationException.  However, returning null will also be treated as an error.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I think it&apos;s fine to reword the BeanFactory exception message, and if that minimizes the number of changes that have to happen to Spring, that&apos;s certainly the solution I would opt for &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  However, can you tell the difference between a circular reference and a FactoryBean returning null because it wasn&apos;t properly initialized?  If so, I agree with you that you shouldn&apos;t have to go back and change all of the existing FactoryBeans.  If not, I think there would be value in distinguishing these two very different errors, and letting the user know what&apos;s going on by throwing a BeanCreationException or something.  Circular bean references and FactoryBeans that fail to initialize are mysterious enough on their own, without the added task of trying to figure out which one of those totally unrelated issues is causing an error &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  &lt;/p&gt;

&lt;p&gt;Matt&lt;/p&gt;</comment>
                            <comment id="12445" author="juergen.hoeller" created="Sun, 27 Feb 2005 20:54:45 +0000"  >&lt;p&gt;I&apos;ve adapted the javadoc accordingly.&lt;/p&gt;

&lt;p&gt;Regarding discrimination between not fully initialized and a circular reference: Those a more similar than they look. A circular reference itself is usually not a problem and can be resolved through a best-effort wiring sequence. Only a FactoryBean that insists on being fully initialized before exposing its object causes a circular reference failure, because its object is &lt;b&gt;not fully initialized&lt;/b&gt; at the time of the reference...&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="12451" author="sgarlatm" created="Sun, 27 Feb 2005 22:55:09 +0000"  >&lt;p&gt;Thanks for clarifying the JavaDoc &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;For circular references vs. not properly initialized factory beans, I see your point about how similar the two bugs are.  However, if it&apos;s at all possible to break out the two into different exceptions, I think that would be much clearer to the end user.  A circular reference tells me as a user that I have a problem with multiple beans that are dependent on each other and I need to figure out some order to initialize them in.  An improperly initialized factory bean tells me something completely different, namely that one particular factory bean isnn&apos;t getting initialized correctly.  If we break out circular references seperately, then a FactoryBeanConfigurationException or whatever tells me that my one bean is missing some dependencies or didn&apos;t get initialized (maybe I forgot to specify an init-method or I didn&apos;t implement the InitializingBean interface).&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        11 years, 44 weeks, 3 days ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 13 Feb 2005 07:49:53 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>true</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i04xhj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>28799</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>