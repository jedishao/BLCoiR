<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 20:28:15 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-5360/SPR-5360.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-5360] Threads bottlenecking in DefaultSingletonBeanRegistry when using Wicket&apos;s @SpringBean annotation for injection</title>
                <link>https://jira.spring.io/browse/SPR-5360</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;I actually wrote to the Wicket mailing list initially about this:&lt;br/&gt;
&lt;a href=&quot;http://www.nabble.com/SpringBeanLocator-and-%40SpringBean-performance-issue-td20964687.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.nabble.com/SpringBeanLocator-and-%40SpringBean-performance-issue-td20964687.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;and they suggest that this is a deeper Spring issue. Basically, I&apos;m using Wicket&apos;s @SpringBean annotation to inject beans throughout our webapp. When we load tested the app, we found threads blocking for extended periods at this particular point:&lt;/p&gt;

&lt;p&gt;Object blocked: 145.133 ms, Object wait: 0 ms, CPU wait: 2.118 ms, I/O wait: 9.017 ms, CPU: 73.847 ms&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton (DefaultSingletonBeanRegistry.java:180, bci=22, server compiler)&lt;br/&gt;
          o blocked on java.util.concurrent.ConcurrentHashMap (0x000000cd67f9d170)&lt;/li&gt;
	&lt;li&gt;org.springframework.beans.factory.support.AbstractBeanFactory.isTypeMatch (AbstractBeanFactory.java:415, bci=41, server compiler)&lt;/li&gt;
	&lt;li&gt;org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType (DefaultListableBeanFactory.java:223, bci=142, server compiler)&lt;/li&gt;
	&lt;li&gt;org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType (DefaultListableBeanFactory.java:202, bci=4, server compiler)&lt;/li&gt;
	&lt;li&gt;org.springframework.context.support.AbstractApplicationContext.getBeanNamesForType (AbstractApplicationContext.java:933, bci=5, server compiler)&lt;/li&gt;
	&lt;li&gt;org.springframework.beans.factory.BeanFactoryUtils.beanNamesForTypeIncludingAncestors (BeanFactoryUtils.java:143, bci=8, server compiler)&lt;/li&gt;
	&lt;li&gt;org.apache.wicket.spring.SpringBeanLocator.getBeanNameOfClass (SpringBeanLocator.java:104, bci=2, server compiler)&lt;/li&gt;
	&lt;li&gt;org.apache.wicket.spring.SpringBeanLocator.getBeanName (SpringBeanLocator.java:192, bci=29, server compiler)&lt;/li&gt;
	&lt;li&gt;org.apache.wicket.spring.SpringBeanLocator.isSingletonBean (SpringBeanLocator.java:133, bci=13, server compiler)&lt;/li&gt;
	&lt;li&gt;org.apache.wicket.spring.injection.annot.AnnotProxyFieldValueFactory.getFieldValue (AnnotProxyFieldValueFactory.java:90, bci=46, server compiler)&lt;/li&gt;
	&lt;li&gt;org.apache.wicket.injection.Injector.inject (Injector.java:108, bci=87, server compiler)&lt;/li&gt;
	&lt;li&gt;org.apache.wicket.injection.ConfigurableInjector.inject (ConfigurableInjector.java:39, bci=6, server compiler)&lt;/li&gt;
	&lt;li&gt;org.apache.wicket.injection.ComponentInjector.onInstantiation (ComponentInjector.java:52, bci=5, server compiler)&lt;/li&gt;
	&lt;li&gt;org.apache.wicket.Application.notifyComponentInstantiationListeners (Application.java:974, bci=20, server compiler)&lt;/li&gt;
	&lt;li&gt;org.apache.wicket.Component.&amp;lt;init&amp;gt; (Component.java:873, bci=35, server compiler)&lt;/li&gt;
	&lt;li&gt;org.apache.wicket.MarkupContainer.&amp;lt;init&amp;gt; (MarkupContainer.java:105, bci=2, server compiler)&lt;/li&gt;
	&lt;li&gt;org.apache.wicket.markup.html.WebMarkupContainer.&amp;lt;init&amp;gt; (WebMarkupContainer.java:39, bci=2, server compiler)&lt;/li&gt;
	&lt;li&gt;org.apache.wicket.markup.html.WebMarkupContainerWithAssociatedMarkup.&amp;lt;init&amp;gt; (WebMarkupContainerWithAssociatedMarkup.java:42, bci=2, server compiler)&lt;/li&gt;
	&lt;li&gt;org.apache.wicket.markup.html.panel.Panel.&amp;lt;init&amp;gt; (Panel.java:76, bci=2, server compiler)&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;...snip...&amp;#93;&lt;/span&gt; &lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;We&apos;re able to hack around it in our code and avoid this bottleneck, which resulted in us getting 50-75% more requests per second. Looking at some of the Spring 3.0 code, it looks like this class has not changed much so we&apos;ll probably run into this problem when we upgrade. Is there a way to make this code path more concurrent? With Spring 3.0 using Java 5, it seems like the use of read/write locks might squeeze more concurrency out of these bean lookups.&lt;/p&gt;
</description>
            <key id="25084">SPR-5360</key>
            <summary>Threads bottlenecking in DefaultSingletonBeanRegistry when using Wicket&apos;s @SpringBean annotation for injection</summary>
                <type id="4" iconUrl="https://jira.spring.io/images/icons/issuetypes/improvement.png">Improvement</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://jira.spring.io/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="3">Duplicate</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="leok">Leo Kim</reporter>
                        <labels>
                    </labels>
                <created>Fri, 12 Dec 2008 03:32:47 +0000</created>
                <updated>Tue, 22 Sep 2015 18:38:40 +0000</updated>
                            <resolved>Tue, 22 Sep 2015 18:38:40 +0000</resolved>
                                    <version>2.5.6</version>
                                                    <component>Core</component>
                        <due></due>
                            <votes>10</votes>
                                    <watches>14</watches>
                                                                <comments>
                            <comment id="49201" author="xaviarias" created="Thu, 10 Dec 2009 23:43:30 +0000"  >&lt;p&gt;Hello, we are facing this problem as well, our environment is JDK 1.5 with Tomcat 6 on Windows servers. Is it possible to know how did you hacked around it to avoid this bottleneck?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Xavier&lt;/p&gt;</comment>
                            <comment id="50004" author="juergen.hoeller" created="Wed, 6 Jan 2010 23:18:11 +0000"  >&lt;p&gt;Actually, looking at that stacktrace, I wonder why Wicket&apos;s SpringBeanLocator recalculates the bean name for every such call? The bottleneck seems to be the introspection of all applicable singleton beans in getBeanNamesForType, which really shouldn&apos;t get invoked for obtaining a simple bean instance...&lt;/p&gt;

&lt;p&gt;Of course we could consider caching getBeanNamesForType results in the first place, for any such caller, in particular for concurrent invocations. If it happens to be unavoidable to reobtain the bean names every time, the factory itself could do some caching. Wicket&apos;s SpringBeanLocator could cache as well though.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="50035" author="leok" created="Fri, 8 Jan 2010 01:05:12 +0000"  >&lt;p&gt;The Wicket folks may have fixed this in 1.4.2 actually:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/WICKET-2344&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/WICKET-2344&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We&apos;re using Wicket 1.3.7 where it&apos;s not yet fixed.&lt;/p&gt;

&lt;p&gt;We hacked around it by relying on a convention that we used for our Spring beans. I&apos;m too embarassed to share it here. &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="50057" author="gredler2" created="Sun, 10 Jan 2010 08:21:30 +0000"  >&lt;p&gt;I&apos;ve also run into trouble with this lock in the DefaultSingletonBeanRegistry#getSingleton(...) methods. Specifically, I was trying to reduce application startup time by parallelizing the initialization of singleton beans in DefaultListableBeanFactory#preInstantiateSingletons() &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure what the best fix is... maybe make the DefaultSingletonBeanRegistry.singletonObjects instance variable volatile and reduce the size of the synchronized block(s)? I see that the synchronized block in getSingleton(String, boolean) is a tad bit more forgiving than the synchronized block in getSingleton(String, ObjectFactory) (the null check is outside of the synchronized block). However, I&apos;m not sure that the smaller synchronized block is safe without making the instance variable volatile and adding a second null check inside the synchronized block (see &quot;Fixing Double-Checked Locking using Volatile&quot; in &lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt;).&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; &lt;a href=&quot;http://github.com/gredler/spriths&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://github.com/gredler/spriths&lt;/a&gt;&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;2&amp;#93;&lt;/span&gt; &lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="50278" author="juergen.hoeller" created="Mon, 18 Jan 2010 05:36:08 +0000"  >&lt;p&gt;Daniel, the singletonObjects variable is final and hence doesn&apos;t need to be marked as volatile since it is properly visible in any case.&lt;/p&gt;

&lt;p&gt;The double-check in the getSingleton(String, boolean) method should be safe as well since it doesn&apos;t create the singleton: The inner block just checks for an &apos;early&apos; singleton reference, after the outer block having checked for a regular singleton reference. The classic double-checked locking case would only apply when lazily creating an instance: you might accidentally create the instance twice then.&lt;/p&gt;

&lt;p&gt;Admittedly, singleton creation in getSingleton(String, ObjectFactory) is not meant to happen in parallel at the moment since none of the out of the box ApplicationContexts operates that way. We&apos;d have to revisit the locking to use a per-bean-name lock instead of a global singletonObjects lock instead.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="50332" author="gredler2" created="Tue, 19 Jan 2010 12:19:50 +0000"  >&lt;p&gt;Good point about singletonObjects already being final, I completely missed that.&lt;/p&gt;

&lt;p&gt;If DefaultSingletonBeanRegistry moves to per-bean-name locks, how would that affect methods like getSingletonNames() and getSingletonCount(), which aren&apos;t bean-scoped?&lt;/p&gt;</comment>
                            <comment id="57891" author="arne" created="Fri, 10 Sep 2010 07:10:14 +0000"  >&lt;p&gt;Hi J&#252;rgen,&lt;/p&gt;

&lt;p&gt;we run into the same issue under load using the javax.inject.Provider-interface with Spring 3.0.2&lt;/p&gt;

&lt;p&gt;We have a workaround for this, using a custom bean-factory. I&apos;ll attach the code later.&lt;/p&gt;

&lt;p&gt;To fix this you probably should make the earlySingletonObjects-Map a ConcurrentHashMap and just move the synchronized-block into the second &quot;if&quot;-block in getSingleton.&lt;/p&gt;</comment>
                            <comment id="57892" author="arne" created="Fri, 10 Sep 2010 07:17:22 +0000"  >&lt;p&gt;As attachment you find an application-context that can be used as a replacement of the XmlWebApplicationContext to work around the synchronized issue.&lt;/p&gt;</comment>
                            <comment id="57893" author="arne" created="Fri, 10 Sep 2010 07:23:10 +0000"  >&lt;p&gt;For the case of using the javax.inject.Provider-interface I wonder if it would be cleverer to resolve the reference to the actual bean at injection time instead of doing this at runtime. In our case we use the provider to look-up beans of a smaller scope from beans of containing scopes, i.e. look-up session-information from within singleton-beans. In this cases (I guess, this is the main usage of the Provider-interface) the referenced bean is known at injection time, but it is not available since the needed scope is just not active.&lt;/p&gt;</comment>
                            <comment id="64560" author="lhotari" created="Mon, 21 Mar 2011 10:10:59 +0000"  >&lt;p&gt;Possible related issues: &lt;a href=&quot;https://jira.spring.io/browse/SPR-6870&quot; title=&quot;Cache by-type lookups in DefaultListableBeanFactory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPR-6870&quot;&gt;&lt;del&gt;SPR-6870&lt;/del&gt;&lt;/a&gt; , &lt;a href=&quot;https://jira.spring.io/browse/SPR-7949&quot; title=&quot;Improve performance of DefaultSingletonBeanRegistry.getSingletonNames(..) for high-concurrent-load applications&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPR-7949&quot;&gt;&lt;del&gt;SPR-7949&lt;/del&gt;&lt;/a&gt; , &lt;a href=&quot;https://jira.spring.io/browse/SPR-7988&quot; title=&quot;Performance improvement in applicationContext.getBean() &amp;amp; AutoWired with complex beans&quot; class=&quot;issue-link&quot; data-issue-key=&quot;SPR-7988&quot;&gt;SPR-7988&lt;/a&gt; .&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10000">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="45521">SPR-9819</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10151">
                    <name>Relate</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="40130">SPR-8767</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="17089" name="NonBlockingWebApplicationContext.java" size="4147" author="arne" created="Fri, 10 Sep 2010 07:17:22 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        5 years, 40 weeks, 3 days ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 10 Dec 2009 23:43:30 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>true</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>juergen.hoeller</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i00h67:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2827</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>