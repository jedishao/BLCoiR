<!-- 
RSS generated by JIRA (6.4.11#64026-sha1:78f6ec473a3f058bd5d6c30e9319c7ab376bdb9c) at Thu Dec 22 21:01:35 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://jira.spring.io/si/jira.issueviews:issue-xml/SPR-2258/SPR-2258.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>Spring JIRA</title>
    <link>https://jira.spring.io</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.4.11</version>
        <build-number>64026</build-number>
        <build-date>25-08-2015</build-date>
    </build-info>

<item>
            <title>[SPR-2258] Use of InheritableThreadLocal creates leak for newly created background threads</title>
                <link>https://jira.spring.io/browse/SPR-2258</link>
                <project id="10000" key="SPR">Spring Framework</project>
                    <description>&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;Quoting part of a reply to a post by Peter Veentjer on the Concurrency-Interest mailing list:&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;There seems to be almost a guarantee for Policy/Strategy support in most of the Spring framework: pure interface, partial base implementations providing useful defaults, and a default instance in the places that need it all this - in contrast with overriding methods. This is good, for many reasons.&lt;/p&gt;

&lt;p&gt;Now, a good idea would be to extend this flexibility to thread context creation in the framework in general: Global/ThreadLocal/InheritableThreadLocal, and the new ActuallyWorksWithGCThreadLocal mentioned by Doug some days ago. This is not because I want the new deterministic threadlocal garbage collection option, but because InheritableThreadLocal is hardcoded in 2 places in Spring: the locale holder, and the new scoping support.&lt;/p&gt;

&lt;p&gt;I find this to cause uncollectable reference leaks, in most applications of fair complexity, on all relevant platforms (ibm, bea, sun).&lt;/p&gt;

&lt;p&gt;The reason (as stated in the thread mentioned above) is simple: there are two groups of components: those that create InheritableThreadLocals, and those that create threads. The mix of these two usually results in references dangling off live threads long after the relevant ClassLoader would have been released. A minimal example would be:&lt;br/&gt;
--------------------------------------&lt;br/&gt;
public class ImageController implements Controller {&lt;/p&gt;

&lt;p&gt;    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &lt;/p&gt;
{

        BufferedImage image = new BufferedImage(20, 20, BufferedImage.TYPE_INT_RGB);
        Graphics2D g = image.createGraphics();
        response.setContentType(&quot;image/png&quot;);
        OutputStream out = response.getOutputStream();
        ImageIO.write(image, &quot;png&quot;, out);
        out.close(); out.flush(); g.dispose();

        return null;
    }
&lt;p&gt;}&lt;br/&gt;
--------------------------------------&lt;br/&gt;
There isn&apos;t much to see in the code, but this controller will activate the Java 2D subsystem, which happens to include starting the sun.java2d.Disposer thread, which will only exit at JVM shutdown (this can be verified with a JVMTI agent). See what I mean by saying that InheritableThreadLocal creators can&apos;t fathom all thread creation sites above their stack? I&apos;ll bet good money I can find 3 other leaks possibilities of this type caused by Spring in the Sun JVM alone (although I also found these two spring ITLs in a different place).&lt;/p&gt;

&lt;p&gt;Now, next for a related story - in the Acegi Security subframework (is there such a thing?):&lt;br/&gt;
&lt;a href=&quot;http://opensource.atlassian.com/projects/spring/browse/SEC-152&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://opensource.atlassian.com/projects/spring/browse/SEC-152&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In the beginning, Acegi used a regular ThreadLocal for auth context. Then developers using JFC or RMI requested transparent propagation to child threads, resulting in a patch to use InheritableThreadLocal. Some IBM 1.3 users reported bugs in their JVM implementation, causing the migration back to a regular ThreadLocal. This could, of course, not please everybody, so a more configurable solution was devised: let the framework user choose an implementation of a Strategy interface for &apos;thread bound context&apos; creation:&lt;br/&gt;
&lt;a href=&quot;http://www.acegisecurity.org/multiproject/acegi-security/apidocs/org/acegisecurity/context/SecurityContextHolderStrategy.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.acegisecurity.org/multiproject/acegi-security/apidocs/org/acegisecurity/context/SecurityContextHolderStrategy.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now this is a good solution, but not perfect: the modus of configuration is not very flexible, and it&apos;s Acegi-specific.&lt;br/&gt;
I propose an extension to spring itself, exposing a strategy/polity extension point for child frameworks like Acegi, infrastructure like the Spring MVC locale support, the new Scoped AOP, and (most important of all) RMI/Swing/etc developers seeking a problem-specific solution.&lt;/p&gt;

&lt;p&gt;I think the place for such support would be somewhere on the ApplicationContext itself, making (for instance) configuration in web.xml possible.&lt;/p&gt;</description>
            <key id="14463">SPR-2258</key>
            <summary>Use of InheritableThreadLocal creates leak for newly created background threads</summary>
                <type id="1" iconUrl="https://jira.spring.io/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://jira.spring.io/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://jira.spring.io/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="juergen.hoeller">Juergen Hoeller</assignee>
                                    <reporter username="plethora">Taras Tielkes</reporter>
                        <labels>
                    </labels>
                <created>Fri, 7 Jul 2006 03:22:21 +0000</created>
                <updated>Tue, 19 Jun 2012 03:52:40 +0000</updated>
                            <resolved>Tue, 24 Oct 2006 07:12:32 +0000</resolved>
                                    <version>1.2.8</version>
                    <version>2.0 RC2</version>
                                    <fixVersion>2.0.1</fixVersion>
                    <fixVersion>1.2.9</fixVersion>
                                    <component>Core</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="20403" author="plethora" created="Mon, 23 Oct 2006 08:14:29 +0000"  >&lt;p&gt;Another scenario is a thread pool invoked from the current deployment context (let&apos;s assume a war) that has a lifetime longer than the deployment unit. If the pool manages expansion by creating additional threads from the calling thread, hooking/leaking the classloader reference happens quite easily.&lt;/p&gt;

&lt;p&gt;I&apos;ve categorized this entry as &apos;Improvement&apos;, but it&apos;s not far from &apos;Bug&apos;.&lt;br/&gt;
To paraphrase a controversial author of Java articles: &quot;InheritableThreadLocals are evil&quot; &lt;img class=&quot;emoticon&quot; src=&quot;https://jira.spring.io/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;There&apos;s just no way to guarantee that some code below the current stack frame won&apos;t create a thread that outlives (and thus leaks/retains) the current context ClassLoader.&lt;/p&gt;</comment>
                            <comment id="20404" author="juergen.hoeller" created="Mon, 23 Oct 2006 09:07:08 +0000"  >&lt;p&gt;I&apos;m actually inclined to simply change both of those Spring-internal ThreadLocals to a normal ThreadLocal instead of an InheritableThreadLocal for Spring 2.0.1. The reason is partly the potential leak that you pointed out, in particular with respect to a thread pool happening to create a new thread during a DispatcherServlet request, but also the request being closed after the main request processing ended. In the latter case, the InheritableThreadLocal both for the RequestAttributes and an HttpServletRequest-based LocaleContext can easily lead to the - then invalid - request being accessed afters the completion of its original processing. As this is all undesirable and there is no propagation of those to remote clients in the first place, I feel it&apos;s better to simply turn them back to normal ThreadLocals, with not even a need for configuration options there.&lt;/p&gt;

&lt;p&gt;As a side note: All of this just affects DispatcherServlet/DispatcherPortlet requests, as well as direct LocaleContext setting in application code (which is rare). There are no other InheritableThreadLocals within Spring, in particular not in the handling of transactional resources.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="20410" author="plethora" created="Mon, 23 Oct 2006 21:50:24 +0000"  >&lt;p&gt;I would certainly welcome the (minimal) switch away from InheritableThreadLocal to regular ThreadLocal. Better a small improvement than none at all.&lt;/p&gt;

&lt;p&gt;Some of my other comments will perhaps come up again in the future, when Java 7 and the &quot;deterministic cleanup&quot; ThreadLocal variant are actually released.&lt;/p&gt;

&lt;p&gt;PS Perhaps you could fix the small typo in the issue title (provice -&amp;gt; provide). It seems regular users can&apos;t edit the title of their own issues?&lt;/p&gt;</comment>
                            <comment id="20411" author="plethora" created="Mon, 23 Oct 2006 22:07:35 +0000"  >&lt;p&gt;Inclusion of the change for &quot;localeContextHolder&quot; in 1.2.9 would be very welcome.&lt;/p&gt;</comment>
                            <comment id="20426" author="juergen.hoeller" created="Tue, 24 Oct 2006 07:05:19 +0000"  >&lt;p&gt;I have turned this issue into a bug, pointing out the potential leak caused by the use of InheritableThreadLocal.&lt;/p&gt;

&lt;p&gt;The solution that I&apos;ve implemented now is explicit support for both kinds of ThreadLocal in LocaleContextHolder and RequestContextHolder, plus a &quot;threadContextInheritable&quot; flag on DispatcherServlet and DispatcherPortlet &amp;#8211; being off by default. This needs to be turned on explicitly to expose the LocaleContext and the RequestAttributes for child threads (that is, to enable the use of an InheritableThreadLocal instead of a standard ThreadLocal for this particular DispatcherServlet/Portlet&apos;s context exposure). I consider inheritance being turned off as the safer default. We generally do not recommend to rely on that state in child threads in the first place.&lt;/p&gt;

&lt;p&gt;The reason why I decided to not go for an extension hook at present is that this is all static infrastructure: static ThreadLocals hidden in static context accessors. An extension point could only be static as well, which does not fit well into Spring&apos;s general approach. Furthermore, switching the ThreadLocal implementation would affect all usages of LocaleContextHolder and RequestContextHolder in the entire ClassLoader, whereas with the present solution as outlined above, this can be chosen on a per-usage basis (e.g. per DispatcherServlet instance).&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="20427" author="juergen.hoeller" created="Tue, 24 Oct 2006 07:12:32 +0000"  >&lt;p&gt;This is in CVS HEAD now; should be available in the next nightly snapshot. It would be great if you could give this a try!&lt;/p&gt;

&lt;p&gt;FYI, 2.0.1 is scheduled for release next week, with 1.2.9 following soon after.&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                            <comment id="20559" author="plethora" created="Mon, 30 Oct 2006 22:29:42 +0000"  >&lt;p&gt;The nightly snapshots (for 2.0.1) no longer show the leak through inherited threadlocals, thumbs up!&lt;/p&gt;

&lt;p&gt;Affected / interested users might also want to take a look at a similar issue I filed for webflow:&lt;br/&gt;
&lt;a href=&quot;http://opensource.atlassian.com/projects/spring/browse/SWF-206&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://opensource.atlassian.com/projects/spring/browse/SWF-206&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="21431" author="juergen.hoeller" created="Fri, 22 Dec 2006 05:50:33 +0000"  >&lt;p&gt;FYI, the Spring 1.2.9 release is - finally - just around the corner, scheduled for December 30th. I&apos;ve made a sort of release candidate available in the form of the 1.2.9-20061222 snapshot, available from:&lt;/p&gt;

&lt;p&gt;  &lt;a href=&quot;http://static.springframework.org/downloads/nightly&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://static.springframework.org/downloads/nightly&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Please give this a try, simply replacing the 1.2.8 jar with the 1.2.9 snapshot jar and testing whether everything still works for you. This will help us to ensure the quality of the actual 1.2.9 release next week!&lt;/p&gt;

&lt;p&gt;Juergen&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_10180" key="com.atlassian.jira.toolkit:dayslastcommented">
                        <customfieldname>Days since last comment</customfieldname>
                        <customfieldvalues>
                                        10 years, 1 week, 6 days ago
    
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10170" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>First Response Date</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 23 Oct 2006 09:07:08 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10181" key="com.atlassian.jira.toolkit:lastusercommented">
                        <customfieldname>Last commented by a User</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>false</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10182" key="com.atlassian.jira.toolkit:lastupdaterorcommenter">
                        <customfieldname>Last updater</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>tmarshall</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_10880" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0107b:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_10380" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5910</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                    <customfield id="customfield_10171" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                </customfields>
    </item>
</channel>
</rss>