<?xml version = "1.0" encoding = "UTF-8" ?>
<bugrepository name="DATACMNS">
	<bug id="19" opendate="2011-02-28 02:07:47" fixdate="2011-03-02 00:11:20" resolution="Fixed">
		<buginformation>
			<summary>Invalid entity metadata when domain class implements persistable</summary>
			<description>Latest snapshot (spring-data-jpa-1.0.0.BUILD-20110227.093237-171.jar) introduced a bug which makes find queries (with Specification API) to fail for domain objects which implement Persistable. I believe issue is either in JpaRepositoryFactory stragery for creating entity information - if domain class implements Persistable, PersistableEntityMetadata fixes domain class to Persistable.class which looses actual domain class. Here is relevant stack trace snippet:






java.lang.IllegalArgumentException: Not an entity: interface org.springframework.data.domain.Persistable




	at org.hibernate.ejb.metamodel.MetamodelImpl.entity(MetamodelImpl.java:160)




	at org.hibernate.ejb.criteria.QueryStructure.from(QueryStructure.java:138)




	at org.hibernate.ejb.criteria.CriteriaQueryImpl.from(CriteriaQueryImpl.java:179)




	at org.springframework.data.jpa.repository.support.SimpleJpaRepository.applySpecificationToCriteria(SimpleJpaRepository.java:450)




	at org.springframework.data.jpa.repository.support.SimpleJpaRepository.getQuery(SimpleJpaRepository.java:385)




	at org.springframework.data.jpa.repository.support.SimpleJpaRepository.findAll(SimpleJpaRepository.java:267)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.springframework.data.repository.support.RepositoryFactorySupport$QueryExecuterMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:268)




	at org.springframework.data.repository.support.RepositoryFactorySupport$QueryExecuterMethodInterceptor.invoke(RepositoryFactorySupport.java:249)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:110)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:155)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:202)




	at $Proxy60.findAll(Unknown Source)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:309)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:183)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150)




	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:110)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:202)




	at $Proxy61.findAll(Unknown Source)





</description>
			<version>1.0 M3</version>
			<fixedVersion>1.0 M4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.PagingAndSortingRepository.java</file>
			<file type="M">org.springframework.data.repository.Repository.java</file>
			<file type="M">org.springframework.data.repository.support.PersistableEntityMetadataUnitTests.java</file>
			<file type="M">org.springframework.data.repository.support.PersistableEntityMetadata.java</file>
			<file type="D">org.springframework.data.repository.support.PersistableEntityInformationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="23" opendate="2011-03-25 03:17:27" fixdate="2011-03-31 23:41:16" resolution="Fixed">
		<buginformation>
			<summary>PageImpl can not be constructed with empty content</summary>
			<description>When passing empty list to PageImpl constructor (e.g. in a test, when mocking repository method which returns Page), PageRequest is instantiated with "content.size()" as page size, but 0 size is not allowed argument value in PageRequest.
BTW, 1.0 M5 DATACMNS is not marked as released in JIRA, but it is, as part of or together with DATAJPA 1.0 M2 release.</description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 M6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.domain.PageImpl.java</file>
			<file type="M">org.springframework.data.domain.PageImplUnitTests.java</file>
			<file type="M">org.springframework.data.domain.Page.java</file>
		</fixedFiles>
	</bug>
	<bug id="38" opendate="2011-05-05 22:05:54" fixdate="2011-05-18 10:15:43" resolution="Fixed">
		<buginformation>
			<summary>StackOverflowError on self-referencing Objects</summary>
			<description>Hi, i get the following error when starting a testcase:






06:55:19,554 ERROR TestContextManager:324 - Caught exception while allowing TestExecutionListener [org.springframework.test.context.support.DependencyInjectionTestExecutionListener@49198ff2] to prepare test instance [null(example.SiteServiceTest)]




java.lang.IllegalStateException: Failed to load ApplicationContext




	at org.springframework.test.context.TestContext.getApplicationContext(TestContext.java:308)




	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.injectDependencies(DependencyInjectionTestExecutionListener.java:109)




	at org.springframework.test.context.support.DependencyInjectionTestExecutionListener.prepareTestInstance(DependencyInjectionTestExecutionListener.java:75)




	at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:321)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:220)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:301)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:303)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:240)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)




	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)




	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:180)




	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:49)




	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)




Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;siteService&amp;amp;apos;: FactoryBean threw exception on object creation; nested exception is java.lang.StackOverflowError




	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:149)




	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.getObjectFromFactoryBean(FactoryBeanRegistrySupport.java:102)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getObjectForBeanInstance(AbstractBeanFactory.java:1429)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:190)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:580)




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:895)




	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:425)




	at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:84)




	at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:1)




	at org.springframework.test.context.TestContext.loadApplicationContext(TestContext.java:280)




	at org.springframework.test.context.TestContext.getApplicationContext(TestContext.java:304)




	... 24 more




Caused by: java.lang.StackOverflowError




	at java.util.HashMap$HashIterator.&amp;lt;init&amp;gt;(HashMap.java:795)




	at java.util.HashMap$EntryIterator.&amp;lt;init&amp;gt;(HashMap.java:849)




	at java.util.HashMap$EntryIterator.&amp;lt;init&amp;gt;(HashMap.java:849)




	at java.util.HashMap.newEntryIterator(HashMap.java:863)




	at java.util.HashMap$EntrySet.iterator(HashMap.java:967)




	at java.util.AbstractMap.hashCode(AbstractMap.java:492)




	at org.springframework.util.ObjectUtils.nullSafeHashCode(ObjectUtils.java:286)




	at org.springframework.data.util.TypeDiscoverer.hashCode(TypeDiscoverer.java:230)




	at org.springframework.data.util.ClassTypeInformation.hashCode(ClassTypeInformation.java:79)




	at org.springframework.util.ObjectUtils.nullSafeHashCode(ObjectUtils.java:286)




	at org.springframework.data.util.TypeDiscoverer.hashCode(TypeDiscoverer.java:231)




	at org.springframework.data.util.ClassTypeInformation.hashCode(ClassTypeInformation.java:79)




	at org.springframework.util.ObjectUtils.nullSafeHashCode(ObjectUtils.java:286)




	at org.springframework.data.util.TypeDiscoverer.hashCode(TypeDiscoverer.java:231)




	at org.springframework.data.util.ClassTypeInformation.hashCode(ClassTypeInformation.java:79)




	at org.springframework.util.ObjectUtils.nullSafeHashCode(ObjectUtils.java:286)




	at org.springframework.data.util.TypeDiscoverer.hashCode(TypeDiscoverer.java:231)




	at org.springframework.data.util.ClassTypeInformation.hashCode(ClassTypeInformation.java:79)




	at org.springframework.util.ObjectUtils.nullSafeHashCode(ObjectUtils.java:286)




	at org.springframework.data.util.TypeDiscoverer.hashCode(TypeDiscoverer.java:231)




	at org.springframework.data.util.ClassTypeInformation.hashCode(ClassTypeInformation.java:79)




	at org.springframework.util.ObjectUtils.nullSafeHashCode(ObjectUtils.java:286)




	at org.springframework.data.util.TypeDiscoverer.hashCode(TypeDiscoverer.java:231)




	at org.springframework.data.util.ClassTypeInformation.hashCode(ClassTypeInformation.java:79)




	at org.springframework.util.ObjectUtils.nullSafeHashCode(ObjectUtils.java:286)




	at org.springframework.data.util.TypeDiscoverer.hashCode(TypeDiscoverer.java:231)




	at org.springframework.data.util.ClassTypeInformation.hashCode(ClassTypeInformation.java:79)




	at org.springframework.util.ObjectUtils.nullSafeHashCode(ObjectUtils.java:286)




	at org.springframework.data.util.TypeDiscoverer.hashCode(TypeDiscoverer.java:231)




	at org.springframework.data.util.ClassTypeInformation.hashCode(ClassTypeInformation.java:79)




	at org.springframework.util.ObjectUtils.nullSafeHashCode(ObjectUtils.java:286)




	at org.springframework.data.util.TypeDiscoverer.hashCode(TypeDiscoverer.java:231)




	at org.springframework.data.util.ClassTypeInformation.hashCode(ClassTypeInformation.java:79)






Here is my applicationContext.xml:






&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;




&amp;lt;beans xmlns="http://www.springframework.org/schema/beans"




    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"




    xmlns:context="http://www.springframework.org/schema/context"




    xmlns:spring-data="http://www.springframework.org/schema/data/mongo"




    xsi:schemaLocation="




        http://www.springframework.org/schema/beans




        http://www.springframework.org/schema/beans/spring-beans.xsd




        http://www.springframework.org/schema/context




        http://www.springframework.org/schema/context/spring-context.xsd




        http://www.springframework.org/schema/data/mongo




        http://www.springframework.org/schema/data/mongo/spring-mongo.xsd"&amp;gt;




    




    &amp;lt;spring-data:mongo id="mongo" host="localhost" port="27017"/&amp;gt;




    




    &amp;lt;bean id="mongoTemplate" class="org.springframework.data.document.mongodb.MongoTemplate"&amp;gt;




        &amp;lt;constructor-arg ref="mongo"/&amp;gt;




        &amp;lt;constructor-arg value="testdb"/&amp;gt;




        &amp;lt;constructor-arg value="testcollection"/&amp;gt;




        &amp;lt;constructor-arg&amp;gt;




            &amp;lt;spring-data:mapping-converter/&amp;gt;




        &amp;lt;/constructor-arg&amp;gt;




    &amp;lt;/bean&amp;gt;




    




    &amp;lt;spring-data:repositories base-package="example.service"&amp;gt;




        &amp;lt;spring-data:repository id="siteService"/&amp;gt;




    &amp;lt;/spring-data:repositories&amp;gt;




    




    &amp;lt;context:annotation-config/&amp;gt;




	




&amp;lt;/beans&amp;gt;






The Testcase:






package example.service;









import java.util.List;









import javax.inject.Inject;









import junit.framework.TestCase;









import org.junit.Assert;




import org.junit.Test;




import org.junit.runner.RunWith;




import org.springframework.test.context.ContextConfiguration;




import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;









import example.Site;




import example.query.SiteQuery;









@RunWith(SpringJUnit4ClassRunner.class)




@ContextConfiguration(locations = "classpath:/applicationContext.xml")




public class SiteServiceTest extends TestCase {




    




    @Inject




    protected SiteService siteService;




    




    public SiteService getSiteService() {




        return siteService;




    }




    




    public void setSiteService(SiteService newSiteService) {




        siteService = newSiteService;




    }




    




    @Test




    public void test() {




        List&amp;lt;Site&amp;gt; sites = null;




        




        sites = siteService.findAll(SiteQuery.getForAlias("/"));




        Assert.assertNull(sites);




    }




}






The classes:






package example.site;









import java.util.*;









import org.springframework.data.document.mongodb.mapping.DBRef;




import org.springframework.data.document.mongodb.mapping.Document;









import com.google.code.morphia.annotations.Entity;









@Document




@Entity




public class Site {




    




    private static final long serialVersionUID = -6751151047717976403L;




    




    @Id




    protected String id;




    protected List&amp;lt;String&amp;gt; aliases = new ArrayList&amp;lt;String&amp;gt;();




    protected Boolean eligibleForSitemap = Boolean.TRUE;




    @DBRef




    protected Site parent;




    




    public List&amp;lt;String&amp;gt; getAliases() {




        return aliases;




    }




    




    public void setAliases(List&amp;lt;String&amp;gt; newAliases) {




        aliases = newAliases;




    }




    




    public Boolean getEligibleForSitemap() {




        return eligibleForSitemap;




    }




    




    public void setEligibleForSitemap(Boolean newEligibleForSitemap) {




        eligibleForSitemap = newEligibleForSitemap;




    }




    




    public Site getParent() {




        return parent;




    }




    




    public void setParent(Site newParent) {




        parent = newParent;




    }




}












package example.query;









import com.mysema.query.types.Predicate;









import example.QSite;









public class SiteQuery {




    




    public static Predicate getForAlias(String alias) {




        return QSite.site.aliases.contains(alias);




    }




}






my Dependencies:






&amp;lt;dependency&amp;gt;




	&amp;lt;groupId&amp;gt;org.springframework.data&amp;lt;/groupId&amp;gt;




	&amp;lt;artifactId&amp;gt;spring-data-mongodb&amp;lt;/artifactId&amp;gt;




	&amp;lt;version&amp;gt;1.0.0.M2&amp;lt;/version&amp;gt;




&amp;lt;/dependency&amp;gt;




&amp;lt;dependency&amp;gt;




	&amp;lt;groupId&amp;gt;cglib&amp;lt;/groupId&amp;gt;




	&amp;lt;artifactId&amp;gt;cglib&amp;lt;/artifactId&amp;gt;




	&amp;lt;version&amp;gt;2.2&amp;lt;/version&amp;gt;




&amp;lt;/dependency&amp;gt;




&amp;lt;dependency&amp;gt;  




	&amp;lt;groupId&amp;gt;com.mysema.querydsl&amp;lt;/groupId&amp;gt;  




	&amp;lt;artifactId&amp;gt;querydsl-mongodb&amp;lt;/artifactId&amp;gt;  




	&amp;lt;version&amp;gt;2.1.2&amp;lt;/version&amp;gt;  




&amp;lt;/dependency&amp;gt;






I&amp;amp;apos;ve found out, that if I comment the parent out, everything is fine ... so I guess the introspection-process of the spring-data library got a bug.</description>
			<version>1.0 Final</version>
			<fixedVersion>1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.AbstractMappingContext.java</file>
			<file type="D">org.springframework.data.util.ArrayTypeDiscoverer.java</file>
			<file type="M">org.springframework.data.util.TypeVariableTypeInformation.java</file>
			<file type="M">org.springframework.data.util.TypeDiscoverer.java</file>
			<file type="M">org.springframework.data.util.ClassTypeInformation.java</file>
			<file type="M">org.springframework.data.util.TypeDiscovererUnitTests.java</file>
			<file type="M">org.springframework.data.repository.RepositoryProxy.java</file>
			<file type="M">org.springframework.data.repository.support.AnnotationRepositoryMetadata.java</file>
			<file type="M">org.springframework.data.util.ClassTypeInformationUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="40" opendate="2011-05-23 02:44:13" fixdate="2011-05-24 08:34:56" resolution="Fixed">
		<buginformation>
			<summary>Rename @RepositoryProxy to @RepositoryDefinition</summary>
			<description></description>
			<version>1.0 Final</version>
			<fixedVersion>1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.support.AnnotationRepositoryMetadataUnitTests.java</file>
			<file type="M">org.springframework.data.repository.sample.SampleAnnotatedRepository.java</file>
			<file type="M">org.springframework.data.repository.config.AbstractRepositoryConfigDefinitionParser.java</file>
			<file type="D">org.springframework.data.repository.RepositoryProxy.java</file>
			<file type="M">org.springframework.data.repository.support.DefaultRepositoryMetadataUnitTests.java</file>
			<file type="M">org.springframework.data.repository.support.AnnotationRepositoryMetadata.java</file>
		</fixedFiles>
	</bug>
	<bug id="42" opendate="2011-06-03 20:44:13" fixdate="2011-06-06 15:52:18" resolution="Complete">
		<buginformation>
			<summary>MappingContext does not map BigDecimal correctly</summary>
			<description></description>
			<version>1.1 M1</version>
			<fixedVersion>1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.BeanWrapper.java</file>
			<file type="M">org.springframework.data.mapping.MappingBeanHelper.java</file>
			<file type="M">org.springframework.data.mapping.AbstractMappingContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="44" opendate="2011-06-05 11:19:52" fixdate="2011-06-07 12:44:49" resolution="Fixed">
		<buginformation>
			<summary>ParametersParameterAccessor iterator will never iterate...</summary>
			<description>In the ParametersParameterAccessor class, the BindableParameterIterator is invalid : 
The hasNext() method test "values.length &amp;lt;= currentIndex;" instead of "values.length &amp;gt;= currentIndex;" ...</description>
			<version>1.1 M1</version>
			<fixedVersion>1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.query.ParametersParameterAccessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="45" opendate="2011-06-07 09:26:52" fixdate="2011-06-08 14:46:07" resolution="Fixed">
		<buginformation>
			<summary>Property check for repository methods fails for properties starting with _</summary>
			<description>If you have a class






class Person {




  private int _age;




  




  public int getAge() {




    return _age;




  }




}






and a repository interface






interface PersonRepository extends Repository&amp;lt;Person, Long&amp;gt; {




  Person findByAge(int age);




}






creating a proxy instance for the interface will fail with an exception claiming that no property age is found. This is due to the fact that TypeDiscoverer is currently only considering fields right now and we should think about if it makes sense to make it really property aware.
A workaround to simply use findBy_Age fails as well as {} is used as custom delimiter to manually define property paths. So we should at least guard the code to correctly resolve _age in case there&amp;amp;apos;s no content in front of the {}.</description>
			<version>1.1 M1</version>
			<fixedVersion>1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.query.parser.Property.java</file>
			<file type="M">org.springframework.data.repository.query.parser.PropertyUnitTests.java</file>
			<file type="M">org.springframework.data.util.TypeDiscoverer.java</file>
			<file type="M">org.springframework.data.util.ClassTypeInformationUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="52" opendate="2011-06-06 06:49:07" fixdate="2011-07-13 11:40:52" resolution="Fixed">
		<buginformation>
			<summary>Declaring an intermediate base repository does not work correctly</summary>
			<description>I have cases where I want to group together several query methods, but they don&amp;amp;apos;t seem to fit on any entity-typed repository. I realize I could just use an arbitrary entity for the repository type, but it seems architecturally wrong, and I don&amp;amp;apos;t want to leave an option for client code to call methods inherited from GenericDao.
Therefore I suggest adding an option to create a repository that has no type and does not inherit any methods. I think the best way to configure such a repository interface is with annotations/XML, and not require inheriting from a marker interface. Such repository mechanism would not require the ability to add custom implementation, since it just groups together JPQL queries instead of placing them at the entity sources, and any "custom implementation" should be placed in other beans.</description>
			<version>1.1 M2</version>
			<fixedVersion>1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformationUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.SimpleEntityPathResolverUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.RepositoryFactorySupportUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformation.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">76</link>
		</links>
	</bug>
	<bug id="55" opendate="2011-07-18 03:13:42" fixdate="2011-07-28 08:31:29" resolution="Fixed">
		<buginformation>
			<summary>java.util.Properties cannot be stored to mongodb</summary>
			<description>When a field is of type java.util.Properties, the MongoMappingContext reports a ClassCastException.






Caused by: java.lang.ClassCastException: java.lang.Class cannot be cast to java.lang.reflect.ParameterizedType




	at org.springframework.data.util.TypeDiscoverer.getMapValueType(TypeDiscoverer.java:201)




	at org.springframework.data.util.ClassTypeInformation.getMapValueType(ClassTypeInformation.java:29)




	at org.springframework.data.mapping.AbstractMappingContext.getNestedTypeToAdd(AbstractMappingContext.java:253)




	...





</description>
			<version>1.1 Final</version>
			<fixedVersion>1.2 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.util.TypeDiscoverer.java</file>
			<file type="M">org.springframework.data.util.TypeDiscovererUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="57" opendate="2011-07-26 08:39:54" fixdate="2011-07-28 08:48:21" resolution="Fixed">
		<buginformation>
			<summary>Use of parameterized type in constructor arguments is not supported</summary>
			<description>When an object contains a List of another object (no simple types), the MongoMappingConverter finds correct generic type for the field, but when this field is used in the PersistenceConstructor, the type is considered to be the raw type and then no information is available to convert batck the DBObject instances for this list.
In the TypeDiscover class, the method getParameterTypes(Constructor&amp;lt;?&amp;gt;) use the reflection method Class&amp;lt;?&amp;gt;[] Constructor.getParameterTypes() that give no hint on the generic parameter types. I replaced this call with Type[] Constructor::getGenericParameterTypes(), that has solved my problem.</description>
			<version>1.1 Final</version>
			<fixedVersion>1.2 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.util.TypeDiscoverer.java</file>
			<file type="M">org.springframework.data.util.TypeDiscovererUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="65" opendate="2011-08-23 00:48:49" fixdate="2011-08-23 11:19:12" resolution="Fixed">
		<buginformation>
			<summary>BasicPersistentEntity potentially suffers from ConcurrentModificationException</summary>
			<description>BasicPersistentEntity exposes an addPersistentEntity(...) method to allow adding properties and essentially makes it mutable. This potentially opens it up to a concurrency problem given the following scenario:
1. We concurrently use MongoTemplate for inserting objects of a type not already known to the MappingContext.
2. Thread A enters getPersistentEntity(...) which discovers the entity not mapped already and thus calls addPersistentEntity(...). The algorithm in there eagerly adds the PersistentEntity object to the map of PersistentEntities to allow type self-references be detected. No or some properties might have been discovered already.
3. Thread B enters getPersistentEntity(...) which now discovers the semi-parsed PersistentEntity and thus returns it. This thread continues and at some point doWithProperties(...) gets invoked, iterating over the PersistentProperties already registered.
4. Meanwhile Thread A wants to add additional PersistentProperties and thus causes a ConcurrentModificationException in thread B.</description>
			<version>1.1 Final</version>
			<fixedVersion>1.2 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="68" opendate="2011-08-26 08:05:09" fixdate="2011-08-31 12:08:41" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException in AbstractPersistentProperty::getComponentType()</summary>
			<description>





class TestClassSet extends TreeSet&amp;lt;Object&amp;gt; { }









class TestClassComplex {




    private String id;




    private TestClassSet testClassSet;









    public String getId() {




        return id;




    }









    public TestClassSet getTestClassSet() {




        return testClassSet;




    }









    public void setTestClassSet(TestClassSet testClassSet) {




        this.testClassSet = testClassSet;




    }




}






The following code appears to work fine:






List&amp;lt;TestClassSet&amp;gt; o = mongoTemplate.findAll(TestClassSet.class);






But this fails with the NPE below:






List&amp;lt;TestClassComplex&amp;gt; o = mongoTemplate.findAll(TestClassComplex.class);












java.lang.NullPointerException: null




        at org.springframework.data.mapping.model.AbstractPersistentProperty.getComponentType(AbstractPersistentProperty.java:147) ~[spring-data-commons-core-1.2.0.BUILD-20110826.083456-44.jar:na]




        at org.springframework.data.mapping.model.AbstractPersistentProperty.isComplexType(AbstractPersistentProperty.java:136) ~[spring-data-commons-core-1.2.0.BUILD-20110826.083456-44.jar:na]




        at org.springframework.data.mapping.model.AbstractPersistentProperty.isEntity(AbstractPersistentProperty.java:143) ~[spring-data-commons-core-1.2.0.BUILD-20110826.083456-44.jar:na]




        at org.springframework.data.mapping.context.AbstractMappingContext.getNestedTypeToAdd(AbstractMappingContext.java:316) ~[spring-data-commons-core-1.2.0.BUILD-20110826.083456-44.jar:na]




        at org.springframework.data.mapping.context.AbstractMappingContext.access$100(AbstractMappingContext.java:65) ~[spring-data-commons-core-1.2.0.BUILD-20110826.083456-44.jar:na]




        at org.springframework.data.mapping.context.AbstractMappingContext$1.doWith(AbstractMappingContext.java:267) ~[spring-data-commons-core-1.2.0.BUILD-20110826.083456-44.jar:na]




        at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:513) ~[spring-core-3.0.5.RELEASE.jar:3.0.5.RELEASE]




        at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:244) ~[spring-data-commons-core-1.2.0.BUILD-20110826.083456-44.jar:na]




        at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:165) ~[spring-data-commons-core-1.2.0.BUILD-20110826.083456-44.jar:na]




        at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:140) ~[spring-data-commons-core-1.2.0.BUILD-20110826.083456-44.jar:na]




        at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:65) ~[spring-data-commons-core-1.2.0.BUILD-20110826.083456-44.jar:na]




        at org.springframework.data.mongodb.core.MongoTemplate.determineCollectionName(MongoTemplate.java:1105) ~[spring-data-mongodb-1.0.0.BUILD-20110826.114729-388.jar:na]




        at org.springframework.data.mongodb.core.MongoTemplate.findAll(MongoTemplate.java:786) ~[spring-data-mongodb-1.0.0.BUILD-20110826.114729-388.jar:na]




        ...





</description>
			<version>1.1 Final</version>
			<fixedVersion>1.2 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.util.ClassTypeInformation.java</file>
			<file type="M">org.springframework.data.mapping.model.AbstractPersistentProperty.java</file>
		</fixedFiles>
	</bug>
	<bug id="69" opendate="2011-08-30 02:50:32" fixdate="2011-08-31 12:33:08" resolution="Fixed">
		<buginformation>
			<summary>Performance issues with RepositoryInterfaceAwareBeanPostProcessor when using @Transactional</summary>
			<description>There is a major performance issue with RepositoryInterfaceAwareBeanPostProcessor when using @Transactional support in application&amp;amp;apos;s service classes. The problem is that the method RepositoryInterfaceAwareBeanPostProcessor.predictBeanType(Class&amp;lt;?&amp;gt; beanClass, String beanName) is relatively slow due to a usage of ClassUtils.resolveClassName(...). The actual problem is that the method in question is called whenever someone calls BeanFactoryUtils.beansOfTypeIncludingAncestors(...) and that someone happens to be TransactionAspectUtils.getTransactionManager(...) method, which is called before a call of any method annotated with @Transactional annotation. These calls happens because RepositoryInterfaceAwareBeanPostProcessor implements SmartInstantiationAwareBeanPostProcessor.
Can RepositoryInterfaceAwareBeanPostProcessor.predictBeanType(Class&amp;lt;?&amp;gt; beanClass, String beanName) method be optimized?</description>
			<version>1.1 Final</version>
			<fixedVersion>1.2 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.RepositoryInterfaceAwareBeanPostProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">70</link>
		</links>
	</bug>
	<bug id="70" opendate="2011-09-01 22:40:13" fixdate="2011-09-07 03:13:57" resolution="Duplicate">
		<buginformation>
			<summary>RepositoryInterfaceAwareBeanPostProcessor predicting a wrong bean type</summary>
			<description>I have two repositories











public interface UserRepository extends MongoRepository&amp;lt;User, ObjectId&amp;gt; {




    public User findByUsername(String username);




}














public interface FeedbackRepository extends MongoRepository&amp;lt;Feedback, ObjectId&amp;gt; {




    public Feedback findById(ObjectId id);




}











which I inject into a service class






@Service("myService")




public class MyService  {









    @Inject




    private FeedbackRepository feedbackRepository;









    @Inject




    private UserRepository userRepository;




    ...




}






My application fails to start throwing 
"Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No matching bean of type [com.space.repository.mongo.FeedbackRepository]"
When I debugged further I noticed RepositoryInterfaceAwareBeanPostProcessor.predictBeanType() returning a cached bean type of UserRepository for FeedbackRepository






RepositoryInterfaceAwareBeanPostProcessor.java






public Class&amp;lt;?&amp;gt; predictBeanType(Class&amp;lt;?&amp;gt; beanClass, String beanName) {









		if (null == context || !REPOSITORY_TYPE.isAssignableFrom(beanClass)) {




			return null;




		}









		BeanDefinition definition = context.getBeanDefinition(beanName);




		PropertyValue value =




				definition.getPropertyValues().getPropertyValue(




						"repositoryInterface");




		




		if (cache.containsKey(beanClass)) {




			return cache.get(beanClass);




		}




		




		Class&amp;lt;?&amp;gt; resolvedBeanClass = getClassForPropertyValue(value);




		cache.put(beanClass, resolvedBeanClass);









		return resolvedBeanClass;




	}






In the above code predicting the bean type a cache is being maintained with beanClass as the key.
For all repository instances  "MongoRepositoryFactoryBean" is the bean class and hence for feedbackRepository bean predictBeanType is picking up a cached userRepository as the type.</description>
			<version>1.1 Final</version>
			<fixedVersion>1.2 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.RepositoryInterfaceAwareBeanPostProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">69</link>
		</links>
	</bug>
	<bug id="81" opendate="2011-09-29 08:01:56" fixdate="2011-09-29 09:53:07" resolution="Fixed">
		<buginformation>
			<summary>RepositoryInterfaceAwareBeanPostProcessor potentially suffers from NullPointerException</summary>
			<description>RepositoryInterfaceAwareBeanPostProcessor.getClassForPropertyValue(...) returns null if a repository interface can not be loaded. The caching ConcurrentHashMap does not allow null as values.</description>
			<version>1.2 M1</version>
			<fixedVersion>1.2 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.RepositoryInterfaceAwareBeanPostProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="98" opendate="2011-11-15 08:25:01" fixdate="2011-11-23 00:10:08" resolution="Fixed">
		<buginformation>
			<summary>ClassCastException on getReturnedDomainClass for variable types</summary>
			<description>ClassCastException on getReturnedDomainClass for variable types.
The base interface:






@NoRepositoryBean




public interface BaseRepository&amp;lt;T extends BaseEntity&amp;gt; extends JpaRepository&amp;lt;T, Long&amp;gt; {









    List&amp;lt;T&amp;gt; findByExternalIdIn(List&amp;lt;String&amp;gt; externalIds);









}






The repository interface:






public interface FooRepository extends BaseRepository&amp;lt;Foo&amp;gt; {









}






The class where the exception is thrown:






org.springframework.data.repository.util.ClassUtils






The line where the exception is thrown:






return componentType instanceof ParameterizedType ? (Class&amp;lt;?&amp;gt;) ((ParameterizedType) componentType).getRawType()




					: (Class&amp;lt;?&amp;gt;) componentType;






The exception:






Caused by: java.lang.ClassCastException: sun.reflect.generics.reflectiveObjects.TypeVariableImpl cannot be cast to java.lang.Class




	at org.springframework.data.repository.util.ClassUtils.getReturnedDomainClass(ClassUtils.java:64) ~[spring-data-commons-core-1.1.0.RELEASE.jar:na]




	at org.springframework.data.repository.query.QueryMethod.getDomainClass(QueryMethod.java:124) ~[spring-data-commons-core-1.1.0.RELEASE.jar:na]




	at org.springframework.data.repository.query.QueryMethod.getNamedQueryName(QueryMethod.java:115) ~[spring-data-commons-core-1.1.0.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$DeclaredQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:118) ~[spring-data-jpa-1.0.1.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateIfNotFoundQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:157) ~[spring-data-jpa-1.0.1.RELEASE.jar:na]




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$AbstractQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:71) ~[spring-data-jpa-1.0.1.RELEASE.jar:na]




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.&amp;lt;init&amp;gt;(RepositoryFactorySupport.java:303) ~[spring-data-commons-core-1.1.0.RELEASE.jar:na]




	at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:157) ~[spring-data-commons-core-1.1.0.RELEASE.jar:na]




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:120) ~[spring-data-commons-core-1.1.0.RELEASE.jar:na]




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:39) ~[spring-data-commons-core-1.1.0.RELEASE.jar:na]




	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:142) ~[spring-beans-3.0.6.RELEASE.jar:3.0.6.RELEASE]




	... 35 common frames omitted





 </description>
			<version>1.1 Final</version>
			<fixedVersion>1.2 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.RepositoryMetadata.java</file>
			<file type="M">org.springframework.data.repository.util.ClassUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.AnnotationRepositoryMetadata.java</file>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryMetadata.java</file>
			<file type="M">org.springframework.data.repository.util.ClassUtils.java</file>
			<file type="M">org.springframework.data.util.TypeDiscoverer.java</file>
			<file type="M">org.springframework.data.util.TypeInformation.java</file>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryMetadataUnitTests.java</file>
			<file type="M">org.springframework.data.repository.query.QueryMethod.java</file>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformation.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">128</link>
		</links>
	</bug>
	<bug id="99" opendate="2011-11-23 02:49:05" fixdate="2011-11-23 03:10:50" resolution="Fixed">
		<buginformation>
			<summary>SimpleTypeHolder does not consider complex enum values as simple</summary>
			<description>If an enum implements abstract methods of some kind the Class object returned by {{$
{ENUM}
.getClass()}} does not return true for an isEnum() call anymore. This is why the call to SimpleTypeHolder.isSimpleType(Class&amp;lt;?&amp;gt; type) will return false in such cases. We should rather enlist Enum into the set of default simple types so that the ....isAssignableFrom(...) check discovers enums already.</description>
			<version>1.0 Final</version>
			<fixedVersion>1.2 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.model.SimpleTypeHolder.java</file>
			<file type="M">org.springframework.data.mapping.SimpleTypeHolderUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="92" opendate="2011-10-23 09:08:05" fixdate="2011-12-02 04:04:56" resolution="Fixed">
		<buginformation>
			<summary>Invalid Entities are placed in the MappingContext - Cache</summary>
			<description>If a call to verify() of an persistent entity fails, it is still in the cache and will be returned on the next call of getPersistentEntity(), so you get the exception thrown by verify() on the first call and get just the entity back on the second call. So we need to remove the entity from the cache after a failed verify(), or put a Null/Dummy object in there that throws the same mapping exeption on getPersistentEntity().</description>
			<version>1.2 M1</version>
			<fixedVersion>1.2 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.data.mapping.context.AbstractMappingContextIntegrationTest.java</file>
			<file type="D">org.springframework.data.repository.core.support.AbstractRepositoryMetadataUnitTest.java</file>
			<file type="D">org.springframework.data.mapping.context.AbstractMappingContextUnitTest.java</file>
			<file type="M">org.springframework.data.mapping.model.MutablePersistentEntity.java</file>
			<file type="D">org.springframework.data.mapping.context.DefaultPersistenPropertyPathUnitTest.java</file>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="108" opendate="2011-12-05 09:57:35" fixdate="2011-12-06 04:45:09" resolution="Fixed">
		<buginformation>
			<summary>RepositoryFactorySupport throws ClassCastException for annotation based repositories</summary>
			<description>Repository interfaces using the annotation based declaration model cannot be created through RepositoryFactorySupport as it&amp;amp;apos;s generics are typed to T extends Repository. As the proxy generated might not implement this interface itself we should add it to the interfaces the proxy exposes.</description>
			<version>1.2 M2</version>
			<fixedVersion>1.2 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.RepositoryFactorySupportUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.RepositoryFactorySupport.java</file>
			<file type="M">org.springframework.data.mapping.model.BeanWrapper.java</file>
		</fixedFiles>
	</bug>
	<bug id="109" opendate="2011-12-07 10:20:32" fixdate="2011-12-19 09:13:36" resolution="Fixed">
		<buginformation>
			<summary>Upgrade to latest Querydsl</summary>
			<description>Hello,
Unit tests against spring-data-commons-core don&amp;amp;apos;t run on JDK 1.7. 
It happens because spring-data-commons-core depends on querydsl 2.2.0 version which has a known bug. Please see https://bugs.launchpad.net/querydsl/+bug/819861
This issue was fixed in 2.2.1, so after I updated dependency everything works fine.
Regards,
Alexey.</description>
			<version>1.2 M2</version>
			<fixedVersion>1.2 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.util.TypeVariableTypeInformation.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">112</link>
		</links>
	</bug>
	<bug id="114" opendate="2011-12-19 03:21:41" fixdate="2011-12-20 03:35:19" resolution="Fixed">
		<buginformation>
			<summary>Wrong custom implementation automatically detected</summary>
			<description>We have two repositories with a similar name suffix. Both repositories have a custom interface and implementation, also ending with a similar name suffix. When automatically scanning the repositories, and their custom implementation, the wrong custom implementation is wired to our repository bean. Resulting in the following exception:






Caused by: java.lang.IllegalArgumentException: No property find found for type class com.myproject.Contract




	at org.springframework.data.repository.query.parser.Property.&amp;lt;init&amp;gt;(Property.java:76)




	at org.springframework.data.repository.query.parser.Property.&amp;lt;init&amp;gt;(Property.java:97)




	at org.springframework.data.repository.query.parser.Property.create(Property.java:312)




	at org.springframework.data.repository.query.parser.Property.create(Property.java:326)




	at org.springframework.data.repository.query.parser.Property.create(Property.java:326)




	at org.springframework.data.repository.query.parser.Property.create(Property.java:326)




	at org.springframework.data.repository.query.parser.Property.create(Property.java:292)




	at org.springframework.data.repository.query.parser.Property.from(Property.java:251)




	at org.springframework.data.repository.query.parser.Property.from(Property.java:232)




	at org.springframework.data.repository.query.parser.Part.&amp;lt;init&amp;gt;(Part.java:48)




	at org.springframework.data.repository.query.parser.PartTree$OrPart.&amp;lt;init&amp;gt;(PartTree.java:242)




	at org.springframework.data.repository.query.parser.PartTree.buildTree(PartTree.java:101)




	at org.springframework.data.repository.query.parser.PartTree.&amp;lt;init&amp;gt;(PartTree.java:77)




	at org.springframework.data.jpa.repository.query.PartTreeJpaQuery.&amp;lt;init&amp;gt;(PartTreeJpaQuery.java:56)




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:92)




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateIfNotFoundQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:159)




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$AbstractQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:71)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.&amp;lt;init&amp;gt;(RepositoryFactorySupport.java:303)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:157)




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:120)




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:39)




	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:142)




	... 67 more






For example:
We have a repository named ContractRepository with a custom interface ContractRepositoryCustom and an implementation ContractRepositoryImpl, all defined inside the same package. In another package we have a repository, for another entity type, named AnotherContractRepository with a custom interface AnotherContractRepositoryCustom and an implementation AnotherContractRepositoryImpl. When starting the application context, the contractRepository bean is linked to our anotherContractRepositoryImpl rather than the contractRepositoryImpl.
This behavior seems to be operating system dependent, as it only occurs on our Linux CI server.
The cause of our problem can be found at AbstractRepositoryConfigDefinitionParser.detectCustomImplementation(...). It might be desirable to scan on getImplementationClassName() before applying the wildcard prefix.</description>
			<version>1.2 RC1</version>
			<fixedVersion>1.2 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.config.AbstractRepositoryConfigDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="125" opendate="2012-01-24 01:19:36" fixdate="2012-02-02 09:28:19" resolution="Fixed">
		<buginformation>
			<summary>QueryExecutorMethodInterceptor does not reject interfaces with query methods if no QueryLookupStrategy defined</summary>
			<description>The constructor of QueryExecutorMethodInterceptor tries to reject interfaces containing query methods if no QueryLookupStrategy is defined. Unfortunately it doesn&amp;amp;apos;t as it checks for custom methods instead of query methods.</description>
			<version>1.2 Final</version>
			<fixedVersion>1.2.1, 1.3 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.QueryExecutorMethodInterceptorUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.RepositoryFactorySupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="120" opendate="2012-01-16 10:17:49" fixdate="2012-04-11 09:25:50" resolution="Fixed">
		<buginformation>
			<summary>PreferredConstructor.Parameter does not have equals(...) and hashCode() methods</summary>
			<description>If this is fixed MappedConstructor.getFor(...) in Spring Data Mongo could rather hold a Map of Parameter to MappedParameter to avoid iterating over all MappedParameter instances on each call.</description>
			<version>1.2 Final</version>
			<fixedVersion>1.3 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.PreferredConstructor.java</file>
		</fixedFiles>
	</bug>
	<bug id="132" opendate="2012-02-17 19:02:20" fixdate="2012-04-11 09:32:48" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException AbstractPersistentProperty inside isEntity</summary>
			<description>isEntity() throws a NPE when evaluating a HashMap. See the forum reference (from entry #4 and forth) for more details.</description>
			<version>1.3 M1</version>
			<fixedVersion>1.3 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.model.AbstractPersistentPropertyUnitTests.java</file>
			<file type="M">org.springframework.data.mapping.model.AbstractPersistentProperty.java</file>
		</fixedFiles>
	</bug>
	<bug id="139" opendate="2012-03-26 14:28:55" fixdate="2012-04-11 09:35:14" resolution="Fixed">
		<buginformation>
			<summary>StackOverflowError from infinite recursion in PropertyPath.create:326</summary>
			<description>Using the mapper from Spring Data MongoDB, I get a stack overflow exception when I make a call to findOne using a simple .is() criteria. I tested with spring-data-commons-core 1.2.1.RELEASE and 1.2.2.BUILD-SNAPSHOT.
I was able to reproduce the error using data common&amp;amp;apos;s PropertyPath stand-alone; putting following line in a test causes the same exception:






PropertyPath pp = PropertyPath.from("_id", CardInteraction.class);






where CardInteraction is defined with the @Id annotation:






@Document




public class CardInteraction {




@Id private String interactionId;




...




}






The infinite recursion converges with the arguments PropertyPath.create:326(source="_", type=..., addTail="id")</description>
			<version>1.2.1</version>
			<fixedVersion>1.3 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.PropertyPath.java</file>
			<file type="M">org.springframework.data.mapping.PropertyUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">158</link>
			<link type="Relate" description="relates to">179</link>
		</links>
	</bug>
	<bug id="154" opendate="2012-04-17 06:02:43" fixdate="2012-04-19 03:52:20" resolution="Fixed">
		<buginformation>
			<summary>Overwriting of delete(T entity) saveAndFlush(T entity); does not work anymore</summary>
			<description>During initialization of the following repository an exception occurs for these two methods.






public interface UserRepository extends JpaRepository&amp;lt;User, Long&amp;gt;,




		PagingAndSortingRepository&amp;lt;User, Long&amp;gt; {









	public User saveAndFlush(User entity);









	public void delete(User entity);




}












Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;userRepository&amp;amp;apos;: FactoryBean threw exception on object creation; nested exception is java.lang.IllegalArgumentException: Could not create query metamodel for method public abstract entities.User repositories.UserRepository.saveAndFlush(entities.User)!




        at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:149)




        at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.getObjectFromFactoryBean(FactoryBeanRegistrySupport.java:102)




        at org.springframework.beans.factory.support.AbstractBeanFactory.getObjectForBeanInstance(AbstractBeanFactory.java:1442)




        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:248)




        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193)




        at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:848)




        at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:790)




        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:707)




        at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:478)




        ... 41 more




Caused by: java.lang.IllegalArgumentException: Could not create query metamodel for method public abstract entities.User repositories.UserRepository.saveAndFlush(entities.User)!




        at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:95)




        at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateIfNotFoundQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:164)




        at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$AbstractQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:71)




        at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.&amp;lt;init&amp;gt;(RepositoryFactorySupport.java:269)




        at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:142)




        at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:114)




        at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:38)




        at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:142)




        ... 49 more




Caused by: java.lang.IllegalArgumentException: No property save found for type class entities.User




        at org.springframework.data.mapping.PropertyPath.&amp;lt;init&amp;gt;(PropertyPath.java:73)




        at org.springframework.data.mapping.PropertyPath.&amp;lt;init&amp;gt;(PropertyPath.java:92)




        at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:319)




        at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:301)




        at org.springframework.data.mapping.PropertyPath.from(PropertyPath.java:265)




        at org.springframework.data.mapping.PropertyPath.from(PropertyPath.java:239)




        at org.springframework.data.repository.query.parser.Part.&amp;lt;init&amp;gt;(Part.java:70)




        at org.springframework.data.repository.query.parser.PartTree$OrPart.&amp;lt;init&amp;gt;(PartTree.java:180)




        at org.springframework.data.repository.query.parser.PartTree$Predicate.buildTree(PartTree.java:260)




        at org.springframework.data.repository.query.parser.PartTree$Predicate.&amp;lt;init&amp;gt;(PartTree.java:240)




        at org.springframework.data.repository.query.parser.PartTree.&amp;lt;init&amp;gt;(PartTree.java:68)




        at org.springframework.data.jpa.repository.query.PartTreeJpaQuery.&amp;lt;init&amp;gt;(PartTreeJpaQuery.java:57)




        at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:93)




        ... 56 more











The same code works with snapshot before weekend (13.04.2012).
So </description>
			<version>1.3 RC1</version>
			<fixedVersion>1.3 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformationUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformation.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">160</link>
		</links>
	</bug>
	<bug id="153" opendate="2012-04-17 08:18:46" fixdate="2012-04-20 04:06:42" resolution="Fixed">
		<buginformation>
			<summary>OSGi issue when using a Repository that extends QueryDslPredicateExecutor (Spring Data + QueryDsl</summary>
			<description>Hi,
I am currently testing Spring Data JPA + QueryDsl in a OSGi environment (Virgo 3.0.2.RELASE + see Environnment section of the ticket). 
When declaring a JPARepository that also extends org.springframework.data.querydsl.QueryDslPredicateExecutor&amp;lt;PortalUser&amp;gt;, I&amp;amp;apos;ve got the following stacktrace:






[2012-04-17 16:14:27.919] start-signalling-5           &amp;lt;DE0006E&amp;gt; Start failed for bundle &amp;amp;apos;org.my-repository&amp;amp;apos; version &amp;amp;apos;0.0.1.BUILD-SNAPSHOT&amp;amp;apos;. org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;org.springframework.osgi.service.exporter.support.OsgiServiceFactoryBean#1&amp;amp;apos;: Invocation of init method failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;portalUserRepository&amp;amp;apos;: FactoryBean threw exception on object creation; nested exception is java.lang.IllegalArgumentException: Did not find a query class org.my.domain.QPortalUser for domain class org.my.domain.PortalUser!




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1420)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:519)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456)




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:291)




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:288)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:190)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:563)




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:895)




	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.access$1600(AbstractDelegatedExecutionApplicationContext.java:69)




	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext$4.run(AbstractDelegatedExecutionApplicationContext.java:355)




	at org.springframework.osgi.util.internal.PrivilegedUtils.executeWithCustomTCCL(PrivilegedUtils.java:85)




	at org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.completeRefresh(AbstractDelegatedExecutionApplicationContext.java:320)




	at org.springframework.osgi.extender.internal.dependencies.startup.DependencyWaiterApplicationContextExecutor$CompleteRefreshTask.run(DependencyWaiterApplicationContextExecutor.java:132)




	at org.eclipse.virgo.kernel.agent.dm.ContextPropagatingTaskExecutor$2.run(ContextPropagatingTaskExecutor.java:95)




	at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)




	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)




	at java.lang.Thread.run(Thread.java:662)




Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;portalUserRepository&amp;amp;apos;: FactoryBean threw exception on object creation; nested exception is java.lang.IllegalArgumentException: Did not find a query class org.my.domain.QPortalUser for domain class org.my.domain.PortalUser!




	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:149)




	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.getObjectFromFactoryBean(FactoryBeanRegistrySupport.java:102)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getObjectForBeanInstance(AbstractBeanFactory.java:1429)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:245)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:190)




	at org.springframework.osgi.service.exporter.support.OsgiServiceFactoryBean.afterPropertiesSet(OsgiServiceFactoryBean.java:167)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1477)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1417)




	... 17 common frames omitted




Caused by: java.lang.IllegalArgumentException: Did not find a query class org.my.domain.QPortalUser for domain class org.my.domain.PortalUser!




	at org.springframework.data.querydsl.SimpleEntityPathResolver.createPath(SimpleEntityPathResolver.java:70)




	at org.springframework.data.jpa.repository.support.QueryDslJpaRepository.&amp;lt;init&amp;gt;(QueryDslJpaRepository.java:80)




	at org.springframework.data.jpa.repository.support.QueryDslJpaRepository.&amp;lt;init&amp;gt;(QueryDslJpaRepository.java:64)




	at org.springframework.data.jpa.repository.support.JpaRepositoryFactory.getTargetRepository(JpaRepositoryFactory.java:86)




	at org.springframework.data.jpa.repository.support.JpaRepositoryFactory.getTargetRepository(JpaRepositoryFactory.java:66)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:146)




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:120)




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:39)




	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:142)




	... 24 common frames omitted




Caused by: org.eclipse.virgo.kernel.osgi.framework.ExtendedClassNotFoundException: org.my.domain.QPortalUser in KernelBundleClassLoader: [bundle=org.springframework.data.commons_1.1.0.RELEASE]




	at org.eclipse.virgo.kernel.userregion.internal.equinox.KernelBundleClassLoader.loadClass(KernelBundleClassLoader.java:138)




	at java.lang.ClassLoader.loadClass(ClassLoader.java:247)




	at org.springframework.util.ClassUtils.forName(ClassUtils.java:257)




	at org.springframework.data.querydsl.SimpleEntityPathResolver.createPath(SimpleEntityPathResolver.java:56)




	... 32 common frames omitted




Caused by: java.lang.ClassNotFoundException: org.my.domain.QPortalUser




	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:513)




	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:429)




	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:417)




	at org.eclipse.osgi.internal.baseadaptor.DefaultClassLoader.loadClass(DefaultClassLoader.java:107)




	at org.eclipse.virgo.kernel.userregion.internal.equinox.KernelBundleClassLoader.loadClass(KernelBundleClassLoader.java:134)




	... 35 common frames omitted






It looks like to be an issue of classloader: in the method org.springframework.data.querydsl.SimpleEntityPathResolver.createPath(.), the classloader of the class SimpleEntityPathResolver is passed to the method ClassUtils.forName(.).






@SuppressWarnings("unchecked")




public &amp;lt;T&amp;gt; EntityPath&amp;lt;T&amp;gt; createPath(Class&amp;lt;T&amp;gt; domainClass) {









    String pathClassName = getQueryClassName(domainClass);




    try {




		Class&amp;lt;?&amp;gt; pathClass = ClassUtils.forName(pathClassName, SimpleEntityPathResolver.class.getClassLoader());




                       ...




	} catch (ClassNotFoundException e) {




		throw new IllegalArgumentException(String.format(NO_CLASS_FOUND_TEMPLATE, pathClassName, SimpleEntityPathResolver.class.getClassLoader()), e);




        }




}






To fix this issue, the classloader of the domainClass need to be used instead:






Class&amp;lt;?&amp;gt; pathClass = ClassUtils.forName(pathClassName, domainClass.getClassLoader());






Please, do find a patch file in attachment.
For JPA, as workaround, man can create a "copy-paste" of the class SimpleEntityPathResolver with the fix and then use a JpaRepositoryFactoryBean that creates JpaRepositoryFactory, which overrides org.springframework.data.jpa.repository.support.JpaRepositoryFactory.getTargetRepository(RepositoryMetadata, EntityManager) to use the new EntityPathResolver:






@Override




@SuppressWarnings({ "unchecked", "rawtypes" })




protected &amp;lt;T, ID extends Serializable&amp;gt; JpaRepository&amp;lt;?, ?&amp;gt; getTargetRepository(final RepositoryMetadata metadata,




                                                                                   final EntityManager entityManager) {









   Class&amp;lt;?&amp;gt; repositoryInterface = metadata.getRepositoryInterface();




   JpaEntityInformation&amp;lt;?, Serializable&amp;gt; entityInformation = getEntityInformation(metadata.getDomainClass());









   if (isQueryDslExecutor(repositoryInterface)) {




       return new QueryDslJpaRepository(entityInformation, entityManager, new OsgiEntityPathResolver());




   } else {




       return new SimpleJpaRepository(entityInformation, entityManager);




   }




}




    




// Also copy / paste of the parent method which is private




protected boolean isQueryDslExecutor(final Class&amp;lt;?&amp;gt; repositoryInterface) {




       return QUERY_DSL_PRESENT &amp;amp;&amp;amp; QueryDslPredicateExecutor.class.isAssignableFrom(repositoryInterface);




}






The workaround has been tested in the described environment.
Hope this helps.</description>
			<version>1.1 Final</version>
			<fixedVersion>1.3 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.querydsl.SimpleEntityPathResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="157" opendate="2012-04-20 01:24:38" fixdate="2012-04-20 05:15:54" resolution="Fixed">
		<buginformation>
			<summary>@Query in extending interface is not picked up correctly</summary>
			<description>I try to define an interface method in a super repository interface and &amp;amp;apos;implement&amp;amp;apos; this in an extending interface with @Query. This does not work.
Tested in the latest nightly build:






@NoRepositoryBean




public interface EntityRepository&amp;lt;T&amp;gt; extends JpaRepository&amp;lt;T, Long&amp;gt; {









	T findByDealer(Dealer dealer);




}









public interface CarRepository extends EntityRepository&amp;lt;PersonalSiteVehicle&amp;gt; {









	@Override




	@Query("select p from PersonalSiteVehicle p join p.detail d join d.enrichable e where e.dealer = ?1")




	PersonalSiteVehicle findByDealer(Dealer dealer);




}






Results in 






Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;carRepository&amp;amp;apos;: FactoryBean threw exception on object creation; nested exception is java.lang.IllegalArgumentException: Could not create query metamodel for method public abstract java.lang.Object nl.inmotiv.indi.repository.EntityRepository.findByDealer(nl.inmotiv.indi.domain.Dealer)!




	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:149)




	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.getObjectFromFactoryBean(FactoryBeanRegistrySupport.java:102)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getObjectForBeanInstance(AbstractBeanFactory.java:1442)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:248)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:848)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:790)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:707)




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:478)




	... 32 more




Caused by: java.lang.IllegalArgumentException: Could not create query metamodel for method public abstract java.lang.Object nl.inmotiv.indi.repository.EntityRepository.findByDealer(nl.inmotiv.indi.domain.Dealer)!




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:95)




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateIfNotFoundQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:164)




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$AbstractQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:71)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.&amp;lt;init&amp;gt;(RepositoryFactorySupport.java:269)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:142)




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:114)




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:38)




	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:142)




	... 40 more




Caused by: java.lang.IllegalArgumentException: No property dealer found for type class nl.inmotiv.indi.domain.PersonalSiteVehicle




	at org.springframework.data.mapping.PropertyPath.&amp;lt;init&amp;gt;(PropertyPath.java:73)




	at org.springframework.data.mapping.PropertyPath.&amp;lt;init&amp;gt;(PropertyPath.java:92)




	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:319)




	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:301)




	at org.springframework.data.mapping.PropertyPath.from(PropertyPath.java:265)




	at org.springframework.data.mapping.PropertyPath.from(PropertyPath.java:239)




	at org.springframework.data.repository.query.parser.Part.&amp;lt;init&amp;gt;(Part.java:70)




	at org.springframework.data.repository.query.parser.PartTree$OrPart.&amp;lt;init&amp;gt;(PartTree.java:180)




	at org.springframework.data.repository.query.parser.PartTree$Predicate.buildTree(PartTree.java:260)




	at org.springframework.data.repository.query.parser.PartTree$Predicate.&amp;lt;init&amp;gt;(PartTree.java:240)




	at org.springframework.data.repository.query.parser.PartTree.&amp;lt;init&amp;gt;(PartTree.java:71)




	at org.springframework.data.jpa.repository.query.PartTreeJpaQuery.&amp;lt;init&amp;gt;(PartTreeJpaQuery.java:57)




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:93)






It looks like Spring Data does not use the @Query annotation in the sub interface. </description>
			<version>1.3 RC1</version>
			<fixedVersion>1.3 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformationUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="158" opendate="2012-04-20 08:54:40" fixdate="2012-04-23 10:11:01" resolution="Duplicate">
		<buginformation>
			<summary>Stack overflow caused by digits in unknown property names</summary>
			<description>When org.springframework.data.mapping.PropertyPath tries to find a non-existent property that contains any digit (e.g. when a finder method with a mistyped property name and a digit has been added to repository interface) PropertyPath.create() method goes into a long recursion which causes StackOverflowError.
Removing digits from the finder method causes IllegalArgumentException with a helpful error message (property not found etc.) as expected.
Attaching stack-trace and a sample test project that uses a JPA repository.</description>
			<version>1.1 Final</version>
			<fixedVersion>1.3 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.PropertyUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">139</link>
		</links>
	</bug>
	<bug id="160" opendate="2012-04-21 08:47:35" fixdate="2012-04-26 09:13:19" resolution="Duplicate">
		<buginformation>
			<summary>Regression of Repository instances with only delete* methods</summary>
			<description>A repository which only defines delete methods is not created by the Spring Data code with the exception:






org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;treeEntityDeleteRepository&amp;amp;apos;: FactoryBean threw exception on object creation; nested exception is java.lang.IllegalArgumentException: Could not create query metamodel for method public abstract void example.data.DeleteOnlyRepository.delete(java.lang.Object)!




	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:149)




	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.getObjectFromFactoryBean(FactoryBeanRegistrySupport.java:102)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getObjectForBeanInstance(AbstractBeanFactory.java:1441)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:305)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:585)




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:913)




	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:464)




	at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:139)




	at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:83)




	at example.data.RepositoryTest.testExample(RepositoryTest.java:10)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:601)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)




	at org.junit.runners.BlockJUnit4ClassRunner.runNotIgnored(BlockJUnit4ClassRunner.java:79)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:71)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)




	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)




	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)




Caused by: java.lang.IllegalArgumentException: Could not create query metamodel for method public abstract void example.data.DeleteOnlyRepository.delete(java.lang.Object)!




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:95)




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateIfNotFoundQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:164)




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$AbstractQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:71)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.&amp;lt;init&amp;gt;(RepositoryFactorySupport.java:269)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:142)




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:114)




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.getObject(RepositoryFactoryBeanSupport.java:38)




	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:142)




	... 33 more




Caused by: java.lang.IllegalArgumentException: No property delete found for type class example.data.TreeEntity




	at org.springframework.data.mapping.PropertyPath.&amp;lt;init&amp;gt;(PropertyPath.java:73)




	at org.springframework.data.mapping.PropertyPath.&amp;lt;init&amp;gt;(PropertyPath.java:92)




	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:319)




	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:301)




	at org.springframework.data.mapping.PropertyPath.from(PropertyPath.java:265)




	at org.springframework.data.mapping.PropertyPath.from(PropertyPath.java:239)




	at org.springframework.data.repository.query.parser.Part.&amp;lt;init&amp;gt;(Part.java:70)




	at org.springframework.data.repository.query.parser.PartTree$OrPart.&amp;lt;init&amp;gt;(PartTree.java:180)




	at org.springframework.data.repository.query.parser.PartTree$Predicate.buildTree(PartTree.java:260)




	at org.springframework.data.repository.query.parser.PartTree$Predicate.&amp;lt;init&amp;gt;(PartTree.java:240)




	at org.springframework.data.repository.query.parser.PartTree.&amp;lt;init&amp;gt;(PartTree.java:68)




	at org.springframework.data.jpa.repository.query.PartTreeJpaQuery.&amp;lt;init&amp;gt;(PartTreeJpaQuery.java:57)




	at org.springframework.data.jpa.repository.query.JpaQueryLookupStrategy$CreateQueryLookupStrategy.resolveQuery(JpaQueryLookupStrategy.java:93)




	... 40 more






caused by a repository which extends:






public interface DeleteOnlyRepository&amp;lt;T, ID extends Serializable&amp;gt; extends Repository&amp;lt;T, ID&amp;gt;{









    public void delete(ID paramID);









    public void delete(T paramT);









    public void delete(Iterable&amp;lt;? extends T&amp;gt; paramIterable);









    public void deleteAll();









}






This appears to be a regression following the upgrade to Spring Data Commons 1.3.0 RC1, as it&amp;amp;apos;s not present when using Spring Data JPA 1.1.0.RC1, only when using the build snapshots. I realise that the bug is most likely in the data commons package, but I wasn&amp;amp;apos;t sure how to reproduce it without using the JPA component, so I&amp;amp;apos;m reporting here for the mo - hope that&amp;amp;apos;s OK.
I attach a sample Maven project to reproduce the issue
The reason for wanting such a repository is to prevent clients from performing CRU operations on a child object without the use of the parent, but I do need to offer the ability to delete it.</description>
			<version>1.3 RC1</version>
			<fixedVersion>1.3 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformationUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformation.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">154</link>
		</links>
	</bug>
	<bug id="170" opendate="2012-05-07 03:51:44" fixdate="2012-05-07 10:12:26" resolution="Fixed">
		<buginformation>
			<summary>Potential NullPointerException in ReflectionEntityInformation</summary>
			<description>After scanning for the annotation handed to the constructor, ReflectionEntityInformation tries to make it accessible before checking the field for null. This will cause a NullPointerException being thrown. Thus, thhe null-check following afterwards should be moved before that statement.</description>
			<version>1.3 RC2</version>
			<fixedVersion>1.3 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.ReflectionEntityInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="133" opendate="2012-02-08 22:51:42" fixdate="2012-05-21 04:54:15" resolution="Fixed">
		<buginformation>
			<summary>Documented Configuration of Conversion Service with DomainClassConverter Does Not Work</summary>
			<description>The Spring Data JPA documentation describes configuring a DomainClassConverter like so:






&amp;lt;mvc:annotation-driven conversion-service="conversionService" /&amp;gt;









&amp;lt;bean id="conversionService" class="....context.support.ConversionServiceFactoryBean"&amp;gt;




  &amp;lt;property name="converters"&amp;gt;




    &amp;lt;list&amp;gt;




      &amp;lt;bean class="org.springframework.data.repository.support.DomainClassConverter"&amp;gt;




        &amp;lt;constructor-arg ref="conversionService" /&amp;gt;




      &amp;lt;/bean&amp;gt;




    &amp;lt;/list&amp;gt;




  &amp;lt;/property&amp;gt;




&amp;lt;/bean&amp;gt;






However, this fails to work from an apparent cyclic instantiation error ("Error creating bean with name &amp;amp;apos;conversionService&amp;amp;apos;: FactoryBean which is currently in creation returned null from getObject").
This is one workaround for the problem:






&amp;lt;bean id="conversionService" class="org.springframework.core.convert.support.DefaultConversionService"/&amp;gt;









&amp;lt;bean class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&amp;gt;




  &amp;lt;property name="targetClass" value="org.springframework.core.convert.support.ConversionServiceFactory"/&amp;gt;




  &amp;lt;property name="targetMethod" value="registerConverters"/&amp;gt;




  &amp;lt;property name="arguments"&amp;gt;




    &amp;lt;util:list&amp;gt;




      &amp;lt;set&amp;gt;




        &amp;lt;bean class="org.springframework.data.repository.support.DomainClassConverter"&amp;gt;




          &amp;lt;constructor-arg ref="conversionService"/&amp;gt;




        &amp;lt;/bean&amp;gt;




      &amp;lt;/set&amp;gt;




      &amp;lt;ref bean="conversionService"/&amp;gt;




    &amp;lt;/util:list&amp;gt;




  &amp;lt;/property&amp;gt;




&amp;lt;/bean&amp;gt;





</description>
			<version>1.2.1</version>
			<fixedVersion>1.3 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.support.DomainClassConverter.java</file>
			<file type="M">org.springframework.data.repository.support.DomainClassConverterUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.AbstractEntityInformationUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">9177</link>
			<link type="Depend" description="depends on">9143</link>
			<link type="Depend" description="depends on">8954</link>
			<link type="Duplicate" description="is duplicated by">171</link>
			<link type="Relate" description="is related to">151</link>
		</links>
	</bug>
	<bug id="226" opendate="2012-09-03 04:24:57" fixdate="2012-09-03 04:43:23" resolution="Fixed">
		<buginformation>
			<summary>ConfigurableTypeInformationMapper caches too aggressively</summary>
			<description>If ConfigurableTypeInformationMapper is used with a MappingContext the TypeInformation and aliases managed are looked up eagerly. As types can be added later on we need to fall back to another PersistentEntity lookup in case we don&amp;amp;apos;t find a cached value. </description>
			<version>1.3.2</version>
			<fixedVersion>1.4 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.convert.TypeInformationMapper.java</file>
			<file type="M">org.springframework.data.convert.DefaultTypeMapper.java</file>
			<file type="M">org.springframework.data.mapping.MappingMetadataTests.java</file>
			<file type="M">org.springframework.data.convert.TypeAliasAccessor.java</file>
			<file type="M">org.springframework.data.convert.ConfigurableTypeInformationMapperUnitTests.java</file>
			<file type="M">org.springframework.data.convert.ConfigurableTypeInformationMapper.java</file>
			<file type="M">org.springframework.data.convert.SimpleTypeInformationMapper.java</file>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContext.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="is depended on by">523</link>
		</links>
	</bug>
	<bug id="221" opendate="2012-09-02 21:24:06" fixdate="2012-09-04 00:15:31" resolution="Fixed">
		<buginformation>
			<summary>Parsing of method names with non-ascii characters fails in some cases</summary>
			<description>Parsing of query methods with special characters fails in some cases. For instance, given this class:






class DomainObjectWithSpecialChars {




        Long id;




        String r;




        String re;




}






And the following repository:






interface DomainObjectWithSpecialChars Repository extends JpaRepository&amp;lt;DomainObjectWithSpecialChars , Long&amp;gt; {









	DomainObjectWithSpecialChars findByreAndr(String re, String r);




}






Initialization then fails with the following exception:






org.springframework.data.mapping.PropertyReferenceException: No property reAndr found for type org.springframework.data.repository.query.parser.PartTreeUnitTests$DomainObjectWithSpecialChars




	at org.springframework.data.mapping.PropertyPath.&amp;lt;init&amp;gt;(PropertyPath.java:74)




	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:326)




	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:306)




	at org.springframework.data.mapping.PropertyPath.from(PropertyPath.java:270)




	at org.springframework.data.mapping.PropertyPath.from(PropertyPath.java:244)




	at org.springframework.data.repository.query.parser.Part.&amp;lt;init&amp;gt;(Part.java:73)




	at org.springframework.data.repository.query.parser.PartTree$OrPart.&amp;lt;init&amp;gt;(PartTree.java:180)




	at org.springframework.data.repository.query.parser.PartTree$Predicate.buildTree(PartTree.java:260)




	at org.springframework.data.repository.query.parser.PartTree$Predicate.&amp;lt;init&amp;gt;(PartTree.java:240)




	at org.springframework.data.repository.query.parser.PartTree.&amp;lt;init&amp;gt;(PartTree.java:71)






The reason for this problem is the use of US-ASCII-based regex matchers (i.e. [a-z], \p
{Uppper}
, etc.) when creating the PartTree. Changing to unicode character matches (\p
{Lu}
 and \p
{Ll}
) solves the issue.</description>
			<version>1.4 RC1</version>
			<fixedVersion>1.4 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.PropertyPath.java</file>
			<file type="M">org.springframework.data.repository.query.parser.PartTree.java</file>
			<file type="M">org.springframework.data.repository.query.parser.OrderBySource.java</file>
			<file type="M">org.springframework.data.repository.query.parser.PartTreeUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="228" opendate="2012-09-10 02:05:09" fixdate="2012-09-10 06:29:13" resolution="Fixed">
		<buginformation>
			<summary>Mapping sub-system should exclude Groovy introduced properties from persistent properties</summary>
			<description>When using Groovy classes with the mapping metadata sub-system, the Groovy compiler introduced fields like metaClass should not be considered a persistent property.</description>
			<version>1.4 RC1</version>
			<fixedVersion>1.4 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContextUnitTests.java</file>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContext.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">531</link>
		</links>
	</bug>
	<bug id="176" opendate="2012-05-21 11:47:05" fixdate="2012-09-13 10:21:33" resolution="Fixed">
		<buginformation>
			<summary>StackOverflowError when inserted object is a CGLIB proxy</summary>
			<description>When trying to persist an object [to MongoDB (spring-data-mongodb v1.1.0.M1)] that is in "session" scope and using a CGLIB proxy (ie: "@Scope(value="session", proxyMode = ScopedProxyMode.TARGET_CLASS)") I receive a StackOverflowError.  When removing the session scoping, it works correctly.
java.lang.StackOverflowError
	at java.util.HashMap$EntryIterator.&amp;lt;init&amp;gt;(HashMap.java:832)
	at java.util.HashMap$EntryIterator.&amp;lt;init&amp;gt;(HashMap.java:832)
	at java.util.HashMap.newEntryIterator(HashMap.java:846)
	at java.util.HashMap$EntrySet.iterator(HashMap.java:950)
	at java.util.AbstractMap.hashCode(AbstractMap.java:459)
	at org.springframework.util.ObjectUtils.nullSafeHashCode(ObjectUtils.java:336)
	at org.springframework.data.util.TypeDiscoverer.hashCode(TypeDiscoverer.java:365)
	at org.springframework.data.util.ClassTypeInformation.hashCode(ClassTypeInformation.java:39)
	at org.springframework.util.ObjectUtils.nullSafeHashCode(ObjectUtils.java:336)
	at org.springframework.data.util.ParentTypeAwareTypeInformation.hashCode(ParentTypeAwareTypeInformation.java:79)
	at org.springframework.util.ObjectUtils.nullSafeHashCode(ObjectUtils.java:336)
	at org.springframework.data.util.ParentTypeAwareTypeInformation.hashCode(ParentTypeAwareTypeInformation.java:79)
	at org.springframework.util.ObjectUtils.nullSafeHashCode(ObjectUtils.java:336)
	at org.springframework.data.util.ParentTypeAwareTypeInformation.hashCode(ParentTypeAwareTypeInformation.java:79)
	at org.springframework.util.ObjectUtils.nullSafeHashCode(ObjectUtils.java:336)
        .... (Repeats)</description>
			<version>1.3 RC1</version>
			<fixedVersion>1.4 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.util.ClassTypeInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="233" opendate="2012-09-14 07:38:12" fixdate="2012-09-17 01:05:34" resolution="Fixed">
		<buginformation>
			<summary>DomainClassConverter should gracefully return null for null sources or empty strings</summary>
			<description>I&amp;amp;apos;ve noticed an important issue related to automatic web binding of String id to Domain class.
Imagine the use case where you have an Order domain class which has a ManyToOne reference to Customer.
When posting a new Order where Order.customer == "" then a converter exception is thrown:






Failed to convert property value of type java.lang.String to required type org.mycomp.domain.Customer for property customer; nested exception is org.springframework.core.convert.ConversionFailedException: Failed to convert from type java.lang.String to type @javax.validation.constraints.NotNull @javax.persistence.ManyToOne org.mycomp.domain.Customer for value &amp;amp;apos;; nested exception is org.springframework.dao.InvalidDataAccessApiUsageException: The given id must not be null!; nested exception is java.lang.IllegalArgumentException: The given id must not be null!






I think it should not try to convert to Domain class if id is null or empty.
And note that for optional references this even might even cause a complete blocker?
This is the code I used:






&amp;lt;form:select path="customer"&amp;gt;




	&amp;lt;form:option value="" label="Select" /&amp;gt;




	&amp;lt;form:options items="${customers}" itemValue="id"&amp;gt;&amp;lt;/form:options&amp;gt;




&amp;lt;/form:select&amp;gt;






</description>
			<version>1.3.2</version>
			<fixedVersion>1.4 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.support.DomainClassConverter.java</file>
			<file type="M">org.springframework.data.repository.support.DomainClassConverterUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="238" opendate="2012-09-21 03:01:18" fixdate="2012-10-09 00:26:14" resolution="Duplicate">
		<buginformation>
			<summary>Re-write PageableArgumentResolver (WebArgumentResolver) as HandlerMethodArgumentResolver</summary>
			<description>To align better with Spring&amp;amp;apos;s transition from WebArgumentResolver to HandlerMethodArgumentResolver (Spring 3.1) it&amp;amp;apos;s recommended to re-write existing WebArgumentResolvers.
Now a ServletWebArgumentResolverAdapter is needed to add the Pageable argument rsolver. In Java config:






@Override




public void addArgumentResolvers(List&amp;lt;HandlerMethodArgumentResolver&amp;gt; argumentResolvers) {




	argumentResolvers.add(new ServletWebArgumentResolverAdapter(new PageableArgumentResolver()));




}






Quoted from this ServletWebArgumentResolverAdapter javadocs:
Note: This class is provided for backwards compatibility. However it is recommended to re-write a WebArgumentResolver as HandlerMethodArgumentResolver. For more details see javadoc of AbstractWebArgumentResolverAdapter.</description>
			<version>1.2 RC1</version>
			<fixedVersion></fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PageableDefaults.java</file>
			<file type="D">org.springframework.data.web.PageableHandlerArgumentResolver.java</file>
			<file type="M">org.springframework.data.web.PageableArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.web.PageableArgumentResolver.java</file>
			<file type="D">org.springframework.data.web.PageableHandlerArgumentResolverUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">117</link>
		</links>
	</bug>
	<bug id="239" opendate="2012-10-04 00:51:43" fixdate="2012-10-09 02:02:58" resolution="Fixed">
		<buginformation>
			<summary>AbstractRepositoryPopulatorFactoryBean handling of ContextRefreshedEvent doesn&amp;apos;t work</summary>
			<description>The code in https://github.com/SpringSource/spring-data-commons/blob/master/spring-data-commons-core/src/main/java/org/springframework/data/repository/init/AbstractRepositoryPopulatorFactoryBean.java assumes that the ApplicationContext is the BeanFactory.
Something like to following seems to be required for a ConfigurableApplicationContext.






ApplicationContext source = event.getApplicationContext();




if (source instanceof ConfigurableApplicationContext &amp;amp;&amp;amp;




	((ConfigurableApplicationContext)source).getBeanFactory().equals(beanFactory)) {





</description>
			<version>1.4 RC1</version>
			<fixedVersion>1.4 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.init.AbstractRepositoryPopulatorFactoryBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="257" opendate="2012-11-29 02:29:27" fixdate="2012-12-12 23:20:27" resolution="Fixed">
		<buginformation>
			<summary>PropertyPath cannot deal with all uppercase fields</summary>
			<description>Cannot execute MongoOperations.findOne method if my model entity contains @Id field which name is uppercase, like UID.
Here an example:






class Foo{




  




  @Id




  private String UID;









  //code omitted




}






Steps to reproduce:
1) create an entity like in example code snippet in MongoDb
2) try to perform find by id operation by calling MongoOperations.findOne
3) at this step you will get an exception






java.lang.IllegalArgumentException: No property uID found on com.xxxxxxxxxxxxx.TemplateDefinitionObject!




	at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentPropertyPath(AbstractMappingContext.java:225)




	at org.springframework.data.mongodb.core.convert.QueryMapper.getPath(QueryMapper.java:202)




	at org.springframework.data.mongodb.core.convert.QueryMapper.determineKey(QueryMapper.java:221)




	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedObject(QueryMapper.java:87)




	at org.springframework.data.mongodb.core.MongoTemplate.doFindOne(MongoTemplate.java:1307)




	at org.springframework.data.mongodb.core.MongoTemplate.findById(MongoTemplate.java:516)




	at org.springframework.data.mongodb.core.MongoTemplate.findById(MongoTemplate.java:509)




	at org.springframework.data.mongodb.repository.support.SimpleMongoRepository.findOne(SimpleMongoRepository.java:99)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:616)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:334)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:319)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:202)




	at $Proxy37.findOne(Unknown Source)




	at com.xxxxxxxx.ShortTest.testFoo(ShortTest.java:65)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:616)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)




	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:74)




	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:83)




	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:231)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)




	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)




	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:71)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:174)




	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)




	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)





</description>
			<version>1.4 Final</version>
			<fixedVersion>1.4.1, 1.5 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.PropertyPath.java</file>
			<file type="M">org.springframework.data.mapping.PropertyPathUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="263" opendate="2012-12-08 11:44:09" fixdate="2013-01-16 09:24:53" resolution="Fixed">
		<buginformation>
			<summary>CDI integration with openEJB fails</summary>
			<description>
provided an EntityManager Producer
create context: context = EJBContainer.createEJBContainer(p).getContext();
log says:

OpenEJB.cdi - OpenWebBeans Container is starting...
org.springframework.data.jpa.repository.cdi.JpaRepositoryExtension - Activating CDI extension for Spring Data JPA repositories.
org.springframework.data.jpa.repository.cdi.JpaRepositoryExtension - Discovered &amp;amp;apos;javax.persistence.EntityManager&amp;amp;apos; with qualifiers [@javax.enterprise.inject.Any(), @javax.enterprise.inject.Default()].
and then:
Unable to resolve a bean for &amp;amp;apos;javax.persistence.EntityManager&amp;amp;apos; with qualifiers [@javax.enterprise.inject.Any(), @javax.enterprise.inject.Default()].
see also attached log</description>
			<version>1.4 Final</version>
			<fixedVersion>1.5 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.cdi.CdiRepositoryExtensionSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="272" opendate="2013-01-28 05:12:05" fixdate="2013-01-28 07:28:34" resolution="Duplicate">
		<buginformation>
			<summary>Cache Annotations in AnnotationBasedPersistentProperty</summary>
			<description>Looking up annotations every time from Java reflection is prohibitively expensive.
So please cache them.
Read annotations from getters, setters and the field and store them in a map with the same precendence rules as findAnnotation(type)
use that cache in isAnnotationPresent() and findAnnotation().
Also provide a getAnnotations() method that returns all annotations on that property. This collection would be used for Bean-Validation (JSR-303) and other methods that have to check meta-annotations.</description>
			<version>1.4 Final</version>
			<fixedVersion></fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.model.AnnotationBasedPersistentProperty.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">271</link>
		</links>
	</bug>
	<bug id="271" opendate="2013-01-28 05:10:37" fixdate="2013-01-28 07:28:43" resolution="Fixed">
		<buginformation>
			<summary>AnnotationBasedPersistentProperty should cache annotation lookups</summary>
			<description></description>
			<version>1.4 Final</version>
			<fixedVersion>1.5 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.model.AnnotationBasedPersistentProperty.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">272</link>
		</links>
	</bug>
	<bug id="276" opendate="2013-01-29 04:06:23" fixdate="2013-01-29 06:06:19" resolution="Fixed">
		<buginformation>
			<summary>ParameterizedTypeInformation is missing hashCode() method</summary>
			<description></description>
			<version>1.4 Final</version>
			<fixedVersion>1.4.1, 1.5 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.util.ParameterizedTypeInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="117" opendate="2011-12-21 07:33:22" fixdate="2013-02-12 08:42:47" resolution="Fixed">
		<buginformation>
			<summary>Add HandlerMethodArgumentResolver alternative to the PageableArgumentResolver</summary>
			<description>It is recommended to re-implement WebArgumentResolver types as HandlerMethodArgumentResolver in Spring 3.1. Although a WebArgumentResolver is adapted transparently to the new contract, as the javadoc for AbstractWebArgumentResolverAdapter indicates, a HandlerMethodArgumentResolver.supportsParameter(MethodParameter) method can only be implemented by actually calling WebArgumentResolver.resolve() and checking if the return value is UNRESOLVED. If an exception occurs during that check, it isn&amp;amp;apos;t clear if the failure is because the parameter can not be supported or whether there was some other real failure. As a result the exception has to be absorbed and other resolvers given a chance instead.</description>
			<version>1.2 RC1</version>
			<fixedVersion>1.6 M1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PageableDefaults.java</file>
			<file type="D">org.springframework.data.web.PageableHandlerArgumentResolver.java</file>
			<file type="M">org.springframework.data.web.PageableArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.web.PageableArgumentResolver.java</file>
			<file type="D">org.springframework.data.web.PageableHandlerArgumentResolverUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">238</link>
			<link type="Relate" description="relates to">330</link>
		</links>
	</bug>
	<bug id="283" opendate="2013-02-15 09:04:59" fixdate="2013-02-15 09:43:57" resolution="Fixed">
		<buginformation>
			<summary>Improve exception message for failed instantiations in ReflectionEntityInstatiator</summary>
			<description>In case we see an exception invoking the constructor of an entity class in ReflectionEntityInstantiator there&amp;amp;apos;s no information about why this has actually failed. We should capture more context such as the type to be instantiated, the constructor being used and the resolved parameters.</description>
			<version>1.5 Final</version>
			<fixedVersion>1.5.1, 1.6 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.convert.ReflectionEntityInstantiator.java</file>
			<file type="M">org.springframework.data.mapping.model.MappingInstantiationException.java</file>
			<file type="M">org.springframework.data.convert.ReflectionEntityInstantiatorUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="281" opendate="2013-02-08 12:25:43" fixdate="2013-02-27 06:22:29" resolution="Fixed">
		<buginformation>
			<summary>Change Order class so that case insensitive sorts can be performed by setting an ignore case flag</summary>
			<description>I would like to allow the setting of an ignore case flag to be set on the Order class so that case insensitive sorts can be supported.</description>
			<version>1.5 Final</version>
			<fixedVersion>1.6 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.domain.Sort.java</file>
			<file type="M">org.springframework.data.domain.SortUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="is depended on by">296</link>
		</links>
	</bug>
	<bug id="300" opendate="2013-03-21 15:42:28" fixdate="2013-03-25 05:49:25" resolution="Fixed">
		<buginformation>
			<summary>ReflectionEntityInstantiator should actually throw created exception</summary>
			<description>In the catch block a new exception is instanciated, which I assume should be thrown, but misses the throw keyword and therefore currently does nothing.
https://github.com/SpringSource/spring-data-commons/blob/master/src/main/java/org/springframework/data/convert/ReflectionEntityInstantiator.java#L64
Simplistic test that demonstrates this: https://github.com/SpringSource/spring-data-commons/pull/25/files</description>
			<version>1.5 Final</version>
			<fixedVersion>1.5.1, 1.6 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.convert.ReflectionEntityInstantiator.java</file>
			<file type="M">org.springframework.data.convert.ReflectionEntityInstantiatorUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="309" opendate="2013-04-05 11:37:35" fixdate="2013-04-10 11:26:43" resolution="Fixed">
		<buginformation>
			<summary>TypeDiscoverer does not correctly resolve nested property path expressions</summary>
			<description>





class Foo {




  Bar bar;




}









class Bar {




  Long id;




}









TypeInformation&amp;lt;?&amp;gt; type = ClassTypeInformation.from(Foo.class);




assertThat(type.getProperty("bar.id"), is(notNullValue()));






The assertion fails as TypeDiscoverer.getProperty() does not recursively resolve the properties but looks up the head in the cache only (line 180).</description>
			<version>1.5 Final</version>
			<fixedVersion>1.5.1, 1.6 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.util.TypeDiscoverer.java</file>
			<file type="M">org.springframework.data.util.ClassTypeInformationUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">324</link>
		</links>
	</bug>
	<bug id="320" opendate="2013-04-25 05:46:32" fixdate="2013-04-25 06:19:37" resolution="Fixed">
		<buginformation>
			<summary>Mapping ambiguation detection is too aggressive</summary>
			<description>We&amp;amp;apos;re using both Jackson 1.9.x annotations and Spring Data annotations on the same entity, since we have a REST/JSON api and persist to Mongo.
Here&amp;amp;apos;s the Code:






@Id




private String id;









@Override




@JsonProperty("_id")




public String getId() {




 return id;




}









@JsonProperty("_id")




public void setId(String id) {




  this.id = id;




}






At some point, we had to add both annotations to make it crystal clear for Jackson that it should both serialize and deserialize _i to the getter/setter. This worked with Spring Data Mongo 1.1.
After upgrading to Spring Data Mongo 1.2.1, we get this exception:






org.springframework.data.mapping.model.MappingException: Ambiguous mapping! Annotation interface org.codehaus.jackson.annotate.JsonProperty configured multiple times on accessor methods of property id in class com.xxxx.xxxxx.xxxxx.Foo!




	at org.springframework.data.mapping.model.AnnotationBasedPersistentProperty.populateAnnotationCache(AnnotationBasedPersistentProperty.java:86) ~[spring-data-commons-1.5.1.RELEASE.jar:na]




	at org.springframework.data.mapping.model.AnnotationBasedPersistentProperty.&amp;lt;init&amp;gt;(AnnotationBasedPersistentProperty.java:62) ~[spring-data-commons-1.5.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.mapping.BasicMongoPersistentProperty.&amp;lt;init&amp;gt;(BasicMongoPersistentProperty.java:73) ~[spring-data-mongodb-1.2.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.mapping.CachingMongoPersistentProperty.&amp;lt;init&amp;gt;(CachingMongoPersistentProperty.java:44) ~[spring-data-mongodb-1.2.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.mapping.MongoMappingContext.createPersistentProperty(MongoMappingContext.java:65) ~[spring-data-mongodb-1.2.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.mapping.MongoMappingContext.createPersistentProperty(MongoMappingContext.java:37) ~[spring-data-mongodb-1.2.1.RELEASE.jar:na]




	at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:391) ~[spring-data-commons-1.5.1.RELEASE.jar:na]




	at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:570) ~[spring-core-3.2.2.RELEASE.jar:3.2.2.RELEASE]




	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:283) ~[spring-data-commons-1.5.1.RELEASE.jar:na]




	at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:190) ~[spring-data-commons-1.5.1.RELEASE.jar:na]




	at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:159) ~[spring-data-commons-1.5.1.RELEASE.jar:na]




	at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:69) ~[spring-data-commons-1.5.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.MongoTemplate.determineCollectionName(MongoTemplate.java:1607) ~[spring-data-mongodb-1.2.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.MongoTemplate.findAll(MongoTemplate.java:1058) ~[spring-data-mongodb-1.2.1.RELEASE.jar:na]





</description>
			<version>1.5.1</version>
			<fixedVersion>1.6 M1, 1.5.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.model.AnnotationBasedPersistentProperty.java</file>
			<file type="M">org.springframework.data.mapping.model.AbstractAnnotationBasedPropertyUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="323" opendate="2013-04-30 02:56:33" fixdate="2013-05-14 08:02:59" resolution="Fixed">
		<buginformation>
			<summary>PageImpl.getTotalPages() possibly returns incorrect result when PageImpl is instantiated with simple constructor</summary>
			<description>I wonder, why PageImpl.getTotalPages() returns 0, when instantiated with simple constructor, with non zero element collection as argument.






PageImplTest.java






import org.junit.*;




import org.springframework.data.domain.*;









import java.util.*;









import static org.hamcrest.CoreMatchers.*;




import static org.junit.Assert.*;









public class PageImplTest {









    @Test




    public void getTotalPagesReturnSameResultForAllConstructors() {




        List&amp;lt;String&amp;gt; content = Arrays.asList("a", "b");









        Page&amp;lt;String&amp;gt; pageWithSimpleConstructor = new PageImpl&amp;lt;&amp;gt;(content);









        Pageable pageable = new PageRequest(0, content.size());









        Page&amp;lt;String&amp;gt; pageWithComplexConstructor = new PageImpl&amp;lt;&amp;gt;(content, pageable, content.size());









        assertThat(pageWithComplexConstructor.getTotalPages(), is(1));




        assertThat(pageWithSimpleConstructor.getTotalPages(), is(1));









    }




}





</description>
			<version>1.5 Final</version>
			<fixedVersion>1.6 M1, 1.5.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.domain.PageImpl.java</file>
			<file type="M">org.springframework.data.domain.PageImplUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="333" opendate="2013-05-27 05:54:07" fixdate="2013-05-29 09:04:30" resolution="Fixed">
		<buginformation>
			<summary>Support for Jackson 2.x for JSON repository populators</summary>
			<description>Trying to getting started with:
http://static.springsource.org/spring-data/commons/docs/current/reference/html/repositories.html#d0e893
However I get a ClassNotFoundException: org.codehaus.jackson.map.ObjectMapper when using Jackson 2.x</description>
			<version>1.5.1</version>
			<fixedVersion>1.6 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.config.RepositoryNameSpaceHandler.java</file>
			<file type="M">org.springframework.data.repository.config.ResourceReaderRepositoryPopulatorBeanDefinitionParserIntegrationTests.java</file>
			<file type="M">org.springframework.data.repository.config.ResourceReaderRepositoryPopulatorBeanDefinitionParser.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">692</link>
		</links>
	</bug>
	<bug id="327" opendate="2013-05-12 14:39:59" fixdate="2013-05-29 09:32:02" resolution="Fixed">
		<buginformation>
			<summary>AbstractMappingContext has to init domain classes in afterPropertiesSet()</summary>
			<description>We have to revert the fix introduced for DATACMNS-179 as this leaves MappingContext implementations in uninitialized state at container init stages when other application components might already rely on the context being fully initialized.
E.g. this could be a MongoDB query execution in an init method of a component that relies on all persistent entities being known in advance. </description>
			<version>1.5.1</version>
			<fixedVersion>1.6 M1, 1.5.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContextUnitTests.java</file>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContext.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">179</link>
		</links>
	</bug>
	<bug id="345" opendate="2013-07-16 02:55:56" fixdate="2013-07-16 03:47:25" resolution="Fixed">
		<buginformation>
			<summary> AbstractMappingContext doesn&amp;apos;t consider the actual type of property of a generic collection type. </summary>
			<description>AbstractMappingContext.getPersistentEntity() should use actual type information to deal with generic collection types. The current implementation of AbstractMappingContext.getPersistentEntity() returns null for the list property of the class listed below. 






static class ParentClass {




  




  String id;




  List&amp;lt;? extends AbstractChildClass&amp;gt; list;









  public ParentClass(String id, List&amp;lt;? extends AbstractChildClass&amp;gt; list) {




    this.id = id;




    this.list = list;




  }




}









static abstract class AbstractChildClass {









  String id;




  String value;









  public AbstractChildClass(String id, String value) {




    this.id = id;




    this.value = value;




  }




}









static class ConcreteChildClass extends AbstractChildClass {









  public ConcreteChildClass(String id, String value) {




    super(id, value);




  }




}





</description>
			<version>1.5.1</version>
			<fixedVersion>1.5.2, 1.6 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContextUnitTests.java</file>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContext.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="is depended on by">721</link>
		</links>
	</bug>
	<bug id="343" opendate="2013-07-12 03:09:09" fixdate="2013-08-01 07:22:05" resolution="Fixed">
		<buginformation>
			<summary>PageableHandlerMethodArgumentResolver should replace pagination parameters not add them</summary>
			<description>PageableHandlerMethodArgumentResolver.enhance() currently uses UriComponentsBuilder.queryParam() to add pagination parameters. In case the base URI already contains these parameters they&amp;amp;apos;ll add up eventually and produce invalid results.</description>
			<version>1.6 M1</version>
			<fixedVersion>1.6 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolverUnitTest.java</file>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="341" opendate="2013-07-04 22:35:09" fixdate="2013-08-12 01:51:31" resolution="Fixed">
		<buginformation>
			<summary>RepositoryFactorySupport proxy classloader</summary>
			<description>The RepositoryFactorySupport.getRepository uses result.getProxy() to create a new proxy. Since the method is called to create a new bean it should probably use the variant that accepts a classloader (obtained via ClassLoaderAware).</description>
			<version>1.5.1</version>
			<fixedVersion>1.6 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.RepositoryFactorySupportUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.RepositoryFactorySupport.java</file>
			<file type="M">org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="352" opendate="2013-08-05 19:29:05" fixdate="2013-08-13 03:17:53" resolution="Fixed">
		<buginformation>
			<summary>SortHandlerMethodArgumentResolver and PageableHandlerMethodArgumentResolver have inconsistent property names</summary>
			<description>In SortHandlerMethodArgumentResolver (added in 1.6), you can customize the request parameter name with method setSortParameter. However, PageableHandlerMethodArgumentResolver uses the word "property" instead of "paramater" for its request parameter properties: setPageProperty and setSizeProperty. These should be consistent. I prefer "parameter" because that reflects the fact that it&amp;amp;apos;s a request parameter, but however they&amp;amp;apos;re named it should be consistent.</description>
			<version>1.6 RC1</version>
			<fixedVersion>1.6 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.web.PageableDefaultUnitTests.java</file>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="304" opendate="2013-03-27 03:33:58" fixdate="2013-08-13 03:41:42" resolution="Fixed">
		<buginformation>
			<summary>Misleading documentation of page parameter resolved by PageableArgumentResolver</summary>
			<description>PageableArgumentResolver is not resolving page parameter. To use pagination, you will have to use page.page
So either table 1.1. needs an update or PageableArgumentResolver has to be changed to use the documented parameter
</description>
			<version>1.5 Final</version>
			<fixedVersion>1.6 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PageableArgumentResolver.java</file>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolver.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">359</link>
		</links>
	</bug>
	<bug id="353" opendate="2013-08-05 20:38:37" fixdate="2013-08-21 23:35:44" resolution="Fixed">
		<buginformation>
			<summary>Mandatory transitive dependency to Spring HATEOS errantly added in 1.6</summary>
			<description>The documentation for @EnableSpringDataWebSupport says this:
Annotation to automatically register the following beans for usage with Spring MVC.

DomainClassConverter - to allow usage of domain types managed by Spring Data repositories as controller method arguments bound with PathVariable or RequestParam.
PageableHandlerMethodArgumentResolver - to allow injection of Pageable instances into controller methods automatically created from request parameters.
SortHandlerMethodArgumentResolver - to allow injection of Sort instances into controller methods automatically created from request parameters.

If Spring HATEOAS is present on the classpath we will additionally register the following beans:

PagedResourcesAssembler - for injection into web components
PagedResourcesAssemblerArgumentResolver - for injection of
PagedResourcesAssembler into controller methods


However, this is not correct, and a mandatory transient dependency on Spring HATEOAS has now been added in Spring Data 1.6. Neither @EnableSpringDataWebSupport, PageableHandlerMethodArgumentResolver, nor SortHandlerMethodArgumentResolver may be used if you don&amp;amp;apos;t have Spring HATEOAS on the classpath.
If you use @EnableSpringDataWebSupport you get a NoClassDefFoundError on application startup for org/springframework/hateoas/mvc/UriComponentsContributor. If you use the PageableHandlerMethodArgumentResolver or SortHandlerMethodArgumentResolver directly you get a compilation error for missing class org.springframework.hateoas.mvc.UriComponentsContributor. This is because PageableHandlerMethodArgumentResolver and SortHandlerMethodArgumentResolver both extend UriComponentsContributor.
This is a MAJOR problem. Spring Data users must now include Spring HATEOAS in their application even if they aren&amp;amp;apos;t using it, and HATEOAS comes with its own significant set of transient dependencies. The HATEOAS components should be separated from PageableHandlerMethodArgumentResolver and SortHandlerMethodArgumentResolver so that they can be used without HATEOAS on the classpath.</description>
			<version>1.6 M1</version>
			<fixedVersion>1.6 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolver.java</file>
			<file type="D">org.springframework.data.web.LegacyPageableHandlerArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.web.PagedResourcesAssemblerUnitTests.java</file>
			<file type="M">org.springframework.data.web.config.EnableSpringDataWebSupport.java</file>
			<file type="M">org.springframework.data.web.PagedResourcesAssemblerArgumentResolver.java</file>
			<file type="D">org.springframework.data.web.SortHandlerArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration.java</file>
			<file type="M">org.springframework.data.web.SortHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.web.config.EnableSpringDataWebSupportIntegrationTests.java</file>
			<file type="M">org.springframework.data.web.config.PageableResourcesAssemblerIntegrationTests.java</file>
			<file type="M">org.springframework.data.web.PagedResourcesAssembler.java</file>
			<file type="M">org.springframework.data.web.PageableDefaultUnitTests.java</file>
			<file type="M">org.springframework.data.web.config.SpringDataWebConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="359" opendate="2013-08-20 10:37:29" fixdate="2013-08-21 23:41:04" resolution="Fixed">
		<buginformation>
			<summary>Incorrect deprecation message in PageableArgumentResolver</summary>
			<description>PageableArgumentResolver is deprecated in 1.6.RC1 to favor PageableWebHandlerArgumentResolver. However the class PageableWebHandlerArgumentResolver does not exist. I believe the new class to be used now should be PageableHandlerMethodArgumentResolver i.e. without Web after Pageable.</description>
			<version>1.6 RC1</version>
			<fixedVersion>1.6 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PageableArgumentResolver.java</file>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolver.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">304</link>
		</links>
	</bug>
	<bug id="360" opendate="2013-08-22 18:59:57" fixdate="2013-08-25 09:32:39" resolution="Fixed">
		<buginformation>
			<summary>Unable to use @Profile annotation on scanned repository interfaces</summary>
			<description>The scanner created by RepositoryConfigurationSourceSupport [1] does not set an Environment. This means that @Profile annotations on the scanned repository will be resolved against a new StandardEnvironement which will not have any active profiles.
[1] https://github.com/SpringSource/spring-data-commons/blob/ac256f9921807977fc8baa70054aa52cbcfebe6b/src/main/java/org/springframework/data/repository/config/RepositoryConfigurationSourceSupport.java#L43</description>
			<version>1.5.2</version>
			<fixedVersion>1.6 Final, 1.5.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.config.XmlRepositoryConfigurationSource.java</file>
			<file type="M">org.springframework.data.repository.config.RepositoryBeanDefinitionRegistrarSupportUnitTests.java</file>
			<file type="M">org.springframework.data.repository.config.RepositoryConfigurationSourceSupport.java</file>
			<file type="M">org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource.java</file>
			<file type="M">org.springframework.data.repository.config.AnnotationRepositoryConfigurationSourceUnitTests.java</file>
			<file type="M">org.springframework.data.repository.config.RepositoryBeanDefinitionParser.java</file>
			<file type="M">org.springframework.data.repository.config.RepositoryBeanDefinitionRegistrarSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="362" opendate="2013-08-26 09:26:53" fixdate="2013-08-26 10:20:52" resolution="Fixed">
		<buginformation>
			<summary>Potential concurrency issues in Repositories</summary>
			<description>getRepoInfoFor() is iterating over the key set of the repositories already cached to eagerly return RepositoryInformation instances found upfront. A second thread might have already passed that block of the code and triggered lookupRepositoryFactoryInformationFor() which writes into the repositories instance variable. This will cause a ConcurrentModificationException as reported in this issue.</description>
			<version>1.5.2</version>
			<fixedVersion>1.6 Final, 1.5.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.support.Repositories.java</file>
		</fixedFiles>
	</bug>
	<bug id="358" opendate="2013-08-19 09:05:03" fixdate="2013-08-26 12:43:44" resolution="Fixed">
		<buginformation>
			<summary>The current page number cannot be greater or equal to the total number of pages</summary>
			<description>I see "The current page number cannot be greater or equal to the total number 
of pages" exception when datastore has no data.
Truncated Trace:
-------------------------------------------
java.lang.IllegalArgumentException: The current page number cannot be greater or equal to the total number of pages!
	org.springframework.util.Assert.isTrue(Assert.java:65)
	org.springframework.hateoas.PagedResources$PageMetadata.&amp;lt;init&amp;gt;(PagedResources.java:207)
	org.springframework.data.web.PagedResourcesAssembler.asPageMetadata(PagedResourcesAssembler.java:162)
	org.springframework.data.web.PagedResourcesAssembler.createResource(PagedResourcesAssembler.java:124)
	org.springframework.data.web.PagedResourcesAssembler.toResource(PagedResourcesAssembler.java:109)</description>
			<version>1.6 RC1</version>
			<fixedVersion>1.6 Final</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PagedResourcesAssemblerUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="376" opendate="2013-10-01 07:12:21" fixdate="2013-10-01 08:39:01" resolution="Fixed">
		<buginformation>
			<summary>Repositories cannot deal with CGLib proxied classes</summary>
			<description>If you ask Repositories for a RepositoryInformation or PersistentEntity and pass a proxy class of a type type that is actually managed by the Repositories instance it currently returns null as the RepositoryFactoryInformation lookup fails. This is due to the lookup not actually looking up the information for the user class but the proxied one.</description>
			<version>1.5.3</version>
			<fixedVersion>1.6.2 (Babbage SR1), 1.7 M1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.support.RepositoriesIntegrationTests.java</file>
			<file type="M">org.springframework.data.repository.support.Repositories.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="is depended on by">169</link>
		</links>
	</bug>
	<bug id="363" opendate="2013-08-27 00:24:19" fixdate="2013-10-07 03:46:18" resolution="Fixed">
		<buginformation>
			<summary>Unicode characters not supported in property reference expressions</summary>
			<description>I have a class writing with Unicode.
@Getter @Setter
class TestEntity {
	Date ;
	String ;
}
I make repository method for this entity
List&amp;lt;TestEntity&amp;gt; findByAnd(Date d, String n);
But this is failed. 
Caused by: org.springframework.data.mapping.PropertyReferenceException: No property And found for type TestEntity
So I invest spring data source and found a Regex pattern is not valid in org.springframework.data.repository.query.parser.PartTree   KEYWORD_TEMPLATE
It is 
KEYWORD_TEMPLATE = "(%s)(?=p
{Lu})";

This is not for Unicode letter. Some language has no cases(no upper/lower). 

So I reference http://www.regular-expressions.info/unicode.html 
and Test with 

String KEYWORD_TEMPLATE = "(%s)(?=P{M}p{M}*+)";

It works. 


Test code is below. 


	@Test
	public void testFail_Not_Splited() {
		String KEYWORD_TEMPLATE = "(%s)(?=p{Lu}
)";
		Pattern pattern = Pattern.compile(String.format(KEYWORD_TEMPLATE, "And"));
		String[] res = pattern.split("findByAnd");
		assertEquals(1, res.length);
		assertEquals("findByAnd", res[0]);
	}
	@Test
	public void testAlternative() {
		// Reference: http://www.regular-expressions.info/unicode.html 
		String KEYWORD_TEMPLATE = "(%s)(?=P
{M}p{M}
*+)";
		Pattern pattern = Pattern.compile(String.format(KEYWORD_TEMPLATE, "And"));
		String[] res = pattern.split("findByAnd");
		assertEquals(2, res.length);
		assertEquals("findBy", res[0]);
		assertEquals("", res[1]);
	}
</description>
			<version>1.5.2</version>
			<fixedVersion>1.7 M1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.query.parser.PartTree.java</file>
			<file type="M">org.springframework.data.repository.query.parser.PartTreeUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="385" opendate="2013-10-23 05:58:59" fixdate="2013-10-23 09:53:41" resolution="Fixed">
		<buginformation>
			<summary>DefaultRepositoryInformation#getTargetClassMethod matches wrong save-Method if Entity implements Iterable</summary>
			<description>If an entity implements Iterable and I try to use SimpleJpaRepository#save(Iterable) to save a list of these entities, the code sometimes fails because DefaultRepositoryInformation#getTargetClassMethod(Method, Class) matches the save(Object)-method, depending which of the two save-methods is checked first in the loop.
To reproduce this behaviour reliably, I had to set a breakpoint in the for-Loop of getTargetClassMethod() and make sure, that the method save(Object) is called before the save(Iterable) for a list of iterable entities.</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2 (Babbage SR1), 1.7 M1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformation.java</file>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformationUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="387" opendate="2013-10-27 08:15:15" fixdate="2013-10-27 08:35:35" resolution="Fixed">
		<buginformation>
			<summary>Potential NullPointerExceptions in PartTree area</summary>
			<description>When creating a PartTree for an empty predicate (e.g. findAllByOrderByFooAsc) we create a Part with a null PropertyPath. This causes issues later on when this path is consumed excepting it not to be null at any time.
We should reject the invalid parameters handed around in the value objects more aggressively and even prevent the creation of a Part in the PartTree if the string is empty at this point.</description>
			<version>1.6.2 (Babbage SR1)</version>
			<fixedVersion>1.7 M1 (Codd), 1.6.3 (Babbage SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.domain.PageImpl.java</file>
			<file type="M">org.springframework.data.repository.query.QueryMethodUnitTests.java</file>
			<file type="M">org.springframework.data.repository.query.QueryMethod.java</file>
			<file type="M">org.springframework.data.domain.Page.java</file>
			<file type="M">org.springframework.data.web.PagedResourcesAssembler.java</file>
			<file type="M">org.springframework.data.domain.PageImplUnitTests.java</file>
			<file type="M">org.springframework.data.util.ClassTypeInformation.java</file>
			<file type="M">org.springframework.data.mapping.PropertyPathUnitTests.java</file>
			<file type="M">org.springframework.data.repository.query.parser.PartTree.java</file>
			<file type="M">org.springframework.data.repository.query.parser.Part.java</file>
			<file type="M">org.springframework.data.util.ClassTypeInformationUnitTests.java</file>
			<file type="M">org.springframework.data.mapping.PropertyPath.java</file>
			<file type="M">org.springframework.data.repository.query.parser.PartTreeUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="is depended on by">405</link>
		</links>
	</bug>
	<bug id="390" opendate="2013-10-28 09:07:46" fixdate="2013-11-04 02:33:59" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentModificationException in MappingContextTypeInformationMapper.resolveTypeFrom</summary>
			<description>I am using Spring Data and found the following Stacktrace in the logs:
Caused by: java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextEntry(HashMap.java:894)
	at java.util.HashMap$ValueIterator.next(HashMap.java:922)
	at org.springframework.data.convert.MappingContextTypeInformationMapper.resolveTypeFrom(MappingContextTypeInformationMapper.java:117)
	at org.springframework.data.convert.DefaultTypeMapper.getFromCacheOrCreate(DefaultTypeMapper.java:122)
	at org.springframework.data.convert.DefaultTypeMapper.readType(DefaultTypeMapper.java:102)
	at org.springframework.data.convert.DefaultTypeMapper.getDefaultedTypeToBeUsed(DefaultTypeMapper.java:164)
	at org.springframework.data.convert.DefaultTypeMapper.readType(DefaultTypeMapper.java:141)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:186)
I think that there might be a data race in the implementation of  org.springframework.data.mapping.context.AbstractMappingContext#getPersistentEntities()
	public Collection&amp;lt;E&amp;gt; getPersistentEntities() {
		try 
{
			read.lock();
			return persistentEntities.values();
		}
 finally 
{
			read.unlock();
		}
	}
Although the code acquires a read lock when returning the values of the HashMap "persistentEntities" it immediately releases the lock. This opens up the possibility that a thread modifies the values of "persistentEntities" while another thread is iterating over the values. 
The JavaDoc of java.util.HashMap#values() says "If the map is
 modified while an iteration over the collection is in progress
 (except through the iterator&amp;amp;apos;s own &amp;lt;tt&amp;gt;remove&amp;lt;/tt&amp;gt; operation),
  the results of the iteration are undefined."
In my case I get a ConcurrentModificationException.
It would be nice, if you could take a look at this issue.  </description>
			<version>1.5.2</version>
			<fixedVersion>1.7 M1 (Codd), 1.6.3 (Babbage SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContextUnitTests.java</file>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="408" opendate="2013-12-04 09:59:28" fixdate="2013-12-05 01:49:09" resolution="Fixed">
		<buginformation>
			<summary>Guard against invalid values when resolving pagination and sorting parameters from web requests</summary>
			<description>[example of invalid value]

page=-1 (negative numeric)
size=a (not numeric)
sort= (not specified)
sort=,DESC (not specified property of sort target)
etc ...

Current implementation of the PageableHandlerMethodArgumentResolver is occurred IllegalArgumentException, and http response status is returned 500(Internal Server Error) on the default settings of SpringMVC.
I think a best that http response status is returned 400(Bad Request).</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.3 (Babbage SR2), 1.7 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.web.SortHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.web.SortHandlerMethodArgumentResolverUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">379</link>
			<link type="Relate" description="relates to">753</link>
			<link type="Relate" description="relates to">195</link>
		</links>
	</bug>
	<bug id="377" opendate="2013-10-03 20:29:30" fixdate="2013-12-05 02:02:37" resolution="Complete">
		<buginformation>
			<summary>All elements are returned if pageSize = 0</summary>
			<description>All elements are returned if pageSize = 0 in splite of new option maxPageSize in PageableHandlerMethodArgumentResolver introduced from v1.6.
Consider the example below






@ContextConfiguration




@RunWith(SpringJUnit4ClassRunner.class)




@Transactional




@TransactionConfiguration(defaultRollback = true)




public class CustomerRepositoryTest {




    @Inject




    protected CustomerRepository customerRepository;














    @Test




    public void testFindAllPageable() {




        System.out.println(customerRepository.findAll(new PageRequest(0, 3)));




        System.out.println(customerRepository.findAll(new PageRequest(0, 0)));




        System.out.println(customerRepository.findAll(new PageRequest(0, -1)));




    }









}






Fist case, only 3 elements are returned with the following SQL






5. /* select count(*) from Customer as generatedAlias0 */ select count(*) as col_0_0_ from customer customer0_ {executed in 5 msec}




5. /* select generatedAlias0 from Customer as generatedAlias0 */ select customer0_.customer_code as customer1_3_, customer0_.customer_add as customer2_3_, customer0_.customer_birth as customer3_3_, customer0_.customer_job as customer4_3_, customer0_.customer_kana as customer5_3_, customer0_.customer_mail as customer6_3_, customer0_.customer_name as customer7_3_, customer0_.customer_pass as customer8_3_, customer0_.customer_post as customer9_3_, customer0_.customer_tel as custome10_3_ from customer customer0_ limit 3 {executed in 8 msec}






Third case, IllegalArgumentException is thrown with a message, "Page size must not be less than zero!".
I think these are correct result.
However, in second case, all elements are returned with the following SQL






5. /* select count(*) from Customer as generatedAlias0 */ select count(*) as col_0_0_ from customer customer0_ {executed in 2 msec}




5. /* select generatedAlias0 from Customer as generatedAlias0 */ select customer0_.customer_code as customer1_3_, customer0_.customer_add as customer2_3_, customer0_.customer_birth as customer3_3_, customer0_.customer_job as customer4_3_, customer0_.customer_kana as customer5_3_, customer0_.customer_mail as customer6_3_, customer0_.customer_name as customer7_3_, customer0_.customer_pass as customer8_3_, customer0_.customer_post as customer9_3_, customer0_.customer_tel as custome10_3_ from customer customer0_ {executed in 7 msec}






Note that there is no &amp;amp;apos;limit&amp;amp;apos; statement.
I&amp;amp;apos;m afraid tha it will cause OutOfMemoryError easily and weak for DDoS atack.
I think it&amp;amp;apos;s better to throw IllegalArgumentException if pageSize=0 or replace pageSize by maxPageSize.</description>
			<version>1.6.1</version>
			<fixedVersion>1.7 M1 (Codd), 1.6.3 (Babbage SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.domain.PageRequest.java</file>
			<file type="M">org.springframework.data.domain.PageRequestUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="366" opendate="2013-09-06 05:44:40" fixdate="2013-12-05 02:12:34" resolution="Fixed">
		<buginformation>
			<summary>PageableArgumentResolver does not support list of properties to sort on</summary>
			<description>Query parameters such as &amp;amp;apos;?page.sort=name&amp;amp;page.sort=description&amp;amp;apos; or &amp;amp;apos;?page.sort=name,description&amp;amp;apos; end up creating a Sort instance (via org.springframework.data.web.PageableArgumentResolver.SortPropertyEditor.setAsText(String)) that sorts on SINGLE property named &amp;amp;apos;name,description&amp;amp;apos; instead of TWO properties named &amp;amp;apos;name&amp;amp;apos; and &amp;amp;apos;description&amp;amp;apos;. This results in &amp;amp;apos;org.springframework.data.mapping.PropertyReferenceException: No property name,description found for type com.co.Xyz&amp;amp;apos;. Fix might to to update line in setAsText method from &amp;amp;apos;setValue(new Sort(order, text));&amp;amp;apos; to &amp;amp;apos;setValue(new Sort(order, StringUtils.commaDelimitedListToStringArray(text)));&amp;amp;apos;.</description>
			<version>1.5.2</version>
			<fixedVersion>1.6.3 (Babbage SR2), 1.7 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.SortHandlerMethodArgumentResolverUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="379" opendate="2013-10-08 11:52:55" fixdate="2013-12-05 06:01:44" resolution="Fixed">
		<buginformation>
			<summary>SortHanderMethodArgumentResolver fails to resolve comma-only sort parameter</summary>
			<description>If specified ","(comma only) in parameter value of sort, occurred the ArrayIndexOutOfBoundsException.
I expected that IllegalArgumentException occurs.
Other patterns is occurred IllegalArgumentException.</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.3 (Babbage SR2), 1.7 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.SortHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.web.SortHandlerMethodArgumentResolverUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">408</link>
		</links>
	</bug>
	<bug id="410" opendate="2013-12-04 11:14:35" fixdate="2013-12-13 05:24:00" resolution="Fixed">
		<buginformation>
			<summary>ReflectionRepositoryInvoker not working properly</summary>
			<description>The ReflectionRepositoryInvoker is not invoking the findOne method correctly on a non-CrudRepository implementation. Specifically, the:






 




public T invokeFindOne(Serializable id) {




  return (T) ReflectionUtils.invokeMethod(methods.getFindOneMethod(), id);




}






should be fixed to: 






 




public T invokeFindOne (Serializable id) {




  return (T) ReflectionUtils.invokeMethod (methods.getFindOneMethod (), repository, id);




}






</description>
			<version>1.6.2 (Babbage SR1)</version>
			<fixedVersion>1.7 RC1 (Codd), 1.6.4 (Babbage SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.support.ReflectionRepositoryInvokerUnitTests.java</file>
			<file type="M">org.springframework.data.repository.support.ReflectionRepositoryInvoker.java</file>
			<file type="M">org.springframework.data.repository.support.RepositoriesIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="415" opendate="2014-01-12 13:56:00" fixdate="2014-01-12 14:15:02" resolution="Fixed">
		<buginformation>
			<summary>Performance improvements in configuration subsystem</summary>
			<description>Original email by Martin Lippert:

The implementation creates a new ClassPathScanningCandidateComponentProvider without setting a MetadataReaderFactory. This causes a new caching metadata reading factory being created every time this method is called, resulting in more or less no caching for the metadata. I am not sure from where to get the appropriate MetadataReaderFactory, but the ConfigurationClassPostProcessor has the right one. I hope there is a way to reuse that, it would reduce the loading and parsing of byte code a lot.</description>
			<version>1.6.3 (Babbage SR2)</version>
			<fixedVersion>1.7 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.config.RepositoryBeanDefinitionBuilder.java</file>
			<file type="M">org.springframework.data.repository.config.RepositoryBeanDefinitionParser.java</file>
			<file type="M">org.springframework.data.repository.config.RepositoryBeanDefinitionRegistrarSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="419" opendate="2014-01-16 05:22:39" fixdate="2014-01-16 05:37:28" resolution="Fixed">
		<buginformation>
			<summary>PagedResourcesAssemblerArgumentResolver fails for methods with templated mappings</summary>
			<description></description>
			<version>1.6.3 (Babbage SR2)</version>
			<fixedVersion>1.7 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PagedResourcesAssemblerArgumentResolver.java</file>
			<file type="M">org.springframework.data.web.PagedResourcesAssemblerArgumentResolverUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="412" opendate="2014-01-08 03:51:56" fixdate="2014-01-17 06:56:56" resolution="Fixed">
		<buginformation>
			<summary>Exception &amp;apos; java.lang.IllegalArgumentException: Not an managed type&amp;apos; upon a tomcat context reload</summary>
			<description>Exception &amp;amp;apos; java.lang.IllegalArgumentException: Not an managed type&amp;amp;apos; upon a tomcat context reload when cached &amp;amp;apos;RepositoryInformation&amp;amp;apos; (change added in  DATACMNS-395) is returned by the &amp;amp;apos;RepositoryFactorySupport&amp;amp;apos; class.
The &amp;amp;apos;Environment&amp;amp;apos; field of this Jira issue contains details on my setup (emdedded tomcat 7).
The attached file &amp;amp;apos;tomcat-log.txt&amp;amp;apos; contains the full trace of the exception and context reload.
If I modify RepositoryFactorySupport#getRepositoryInformation and have it always return new RepositoryInformation (i.e. effectively the old behaviour prior to the DATACMNS-395 change) then this exception does not occur.
Attached ("RepositoryInformationCmp.txt") is a dump of the cached version of RepositoryInformation vs a newly created instance (I used ReflectionToStringBuilder with a recursive &amp;amp;apos;ToStringStyle&amp;amp;apos; strategey to produce the dump). The &amp;amp;apos;diff&amp;amp;apos; utility reveals that the content of both instances is identical.
Note however that the recursion stops at java.lang classes and so does not include the contents of the &amp;amp;apos;Class&amp;amp;apos; classes which is where I believe the difference lies.
My theory on the cause of this problem is that a new class loader is instantiated when the Tomcat context is reloaded, thereby somehow invalidating existing &amp;amp;apos;Class&amp;amp;apos; meta-information.
Interestingly, the first comment I saw upon navigating to the Spring Data Commons Jira site, by Seppel Hardt read with words to the effect that he encountered a similar problem and had reached a similar conclusion.
By anecdotal observation of stack overflow posts, I see there appears to numerous other users facing this issue also.</description>
			<version>1.6.3 (Babbage SR2)</version>
			<fixedVersion>1.7 RC1 (Codd), 1.6.4 (Babbage SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.RepositoryFactorySupport.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">395</link>
		</links>
	</bug>
	<bug id="429" opendate="2014-01-22 07:45:22" fixdate="2014-01-23 03:24:30" resolution="Fixed">
		<buginformation>
			<summary>PageRequest constructor documentation parameter order incorrect.</summary>
			<description>The documentation for the constructor PageRequest(int page, int size) is incorrect as it has the parameters listed in the wrong order.</description>
			<version>1.6.1</version>
			<fixedVersion>1.7 RC1 (Codd), 1.6.4 (Babbage SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.domain.Sort.java</file>
			<file type="M">org.springframework.data.domain.PageRequest.java</file>
		</fixedFiles>
	</bug>
	<bug id="432" opendate="2014-01-30 04:09:52" fixdate="2014-02-06 09:07:06" resolution="Fixed">
		<buginformation>
			<summary>ConcurrentModificationException in Repositories.getRepoInfoFor(Repositories.java:183)</summary>
			<description>If the first request(s) to a repository after starting the application server comes in  multithreaded, a Concurentmodification exception is thrown.
All subsequent requests are working.
Seems releated to: DATACMNS-362
SEVERE: Servlet.service() for servlet [yes] in context with path [/yes] threw exception [Request processing failed; nested exception is java.util.ConcurrentModificationException] with root cause
java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextEntry(HashMap.java:926)
	at java.util.HashMap$KeyIterator.next(HashMap.java:960)
	at java.util.Collections$UnmodifiableCollection$1.next(Collections.java:1067)
	at org.springframework.data.repository.support.Repositories.getRepoInfoFor(Repositories.java:183)
	at org.springframework.data.repository.support.Repositories.getRepositoryInformationFor(Repositories.java:130)
	at org.springframework.data.repository.support.DomainClassConverter.matches(DomainClassConverter.java:86)
	at org.springframework.core.convert.support.GenericConversionService$ConvertersForPair.getConverter(GenericConversionService.java:617)
	at org.springframework.core.convert.support.GenericConversionService$Converters.getRegisteredConverter(GenericConversionService.java:523)
	at org.springframework.core.convert.support.GenericConversionService$Converters.find(GenericConversionService.java:507)
	at org.springframework.core.convert.support.GenericConversionService.getConverter(GenericConversionService.java:240)
	at org.springframework.core.convert.support.GenericConversionService.canConvert(GenericConversionService.java:135)
	at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:159)
	at org.springframework.beans.TypeConverterDelegate.convertIfNecessary(TypeConverterDelegate.java:93)
	at org.springframework.beans.TypeConverterSupport.doConvert(TypeConverterSupport.java:64)
	at org.springframework.beans.TypeConverterSupport.convertIfNecessary(TypeConverterSupport.java:47)
	at org.springframework.validation.DataBinder.convertIfNecessary(DataBinder.java:582)
	at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:102)
	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:79)
	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:157)
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:124)
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:748)
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:689)
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:83)
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:945)
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:876)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:931)
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:822)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:621)</description>
			<version>1.6.3 (Babbage SR2)</version>
			<fixedVersion>1.6.4 (Babbage SR3), 1.7 Final (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.support.Repositories.java</file>
			<file type="M">org.springframework.data.repository.core.support.RepositoryFactoryBeanSupportUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">246</link>
			<link type="Relate" description="relates to">471</link>
		</links>
	</bug>
	<bug id="436" opendate="2014-02-06 07:26:04" fixdate="2014-02-06 09:17:15" resolution="Fixed">
		<buginformation>
			<summary>Order.ignoreCase not taken into account in equals(), hashCode() and toString()</summary>
			<description>The org.springframework.data.domain.Sort.Order#ignoreCase field is not taken into account in Order#equals(), Order#hashCode() and Order#toString(), although setting this field to different values impacts the semantics of Order.</description>
			<version>1.6.3 (Babbage SR2)</version>
			<fixedVersion>1.6.4 (Babbage SR3), 1.7 Final (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.domain.Sort.java</file>
			<file type="M">org.springframework.data.domain.SortUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="441" opendate="2014-02-18 04:41:56" fixdate="2014-02-19 00:34:21" resolution="Fixed">
		<buginformation>
			<summary>Analyzing @Query annotated bridge methods lead to NPEs during QueryMethod processing in Java 8</summary>
			<description>We should skip bridge methods instead considering them for @Query annotation inspection, since we cannot extract the generic type parameter from bridge  methods.</description>
			<version>1.7 RC1 (Codd)</version>
			<fixedVersion>1.7 Final (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformation.java</file>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformationUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">465</link>
		</links>
	</bug>
	<bug id="453" opendate="2014-02-26 05:25:34" fixdate="2014-02-26 23:40:27" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException at listing non-CRUD repositories in RepositoryMetadata.isPageableRepository()</summary>
			<description>Listing repositories if one repository has no pageable finders leads to a NullPointerException.</description>
			<version>1.7 Final (Codd)</version>
			<fixedVersion>1.7.1 (Codd SR1), 1.8 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.AbstractRepositoryMetadataUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.AbstractRepositoryMetadata.java</file>
		</fixedFiles>
	</bug>
	<bug id="477" opendate="2014-03-26 09:51:20" fixdate="2014-03-26 10:24:20" resolution="Fixed">
		<buginformation>
			<summary>PageableHandlerMethodArgumentResolver.setFallbackPageable(null) does not work as specified</summary>
			<description>The javadoc indicates that passing null to this method is valid and should result in a null value handed into the controller method.  However if a null value is passed the result is a NullPointerException thrown from the resolveArgument() method.  It is clear from the implementation code in resolveArgument() that a null default is not anticipated.  The fix is relatively trivial: the resolveArgument() method simply needs to return null if the defaultOrFallback value is null.
The ability to provide null as a default value allows an application to support both paged and non paged results from a single controller method, depending on whether the page parameters are passed in.  The workaround is to declare separate methods and use request mappings to differentiate them based on presence of the page parameters in the request, but this seems awkward compared to being able to simply test for a null pageable.</description>
			<version>1.7.1 (Codd SR1)</version>
			<fixedVersion>1.8 M1 (Dijkstra), 1.7.2 (Codd SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.web.PageableDefaultUnitTests.java</file>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="479" opendate="2014-03-27 04:17:50" fixdate="2014-03-27 04:25:26" resolution="Fixed">
		<buginformation>
			<summary>Regression in PersistentEntity detection for concrete Map types</summary>
			<description>A change introduced in Spring Data Commons 1.7.x to improve the detection of nested PersistentEntities causes concrete Map types being added to the MappingContext in case they are used as property type.
This is caused by PersistentProperty.isEntity() not excluding Map and Collection types anymore and PersistentProperty.getPersistentEntityTypes() adding the sole type to the list of returned types in a subsequent detection step.
We should ditch the check on isEntity() altogether and solely rely on the list of nested types being returned from getPersistentEntityTypes(). Ironically, master already has this implemented correctly due to the changes made for DATACMNS-243. Still we should forward port the slight change in the detection algorithm to keep them as consistent as possible.</description>
			<version>1.7.1 (Codd SR1)</version>
			<fixedVersion>1.8 M1 (Dijkstra), 1.7.2 (Codd SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContextUnitTests.java</file>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContext.java</file>
			<file type="M">org.springframework.data.mapping.model.AbstractPersistentProperty.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="is depended on by">887</link>
		</links>
	</bug>
	<bug id="501" opendate="2014-05-05 22:39:24" fixdate="2014-05-06 01:48:57" resolution="Fixed">
		<buginformation>
			<summary>ID type not detected for intermediate repository interface</summary>
			<description>I have a class hierarchy as follows (actual code running in Production):






abstract class Entity {}









@MappedSuperClass




abstract class RelationalEntity {}









@Entity




@Inheritance(strategy = InheritanceType.JOINED)




@Table(name = "person")




public class Person extends RelationalEntity {}









@Entity




@Table(name = "employee")




public class Employee extends Person {}









@Entity




@Table(name = "manager")




public class Manager extends Employee {}






and their corresponding Spring Data JPA repositories:






@NoRepositoryBean




public interface RelationalEntityRepository&amp;lt;T extends RelationalEntity&amp;gt; extends JpaRepository&amp;lt;T, Long&amp;gt; {}









public interface PersonRepository&amp;lt;P extends Person&amp;gt; extends RelationalEntityRepository&amp;lt;P&amp;gt; {}









public interface EmployeeRepository extends PersonRepository&amp;lt;Employee&amp;gt; {}









public interface ManagerRepository extends PersonRepository&amp;lt;Manager&amp;gt; {}






We have to sometimes run queries such as PersonRepository&amp;lt;Person&amp;gt;.count() because of which we have not marked that repository with NoRepositoryBean.  This arrangement is working fine in production with Spring Data JPA 1.4.3.
On attempting to upgrade to Spring Data JPA 1.5.2 we get the following exception:






Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;personRepository&amp;amp;apos;: Invocation of init method failed; nested exception is java.lang.IllegalArgumentException: Could not resolve id type of interface org.example.data.PersonRepository!




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1553)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:539)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475)




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304)




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:684)




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:760)




	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482)




	at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:125)




	at org.springframework.test.context.support.AbstractGenericContextLoader.loadContext(AbstractGenericContextLoader.java:60)




	at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.delegateLoading(AbstractDelegatingSmartContextLoader.java:100)




	at org.springframework.test.context.support.AbstractDelegatingSmartContextLoader.loadContext(AbstractDelegatingSmartContextLoader.java:250)




	at org.springframework.test.context.CacheAwareContextLoaderDelegate.loadContextInternal(CacheAwareContextLoaderDelegate.java:64)




	at org.springframework.test.context.CacheAwareContextLoaderDelegate.loadContext(CacheAwareContextLoaderDelegate.java:91)




	... 25 more




Caused by: java.lang.IllegalArgumentException: Could not resolve id type of interface org.example.data.PersonRepository!




	at org.springframework.data.repository.core.support.DefaultRepositoryMetadata.resolveIdType(DefaultRepositoryMetadata.java:79)




	at org.springframework.data.repository.core.support.DefaultRepositoryMetadata.&amp;lt;init&amp;gt;(DefaultRepositoryMetadata.java:51)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepositoryMetadata(RepositoryFactorySupport.java:173)




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.afterPropertiesSet(RepositoryFactoryBeanSupport.java:207)




	at org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean.afterPropertiesSet(JpaRepositoryFactoryBean.java:84)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1612)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1549)




	... 40 more






This exception is thrown from every Spring Data JPA version 1.4.4 onwards.
We have a few class hierarchies like this in our code base for which Spring Data JPA has been working well so far.  Has this kind of support been dropped from 1.4.4 onwards?
Attached is a sample project that demonstrates the problem.</description>
			<version>1.7.2 (Codd SR2)</version>
			<fixedVersion>1.8 GA (Dijkstra), 1.7.3 (Codd SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryMetadataUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryMetadata.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">11763</link>
		</links>
	</bug>
	<bug id="502" opendate="2014-05-07 11:01:22" fixdate="2014-05-08 05:54:02" resolution="Fixed">
		<buginformation>
			<summary>AnnotationRepositoryConfigurationSource fails when the annotated class is in the default package.</summary>
			<description>






@Configuration




@ComponentScan




@EnableJpaRepositories




public class OtherConfig {




}






No package statement.  This class is in the default package.






Caused by: java.lang.StringIndexOutOfBoundsException: String index out of range: -1




	at java.lang.String.substring(String.java:1911) ~[na:1.7.0_51]




	at org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource.getBasePackages(AnnotationRepositoryConfigurationSource.java:98) ~[spring-data-commons-1.7.2.RELEASE.jar:na]




	at org.springframework.data.repository.config.RepositoryConfigurationSourceSupport.getCandidates(RepositoryConfigurationSourceSupport.java:68) ~[spring-data-commons-1.7.2.RELEASE.jar:na]




	at org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport.getRepositoryConfigurations(RepositoryConfigurationExtensionSupport.java:54) ~[spring-data-commons-1.7.2.RELEASE.jar:na]




	at org.springframework.data.repository.config.RepositoryConfigurationDelegate.registerRepositoriesIn(RepositoryConfigurationDelegate.java:88) ~[spring-data-commons-1.7.2.RELEASE.jar:na]




	at org.springframework.data.repository.config.RepositoryBeanDefinitionRegistrarSupport.registerBeanDefinitions(RepositoryBeanDefinitionRegistrarSupport.java:78) ~[spring-data-commons-1.7.2.RELEASE.jar:na]






This should not cause an exception.
Thanks,
Adam and Rossen</description>
			<version>1.7.2 (Codd SR2)</version>
			<fixedVersion>1.8 GA (Dijkstra), 1.7.3 (Codd SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.config.AnnotationRepositoryConfigurationSourceUnitTests.java</file>
			<file type="M">org.springframework.data.repository.config.AnnotationRepositoryConfigurationSource.java</file>
		</fixedFiles>
	</bug>
	<bug id="509" opendate="2014-05-08 08:39:02" fixdate="2014-05-20 07:35:26" resolution="Fixed">
		<buginformation>
			<summary>NullableWrapper Breaks JSON Conversion</summary>
			<description>Since an upgrade to JPA 1.6 RC1, Spring MVC fails to properly address a NullableWrapper and this is returned, with the contents contained with the NullableWrapper.
I have a MVC method that is returning:






public Callable&amp;lt;Set&amp;lt;Pos&amp;gt;&amp;gt; get(.....) {




    final Set&amp;lt;Pos&amp;gt; allPos = posService.findAll();




    return ImmutableSortedSet.copyOf(allPos);




}






With Spring Data JPA 1.5., I get on the wire a set of Pos&amp;amp;apos;s in JSON format, i.e.,






[{"name: "pos1"}, {"name: "pos2"}]






With Spring Data JPA 1.6 RC1, I now get the NullableWrapper with Contents:






[valueType: "java.util.ArrayList", value: [{"name: "pos1"}, {"name: "pos2"}]]





</description>
			<version>1.8 RC1 (Dijkstra)</version>
			<fixedVersion>1.8 GA (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.util.QueryExecutionConverters.java</file>
			<file type="M">org.springframework.data.repository.core.support.RepositoryFactorySupport.java</file>
			<file type="M">org.springframework.data.repository.core.support.DummyRepositoryFactory.java</file>
			<file type="M">org.springframework.data.repository.core.support.RepositoryFactorySupportUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="511" opendate="2014-05-22 00:04:43" fixdate="2014-05-31 05:54:31" resolution="Fixed">
		<buginformation>
			<summary>AbstractMappingContext.addPersistentEntity causes infinite loop</summary>
			<description>After updating from Codd SR2 to Dijkstra I could not run my tests. After debugging the issue I found that the problem lies in AbstractMappingContext.addPersistentEntity. This method is never called in Codd SR2 due to initialize not being triggered.
We use quite a few abstract MappedSuperclasses that have circular references and apparently this does not work. An example:






public class User extends AbstractTenantUser&amp;lt;User, Role, Permission, Tenant&amp;gt; {




    ...




}




public abstract class AbstractTenantUser&amp;lt;USER extends AbstractTenantUser&amp;lt;USER, ROLE, PERMISSION, TENANT&amp;gt;, ROLE extends AbstractRole&amp;lt;USER, PERMISSION&amp;gt;, PERMISSION extends AbstractPermission&amp;lt;USER&amp;gt;, TENANT extends AbstractTenant&amp;lt;USER&amp;gt;&amp;gt; extends AbstractUser&amp;lt;USER, ROLE, PERMISSION&amp;gt; implements TenantEntity&amp;lt;TENANT&amp;gt; {




    ...




}




public abstract class AbstractUser&amp;lt;USER extends AbstractUser&amp;lt;USER, ROLE, PERMISSION&amp;gt;, ROLE extends AbstractRole&amp;lt;USER, PERMISSION&amp;gt;, PERMISSION extends AbstractPermission&amp;lt;USER&amp;gt;&amp;gt; extends AuditingDateBaseEntity&amp;lt;USER&amp;gt; {




    ...




}




public abstract class AbstractPermission&amp;lt;USER extends AbstractUser&amp;lt;USER, ?, ?&amp;gt;&amp;gt; extends AuditingDateBaseEntity&amp;lt;USER&amp;gt; {




    ...




}




public abstract class AuditingDateBaseEntity&amp;lt;USER extends AbstractUser&amp;lt;USER, ?, ?&amp;gt;&amp;gt; extends AbstractDateBaseEntity implements AuditingEntity&amp;lt;USER&amp;gt; {




    ...




}




public abstract class AbstractDateBaseEntity extends AbstractBaseEntity implements DateEntity {




    ...




}




public abstract class AbstractBaseEntity implements BaseEntity {




    ...




}






I hope this gives enough insight into the problem and hopefully you can fix this soon.</description>
			<version>1.8 GA (Dijkstra)</version>
			<fixedVersion>1.7.3 (Codd SR3), 1.8.1 (Dijkstra SR1), 1.9 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.util.TypeVariableTypeInformation.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">558</link>
		</links>
	</bug>
	<bug id="519" opendate="2014-06-11 06:14:40" fixdate="2014-06-12 04:03:37" resolution="Fixed">
		<buginformation>
			<summary>PagedResourcesAssembler should keep tempalte variables provided in base link</summary>
			<description></description>
			<version>1.7.2 (Codd SR2)</version>
			<fixedVersion>1.9 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PagedResourcesAssembler.java</file>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolver.java</file>
			<file type="M">org.springframework.data.web.PagedResourcesAssemblerUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="518" opendate="2014-06-10 10:08:36" fixdate="2014-06-26 05:12:06" resolution="Fixed">
		<buginformation>
			<summary>Spring Data Infinite Loop in HashMap in PreferredConstructor and CustomConversions</summary>
			<description>See also post at newsgroup:
http://forum.spring.io/forum/spring-projects/data/750072-spring-data-infinite-loop-in-hashmap-in-preferredconstructor-and-customconversions
Spring Data Infinite Loops in Production
This post is related to an issue we have started seeing in production at the company where I work. I am trying to figure out where to take this next. Should I proceed to filing a bug report, or do I need to try and collect more information?
It started happening a few weeks ago. We would see a box CPU suddenly go to 100% indefinitely until the app was redeployed. Fortunately, we did take thread dumps, and in one case a heap dump. We were able to see that there is a recurring infinite loop in two places in Spring Data.
This has happened a total of 3 times now. Given the number of nodes we run in PROD, INT and QA (some number &amp;gt; 30), and the length of time we have been in production on this stack, we would characterize it as a rare occurrence. But it worries us.
One could ask "what changed in the application to make this start happening?". Ack. We are in our busy season right now, so a lot of commits went into our application for the weeks prior to the first occurrence. And given the rare nature of the problem, it would be difficult to really identify even the time range of commits that we would need to evaluate. Root Cause
In all 3 cases, the infinite loop is coming from concurrent updates to the thread-unsafe HashMap class. We see it happening within two Spring Data classes:

org.springframework.data.mapping.PreferredConstructor
org.springframework.data.mongodb.core.convert.CustomConversions

I could explain why HashMap is getting stuck in infinite loops, but several others have already done a great job doing it, so I refer you there:

http://mailinator.blogspot.dk/2009/06/beautiful-race-condition.html
https://code.google.com/p/javasimon/issues/detail?id=115

Stack Trace Snippets
These stack traces come from our thread dumps. Each stack is seen multiple times when the problem occurs. 
PreferredConstructor
"http-bio-8080-exec-235" daemon prio=10 tid=0x00007fb19c0a9800 nid=0x5337 runnable [0x00007fb228953000]
java.lang.Thread.State: RUNNABLE
at java.util.HashMap.getEntry(HashMap.java:469)
at java.util.HashMap.get(HashMap.java:421)
at org.springframework.data.mapping.PreferredConstruc tor.isConstructorParameter(PreferredConstructor.ja va:120)
at org.springframework.data.mapping.model.BasicPersis tentEntity.isConstructorArgument(BasicPersistentEn tity.java:98)
at org.springframework.data.mongodb.core.convert.Mapp ingMongoConverter$1.doWithPersistentProperty(Mappi ngMongoConverter.java:252)
at org.springframework.data.mongodb.core.convert.Mapp ingMongoConverter$1.doWithPersistentProperty(Mappi ngMongoConverter.java:249)
at org.springframework.data.mapping.model.BasicPersis tentEntity.doWithProperties(BasicPersistentEntity. java:257)
at 
CustomConversions
"http-bio-8080-exec-75" daemon prio=10 tid=0x00007f3688018000 nid=0x6c2e runnable [0x00007f376e9ef000]
java.lang.Thread.State: RUNNABLE
at java.util.HashMap.getEntry(HashMap.java:469)
at java.util.HashMap.get(HashMap.java:421)
at org.springframework.data.mongodb.core.convert.Cust omConversions.getCustomReadTarget(CustomConversion s.java:317)
at org.springframework.data.mongodb.core.convert.Cust omConversions.hasCustomReadTarget(CustomConversion s.java:281)
at org.springframework.data.mongodb.core.convert.Mapp ingMongoConverter.read(MappingMongoConverter.java: 200)
at org.springframework.data.mongodb.core.convert.Mapp ingMongoConverter.readCollectionOrArray(MappingMon goConverter.java:791)
at 
More Information
I posted a lot more information about this issue here:

http://peterlairdtech.blogspot.com/2014/06/spring-data-infinite-loop-in-hashmap-in.html

Please let me know if there are things I can do to help diagnose this further. Thanks!</description>
			<version>1.6.2 (Babbage SR1)</version>
			<fixedVersion>1.8.1 (Dijkstra SR1), 1.9 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.PreferredConstructor.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">830</link>
		</links>
	</bug>
	<bug id="562" opendate="2014-08-19 01:25:20" fixdate="2014-08-19 07:50:41" resolution="Fixed">
		<buginformation>
			<summary>MappingContext fails to resolve TreeMap as Map value type</summary>
			<description>This is the Class of entity used to save to mongodb.






ClassC.java






public class ClassC extends ClassA {




	private ClassB b;









	public ClassB getB() {




		return b;




	}









	public void setB(ClassB b) {




		this.b = b;




	}




}









class ClassA {









	private String name;









	private ClassD dObject;









	public String getName() {




		return name;




	}









	public void setName(String name) {




		this.name = name;




	}









	public ClassD getdObject() {




		return dObject;




	}









	public void setdObject(ClassD dObject) {




		this.dObject = dObject;




	}




}









class ClassB extends ClassA {




}









class ClassD {









	private TreeMap&amp;lt;String, TreeMap&amp;lt;String, String&amp;gt;&amp;gt; map = new TreeMap&amp;lt;&amp;gt;();









	public TreeMap&amp;lt;String, TreeMap&amp;lt;String, String&amp;gt;&amp;gt; getMap() {




		return map;




	}









	public void setMap(TreeMap&amp;lt;String, TreeMap&amp;lt;String, String&amp;gt;&amp;gt; map) {




		this.map = map;




	}









}






This is the call entry:






// handle this correctly somewhere




// @Autowired




// private MongoOperations	mongoTemplate;









ClassC cObject = new ClassC();




cObject.setName("Jon");




try {




	mongoTemplate.save(cObject, "c");




} catch (Exception e) {




	e.printStackTrace();




}






Exception caught as below:






java.lang.ArrayIndexOutOfBoundsException: 0




at org.springframework.data.util.ParameterizedTypeInformation.getComponentType(ParameterizedTypeInformation.java:147)




at org.springframework.data.util.TypeDiscoverer.getActualType(TypeDiscoverer.java:292)




at org.springframework.data.util.ParentTypeAwareTypeInformation.getActualType(ParentTypeAwareTypeInformation.java:29)




at org.springframework.data.mapping.model.AbstractPersistentProperty.getPersistentEntityType(AbstractPersistentProperty.java:125)




at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:469)




at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:427)




at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:572)




at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:295)




at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:470)




at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:427)




at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:572)




at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:295)




at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:470)




at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:427)




at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:572)




at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:295)




at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.createAndRegisterProperty(AbstractMappingContext.java:470)




at org.springframework.data.mapping.context.AbstractMappingContext$PersistentPropertyCreator.doWith(AbstractMappingContext.java:427)




at org.springframework.util.ReflectionUtils.doWithFields(ReflectionUtils.java:572)




at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:295)




at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:181)




at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:141)




at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:67)




at org.springframework.data.mongodb.core.MongoTemplate.getPersistentEntity(MongoTemplate.java:1831)




at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:829)






I got the same issues on both spring-data-mongodb-1.5.0-RELEASE.jar and spring-data-mongodb-1.5.2-RELEASE.jar.
Below is some of my investigation, maybe helpful.
It seems something unsafe in spring-data-commons-1.8.0-RELEASE.jar and spring-data-commons-1.8.2-RELEASE.jar.
It seems that TreeMap has something different to HashMap, such as private transient EntrySet entrySet = null;, which causes returning empty Type array to emit ArrayIndexOutOfBoundsException.
May I know why the author treats Map as normal entity Type to traverse every field inside? Normally Map and List only used as container.
</description>
			<version>1.8.2 (Dijkstra SR2)</version>
			<fixedVersion>1.8.4 (Dijkstra SR4), 1.9 GA (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.model.AbstractPersistentPropertyUnitTests.java</file>
			<file type="M">org.springframework.data.mapping.model.AbstractPersistentProperty.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">588</link>
		</links>
	</bug>
	<bug id="566" opendate="2014-08-21 01:12:31" fixdate="2014-08-26 04:58:52" resolution="Fixed">
		<buginformation>
			<summary>Cannot sort on field operation with QueryDSL</summary>
			<description>Hello, it seems sorting on field operation (like yearMonth() on a date) with querydsl is not working since 1.7.3. (no problem with 1.6.5)






QInvoice invoice = QInvoice.invoice;




Iterable&amp;lt;Invoice&amp;gt; all = invoiceRepository.findAll(invoice.exclTaxAmount.gt(0), invoice.issueDate.yearMonth().asc());






Exception stack trace:






java.lang.ClassCastException: com.mysema.query.types.OperationImpl cannot be cast to com.mysema.query.types.Path




	at org.springframework.data.querydsl.QSort.toOrder(QSort.java:89)




	at org.springframework.data.querydsl.QSort.toOrders(QSort.java:72)




	at org.springframework.data.querydsl.QSort.&amp;lt;init&amp;gt;(QSort.java:55)




	at org.springframework.data.querydsl.QSort.&amp;lt;init&amp;gt;(QSort.java:46)




	at org.springframework.data.jpa.repository.support.QueryDslJpaRepository.findAll(QueryDslJpaRepository.java:108)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:442)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:427)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:381)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:98)




	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:262)




	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:95)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:136)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.data.jpa.repository.support.CrudMethodMetadataPostProcessor$CrudMethodMetadataPopulatingMethodIntercceptor.invoke(CrudMethodMetadataPostProcessor.java:111)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207)




	at com.sun.proxy.$Proxy119.findAll(Unknown Source)






FIY, following is working






JPAQuery query = new JPAQuery(entityManager);




QInvoice invoice = QInvoice.invoice;




SearchResults&amp;lt;Invoice&amp;gt; results = query.from(invoice).where(invoice.exclTaxAmount.gt(0)).orderBy(invoice.issueDate.yearMonth().asc()).listResults(invoice);






Thanks</description>
			<version>1.7.3 (Codd SR3)</version>
			<fixedVersion>1.8.4 (Dijkstra SR4), 1.9 GA (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.querydsl.User.java</file>
			<file type="M">org.springframework.data.querydsl.QSort.java</file>
			<file type="M">org.springframework.data.querydsl.QSortUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">596</link>
		</links>
	</bug>
	<bug id="565" opendate="2014-08-20 11:48:50" fixdate="2014-09-01 04:34:20" resolution="Fixed">
		<buginformation>
			<summary>Custom repository implementations are not picked up when using CDI</summary>
			<description>Custom repository implementations cannot be resolved when using CDI 1.0 because BeanManager.getBeans(... does not provide any beans during AfterBeanDiscovery event.
Solution: Shift the lookup from AfterBeanDiscovery to the the actual bean creation</description>
			<version>1.9 RC1 (Evans)</version>
			<fixedVersion>1.9 GA (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.cdi.CdiRepositoryBean.java</file>
			<file type="M">org.springframework.data.repository.cdi.DummyCdiExtension.java</file>
			<file type="M">org.springframework.data.repository.cdi.CdiRepositoryExtensionSupport.java</file>
		</fixedFiles>
	</bug>
	<bug id="583" opendate="2014-10-21 15:54:29" fixdate="2014-10-29 01:45:22" resolution="Fixed">
		<buginformation>
			<summary>DomainClassConverter#matches should return false when source- and targetType are equal</summary>
			<description>I ran into a very peculiar issue today, that was hard to reproduce. In a Spring-MVC app that uses Spring Data JPA and has a DomainClassConverter registered I have a controller method that takes some entity as a model attribute parameter. The entity has a String ID field.
What happens now in some cases (haven&amp;amp;apos;t identified the exact circumstances) is that the entity instance, which is initially created and bound correctly, is ran through the conversion service, which finds the DomainClassConverter which will happily map the entity instance onto another instance of the same type by mapping the instance to a String using the standard ObjectToStringConverter and treating the result as the primary key of the entity type... This results in always getting null passed in as the parameter for the controller method.
Obviously the DomainClassConverter should not be used at all in this scenario.
Fortunately I was able to reproduce the scenario in a simple app (see attachment). It&amp;amp;apos;s really weird: if you remove the extra non-default constructor of the Entity class, for example, you can no longer reproduce the error. Also, if you comment out the spring.version property in the pom, thereby using 4.0.7.RELEASE instead of 4.1.1.RELEASE, you can also not reproduce the error. This might therefore be related to a recent change in Spring Core as well.
Anyways, there is an easy fix for this issue: the DomainClassConvert#matches method should first check if the source- and targetType are equal and if so, return false: I&amp;amp;apos;d say that no domain class can have itself as its key type and thus it should never attempt to convert these types. 
If you manage to pinpoint the exact cause you might find that there&amp;amp;apos;s a better solution, but this is how I worked around this issue for now.</description>
			<version>1.8.4 (Dijkstra SR4)</version>
			<fixedVersion>1.9.1 (Evans SR1), 1.10 M1 (Fowler), 1.8.5 (Dijkstra SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.support.DomainClassConverterUnitTests.java</file>
			<file type="M">org.springframework.data.repository.support.DomainClassConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="590" opendate="2014-11-05 10:29:49" fixdate="2014-11-14 00:51:49" resolution="Fixed">
		<buginformation>
			<summary>Bug in generics detection for multiply nested generic types</summary>
			<description>It fails guess the concrete class of a two level embedded document in a concrete scenario using abstract class with generics.
The reference git repository, reproduces this error running unit tests. It also downloads and runs a local MongoDB server using https://github.com/jirutka/embedmongo-Spring plugin.
</description>
			<version>1.9.1 (Evans SR1)</version>
			<fixedVersion>1.10 M1 (Fowler), 1.8.5 (Dijkstra SR5), 1.9.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.util.ClassTypeInformation.java</file>
			<file type="M">org.springframework.data.util.ParentTypeAwareTypeInformation.java</file>
			<file type="M">org.springframework.data.util.TypeDiscoverer.java</file>
			<file type="M">org.springframework.data.util.TypeDiscovererUnitTests.java</file>
			<file type="M">org.springframework.data.util.ParameterizedTypeUnitTests.java</file>
			<file type="M">org.springframework.data.util.TypeVariableTypeInformation.java</file>
			<file type="M">org.springframework.data.util.ClassTypeInformationUnitTests.java</file>
			<file type="M">org.springframework.data.util.ParameterizedTypeInformation.java</file>
			<file type="M">org.springframework.data.util.GenericArrayTypeInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="597" opendate="2014-11-18 17:04:05" fixdate="2014-11-19 09:26:42" resolution="Fixed">
		<buginformation>
			<summary>BasicPersistentEntity.getPropertyAccessor for target bean does not properly handle inheritance when PersistentEntity instances are interface or abstract class based</summary>
			<description>The BasicPersistentEntity&amp;amp;apos;s getPropertyAccessor(..) method fails to take into account &amp;amp;apos;target&amp;amp;apos; beans that implement the specified type of the PersistentEntity.  The specified type may be an interface or a abstract base class of the implementing domain object entity.
Spring Data GemFire, in particular, added support for interface-based PersistentEntity definitions in SGF-260, where the entity meta-data (such as @Id comes from an interface definition of the entity.</description>
			<version>1.10 M1 (Fowler)</version>
			<fixedVersion>1.10 M1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.model.BasicPersistentEntity.java</file>
			<file type="M">org.springframework.data.mapping.model.BasicPersistentEntityUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="594" opendate="2014-11-14 03:39:52" fixdate="2014-11-19 09:32:12" resolution="Fixed">
		<buginformation>
			<summary>Strange generics behaviour for multiply nested generic types</summary>
			<description>This behaviour was incorrectly reported reopening DATACMNS-590 by me, sorry about that 
After the resolution of DATACMNS-590, we found another strange behaviour using Spring Data MongoDB, but only disabling the default type mapper resolution, which resolves the class type to map using an attribute. See github repo and run unit tests.
I simplify a lot the domain model and use the generics in the minimal expression as possible to reproduce this, and I think now is much easier to understand.
Take a close look at:

CustomerNonTypedRepositoryTest.testFindOne
CustomerNonTypedRepositoryTest.testFindOneItem

Retrieving a Customer and navigate to ItemType will lead to a ClassCastException due the lost of generic type. But if we retrieve an Item and navigate to ItemType is ok.
I know this is a corner case, and as said in DATACMNS-590 this will probably lead into a &amp;amp;apos;work-as-designed&amp;amp;apos; resolution.
We can&amp;amp;apos;t use the default type, because we are not using Spring to populate the database, but we think we can workaround this providing a custom type mapper.
Thank you </description>
			<version>1.9.1 (Evans SR1)</version>
			<fixedVersion>1.10 M1 (Fowler), 1.8.5 (Dijkstra SR5), 1.9.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.util.ClassTypeInformation.java</file>
			<file type="M">org.springframework.data.util.TypeDiscoverer.java</file>
			<file type="M">org.springframework.data.util.ClassTypeInformationUnitTests.java</file>
			<file type="M">org.springframework.data.util.GenericArrayTypeInformation.java</file>
			<file type="M">org.springframework.data.util.ParameterizedTypeInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="609" opendate="2014-11-30 07:31:51" fixdate="2014-12-01 01:35:19" resolution="Fixed">
		<buginformation>
			<summary>Multiple usage of repository setup means (XML or annotation) creates multiple bean definitions for RepositoryInterfaceAwareBeanPostProcessor</summary>
			<description>Apparently every time the tag jpa:repositories is used in XML files, a new instance of RepositoryInterfaceAwareBeanPostProcessor is created and registered with the bean factory. This is mainly a performance problem because predictBeanType()-method is then called N times for every relevant bean. This can easily be reproduced with the version 51d1c5d of git@github.com:spring-projects/spring-data-jpa-examples.git by adding an extra stanza like &amp;lt;jpa:repositories base-package="org.springframework.dummy" /&amp;gt; to simple-repository-context.xml and running XmlConfigCachingRepositoryTests.</description>
			<version>1.9.1 (Evans SR1)</version>
			<fixedVersion>1.10 M1 (Fowler), 1.9.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport.java</file>
			<file type="M">org.springframework.data.repository.config.RepositoryConfigurationExtensionSupportUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">218</link>
			<link type="Relate" description="relates to">611</link>
		</links>
	</bug>
	<bug id="616" opendate="2014-12-17 02:25:54" fixdate="2014-12-17 07:20:00" resolution="Fixed">
		<buginformation>
			<summary>AnnotationRevisionMetadata can&amp;apos;t access private fields</summary>
			<description>Trying to use a custom Envers revision class:






@Entity




@RevisionEntity(ExtendedRevisionListener.class)




@Table(name = "revinfo")




public class ExtendedRevision implements Serializable {









	@Id




	@GeneratedValue




	@Column(name = "REV")




	@RevisionNumber




	private Integer id;









	@RevisionTimestamp




	@Temporal(TemporalType.TIMESTAMP)




	@Column(name = "REVTSTMP", nullable = false)




	private Date date;









	@Column(nullable = false, length = 15)




	private String username;









	public Integer getId() {




		return id;




	}









	public Date getDate() {




		return date;




	}









	public String getUsername() {




		return username;




	}









	public void setUsername(String username) {




		this.username = username;




	}






triggers this error:






java.lang.IllegalStateException: Could not access method: Class org.springframework.util.ReflectionUtils can not access a member of class ExtendedRevision with modifiers "private"




	at org.springframework.util.ReflectionUtils.handleReflectionException(ReflectionUtils.java:262)




	at org.springframework.util.ReflectionUtils.getField(ReflectionUtils.java:132)




	at org.springframework.data.util.AnnotationDetectionFieldCallback.getValue(AnnotationDetectionFieldCallback.java:82)




	at org.springframework.data.history.AnnotationRevisionMetadata.&amp;lt;init&amp;gt;(AnnotationRevisionMetadata.java:54)






I assume the fields have to be made accessible from the field callback.</description>
			<version>1.9.1 (Evans SR1)</version>
			<fixedVersion>1.8.5 (Dijkstra SR5), 1.9.2 (Evans SR2), 1.10 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.util.AnnotationDetectionFieldCallback.java</file>
		</fixedFiles>
	</bug>
	<bug id="640" opendate="2015-02-03 23:29:21" fixdate="2015-02-04 02:45:26" resolution="Fixed">
		<buginformation>
			<summary>Possible NullPointerException on PageableHandlerMethodArgumentResolver when fallbackPageable is null</summary>
			<description>If {fallbackPageable}} is set to null, but a specific page is requested without a valid sort parameter, a NullPointerException is thrown as the resolver tries to fetch the default sort from the fallbackPageable in the end (if no sort is determined yet). Case recap: page and size are given, sort is not.
Problem situated on line 249 in 1.9.1 source of PageableHandlerMethodArgumentResolver. As far as I can tell possible issue is still there in recent code base.
This is in fact blocking in situations where no valid sort properties are available. There is also no valid workaround to have the SortHandlerMethodArgumentResolver return an "empty" (but not null) sort instance.
Apart from the bug, possible improvement:
My case is as follows: for some controllers the paging settings are stored on the user profile.  If no actual pageable is defined, use the default from the user profile.  
With the current code base there appears to be no way to determine if the pageable you receive is the actual fallback pageable. Since new pageable instances get created, you cannot distinguish between the fallback and a manually selected version with the same parameters. Null would be the only - and acceptable - solution for this, but then you are forced to configure this globally on the resolver level.  An improvement could also be to have a null default pageable configurable on controller parameter.</description>
			<version>1.9.2 (Evans SR2)</version>
			<fixedVersion>1.10 RC1 (Fowler), 1.9.3 (Evans SR3), 1.8.6 (Dijkstra SR6)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="663" opendate="2015-03-27 04:32:06" fixdate="2015-03-27 04:54:23" resolution="Fixed">
		<buginformation>
			<summary>Typo in method in BytecodeGeneratingEntityInstantiator</summary>
			<description></description>
			<version>1.10 GA (Fowler)</version>
			<fixedVersion>1.11 M1 (Gosling), 1.10.1 (Fowler SR1)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.convert.BytecodeGeneratingEntityInstantiator.java</file>
		</fixedFiles>
	</bug>
	<bug id="683" opendate="2015-04-13 05:31:25" fixdate="2015-04-13 08:44:38" resolution="Fixed">
		<buginformation>
			<summary>Enabling Spring Data web support breaks @ModelAttribute binding in Spring MVC</summary>
			<description>Given following Java config class






package be.vdab.web;









import org.springframework.context.annotation.ComponentScan;




import org.springframework.context.annotation.Configuration;




import org.springframework.data.web.config.EnableSpringDataWebSupport;




import org.springframework.web.servlet.config.annotation.EnableWebMvc;




import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;









// enkele imports




@Configuration




@EnableWebMvc




@EnableSpringDataWebSupport




@ComponentScan




public class CreateControllerBeans extends WebMvcConfigurerAdapter {




}






, following Controller class






package be.vdab.web;









import org.springframework.stereotype.Controller;




import org.springframework.web.bind.annotation.ModelAttribute;




import org.springframework.web.bind.annotation.RequestMapping;




import org.springframework.web.bind.annotation.RequestMethod;




import org.springframework.web.servlet.ModelAndView;









import be.vdab.entities.Person;









@Controller




@RequestMapping(value = "/")




public class PersonController {




	private static final String TOEVOEGEN_VIEW = "/WEB-INF/JSP/index.jsp";














	@RequestMapping(method=RequestMethod.GET)




	ModelAndView get() {




		return new ModelAndView(TOEVOEGEN_VIEW).addObject(new Person());




	}




	




	@RequestMapping(method = RequestMethod.POST)




	String post(@ModelAttribute Person person) {




	  if (person == null) {




		  throw new IllegalArgumentException("person IS NULL");




	  }




	  return "redirect:/";




	}



















}






and following JSP






&amp;lt;%@page contentType="text/html" pageEncoding="UTF-8" session="false"%&amp;gt;




&amp;lt;%@taglib prefix="form" uri="http://www.springframework.org/tags/form" %&amp;gt;




&amp;lt;!doctype html&amp;gt;




&amp;lt;html lang="nl"&amp;gt;




&amp;lt;head&amp;gt;




&amp;lt;title&amp;gt;Add person&amp;lt;/title&amp;gt;




&amp;lt;/head&amp;gt;




&amp;lt;body&amp;gt;




&amp;lt;form:form action="" method="post" commandName="person"&amp;gt;




&amp;lt;form:label path="name"&amp;gt;Name:&amp;lt;/form:label&amp;gt;




&amp;lt;form:input path="name" autofocus="true"/&amp;gt;




&amp;lt;input type="submit"&amp;gt;




&amp;lt;/form:form&amp;gt;




&amp;lt;/body&amp;gt;




&amp;lt;/html&amp;gt;






the method post in PersonController throws the InvalidArgumentException because the person parameter is null.
Observation 1:
This worked up to and including spring-data-jpa 1.7.2.RELEASE
Observation 2:
The bug disappears when @EnableSpringDataWebSupport is put in comment in CreateControllerBeans.java
Observation 3:
The bug disappears when @ModelAttribute is put in comment in PersonController.java
You can clone a project that shows the bug from
https://github.com/desmethans/springDataJpaError.git</description>
			<version>1.10 GA (Fowler)</version>
			<fixedVersion>1.11 M1 (Gosling), 1.10.1 (Fowler SR1)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.support.DomainClassConverterUnitTests.java</file>
			<file type="M">org.springframework.data.repository.support.DomainClassConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">711</link>
		</links>
	</bug>
	<bug id="692" opendate="2015-05-11 14:50:15" fixdate="2015-05-13 09:07:26" resolution="Fixed">
		<buginformation>
			<summary>IllegalArgumentExceptions in PageableHandlerMethodArgumentResolver with one-based index parameters</summary>
			<description>When the PageableHandlerMethodArgumentResolver is configured with one-based index parameters:






resolver.setOneIndexedParameters(true);






and a zero or negative page parameter is provided, e.g. ?page=0 or ?page=-1, an IllegalArgumentException is thrown, rather than falling back to the first page.






java.lang.IllegalArgumentException: Page index must not be less than zero!




	at org.springframework.data.domain.AbstractPageRequest.&amp;lt;init&amp;gt;(AbstractPageRequest.java:43) ~[spring-data-commons-1.10.0.RELEASE.jar:na]




	at org.springframework.data.domain.PageRequest.&amp;lt;init&amp;gt;(PageRequest.java:63) ~[spring-data-commons-1.10.0.RELEASE.jar:na]




	at org.springframework.data.web.PageableHandlerMethodArgumentResolver.resolveArgument(PageableHandlerMethodArgumentResolver.java:253) ~[spring-data-commons-1.10.0.RELEASE.jar:na]




	. . .






The page is initially set to the appropriate default page number of 0, but then, one is subtracted from that value, resulting in a negative value, which is passed to the PageRequest constructor, resulting in the IllegalArgumentException:






PageableHandlerMethodArgumentResolver#resolveArgument






int page = StringUtils.hasText(pageString) ? parseAndApplyBoundaries(pageString, 0, Integer.MAX_VALUE)




				- (oneIndexedParameters ? 1 : 0) : defaultOrFallback.getPageNumber();









. . . 









return new PageRequest(page, pageSize, sort);






There may be multiple ways to solve this problem, but one approach could be to validate the lower bound after the page var is initially set, in a similar way as the pageSize:






PageableHandlerMethodArgumentResolver#resolveArgument






// Limit lower bound




pageSize = pageSize &amp;lt; 1 ? defaultOrFallback.getPageSize() : pageSize;




// TODO add similar lower bound limit for page param as well...





</description>
			<version>1.10 GA (Fowler)</version>
			<fixedVersion>1.11 M1 (Gosling), 1.9.3 (Evans SR3), 1.10.1 (Fowler SR1), 1.8.6 (Dijkstra SR6)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="695" opendate="2015-05-13 09:08:15" fixdate="2015-05-13 09:37:39" resolution="Fixed">
		<buginformation>
			<summary>Potential NullPointerException in AbstractMappingContext</summary>
			<description>We found the reported issue upgrading Spring Data MongoDB library from 1.3.5.RELEASE to 1.5.5.RELEASE. The issue is triggered querying a nested generic field qualified with a custom class (not primitive). Following snippet shows the nested field we are trying to query:






public class External{




 ..




 private Optional&amp;lt;Internal&amp;gt; field = new Optional&amp;lt;Internal&amp;gt;();




 ..




}






The call to mongoOperations throws a NullPointerException originating from AbstractMappingContext. It is a Spring Data Commons class and we noticed that the issue starts from version 1.7.2.RELEASE of this library, just after commit 02046da.</description>
			<version>1.8.5 (Dijkstra SR5)</version>
			<fixedVersion>1.11 M1 (Gosling), 1.9.3 (Evans SR3), 1.10.1 (Fowler SR1), 1.8.6 (Dijkstra SR6)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContextUnitTests.java</file>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="697" opendate="2015-05-15 11:00:52" fixdate="2015-05-16 09:58:38" resolution="Fixed">
		<buginformation>
			<summary>Field-local generics information not honored</summary>
			<description>In my project, we have an entity called NormalizedProfile, which is a huge collection of generic ListField s. Each listField is a list of Value s plus some metadata. And Value is a (well) single "value" plus some metadata. In our case, atomic "value" is either primitive wrapper, Object or Enum, never a collection (in case it is relevant).
Value&amp;lt;T&amp;gt; gets its generic type from ListField&amp;lt;T&amp;gt; it is enclosed in. Nothing fancy.
In addition to standard java SpringDataMongo config, we customise MappingMongoConverter to stop save and use "_class" field. No polymorphic behaviour is needed in our case, so why not.
Problem is with Object- and Enum- generalized ListField s. After they are saved, they never read as a real object and returned as LHM instead. When I use java.util.List instead of our custom structure, everything works fine.
Please see attached minimal test - j.u.List&amp;lt;Education&amp;gt; testcase succeeds and ListField&amp;lt;Education&amp;gt; fails.</description>
			<version>1.10 GA (Fowler)</version>
			<fixedVersion>1.11 M1 (Gosling), 1.9.3 (Evans SR3), 1.10.1 (Fowler SR1), 1.8.6 (Dijkstra SR6)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.util.TypeDiscoverer.java</file>
			<file type="M">org.springframework.data.util.ParameterizedTypeUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="702" opendate="2015-05-20 06:14:36" fixdate="2015-05-20 06:24:25" resolution="Duplicate">
		<buginformation>
			<summary>QueryDSL starting from version 4.0.0 is not compatible due to package rename</summary>
			<description>Packages of QueryDSL have been renamed from com.mysema.query.* to com.querydsl.* . QueryDslPredicateExecutor depends on the old package names, which makes latest QueryDSL unusable with Spring Data.</description>
			<version>1.10 GA (Fowler)</version>
			<fixedVersion></fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.querydsl.SimpleEntityPathResolverUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.SimpleEntityPathResolver.java</file>
			<file type="M">org.springframework.data.querydsl.QueryDslUtils.java</file>
			<file type="M">org.springframework.data.querydsl.User.java</file>
			<file type="M">org.springframework.data.querydsl.EntityPathResolver.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindingsFactoryUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.QueryDslPredicateExecutor.java</file>
			<file type="M">org.springframework.data.querydsl.QSortUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslPredicateBuilder.java</file>
			<file type="M">org.springframework.data.web.config.QuerydslWebConfiguration.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindingsUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslDefaultBinding.java</file>
			<file type="M">org.springframework.data.querydsl.binding.SingleValueBinding.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslPredicateBuilderUnitTests.java</file>
			<file type="M">org.springframework.data.web.querydsl.QuerydslPredicateArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.QPageRequestUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindings.java</file>
			<file type="M">org.springframework.data.web.querydsl.QuerydslPredicateArgumentResolver.java</file>
			<file type="M">org.springframework.data.querydsl.QPageRequest.java</file>
			<file type="M">org.springframework.data.querydsl.QSort.java</file>
			<file type="M">org.springframework.data.querydsl.QuerydslRepositoryInvokerAdapter.java</file>
			<file type="M">org.springframework.data.querydsl.QuerydslRepositoryInvokerAdapterUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindingsFactory.java</file>
			<file type="M">org.springframework.data.querydsl.binding.MultiValueBinding.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBinderCustomizer.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslDefaultBindingUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.Address.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">670</link>
		</links>
	</bug>
	<bug id="705" opendate="2015-05-31 12:48:24" fixdate="2015-05-31 22:53:22" resolution="Duplicate">
		<buginformation>
			<summary>Port to querydsl 4.0.0</summary>
			<description>Port to querydsl 4.0.0</description>
			<version>1.10 GA (Fowler)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.querydsl.SimpleEntityPathResolverUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.SimpleEntityPathResolver.java</file>
			<file type="M">org.springframework.data.querydsl.QueryDslUtils.java</file>
			<file type="M">org.springframework.data.querydsl.User.java</file>
			<file type="M">org.springframework.data.querydsl.EntityPathResolver.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindingsFactoryUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.QueryDslPredicateExecutor.java</file>
			<file type="M">org.springframework.data.querydsl.QSortUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslPredicateBuilder.java</file>
			<file type="M">org.springframework.data.web.config.QuerydslWebConfiguration.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindingsUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslDefaultBinding.java</file>
			<file type="M">org.springframework.data.querydsl.binding.SingleValueBinding.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslPredicateBuilderUnitTests.java</file>
			<file type="M">org.springframework.data.web.querydsl.QuerydslPredicateArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.QPageRequestUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindings.java</file>
			<file type="M">org.springframework.data.web.querydsl.QuerydslPredicateArgumentResolver.java</file>
			<file type="M">org.springframework.data.querydsl.QPageRequest.java</file>
			<file type="M">org.springframework.data.querydsl.QSort.java</file>
			<file type="M">org.springframework.data.querydsl.QuerydslRepositoryInvokerAdapter.java</file>
			<file type="M">org.springframework.data.querydsl.QuerydslRepositoryInvokerAdapterUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindingsFactory.java</file>
			<file type="M">org.springframework.data.querydsl.binding.MultiValueBinding.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBinderCustomizer.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslDefaultBindingUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.Address.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">670</link>
		</links>
	</bug>
	<bug id="711" opendate="2015-06-09 13:13:09" fixdate="2015-06-14 02:28:40" resolution="Duplicate">
		<buginformation>
			<summary>DomainClassConverter triggered unnecessarily</summary>
			<description>DomainClassConverter wrongfully triggers on form submits. I have a controller, which accepts a filled out Entity as a form 
@RequestMapping(value="entity/edit", method=RequestMethod.POST)
public String modifyEntity(@Validated(Edit.class) Entity entity){
MVC builds a Detached Entity, and does a check if a conversion via the ConversionService must take place. The conversion goes from com.mycompany.myproject.domain.Entity to @Validated com.mycompany.myproject.domain.Entity. It goes through every registered converter to see if someone wishes to perform this conversion. So far so good.
Now DomainClassConverter.ToIdConverter checks if it can convert Entity to @Validated Entity. It agrees that it can not, however it then reduces the source entity to its ID, and begins a brand new search by the converters to see if Entity&amp;amp;apos;s String id can be converted to Entity. Of course it finds  the DomainClassConverter.ToEntityConverter. 
Thus the DomainClassConvert.ToIdConverter is found as a legitimate converter for Entity-&amp;gt;@Validated Entity. When it is asked to do this convertion, it doesn&amp;amp;apos;t match them as equals, being as they have different annotations, and actually invokes DomainClassConvert.ToEntityConverter which does a callback to the database etc. etc. etc.
There are of course two problems with this. Most importantly, it discards any of the changes. Secondly, since my Entity has a collection, and the DomainClassConverter loads the Entity in its own transaction, which is commited and closed by the time the Controller is called, any work on the collection results in a org.hibernate.LazyInitializationException. 
Basically, I am now disabling DomainClassConverter, until this is fixed. I think the way to fix it, is to do more intelligent TypeDescriptor comparisons in the convert method. Alternatively, some way to disable DomainClassConverter from activating on a specific controller, or just only focusing on IdToEntity, and never EntityToId</description>
			<version>1.10 GA (Fowler)</version>
			<fixedVersion>1.10.1 (Fowler SR1)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.support.DomainClassConverterUnitTests.java</file>
			<file type="M">org.springframework.data.repository.support.DomainClassConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">683</link>
		</links>
	</bug>
	<bug id="648" opendate="2015-02-17 05:26:35" fixdate="2015-06-15 09:12:15" resolution="Fixed">
		<buginformation>
			<summary>o.s.d.r.q.Parameters prevents custom classloader from being garbage collected</summary>
			<description>Parameters creates a static DefaultParameterNameDiscoverer, wich adds a LocalVariableTableParameterNameDiscoverer to its list of ParameterNameDiscoverers.
This LVTPND holds a Map with a class as a key.
As I said, I&amp;amp;apos;m using a custom classloaders for a kind of plugin-based application.
The problem is, since Repository-subclasses stay in the LVTPND&amp;amp;apos;s parameterNamesCache, the custom classloader who loaded the Repository can never be GC&amp;amp;apos;ed.
Im not sure about if this issue should be fixed in Spring Data Commons or in LocalVariableTableParameterNameDiscoverer by using a WeakHashMap for parameterNamesCache.
Regards
Matthias</description>
			<version>1.9.2 (Evans SR2)</version>
			<fixedVersion>1.9.3 (Evans SR3), 1.10.1 (Fowler SR1), 1.8.6 (Dijkstra SR6), 1.11 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.query.Parameters.java</file>
		</fixedFiles>
	</bug>
	<bug id="715" opendate="2015-06-10 01:29:16" fixdate="2015-06-17 07:36:14" resolution="Fixed">
		<buginformation>
			<summary>@Transactional customizations not applied correctly on redeclared methods</summary>
			<description>





public interface RepositoryExample extends JpaRepository&amp;lt;User, String&amp;gt;{




	




        // This Query&amp;amp;apos;s timeout just works 




	@Query("FROM User")




	@Transactional(timeout = 10,propagation = Propagation.REQUIRED)




	public List&amp;lt;User&amp;gt; findAll2();




	




        //The query below - timeout doesn&amp;amp;apos;t work , the @Transactional timeout is not being applied




        // Although in the documentation it shows it suppose to work exactly as below 




        @Override	




	@Transactional(timeout = 10,propagation = Propagation.REQUIRED)




	public List&amp;lt;User&amp;gt; findAll();




}






Recommendation: In order to debug it put breakpoint in  EntityManagerFactoryUtils.applyTransactionTimeout</description>
			<version>1.8.5 (Dijkstra SR5)</version>
			<fixedVersion>1.9.3 (Evans SR3), 1.10.1 (Fowler SR1), 1.8.6 (Dijkstra SR6), 1.11 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.TransactionalRepositoryProxyPostProcessor.java</file>
			<file type="M">org.springframework.data.repository.core.support.TransactionRepositoryProxyPostProcessorUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.RepositoryFactorySupportUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.RepositoryFactorySupport.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">13109</link>
			<link type="Duplicate" description="is duplicated by">755</link>
			<link type="Relate" description="relates to">778</link>
			<link type="Relate" description="relates to">732</link>
		</links>
	</bug>
	<bug id="717" opendate="2015-06-18 08:32:08" fixdate="2015-06-18 08:55:28" resolution="Fixed">
		<buginformation>
			<summary>AnnotatedTypeScanner does not use context classloader for loading found types</summary>
			<description></description>
			<version>1.8.5 (Dijkstra SR5)</version>
			<fixedVersion>1.9.3 (Evans SR3), 1.10.1 (Fowler SR1), 1.8.6 (Dijkstra SR6), 1.11 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.util.AnnotatedTypeScanner.java</file>
		</fixedFiles>
	</bug>
	<bug id="719" opendate="2015-06-22 01:10:57" fixdate="2015-06-22 02:46:03" resolution="Fixed">
		<buginformation>
			<summary>Version fails to parse input string with non-numerical suffix</summary>
			<description></description>
			<version>1.8.5 (Dijkstra SR5)</version>
			<fixedVersion>1.9.3 (Evans SR3), 1.10.1 (Fowler SR1), 1.8.6 (Dijkstra SR6), 1.11 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.util.VersionUnitTests.java</file>
			<file type="M">org.springframework.data.util.Version.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">496</link>
		</links>
	</bug>
	<bug id="720" opendate="2015-06-22 08:06:02" fixdate="2015-06-24 11:08:14" resolution="Fixed">
		<buginformation>
			<summary>Explicit transaction configuration is not considered if default transactions are disabled</summary>
			<description></description>
			<version>1.10 GA (Fowler)</version>
			<fixedVersion>1.10.1 (Fowler SR1), 1.11 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.TransactionalRepositoryFactoryBeanSupport.java</file>
			<file type="M">org.springframework.data.repository.core.support.TransactionalRepositoryProxyPostProcessor.java</file>
			<file type="M">org.springframework.data.repository.core.support.TransactionRepositoryFactoryBeanSupportUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.TransactionRepositoryProxyPostProcessorUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">656</link>
		</links>
	</bug>
	<bug id="722" opendate="2015-06-25 05:01:24" fixdate="2015-06-25 05:32:23" resolution="Fixed">
		<buginformation>
			<summary>ProxyProjectionFactory does not handle arrays correctly</summary>
			<description>The ProxyProjectionFactory currently does not handle primitive and non-primitive arrays correctly.</description>
			<version>1.10 GA (Fowler)</version>
			<fixedVersion>1.10.1 (Fowler SR1), 1.11 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.projection.ProxyProjectionFactoryUnitTests.java</file>
			<file type="M">org.springframework.data.projection.ProjectingMethodInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="733" opendate="2015-07-19 12:04:50" fixdate="2015-07-21 06:53:39" resolution="Fixed">
		<buginformation>
			<summary>PreferredConstructorDiscoverer prevents custom classloader from being garbage collected</summary>
			<description>Hi,
the reason for this issue is similar/related to the one described in DATACMNS-648:
PreferredConstructorDiscoverer creates a static DefaultParameterNameDiscoverer, wich adds a LocalVariableTableParameterNameDiscoverer to parameterNameDiscoverers. This LVTPND holds a Map with a class as a key.
As I said, I&amp;amp;apos;m using a custom classloaders for a kind of plugin-based application.
The problem is, since entity-classes stay in the LVTPND&amp;amp;apos;s parameterNamesCache, the custom classloader who loaded the entity class can never be GC&amp;amp;apos;ed.
Also note that MethodParameters could potentially cause the same problems because of the static DefaultParameterNameDiscoverer
Regards
Matthias</description>
			<version>1.9.3 (Evans SR3)</version>
			<fixedVersion>1.10.2 (Fowler SR2), 1.11 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.model.PreferredConstructorDiscoverer.java</file>
			<file type="M">org.springframework.data.repository.query.Parameters.java</file>
			<file type="M">org.springframework.data.repository.support.MethodParameters.java</file>
		</fixedFiles>
	</bug>
	<bug id="736" opendate="2015-07-21 07:43:46" fixdate="2015-07-21 11:13:04" resolution="Fixed">
		<buginformation>
			<summary>Invalid error message in PointFormatter</summary>
			<description>It reports it&amp;amp;apos;s expecting a semicolon but actually expects a comma.</description>
			<version>1.10.1 (Fowler SR1)</version>
			<fixedVersion>1.10.2 (Fowler SR2), 1.11 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.geo.format.DistanceFormatterUnitTests.java</file>
			<file type="M">org.springframework.data.geo.format.PointFormatterUnitTests.java</file>
			<file type="M">org.springframework.data.geo.format.PointFormatter.java</file>
		</fixedFiles>
	</bug>
	<bug id="748" opendate="2015-08-08 00:23:11" fixdate="2015-08-08 02:11:14" resolution="Fixed">
		<buginformation>
			<summary>Spring version check in QueryExecutionConverters might fail</summary>
			<description>With the latest Gosling RC I&amp;amp;apos;m intermittently seeing the following Exceptions on deployment. Usually a consecutive deployment will be successful.






org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;entryDao&amp;amp;apos;: Invocation of init method failed; nested exception is java.lang.ExceptionInInitializerError




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1578) ~[spring-beans-4.2.0.RELEASE.jar:na]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:545) ~[spring-beans-4.2.0.RELEASE.jar:na]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482) ~[spring-beans-4.2.0.RELEASE.jar:na]




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:305) ~[spring-beans-4.2.0.RELEASE.jar:na]




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.2.0.RELEASE.jar:na]




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:301) ~[spring-beans-4.2.0.RELEASE.jar:na]




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:196) ~[spring-beans-4.2.0.RELEASE.jar:na]




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1145) ~[spring-beans-4.2.0.RELEASE.jar:na]




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1069) ~[spring-beans-4.2.0.RELEASE.jar:na]




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:967) ~[spring-beans-4.2.0.RELEASE.jar:na]




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:543) ~[spring-beans-4.2.0.RELEASE.jar:na]




	... 37 common frames omitted




Caused by: java.lang.ExceptionInInitializerError: null




	at org.springframework.data.repository.core.support.QueryExecutionResultHandler.&amp;lt;init&amp;gt;(QueryExecutionResultHandler.java:41) ~[spring-data-commons-1.11.0.RC1.jar:na]




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.&amp;lt;init&amp;gt;(RepositoryFactorySupport.java:383) ~[spring-data-commons-1.11.0.RC1.jar:na]




	at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:203) ~[spring-data-commons-1.11.0.RC1.jar:na]




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.initAndReturn(RepositoryFactoryBeanSupport.java:251) ~[spring-data-commons-1.11.0.RC1.jar:na]




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.afterPropertiesSet(RepositoryFactoryBeanSupport.java:237) ~[spring-data-commons-1.11.0.RC1.jar:na]




	at org.springframework.data.jpa.repository.support.JpaRepositoryFactoryBean.afterPropertiesSet(JpaRepositoryFactoryBean.java:92) ~[spring-data-jpa-1.9.0.RC1.jar:na]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1637) ~[spring-beans-4.2.0.RELEASE.jar:na]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1574) ~[spring-beans-4.2.0.RELEASE.jar:na]




	... 47 common frames omitted




Caused by: java.lang.IllegalArgumentException: [Assertion failed] - this String argument must have text; it must not be null, empty, or blank




	at org.springframework.util.Assert.hasText(Assert.java:168) ~[spring-core-4.2.0.RELEASE.jar:4.2.0.RELEASE]




	at org.springframework.util.Assert.hasText(Assert.java:181) ~[spring-core-4.2.0.RELEASE.jar:4.2.0.RELEASE]




	at org.springframework.data.util.Version.parse(Version.java:67) ~[spring-data-commons-1.11.0.RC1.jar:na]




	at org.springframework.data.repository.util.QueryExecutionConverters.&amp;lt;clinit&amp;gt;(QueryExecutionConverters.java:47) ~[spring-data-commons-1.11.0.RC1.jar:na]




	... 55 common frames omitted






Own analysis:
Commit in question: https://github.com/spring-projects/spring-data-commons/commit/e0dafd29f4027bd2fe40215c8a916e61bff16740
The usage of org.springframework.core.SpringVersion.getVersion() is unreliable, as already stated in the comment section of said class:






/**




 * Class that exposes the Spring version. Fetches the




 * "Implementation-Version" manifest attribute from the jar file.




 *




 * &amp;lt;p&amp;gt;Note that some ClassLoaders do not expose the package metadata,




 * hence this class might not be able to determine the Spring version




 * in all environments. Consider using a reflection-based check instead:




 * For example, checking for the presence of a specific Spring 2.0




 * method that you intend to call.




 *




 * @author Juergen Hoeller




 * @since 1.1




 */






The code in QueryExecutionConverters private static final Version SPRING_VERSION = Version.parse(SpringVersion.getVersion()); fails to handle null, because Version.parse() has an Assert.hasText() and can&amp;amp;apos;t handle null.
So there are at least two obvious things to consider here: One is the not handling the null case. And the other is the reliance on SpringVersion.getVersion(), which is said to not work in all environments. Or probably in my case has timing issues.</description>
			<version>1.11 RC1 (Gosling)</version>
			<fixedVersion>1.11 GA (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.util.QueryExecutionConverters.java</file>
		</fixedFiles>
	</bug>
	<bug id="750" opendate="2015-08-12 20:05:41" fixdate="2015-08-13 03:50:56" resolution="Fixed">
		<buginformation>
			<summary>Part.extractProperty(String part) invalidly extracts property paths containing keywords</summary>
			<description>I declare a method named findByLeakInfoAuditStateIn(Collection states). When I start up my application, Spring Data throws an exception: 






PropertyReferenceException: No property leak found for type Leak!






LeakInfo is a bean, Leak is not. Then i debug into source, i found source that:






public String extractProperty(String part) {









  String candidate = StringUtils.uncapitalize(part);




  for (String keyword : keywords) {




    if (candidate.endsWith(keyword)) {




      return candidate.substring(0, candidate.indexOf(keyword));




    }




  }




  return candidate;




}






The String.indexOf() method find the first In within LeakInfo. That&amp;amp;apos;s not excepted. May be use String.lastIndexOf() instead?</description>
			<version>1.10.2 (Fowler SR2)</version>
			<fixedVersion>1.11 GA (Gosling), 1.10.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.query.parser.PartTreeUnitTests.java</file>
			<file type="M">org.springframework.data.repository.query.parser.Part.java</file>
		</fixedFiles>
	</bug>
	<bug id="755" opendate="2015-08-18 03:36:20" fixdate="2015-08-18 05:09:15" resolution="Complete">
		<buginformation>
			<summary>Paths without parent are causing IllegalArgumentException in QSort class</summary>
			<description>In version 1.8.x was changed the way property path is resolved in class QSort. There is a private method preparePropertyPath(.), which should return the correct path. But if the parent is null, it returns an empty String and this is probably not correct. For example when I use Querydsl StringPath like this:






QSort sort = new QSort(new OrderSpecifier&amp;lt;&amp;gt;(com.mysema.query.types.Order.ASC, new StringPath("eventTime")));






an IllegalArgumentException is thrown:






java.lang.IllegalArgumentException: Property must not null or empty!




	at org.springframework.data.domain.Sort$Order.&amp;lt;init&amp;gt;(Sort.java:320) ~[spring-data-commons-1.9.3.RELEASE.jar:na]




	at org.springframework.data.domain.Sort$Order.&amp;lt;init&amp;gt;(Sort.java:282) ~[spring-data-commons-1.9.3.RELEASE.jar:na]




	at org.springframework.data.domain.Sort$Order.&amp;lt;init&amp;gt;(Sort.java:304) ~[spring-data-commons-1.9.3.RELEASE.jar:na]




	at org.springframework.data.querydsl.QSort.toOrder(QSort.java:98) ~[spring-data-commons-1.9.3.RELEASE.jar:na]




	at org.springframework.data.querydsl.QSort.toOrders(QSort.java:76) ~[spring-data-commons-1.9.3.RELEASE.jar:na]




	at org.springframework.data.querydsl.QSort.&amp;lt;init&amp;gt;(QSort.java:59) ~[spring-data-commons-1.9.3.RELEASE.jar:na]




	at org.springframework.data.querydsl.QSort.&amp;lt;init&amp;gt;(QSort.java:50) ~[spring-data-commons-1.9.3.RELEASE.jar:na]











In version 1.7.x is it working as expected, no parent is needed. The recursion method preparePropertyPath() should be fixed.</description>
			<version>1.10.2 (Fowler SR2)</version>
			<fixedVersion>1.11 GA (Gosling), 1.10.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.querydsl.QSort.java</file>
			<file type="M">org.springframework.data.querydsl.QSortUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="760" opendate="2015-09-01 07:21:26" fixdate="2015-09-01 10:40:26" resolution="Complete">
		<buginformation>
			<summary>Remove cyclic dependency in querydsl packages</summary>
			<description></description>
			<version>1.11 RC1 (Gosling)</version>
			<fixedVersion>1.11 GA (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.querydsl.QuerydslPredicateArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindingsFactoryUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindingsFactory.java</file>
			<file type="M">org.springframework.data.web.querydsl.QuerydslPredicateArgumentResolver.java</file>
			<file type="D">org.springframework.data.web.querydsl.QuerydslPredicate.java</file>
		</fixedFiles>
	</bug>
	<bug id="761" opendate="2015-09-02 14:08:24" fixdate="2015-09-02 14:17:09" resolution="Fixed">
		<buginformation>
			<summary>PageableHandlerMethodArgumentResolver reduces page size by one if on-indexed parameters are used</summary>
			<description></description>
			<version>1.10.2 (Fowler SR2)</version>
			<fixedVersion>1.11.1 (Gosling SR1), 1.12 M1 (Hopper), 1.10.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolver.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">799</link>
		</links>
	</bug>
	<bug id="763" opendate="2015-09-06 09:28:33" fixdate="2015-09-08 10:26:27" resolution="Fixed">
		<buginformation>
			<summary>Custom repository implementation class not working as stated in the reference documentation</summary>
			<description>When I use spring-data-jpa 1.8.2 , which depends on spring-data-commons-1.10.2.RELEASE , my custom repository implementation works fine :






public class MyRepositoryImpl&amp;lt;T, ID extends Serializable&amp;gt; extends SimpleJpaRepository&amp;lt;T , ID&amp;gt; implements MyRepository&amp;lt;T, ID&amp;gt; {









  protected Logger logger = LoggerFactory.getLogger(getClass());









  private final EntityManager entityManager;









  public MyRepositoryImpl(Class&amp;lt;T&amp;gt; domainClass, EntityManager entityManager) {




    super(domainClass , entityManager);




    this.entityManager = entityManager;




  }




}






But when I upgrade my project to spring-boot 1.3.M5 as project&amp;amp;apos;s parent , it seems it&amp;amp;apos;s depend on spring-data-jpa:jar:1.9.0.RELEASE  , and depend on spring-data-commons:jar:1.11.0.RELEASE .
But my custom repository cannot get injected , throws :






Caused by: java.lang.IllegalStateException: No suitable constructor found on class destiny.MyRepositoryImpl to match the given arguments: [Ljava.lang.Object;@554188ac




	at org.springframework.data.repository.core.support.RepositoryFactorySupport.getTargetRepositoryViaReflection(RepositoryFactorySupport.java:338)






It seems it&amp;amp;apos;s from RepositoryFactorySupport inside spring-data-commons-1.11.0.RELEASE :






	protected final &amp;lt;R&amp;gt; R getTargetRepositoryViaReflection(RepositoryInformation information, Object... constructorArguments) {




    Class baseClass = information.getRepositoryBaseClass();




    Constructor constructor = ReflectionUtils.findConstructor(baseClass, constructorArguments);




    if(constructor == null) {




      throw new IllegalStateException(String.format("No suitable constructor found on %s to match the given arguments: %s", new Object[]{baseClass, constructorArguments}));




    } else {




      return BeanUtils.instantiateClass(constructor, constructorArguments);




    }




  }






There is no such method in spring-data-commons-1.10.2 , but available in spring-data-commons-1.11.0 . Can you check it out ?
Thanks.
BTW , in the 1.9.0.RELEASE document :
http://docs.spring.io/spring-data/jpa/docs/1.9.0.RELEASE/reference/html/#jpa.misc.jpa-context
I cannot find JpaContext in any package ... where is it ?</description>
			<version>1.11 GA (Gosling)</version>
			<fixedVersion>1.11.1 (Gosling SR1), 1.12 M1 (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.RepositoryFactorySupportUnitTests.java</file>
			<file type="M">org.springframework.data.repository.core.support.RepositoryFactorySupport.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">793</link>
		</links>
	</bug>
	<bug id="772" opendate="2015-10-05 16:00:18" fixdate="2015-10-05 16:01:23" resolution="Duplicate">
		<buginformation>
			<summary>Add converter for ZoneId to String and vice versa</summary>
			<description></description>
			<version>1.11 GA (Gosling)</version>
			<fixedVersion>1.12 M1 (Hopper)</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.convert.ThreeTenBackPortConvertersUnitTests.java</file>
			<file type="M">org.springframework.data.convert.Jsr310Converters.java</file>
			<file type="M">org.springframework.data.convert.ThreeTenBackPortConverters.java</file>
			<file type="M">org.springframework.data.convert.Jsr310ConvertersUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">773</link>
		</links>
	</bug>
	<bug id="769" opendate="2015-10-01 15:10:13" fixdate="2015-10-05 16:45:50" resolution="Fixed">
		<buginformation>
			<summary>Cannot create auto-generated @Async method with pagination</summary>
			<description>When I create a repository with asynchronous paging query, I get a BeanCreationException about incompatible return type, which must be Slice, Page or List (see stacktrace.txt).






public interface TRepository extends MongoRepository&amp;lt;T, String&amp;gt; {









    @Async




    CompletableFuture&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; findByUrl(String url, Pageable p); // works neither with Future nor with ListenableFuture




}





</description>
			<version>1.11 GA (Gosling)</version>
			<fixedVersion>1.11.1 (Gosling SR1), 1.12 M1 (Hopper), 1.10.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.util.ClassUtilsUnitTests.java</file>
			<file type="M">org.springframework.data.repository.util.ClassUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="773" opendate="2015-09-25 04:43:18" fixdate="2015-10-05 16:46:04" resolution="Fixed">
		<buginformation>
			<summary>Add support for persisting ZoneId instances out of the box</summary>
			<description>The JSR-310 mapping support can read a simple string (e.g., "US/Central") into a ZoneId field, but when it&amp;amp;apos;s saved, it&amp;amp;apos;s saved as a complex serialized object, with _class: "java.time.ZoneRegion" and all the internal state.
However, the mapper can&amp;amp;apos;t read this saved object, presumably because of the lack of a cooperative constructor; the exception message is






org.springframework.data.mapping.model.MappingException: No property null found on entity class java.time.ZoneRegion to bind constructor parameter to!






I suggest that the ZoneId should be saved as the simple string identifier.</description>
			<version>1.11 GA (Gosling)</version>
			<fixedVersion>1.12 M1 (Hopper)</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.convert.ThreeTenBackPortConvertersUnitTests.java</file>
			<file type="M">org.springframework.data.convert.Jsr310Converters.java</file>
			<file type="M">org.springframework.data.convert.ThreeTenBackPortConverters.java</file>
			<file type="M">org.springframework.data.convert.Jsr310ConvertersUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">772</link>
		</links>
	</bug>
	<bug id="779" opendate="2015-10-22 08:14:51" fixdate="2015-10-22 09:56:26" resolution="Fixed">
		<buginformation>
			<summary>Fix JavaDoc of constructor of QuerydslPredicateBuilder</summary>
			<description></description>
			<version>1.11 GA (Gosling)</version>
			<fixedVersion>1.11.1 (Gosling SR1), 1.12 M1 (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslPredicateBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="670" opendate="2015-03-30 06:01:54" fixdate="2015-11-17 13:12:10" resolution="Fixed">
		<buginformation>
			<summary>Add support for Querydsl 4</summary>
			<description></description>
			<version>1.10 GA (Fowler)</version>
			<fixedVersion>1.12 M1 (Hopper)</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.querydsl.SimpleEntityPathResolverUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.SimpleEntityPathResolver.java</file>
			<file type="M">org.springframework.data.querydsl.QueryDslUtils.java</file>
			<file type="M">org.springframework.data.querydsl.User.java</file>
			<file type="M">org.springframework.data.querydsl.EntityPathResolver.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindingsFactoryUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.QueryDslPredicateExecutor.java</file>
			<file type="M">org.springframework.data.querydsl.QSortUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslPredicateBuilder.java</file>
			<file type="M">org.springframework.data.web.config.QuerydslWebConfiguration.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindingsUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslDefaultBinding.java</file>
			<file type="M">org.springframework.data.querydsl.binding.SingleValueBinding.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslPredicateBuilderUnitTests.java</file>
			<file type="M">org.springframework.data.web.querydsl.QuerydslPredicateArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.QPageRequestUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindings.java</file>
			<file type="M">org.springframework.data.web.querydsl.QuerydslPredicateArgumentResolver.java</file>
			<file type="M">org.springframework.data.querydsl.QPageRequest.java</file>
			<file type="M">org.springframework.data.querydsl.QSort.java</file>
			<file type="M">org.springframework.data.querydsl.QuerydslRepositoryInvokerAdapter.java</file>
			<file type="M">org.springframework.data.querydsl.QuerydslRepositoryInvokerAdapterUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindingsFactory.java</file>
			<file type="M">org.springframework.data.querydsl.binding.MultiValueBinding.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBinderCustomizer.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslDefaultBindingUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.Address.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="is depended on by">119</link>
			<link type="Depend" description="is depended on by">708</link>
			<link type="Duplicate" description="is duplicated by">705</link>
			<link type="Duplicate" description="is duplicated by">702</link>
			<link type="Duplicate" description="is duplicated by">765</link>
			<link type="Duplicate" description="is duplicated by">1238</link>
		</links>
	</bug>
	<bug id="789" opendate="2015-11-23 16:13:06" fixdate="2015-11-23 16:13:49" resolution="Fixed">
		<buginformation>
			<summary>Fix typo in JavaDoc of Page</summary>
			<description></description>
			<version>1.10.2 (Fowler SR2)</version>
			<fixedVersion>1.11.2 (Gosling SR2), 1.12 M1 (Hopper), 1.10.3 (Fowler SR3)</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.domain.Page.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">906</link>
		</links>
	</bug>
	<bug id="799" opendate="2015-12-29 03:25:57" fixdate="2015-12-29 12:41:26" resolution="Duplicate">
		<buginformation>
			<summary>Pageable&amp;apos;s size should not be dependent on 1-based or 0-based paging.</summary>
			<description>In this controller :






@RequestMapping("/list")




public String list(Model model , Pageable pageable) {




  logger.info("pageable = {}" , pageable);




  // ... skipped




}






My goal : I want Spring automatically build this pageable object from page and size parameter of URL , which page starts from 1.
The solution is here : http://stackoverflow.com/questions/34459658
First , I feel the API design of `addArgumentResolvers` is problematic . It has to call super.addArgumentResolvers(argumentResolvers) at the end of the method.
It should be able to designed to just add the resolver to argumentResolvers and make it work.
And here is the point : resolver.setOneIndexedParameters(true) will also change the meaning of size , it is very counter-intuitive.
In most people&amp;amp;apos;s intuition , no matter page starts from 1 or 0 , size should not be dependent on that value.
But when I code : 






resolver.setMaxPageSize(10);




resolver.setOneIndexedParameters(true);






And pass ?page=1&amp;amp;size=10 in the URL . The receiving size becomes 9 . It should be fixed.</description>
			<version>1.10.2 (Fowler SR2)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolverUnitTests.java</file>
			<file type="M">org.springframework.data.web.PageableHandlerMethodArgumentResolver.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">761</link>
		</links>
	</bug>
	<bug id="804" opendate="2016-01-20 17:02:18" fixdate="2016-01-21 09:25:04" resolution="Fixed">
		<buginformation>
			<summary>IndexOutOfBoundException in ParametersParameterAccessor iterator when non-bindable parameter(s) used</summary>
			<description>When using a ParametersParameterAccessor on a method with, say, a Pageable (which is non-bindable), attempting to iterate over the accessor throws an IndexOutOfBoundException.
This is because BindableParameterIterator.hasNext() checks values.length, which includes non-bindable parameters, whereas next() calls getBindableValue.</description>
			<version>1.11.2 (Gosling SR2)</version>
			<fixedVersion>1.12 M1 (Hopper), 1.11.4 (Gosling SR4), 1.10.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.query.ParametersParameterAccessorUnitTests.java</file>
			<file type="M">org.springframework.data.repository.query.ParametersParameterAccessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="812" opendate="2016-01-29 20:53:59" fixdate="2016-03-07 10:34:55" resolution="Fixed">
		<buginformation>
			<summary>Confusing message generated by  PageImpl.toString()</summary>
			<description>The PageImpl.toString() uses getNumber() and getTotalPages(). The problem is:

getNumber() uses 0-based index
getTotalPages() is the total number of pages

So you end up with:






Page 0 of 2 containing com.foo.Bar instances




Page 1 of 2 containing com.foo.Bar instances





</description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion>1.12 RC1 (Hopper), 1.10.3 (Fowler SR3), 1.11.5 (Gosling SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.domain.PageImpl.java</file>
		</fixedFiles>
	</bug>
	<bug id="828" opendate="2016-03-15 14:00:02" fixdate="2016-03-15 14:06:42" resolution="Fixed">
		<buginformation>
			<summary>Potential NullPointerException in ResultProcessor</summary>
			<description>According to the JavaDoc ResultProcessor.processResult() allows null to be handed as result, which makes sense as a query result to be processed can be null. However, null is not handled implicitly or explicitly and will yield an exception being thrown from ProjectionFactory as a projection is attempted downstream.
We should handle null explicitly and eagerly return the value as is.</description>
			<version>1.12 M1 (Hopper)</version>
			<fixedVersion>1.12 RC1 (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.query.ResultProcessorUnitTests.java</file>
			<file type="M">org.springframework.data.repository.query.ResultProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="829" opendate="2016-03-15 14:06:25" fixdate="2016-03-15 14:52:10" resolution="Fixed">
		<buginformation>
			<summary>Projecting a Map with a null value causes an exception</summary>
			<description>ProjectingMethodInterceptor.getProjection(Object, Class&amp;lt;?&amp;gt;) assumes the first param to be non-null, but it may be null if there is a Map with a null value, e.g. a Collections.createSingletonMap("key", null).
That means that returning such map from a @Projection, e.g.:






public interface MyProjection {




    Map&amp;lt;String, Object&amp;gt; getData();




}






results in an exception.
A kind of a workaround is to remove nulls from a projected map, e.g.:






public interface MyProjection {




    @Value("#{T(...).mapWithoutNulls(target.getData())}")




    Map&amp;lt;String, Object&amp;gt; getData();




}









...









public static &amp;lt;K, V&amp;gt; Map&amp;lt;K, V&amp;gt; mapWithoutNulls(Map&amp;lt;K, V&amp;gt; map) {




    return map.entrySet().stream()




            .filter(entry -&amp;gt; entry.getValue() != null)




            .collect(Collectors.toMap(




                    Map.Entry::getKey,




                    Map.Entry::getValue));




}





</description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion>1.12 RC1 (Hopper), 1.10.3 (Fowler SR3), 1.11.5 (Gosling SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.projection.ProxyProjectionFactoryUnitTests.java</file>
			<file type="M">org.springframework.data.projection.ProjectingMethodInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="843" opendate="2016-04-10 09:23:23" fixdate="2016-04-10 09:32:50" resolution="Fixed">
		<buginformation>
			<summary>Raise log level of repositories that get dropped in strict configuration mode to INFO</summary>
			<description></description>
			<version>1.10.2 (Fowler SR2)</version>
			<fixedVersion>1.10.3 (Fowler SR3), 1.11.5 (Gosling SR5), 1.12.2 (Hopper SR2), 1.13 M1 (Ingalls)</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.config.RepositoryConfigurationDelegate.java</file>
			<file type="M">org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">690</link>
			<link type="Relate" description="relates to">1413</link>
		</links>
	</bug>
	<bug id="854" opendate="2016-05-06 20:07:28" fixdate="2016-05-24 17:08:02" resolution="Fixed">
		<buginformation>
			<summary>Custom implementation of repository fails when overriding methods containing generics</summary>
			<description>I am using the method for creating custom implementation of repositories, as described (among other places) here. This works great for just about all methods, including methods from the standard CrudRepository and PagingAndSortingRepository like Page&amp;lt;T&amp;gt; findAll(Pageable pageable). However, this does not work if the method defined in CrudRepository or PagingAndSortingRepository contains parameters with generics, like T findOne(ID id).
Why am I doing this you ask? Well, I am trying to find a work around while waiting for DATACMNS-293. This allows me to implement the methods manually, while keeping all the goodness of the restful exposure code as-is, which given QueryDSL is suprisingly simple and I am nearly questioning the need for the solution in DATACMNS-293...
The following patch fixes the issue for me, but I am not able to see if this has further unwanted ramifications:






iff --git a/src/main/java/org/springframework/data/repository/core/support/DefaultRepositoryInformation.java b/src/main/java/org/springframework/data/repository/core/support/DefaultRepositoryInformation.java




index 48bcdac..785c575 100644




--- a/src/main/java/org/springframework/data/repository/core/support/DefaultRepositoryInformation.java




+++ b/src/main/java/org/springframework/data/repository/core/support/DefaultRepositoryInformation.java




@@ -356,7 +356,7 @@ class DefaultRepositoryInformation implements RepositoryInformation {




                                        return false;




                                }




                        } else {




-                               if (!types[i].equals(parameterType)) {




+                               if (!types[i].isAssignableFrom(parameterType)) {




                                        return false;




                                }




                        }





</description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion>1.11.5 (Gosling SR5), 1.12.2 (Hopper SR2), 1.13 M1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformation.java</file>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformationUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">912</link>
		</links>
	</bug>
	<bug id="859" opendate="2016-05-25 08:11:32" fixdate="2016-05-25 15:07:48" resolution="Fixed">
		<buginformation>
			<summary>ResultProcessor doesn&amp;apos;t handle Stream instances correctly</summary>
			<description></description>
			<version>1.12.1 (Hopper SR1)</version>
			<fixedVersion>1.12.2 (Hopper SR2), 1.13 M1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.query.ResultProcessorUnitTests.java</file>
			<file type="M">org.springframework.data.repository.query.ResultProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="860" opendate="2016-05-25 08:14:03" fixdate="2016-05-25 15:08:11" resolution="Fixed">
		<buginformation>
			<summary>ResultProcessor should use ConversionService as fallback if target is a class</summary>
			<description>If the actual conversion target in repository projections is not an interface, ResultProcessor currently fails with the ProjectionFactory rejecting the type. We could rather use a standard ConversionService implementation so that normal object conversion mechanisms can kick in (i.e. the ObjectToObjectConverter supporting converting factory methods, and constructors).</description>
			<version>1.12.1 (Hopper SR1)</version>
			<fixedVersion>1.12.2 (Hopper SR2), 1.13 M1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.query.ResultProcessorUnitTests.java</file>
			<file type="M">org.springframework.data.repository.query.ResultProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="856" opendate="2016-05-17 19:38:06" fixdate="2016-05-31 16:18:05" resolution="Fixed">
		<buginformation>
			<summary>DomainClassConverter throws erroneous exception in matches</summary>
			<description>DomainClassConverter#matches throws a ConversionMatchAbbreviationException instead of correctly returning false in at least the following scenario:

sourceType is not related to targetType
targetType has a Spring Data repository with a String ID

The matches method performs the following logic:

sourceType is not assignable to targetType
targetType has a repository
the ID type is String
sourceType is not a String, and I can&amp;amp;apos;t convert sourceType to a String

The correct response is therefore simply not to match (and in my case, to let SpEL attempt to bind to a different method overload). The converter instead throws an exception.</description>
			<version>1.12.1 (Hopper SR1)</version>
			<fixedVersion>1.11.5 (Gosling SR5), 1.12.2 (Hopper SR2), 1.13 M1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.support.DomainClassConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">685</link>
		</links>
	</bug>
	<bug id="690" opendate="2015-05-07 12:31:58" fixdate="2016-05-31 16:33:20" resolution="Duplicate">
		<buginformation>
			<summary>Multi-store silently ignores repository creation failures</summary>
			<description>Basic use case is presented here
https://github.com/spring-projects/spring-data-examples/tree/master/multi-store
In my use case we did not put @Document on mongo annotations. Therefore, when I migrated our application to the latest version of spring boot (hence the latest version of spring data), my repositories were not created in the context.
It was very hard to guess that this happened as this is notified on a DEBUG level.
Fyi, we have a @Enable*Repositories which points to separate packages to avoid confusion on repository creation, therefore, it is was not trivial to understand the existence of this "strict" mode.</description>
			<version>1.10.2 (Fowler SR2)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.config.RepositoryConfigurationDelegate.java</file>
			<file type="M">org.springframework.data.repository.config.RepositoryConfigurationExtensionSupport.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">843</link>
		</links>
	</bug>
	<bug id="831" opendate="2016-03-23 19:22:03" fixdate="2016-05-31 17:05:26" resolution="Fixed">
		<buginformation>
			<summary>AbstractMappingContext.getPersistentEntity sometimes returns an empty entity when called by multiple threads</summary>
			<description>If you call the getPersistentEntity() method in the AbstractMappingContext class with the same type from multiple threads concurrently, you will sometimes get an empty entity back, i.e. an entity without any properties. This is caused by a race condition at the beginning of the addPersistentEntity() method. If one thread calls the method while another one is already executing inside the write lock in the method, the first thread will return an empty entity from the persistentEntities map even though the second thread is still populating it with properties. To fix this, the addPersistentEntity() method should acquire the read lock before accessing the persistentEntities map.</description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion>1.11.5 (Gosling SR5), 1.12.2 (Hopper SR2), 1.13 M1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.context.AbstractMappingContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="862" opendate="2016-06-01 15:41:21" fixdate="2016-06-01 15:55:36" resolution="Fixed">
		<buginformation>
			<summary>ReturnedInterface should not consider super interfaces of domain type projecting</summary>
			<description></description>
			<version>1.12.1 (Hopper SR1)</version>
			<fixedVersion>1.12.2 (Hopper SR2), 1.13 M1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.query.ReturnedTypeUnitTests.java</file>
			<file type="M">org.springframework.data.repository.query.ReturnedType.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">885</link>
		</links>
	</bug>
	<bug id="863" opendate="2016-06-04 12:29:03" fixdate="2016-06-06 16:34:11" resolution="Fixed">
		<buginformation>
			<summary>Query method Parameter should return element type for wrapper ones (e.g. Optional)</summary>
			<description></description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion>1.11.5 (Gosling SR5), 1.12.2 (Hopper SR2), 1.13 M1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.query.ParametersUnitTests.java</file>
			<file type="M">org.springframework.data.repository.query.Parameter.java</file>
		</fixedFiles>
	</bug>
	<bug id="882" opendate="2016-07-15 07:42:08" fixdate="2016-07-15 09:10:29" resolution="Duplicate">
		<buginformation>
			<summary>Allow to filter value inside list of object via query URL</summary>
			<description>Create a support for query inside list of object, see issue in this link.
I&amp;amp;apos;m trying to implement by myself, see code here but I also hit a roadblock with issue of querydsl itself (here issue).
If you think that the issue of querydsl is not important, I can improve code quality and then create a pull request to your repo.
I think my code quality is not as good as yours, please give me an advice.</description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion></fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindings.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslPredicateBuilderUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.QueryDslUtils.java</file>
			<file type="M">org.springframework.data.querydsl.User.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslPredicateBuilder.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindingsUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">883</link>
		</links>
	</bug>
	<bug id="874" opendate="2016-06-23 11:04:05" fixdate="2016-07-18 07:43:54" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException when unwrapping empty Scala Options</summary>
			<description>Unwrapping an empty Scala Option causes a NullPointerException. The passed argument is a function which is accessed during the orNull() call.
A solution would look like:






Option.empty().getOrElse(new AbstractFunction0&amp;lt;Object&amp;gt;() {




			@Override




			public Object apply() {




				return null;




			}




		});






Exception:






java.lang.NullPointerException




	at scala.Option$$anonfun$orNull$1.apply(Option.scala:132)




	at scala.Option.getOrElse(Option.scala:121)




	at scala.Option.orNull(Option.scala:132)




	at org.springframework.data.repository.util.QueryExecutionConverters$ScalOptionUnwrapper.convert(QueryExecutionConverters.java:431)




	at org.springframework.data.repository.util.QueryExecutionConverters.unwrap(QueryExecutionConverters.java:154)




	at org.springframework.data.repository.query.ParametersParameterAccessor.&amp;lt;init&amp;gt;(ParametersParameterAccessor.java:55)






Repository:






public interface PersonRepository extends CrudRepository&amp;lt;Person, Long&amp;gt; {




	List&amp;lt;Person&amp;gt; findByFirstname(Option&amp;lt;String&amp;gt; gender);




}






Invocation:






repository.findByFirstname(Option.empty());





</description>
			<version>1.12.2 (Hopper SR2)</version>
			<fixedVersion>1.13 M1 (Ingalls), 1.12.3 (Hopper SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.util.QueryExecutionConverters.java</file>
			<file type="M">org.springframework.data.repository.util.QueryExecutionConvertersUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="883" opendate="2016-07-15 08:26:03" fixdate="2016-07-25 18:13:29" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException for Querydsl bindings referring to collection element attributes</summary>
			<description>Assume you have a domain model like this:






class User {




  List&amp;lt;Address&amp;gt; addresses;




}









class Address {




  String street;




}






Referring to the property addresses.street via Querydsl-backed web requests doesn&amp;amp;apos;t work as we&amp;amp;apos;re inspecting the properties in the Querydsl generated classes, and the ListPath generated for addresses needs a dedicated any() lookup to get back to the EntityPath for the element predicates.
Manually specifying a binding, doesn&amp;amp;apos;t help either as the translation into a PropertyPath fails, as we currently rely on the toString() representation of the PathMetadata, which in case of the usage of any() returns any(user.addresses).street.
We need to fix the to-dot-path translation in that step and should add the implicit call to any() for derived path expressions in case we encounter a Path that points to a collection.</description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion>1.13 M1 (Ingalls), 1.12.3 (Hopper SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindings.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslPredicateBuilderUnitTests.java</file>
			<file type="M">org.springframework.data.querydsl.QueryDslUtils.java</file>
			<file type="M">org.springframework.data.querydsl.User.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslPredicateBuilder.java</file>
			<file type="M">org.springframework.data.querydsl.binding.QuerydslBindingsUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">882</link>
		</links>
	</bug>
	<bug id="880" opendate="2016-07-05 22:03:56" fixdate="2016-07-26 07:54:26" resolution="Fixed">
		<buginformation>
			<summary>TransactionalRepositoryFactoryBeanSupport.setBeanFactory doesn&amp;apos;t delegate to super-implementation</summary>
			<description>From TransactionalRepositoryFactoryBeanSupport:






public void setBeanFactory(BeanFactory beanFactory) {









	Assert.isInstanceOf(ListableBeanFactory.class, beanFactory);









	ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory;




	this.txPostProcessor = new TransactionalRepositoryProxyPostProcessor(listableBeanFactory, transactionManagerName,




			enableDefaultTransactions);




	this.exceptionPostProcessor = new PersistenceExceptionTranslationRepositoryProxyPostProcessor(listableBeanFactory);




	    




}






which doesn&amp;amp;apos;t delegate to the super-implementation of RepositoryFactoryBeanSupport, and consequently, afterPropertiesSet() passes null down to a custom factory implementation, which is IMHO wrong. Maven project attached to demonstrate the issue, but I think the fix is simply to add a line with the call to the super implementation in TransactionalRepositoryFactoryBeanSupport.setBeanFactory.</description>
			<version>1.12.2 (Hopper SR2)</version>
			<fixedVersion>1.13 M1 (Ingalls), 1.12.3 (Hopper SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.TransactionalRepositoryFactoryBeanSupport.java</file>
			<file type="M">org.springframework.data.repository.core.support.TransactionRepositoryFactoryBeanSupportUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="896" opendate="2016-08-18 20:48:18" fixdate="2016-08-19 17:58:10" resolution="Fixed">
		<buginformation>
			<summary>ClassTypeInformation computes incorrect TypeVariable mappings for recursive generics</summary>
			<description>When using a class with type variables in the class hierarchy, which contains variables referencing other classes also using common parts of the same class hierarchy, the type variables type mappings for the referenced classes are incorrectly mixed into the original classes type variables.
See the attached JUnit test which can demonstrate the problem.  It may require several runs for it appear, but it is consistently failing for us.
I believe this is due the essentially random ordering of the HashSet.entrySet().iterator() on line 130 and the putAll() on line 136:
https://github.com/spring-projects/spring-data-commons/blob/master/src/main/java/org/springframework/data/util/ClassTypeInformation.java#L130
https://github.com/spring-projects/spring-data-commons/blob/master/src/main/java/org/springframework/data/util/ClassTypeInformation.java#L136
Depending on the sequencing, you either get your own type variable value, or some other related classes.  Last one wins.
We&amp;amp;apos;ve tried modifying this class to removed the putAll (line 136), and it fixes this test, and does not appear to cause problems for 100s of other Spring Data Repository based tests we have.  It&amp;amp;apos;s not clear why the type variable mappings from other classes that are not direct superclasses or interfaces are included at all, it seems very wrong.

It took us 4 days to track down this as the ultimate source of a random startup failures of a Spring Data JPA Repository while parsing of dynamic query methods on a particular part of our domain model.  It was very hard to reproduce, but one developers box seemed to want to fail rather consistently, which gave the opportunity to narrow it down.  My hope, for now, is to work around it by mapping the query method to a custom implementation.</description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion>1.11.5 (Gosling SR5), 1.12.3 (Hopper SR3), 1.13 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.util.ClassTypeInformation.java</file>
			<file type="M">org.springframework.data.util.ClassTypeInformationUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="906" opendate="2016-08-26 14:24:44" fixdate="2016-08-31 11:58:06" resolution="Duplicate">
		<buginformation>
			<summary>Typo in Javadoc of Page.getTotalPages()</summary>
			<description>In the javadoc of org.springframework.data.domain.Page, method getTotalPages, the word total is not written correctly in @return. Thank&amp;amp;apos;s </description>
			<version>1.10.2 (Fowler SR2)</version>
			<fixedVersion></fixedVersion>
			<type>Task</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.domain.Page.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">789</link>
		</links>
	</bug>
	<bug id="900" opendate="2016-08-25 12:24:34" fixdate="2016-09-01 15:25:50" resolution="Fixed">
		<buginformation>
			<summary>ExampleMatcher.PropertySpecifiers does not implement equals/hashCode</summary>
			<description>The class ExampleMatcher.PropertySpecifiers does not implement equals/hashCode. Since an ExampleMatcher and its PropertySpecifiers are referenced by an Example instance, this means that it is not possible to mock the implementation of repository methods taking an Example as argument, e.g. JpaRepository.findAll(Example).</description>
			<version>1.12.2 (Hopper SR2)</version>
			<fixedVersion>1.12.3 (Hopper SR3), 1.13 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.domain.ExampleMatcher.java</file>
			<file type="M">org.springframework.data.domain.ExampleMatcherUnitTests.java</file>
			<file type="M">org.springframework.data.domain.ExampleUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="909" opendate="2016-09-08 08:55:13" fixdate="2016-09-09 20:02:51" resolution="Fixed">
		<buginformation>
			<summary>Exclude decoratedClass from JSON links, created from Projection and received with Spring @RestController</summary>
			<description>Experiment with spring-boot version: in 1.3.7.RELEASE (spring data 2.4.4) decoratedClass is absent, but in 1.4.0.RELEASE (spring data 2.5.2) it is present
I&amp;amp;apos;d like get clean JSON, when using Projection as DTO with RestController. However, in the best case we get JSON, most of which contain links to dekoratedClass.
{"name":"Dmitry","id":1,"decoratedClass":"ru.inkontext.domain.Person", "adress":{"id":1,"decoratedClass":"ru.inkontext.domain.Adress","city":"Surgut"}}
Decide by Oliver Gierke
Looks like this is caused by proxies created through Spring&amp;amp;apos;s ProxyFactory now also implementing a new DecoratingProxy, which exposes getDecoratedClass() and our TargetAware interface that&amp;amp;apos;s in place to mask the artificial proxy properties doesn&amp;amp;apos;t mask that newly introduced attribute. I can adapt our TargetAware accordingly.
A temporary workaround would be to redeclare the getDecoratedClass() method on your projection interface and annotate it with @JsonIgnore.
Tests below imaging matter of question.
RestController
Without Projection
mockMvc.perform(get("/rest/persons/1"))
.andExpect(jsonPath("id").value(1)
.andExpect(jsonPath("decoratedClass").doesNotExist());
Projection created by Repository
mockMvc.perform(get("/rest/persons/1/projected"))
.andExpect(jsonPath("id").value(1))
.andExpect(jsonPath("decoratedClass").value("java.util.HashMap"));
Projection created by Repository with Generic
mockMvc.perform(get("/rest/persons/1/projectedClass"))
.andExpect(jsonPath("id").value(1))
.andExpect(jsonPath("decoratedClass").value("java.util.HashMap"));
Projection created by Projection Factory
mockMvc.perform(get("/rest/persons/1/adressCity"))
.andExpect(jsonPath("id").value(1))
.andExpect(jsonPath("decoratedClass").value("ru.inkontext.domain.Person"));
Standard Sring Data REST API
without Projection
mockMvc.perform(get("/rest/api/persons/1"))
.andExpect(jsonPath("id").doesNotExist())
.andExpect(jsonPath("_links").exists());
with Projection
mockMvc.perform(get("/rest/api/persons/1?projection=adressCity"))
.andExpect(status().isOk())
.andExpect(jsonPath("id").value(1))
.andExpect(jsonPath("_links").exists());</description>
			<version>1.11.4 (Gosling SR4)</version>
			<fixedVersion>1.11.5 (Gosling SR5), 1.12.3 (Hopper SR3), 1.13 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.projection.TargetAware.java</file>
		</fixedFiles>
	</bug>
	<bug id="912" opendate="2016-09-16 15:08:45" fixdate="2016-09-19 22:57:54" resolution="Fixed">
		<buginformation>
			<summary>Unable to write custom implementation of CRUD method with generic parameters</summary>
			<description>As discussed in https://jira.spring.io/browse/DATACMNS-854, I am opening a new issue as I am unable to create a custom implementation of a CRUD method that takes generic parameters.
I modified my example that reproduces the problem and removed Mockito from the picture.  I also tested the flow in our code base at runtime (not in unit tests), and am also able to reproduce.
Here is the potential DefaultRepositoryInformationUnitTests test that reproduces:






    class BossRepositoryCustom {




        Boss save(Boss boss) {




            return boss;




        }




    }









    @Test




    public void discoversCustomlyImplementedCrudMethodWithGenericParameters() throws SecurityException, NoSuchMethodException {




        BossRepositoryCustom customImplementation = new BossRepositoryCustom();




        RepositoryMetadata metadata = new DefaultRepositoryMetadata(BossRepository.class);




        RepositoryInformation information = new DefaultRepositoryInformation(metadata, CrudRepository.class,




                                                                             customImplementation.getClass());









        Method customBaseRepositoryMethod = BossRepository.class.getMethod("save", Object.class);




        assertThat(information.isCustomMethod(customBaseRepositoryMethod), is(true));




    }






I&amp;amp;apos;ve also attached a self-contained small test that also reproduces the issue.
Let me know if you need more information.  Hopefully I am not missing something obvious here.</description>
			<version>1.12.2 (Hopper SR2)</version>
			<fixedVersion>1.11.5 (Gosling SR5), 1.12.3 (Hopper SR3), 1.13 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformation.java</file>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformationUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">854</link>
		</links>
	</bug>
	<bug id="916" opendate="2016-09-22 19:15:37" fixdate="2016-09-23 12:57:56" resolution="Fixed">
		<buginformation>
			<summary>Generated PropertyAccessor fails lookup of setter accepting a primitive type</summary>
			<description>Class:
https://github.com/spring-projects/spring-integration/blob/master/spring-integration-mongodb/src/main/java/org/springframework/integration/mongodb/store/MongoDbMessageStore.java#L841






	private static final class MessageWrapper {









		@SuppressWarnings("unused")




		private int sequence;









		public void setSequence(int sequence) {




			this.sequence = sequence;




		}




	}












java.lang.ExceptionInInitializerError: java.lang.ExceptionInInitializerError




java.lang.ExceptionInInitializerError




	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)




	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)




	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)




	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)




	at org.springframework.data.mapping.model.ClassGeneratingPropertyAccessorFactory.getPropertyAccessor(ClassGeneratingPropertyAccessorFactory.java:84)




	at org.springframework.data.mapping.model.BasicPersistentEntity.getPropertyAccessor(BasicPersistentEntity.java:417)




	at org.springframework.data.mongodb.core.MongoTemplate.assertUpdateableIdIfNotSet(MongoTemplate.java:1294)




	at org.springframework.data.mongodb.core.MongoTemplate.doInsert(MongoTemplate.java:843)




	at org.springframework.data.mongodb.core.MongoTemplate.insert(MongoTemplate.java:791)




	at org.springframework.integration.mongodb.store.MongoDbMessageStore.addMessageDocument(MongoDbMessageStore.java:216)




	at org.springframework.integration.mongodb.store.MongoDbMessageStore.addMessagesToGroup(MongoDbMessageStore.java:291)




	at org.springframework.integration.store.AbstractMessageGroupStore.addMessageToGroup(AbstractMessageGroupStore.java:209)




	at org.springframework.integration.handler.DelayHandler.releaseMessageAfterDelay(DelayHandler.java:315)




	at org.springframework.integration.handler.DelayHandler.handleRequestMessage(DelayHandler.java:243)




	at org.springframework.integration.handler.AbstractReplyProducingMessageHandler.handleMessageInternal(AbstractReplyProducingMessageHandler.java:109)




	at org.springframework.integration.handler.AbstractMessageHandler.handleMessage(AbstractMessageHandler.java:127)




	at org.springframework.integration.dispatcher.AbstractDispatcher.tryOptimizedDispatch(AbstractDispatcher.java:116)




	at org.springframework.integration.dispatcher.UnicastingDispatcher.doDispatch(UnicastingDispatcher.java:148)




	at org.springframework.integration.dispatcher.UnicastingDispatcher.dispatch(UnicastingDispatcher.java:121)




	at org.springframework.integration.channel.AbstractSubscribableChannel.doSend(AbstractSubscribableChannel.java:77)




	at org.springframework.integration.channel.AbstractMessageChannel.send(AbstractMessageChannel.java:423)




	at org.springframework.integration.channel.AbstractMessageChannel.send(AbstractMessageChannel.java:373)




	at org.springframework.integration.mongodb.store.DelayerHandlerRescheduleIntegrationTests.testDelayerHandlerRescheduleWithMongoDbMessageStore(DelayerHandlerRescheduleIntegrationTests.java:82)




	at org.springframework.integration.mongodb.store.DelayerHandlerRescheduleIntegrationTests.testWithMongoDbMessageStore(DelayerHandlerRescheduleIntegrationTests.java:62)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:498)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)




	at org.springframework.integration.mongodb.rules.MongoDbAvailableRule$1.evaluate(MongoDbAvailableRule.java:59)




	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)




	at org.junit.rules.RunRules.evaluate(RunRules.java:20)




	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)




	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:114)




	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:57)




	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:66)




	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:498)




	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)




	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)




	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)




	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)




	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)




	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:109)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:498)




	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)




	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)




	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:377)




	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)




	at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)




	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)




	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)




	at java.lang.Thread.run(Thread.java:745)




Caused by: java.lang.NoSuchMethodException: org.springframework.integration.mongodb.store.MongoDbMessageStore$MessageWrapper.setSequence(java.lang.Integer)




	at java.lang.Class.getDeclaredMethod(Class.java:2130)




	at org.springframework.integration.mongodb.store.MongoDbMessageStore$MessageWrapper_Accessor_lxoqe3.&amp;lt;clinit&amp;gt;(Unknown Source)




	... 70 more






Update: Generated property accessors initialize field and property accessors as far as possible upon class initialization. Although setter initialization is not required for this case, it revealed a bug in setter lookup. The call to getDeclaredMethod used java.lang.Integer as argument type instead of java.lang.Integer#TYPE. The root cause is that a setter lookup uses wrapped types instead of the primitive type for getDeclaredMethod lookup.</description>
			<version>1.13 M1 (Ingalls)</version>
			<fixedVersion>1.13 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.model.ClassGeneratingPropertyAccessorFactory.java</file>
			<file type="M">org.springframework.data.mapping.model.ClassGeneratingPropertyAccessorFactoryTests.java</file>
			<file type="M">org.springframework.data.mapping.model.ClassGeneratingPropertyAccessorFactoryDatatypeTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">4119</link>
		</links>
	</bug>
	<bug id="921" opendate="2016-09-28 12:52:56" fixdate="2016-09-28 13:02:39" resolution="Fixed">
		<buginformation>
			<summary>ResultProcessor should create approximate collection instead of exact one</summary>
			<description>ResultProcessor currently tries to create an instance of the exact collection type encountered when processing collections. This will fail for special collection implementation types that don&amp;amp;apos;t have a default constructor or fail to instantiate for other reasons.
We should fall back to an approximate collection in that case.</description>
			<version>1.12.3 (Hopper SR3)</version>
			<fixedVersion>1.12.4 (Hopper SR4), 1.13 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.query.ResultProcessorUnitTests.java</file>
			<file type="M">org.springframework.data.repository.query.ResultProcessor.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">974</link>
		</links>
	</bug>
	<bug id="939" opendate="2016-11-19 13:26:43" fixdate="2016-11-21 20:05:49" resolution="Fixed">
		<buginformation>
			<summary>Static interface methods should not be considered query methods</summary>
			<description>I have a table with a partition key on a date, and I&amp;amp;apos;ll mostly ever query only the last 2 days. Beyond that, the data is "dead", we only keep it for trace.
I&amp;amp;apos;m using Java 8 in which you can set default implementation of methods in interfaces.
Here is what I&amp;amp;apos;m trying to do:






public interface MyObjectRepository extends CassandraRepository&amp;lt;MyObject&amp;gt; {









    /**




     * @return the partition key dates that we consider contain "alive" data.




     */




    static String[] getAlivePartitionKeys() {




        String[] searchedPartitionKeys = new String[2];




        LocalDate currentLocalDate = LocalDateUtils.getUtcLocalDate();




        searchedPartitionKeys[0] = LocalDateUtils.format(currentLocalDate);// today




        searchedPartitionKeys[1] = LocalDateUtils.format(currentLocalDate.minus(Period.ofDays(1)));// yesterday




        return searchedPartitionKeys;




    }









    default MyObject findById(UUID id) {




        return findByPartitionKeyDateAndId(getAlivePartitionKeys(), sessionUUID);




    }









    @Query("SELECT * FROM myobject WHERE partition_key_date IN (:partitionKeyDates) AND id = :id")




    MyObject findByPartitionKeyDateAndId(@NotNull @Param("partitionKeyDates") String[] partitionKeyDates, @NotNull @Param("id") UUID id);









}






(Note: The String[] seem to not be supported with the version 1.4.5 but should be supported in 1.5.0 from what I understood, but that&amp;amp;apos;s not the object of my request, I&amp;amp;apos;m only trying to express the need)
Here&amp;amp;apos;s is what I&amp;amp;apos;d like to do from my service:






myObjectRepository.finById(uuid);






And that call will automatically look on the last 2 days. Am I trying to do something bad?
The problem is, I get the following error:






Caused by: org.springframework.dao.InvalidDataAccessApiUsageException: declarative query methods are a todo






I&amp;amp;apos;m looking for a way to tell him I dont want any query resolution for those methods...
I thought an annotation could be used to disable it. Or we could automatically detect its a "static" or "default" method. We would then only resolve the query if:






!method.isDefault() &amp;amp;&amp;amp; !Modifier.isStatic(method.getModifiers())






</description>
			<version>1.12.5 (Hopper SR5)</version>
			<fixedVersion>1.13 RC1 (Ingalls), 2.0 M1 (Kay), 1.12.6 (Hopper SR6)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformation.java</file>
		</fixedFiles>
	</bug>
	<bug id="943" opendate="2016-10-04 21:54:22" fixdate="2016-11-24 16:25:00" resolution="Fixed">
		<buginformation>
			<summary>Redeclared save(Iterable) results in wrong method overload to be invoked eventually</summary>
			<description>I have upgrade my project from spring boot 1.3.1 to 1.4.1.
After the update the code seems to behave fine in windows with java 1.8.0_45 64bit
But in jenkins server (on linux) with the same java version the code breaks with this exception






org.springframework.beans.NotReadablePropertyException: Invalid property &amp;amp;apos;id&amp;amp;apos; of bean class [java.util.Arrays$ArrayList]: Could not find field for property during fallback access!




	at org.springframework.data.util.DirectFieldAccessFallbackBeanWrapper.getPropertyValue(DirectFieldAccessFallbackBeanWrapper.java:56)




	at org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.getId(JpaMetamodelEntityInformation.java:149)




	at org.springframework.data.repository.core.support.AbstractEntityInformation.isNew(AbstractEntityInformation.java:51)




	at org.springframework.data.jpa.repository.support.JpaMetamodelEntityInformation.isNew(JpaMetamodelEntityInformation.java:225)




	at org.springframework.data.jpa.repository.support.SimpleJpaRepository.save(SimpleJpaRepository.java:505)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:497)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:503)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:488)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:460)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:61)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99)




	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281)




	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:136)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at 






The invoking call is 





 myRepository.save(Arrays.asList(new MyEntity(1, "foo"), new MyEntity(2, "bar"))); 





. In linux and with the upgrade to spring boot 1.4.1 it seems the save(Iterable) method is not invoked, but the save(entity) method is invoked and causes this exception.</description>
			<version>1.12.5 (Hopper SR5)</version>
			<fixedVersion>1.13 RC1 (Ingalls), 1.11.7 (Gosling SR7), 1.12.6 (Hopper SR6), 2.0 M2 (Kay)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformation.java</file>
			<file type="M">org.springframework.data.repository.core.support.DefaultRepositoryInformationUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">945</link>
		</links>
	</bug>
	<bug id="848" opendate="2016-04-21 10:56:08" fixdate="2016-12-05 08:51:16" resolution="Duplicate">
		<buginformation>
			<summary>Support JSR-310 Duration and Period (to and from String)</summary>
			<description>The current Jsr310Converters.java doesn&amp;amp;apos;t support convertion to and from String representations of java.time.Duration and java.time.Period.
MongoTemplate should understand how to deserialize for instance "PT3M" to a java.time.Duration (by Duration#parse</description>
			<version>1.12.1 (Hopper SR1)</version>
			<fixedVersion></fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.convert.Jsr310Converters.java</file>
			<file type="M">org.springframework.data.convert.Jsr310ConvertersUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">951</link>
		</links>
	</bug>
	<bug id="951" opendate="2016-12-05 08:11:22" fixdate="2016-12-05 15:35:07" resolution="Fixed">
		<buginformation>
			<summary>Add Converters for JSR-310 Duration and Period</summary>
			<description></description>
			<version>1.12.1 (Hopper SR1)</version>
			<fixedVersion>1.13 RC1 (Ingalls), 2.0 M2 (Kay)</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.convert.Jsr310Converters.java</file>
			<file type="M">org.springframework.data.convert.Jsr310ConvertersUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">848</link>
		</links>
	</bug>
	<bug id="934" opendate="2016-11-11 13:26:41" fixdate="2016-12-05 16:07:55" resolution="Fixed">
		<buginformation>
			<summary>BasicPersistentEntity.addAssociations() must not add null values to the collection of associations</summary>
			<description>The issue happens when use the same class to define an entity of Spring Data MongoDB and Spring Data Solr, and also have a field with annotation in MongoDB as @DBRef. @DBRef adds the annotation @Reference, when mapping the object to SimpleSolrPersistentEntity, this sets to null the property association on AbstractPersistentProperty. Then, when you make a search with Spring Data Solr and try to get the hasScoreProperty() this throws a NullPointerException.






        at org.springframework.data.mapping.model.BasicPersistentEntity.getPersistentProperty(BasicPersistentEntity.java:266)




	at org.springframework.data.solr.core.mapping.SimpleSolrPersistentEntity.getScoreProperty(SimpleSolrPersistentEntity.java:133)




	at org.springframework.data.solr.core.mapping.SimpleSolrPersistentEntity.hasScoreProperty(SimpleSolrPersistentEntity.java:124)




	at org.springframework.data.solr.core.SolrTemplate.query(SolrTemplate.java:497)




	at org.springframework.data.solr.core.SolrTemplate.doQueryForPage(SolrTemplate.java:338)




	at org.springframework.data.solr.core.SolrTemplate.queryForPage(SolrTemplate.java:350)




	at com.mycompany.engine.solr.repositories.bc.SolrBCDaoImpl.selectObject(SolrBCDaoImpl.java:104)





</description>
			<version>1.11.6 (Gosling SR6)</version>
			<fixedVersion>1.13 RC1 (Ingalls), 1.11.7 (Gosling SR7), 1.12.6 (Hopper SR6), 2.0 M2 (Kay)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mapping.model.BasicPersistentEntity.java</file>
			<file type="M">org.springframework.data.mapping.model.BasicPersistentEntityUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">341</link>
		</links>
	</bug>
	<bug id="963" opendate="2016-12-21 13:07:49" fixdate="2016-12-21 13:15:19" resolution="Fixed">
		<buginformation>
			<summary>ReturnedType.getInputProperties() does not guarantee distinct properties</summary>
			<description>In case inheritance is used in projection interfaces and an accessor method is redeclared, the property is returned twice in ReturnedType.getInputProperties(). The reason for that is that the accessor methods are backed by different PropertyDescriptor instances as they&amp;amp;apos;re unique per declared type.</description>
			<version>1.12.5 (Hopper SR5)</version>
			<fixedVersion>1.13 RC1 (Ingalls), 1.12.6 (Hopper SR6), 2.0 M2 (Kay)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.repository.query.ReturnedTypeUnitTests.java</file>
			<file type="M">org.springframework.data.repository.query.ReturnedType.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="is depended on by">1029</link>
		</links>
	</bug>
</bugrepository>