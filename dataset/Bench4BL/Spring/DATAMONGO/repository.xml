<?xml version = "1.0" encoding = "UTF-8" ?>
<bugrepository name="DATAMONGO">
	<bug id="273" opendate="2011-09-07 13:22:57" fixdate="2011-10-11 04:25:21" resolution="Fixed">
		<buginformation>
			<summary>Collection elements seem to lost their type when persisted</summary>
			<description>When I persist a list of objects they do not get a _class field in mongo, and come back as a LinkedHashMap rather than the type I expect.






Map&amp;lt;EventParam, Object&amp;gt; params = new HashMap&amp;lt;EventParam, Object&amp;gt;();




params.put(EventParam.USER, new FakeUser("bob"));




params.put(EventParam.VARIABLES, Collections.singletonList(new Variable("var_a", "value for a")));









IEvent event = new Event(EventType.VARIABLES_UPDATE, params);









RecordedServerEvent frame = new RecordedServerEvent((Event)event);




frame.setRecordingId(recordingId);




frame.setFrameId(new ObjectId().toString());




frame.setTimestamp(new Date());














mongoTemplate.insert(frame, COLLECTION_NAME);






gets persisted as:






{ "_id" : ObjectId("4e67ca8ca4b7746a17107034"), "_class" : "___.RecordedServerEvent", "event" : { "type" : "VARIABLES_UPDATE", "params" : { "VARIABLES" : [




	{




		"name" : "var_a",




		"value" : "value for a"




	}




], "USER" : { "name" : "bob", "_class" : "___.FakeUser" } } }, "recordingId" : "1234", "timestamp" : ISODate("2011-09-07T19:48:28.211Z") }






and when I try to deserialize it and use it, it comes back as a LinkedHashMap






Map&amp;lt;String, Object&amp;gt; rawParams = mappingConv.read(Map.class, (DBObject)s.get("params"));









System.out.println(((List)rawParams.get("VARIABLES")).get(0).getClass());   =&amp;gt;   java.util.LinkedHashMap






The behavior I would expect would be to get back a list of objects instantiated to the type they were before being persisted.
The motivation for deserializing this way is related to DATAMONGO-268 where I have to use a custom deserializer for third-party classes that I can&amp;amp;apos;t add a persistence constructor to.</description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.data.mongodb.core.convert.DataDoc273Test.java</file>
		</fixedFiles>
	</bug>
	<bug id="294" opendate="2011-10-12 13:06:47" fixdate="2011-10-13 09:05:20" resolution="Fixed">
		<buginformation>
			<summary>List elements nested in Map lose their type when persisted</summary>
			<description>Possibly related to DATAMONGO-273, objects in a List inside of a Map lose their type and can not be deserialized properly. When I run the attached test, I see this output:






{ "_class" : "net.emota.openspacedsr.MongoMapTest$Shipment" , 




  "boxes" : { 




     "one" : [ { "maker" : "Boeing" , "numberOfPropellers" : 4} , 




               { "railLine" : "Santa Fe" , "numberOfCars" : 200} , 




               { "make" : "Tesla" , "model" : "Roadster" , "numberOfDoors" : 2}]




}}






Where I would expect to see a _class attribute for each list element, allowing the proper reader conversions and letting the assertions in the test case pass.</description>
			<version>1.0 M4</version>
			<fixedVersion>1.0 M5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.data.mongodb.core.convert.DataDoc273Test.java</file>
		</fixedFiles>
	</bug>
	<bug id="316" opendate="2011-11-09 19:16:48" fixdate="2011-11-14 13:38:08" resolution="Complete">
		<buginformation>
			<summary>Replica Set configuration via properties file throws ArrayIndexOutOfBoundsException</summary>
			<description>Mongo ReplicaSet configuration via properties file is not working.
The configuration &amp;lt;br/&amp;gt;
&amp;lt;code&amp;gt;mongo.replicaSet=192.168.174.130:27017,192.168.174.130:27018,192.168.174.130:27019&amp;lt;/code&amp;gt;  &amp;lt;br/&amp;gt; resulted in the following exception:
&amp;lt;code&amp;gt;
Caused by: java.lang.ArrayIndexOutOfBoundsException: 1
	at org.springframework.data.mongodb.config.ParsingUtils.parseReplicaSet(ParsingUtils.java:51)
	at org.springframework.data.mongodb.config.MongoParser.doParse(MongoParser.java:49)
	at org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser.parseInternal(AbstractSingleBeanDefinitionParser.java:85)
	at org.springframework.beans.factory.xml.AbstractBeanDefinitionParser.parse(AbstractBeanDefinitionParser.java:59)
	at org.springframework.beans.factory.xml.NamespaceHandlerSupport.parse(NamespaceHandlerSupport.java:73)
	at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1335)
	at org.springframework.beans.factory.xml.BeanDefinitionParserDelegate.parseCustomElement(BeanDefinitionParserDelegate.java:1325)
	at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.parseBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:135)
	at org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:93)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.registerBeanDefinitions(XmlBeanDefinitionReader.java:493)
	at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:390)
&amp;lt;/code&amp;gt;</description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.config.MongoParser.java</file>
			<file type="M">org.springframework.data.mongodb.config.ParsingUtils.java</file>
			<file type="M">org.springframework.data.mongodb.config.MongoNamespaceReplicaSetTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="306" opendate="2011-10-27 15:07:15" fixdate="2011-11-14 19:47:51" resolution="Complete">
		<buginformation>
			<summary>NullPointerException if mongo factory created via URI with out credentials</summary>
			<description>Configuring mongo data factory with a URI that does not contain any credentials like the following






&amp;lt;mongo:db-factory uri="mongodb://localhost/myDatabase.myCollection"/&amp;gt;






will cause the following NPE






java.lang.NullPointerException




	at java.lang.String.&amp;lt;init&amp;gt;(String.java:177)




	at java.lang.String.valueOf(String.java:2840)




	at org.springframework.data.mongodb.core.SimpleMongoDbFactory.&amp;lt;init&amp;gt;(SimpleMongoDbFactory.java:89)





</description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.config.MongoDbFactoryParserIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.SimpleMongoDbFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="315" opendate="2011-11-09 10:21:33" fixdate="2011-11-14 20:30:06" resolution="Complete">
		<buginformation>
			<summary>MongoTemplate.findOne(query) methods ignore SortOrder on query</summary>
			<description>Query query = query(where("type").is("ad"));
query.sort().on("rawBidPrice", Order.DESCENDING);
Ad ad = mongoTemplate.findOne(query, Ad.class);
This does not sort the results before returning the first item.
Looking at the code, it doesn&amp;amp;apos;t even call query.getSortOrder().
--------------
Workaround
Query query = query(where("type").is("ad"));
query.sort().on("rawBidPrice", Order.DESCENDING);
query.limit(1);
List&amp;lt;Ad&amp;gt; ads = mongoTemplate.find(query, Ad.class);
Ad ad = ads.isEmpty() ? null : ads.get(0);
</description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="319" opendate="2011-11-15 13:50:15" fixdate="2011-11-15 13:56:01" resolution="Complete">
		<buginformation>
			<summary>WriteConcern not parsed correctly in namespace handlers</summary>
			<description>The WriteConcern strings (SAFE, NONE, etc..) was not being parsed correctly, probably a wrong assumption it was an enum and the test case was only testing the at the bean definition level, not instantiating the MongoDbFactory to check its value.</description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.config.MongoParser.java</file>
			<file type="M">org.springframework.data.mongodb.config.MongoDbFactoryParserIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.config.MongoDbFactoryParser.java</file>
			<file type="M">org.springframework.data.mongodb.core.SimpleMongoDbFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="309" opendate="2011-10-31 09:17:17" fixdate="2011-11-23 01:38:15" resolution="Fixed">
		<buginformation>
			<summary>POJO containing a List of Maps not persisting properly</summary>
			<description>I&amp;amp;apos;m trying to represent a JSON structure that looks like this:






{"id": "abc123", "listOfMaps" : [ { "aString" : "aValue" , "anArray" : { "anotherValue"}}]}






But when I create a POJO and matching Repository to persist it, the Map containing a List of Strings does not persist properly. I&amp;amp;apos;ve attached a screenshot from my debugger to show what it looks like in memory. When converted to a String using a MongoTemplate, it looks like:






{ "_class" : "com.foo.MyPojo" , "_id" : { "$oid" : "4eaec52bad108fb6c5ecde5a"} , "listOfMaps" : [ { "aString" : "aValue" , "anArray" : { "_class" : "[[Ljava.lang.String;"}}]}






Note that I&amp;amp;apos;m losing the values in "anArray".
This is using 1.0.0M5. I&amp;amp;apos;ve included a full unit test. Should just need to set appropriate MongoDB server settings in the Spring config file to get it running.</description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="312" opendate="2011-11-06 09:34:29" fixdate="2011-11-23 03:04:56" resolution="Fixed">
		<buginformation>
			<summary>Cannot retrieve persisted Enum implementing an abstract method</summary>
			<description>I have the following sample model with enum values implementing an abstract method:






Entity.java






@Document




public class Entity {




    private String id;




    private ImAnEnum testEnums = ImAnEnum.ONE;









    public String getId() {




        return id;




    }




}












ImAnEnum.java






@Document




public enum ImAnEnum {




    ONE {




        @Override




        boolean somethingToDo() {




            return false;




        }




    },




    TWO {




        @Override




        boolean somethingToDo() {




            return false;




        }




    },




    THREE {




        @Override




        boolean somethingToDo() {




            return true;




        }




    };









    abstract boolean somethingToDo();




}






When I save the entity the document looks like:






db document






{




	"_id" : ObjectId("4eb6bf6ef5981c320579e48b"),




	"_class" : "com.sejda.persistence.MongoTestEnum$Entity",




	"testEnums" : {




		"_class" : "com.sejda.persistence.MongoTestEnum$ImAnEnum$1",




		"name" : "ONE",




		"ordinal" : 0




	}




}






and when I run: 






 Entity foundEntity = mongoOps.findById(entity.getId(), Entity.class);






I get the following exception:






org.springframework.data.mapping.model.MappingInstantiationException: Could not instantiate bean class [com.sejda.persistence.MongoTestEnum$ImAnEnum$1]: Illegal arguments for constructor; nested exception is java.lang.IllegalArgumentException: Cannot reflectively create enum objects




	at org.springframework.data.mapping.model.BeanWrapper.&amp;lt;init&amp;gt;(BeanWrapper.java:122)




	at org.springframework.data.mapping.model.BeanWrapper.create(BeanWrapper.java:73)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:255)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:203)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.getValueInternal(MappingMongoConverter.java:762)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter$2.doWithPersistentProperty(MappingMongoConverter.java:268)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter$2.doWithPersistentProperty(MappingMongoConverter.java:258)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:173)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:258)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:203)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:171)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:77)




	at org.springframework.data.mongodb.core.MongoTemplate$ReadDbObjectCallback.doWith(MongoTemplate.java:1505)




	at org.springframework.data.mongodb.core.MongoTemplate.executeFindOneInternal(MongoTemplate.java:1237)




	at org.springframework.data.mongodb.core.MongoTemplate.doFindOne(MongoTemplate.java:1081)




	at org.springframework.data.mongodb.core.MongoTemplate.findById(MongoTemplate.java:478)




	at org.springframework.data.mongodb.core.MongoTemplate.findById(MongoTemplate.java:471)




	at com.sejda.persistence.MongoTestEnum.testInsertAndRetrieve(MongoTestEnum.java:37)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)




	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:74)




	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:82)




	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:231)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)




	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)




	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:300)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:174)




	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:49)




	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)




Caused by: org.springframework.beans.BeanInstantiationException: Could not instantiate bean class [com.sejda.persistence.MongoTestEnum$ImAnEnum$1]: Illegal arguments for constructor; nested exception is java.lang.IllegalArgumentException: Cannot reflectively create enum objects




	at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:137)




	at org.springframework.data.mapping.model.BeanWrapper.&amp;lt;init&amp;gt;(BeanWrapper.java:120)




	... 45 more




Caused by: java.lang.IllegalArgumentException: Cannot reflectively create enum objects




	at java.lang.reflect.Constructor.newInstance(Constructor.java:511)




	at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:126)




	... 46 more















</description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="329" opendate="2011-11-30 00:50:07" fixdate="2011-11-30 07:24:31" resolution="Fixed">
		<buginformation>
			<summary>Map value not converted correctly</summary>
			<description>





public class A&amp;lt;T&amp;gt; implements Serializable {









	private String valueType;




	private T value;









	public A(T value) {




		this.valueType = value.getClass().getName();




		this.value = value;




	}




}












Map&amp;lt;String, A&amp;lt;String&amp;gt;&amp;gt; objectToSave = new HashMap&amp;lt;String, A&amp;lt;String&amp;gt;&amp;gt;();




objectToSave.put("test", new A&amp;lt;String&amp;gt;("testValue"));









A&amp;lt;Map&amp;lt;String, A&amp;lt;String&amp;gt;&amp;gt;&amp;gt; a = new A&amp;lt;Map&amp;lt;String, A&amp;lt;String&amp;gt;&amp;gt;&amp;gt;(objectToSave);




DBObject result = new BasicDBObject();









converter.write(a, result);












{ "_id" : ObjectId("4ebbae36d0ab5ef4ac6b0533"), 




  "_class" : "foo.bar.A", 




  "valueType" : "java.util.HashMap", 




  "value" : { "_class" : "java.util.HashMap", 




              "threshold" : 12, 




              "loadFactor" : 0.75 } 




}





</description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="331" opendate="2011-11-30 07:30:59" fixdate="2011-11-30 09:35:05" resolution="Fixed">
		<buginformation>
			<summary>Wrong enumeration value in schema</summary>
			<description>In the XML schema for spring mongo  http://www.springframework.org/schema/data/mongo/spring-mongo-1.0.xsd in the restricted values for write-concern attribute there is REPLICA_SAFE while in the java  type (com.mongodb.WriteConcern) the name is REPLICAS_SAFE , please either change the schema or the class to the appropriate form.</description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.config.MongoDbFactoryParserIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="325" opendate="2011-11-20 19:18:58" fixdate="2011-11-30 14:03:02" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate fails to correctly report a js file not found on classpath while calling mapReduce</summary>
			<description>Consider the follwoing code snippet:






String mapFunction = "classpath:js/map.js";




String reduceFunction = "classpath:js/reduce.js";




MapReduceOptions mapReduceOptions = new MapReduceOptions();




mapReduceOptions.outputCollection("outColl");









MapReduceResults&amp;lt;MRResult&amp;gt; results =mongo.mapReduce("myColl", mapFunction, reduceFunction, mapReduceOptions, MRResult.class);






If map.js or reduce.js are not found on the classpath, function replaceWithResourceIfNecessary silently ignores this and considers the string classpath:map.js as the map function. Following debug statement is printed which is not very helpful and does not create any suspicion.






2011-11-21 08:20:27,906 [main] DEBUG org.springframework.data.mongodb.core.MongoTemplate - Executing MapReduce on collection [myColl], mapFunction [classpath:map.js], reduceFunction [classpath:reduce.js]






This leads to the following error which is also not helpful in debugging:






2011-11-21 08:20:27,926 [main] WARN  org.springframework.data.mongodb.core.MongoTemplate - Command execution of { "mapreduce" : "myColl" , "map" : "classpath:map.js" , "reduce" : "classpath:reduce.js" , "verbose" : true , "out" : { "replace" : "outColl"}} failed: db assertion failure






Error description on the mongod log is also useless:






Mon Nov 21 08:20:27 [conn9] JS Error: SyntaxError: missing ; before statement nofile_a:0




Mon Nov 21 08:20:27 [conn9] mr failed, removing collection :: caused by :: 13598 couldn&amp;amp;apos;t compile code for: _map






So, it becomes really hard to debug that the real problem is missing js file on the classpath.
Catching and ignoring exception in method protected String replaceWithResourceIfNecessary(String function) is a bad thing to do.











} catch (Exception e) {




	// ignore - could be embedded JavaScript text




}





</description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="333" opendate="2011-12-01 02:28:06" fixdate="2011-12-01 08:07:16" resolution="Fixed">
		<buginformation>
			<summary>AbstractMongoEventListener throws NullPointerException if used without generic parameter</summary>
			<description>There&amp;amp;apos;s unguarded access to domainClass in AbstractMongoEventListener.onApplicationEvent() although it could be null in case the type lookup in the constructor fails. We should default that to Object.</description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.mapping.event.AbstractMongoEventListenerUnitTest.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.event.AbstractMongoEventListener.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">104</link>
		</links>
	</bug>
	<bug id="321" opendate="2011-11-17 01:53:43" fixdate="2011-12-01 08:54:08" resolution="Fixed">
		<buginformation>
			<summary>An ID field of type integer is always saved as zero if not set by the user before calling save.  Throw exception to indicate an int field will not be autopopulated.</summary>
			<description>int id is saved as string.</description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.AbstractMongoConverter.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.CustomConversions.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.QueryMapperUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">322</link>
		</links>
	</bug>
	<bug id="199" opendate="2011-07-19 05:40:40" fixdate="2011-12-06 04:46:47" resolution="Fixed">
		<buginformation>
			<summary>Synchronisation during performance tests</summary>
			<description>Hi, 
During performance tests, I observed that several threads were in status "blocked". Below, the stack:
The tests were carried out with jmeter with read-only queries.
""http-bio-8080"-exec-52" - Thread t@115
   java.lang.Thread.State: BLOCKED
	at java.lang.reflect.Field.declaredAnnotations(Field.java:1013)

waiting to lock &amp;lt;27df34b4&amp;gt; (a java.lang.reflect.Field) owned by ""http-bio-8080"-exec-31" t@94
	at java.lang.reflect.Field.getAnnotation(Field.java:1000)
	at java.lang.reflect.AccessibleObject.isAnnotationPresent(AccessibleObject.java:168)
	at org.springframework.data.mapping.AnnotationBasedPersistentProperty.isTransient(AnnotationBasedPersistentProperty.java:74)
	at org.springframework.data.mapping.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:111)
	at org.springframework.data.document.mongodb.convert.MappingMongoConverter.read(MappingMongoConverter.java:230)
	at org.springframework.data.document.mongodb.convert.MappingMongoConverter.read(MappingMongoConverter.java:174)
	at org.springframework.data.document.mongodb.convert.MappingMongoConverter.read(MappingMongoConverter.java:128)
	at org.springframework.data.document.mongodb.MongoTemplate$ReadDbObjectCallback.doWith(MongoTemplate.java:1655)
	at org.springframework.data.document.mongodb.MongoTemplate.executeFindMultiInternal(MongoTemplate.java:1426)
	at org.springframework.data.document.mongodb.MongoTemplate.doFind(MongoTemplate.java:1186)
	at org.springframework.data.document.mongodb.MongoTemplate.find(MongoTemplate.java:587)
	at org.springframework.data.document.mongodb.MongoTemplate.find(MongoTemplate.java:557)
	at $MongoOperations_1314237160b.find($MongoOperations_1314237160b.java)

</description>
			<version>1.0 M3</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.mapping.CachingMongoPersistentProperty.java</file>
		</fixedFiles>
	</bug>
	<bug id="318" opendate="2011-11-11 09:25:56" fixdate="2011-12-06 06:24:58" resolution="Fixed">
		<buginformation>
			<summary>Distinguishing write errors and writes with zero documents affected</summary>
			<description>Currently MongoTemplate.handleAnyWriteResultErrors(...) have the same behavior for write errors and zero writes (conditional updates with zero documents affected) which is not always convenient because there are cases when zero write is not an error.
Examples:

Optimistic lock for update http://www.mongodb.org/display/DOCS/Atomic+Operations#AtomicOperations-%22UpdateifCurrent%22
Updating something in concurrent environment.

Sometimes best solution is to silently ignore updating or deleting of missed document but still throw in case of DB errors.</description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="322" opendate="2011-11-17 01:56:47" fixdate="2011-12-06 10:44:13" resolution="Fixed">
		<buginformation>
			<summary>Throw exception in a save operation if the POJO&amp;apos;s ID field is null and field type is not String, BigInteger or ObjectId.</summary>
			<description>findById with int type id returns null.</description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.support.MongoRepositoryFactory.java</file>
			<file type="M">org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.MongoSimpleTypes.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">321</link>
		</links>
	</bug>
	<bug id="298" opendate="2011-10-14 16:45:47" fixdate="2011-12-12 06:17:38" resolution="Fixed">
		<buginformation>
			<summary>Spring custom converters do not work for subclasses of java.lang.Number</summary>
			<description>The detail description can be found in here
http://forum.springsource.org/showthread.php?115419-Custom-convertor-from-a-non-primitive-class-to-Integer</description>
			<version>1.0 M4</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.CustomConversions.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.CustomConversionsUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.MongoSimpleTypes.java</file>
		</fixedFiles>
	</bug>
	<bug id="343" opendate="2011-12-08 04:04:19" fixdate="2011-12-12 09:05:59" resolution="Fixed">
		<buginformation>
			<summary>ServerAddressPropertyEditor disables default Spring conversion</summary>
			<description>After upgrading to 1.0 RC1, we are getting the following error on an unrelated bean






java.lang.IllegalArgumentException: Cannot convert value of type [java.util.HashMap$Values] to required type [java.util.List]: PropertyEditor [org.springframework.data.mongodb.config.ServerAddressPropertyEditor] returned inappropriate value






The exception is thrown on a bean that has @Autowired List constructor argument where the values of the List are collected from the Spring context. (Basically, we want to inject all beans of given type). This bean has nothing to do with Mongo but when the ServerAddressPropertyEditor is defined, it&amp;amp;apos;s used for all conversions to java.util.List. It is not correct.</description>
			<version>1.0 RC1</version>
			<fixedVersion>1.0 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.config.MongoParserIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.config.MongoParser.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoFactoryBean.java</file>
			<file type="M">org.springframework.data.mongodb.config.ServerAddressPropertyEditor.java</file>
			<file type="M">org.springframework.data.mongodb.config.ParsingUtils.java</file>
			<file type="M">org.springframework.data.mongodb.config.MongoDbFactoryParser.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">344</link>
		</links>
	</bug>
	<bug id="346" opendate="2011-12-10 04:44:04" fixdate="2011-12-14 11:32:32" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate.remove(Object arg) not working</summary>
			<description>Method remove(Object arg) in org.springframework.data.mongodb.core.MongoOperations not working in spring-data-mongodb older 1.0.0.M4.</description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">349</link>
		</links>
	</bug>
	<bug id="260" opendate="2011-09-05 01:06:36" fixdate="2011-12-21 23:35:41" resolution="Fixed">
		<buginformation>
			<summary>MapReduce fails when using with Long as key-type.</summary>
			<description>MapReduce will fail calling emit with Long as key-type.






class Foo {




  String id;




  Long number;




  Long version;




} 






Map:






function() {




	emit(this.number, this.version)




}






Reduce:






function(key, values) {




	return Math.max.apply(Math, values);




}






(see http://cookbook.mongodb.org/patterns/finding_max_and_min/)
outputcollection






{




  "_id": 1,




  "value": 2




}






then it tries to convert _id to objectid which fails:






org.springframework.core.convert.ConverterNotFoundException: No converter found capable of converting from &amp;amp;apos;java.lang.Long&amp;amp;apos; to &amp;amp;apos;java.lang.String&amp;amp;apos;




	at org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:155)




	at org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:127)




	at org.springframework.data.mapping.model.BeanWrapper.getPotentiallyConvertedValue(BeanWrapper.java:221)




	at org.springframework.data.mapping.model.BeanWrapper.setProperty(BeanWrapper.java:155)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter$2.doWithPersistentProperty(MappingMongoConverter.java:260)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter$2.doWithPersistentProperty(MappingMongoConverter.java:248)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:160)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:248)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:193)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:161)




	at org.springframework.data.mongodb.core.MongoTemplate$ReadDbObjectCallback.doWith(MongoTemplate.java:1462)




	at org.springframework.data.mongodb.core.MongoTemplate.mapReduce(MongoTemplate.java:885)




	at org.springframework.data.mongodb.core.MongoTemplate.mapReduce(MongoTemplate.java:841)





</description>
			<version>1.0 M4</version>
			<fixedVersion>1.0 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.AbstractMongoConverter.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapreduce.MapReduceTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="336" opendate="2011-12-03 19:39:17" fixdate="2011-12-22 23:39:46" resolution="Fixed">
		<buginformation>
			<summary>MongoDB GeoNear returning  null pointer exception when giving data more precision than test data</summary>
			<description>When i give data as per test (geoSpatialTest.java) its returning  results. But when I input more precision data from google map data its giving null pointer exception. 
(1.4377786502730732,103.78692984580994)
But when i try in mongodb intractive consol its returning values . 
Could you please investigate . </description>
			<version>1.0 M5</version>
			<fixedVersion>1.0 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.geo.GeoSpatialTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="373" opendate="2012-01-09 14:35:14" fixdate="2012-01-11 11:20:42" resolution="Fixed">
		<buginformation>
			<summary>QueryMapper is getting a ClassCasteException When trying to Convert an ArrayList to a BSONList</summary>
			<description>I am using Mongodb java driver (mongo-java-driver - 2.7.2) to create a Query using QueryBuilder and then using QueryBuilder to get the DBObject to create a BasicQuery; then using MongoTemplate&amp;amp;apos;s find method by passing the BasicQuery Object.  Getting a ClassCastException in QueryMapper - trying cast an ArrayList to a BasicBSONList.  Using version 1.0.0.M4.  It would be nice if a patch is applied to this version??  Attached is the changes I made in order to make it work.</description>
			<version>1.0 GA</version>
			<fixedVersion>1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.QueryMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="369" opendate="2012-01-02 07:47:13" fixdate="2012-01-12 02:27:14" resolution="Fixed">
		<buginformation>
			<summary>Wrong query created when one value is a DBObject</summary>
			<description>Regression in 1.0.0-RELEASE. Works as expected in 1.0.0-RC1
Query: { "type" : 
{ "$in" : [ "folder"]}
 , "deleted" : false }
When a query contains a DBObject as a value like "type" in the example QueryMapper.getMappedObject will return in line 103 ignoring all further keys of the query.
This results in the query { "type" : 
{ "$in" : [ "folder"]}
 } sent to MongoDB.
</description>
			<version>1.0 GA</version>
			<fixedVersion>1.0.1, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.QueryMapperUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">381</link>
			<link type="Duplicate" description="is duplicated by">430</link>
			<link type="Relate" description="relates to">363</link>
			<link type="Relate" description="relates to">364</link>
			<link type="Relate" description="relates to">393</link>
			<link type="Relate" description="relates to">417</link>
		</links>
	</bug>
	<bug id="376" opendate="2012-01-12 03:10:01" fixdate="2012-01-12 03:51:50" resolution="Fixed">
		<buginformation>
			<summary>Fix potential NPE in SpringDataMongodbSerializer</summary>
			<description>We currently run into a NPE in case no property with the to-string expression is found. This is inevitably the case if an any() expression is used in the predicate because of the way visit() is implemented in the superclass. I&amp;amp;apos;ve opened a ticket against Querydsl to prevent the invocation (as it doesn&amp;amp;apos;t seem necessary) but we should guard against the issue nevertheless.</description>
			<version>1.0 GA</version>
			<fixedVersion>1.0.1, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializerUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.support.QueryDslMongoRepository.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">359</link>
		</links>
	</bug>
	<bug id="368" opendate="2012-01-02 04:54:21" fixdate="2012-01-12 11:55:21" resolution="Fixed">
		<buginformation>
			<summary>Empty values in collections are not supported</summary>
			<description>Using the MongoDB command line it is possible to insert null values as part of a collection:






&amp;gt; db.test.insert({x: [1,2,3,null,3,2,3,4]})






In the result it will still be visible:






&amp;gt; db.test.find()




{ "_id" : ObjectId("4f01a3cb41e58d141d6c06ab"), "x" : [ 1, 2, 3, null, 3, 2, 3, 4 ] }






Using Spring Data (RC1) the null values are removed by the MappingMongoConverter.writeCollectionInternal(Collection&amp;lt;?&amp;gt; source, TypeInformation&amp;lt;?&amp;gt; type, BasicDBList sink) method.
For sample code:






List&amp;lt;Number&amp;gt; al = new ArrayList&amp;lt;Number&amp;gt;();




al.add(1);




al.add(null);




al.add(2);




Test test = new Test();




test.setX(al);




operations.insert(test, "test2");






The result is:






&amp;gt; db.test2.find()




{ "_id" : ObjectId("4f01a50d3372f368908a571a"), "_class" : "nl.eid.dashboard.mvc.ajax.dashboard.Test", "x" : [ 1, 2 ] }






I would expect the null value in the result. The writeCollectionInternal() method should not remove the null values.</description>
			<version>1.0 GA</version>
			<fixedVersion>1.0.1, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="359" opendate="2011-12-23 14:22:07" fixdate="2012-01-16 11:59:43" resolution="Duplicate">
		<buginformation>
			<summary>Collection any() paths can&amp;apos;t be treated as property paths.</summary>
			<description>NPE in QueryDslMongoRepository after M4 - RC1 upgrade 
Example code, variable state and stacktraces nicely formatted in the reference forum post.
Timo Westkmper from QDSL has indicated this is a bug in Spring Data https://groups.google.com/forum/#!topic/querydsl/bZVxc4v0NPk</description>
			<version>1.0 GA</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializerUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.support.QueryDslMongoRepository.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">376</link>
		</links>
	</bug>
	<bug id="381" opendate="2012-01-17 17:01:36" fixdate="2012-01-22 22:27:19" resolution="Duplicate">
		<buginformation>
			<summary>Querying criteria for "$in" on enum field gets lost in QueryMapper</summary>
			<description>As I was updating my project from M5 to GA, some of my tests started failing. It seemed that "$in" stopped working because I was getting an unfiltered result set back. I was able to trace the problem to QueryMapper.
Before it goes in, the DBOBject for query.getCriteriaObject()&amp;amp;apos;s toString() shows:






{




"cardId" : "12345" , 




"interactionTime" : { "$lte" : { "$date" : "2012-01-18T00:44:06.469Z"}} , 




"isDeleted" : false , 




"actionCode" : { "$in" : [ "AVATAR_STAND"]} , 




"sourcePersonId" : { "$in" : [ "4f1615cb036416a89c12a60f"]}




}






after query mapper, when it gets passed into new FindCallback(...), the query DBObject is reduced to only the following:






{




"cardId" : "12345" , 




"interactionTime" : { "$lte" : { "$date" : "2012-01-18T00:44:06.469Z"}}




}






So I&amp;amp;apos;m not sure exactly what I&amp;amp;apos;m doing wrong / missing, but something between M5 and GA must&amp;amp;apos;ve changed. Any pointers?
Here&amp;amp;apos;s part of my class, in case it&amp;amp;apos;s any help:






@Document




public class CardInteraction {




  @Id private String interactionId;




  private String cardId;




  private String sourcePersonId;




  private ActionCodeEnum actionCode; // a java enum class




  private Date interactionTime;




  private boolean isDeleted;









  ...




}





</description>
			<version>1.0 GA</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.QueryMapperUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">369</link>
		</links>
	</bug>
	<bug id="387" opendate="2012-02-01 05:16:08" fixdate="2012-02-01 05:46:00" resolution="Fixed">
		<buginformation>
			<summary>Executing query methods with GeoPage results doesn&amp;apos;t work</summary>
			<description>When using GeoPage as return value for repository query methods we run into a ClassCastException.






org.springframework.data.mongodb.core.geo.GeoResults cannot be cast to org.springframework.data.mongodb.core.geo.GeoPage





</description>
			<version>1.0 GA</version>
			<fixedVersion>1.0.1, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQuery.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreator.java</file>
			<file type="M">org.springframework.data.mongodb.repository.AbstractPersonRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.PartTreeMongoQuery.java</file>
			<file type="M">org.springframework.data.mongodb.repository.PersonRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="358" opendate="2011-12-23 10:10:13" fixdate="2012-02-01 07:32:31" resolution="Fixed">
		<buginformation>
			<summary>Nested List does not work anymore for a @Document</summary>
			<description>An object that looks like this:
@Document
Item {
  List&amp;lt;Attribute&amp;gt; attributes;
}
Attribute {
  String key;
  Object value;
}
E.g.
Item item = new Item();
List&amp;lt;Attribute&amp;gt; list = new ArrayList&amp;lt;Attribute&amp;gt;();
Attribute attribute = new Attribute();
attribute.setKey("key");
List&amp;lt;String&amp;gt; valueList = new ArrayList();
valueList.add("1");
valueList.add("2");
attribute.setValue(valueList);
If you persist that Document and retrieve it again, the valueList List is now just an Object reference with no data.
If you create an Attribute where the value is a List it now fails to convert that property back to a list. 
This used to work up until M5.</description>
			<version>1.0 GA</version>
			<fixedVersion>1.0.1, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">370</link>
		</links>
	</bug>
	<bug id="385" opendate="2012-01-26 05:13:31" fixdate="2012-02-02 01:41:00" resolution="Fixed">
		<buginformation>
			<summary>MongoRepositoryFactory does not support id classes of type java.lang.Long</summary>
			<description>It is not possible to use a MongoRepository with Long id class:






public interface TestRepository extends MongoRepository&amp;lt;TestEntity, Long&amp;gt; {  }












@Document




public class TestEntity




{




  @Id




  private Long id;




  




}





</description>
			<version>1.0 RC1</version>
			<fixedVersion>1.0 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="398" opendate="2012-02-10 07:11:53" fixdate="2012-02-10 07:22:05" resolution="Duplicate">
		<buginformation>
			<summary>Fails to store org.osgi.service.event.Event</summary>
			<description>When I attempt to save an object from org.apache.felix&amp;amp;apos;s versions of org.osgi.service.event.Event, the stack trace below occurs. This appears to be due to the system attempting to save the topic field in Event as event.topics. If anyone could confirm this as a bug, or tell me what I am doing wrong that would be great.
I am using the following dependency versions






&amp;lt;dependency&amp;gt;




    &amp;lt;groupId&amp;gt;org.apache.felix&amp;lt;/groupId&amp;gt;




    &amp;lt;artifactId&amp;gt;org.osgi.core&amp;lt;/artifactId&amp;gt;




    &amp;lt;version&amp;gt;1.4.0&amp;lt;/version&amp;gt;




&amp;lt;/dependency&amp;gt;









&amp;lt;dependency&amp;gt;




    &amp;lt;groupId&amp;gt;org.springframework.data&amp;lt;/groupId&amp;gt;




    &amp;lt;artifactId&amp;gt;spring-data-mongodb&amp;lt;/artifactId&amp;gt;




    &amp;lt;version&amp;gt;1.0.0.RELEASE&amp;lt;/version&amp;gt;




&amp;lt;/dependency&amp;gt;









&amp;lt;dependency&amp;gt;




    &amp;lt;groupId&amp;gt;org.apache.felix&amp;lt;/groupId&amp;gt;




    &amp;lt;artifactId&amp;gt;org.osgi.compendium&amp;lt;/artifactId&amp;gt;




    &amp;lt;version&amp;gt;1.4.0&amp;lt;/version&amp;gt;




&amp;lt;/dependency&amp;gt;












org.osgi.framework.BundleException: Exception in myproject.bundle.dbtest.Activator.start() of bundle myproject.bundle.dbtest.policy-db-test.




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.startActivator(BundleContextImpl.java:806)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.start(BundleContextImpl.java:755)




	at org.eclipse.osgi.framework.internal.core.BundleHost.startWorker(BundleHost.java:370)




	at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:284)




	at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:276)




	at org.eclipse.osgi.framework.internal.core.FrameworkCommandProvider._start(FrameworkCommandProvider.java:252)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:616)




	at org.eclipse.osgi.framework.internal.core.FrameworkCommandInterpreter.execute(FrameworkCommandInterpreter.java:155)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.docommand(FrameworkConsole.java:156)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.runConsole(FrameworkConsole.java:141)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.run(FrameworkConsole.java:105)




	at java.lang.Thread.run(Thread.java:679)




Caused by: java.lang.IllegalArgumentException: fields stored in the db can&amp;amp;apos;t have . in them. (Bad Key: &amp;amp;apos;event.topics&amp;amp;apos;)




	at com.mongodb.DBCollection.validateKey(DBCollection.java:1213)




	at com.mongodb.DBCollection._checkKeys(DBCollection.java:1181)




	at com.mongodb.DBCollection._checkKeys(DBCollection.java:1184)




	at com.mongodb.DBCollection._checkObject(DBCollection.java:1171)




	at com.mongodb.DBCollection.save(DBCollection.java:718)




	at com.mongodb.DBCollection.save(DBCollection.java:703)




	at org.springframework.data.mongodb.core.MongoTemplate$11.doInCollection(MongoTemplate.java:790)




	at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:368)




	at org.springframework.data.mongodb.core.MongoTemplate.saveDBObject(MongoTemplate.java:784)




	at org.springframework.data.mongodb.core.MongoTemplate.doSave(MongoTemplate.java:720)




	at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:707)




	at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:703)




	at myproject.bundle.db.PolicyDb.updatePolicy(PolicyDb.java:32)




	at myproject.bundle.dbtest.Activator.start(Activator.java:21)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl$1.run(BundleContextImpl.java:783)




	at java.security.AccessController.doPrivileged(Native Method)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.startActivator(BundleContextImpl.java:774)




	... 14 more




Nested Exception:




java.lang.IllegalArgumentException: fields stored in the db can&amp;amp;apos;t have . in them. (Bad Key: &amp;amp;apos;event.topics&amp;amp;apos;)




	at com.mongodb.DBCollection.validateKey(DBCollection.java:1213)




	at com.mongodb.DBCollection._checkKeys(DBCollection.java:1181)




	at com.mongodb.DBCollection._checkKeys(DBCollection.java:1184)




	at com.mongodb.DBCollection._checkObject(DBCollection.java:1171)




	at com.mongodb.DBCollection.save(DBCollection.java:718)




	at com.mongodb.DBCollection.save(DBCollection.java:703)




	at org.springframework.data.mongodb.core.MongoTemplate$11.doInCollection(MongoTemplate.java:790)




	at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:368)




	at org.springframework.data.mongodb.core.MongoTemplate.saveDBObject(MongoTemplate.java:784)




	at org.springframework.data.mongodb.core.MongoTemplate.doSave(MongoTemplate.java:720)




	at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:707)




	at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:703)




	at myproject.bundle.db.PolicyDb.updatePolicy(PolicyDb.java:32)




	at myproject.bundle.dbtest.Activator.start(Activator.java:21)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl$1.run(BundleContextImpl.java:783)




	at java.security.AccessController.doPrivileged(Native Method)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.startActivator(BundleContextImpl.java:774)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.start(BundleContextImpl.java:755)




	at org.eclipse.osgi.framework.internal.core.BundleHost.startWorker(BundleHost.java:370)




	at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:284)




	at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:276)




	at org.eclipse.osgi.framework.internal.core.FrameworkCommandProvider._start(FrameworkCommandProvider.java:252)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:616)




	at org.eclipse.osgi.framework.internal.core.FrameworkCommandInterpreter.execute(FrameworkCommandInterpreter.java:155)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.docommand(FrameworkConsole.java:156)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.runConsole(FrameworkConsole.java:141)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.run(FrameworkConsole.java:105)




	at java.lang.Thread.run(Thread.java:679)




Nested Exception:




java.lang.IllegalArgumentException: fields stored in the db can&amp;amp;apos;t have . in them. (Bad Key: &amp;amp;apos;event.topics&amp;amp;apos;)




	at com.mongodb.DBCollection.validateKey(DBCollection.java:1213)




	at com.mongodb.DBCollection._checkKeys(DBCollection.java:1181)




	at com.mongodb.DBCollection._checkKeys(DBCollection.java:1184)




	at com.mongodb.DBCollection._checkObject(DBCollection.java:1171)




	at com.mongodb.DBCollection.save(DBCollection.java:718)




	at com.mongodb.DBCollection.save(DBCollection.java:703)




	at org.springframework.data.mongodb.core.MongoTemplate$11.doInCollection(MongoTemplate.java:790)




	at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:368)




	at org.springframework.data.mongodb.core.MongoTemplate.saveDBObject(MongoTemplate.java:784)




	at org.springframework.data.mongodb.core.MongoTemplate.doSave(MongoTemplate.java:720)




	at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:707)




	at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:703)




	at myproject.bundle.db.PolicyDb.updatePolicy(PolicyDb.java:32)




	at myproject.bundle.dbtest.Activator.start(Activator.java:21)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl$1.run(BundleContextImpl.java:783)




	at java.security.AccessController.doPrivileged(Native Method)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.startActivator(BundleContextImpl.java:774)




	at org.eclipse.osgi.framework.internal.core.BundleContextImpl.start(BundleContextImpl.java:755)




	at org.eclipse.osgi.framework.internal.core.BundleHost.startWorker(BundleHost.java:370)




	at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:284)




	at org.eclipse.osgi.framework.internal.core.AbstractBundle.start(AbstractBundle.java:276)




	at org.eclipse.osgi.framework.internal.core.FrameworkCommandProvider._start(FrameworkCommandProvider.java:252)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:616)




	at org.eclipse.osgi.framework.internal.core.FrameworkCommandInterpreter.execute(FrameworkCommandInterpreter.java:155)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.docommand(FrameworkConsole.java:156)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.runConsole(FrameworkConsole.java:141)




	at org.eclipse.osgi.framework.internal.core.FrameworkConsole.run(FrameworkConsole.java:105)




	at java.lang.Thread.run(Thread.java:679)





</description>
			<version>1.0 GA</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">380</link>
		</links>
	</bug>
	<bug id="401" opendate="2012-02-11 05:31:10" fixdate="2012-02-11 07:01:43" resolution="Fixed">
		<buginformation>
			<summary>StringBasedMongoQuery suffers from NullPointerException in case a null parameter gets bound to a parameter placeholder</summary>
			<description>Given a repository:






private interface SampleRepository extends Repository&amp;lt;Person, Long&amp;gt; {









  @Query("{ &amp;amp;apos;lastname&amp;amp;apos; : ?0 }")




  Person findByLastname(String lastname);




}






when you call the repository method as follows:






repo.findByLastname(null);






one is currently getting:






java.lang.NullPointerException




  at org.springframework.data.mongodb.repository.query. StringBasedMongoQuery.getParameterWithIndex(StringBasedMongoQuery.java:103)




  at org.springframework.data.mongodb.repository.query. StringBasedMongoQuery.replacePlaceholders(StringBasedMongoQuery.java:95)





</description>
			<version>1.0 GA</version>
			<fixedVersion>1.0.1, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQueryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="411" opendate="2012-03-02 00:07:05" fixdate="2012-03-04 00:53:11" resolution="Fixed">
		<buginformation>
			<summary>Potential ClassCastExceptions in MongoPersistentEntityIndexCreator</summary>
			<description>The Spring ApplicationEvent mechanism uses some mechanism to select event listeners based on generic types. Unfortunately it does not consider nested generic types which we use to distinguish a mapping event for MongoDB from one for Neo4j e.g. Thus the MongoPersistentEntityIndexCreator will get invoked for mapping events for other stores as well. Thus we have to double check the event types before invoking further code.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.java</file>
		</fixedFiles>
	</bug>
	<bug id="382" opendate="2012-01-17 17:18:11" fixdate="2012-03-06 23:25:33" resolution="Fixed">
		<buginformation>
			<summary>ClassCastException: "com.mongodb.BasicDBObject cannot be cast to com.mongodb.BasicDBList" during find()</summary>
			<description>While upgrading from M5 to GA I started getting this error in my tests:






java.lang.ClassCastException: com.mongodb.BasicDBObject cannot be cast to com.mongodb.BasicDBList




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.writeInternal(MappingMongoConverter.java:324)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.write(MappingMongoConverter.java:294)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.convertToMongoType(MappingMongoConverter.java:850)




	at org.springframework.data.mongodb.core.QueryMapper.getMappedObject(QueryMapper.java:106)




	at org.springframework.data.mongodb.core.QueryMapper.getMappedObject(QueryMapper.java:102)




	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:1259)




	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:1248)




	at org.springframework.data.mongodb.core.MongoTemplate.find(MongoTemplate.java:471)




	at net.emota.together.service.PersonService.createOrUpdateGroupPersons(PersonService.java:372)




	at net.emota.together.core.itest.service.PersonServiceIT.createOrUpdateGroupPersons(PersonServiceIT.java:303)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)




	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)




	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:74)




	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:31)




	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:82)




	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:231)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)




	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)




	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:174)




	at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:53)




	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:123)




	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:104)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:164)




	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:110)




	at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:175)




	at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcessWhenForked(SurefireStarter.java:107)




	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:68)






The query I am using is simple (and involves $in, maybe releated to my previous issue?):






{




"fbUserId" : { "$in" : [ "88888" , "ABCDE" , "12345"]}




}





</description>
			<version>1.0 GA</version>
			<fixedVersion>1.0.2, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">473</link>
		</links>
	</bug>
	<bug id="360" opendate="2011-12-23 16:33:37" fixdate="2012-03-08 03:19:58" resolution="Fixed">
		<buginformation>
			<summary>java.lang.ClassCastException when placing GeospatialIndex into IndexOperations and invoking IndexOperations.getIndexInfo()</summary>
			<description>





MongoTemplate mongoTemplate = ...




IndexOperations indexOps = mongoTemplate.indexOps(DomainModel.class);




indexOps.ensureIndex(new GeospatialIndex("attributename"));




indexOps.getIndexInfo();






throws:






Caused by: java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer




	at org.springframework.data.mongodb.core.DefaultIndexOperations$4.getIndexData(DefaultIndexOperations.java:140)




	at org.springframework.data.mongodb.core.DefaultIndexOperations$4.doInCollection(DefaultIndexOperations.java:123)




	at org.springframework.data.mongodb.core.DefaultIndexOperations$4.doInCollection(DefaultIndexOperations.java:120)




	at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:368)




	at org.springframework.data.mongodb.core.DefaultIndexOperations.getIndexInfo(DefaultIndexOperations.java:120)






Offending Code: org.springframework.data.mongodb.core.DefaultIndexOperations.java:138











Entry&amp;lt;Object, Integer&amp;gt; thisEntry = (Entry&amp;lt;Object, Integer&amp;gt;) entries.next();











but is actually type: Entry&amp;lt;Object, String&amp;gt; with a value "2d".
</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.RepositoryIndexCreationIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.IndexInfo.java</file>
			<file type="M">org.springframework.data.mongodb.core.geo.GeoSpatialTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.DefaultIndexOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="412" opendate="2012-03-04 18:54:04" fixdate="2012-03-09 02:11:43" resolution="Fixed">
		<buginformation>
			<summary>getUserCredentials() is called twice in AbstractMongoConfiguration::mongoDbFactory()</summary>
			<description>During MongoDbFactory creation in mongoDbFactory(), getUserCredentials() is called twice:






if (getUserCredentials() == null) {




 return new SimpleMongoDbFactory(mongo(), getDatabaseName());




} else {




 return new SimpleMongoDbFactory(mongo(), getDatabaseName(), getUserCredentials());




}






It is almost not worth mentioning, but for pedantic reasons it would be better to do:






UserCredentials userCredentials = getUserCredentials();




if (userCredentials == null) {




 return new SimpleMongoDbFactory(mongo(), getDatabaseName());




} else {




 return new SimpleMongoDbFactory(mongo(), getDatabaseName(), userCredentials);




}






Almost always override of getUserCredentials() would look like:






@Override




public UserCredentials getUserCredentials() {




  return new UserCredentials(..., ...);




}






and there is no need to create UserCredentials twice, even if it only happens during startup.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.config.AbstractMongoConfiguration.java</file>
			<file type="M">org.springframework.data.mongodb.core.TestMongoConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="402" opendate="2012-02-17 00:31:18" fixdate="2012-03-09 06:31:10" resolution="Fixed">
		<buginformation>
			<summary>Inner class not supported</summary>
			<description>Inner class not supported in 1.0.1.GA. It works fine in 1.0.0.GA
java.lang.IllegalArgumentException: No property null found for type class org.test.EnclosingClass$InsideClass
	at org.springframework.data.mapping.PropertyPath.&amp;lt;init&amp;gt;(PropertyPath.java:73)
	at org.springframework.data.mapping.PropertyPath.&amp;lt;init&amp;gt;(PropertyPath.java:92)
	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:312)
	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:294)
	at org.springframework.data.mapping.PropertyPath.from(PropertyPath.java:258)
	at org.springframework.data.mapping.PropertyPath.from(PropertyPath.java:239)
	at org.springframework.data.mongodb.core.convert.MappedConstructor$MappedParameter.&amp;lt;init&amp;gt;(MappedConstructor.java:125)
	at org.springframework.data.mongodb.core.convert.MappedConstructor.&amp;lt;init&amp;gt;(MappedConstructor.java:57)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:212)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:200)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.getValueInternal(MappingMongoConverter.java:713)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter$1.doWithPersistentProperty(MappingMongoConverter.java:230)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter$1.doWithPersistentProperty(MappingMongoConverter.java:220)
	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:173)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:220)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:200)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:164)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:73)
	at org.springframework.data.mongodb.core.MongoTemplate$ReadDbObjectCallback.doWith(MongoTemplate.java:1693)
	at org.springframework.data.mongodb.core.MongoTemplate.executeFindOneInternal(MongoTemplate.java:1405)
	at org.springframework.data.mongodb.core.MongoTemplate.doFindOne(MongoTemplate.java:1224)
	at org.springframework.data.mongodb.core.MongoTemplate.findOne(MongoTemplate.java:455)
	at org.springframework.data.mongodb.core.MongoTemplate.findOne(MongoTemplate.java:450)
	at org.test.InnerClassTest.testInnerClass(InnerClassTest.java:43)</description>
			<version>1.0.1</version>
			<fixedVersion>1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">134</link>
		</links>
	</bug>
	<bug id="413" opendate="2012-03-09 17:21:02" fixdate="2012-03-12 04:51:50" resolution="Fixed">
		<buginformation>
			<summary>Using "Or" in repository query yields a ClassCastException</summary>
			<description>This:
    List&amp;lt;User&amp;gt; findByEmailOrAlias(String email, String alias);
Gives:
2012-03-09 17:19:55,057 [main] DEBUG org.springframework.data.mongodb.repository.query.MongoQueryCreator - Created query { "email" : "a@b.c" , "alias" : "abc" , "$or" : { }}
2012-03-09 17:19:55,062 [main] DEBUG org.springframework.data.mongodb.core.MongoTemplate - find using query: { "email" : "a@b.c" , "$or" : { }} fields: null for class: class com.musicalabs.api.model.User in collection: user
Exception in thread "main" java.lang.ClassCastException: com.mongodb.BasicDBObject cannot be cast to java.lang.Iterable
	at org.springframework.data.mongodb.core.QueryMapper.getMappedObject(QueryMapper.java:92)
	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:1259)
	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:1248)
	at org.springframework.data.mongodb.core.MongoTemplate.find(MongoTemplate.java:471)
	at org.springframework.data.mongodb.repository.query.AbstractMongoQuery$Execution.readCollection(AbstractMongoQuery.java:125)
	at org.springframework.data.mongodb.repository.query.AbstractMongoQuery$CollectionExecution.execute(AbstractMongoQuery.java:142)
	at org.springframework.data.mongodb.repository.query.AbstractMongoQuery.execute(AbstractMongoQuery.java:88)
	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:302)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:202)
	at $Proxy22.findByEmailOrAlias(Unknown Source)
	at com.acme.Fake.main(Fake.java:23)
While that:
    List&amp;lt;User&amp;gt; findByEmailAndAlias(String email, String alias);
works fine.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreator.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreatorUnitTests.java</file>
			<file type="D">org.springframework.data.mongodb.core.query.OrQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="422" opendate="2012-03-27 17:55:34" fixdate="2012-04-02 04:45:15" resolution="Fixed">
		<buginformation>
			<summary>UUIDToBinaryConverter not compatible with mongo java driver</summary>
			<description>UUID to Binary conversion as implemented in spring-data-mongodb converts the UUID to a string and saves it as a mongo Binary with subtype BSON.B_UUID:






return source == null ? null : new Binary(BSON.B_UUID, source.toString().getBytes("UTF-8"));






The java driver reads this value back in with






org.bson.BasicBSONDecoder






case B_UUID:




    if ( totalLen != 16 )




        throw new IllegalArgumentException( "bad data size subtype 3 len: " + totalLen + " != 16");









    long part1 = _in.readLong();




    long part2 = _in.readLong();




    _callback.gotUUID(name, part1, part2);




    return;




}






That obviously does not work because the java driver expects to read in 2 x 8 bytes containing the most and least significant bytes when it encounters the binary subtype BSON.B_UUID. The converter has to save UUIDs as in BasicBSONEncoder (method putUUID, arround line 266 in 2.7.1) in order for this to work.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MongoConvertersUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.CustomConversions.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MongoConverters.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.CustomConversionsUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.MongoSimpleTypes.java</file>
		</fixedFiles>
	</bug>
	<bug id="425" opendate="2012-04-02 04:56:44" fixdate="2012-04-02 09:09:29" resolution="Fixed">
		<buginformation>
			<summary>Binding a Date to a manually defined repository query fails</summary>
			<description>See this StackOverflow question for details.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2, 1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.config.MongoNamespaceIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.Person.java</file>
			<file type="M">org.springframework.data.mongodb.repository.AbstractPersonRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.PersonRepository.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="423" opendate="2012-03-29 06:03:26" fixdate="2012-04-02 11:48:19" resolution="Fixed">
		<buginformation>
			<summary>Criteria.regex should use java.util.Pattern instead of $regex</summary>
			<description>mongod complains about $regex in some cases.  If you try:






DBCollection c = ...




c.find( new BasicDBObject( "x" ,




                new BasicDBObject("$not", new BasicDBObject("$regex", "b") ) ) );






throws this exception:






   com.mongodb.MongoException: can&amp;amp;apos;t use $not with $regex, use BSON regex type instead




	at com.mongodb.MongoException.parse(MongoException.java:82)




	at com.mongodb.DBApiLayer$MyCollection.__find(DBApiLayer.java:312)




	at com.mongodb.DBCursor._check(DBCursor.java:369)




	at com.mongodb.DBCursor._hasNext(DBCursor.java:504)




	at com.mongodb.DBCursor.hasNext(DBCursor.java:529)






while this does not:






DBCollection c = ...




c.find( new BasicDBObject( "x" ,




                new BasicDBObject("$not", Pattern.compile( "b" , Pattern.CASE_INSENSITIVE ) ) ) );





</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.query.Criteria.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.QueryTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="430" opendate="2012-04-10 03:35:56" fixdate="2012-04-10 07:38:52" resolution="Duplicate">
		<buginformation>
			<summary>Query criteria is not considered in the query</summary>
			<description>When I perform a query that includes more than one criteria, only the first criteria is being considered, others are discarded.
An example is attached; When the query is performed by MongoDB driver it works fine, but with Spring, the problem occurs.</description>
			<version>1.0 GA</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.QueryMapperUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">369</link>
		</links>
	</bug>
	<bug id="429" opendate="2012-04-10 02:33:09" fixdate="2012-04-14 04:41:42" resolution="Fixed">
		<buginformation>
			<summary>using @Query annotation, arrays are translated somewhere between query creation and mongo interpretation</summary>
			<description>I&amp;amp;apos;m trying to pass an array for a $all query so that I can keep all my queries in the same repository interface.  I&amp;amp;apos;ve tried various things, but I keep getting 






org.springframework.data.mongodb.UncategorizedMongoDbException: $all requires array; 




nested exception is com.mongodb.MongoException: $all requires array






Putting debug on both ends, Spring Data is logging:






DEBUG [10/04/2012 09:57:38 BST - main] - Created query { "tags" : { "$all" : [ "green" , "orange"]}}




DEBUG [10/04/2012 09:57:38 BST - main] - find using query: { "tags" : { "$all" : [ "green" , "orange"]}} fields: null for class:






and that query when pasted into a mongo shell is correct, returning the required documents however mongo is logging:






Tue Apr 10 10:57:39 [conn84] assertion 13050 $all requires array ns:database.collection query:{ tags: { $all: { 0: "green", 1: "orange" } } }






Which when pasted into a mongo shell returns the above error.
Debugging, this translation error occurs in DBObject org.springframework.data.mongodb.core.QueryMapper.getMappedObject(DBObject query, MongoPersistentEntity&amp;lt;?&amp;gt; entity)
It looks like this needs another clause for $all, similar to that which exists for $.*or.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="181" opendate="2011-06-23 01:18:57" fixdate="2012-05-07 07:48:25" resolution="Fixed">
		<buginformation>
			<summary>MongoFactoryBean does not call Mongo.close() on shutdown</summary>
			<description>MongoFactoryBean should call Mongo.close() on created object. Otherwise some resources aren&amp;amp;apos;t properly closed on application shutdown. For instance Tomcat reports two Mongo threads not being closed on shutdown.</description>
			<version>1.0 M3</version>
			<fixedVersion>1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoFactoryBean.java</file>
			<file type="M">org.springframework.data.mongodb.core.SimpleMongoDbFactoryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.SimpleMongoDbFactory.java</file>
			<file type="M">org.springframework.data.mongodb.config.MongoDbFactoryParserIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.config.MongoNamespaceTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="458" opendate="2012-06-07 01:18:27" fixdate="2012-06-08 04:04:08" resolution="Fixed">
		<buginformation>
			<summary>When reading back empty collections unmodifiable instances of Collections.emptyList/Set is returned.</summary>
			<description>When reading back a document stored with an empty collection, e.g:
  private Set&amp;lt;ClusterId&amp;gt; clusters = new HashSet&amp;lt;ClusterId&amp;gt;();
The driver deserializes this into a instance of Collections.emptySet, thus causing UnsupportedOperation exception when modifying.
</description>
			<version>1.1 M1</version>
			<fixedVersion>1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="459" opendate="2012-06-07 13:05:33" fixdate="2012-06-11 04:52:24" resolution="Duplicate">
		<buginformation>
			<summary>Using Update.set in nested arrays does not save the _class attribute</summary>
			<description>I have a service method like that:






	public Goal save(Goal goal) {




		Match match = this.mongoTemplate.findAndModify(




				query(where("goals").elemMatch(where("id").is(goal.getId()))),




				new Update().set("goals.$", goal), Match.class);




		return match.findGoalById(goal.getId());




	}






classes:






class Match {




     List&amp;lt;Goal&amp;gt; goals;




}




class Goal {




     Player player;




}




abstract class Player {}




class Forward extends Player {}




class Defender extends Player{}






When running the method above, the _class information for the Player object in the Goal class does not get saved in the database. This makes the saved document unloadable by Spring MongoDB.
Doing like that however will work:






Goal g = match.getGoal(&amp;lt;id&amp;gt;);




g.setPlayer(&amp;lt;a player&amp;gt;);






matchRepository.save(match);</description>
			<version>1.0.1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">392</link>
		</links>
	</bug>
	<bug id="450" opendate="2012-05-11 13:41:25" fixdate="2012-06-14 03:46:19" resolution="Fixed">
		<buginformation>
			<summary>enabling DEBUG causes RuntimeException</summary>
			<description>In MongoTemplate  this causes a runtime exception, when DEBUG level is enabled.






		if (LOGGER.isDebugEnabled()) {




			LOGGER.debug("findAndModify using query: " + query + " fields: " + fields + " sort: " + sort + " for class: "




					+ entityClass + " and update: " + updateObj + " in collection: " + collectionName);




		}






Seems the toString() doesn&amp;amp;apos;t use the converters. Stack trace:






java.lang.RuntimeException: json can&amp;amp;apos;t serialize type : class State




	at com.mongodb.util.JSON.serialize(JSON.java:261)




	at com.mongodb.util.JSON.serialize(JSON.java:141)




	at com.mongodb.util.JSON.serialize(JSON.java:58)




	at com.mongodb.BasicDBObject.toString(BasicDBObject.java:84)




	at java.lang.String.valueOf(String.java:2826)




	at java.lang.StringBuilder.append(StringBuilder.java:115)




	at org.springframework.data.mongodb.core.MongoTemplate.doFindAndModify(MongoTemplate.java:1341)




	at org.springframework.data.mongodb.core.MongoTemplate.findAndModify(MongoTemplate.java:536)




	at org.springframework.data.mongodb.core.MongoTemplate.findAndModify(MongoTemplate.java:527)





</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2, 1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="447" opendate="2012-05-10 08:27:15" fixdate="2012-06-14 05:06:10" resolution="Fixed">
		<buginformation>
			<summary>Removal of Documents fails in in debug mode for Documents with complex ids</summary>
			<description>During the removal of Objects MongoTemplate.remove() that use complex classes as ids spring-data tries to create a string out of the idquery that is used to find the object in the Mongo Database MongoTemplate.class. Since the query contains the id object JSON.serialize() is called for it. Since JSON can only handle a limited set of classes this call fails.
During the creation of the query spring-data even tests if it is necessary to convert the id-object into something manageable (and such a converter is required to use complex classes as ids in the first place) but the check (BeanWrapper.class:230) results in a false because the target type in this case is always Object.
Workaround
Never activate the debug log for MongoTemplate.
The Exception:






java.lang.RuntimeException: json can&amp;amp;apos;t serialize type : class myclass.ChannelId




	at com.mongodb.util.JSON.serialize(JSON.java:261) ~[mongo-java-driver-2.7.1.jar:na]




	at com.mongodb.util.JSON.serialize(JSON.java:141) ~[mongo-java-driver-2.7.1.jar:na]




	at com.mongodb.util.JSON.serialize(JSON.java:58) ~[mongo-java-driver-2.7.1.jar:na]




	at com.mongodb.BasicDBObject.toString(BasicDBObject.java:84) ~[mongo-java-driver-2.7.1.jar:na]




	at java.lang.String.valueOf(String.java:2902) ~[na:1.7.0_04]




	at java.lang.StringBuilder.append(StringBuilder.java:128) ~[na:1.7.0_04]




	at org.springframework.data.mongodb.core.MongoTemplate$13.doInCollection(MongoTemplate.java:941) ~[spring-data-mongodb-1.0.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.MongoTemplate$13.doInCollection(MongoTemplate.java:933) ~[spring-data-mongodb-1.0.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:368) ~[spring-data-mongodb-1.0.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.MongoTemplate.doRemove(MongoTemplate.java:933) ~[spring-data-mongodb-1.0.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.MongoTemplate.remove(MongoTemplate.java:924) ~[spring-data-mongodb-1.0.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.MongoTemplate.remove(MongoTemplate.java:865) ~[spring-data-mongodb-1.0.1.RELEASE.jar:na]




	...





</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2, 1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreator.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.Query.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="428" opendate="2012-04-09 10:42:02" fixdate="2012-06-19 08:54:30" resolution="Fixed">
		<buginformation>
			<summary>ClassCastException when using outputDatabase option in map-reduce</summary>
			<description>I have a database with a collection of documents. I am trying to do a mapreduce operation on this collection. When I select a set of mapreduce options such that the result is written to a collection in a different database from my source collection, I get a ClassCastException. Here is a snippet of my code (params is an object that contains String representations of my map, reduce, and finalize functions):






MapReduceOptions options = MapReduceOptions.options()




		.finalizeFunction(params.finalizeFunction)




		.outputDatabase("mapreduceres")




		.outputCollection(collName)




		.outputSharded(true);









MapReduceResults&amp;lt;Object&amp;gt; temp = mongoTemplate.mapReduce(params.collectionId, params.mapFunction,




		params.reduceFunction,options,Object.class);






Here is the exception:






SEVERE: com.mongodb.BasicDBObject cannot be cast to java.lang.String




java.lang.ClassCastException: com.mongodb.BasicDBObject cannot be cast to java.lang.String




	at org.springframework.data.mongodb.core.mapreduce.MapReduceResults.&amp;lt;init&amp;gt;(MapReduceResults.java:52)




	at org.springframework.data.mongodb.core.MongoTemplate.mapReduce(MongoTemplate.java:1026)




	at org.springframework.data.mongodb.core.MongoTemplate.mapReduce(MongoTemplate.java:976)






This is the Spring code that is throwing the exception:






public MapReduceResults(List&amp;lt;T&amp;gt; mappedResults, DBObject rawResults) {




	Assert.notNull(mappedResults);




	Assert.notNull(rawResults);




	this.mappedResults = mappedResults;




	this.rawResults = rawResults;




	parseTiming(rawResults);




	parseCounts(rawResults);




	if (rawResults.get("result") != null) {




		this.outputCollection = (String) rawResults.get("result");   //==== here!




	}






I put a breakpoint here, and I can see the value of the result object. If I do NOT use a different database (i.e., comment out the .outputDatabase("mapreduceres") line above, the result object is indeed a simple string. However, if I DO use a different database (i.e., keep the .outputDatabase("mapreduceres") above), the result object looks like this:






{ "db" : "mapreduceres" , "collection" : "myCollectionName"}






In this case, the cast doesn&amp;amp;apos;t work.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2, 1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.mapreduce.MapReduceResults.java</file>
		</fixedFiles>
	</bug>
	<bug id="424" opendate="2012-03-29 14:03:18" fixdate="2012-06-19 08:57:01" resolution="Fixed">
		<buginformation>
			<summary>Declaring a list of DBRef in a domian class results in Null for each DBRef when reading from mongo database</summary>
			<description>We have a requirement that we have to be able to define the following field in our domain class. The reason that we need to have such restriction is that this domain is used for integration with another system.






@Field("deletions")




private List&amp;lt;com.mongodb.DBRef&amp;gt; deletions;






Saving of deletions collections works fine and I can verify deletions list stored properly. However, when the list is read from Mongo DB, all instance of com.mongodb.DBRef are null. I had the same issue with having define one com.mongodb.DBRef in a domain class, but I could get around with that by creating a reading converter that converts from com.mongodb.DBRef to com.mongodb.DBRef </description>
			<version>1.0.1</version>
			<fixedVersion>1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="462" opendate="2012-06-19 08:57:02" fixdate="2012-06-19 10:00:45" resolution="Fixed">
		<buginformation>
			<summary>findAll() fails with NPE - discovering the root cause</summary>
			<description>This bug report is based on a forum thread(see Reference URL). I do not want to duplicate the original posts. Here is my response.
Hello Oliver, 
This morning I built spring data from source which provided a more informative error (see below). My code doesn&amp;amp;apos;t use the  @PersistenceConstructor annotation. I&amp;amp;apos;ll investigate. 
My source is open source. It is pre-alpha at this time. You&amp;amp;apos;ll find it on github (https://github.com/kern3020/harbinger).
Exception in thread "main" org.springframework.data.mapping.model.MappingInstantiationException: Could not instantiate bean class [java.net.URL]: No default constructor found; nested exception is java.lang.NoSuchMethodException: java.net.URL.&amp;lt;init&amp;gt;()
	at org.springframework.data.convert.ReflectionEntityInstantiator.createInstance(ReflectionEntityInstantiator.java:63)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:230)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:210)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter$MongoDbPropertyValueProvider.getPropertyValue(MappingMongoConverter.java:953)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.getValueInternal(MappingMongoConverter.java:708)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter$1.doWithPersistentProperty(MappingMongoConverter.java:246)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter$1.doWithPersistentProperty(MappingMongoConverter.java:236)
	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:183)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:236)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:210)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:174)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:170)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:73)
	at org.springframework.data.mongodb.core.MongoTemplate$ReadDbObjectCallback.doWith(MongoTemplate.java:1700)
	at org.springframework.data.mongodb.core.MongoTemplate.executeFindMultiInternal(MongoTemplate.java:1451)
	at org.springframework.data.mongodb.core.MongoTemplate.findAll(MongoTemplate.java:959)
	at org.john.app.InstituteRepository.dump(InstituteRepository.java:58)
	at org.john.app.InstituteRepository$$FastClassByCGLIB$$7799dab9.invoke(&amp;lt;generated&amp;gt;)
	at net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:191)
	at org.springframework.aop.framework.Cglib2AopProxy$CglibMethodInvocation.invokeJoinpoint(Cglib2AopProxy.java:689)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150)
	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:138)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
	at org.springframework.aop.framework.Cglib2AopProxy$DynamicAdvisedInterceptor.intercept(Cglib2AopProxy.java:622)
	at org.john.app.InstituteRepository$$EnhancerByCGLIB$$a998483c.dump(&amp;lt;generated&amp;gt;)
	at org.john.app.ReaperApp.main(ReaperApp.java:49)
Caused by: org.springframework.beans.BeanInstantiationException: Could not instantiate bean class [java.net.URL]: No default constructor found; nested exception is java.lang.NoSuchMethodException: java.net.URL.&amp;lt;init&amp;gt;()
	at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:107)
	at org.springframework.data.convert.ReflectionEntityInstantiator.createInstance(ReflectionEntityInstantiator.java:60)
	... 25 more
Caused by: java.lang.NoSuchMethodException: java.net.URL.&amp;lt;init&amp;gt;()
	at java.lang.Class.getConstructor0(Class.java:2723)
	at java.lang.Class.getDeclaredConstructor(Class.java:2002)
	at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:104) 
</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2, 1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.CustomConversions.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MongoConverters.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.CustomConversionsUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="454" opendate="2012-05-31 01:35:01" fixdate="2012-06-20 03:03:00" resolution="Fixed">
		<buginformation>
			<summary>ServerAddressPropertyEditor fails if a hostname is unresolvable </summary>
			<description>We have a replica set with three nodes with hostnames A, B and C. ServerAddressPropertyEditor parses the replica set A,B,C and fails if one of the host name is unresolvable. That&amp;amp;apos;s not correct because the replica set configuration is treated as a seed for the MongoDB&amp;amp;apos;s driver. The driver is able discover the replica set topology even if only one node is available from the seed. 
ServerAddressPropertyEditor should be more robust and fail only if all hostnames from the replica set seed are unresolvable. You can see such implementation below






public class RobustServerAddressPropertyEditor extends PropertyEditorSupport{




    private static Logger log = LoggerFactory.getLogger(RobustServerAddressPropertyEditor.class);









    @Override




    public void setAsText(String replicaSetString) {




        String[] replicaSetStringArray = StringUtils.commaDelimitedListToStringArray(replicaSetString);




        List&amp;lt;ServerAddress&amp;gt; serverAddresses = new ArrayList&amp;lt;ServerAddress&amp;gt;(replicaSetStringArray.length);









        for (int i = 0; i &amp;lt; replicaSetStringArray.length; i++) {




            String[] hostAndPort = StringUtils.delimitedListToStringArray(replicaSetStringArray[i], ":");




            try {




                ServerAddress serverAddress = new ServerAddress(hostAndPort[0], Integer.parseInt(hostAndPort[1]));




                serverAddresses.add(serverAddress);




            } catch (NumberFormatException e) {




                log.warn("Could not parse MongoDB configuration port {}", hostAndPort[1]);




            } catch (UnknownHostException e) {




                log.warn("The IP address for host {} could not be determined", hostAndPort[0]);




            }




        }




        if(serverAddresses.isEmpty()) {




            log.error("Cannot resolve at least one host in MongoDB replicaSet configuratuin {}", replicaSetString);




            throw new IllegalArgumentException("Cannot resolve at least one host in MongoDB replicaSet configuratuin");




        }




        setValue(serverAddresses.toArray(new ServerAddress[0]));




    }




}





</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2, 1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.data.mongodb.config.NamespaceTestSupport.java</file>
			<file type="M">org.springframework.data.mongodb.config.ServerAddressPropertyEditor.java</file>
			<file type="M">org.springframework.data.mongodb.config.MongoNamespaceReplicaSetTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="467" opendate="2012-06-24 08:58:49" fixdate="2012-06-25 04:13:59" resolution="Fixed">
		<buginformation>
			<summary>String @id field is not mapped to ObjectId when using QueryDSL ".id" path</summary>
			<description>Using this entity (@Document) definition with a String as the declared ID:






User.class




...




@Id String id;






and the following query






QUser.id.eq("4f43b6a384aea4e77d403709")






Always returns null for a repository find. Looking at the mongoDb query log (mongod -v) it appears that the spring-data-mongodb/QueryDSL layers are not translating the String 4f43b6a384aea4e77d403709 to ObjectId("4f43b6a384aea4e77d403709") as one would normally do in the mongo shell.</description>
			<version>1.0.2</version>
			<fixedVersion>1.0.3, 1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializer.java</file>
			<file type="M">org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializerUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="475" opendate="2012-07-02 01:29:47" fixdate="2012-07-16 08:41:17" resolution="Fixed">
		<buginformation>
			<summary>&amp;apos;group&amp;apos; operation fails where query references non primitive property</summary>
			<description>&amp;amp;apos;group&amp;amp;apos; operation fails where query references non primitive property
See failing test at https://bitbucket.org/patrikfr/springmongotest/src/96590e6d599c/ CarRepositoryTest#groupByWithNonPrimitiveProperty
Stacktrace:
java.lang.RuntimeException: json can&amp;amp;apos;t serialize type : class mongo.MakeId
	at com.mongodb.util.ClassMapBasedObjectSerializer.serialize(ClassMapBasedObjectSerializer.java:77)
	at com.mongodb.util.JSONSerializers$IterableSerializer.serialize(JSONSerializers.java:280)
	at com.mongodb.util.ClassMapBasedObjectSerializer.serialize(ClassMapBasedObjectSerializer.java:79)
	at com.mongodb.util.JSONSerializers$MapSerializer.serialize(JSONSerializers.java:307)
	at com.mongodb.util.ClassMapBasedObjectSerializer.serialize(ClassMapBasedObjectSerializer.java:79)
	at com.mongodb.util.JSONSerializers$MapSerializer.serialize(JSONSerializers.java:307)
	at com.mongodb.util.ClassMapBasedObjectSerializer.serialize(ClassMapBasedObjectSerializer.java:79)
	at com.mongodb.util.JSONSerializers$MapSerializer.serialize(JSONSerializers.java:307)
	at com.mongodb.util.ClassMapBasedObjectSerializer.serialize(ClassMapBasedObjectSerializer.java:79)
	at com.mongodb.util.JSONSerializers$MapSerializer.serialize(JSONSerializers.java:307)
	at com.mongodb.util.ClassMapBasedObjectSerializer.serialize(ClassMapBasedObjectSerializer.java:79)
	at com.mongodb.util.JSON.serialize(JSON.java:56)
	at com.mongodb.util.JSON.serialize(JSON.java:41)
	at com.mongodb.BasicDBObject.toString(BasicDBObject.java:84)
	at org.springframework.data.mongodb.core.MongoTemplate.group(MongoTemplate.java:1070)
	at mongo.CarRepositoryCustomImpl.aggregateDistanceTravelledAndColorByMake(CarRepositoryCustomImpl.java:29)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</description>
			<version>1.0.2</version>
			<fixedVersion>1.0.3, 1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="483" opendate="2012-07-14 22:16:49" fixdate="2012-07-16 09:37:35" resolution="Fixed">
		<buginformation>
			<summary>@Indexed(unique=true, name="foo") puts name&amp;apos;s value to the &amp;apos;key&amp;apos; in the MongoDB </summary>
			<description>Here is the example:






@Document




class User {




   @Id




   private String id;




   




   @Indexed(unique=true, name="username_unique_1")




   @Field("username")




   private String user_name;




} 






Spring Data will generate the follwoing index document: 






{ "v" : 1, "key" : { "username_unique_1" : 1 }, "unique" : true, "ns" : "test_db.user", "name" : "username_unique_1", "dropDups" : false, "sparse" : false }






However the expected document is:






{ "v" : 1, "key" : { "username" : 1 }, "unique" : true, "ns" : "test_db.user", "name" : "username_unique_1", "dropDups" : false, "sparse" : false }






I think the expected behavior is: @Indexed.name should correpond to name in the index document, while @Field.value should correpsond to the key in the index document. If @Field is absent, than field name should be used as a key in the index document.
The current implementation confusing: if you put something different from a field name into @Indexed.name, your index will be created on nonexistent field. However this is why we need @Indexed.name - to add a descriptive name to the index.
If someone wants to use @Indexed.name for creating an index on non-existen field (to be honest can&amp;amp;apos;t imagine the case) then low-level API like execute on DBCollection should be used.
The issue is related to the line 165 of MongoPersistentEntityIndexCreator.java where @Inbdexed.name is implicitly used as a name of the field on which index should be created.
P.S. Before submitting this issue I&amp;amp;apos;ve seatched this JIRA for similar defact and found couple of them:

DATAMONGO-70
DATAMONGO-79
DATAMONGO-237

The mentioned issues doesn&amp;amp;apos;t describe the problem in full.
Guys, would you like me to sumbit a patch for that?</description>
			<version>1.0.2</version>
			<fixedVersion>1.0.3, 1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.CompoundIndex.java</file>
		</fixedFiles>
	</bug>
	<bug id="480" opendate="2012-07-09 09:00:44" fixdate="2012-07-16 10:01:25" resolution="Fixed">
		<buginformation>
			<summary>The WriteResultChecking is not used in case of insert or save of documents.</summary>
			<description>The insertDBObject(), insertDBObjectList() and saveDBObject() do not use the WriteResultChecking similar to what is done in doInsert() and doUpdate() methods.</description>
			<version>1.0.2</version>
			<fixedVersion>1.0.3, 1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="489" opendate="2012-07-22 08:44:19" fixdate="2012-07-23 07:43:59" resolution="Fixed">
		<buginformation>
			<summary>ClassCastException when loading Map&lt;String, String[]&gt;</summary>
			<description>When saving a regular Java Map with array inside (as in SolrQuery), it seems that Spring Sata saves the object fine, but when you trying to read it, it is a Map with List as the value type. When you&amp;amp;apos;re trying to work with the object you&amp;amp;apos;re getting a ClassCastException: java.util.ArrayList cannot be cast to [Ljava.lang.String. We find that the problem is in MappingMongoConverter#readCollectionOrArray(), at this line:






collectionType = Collection.class.isAssignableFrom(collectionType) ? collectionType : List.class;






When the type is array (String[]) it obviously cannot be assigned to Collection so it returns it as a List. Possible solution is to return an object from this method and handle arrays too. There is a main that reproduce that issue as an attachment.</description>
			<version>1.0.2</version>
			<fixedVersion>1.0.3, 1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="474" opendate="2012-06-29 06:01:31" fixdate="2012-07-24 06:28:18" resolution="Fixed">
		<buginformation>
			<summary>Wrong property is used for Id mapping</summary>
			<description>After upgrading to 1.0.2 storing fails with the stacktrace below:
It seems like the incorrect property is used when mapping the ID, possibly being confused by a getter &amp;amp;apos;getId()&amp;amp;apos; that is not referencing the MongoDB Id.
See example project on Bitbucket for testcase. CarRepositoryTest#findByCarId
https://bitbucket.org/patrikfr/springmongotest






org.springframework.core.convert.ConverterNotFoundException: No converter found capable of converting from type mongo.CarId to type java.lang.String




	at org.springframework.core.convert.support.GenericConversionService.handleConverterNotFound(GenericConversionService.java:475)




	at org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:175)




	at org.springframework.core.convert.support.GenericConversionService.convert(GenericConversionService.java:154)




	at org.springframework.data.mapping.model.BeanWrapper.getPotentiallyConvertedValue(BeanWrapper.java:233)




	at org.springframework.data.mapping.model.BeanWrapper.getProperty(BeanWrapper.java:212)




	at org.springframework.data.mapping.model.BeanWrapper.getProperty(BeanWrapper.java:183)




	at org.springframework.data.mongodb.core.MongoTemplate.populateIdIfNecessary(MongoTemplate.java:1375)




	at org.springframework.data.mongodb.core.MongoTemplate.doSave(MongoTemplate.java:723)




	at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:708)




	at org.springframework.data.mongodb.repository.support.SimpleMongoRepository.save(SimpleMongoRepository.java:70)





</description>
			<version>1.0.2</version>
			<fixedVersion>1.0.3, 1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="493" opendate="2012-07-24 09:58:49" fixdate="2012-07-24 11:46:11" resolution="Fixed">
		<buginformation>
			<summary>Criteria.ne() method converts all value into ObjectId</summary>
			<description>The QueryMapper.getMappedObject() converts all $ne criterion value into ObjectId.
Fix : Test for id key like $in criterion</description>
			<version>1.1 M2</version>
			<fixedVersion>1.0.4, 1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="495" opendate="2012-07-25 18:57:39" fixdate="2012-07-26 01:37:21" resolution="Fixed">
		<buginformation>
			<summary>JSON can&amp;apos;t serialize Enum when printing Query in DEBUG message</summary>
			<description>I&amp;amp;apos;m trying to execute the following code to query MongoDB where the field &amp;amp;apos;type&amp;amp;apos; is an Enum.






this.getOperations().find(new Query(Criteria.where("type").is(type)), ComponentDefinition.class);






I get an error saying the class can&amp;amp;apos;t be serialized (see exception below).
But I noticed the error only happens when the log level is set to DEBUG, when a line in MongoTemplate.java attempts to add the Query to a debug message. The serialization error is then triggered by toString() of BasicDBObject. The exception thrown is:






java.lang.RuntimeException: json can&amp;amp;apos;t serialize type : class au.org.aurin.workflow.datamodel.ComponentType




	at com.mongodb.util.JSON.serialize(JSON.java:261)




	at com.mongodb.util.JSON.serialize(JSON.java:141)




	at com.mongodb.util.JSON.serialize(JSON.java:58)




	at com.mongodb.BasicDBObject.toString(BasicDBObject.java:84)




	at java.lang.String.valueOf(String.java:2902)




	at java.lang.StringBuilder.append(StringBuilder.java:128)




	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:1241)




	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:1233)




	at org.springframework.data.mongodb.core.MongoTemplate.find(MongoTemplate.java:471)




	at org.springframework.data.mongodb.core.MongoTemplate.find(MongoTemplate.java:466)




	at au.org.aurin.workflow.persistence.ComponentRepository.getByType(ComponentRepository.java:42)






When log level is set to INFO, the problem doesn&amp;amp;apos;t appear. The enum value is serialized as expected in all DB operations.</description>
			<version>1.0.3</version>
			<fixedVersion>1.0.4, 1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="494" opendate="2012-07-25 11:55:03" fixdate="2012-07-27 07:37:32" resolution="Fixed">
		<buginformation>
			<summary>$or/$nor expressions do not consider entity class mapping</summary>
			<description>Use case example :






// The given entity




MyEntity {




@Id




String code;




}









// Querying using




Query(new Criteria().orOperator(new Criteria[]{




Criteria.where("code").regex(".*value.*", "i")




}))









// Produces




{ "$or" : [ { "code" : { "$regex" : ".*value.*" , "$options" : "i"}}}









// Instead of




{ "$or" : [ { "_id" : { "$regex" : ".*value.*" , "$options" : "i"}}}











The QueryMapper.getMappedObject set the entityClass as null for reentrant calls from the or/nor case, I don&amp;amp;apos;t anderstand why ?
Fix : Set the entityClass for reentrant calls (L91).</description>
			<version>1.1 M2</version>
			<fixedVersion>1.0.4, 1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="497" opendate="2012-07-27 12:13:40" fixdate="2012-07-30 06:59:46" resolution="Fixed">
		<buginformation>
			<summary>Reading an empty List throws a MappingInstantiationException because it returns an HashSet instead of returning an ArrayList</summary>
			<description>When trying to switch to spring-data-mongo-1.1.M2 from 1.0.3, I had the following stacktrace :






org.springframework.data.mapping.model.MappingInstantiationException: Could not instantiate bean class [com.mycompany.catalog.Transaction]: Illegal arguments for constructor; nested exception is java.lang.IllegalArgumentException: argument type mismatch




	at org.springframework.data.convert.ReflectionEntityInstantiator.createInstance(ReflectionEntityInstantiator.java:77)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:230)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:210)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:174)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:170)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:73)




	at org.springframework.data.mongodb.core.MongoTemplate$ReadDbObjectCallback.doWith(MongoTemplate.java:1718)




	at org.springframework.data.mongodb.core.MongoTemplate.executeFindMultiInternal(MongoTemplate.java:1441)




	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:1244)




	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:1233)




	at org.springframework.data.mongodb.core.MongoTemplate.find(MongoTemplate.java:471)




	at org.springframework.data.mongodb.core.MongoTemplate.find(MongoTemplate.java:466)




	at com.mycompany.catalog.repositories.AbstractRepositoryCustomMongo.findByQueryPageable(AbstractRepositoryCustomMongo.java:35)




	at com.mycompany.catalog.repositories.TransactionRepositoryCustomMongo.findByProduct(TransactionRepositoryCustomMongo.java:64)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:334)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:309)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:202)




	at $Proxy26.findByProduct(Unknown Source)




	at com.mycompany.catalog.repositories.TransactionRepositoryTest.testFindByProduct(TransactionRepositoryTest.java:49)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)




	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)




	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:74)




	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:83)




	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:231)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)




	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)




	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:71)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:174)




	at org.junit.runner.JUnitCore.run(JUnitCore.java:157)




	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:62)




Caused by: org.springframework.beans.BeanInstantiationException: Could not instantiate bean class [com.mycompany.catalog.Transaction]: Illegal arguments for constructor; nested exception is java.lang.IllegalArgumentException: argument type mismatch




	at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:158)




	at org.springframework.data.convert.ReflectionEntityInstantiator.createInstance(ReflectionEntityInstantiator.java:75)




	... 50 more




Caused by: java.lang.IllegalArgumentException: argument type mismatch




	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)




	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)




	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)




	at java.lang.reflect.Constructor.newInstance(Constructor.java:525)




	at org.springframework.beans.BeanUtils.instantiateClass(BeanUtils.java:147)




	... 51 more






After further investigation, I found that the problem come from the instanciation of my Transaction document which use @PersistenceConstructor on this constructor :






@PersistenceConstructor




public Transaction(




        ObjectId id,




        Product product,




        List&amp;lt;Operation&amp;gt; operations




)






Spring try to instantiate it with an HashSet instead of a List for the third constructor argument.
The HashSet is passed from the method org.springframework.data.mongodb.core.convert.MappingMongoConverter#readCollectionOrArray resulting in the a IllegalArgumentException: argument type mismatch
The readCollectionOrArray method should return an empty collection which matches the type of the constructor param at line https://github.com/SpringSource/spring-data-mongodb/blob/master/spring-data-mongodb/src/main/java/org/springframework/data/mongodb/core/convert/MappingMongoConverter.java#L724
It may be related to :

issue DATAMONGO-458
commit https://github.com/SpringSource/spring-data-mongodb/commit/b3a891c69b38f5b53b5f6041c9af6aa3f89afe24

</description>
			<version>1.1 M2</version>
			<fixedVersion>1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="481" opendate="2012-07-11 16:33:26" fixdate="2012-08-10 01:54:16" resolution="Fixed">
		<buginformation>
			<summary>After upgrading to 1.0.2 IsTrue does not work properly in query method</summary>
			<description>For such created query:
Account findByUsernameAndConfirmedIsTrue(String username);
I see following in logs:
Created query Query: { "confirmed" : true , "$and" : [ 
{ "confirmed" : true}
]}, Fields: null, Sort: null
And the query does not return proper value.
In previous release (1.0.1.RELEASE) the same code produces valid query:
Created query 
{ "username" : "me" , "confirmed" : true}</description>
			<version>1.0.2</version>
			<fixedVersion>1.0.3, 1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreator.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreatorUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">469</link>
		</links>
	</bug>
	<bug id="508" opendate="2012-08-15 07:33:43" fixdate="2012-08-15 09:31:51" resolution="Fixed">
		<buginformation>
			<summary>DBRef can accidentally get added as PersistentProperty</summary>
			<description>MappingMongoConverter.createDBRef() inspects the given object&amp;amp;apos;s metadata to extract id value and collection information of it. In case the given object is a DBRef already this is not necessary. Actually it will cause DBRef being added as PersistentEntity which should be avoided.</description>
			<version>1.1 M2</version>
			<fixedVersion>1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="505" opendate="2012-08-14 03:07:56" fixdate="2012-08-15 10:09:59" resolution="Fixed">
		<buginformation>
			<summary>Conversion of associations doesn&amp;apos;t work for collection values</summary>
			<description>Assume you have the following scenario:






class Entity {









  Long id;




  @DBRef




  Property property;




}









class Property {




  Long id;




}









interface EntityRepository extends Repository&amp;lt;Entity, Long&amp;gt; {









  Entity findByPropertyIn(Property... property);




}






The execution of findByProperty() will fail as the given array (or collection) is not correctly translated into a collection of DBRefs. The reason is that ConvertingIterator treats the value as is and wants to create a DBRef from it. We need to unwrap the elements and convert them into DBRef instances one by one.</description>
			<version>1.1 M2</version>
			<fixedVersion>1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.ConvertingParameterAccessorUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.ConvertingParameterAccessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="517" opendate="2012-08-21 03:07:04" fixdate="2012-08-21 03:29:19" resolution="Fixed">
		<buginformation>
			<summary>QueryMapping incorrectly translates complex keywords</summary>
			<description>For queries with keywords having complex values (e.g. 
{ "$in" : [  ] }
) QueryMapper drops the keyword and makes the converted complex value the value of the actual property reference.</description>
			<version>1.1 M2</version>
			<fixedVersion>1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="472" opendate="2012-06-28 02:35:59" fixdate="2012-08-29 02:34:39" resolution="Fixed">
		<buginformation>
			<summary>Using a "Not" Keyword in a Query Method Doesn&amp;apos;t Work</summary>
			<description>I basically created an interface that contains a query method that looks something like this:






List&amp;lt;Status&amp;gt; findByStatusNot(String status);






When I tired to use this method spring-mongo threw: 






InvalidMongoDbApiUsageException: "Invalid query: &amp;amp;apos;not&amp;amp;apos; can&amp;amp;apos;t be used with &amp;amp;apos;is&amp;amp;apos; - use &amp;amp;apos;ne&amp;amp;apos; instead."






From the looks of it there seems to be a bug in the MongoQueryCreator class which does the following for NEGATING_SIMPLE_PROPERTY case:






criteria.not().is(parameters.nextConverted(property));






Note that criteria.is() explicitly throws an exception if a call to not() proceeds it.</description>
			<version>1.0.2</version>
			<fixedVersion>1.1 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreator.java</file>
			<file type="M">org.springframework.data.mongodb.repository.AbstractPersonRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.PersonRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="469" opendate="2012-06-25 12:57:40" fixdate="2012-08-31 01:39:48" resolution="Fixed">
		<buginformation>
			<summary>Query creation from method names using AND criteria does not work anymore</summary>
			<description>When migrating from 1.0.1 to 1.0.2, one of my test failed.






@Test




public void testFindByPseudoAndPassword_wrongPseudo() {




    Member member = new Member("pseudo");




    member.setPassword("password");









    memberRepository.save(member);









    Member findMember = memberRepository.findByPseudoAndPassword("wrong-pseudo", "password");




    assertThat(findMember).isNull(); // FAILS HERE because the query retrieve the member with password equals "password" and miss the pseudo value




}






and the log is : 





 DEBUG [MongoTemplate] findOne using query: { "password" : "password" , "$and" : [ { "password" : "password"}]} 






I saw that in https://github.com/SpringSource/spring-data-mongodb/blob/1.0.x/spring-data-mongodb/src/test/java/org/springframework/data/mongodb/repository/query/MongoQueryCreatorUnitTests.java there is no assertion for the test #createsQueryCorrectly which test the Criteria AND case.
May be it is due to https://github.com/SpringSource/spring-data-mongodb/commit/c8bb46ffb3b2ffa5456417a199ffa0d3b977bf0b</description>
			<version>1.0.2</version>
			<fixedVersion>1.0.3, 1.1 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreator.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreatorUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">481</link>
			<link type="Relate" description="relates to">547</link>
		</links>
	</bug>
	<bug id="523" opendate="2012-09-01 03:39:51" fixdate="2012-09-03 06:26:10" resolution="Fixed">
		<buginformation>
			<summary>@TypeAlias annotation not used with AbstractMongoConfiguration </summary>
			<description>When using the AbstractMongoConfiguration without any further modifications regarding the converter (afterMappingMongoConverterCreation) the @TypeAlias annotation is not used when writing the _class property. Seems like it always uses the SimpleTypeInformationMapper. The documentation suggests that you just annotate your @Document classes with the @TypeAlias annotations and everything should be fine. </description>
			<version>1.0.4</version>
			<fixedVersion>1.1 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">226</link>
		</links>
	</bug>
	<bug id="521" opendate="2012-08-31 02:37:13" fixdate="2012-09-03 22:42:49" resolution="Fixed">
		<buginformation>
			<summary>Query creation from method names using AND criteria does not work anymore</summary>
			<description>I created a simple repository like below






public interface PersonRepository extends PagingAndSortingRepository&amp;lt;Person, String&amp;gt; {




	




	Person findOneByFirstname(String name);




	Person findOneByFirstnameAndLastname(String firstname, String lastname);




}






and when queried using this repository






Person p = repository.findOneByFirstnameAndLastname("Shirish","Reddy");






The command that goes in to mongodb is
runQuery called db.persons 
{ lastname: "Reddy" }
 where as it should be having </description>
			<version>1.0.3</version>
			<fixedVersion>1.1 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.AbstractPersonRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.PersonRepository.java</file>
			<file type="M">org.springframework.data.mongodb.repository.PersonRepositoryIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="527" opendate="2012-09-03 09:30:45" fixdate="2012-09-03 22:45:51" resolution="Fixed">
		<buginformation>
			<summary>Criteria.equals() broken for complex criterias</summary>
			<description></description>
			<version>1.0.4</version>
			<fixedVersion>1.1 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.query.Criteria.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.CriteriaTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="532" opendate="2012-09-07 03:49:02" fixdate="2012-09-12 04:06:56" resolution="Fixed">
		<buginformation>
			<summary>Multithreading authentication issue</summary>
			<description>I have come across an issue which results in the following exception to be thrown.






java.lang.RuntimeException: org.springframework.data.mongodb.CannotGetMongoDbConnectionException: Failed to authenticate to database






This appears to be caused by multiple threads trying to authenticate a single DB instance. The bug appears to be in MongoDbUtils in the doGetDB() method. The method retrieves the DB object for a given name and checks if it is authenticated, if it is not authenticated then it will authenticate it with the given username and password. However, if two threads check the same DB object they will both attempt to authenticate which leads to the exception being thrown. I have checked the latest source code in the git repository and the bug still appears to be present. To solve this issue I have replaced lines 109 - 118 with:






if (credentialsGiven &amp;amp;&amp;amp; !db.isAuthenticated()) {




	String username = credentials.getUsername();




	String password = credentials.hasPassword() ? credentials.getPassword() : null;




	synchronized (db) {




		if (!db.isAuthenticated() &amp;amp;&amp;amp; !db.authenticate(username, password == null ? null : password.toCharArray())) {




			throw new CannotGetMongoDbConnectionException("Failed to authenticate to database [" + databaseName




					+ "], username = [" + username + "], password = [" + password + "]", databaseName, credentials);




		}	




	}




}






The synchronized block could be moved to include both if statements which would remove the need for the second call to isAuthenticated() but it would mean that each time the doGetDb() method is called the synchronized block will be entered. Whereas the above will only be synchronized on calls to doGetDb() when the db has not been authenticated, with the compromise that the isAuthenticated() method has to be called twice.
I have run the above fix (well the same fix based on the 1.0.4.RELEASE code) and it appears to solve the issue.
A second issue to be aware of is the pre version 2.9.0 of the java mongo driver has a multithreading bug described in the link below. I have had a look a the latest dev version of spring-mongo and it is still using 2.7.1 so it would be worth considering the upgrade.
https://jira.mongodb.org/browse/JAVA-582</description>
			<version>1.0.4</version>
			<fixedVersion>1.1 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoDbUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">484</link>
		</links>
	</bug>
	<bug id="530" opendate="2012-09-06 07:06:15" fixdate="2012-09-12 04:33:50" resolution="Fixed">
		<buginformation>
			<summary>MongoMappingContext.setApplicationContext() does not invoke superclass method</summary>
			<description>AbstractMappingContext.setApplicationContext() does not get invoked on invocations of MongoMappingContext.setApplicationContext(). This causes the entity initialization not being triggered correctly.</description>
			<version>1.1 RC1</version>
			<fixedVersion>1.1 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.mapping.MongoMappingContextUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.MongoMappingContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="535" opendate="2012-09-10 03:15:19" fixdate="2012-09-12 04:34:01" resolution="Fixed">
		<buginformation>
			<summary>Retrieve of existing Mongo DB from Transaction is not working</summary>
			<description>dbHolder.doesNotHoldNonDefaultDB() in MongoDbUtils.doGetDB() is always false, so the DbHolder is never used. 
MongoDbUtils.doGetDB() is also always registering synchronization for the same Mongo instance on every call. For two or more calls it fails to unbindResource() because resource is already unbounded.</description>
			<version>1.0.4</version>
			<fixedVersion>1.1 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoDbUtils.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoDbUtilsUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="539" opendate="2012-09-13 07:22:42" fixdate="2012-09-17 03:01:24" resolution="Fixed">
		<buginformation>
			<summary>Document remove doesn&amp;apos;t work when giving collection name as a parameter</summary>
			<description>I have a document that is put to different kinds of collections, depending on the need. Therefore, I need to use mongoOperations.save(item, "collection") method to save the document. Saving works fine, but removing the item with a call like this: mongoOperations.remove(item, "collection") doesn&amp;amp;apos;t actually remove the document. The remove operation doesn&amp;amp;apos;t fail, but the document still exists in the collection.
Remove works when using spring-data-mongo version 1.0.1 and 1.0.2.
Here&amp;amp;apos;s some test code to show a failing test:






Item item = new Item("kukkuu");




mongoOperations.save(item, "test");




mongoOperations.remove(item, "test");




assertThat(mongoOperations.findAll(Item.class, "test").isEmpty(), is(Boolean.TRUE));






The Item is defined as:






@Document




public class Item {









    @Id




    private String id;




    private String name;









    public Item(String name) {




        this.name = name;




    }









    public String getName() {




        return name;




    }









    public String getId() {




        return id;




    }









    public void setId(String id) {




        this.id = id;




    }









    public void setName(String name) {




        this.name = name;




    }




}






</description>
			<version>1.0.3</version>
			<fixedVersion>1.1 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="549" opendate="2012-10-10 23:32:46" fixdate="2012-10-10 23:59:43" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate.save() suffers from potential NullPointException</summary>
			<description>MongoTemplate.save() runs into a NullPointerException in case the object handed in is a Mongo-primitive one (Map, Collection, Java-primitive). Also if the object handed into the method is null already we run into an NPE as well.</description>
			<version>1.1 GA</version>
			<fixedVersion>1.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="550" opendate="2012-10-11 07:52:36" fixdate="2012-10-15 09:01:57" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate.save(BasicDBObject, String) results in NPE (after upgrading to 1.1.0.RELEASE</summary>
			<description></description>
			<version>1.1 GA</version>
			<fixedVersion>1.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="is depended on by">2785</link>
		</links>
	</bug>
	<bug id="551" opendate="2012-10-11 08:00:10" fixdate="2012-10-15 09:02:10" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate.save(String, String) results in NPE (after upgrading to 1.1.0.RELEASE</summary>
			<description>In this case the String we are talking about is a JSON String. </description>
			<version>1.1 GA</version>
			<fixedVersion>1.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="is depended on by">2785</link>
		</links>
	</bug>
	<bug id="553" opendate="2012-10-12 06:36:38" fixdate="2012-10-17 14:49:48" resolution="Fixed">
		<buginformation>
			<summary>StackOverflowError when objects have cycles</summary>
			<description>The issue was first reported to Spring Integration project: https://jira.springsource.org/browse/INT-2778 and we narrowed down the problem to the fact that the persisted object had a cycle. In the reported case persisted object is Exception who&amp;amp;apos;s default &amp;amp;apos;cause&amp;amp;apos; is &amp;amp;apos;this&amp;amp;apos; thus creating a cycle.
I think classes of type Throwable needs to be treated in a special way where instead of using Reflection getCause() should be called.
However it would also help to have some cycle detection mechanism even for the purpose of throwing a more meaningful exception (e.g., Cycle detected)</description>
			<version>1.1 GA</version>
			<fixedVersion>1.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.mapping.SimpleMongoMappingContext.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.BasicMongoPersistentPropertyUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.BasicMongoPersistentProperty.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.MongoPersistentProperty.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">2778</link>
		</links>
	</bug>
	<bug id="562" opendate="2012-10-24 05:57:43" fixdate="2012-10-24 07:13:51" resolution="Fixed">
		<buginformation>
			<summary>Cannot create entity with OptimisticLocking (@Version) and initial id</summary>
			<description>Cannot store entities with @Version and id already set. Either a NullPointerException or OptimisticLockingFailureException
The following test case provokes a NullPointerException since person.version is null. However, if I change version to 0 I will get an OptimisticLockingFailureException.
	@Test
	public void optimisticLockingHandlingWithExistingId() 
{
		PersonWithVersionPropertyOfTypeInteger person = new PersonWithVersionPropertyOfTypeInteger();
		person.id = new ObjectId().toString();
		person.age = 29;
		person.firstName = "Patryk";
		template.save(person);
	}</description>
			<version>1.1.1</version>
			<fixedVersion>1.1.2, 2.0 M1 (Kay)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="570" opendate="2012-11-08 13:40:06" fixdate="2012-11-13 09:34:13" resolution="Fixed">
		<buginformation>
			<summary>Query methods on @DBRef field with the qualifier isNull throws Exception</summary>
			<description>For the following repository query on @DBRef field with the qualifier isNull throws Exception
public class Tree {
  private String id;
  @DBRef
  private Tree parent;
  ...
}
@Repository
public interface TreeRepository extends CrudRepository&amp;lt;Tree, String&amp;gt; {
  List&amp;lt;Tree&amp;gt; findByParentIsNull();
}
Here is the stacktrace:
Caused by: java.lang.IllegalArgumentException: [Assertion failed] - this argument is required; it must not be null
	at org.springframework.util.Assert.notNull(Assert.java:112)
	at org.springframework.util.Assert.notNull(Assert.java:123)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.createDBRef(MappingMongoConverter.java:672)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.toDBRef(MappingMongoConverter.java:277)
	at org.springframework.data.mongodb.core.convert.QueryMapper.convertAssociation(QueryMapper.java:266)
	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedValue(QueryMapper.java:177)
	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedObject(QueryMapper.java:90)
	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:1332)
	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:1318)
	at org.springframework.data.mongodb.core.MongoTemplate.find(MongoTemplate.java:504)
	at org.springframework.data.mongodb.repository.query.AbstractMongoQuery$Execution.readCollection(AbstractMongoQuery.java:123)
	at org.springframework.data.mongodb.repository.query.AbstractMongoQuery$CollectionExecution.execute(AbstractMongoQuery.java:146)
	at org.springframework.data.mongodb.repository.query.AbstractMongoQuery.execute(AbstractMongoQuery.java:86)
	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:313)
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:202)
	at $Proxy39.findByParentIsNull(Unknown Source)</description>
			<version>1.1 GA</version>
			<fixedVersion>1.1.2, 1.2 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="378" opendate="2012-01-14 06:35:42" fixdate="2012-11-29 04:49:14" resolution="Fixed">
		<buginformation>
			<summary>MapReduceResults ClassCastException due to raw results counts as Long</summary>
			<description>org.springframework.data.mongodb.core.mapreduce.MapReduceCounts appears to be typed incorrectly which causes MapReduceResults.parseCounts to fail. MapReduceCounts uses ints to store the output of the M/R result counts however the MongoDB server appears to return a long (see link and CPP code below).






Jan 13, 2012 11:14:13 PM org.apache.catalina.core.ApplicationContext log




SEVERE: Exception while dispatching incoming RPC call




com.google.gwt.user.server.rpc.UnexpectedException: Service method &amp;amp;apos;public abstract com.extjs.gxt.ui.client.data.PagingLoadResult com.ibbs.bbx.diagnostics.report.client.DocsisCapabilityService.getFilteredSubscriberModems(int,int,com.extjs.gxt.ui.client.data.FilterPagingLoadConfig)&amp;amp;apos; threw an unexpected exception: java.lang.ClassCastException: java.lang.Long cannot be cast to java.lang.Integer




        at com.google.gwt.user.server.rpc.RPC.encodeResponseForFailure(RPC.java:385)




        at com.google.gwt.user.server.rpc.RPC.invokeAndEncodeResponse(RPC.java:588)




        at com.google.gwt.user.server.rpc.RemoteServiceServlet.processCall(RemoteServiceServlet.java:208)




        at com.google.gwt.user.server.rpc.RemoteServiceServlet.processPost(RemoteServiceServlet.java:248)




        at com.google.gwt.user.server.rpc.AbstractRemoteServiceServlet.doPost(AbstractRemoteServiceServlet.java:62)




        at javax.servlet.http.HttpServlet.service(HttpServlet.java:637)




        at javax.servlet.http.HttpServlet.service(HttpServlet.java:717)




        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290)




        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)




        at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:233)




        at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:191)




        at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:127)




        at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102)




        at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)




        at org.apache.catalina.ha.session.JvmRouteBinderValve.invoke(JvmRouteBinderValve.java:227)




        at org.apache.catalina.ha.tcp.ReplicationValve.invoke(ReplicationValve.java:347)




        at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:298)




        at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:859)




        at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:588)




        at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:489)




        at java.lang.Thread.run(Thread.java:662)




Caused by: java.lang.ClassCastException: java.lang.Long cannot be cast to java.lang.Integer




        at org.springframework.data.mongodb.core.mapreduce.MapReduceResults.parseCounts(MapReduceResults.java:95)




        at org.springframework.data.mongodb.core.mapreduce.MapReduceResults.&amp;lt;init&amp;gt;(MapReduceResults.java:50)




        at org.springframework.data.mongodb.core.MongoTemplate.mapReduce(MongoTemplate.java:1026)




        at com.ibbs.unity.mongodb.services.ModemService.getDocsisCapByCmtsId(ModemService.java:241)




        at com.ibbs.bbx.diagnostics.report.server.DocsisCapabilityServiceImpl.getDocsisCapabilities(DocsisCapabilityServiceImpl.java:55)




        at com.ibbs.bbx.diagnostics.report.server.DocsisCapabilityServiceImpl.getFilteredSubscriberModems(DocsisCapabilityServiceImpl.java:136)




        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




        at java.lang.reflect.Method.invoke(Method.java:597)




        at com.google.gwt.user.server.rpc.RPC.invokeAndEncodeResponse(RPC.java:569)




        ... 19 more






Log output of the actual values:






INFO   | jvm 1    | 2012/01/13 23:14:13 | input: 55668 class: java.lang.Long




INFO   | jvm 1    | 2012/01/13 23:14:13 | emit: 55668 class: java.lang.Long




INFO   | jvm 1    | 2012/01/13 23:14:13 | output: 52 class: java.lang.Long






Total number of documents in the collection being queried: 20,057,139
Relevant MongoDB source:
https://github.com/mongodb/mongo/blob/master/src/mongo/db/commands/mr.cpp






1036                long long num = 0;




1037                long long inReduce = 0;









1140                countsBuilder.appendNumber( "input" , num );




1141                countsBuilder.appendNumber( "emit" , state.numEmits() );









1162                long long finalCount = state.postProcessCollection(op, pm);




                    state.appendResults( result );









                    timingBuilder.append( "total" , t.millis() );




                    result.append( "timeMillis" , t.millis() );




1167                countsBuilder.appendNumber( "output" , finalCount );





</description>
			<version>1.0 RC1</version>
			<fixedVersion>1.0.2, 1.1 M2, 1.2 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.mapreduce.MapReduceResults.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapreduce.MapReduceResultsUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="585" opendate="2012-12-01 08:28:43" fixdate="2012-12-03 02:47:10" resolution="Fixed">
		<buginformation>
			<summary>Exception during authentication in multithreaded access</summary>
			<description>Bug &amp;amp; further details are here:
http://forum.springsource.org/showthread.php?132878-can-t-authenticate-twice-on-same-database
Specifically what can be used for a test case is use a ThreadPoolExecutor, set a minpool and maxpool value of 5, add 25 objects to be executed.  Those objects are a class which implements Runnable.  
Those objects each then perform a bunch of inserts into mongoDB using a DocumentDao which calls mongoOperations.insert.
thanks</description>
			<version>1.1 GA</version>
			<fixedVersion>1.1.2, 1.2 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoDbUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="588" opendate="2012-12-08 16:35:30" fixdate="2012-12-12 22:45:30" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate.insert does not initialize null versions to zero</summary>
			<description>When persisting an object with a null @version field, you get different results when calling MongoTemplate.insert(Object) versus MongoTemplate.save(Object):

MongoTemplate.insert ==&amp;gt; @version = null
MongoTemplate.save ==&amp;gt; @version = 0

I think the insert method should set @version to zero when it is null, like is done for the save method.</description>
			<version>1.1.1</version>
			<fixedVersion>1.1.2, 1.2 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="583" opendate="2012-11-29 07:08:25" fixdate="2012-12-12 22:46:58" resolution="Fixed">
		<buginformation>
			<summary>Check if you are using for loop with a DBCursor</summary>
			<description>The mongodb driver has a possible memory leak, when using a DBCursor with a for loop:






DBCursor cursor = c.find();




try {




    for (DBObject obj: cursor) {




        if (someCondition(obj)) {




            return obj;




        }




    }




} finally {




    cursor.close();




}






Please see here:
https://jira.mongodb.org/browse/JAVA-664
Please check this case is used and maybe switch to a while(cursor.hasNext())</description>
			<version>1.1.1</version>
			<fixedVersion>1.1.2, 1.2 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="592" opendate="2012-12-13 21:23:45" fixdate="2012-12-16 06:42:32" resolution="Fixed">
		<buginformation>
			<summary>Persisting Objects containing Objects with PersistenceConstructor causes MappingInstantiationException</summary>
			<description>I am able to persist an object and have SringSource re-create the object from the database if all the member variables are primitive types.  This holds true if the names of the @PersistenceConstructor arguments don&amp;amp;apos;t match exactly the names of the member variables - in this case they an be matched up by using the @Field("foo") and @Value("#root.foo") annotations.  However, I get a MappingInstantiationException when I try to persist objects that contain other objects using the @PersistenceConstructor.
See StackOverflow 13854753 and StackOverflow 13832188 for details.
According to Oliver Gierke:

You seem to have found a bug. The value resulting from the first Spel expression evaluation is a DBObject and not actually translated into the parameter type. I&amp;amp;apos;ve already have some code here locally that fixes that. Would you mind creating a ticket against Spring Data MongoDB to file this as a bug?</description>
			<version>1.1.1</version>
			<fixedVersion>1.2 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">260</link>
			<link type="Relate" description="is related to">593</link>
		</links>
	</bug>
	<bug id="601" opendate="2013-01-29 02:42:36" fixdate="2013-01-29 07:48:06" resolution="Fixed">
		<buginformation>
			<summary>CannotGetMongoDbConnectionException should not print password in logfile</summary>
			<description>When the provided password and / or user is wrong we receive the following exception:






Error creating bean with name &amp;amp;apos;sameCoolClassRepository&amp;amp;apos;: FactoryBean threw exception on object creation; nested exception is org.springframework.data.mongodb.CannotGetMongoDbConnectionException:




Failed to authenticate to database [mydbname], username = [myusername], password = [thecleartextpassword]






Spring Data should never print the password in the logiles.
Suggested solution: print first and last letter: &amp;amp;apos;mysecret&amp;amp;apos; gets &amp;amp;apos;m**************t&amp;amp;apos;</description>
			<version>1.1.1</version>
			<fixedVersion>1.1.2, 1.2 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoDbUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="603" opendate="2013-02-01 06:15:07" fixdate="2013-02-01 07:00:30" resolution="Fixed">
		<buginformation>
			<summary>Results of geo queries in repository dont&amp;apos;t get metrics of supplied distance applied</summary>
			<description>Assume you have a geo query in a repository:






interface PersonRepository implements Repository&amp;lt;Person, Long&amp;gt; {









  GeoResults&amp;lt;Person&amp;gt; findByLocationNear(Point point, Distance distance);




}






Handing in a Distance in a particular metric is not regarded in the Distance instance the GeoResults instance carries in .getAverageDistance().






Distance distance = new Distance(150, Metrics.KILOMETERS);




Point point = new Point(10.0, 20.0);









GeoResults&amp;lt;Person&amp;gt; result = repository.findByLocationNear(point, distance);









// fails




assertThat(result.getAverageDistance().getMetric(), is(Metrics.KILOMETERS));





</description>
			<version>1.1.1</version>
			<fixedVersion>1.2 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.config.AbstractMongoConfiguration.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.NearQueryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.geo.GeoSpatialTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQuery.java</file>
			<file type="M">org.springframework.data.mongodb.repository.AbstractPersonRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.NearQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="380" opendate="2012-01-16 10:47:58" fixdate="2013-02-04 08:17:04" resolution="Fixed">
		<buginformation>
			<summary>maps with mongo reserved characters for keys generate on save: java.lang.IllegalArgumentException: fields stored in the db can&amp;apos;t have . in them</summary>
			<description>create an object like:






@Document




class MyDataObject {




  private Map&amp;lt;String, Long&amp;gt; impressionsByOSVersion;




}






add an entry to map like






myObject.osVersions.put("iPhone 4.3.2", 1L);






save this object using mongo operations i.e.
see exception:






java.lang.IllegalArgumentException: fields stored in the db can&amp;amp;apos;t have . in them. (Bad Key: &amp;amp;apos;iPhone 5.0.1&amp;amp;apos;)




        at com.mongodb.DBCollection.validateKey(DBCollection.java:1203)




        at com.mongodb.DBCollection._checkKeys(DBCollection.java:1171)




        at com.mongodb.DBCollection._checkKeys(DBCollection.java:1174)




        at com.mongodb.DBCollection._checkObject(DBCollection.java:1161)




        at com.mongodb.DBCollection.save(DBCollection.java:706)




        at com.mongodb.DBCollection.save(DBCollection.java:691)




        at org.springframework.data.mongodb.core.MongoTemplate$11.doInCollection(MongoTemplate.java:790)




        at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:368)




        at org.springframework.data.mongodb.core.MongoTemplate.saveDBObject(MongoTemplate.java:784)




        at org.springframework.data.mongodb.core.MongoTemplate.doSave(MongoTemplate.java:720)




        at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:707)




        at org.springframework.data.mongodb.repository.support.SimpleMongoRepository.save(SimpleMongoRepository.java:72)




        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




        at java.lang.reflect.Method.invoke(Method.java:601)




        at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:322)




        at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:307)




        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




        at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:202)




        at $Proxy3022.save(Unknown Source)






if I extend MappingMongoConverter and use it, the save works.






class KeyEscapingMongoConverter extends MappingMongoConverter {









    public KeyEscapingMongoConverter(MongoDbFactory mongoDbFactory,




        MappingContext&amp;lt;? extends MongoPersistentEntity&amp;lt;?&amp;gt;, MongoPersistentProperty&amp;gt; mappingContext) {




        super(mongoDbFactory, mappingContext);




    }









    @Override




    protected Map&amp;lt;Object, Object&amp;gt; readMap(TypeInformation&amp;lt;?&amp;gt; type, DBObject dbObject) {




        return unescapeKeys(super.readMap(type, dbObject));




    }









    @Override




    protected DBObject writeMapInternal(Map&amp;lt;Object, Object&amp;gt; map, DBObject dbo, TypeInformation&amp;lt;?&amp;gt; propertyType) {




        return super.writeMapInternal(escapeKeys(map), dbo, propertyType);




    }









    @SuppressWarnings("unchecked")




    private &amp;lt;K, V&amp;gt; Map&amp;lt;K, V&amp;gt; escapeKeys(Map&amp;lt;K, V&amp;gt; map) {




        Map&amp;lt;K, V&amp;gt; escaped = newHashMap();




        for (Object key : map.keySet()) {




            Object newKey = key;




            if (key instanceof String) {




                newKey = escapeMongoValue((String) key);




            }




            escaped.put((K) newKey, map.get(key));




        }




        return escaped;




    }









    @SuppressWarnings("unchecked")




    private &amp;lt;K, V&amp;gt; Map&amp;lt;K, V&amp;gt; unescapeKeys(Map&amp;lt;K, V&amp;gt; map) {




        Map&amp;lt;K, V&amp;gt; unescaped = newHashMap();




        for (Object key : map.keySet()) {




            Object newKey = key;




            if (key instanceof String) {




                newKey = unescapeMongoValue((String) key);




            }




            unescaped.put((K) newKey, map.get(key));




        }




        return unescaped;




    }









    private String escapeMongoValue(String raw) {




        return raw.replaceAll("\\.", "ZZ");




    }









    private String unescapeMongoValue(String raw) {




        return raw.replaceAll("ZZ", "\\.");




    }




}





</description>
			<version>1.0 GA</version>
			<fixedVersion>1.0.1, 1.1 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">398</link>
			<link type="Relate" description="relates to">615</link>
		</links>
	</bug>
	<bug id="568" opendate="2012-11-07 14:16:47" fixdate="2013-02-06 06:24:38" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate.find(...)  method causes Nullpointer if query parameter is null</summary>
			<description>If the Query query parameter is null both find methods cause a NullPointer Exception.
If query is null an IllegalArgument should be thrown.
The Assert.notnull(query) is missing</description>
			<version>1.1.1</version>
			<fixedVersion>1.1.2, 1.2 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="622" opendate="2013-02-26 01:40:45" fixdate="2013-03-05 00:52:23" resolution="Fixed">
		<buginformation>
			<summary>An unversioned object should be created using insert() instead of save.</summary>
			<description>MongoTemplate.doSaveVersioned() uses doSave() to store an unversioned object. It should rather use doInsert() to avoid race conditions on concurrent inserts.</description>
			<version>1.2 GA</version>
			<fixedVersion>1.2.1, 1.3 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="621" opendate="2013-02-26 01:34:44" fixdate="2013-03-05 00:56:11" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate.initializeVersionProperty() does not use ConversionService</summary>
			<description>The BeanWrapper used in MongoTemplate.initializeVersionProperty() is not using the ConversionService held in the MongoConverter. This can cause type assignment conflicts in case the version property is not an integer.</description>
			<version>1.2 GA</version>
			<fixedVersion>1.2.1, 1.3 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="620" opendate="2013-02-26 01:32:23" fixdate="2013-03-05 00:57:53" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate.doSaveVersioned() does not consider collection handed into the method</summary>
			<description>doSaveVersioned() calls updateFirst(query, update, objectToSave.getClass()) in an update case which essentially neglects the collectionName originally handed into the method.</description>
			<version>1.2 GA</version>
			<fixedVersion>1.2.1, 1.3 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.core.PersonWithVersionPropertyOfTypeInteger.java</file>
		</fixedFiles>
	</bug>
	<bug id="633" opendate="2013-03-25 09:10:22" fixdate="2013-03-25 09:13:51" resolution="Fixed">
		<buginformation>
			<summary>Upgrade to Querydsl 3.0.0</summary>
			<description></description>
			<version>1.2.1</version>
			<fixedVersion>1.3 M1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializer.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">669</link>
		</links>
	</bug>
	<bug id="617" opendate="2013-02-20 02:13:42" fixdate="2013-03-25 10:47:17" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException in MongoTemplate.initializeVersionProperty()</summary>
			<description>If mongoPersistentEntity is null, NullPointerException is thrown (line 671).
Write this (ligne 669) : 






if (mongoPersistentEntity != null &amp;amp;&amp;amp; mongoPersistentEntity.hasVersionProperty()) 






Instead of : 






if (mongoPersistentEntity == null || mongoPersistentEntity.hasVersionProperty())





</description>
			<version>1.1.2</version>
			<fixedVersion>1.2.1, 1.3 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">646</link>
		</links>
	</bug>
	<bug id="629" opendate="2013-03-22 04:08:25" fixdate="2013-03-27 04:22:53" resolution="Fixed">
		<buginformation>
			<summary>Different results when using count and find with the same criteria with &amp;apos;id&amp;apos; field</summary>
			<description>Assume we have following query:






Query q = query(where(&amp;amp;apos;id&amp;amp;apos;).regex(&amp;amp;apos;zzz&amp;amp;apos;))






mongoTemplate.find(q,java.util.HashMap.class,&amp;amp;apos;test&amp;amp;apos;) gives following query (peeked in mongo console):






{ "ts" : ISODate("2013-03-22T10:00:51.685Z"),




  "op" : "query",




  "ns" : "test.test",




  "query" : {




		"id" : /zzz/




	},




	"nscanned" : 1,




	"responseLength" : 20,




	"millis" : 0,




	"client" : "127.0.0.1",




	"user" : ""




}






The same query, when used in count (mongoTemplate.count(q,&amp;amp;apos;test&amp;amp;apos;)) gives:






{




	"ts" : ISODate("2013-03-22T10:00:36.299Z"),




	"op" : "command",




	"ns" : "test.$cmd",




	"command" : {




		"count" : "test",




		"query" : {




			"_id" : /zzz/




		}




	},




	"ntoreturn" : 1,




	"responseLength" : 48,




	"millis" : 0,




	"client" : "127.0.0.1",




	"user" : ""




}






This is inconsistent since we could have records with field id and they will be retrieved properly from the db. Count on the other hand will give bad results since it uses _id field.
In org.springframework.data.mongodb.core.convert.QueryMapper the method determineKey, for some reason treats id and _id as the same field. This is probably the cause of the strange behaviour because find() method does not use QueryMapper and count() does.</description>
			<version>1.1.1</version>
			<fixedVersion>1.2.1, 1.3 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.MongoMappingContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="642" opendate="2013-04-02 02:18:55" fixdate="2013-04-02 02:47:02" resolution="Fixed">
		<buginformation>
			<summary>MongoChangeSetPersister does not use mapped collection name</summary>
			<description></description>
			<version>1.1.1</version>
			<fixedVersion>1.2.1, 1.3 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.crossstore.CrossStoreMongoTests.java</file>
			<file type="M">org.springframework.data.mongodb.crossstore.MongoChangeSetPersister.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">594</link>
		</links>
	</bug>
	<bug id="594" opendate="2012-12-24 11:37:31" fixdate="2013-04-02 03:40:27" resolution="Fixed">
		<buginformation>
			<summary>cross-store=&gt; Define document name using annotation</summary>
			<description>In a cross-store configuration, the RelatedDocument is stored in a MongoDB collection using the container&amp;amp;apos;s Entity&amp;amp;apos;s package name.
It would be nice if the collection name would be either the name of the class (document, not entity) or as specified using annotations(@Document(collection="")).
This "issue" is caused by the class
org.springframework.data.mongodb.crossstore.MongoChangeSetPersister
which gets the name of the collection from the method getCollectionNameForEntity which does:
return ClassUtils.getQualifiedName(entityClass);</description>
			<version>1.1.1</version>
			<fixedVersion>1.2.1, 1.3 M1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.crossstore.CrossStoreMongoTests.java</file>
			<file type="M">org.springframework.data.mongodb.crossstore.MongoChangeSetPersister.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">642</link>
		</links>
	</bug>
	<bug id="646" opendate="2013-04-08 03:56:44" fixdate="2013-04-08 11:15:14" resolution="Duplicate">
		<buginformation>
			<summary>Can&amp;apos;t insert DBObjects through MongoTemplate</summary>
			<description>It appears that inserting DBObject instances directly through MongoTemplate is no longer possible in 1.2.0. Is this supposed to be the case?
When I try to insert a raw DBObject (to test conversion logic from old schema to new upon read), the following exception is thrown:






java.lang.NullPointerException




	at org.springframework.data.mongodb.core.MongoTemplate.initializeVersionProperty(MongoTemplate.java:671)




	at org.springframework.data.mongodb.core.MongoTemplate.doInsert(MongoTemplate.java:651)




	at org.springframework.data.mongodb.core.MongoTemplate.insert(MongoTemplate.java:613)




	at com.portalify.a.project.AnITCase.testThatRequiresInsertionOfRawObjects(AnITCase.java:123)






The direct problem is that initializeVersionProperty() doesn&amp;amp;apos;t do proper null checking before calling mongoPersistentEntity.getVersionProperty(). In fact, it specifically allows proceeding to the problematic branch when mongoPersistentEntity is null.</description>
			<version>1.2 GA</version>
			<fixedVersion>1.2.1, 1.3 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">617</link>
		</links>
	</bug>
	<bug id="571" opendate="2012-11-09 08:00:10" fixdate="2013-04-11 03:05:45" resolution="Fixed">
		<buginformation>
			<summary>Spring Data for MongoDb doesn&amp;apos;t save null values when @Version is added to domain class </summary>
			<description>Scenario:
1. Domain class is loaded from mongodb using CrudRepository.findOne() method.
2. The loaded instances any non id nor @Version annotated field is set to null. 
3. The loaded instance is saved to same mongodb using CrudRepository.save() method.
4. The field that has been set to null doesnt write to database, its unchanged.
Important: The problem doesnt occur when @Version annotation is not used in the domain class definition.</description>
			<version>1.1.1</version>
			<fixedVersion>1.2.1, 1.3 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.Update.java</file>
		</fixedFiles>
	</bug>
	<bug id="663" opendate="2013-04-24 03:21:19" fixdate="2013-04-26 06:47:53" resolution="Fixed">
		<buginformation>
			<summary>org.springframework.data.mongodb.core.query.Field needs an equals method</summary>
			<description>The above class Field does not has an equals() method.
But org.springframework.data.mongodb.core.query.Query has an equals method which is using the equals method of the Field class.






boolean fieldsEqual = this.fieldSpec == null ? that.fieldSpec == null : this.fieldSpec.equals(that.fieldSpec);






Please implement an equals on the Field method.
Purpose: For unit testing the equals method is needed.</description>
			<version>1.2.1</version>
			<fixedVersion>1.3 M1, 1.2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.query.Field.java</file>
		</fixedFiles>
	</bug>
	<bug id="669" opendate="2013-05-03 10:58:37" fixdate="2013-05-03 11:05:43" resolution="Duplicate">
		<buginformation>
			<summary>Incompatibility with Querydsl 3.1.1</summary>
			<description>





java.lang.NoSuchMethodError: com.mysema.query.types.PathMetadata.getExpression()Lcom/mysema/query/types/Expression;




	at org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializer.getKeyForPath(SpringDataMongodbSerializer.java:66)




	at com.mysema.query.mongodb.MongodbSerializer.visit(MongodbSerializer.java:223)




	at com.mysema.query.mongodb.MongodbSerializer.visit(MongodbSerializer.java:34)




	at com.mysema.query.types.PathImpl.accept(PathImpl.java:94)




	at com.mysema.query.mongodb.MongodbSerializer.asDBValue(MongodbSerializer.java:75)




	at com.mysema.query.mongodb.MongodbSerializer.asDBKey(MongodbSerializer.java:71)




	at com.mysema.query.mongodb.MongodbSerializer.visit(MongodbSerializer.java:93)




	at com.mysema.query.mongodb.MongodbSerializer.visit(MongodbSerializer.java:34)




	at com.mysema.query.types.expr.BooleanOperation.accept(BooleanOperation.java:61)




	at com.mysema.query.mongodb.MongodbSerializer.handle(MongodbSerializer.java:39)




	at com.mysema.query.mongodb.MongodbSerializer.visit(MongodbSerializer.java:102)




	at com.mysema.query.mongodb.MongodbSerializer.visit(MongodbSerializer.java:34)




	at com.mysema.query.types.OperationImpl.accept(OperationImpl.java:91)




	at com.mysema.query.mongodb.MongodbSerializer.handle(MongodbSerializer.java:39)




	at com.mysema.query.mongodb.MongodbQuery.createQuery(MongodbQuery.java:389)




	at com.mysema.query.mongodb.MongodbQuery.createCursor(MongodbQuery.java:286)




	at com.mysema.query.mongodb.MongodbQuery.createCursor(MongodbQuery.java:281)




	at com.mysema.query.mongodb.MongodbQuery.list(MongodbQuery.java:267)




	at org.springframework.data.mongodb.repository.support.QueryDslMongoRepository.findAll(QueryDslMongoRepository.java:93)




	at org.springframework.data.mongodb.repository.support.QueryDslMongoRepository.findAll(QueryDslMongoRepository.java:47)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:601)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:333)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:318)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)




	at com.sun.proxy.$Proxy27.findAll(Unknown Source)




	at ch.twinf.mongodb.repositories.PersonRepositoryTest.querydsl(PersonRepositoryTest.java:137)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:601)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)




	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)




	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:74)




	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:83)




	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:231)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:88)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)




	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)




	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:71)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:174)




	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)




	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)





</description>
			<version>1.2.1</version>
			<fixedVersion>1.3 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializer.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">633</link>
		</links>
	</bug>
	<bug id="679" opendate="2013-05-22 08:18:46" fixdate="2013-05-23 12:33:31" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate.doSave() passed a JSON String doesn&amp;apos;t save it.</summary>
			<description>I have Spring 3.1.2 setup to TEXT messages off a queue(that contain JSON), then insert them into a mongo database.
The MongoTemplate.doSave(..) method is passed in 
collectionName = "audit_log"
objectToSave = "{"nanosecond":528023582734299,"clientID":"300","action":"ENTRY"";
writer = MappingMongoConvertor()
These are all correct.
The code though has this...
if (!(objectToSave instanceof String)) {
	writer.write(objectToSave, dbDoc);
} else {
	try 
{
		objectToSave = (T) JSON.parse((String) objectToSave);
	}
 catch (JSONParseException e) 
{
		throw new MappingException("Could not parse given String to save into a JSON document!", e);
	}
}
maybeEmitEvent(new BeforeSaveEvent&amp;lt;T&amp;gt;(objectToSave, dbDoc));
Object id = saveDBObject(collectionName, dbDoc, objectToSave.getClass());
So the objectToSave is a String, so the first IF statement fails, and it goes into the ELSE section.
The &amp;amp;apos;objectToSave&amp;amp;apos; is then correctly pasrsed into a BasicDBObject with the correct values.
The saveDBObject() method though is not passed in the objectToSave.
Its passed in the collectionName (which is correct). 
The dbDoc which is empty since we&amp;amp;apos;ve put nothing into it.
and the objectToSave.getClass()
So how will it ever save the objectToSave if its not passed into the save method ??
I suspect it should have something like...
objectToSave = (T) JSON.parse((String) objectToSave);
followed by
dbDoc = (com.mongodb.BasicDBObject)objectToSave
Note my spring config is using a int-jms:channel to wire in the queue to Mongo.
&amp;lt;int-jms:channel id="saveToDBChannel"  
    	queue-name="ESI_AUDIT" 
    	auto-startup="true" concurrency="50"&amp;gt;
    &amp;lt;/int-jms:channel&amp;gt;
    &amp;lt;int-mongodb:outbound-channel-adapter id="outBoundMongoAdapter"
        collection-name="audit_log"  
        mongodb-factory="mongoDbFactory" channel="saveToDBChannel" /&amp;gt;
If you require a WAR that is a test of this, please let me know.
Thanks
Jeff
Note: this affect version 1.1.2(at least) to 1.2.1
</description>
			<version>1.2.1</version>
			<fixedVersion>1.3 M1, 1.2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="683" opendate="2013-05-23 22:49:52" fixdate="2013-05-24 00:26:22" resolution="Fixed">
		<buginformation>
			<summary>QueryMapper does not handle default _id when no MappingMetadata is present</summary>
			<description></description>
			<version>1.2.1</version>
			<fixedVersion>1.3 M1, 1.2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="676" opendate="2013-05-20 10:06:35" fixdate="2013-05-24 00:43:42" resolution="Fixed">
		<buginformation>
			<summary>SimpleMongoRepository fails if used with customized collection name</summary>
			<description>SimpleMongoRepository fails if MongoEntityInformation is passed to initialize the repository which customized collection name for entity.
It fails with 
SimpleMongoRepository#findOne(id)
SimpleMongoRepository#delete(id)
SimpleMongoRepository#delete(entity)
</description>
			<version>1.2.1</version>
			<fixedVersion>1.3 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoOperations.java</file>
			<file type="M">org.springframework.data.mongodb.repository.support.SimpleMongoRepository.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="706" opendate="2013-06-29 04:04:09" fixdate="2013-06-29 06:05:43" resolution="Fixed">
		<buginformation>
			<summary>QueryMapper does not transform DBRefs in nested keywords correctly</summary>
			<description></description>
			<version>1.2.1</version>
			<fixedVersion>1.2.2, 1.3 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="693" opendate="2013-06-12 06:04:14" fixdate="2013-07-02 07:40:16" resolution="Fixed">
		<buginformation>
			<summary>MongoFactoryBean should create a mongo instance with host/port if replicaset is null or empty</summary>
			<description>I&amp;amp;apos;m initializing mongo with a spring xml. I&amp;amp;apos;m using propertyPlaceHolderConfigurer to inject parameters that are coming from jndi.
I can configure my application with a replicatset or not (a simple host). 
The only workaround to distinct the two cases is to inject a empty string for replicaset when i&amp;amp;apos;m using a simple host. But MongoFactoryBean should ignore this property in this case.
</description>
			<version>1.1.1</version>
			<fixedVersion>1.2.2, 1.3 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoFactoryBeanIntegrationTest.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoFactoryBean.java</file>
			<file type="M">org.springframework.data.mongodb.config.ServerAddressPropertyEditor.java</file>
			<file type="M">org.springframework.data.mongodb.config.ServerAddressPropertyEditorUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="688" opendate="2013-06-03 14:11:53" fixdate="2013-07-08 03:12:11" resolution="Fixed">
		<buginformation>
			<summary>There is no precedence between @Id annotation and field named "id" - both are attempted to be used</summary>
			<description>If you have a domain class with an attribute named "id", even if you annotate a DIFFERENT field with "@Id", spring-data-mongo errors trying to map 2 things to the id.  While the error is correct in that you can&amp;amp;apos;t have 2, it surprises me that one doesn&amp;amp;apos;t take precedence over the other.
I tried (in vain) to find this issue listed in jira, having read about it from a post in the forums after hitting the same issue myself, so apologies if this is a duplicate.
Original forum post here: http://forum.springsource.org/showthread.php?120188-_id-mapping</description>
			<version>1.2.1</version>
			<fixedVersion>1.3 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.mapping.MongoPersistentProperty.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.MongoMappingContextUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.BasicMongoPersistentEntity.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.BasicMongoPersistentProperty.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">342</link>
		</links>
	</bug>
	<bug id="392" opendate="2012-02-07 04:28:15" fixdate="2013-07-08 06:13:48" resolution="Fixed">
		<buginformation>
			<summary>Updating an object does not write type information for objects to be updated</summary>
			<description>I&amp;amp;apos;m using quite complex domain model, that consist of instantiable domain classes as well as of abstract ones. I used 1.0.0.M5 version, and the type information (under _class key) was stored with object when it was necessary to be able to read it from database later. That worked perfectly for me till my upgrade to 1.0.0.RELEASE version that broke my application as it saves the objects without type information and later it is impossible to read it back to java model. 
What I found is that MappingMongoConverter.writeInternal(...) method that in turn calls addCustomTypeIfNecessary(...) (line 330) which puts type information into DBObject. During execution of convertToMongoType(...) (at line 851) removeTypeInfoRecursively(...) is called which clears type data saved earlier under _class key. I had to comment out this call in order to 
The first point is that there is a contradiction: why to save type information to DBObject if it is later removed by other method? The second point is that there should be a way to persist the type information inferred from runtime along the persisted object and not just the class definition.
</description>
			<version>1.0 RC1</version>
			<fixedVersion>1.3 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">459</link>
			<link type="Relate" description="relates to">407</link>
			<link type="Relate" description="relates to">724</link>
		</links>
	</bug>
	<bug id="702" opendate="2013-06-20 00:12:30" fixdate="2013-07-09 02:35:34" resolution="Fixed">
		<buginformation>
			<summary>Spring Data MongoDB projection search, is not properly configured with respective Java Pojo</summary>
			<description>If Model Java POJO, is annotated with @Field, then during search with
query.fields().include(field)
uning mongoTemplate
it does not java property field as field parameter, rather it needs the name declared with name defined with @Field annotation.</description>
			<version>1.2.1</version>
			<fixedVersion>1.3 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="717" opendate="2013-07-10 11:13:46" fixdate="2013-07-10 14:09:31" resolution="Fixed">
		<buginformation>
			<summary>Application context is not properly distributed to persistent entities</summary>
			<description>The MongoMappingContext does not properly distribute the application context when set to persistent entities that have already been added.
Current code:






MongoMappingContext.java






	@Override




	protected &amp;lt;T&amp;gt; BasicMongoPersistentEntity&amp;lt;T&amp;gt; createPersistentEntity(TypeInformation&amp;lt;T&amp;gt; typeInformation) {









		BasicMongoPersistentEntity&amp;lt;T&amp;gt; entity = new BasicMongoPersistentEntity&amp;lt;T&amp;gt;(typeInformation);









		if (context != null) {




			entity.setApplicationContext(context);




		}









		return entity;




	}









	




	@Override




	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {









		this.context = applicationContext;




		super.setApplicationContext(applicationContext);




	}






Possible fix:






MongoMappingContext.java






@Override




	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {









		this.context = applicationContext;




		super.setApplicationContext(applicationContext);




                // Send the application context to ALL the PersistentEntities, not just ones created after this point




               for (BasicMongoPersistentEntity entity : getPersistentEntities()) {




                   entity.setApplicationContext(applicationContext);




               }




	}






See referenced URL PoC, no_indexes branch, test: MultiTenantTest::testMultiTenantSave() for example.
UPDATE:
AbstractMongoConfiguration is calling initialize() on MongoMappingContext before it returns the object.






AbstractMongoConfiguration






        @Bean




	public MongoMappingContext mongoMappingContext() throws ClassNotFoundException {









		MongoMappingContext mappingContext = new MongoMappingContext();




		mappingContext.setInitialEntitySet(getInitialEntitySet());




		mappingContext.setSimpleTypeHolder(customConversions().getSimpleTypeHolder());




		mappingContext.initialize(); // &amp;lt;----









		return mappingContext;




	}





</description>
			<version>1.2.1</version>
			<fixedVersion>1.2.2, 1.3 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.config.AbstractMongoConfigurationUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">569</link>
		</links>
	</bug>
	<bug id="721" opendate="2013-07-11 11:36:06" fixdate="2013-07-16 04:40:15" resolution="Fixed">
		<buginformation>
			<summary>Polymorphic attribute type not persisted on update operations</summary>
			<description>We found a problem with Spring Data for Mongo DB.
Here is our situation: we have an entity which have an attribute which is a list of another kind of entity, like the code below.
@Document
public class ParentClass {
   private List&amp;lt;ChildClass&amp;gt; list;
}
the ChildClass is annotated with @Document too, but we want to store it&amp;amp;apos;s content as an embed document of ParentClass.
When using MongoTemplate class with code such as below, the _class attribute is not inserted on the embedded document, so, if one of the items of the list attribute is a subclass of ChildClass, and ChildClass is an abstract class, we begin to face instantiation problems.
Here is one example of usage of MongoTemplate in which we found a problem.
mongoTemplate.updateFirst(Query.query(criteria), 
  new Update().push("list", child));
If child is a subclass of ChildClass, the _class attribute is not added to the embedded document.</description>
			<version>1.2.1</version>
			<fixedVersion>1.3 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">345</link>
		</links>
	</bug>
	<bug id="741" opendate="2013-08-06 12:03:08" fixdate="2013-08-07 01:27:12" resolution="Fixed">
		<buginformation>
			<summary>Trying to &amp;apos;group&amp;apos; on a field of a sub-object causes an error in Spring Data MongoDB 1.3.0.RC1</summary>
			<description>Using the new Aggregation support fails when I try to &amp;amp;apos;group&amp;amp;apos; on a property of a sub-object.  The referenced Gist should give enough context.  Following things in the debugger lead me to believe that the code is trying to resolve the &amp;amp;apos;code&amp;amp;apos; property on the parent object instead of the contained sub-object.  Using a top-level property works great.  I&amp;amp;apos;ve run the equivalent aggregation in the MongoDB shell and it allows me to &amp;amp;apos;group&amp;amp;apos; on the sub-object&amp;amp;apos;s property so it doesn&amp;amp;apos;t appear to be illegal in MongoDB.</description>
			<version>1.3 RC1</version>
			<fixedVersion>1.3 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.aggregation.ExposedFieldsAggregationOperationContext.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.GroupOperationUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.ExposedFields.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.Fields.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.AggregationUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.TypeBasedAggregationOperationContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="602" opendate="2013-01-30 02:22:53" fixdate="2013-08-07 10:11:51" resolution="Fixed">
		<buginformation>
			<summary>Querying with $in operator on the id field of type BigInteger returns zero results</summary>
			<description>There is a problem when trying to query for documents with id field is in a given list of BigInteger values. Id field is mapped as a BigInteger.
For example, these lines will work only if given id list contains only one item.






List&amp;lt;BigInteger&amp;gt; profileIds = findProfileIds();




Predicate predicate = QProfileDocument.profileDocument.id.in(profileIds);




Iterable&amp;lt;ProfileDocument&amp;gt; profiles = profileRepository.findAll(predicate);






The underlying MongodbQuery is different if there is only one item in profileIds. The query looks like this for a profileIds with multiple elements






{ "_id" : { "$in" : [ "25069473312490162649510603609" , "25045916045544535958655878835"]}}






and it looks like this when there is only one item in the list.






{ "_id" : { "$oid" : "5100fb776c67e7e092be6b59"}}






In the first case, query will return no results and in the second it will work and return an Iterable with one item.
As you can see, the problem is with the representation of the BigInteger. using decimal format will not work with MongoDB.</description>
			<version>1.1.1</version>
			<fixedVersion>1.3 GA, 1.2.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="737" opendate="2013-08-01 21:18:51" fixdate="2013-08-12 00:53:30" resolution="Fixed">
		<buginformation>
			<summary>Extra MongoSynchronizations cause TransactionSynchronizationManager to throw IllegalStateException on transaction complete</summary>
			<description>Multiple Mongo databases are being accessed in a transactional test case. When the transaction is rolled back at the end of the test, the following exception is thrown:
2013-08-01 19:55:56,774 ERROR [org.springframework.transaction.support.TransactionSynchronizationUtils] - &amp;lt;TransactionSynchronization.beforeCompletion threw exception&amp;gt;
java.lang.IllegalStateException: No value for key [Mongo: localhost/127.0.0.1:27017] bound to thread [main]
at org.springframework.transaction.support.TransactionSynchronizationManager.unbindResource(TransactionSynchronizationManager.java:209)
at org.springframework.transaction.support.ResourceHolderSynchronization.beforeCompletion(ResourceHolderSynchronization.java:69)
at org.springframework.transaction.support.TransactionSynchronizationUtils.triggerBeforeCompletion(TransactionSynchronizationUtils.java:106)
at org.springframework.transaction.support.AbstractPlatformTransactionManager.triggerBeforeCompletion(AbstractPlatformTransactionManager.java:937)
at org.springframework.transaction.support.AbstractPlatformTransactionManager.processRollback(AbstractPlatformTransactionManager.java:834)
at org.springframework.transaction.support.AbstractPlatformTransactionManager.rollback(AbstractPlatformTransactionManager.java:822)
at org.springframework.test.context.transaction.TransactionalTestExecutionListener$TransactionContext.endTransaction(TransactionalTestExecutionListener.java:519)
at org.springframework.test.context.transaction.TransactionalTestExecutionListener.endTransaction(TransactionalTestExecutionListener.java:293)
at org.springframework.test.context.transaction.TransactionalTestExecutionListener.afterTestMethod(TransactionalTestExecutionListener.java:186)
at org.springframework.test.context.TestContextManager.afterTestMethod(TestContextManager.java:406)
at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:91)
at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)
at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:231)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)
at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)
at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)
at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)
at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)
at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)
at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)
at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:71)
at org.junit.runners.ParentRunner.run(ParentRunner.java:300)
at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:174)
at org.junit.runner.JUnitCore.run(JUnitCore.java:157)
at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:76)
at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:195)
at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:63)
This is a similar stack trace that was filed for DATAMONGO-546. I looked for a code resolution to that issue, but it appears that it was closed because the reporter upgraded and the issue disappeared.
After some debugging of the interaction between MongoDbUtils and TransactionSynchronizationManager, I have a working theory as to the cause. In a nutshell, MongoDbUtils invokes TransactionSynchronizationManager for each database in the same Mongo instance. This ends up registering two MongoSynchronizations that have the same holder. As such, there is only one resource bound in the TransactionSynchronizationManager, (see MongoDbUtils.java lines 124-139). When the transaction is completed, TransactionSynchronizationUtils.triggerBeforeCompletion() is invoked and it iterates through the MongoSynchronizations in effect invoking unbindResource() for each. The first database&amp;amp;apos;s synchronization unbinds the holder by Mongo key. The second fails because the holder is only bound once.
I am willing to submit a patch for this issue that does one of two things:
1. Override MongoSynchronization.beforeCompletion() and MongoSynchronization.suspend() so that they utilize unbindResourceIfPossible(), or
2. Modify MongoDbUtils.doGetDB() so that it only registers one MongoSynchronization per Mongo instead of one per database.
I am not sure which of these two options is "better", so some feedback from the committer community would be appreciated before I get too far into the weeds!</description>
			<version>1.2.1</version>
			<fixedVersion>1.3 GA, 1.2.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoDbUtils.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoDbUtilsUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="540" opendate="2012-09-13 22:48:20" fixdate="2013-08-21 23:45:19" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate upsert and findOne handle id queries differently</summary>
			<description>With a domain object class that has @Id annotated property:






public class Item {




  @Id




  private String id;




  






If these objects are upserted using MongoTemplate and the resulting object is then fetched with exactly the same query using findOne() method, the upsert fails silently (ie. no exception or error messages in debug logs) but findOne() returns the correct object (in applications point of view).






Query query = new Query(Criteria.where("id").is(identifier));




mongoTemplate.upsert(query, update, collectionName);




Item item = mongoTemplate.findOne(query, Item.class, collectionName);






In mongod logs:






Thu Sep 13 14:25:51 [conn91] update db.collection query: { id: "foo" } update: { $inc: { totalClickCount: 1 } } 0ms




Thu Sep 13 14:25:51 [conn91] query db.collection query: { _id: "foo" } ntoreturn:1 idhack:1 reslen:61 0ms






This shows that in upsert method, id in the query is resolved to id, whereas in findOne() method it is resolved to _id. 
Because of this, the upsert creates or updates a document {id : "foo", _id : 
{"$oid" : &amp;lt;something&amp;gt;}
 ...} but findOne returns the document {_id : "foo" ...}
If I change the property in query to _id like this: 






Query query = new Query(Criteria.where("_id").is(identifier));






everything works as expected.
Now I know, having browsed through this project&amp;amp;apos;s JIRA, that it is confusing to use id-property and @Id at the same time and should be avoided. The problem here is, IMO, that MongoTemplate methods resolve these queries differently leading to confusing results.
The example works as expected (upsert() succeeds and findOne() returns the created object) up until 1.0.2.</description>
			<version>1.0.3</version>
			<fixedVersion>1.2.2, 1.3 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="445" opendate="2012-05-07 23:15:38" fixdate="2013-08-22 09:19:54" resolution="Fixed">
		<buginformation>
			<summary>GeoNear Query Doesn&amp;apos;t Work with Pageable</summary>
			<description>I am trying to perform a geoNear query in conjunction with a point and a pageable parameter and it seems that the paging functionality doesn&amp;amp;apos;t work. Regardless of what I set the page and size parameters of the pageable to the query always returns 100 results. I have created a test case that demonstrates the issue. Please note that there are three test cases with comments. The findAll() test case demonstrates paging functionality working as expected and the other two test cases demonstrate paging functionality not working. 
One possible clue as to what is going might be the fact that findAll() utilizes QueryUtils.applyPagination() in the SimpleMongoRepository class to specify the query skip and limit values but the same isn&amp;amp;apos;t done for the geoNear queries and so it defaults to page 0 and size 100.</description>
			<version>1.0.1</version>
			<fixedVersion>1.3 GA, 1.2.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.query.NearQuery.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.NearQueryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQuery.java</file>
			<file type="M">org.springframework.data.mongodb.repository.AbstractPersonRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.geo.GeoResults.java</file>
		</fixedFiles>
	</bug>
	<bug id="753" opendate="2013-09-10 21:16:34" fixdate="2013-09-26 07:33:31" resolution="Fixed">
		<buginformation>
			<summary>Add support for nested field references in group operations</summary>
			<description> use Spring Data (1.3.0.RC1) to access our MongoDB and for some new queries I want to use the aggregation framework.
In the mongo shell the command would be:
db.spotreports.aggregate(

{ "$unwind" : "$pd"}
 , { "$group" : { "_id" : "$pd.PDch", "base" : {$sum : "$pd.aBL"}, "uplift" : {$sum : "$pd.up"}}})
{
"result" : [
{
"_id" : 5,
"base" : 529133,
"uplift" : 21516
},
...
The Spring Code I use is:
Aggregation agg = Aggregation.newAggregation(
Aggregation.unwind("pd"),
Aggregation.group("pd.PDch").sum("pd.aBL").as("base").sum("pd.up").as("uplift")
);
AggregationResults&amp;lt;SpotReportResult&amp;gt; result = mongoTemplate.aggregate(agg, resolveCollection(), SpotReportResult.class);
I get the following error:
java.lang.IllegalArgumentException: Invalid reference &amp;amp;apos;PDch&amp;amp;apos;!
at org.springframework.data.mongodb.core.aggregation.ExposedFieldsAggregationOperationContext.getReference(ExposedFieldsAggregationOperationContext.java:63)
at org.springframework.data.mongodb.core.aggregation.ExposedFieldsAggregationOperationContext.getReference(ExposedFieldsAggregationOperationContext.java:47)
at org.springframework.data.mongodb.core.aggregation.GroupOperation.toDBObject(GroupOperation.java:284)
at org.springframework.data.mongodb.core.aggregation.Aggregation.toDbObject(Aggregation.java:228)
I wonder why spring want to reference &amp;amp;apos;PDch&amp;amp;apos; instead of &amp;amp;apos;pd.PDch&amp;amp;apos;?</description>
			<version>1.3.1</version>
			<fixedVersion>1.3.2 (Babbage SR1), 1.4 M1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.aggregation.ExposedFieldsAggregationOperationContext.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.ProjectionOperation.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.UnwindOperation.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.GroupOperation.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.AggregationTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.Aggregation.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.AggregationUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.TypeBasedAggregationOperationContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="761" opendate="2013-09-24 01:50:30" fixdate="2013-10-08 03:43:25" resolution="Fixed">
		<buginformation>
			<summary>ClassCastException in SpringDataMongodbSerializer.getKeyForPath</summary>
			<description>Hello,
I recently upgraded from querydsl 2.9.0 to 3.2.3 and spring-data-mongodb 1.2.1.RELEASE to 1.3.1.RELEASE.
Currently, some of my MongoDB entities have inner objects stored using maps with Long keys :






    @Document(collection = "xxx")




    @QueryEntity




    public class ObjectA {




        private Map&amp;lt;Long, ObjectB&amp;gt; objects;




    }






I used to query such objects using the QueryDslPredicateExecutor repository interface. For instance, I used to check whether a map key was present with : QObjectA.objectA.objects.get(objectId).isNotNull()
With the updated versions, I now get a ClassCastException I didn&amp;amp;apos;t experience before :






    java.lang.ClassCastException: java.lang.Long cannot be cast to java.lang.String




        at com.mysema.query.types.PathMetadata.getName(PathMetadata.java:70)




        at org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializer.getKeyForPath(SpringDataMongodbSerializer.java:66)






Judging by the source code of PathMetadata, it looks like the correct behaviour might be to use getElement().toString() instead of getName() :
https://github.com/mysema/querydsl/blob/master/querydsl-core/src/main/java/com/mysema/query/types/PathMetadata.java
What do you think ?</description>
			<version>1.3.1</version>
			<fixedVersion>1.3.2 (Babbage SR1), 1.4 M1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializer.java</file>
			<file type="M">org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializerUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="534" opendate="2012-09-08 13:45:30" fixdate="2013-10-13 03:46:07" resolution="Fixed">
		<buginformation>
			<summary>The GridFs query execution does not return sorted resources, when the sorting fields are defined in the query definition</summary>
			<description>The sorting fields of a Query instance are disregarded during the query execution using an instance of GridFsOperations. The result sets of the found GridFS files are not sorted no matter of the existence of the sorting fields in the preceding query. I expected the resources to be sorted according to the instructions of the corresponding sorting fields.
Example (a dummy one):
Prerequisites:
1. At least 2 files have been stored using GridFs
2. We have certain meta-data fields, which are used as part of the criteria, but we will miss, since they are irrelevant to the example.






@Autowired




private GridFsOperations ops;









Query query = Query.query(Criteria.where(...));




query = query.sort().on("uploadDate", Order.DESCENDING);









final List&amp;lt;GridFSDBFile&amp;gt; files = ops.find(query);






The results in the list, named files, will not be sorted according to the standard GridFsDbFile attribute uploadDate. I believe that the reason lies into the default implementation of the GridFsOperations, more precisely in the class GridFsTemplate. There the method getMappedQuery(Query), which is used for a basic mapping facility from Query to DBObject is implemented like this:






private DBObject getMappedQuery(Query query) {




	return query == null ? null : queryMapper.getMappedObject(query.getQueryObject(), null);




}






I believe that this is the problematic call, since I debugged the DBObject returned from the invocation of the queryMapper.getMappedObject() and it never contained any sorting fields no matter that they were part of if the transformed Query instance. I think that if one goes through the MongoTemplate find-ers implementations, she / he may find the mapping implementation there way better than what is currently available with the GridFs implementation.</description>
			<version>1.1 RC1</version>
			<fixedVersion>1.4 M1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.gridfs.GridFsTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.gridfs.GridFsTemplateIIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="752" opendate="2013-09-10 03:48:06" fixdate="2013-10-13 04:53:00" resolution="Fixed">
		<buginformation>
			<summary>QueryMapper prevents searching for values that start with a $ [dollarsign]</summary>
			<description>When querying for values that start with a dollar sign the QueryMapper.Keyword#isKeyword recognizes this as a keyword, resulting in a ClassCastException (QueryMapper.java:311)
The following snippet demonstrates this behaviour:






mongoTemplate.find(query(where("myvalue").is("$334")), My.class);






The mongo keywords (&amp;amp;apos;$gt&amp;amp;apos; etc.) would usually be provided with the associated methods (.gt() etc.). A is() query should either not try to recognize keywords or at least be more specific (not only check for a leading &amp;amp;apos;$&amp;amp;apos;).
How could a query for a value that starts with a dollar sign be written otherwise, using the Spring MongoTemplate?</description>
			<version>1.2.3</version>
			<fixedVersion>1.3.2 (Babbage SR1), 1.4 M1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="746" opendate="2013-09-04 07:43:44" fixdate="2013-10-25 02:15:17" resolution="Fixed">
		<buginformation>
			<summary>IndexInfo cannot be read for indices created via mongo shell</summary>
			<description>As described in the stackoverflow post, spring mongo data cannot retrieve the index information for an index that has been created via the mongo shell.
Trisha from 10gen traced the root cause down to this:
"I would recommend reporting this to the guys at Spring, you will not be the only one who experiences this. I found the problem in DefaultIndexOperations lines 138 - 141 in version 1.1.1 of spring-data-mongodb."
I figure this issue also exists in later versions though I did not get around to test it myself.</description>
			<version>1.1.1</version>
			<fixedVersion>1.3.2 (Babbage SR1), 1.4 M1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.DefaultIndexOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="788" opendate="2013-10-29 02:09:11" fixdate="2013-10-31 07:50:33" resolution="Fixed">
		<buginformation>
			<summary>Projection operations do not render synthetic fields properly.</summary>
			<description>If a part "a" of a group id _id.a is referenced in a projection operation it should be rendered as 





"a":"$_id.a"





 while it is currently rendered as 





"a":1





.</description>
			<version>1.3.2 (Babbage SR1)</version>
			<fixedVersion>1.4 M1 (Codd), 1.3.3 (Babbage SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.aggregation.ProjectionOperation.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.ProjectionOperationUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.Field.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.ExposedFields.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.AggregationUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.Fields.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.AggregationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">757</link>
		</links>
	</bug>
	<bug id="789" opendate="2013-10-31 00:47:07" fixdate="2013-11-06 03:20:25" resolution="Fixed">
		<buginformation>
			<summary>Support login via different (e.g. admin) authentication database</summary>
			<description>MongoDB allows to have users to be defined in the &amp;amp;apos;admin&amp;amp;apos; database that have permissions in other databases. See last example in http://docs.mongodb.org/manual/tutorial/add-user-to-database/. Before MongoDB 2.4, a login was automatically checked both in the database you connected to and in the &amp;amp;apos;admin&amp;amp;apos; database. Since MongoDB 2.4, you need to explicitly mention the authentication database when logging in via the tools.
If you connect via the Driver, you need to first connect to the &amp;amp;apos;admin&amp;amp;apos; database to authenticate, and then switch to the database of your choice.
This option is missing from the Spring-Data-MongoDB integration module.






    &amp;lt;mongo:mongo id="mongo" write-concern="#{T(com.mongodb.WriteConcern).ACKNOWLEDGED}"




                 replica-set="${mongo.mongoReplicaSet}"/&amp;gt;




    &amp;lt;mongo:db-factory id="mongoDbFactory"




                      dbname="${mongo.mongoDatabaseName}"




                      username="${mongo.mongoUser}"




                      password="${mongo.mongoPass}"




                      mongo-ref="mongo"









authenticationDatabase="${mongo.authenticationDatabase}"




/&amp;gt; &amp;lt;!-- authenticationDatabase missing --&amp;gt;




    &amp;lt;mongo:auditing/&amp;gt;






The use of users in the admin database was enforced by our MongoDB consultants.</description>
			<version>1.3.1</version>
			<fixedVersion>1.4 M1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.SimpleMongoDbFactoryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.monitor.ServerInfo.java</file>
			<file type="M">org.springframework.data.mongodb.config.MongoNamespaceTests.java</file>
			<file type="M">org.springframework.data.mongodb.config.AbstractMongoConfiguration.java</file>
			<file type="M">org.springframework.data.mongodb.config.AbstractMongoConfigurationUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoAdmin.java</file>
			<file type="M">org.springframework.data.mongodb.core.SimpleMongoDbFactory.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoDbUtils.java</file>
			<file type="M">org.springframework.data.mongodb.config.MongoDbFactoryParser.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoDbUtilsIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="804" opendate="2013-11-28 02:01:03" fixdate="2013-12-04 03:14:35" resolution="Fixed">
		<buginformation>
			<summary>EnableMongoRepositories repositoryImplementationPostfix() default is empty String instead of "Impl"</summary>
			<description>In contrast to the doc, which states that the default repositoryImplementationPostfix is "Impl", the default is actually set to empty string:
String repositoryImplementationPostfix() default "";
Took me a while to figure out why my RepositoryImpl was not recognised...</description>
			<version>1.4 M1 (Codd)</version>
			<fixedVersion>1.3.3 (Babbage SR2), 1.4 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.config.EnableMongoRepositories.java</file>
		</fixedFiles>
	</bug>
	<bug id="806" opendate="2013-12-04 08:49:32" fixdate="2013-12-09 08:12:39" resolution="Fixed">
		<buginformation>
			<summary>Spring Data MongoDB - Aggregation Framework - No property _id found for type com.entity.User</summary>
			<description>In the mongo shell the command would be:
db.custom.aggregate([
{$project:{"msgs" : 1,"_id" : 1}},
{$unwind:"$msgs"},
{$match:{"msgs.createDate" :
{"$gt":ISODate( "2013-12-04T06:07:14.609Z")}
}}, 
{ "$group" : { "_id" : "$_id" }}])
=-----------
The Spring Code I use is:
public class User {
	private int id;
	private String name;
	private List&amp;lt;PushMessage&amp;gt; msgs;
};
Aggregation aggre = Aggregation.newAggregation(User.class,new AggregationOperation[]
{
		Aggregation.project("msgs","_id"),
		Aggregation.unwind("msgs"),
                Aggregation.match(Criteria.where("msgs.createDate").gt(date)),
     		Aggregation.group("_id").push("msgs").as("msgs")
		}
);
AggregationResults&amp;lt;User&amp;gt; r =dboper.aggregate(aggre, User.class,User.class);
I get the following error:
org.springframework.data.mapping.PropertyReferenceException: No property _id found for type com.entity.User
	at org.springframework.data.mapping.PropertyPath.&amp;lt;init&amp;gt;(PropertyPath.java:75)
	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:327)
	at org.springframework.data.mapping.PropertyPath.create(PropertyPath.java:307)
	at org.springframework.data.mapping.PropertyPath.from(PropertyPath.java:271)
	at org.springframework.data.mapping.PropertyPath.from(PropertyPath.java:245)</description>
			<version>1.3.2 (Babbage SR1)</version>
			<fixedVersion>1.3.3 (Babbage SR2), 1.4 RC1 (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.aggregation.AggregationTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.ExposedFields.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.TypeBasedAggregationOperationContext.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.ProjectionOperation.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.TypeBasedAggregationOperationContextUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="805" opendate="2013-12-02 06:34:36" fixdate="2014-01-14 05:35:09" resolution="Fixed">
		<buginformation>
			<summary>Excluding DBRef field in a query causes a MappingException</summary>
			<description>Excluding a field in a query where the field is a DBRef as below throws a MappingException.
Query query = new Query(Criteria.where("parentField").is("test"));
        query.fields().exclude("children");
        ParentClass parentClass = mongoOperations.findOne(query, ParentClass.class);
Exception trace:
org.springframework.data.mapping.model.MappingException: No mapping metadata found for class java.lang.Integer
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.createDBRef(MappingMongoConverter.java:729)
	at com.digitalshadows.collation.persistence.impl.CollectionNameProvidedMongoConverter.createDBRef(CollectionNameProvidedMongoConverter.java:28)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.toDBRef(MappingMongoConverter.java:288)
	at org.springframework.data.mongodb.core.convert.QueryMapper.convertAssociation(QueryMapper.java:273)
	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedValue(QueryMapper.java:204)
	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedObject(QueryMapper.java:113)
	at org.springframework.data.mongodb.core.MongoTemplate.doFindOne(MongoTemplate.java:1439)
	at org.springframework.data.mongodb.core.MongoTemplate.findOne(MongoTemplate.java:489)
	at org.springframework.data.mongodb.core.MongoTemplate.findOne(MongoTemplate.java:484)
	at ExcludeDBRefFieldTest.testExcludeChildren(ExcludeDBRefFieldTest.java:28)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:74)
	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:83)
	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:231)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:88)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)
	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)
	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:71)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:300)
	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:174)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)
I&amp;amp;apos;ve attached a simple test case that throws the MappingException. The workaround for this I can currently see is to use include for all the other fields instead.</description>
			<version>1.3.2 (Babbage SR1)</version>
			<fixedVersion>1.4 RC1 (Codd), 1.3.4 (Babbage SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.MappingTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="816" opendate="2013-12-18 00:36:29" fixdate="2014-01-14 06:02:15" resolution="Fixed">
		<buginformation>
			<summary>Unable to execute query with DocumentCallbackHandler when query contains Criteria with enums.</summary>
			<description>spring-data-mongodb - 1.3.3.RELEASE
mongo-java-driver - 2.11.3
Unable to execute query using void org.springframework.data.mongodb.core.MongoTemplate.executeQuery(Query query, String collectionName, DocumentCallbackHandler dch)
with queries which contain Criteries with Enums.






Stack trace






:




java.lang.IllegalArgumentException: can&amp;amp;apos;t serialize class Day




	at org.bson.BasicBSONEncoder._putObjectField(BasicBSONEncoder.java:273)




	at org.bson.BasicBSONEncoder.putIterable(BasicBSONEncoder.java:298)




	at org.bson.BasicBSONEncoder._putObjectField(BasicBSONEncoder.java:237)




	at org.bson.BasicBSONEncoder.putObject(BasicBSONEncoder.java:174)




	at org.bson.BasicBSONEncoder._putObjectField(BasicBSONEncoder.java:229)




	at org.bson.BasicBSONEncoder.putObject(BasicBSONEncoder.java:174)




	at org.bson.BasicBSONEncoder.putObject(BasicBSONEncoder.java:120)




	at com.mongodb.DefaultDBEncoder.writeObject(DefaultDBEncoder.java:27)




	at com.mongodb.OutMessage.putObject(OutMessage.java:289)




	at com.mongodb.OutMessage.writeQuery(OutMessage.java:211)




	at com.mongodb.OutMessage.query(OutMessage.java:84)




	at com.mongodb.DBApiLayer$MyCollection.__find(DBApiLayer.java:285)




	at com.mongodb.DBApiLayer$MyCollection.__find(DBApiLayer.java:273)




	at com.mongodb.DBCursor._check(DBCursor.java:368)




	at com.mongodb.DBCursor._hasNext(DBCursor.java:459)




	at com.mongodb.DBCursor.hasNext(DBCursor.java:484)




	at org.springframework.data.mongodb.core.MongoTemplate.executeQueryInternal(MongoTemplate.java:1701)




	at org.springframework.data.mongodb.core.MongoTemplate.executeQuery(MongoTemplate.java:377)




	at org.springframework.data.mongodb.core.MongoTemplate.executeQuery(MongoTemplate.java:350)






Please find little unit test in attachment</description>
			<version>1.3.3 (Babbage SR2)</version>
			<fixedVersion>1.4 RC1 (Codd), 1.3.4 (Babbage SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="686" opendate="2013-05-28 05:57:30" fixdate="2014-01-23 04:12:21" resolution="Fixed">
		<buginformation>
			<summary>ClassCastException while reusing Query object</summary>
			<description>When I create a query on document _id with $in operator and reuse that query to do another search i get ClassCastException.
Query creation:






query.addCriteria(Criteria.where("_id").in(signedPetitionIds));






Reusing query (as a filterQuery argument):






private Page&amp;lt;PetitionHeader&amp;gt; findPetitionHeaders(Pageable pageable, Query filterQuery, Sort sort) {




	long count = mongoOp.count(filterQuery, PetitionHeader.class);




	filterQuery.with(pageable);




	filterQuery.with(sort);




	List&amp;lt;PetitionHeader&amp;gt; headers = mongoOp.find(filterQuery, PetitionHeader.class);




	return new PageImpl&amp;lt;PetitionHeader&amp;gt;(headers, pageable, count);




}






Stacktrace:






java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to java.lang.Iterable




	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedValue(QueryMapper.java:159) ~[spring-data-mongodb-1.2.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedObject(QueryMapper.java:90) ~[spring-data-mongodb-1.2.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedKeyword(QueryMapper.java:112) ~[spring-data-mongodb-1.2.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedObject(QueryMapper.java:79) ~[spring-data-mongodb-1.2.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:1337) ~[spring-data-mongodb-1.2.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:1323) ~[spring-data-mongodb-1.2.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.MongoTemplate.find(MongoTemplate.java:495) ~[spring-data-mongodb-1.2.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.MongoTemplate.find(MongoTemplate.java:486) ~[spring-data-mongodb-1.2.1.RELEASE.jar:na]






Object returned by valueDbo.get(inKey) (in line 159) is of type Object[].</description>
			<version>1.2.1</version>
			<fixedVersion>1.4 RC1 (Codd), 1.3.4 (Babbage SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="807" opendate="2013-12-08 05:14:31" fixdate="2014-01-27 09:34:03" resolution="Fixed">
		<buginformation>
			<summary>using findAndModify removes the _class field of encapsulated classes, causing MappingInstantiationException</summary>
			<description>given the two classes:
public interface IUser{
}
public class User implements IUser{
    public int i;
}
public class UserWrapper{
    private IUser user;
}
when using findAndModify on a UserWrapper collection, 
the "_class" field from the User class is removed.
when trying to restore the UserWrapper class, 
a MappingInstantiationException is being thrown with "Failed to instantiate IUser using constructor NO_CONSTRUCTOR with arguments.</description>
			<version>1.3.2 (Babbage SR1)</version>
			<fixedVersion>1.4 RC1 (Codd), 1.3.4 (Babbage SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapperUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">407</link>
		</links>
	</bug>
	<bug id="407" opendate="2012-02-24 07:21:40" fixdate="2014-01-27 11:11:45" resolution="Fixed">
		<buginformation>
			<summary>Collection with generics losing element type after $set update</summary>
			<description>The example that works fine in TestThatWorks.java :

inserting a new object using mongoOps
adding a new element and then update it using mongoOps
querying the data, printing the list, the list still contains the correct element type

The example that does not work as expected in TestThatFails.java :

inserting a new object using mongoOps
adding a new element and then update it using mongoOps
querying the data, printing the list, the list now contains LinkedHashMap instead of the original element type

The difference between the 2 example lies in the parameterized nestedDomain&amp;amp;apos;s List object. Without the parameterization using generics, the list will retain the type. Using generics on the list will result in LinkedHashMap after getting updated on the nestedDomain.
Strangely, the TestThatFails will work fine if the query is using is("bean1") which means the collection element when insertion happens instead of is("bean2"), which is the collection element when update happens.
Please help !</description>
			<version>1.0.1</version>
			<fixedVersion>1.4 RC1 (Codd), 1.3.4 (Babbage SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapperUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">807</link>
			<link type="Relate" description="is related to">392</link>
		</links>
	</bug>
	<bug id="675" opendate="2013-05-14 17:45:05" fixdate="2014-01-28 01:04:11" resolution="Fixed">
		<buginformation>
			<summary>findAndModify doesn&amp;apos;t use field value annotation for update object</summary>
			<description>I am using the @Field annotation on some of my fields to keep the full variable name in java but shorten the mongodb key associated to it. Example: 






@Field(value = "desc")




protected String description;






Everywhere I can still use the java name (e.g. description) to query with criteria except in findAndModify() from the MongoTemplate class.
I dug into your code to try to understand why and noticed in doFindAndModify() you are not calling the mapper.getMappedObject() on the update object passed in parameters. Is there any reason for that? Because it is called in the doUpdate() (line 927).
It is not a big issue but just wanted to know why it was not consistent with the rest.</description>
			<version>1.2.1</version>
			<fixedVersion>1.2.2, 1.3 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.Update.java</file>
		</fixedFiles>
	</bug>
	<bug id="830" opendate="2014-01-23 08:09:40" fixdate="2014-02-11 05:56:17" resolution="Fixed">
		<buginformation>
			<summary>NPE during cache warmup in CustomConversions</summary>
			<description>The cache seems not to be able to handle heavy load during its warmup phase.
We use 42 threads in parallel in performance test scenario (a lot of database operations in each thread) and got the NPE in one of five runs.
Using a ConcurrentHashMap solves the problem.






java.lang.NullPointerException




     at org.springframework.data.mongodb.core.convert.CustomConversions.getCustomReadTarget(CustomConversions.java:329)




     at org.springframework.data.mongodb.core.convert.CustomConversions.hasCustomReadTarget(CustomConversions.java:283)




     at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:200)




     at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:187)




     at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:183)




     at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:77)




     at org.springframework.data.mongodb.core.MongoTemplate$ReadDbObjectCallback.doWith(MongoTemplate.java:1975)




     at org.springframework.data.mongodb.core.MongoTemplate.executeFindOneInternal(MongoTemplate.java:1626)




     at org.springframework.data.mongodb.core.MongoTemplate.doFindOne(MongoTemplate.java:1446)




     at org.springframework.data.mongodb.core.MongoTemplate.findById(MongoTemplate.java:539)




     at org.springframework.data.mongodb.repository.support.SimpleMongoRepository.findOne(SimpleMongoRepository.java:100)




     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




     at java.lang.reflect.Method.invoke(Method.java:606)




     at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.executeMethodOn(RepositoryFactorySupport.java:358)




     at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:343)




     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




     at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)




     at com.sun.proxy.$Proxy26.findOne(Unknown Source)




     at de.is24.offer.mongodb.evaluation.ReadYourOwnDataRightTask.countNumberOfInvalidResults(ReadYourOwnDataRightTask.java:34)




     at de.is24.offer.mongodb.evaluation.ReadYourOwnDataRightTask$$FastClassByCGLIB$$2b453a69.invoke(&amp;lt;generated&amp;gt;)




     at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)




     at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:698)




     at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150)




     at org.springframework.aop.interceptor.AsyncExecutionInterceptor$1.call(AsyncExecutionInterceptor.java:95)




     at java.util.concurrent.FutureTask.run(FutureTask.java:262)




     at java.lang.Thread.run(Thread.java:744)





</description>
			<version>1.3.3 (Babbage SR2)</version>
			<fixedVersion>1.3.4 (Babbage SR3), 1.4 GA (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.CustomConversions.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">518</link>
		</links>
	</bug>
	<bug id="410" opendate="2012-02-29 22:44:05" fixdate="2014-02-17 02:20:55" resolution="Fixed">
		<buginformation>
			<summary>Update with pushAll doesnt recognize defined Converter</summary>
			<description>I am not being lazy, but i think this quote from the code that i attach can describe better :






List&amp;lt;MyNested&amp;gt; someValues = Arrays.asList(new MyNested("my"), new MyNested("name"), new MyNested("is"));




MyNested[] array = new MyNested[someValues.size()];




this.ops.updateFirst(




	Query.query(Criteria.where("id").is("testId")),




	new Update().pushAll("nestedList", someValues.toArray(array)), // fails with exception




// new Update().set("nestedList", someValues.toArray()), // this works fine !




// new Update().set("myNested", new MyNested("my")), // this works fine !




	COLLECTION_NAME);






Using pushAll() will results in exception, and also i notice that the converter&amp;amp;apos;s debugging message is not displayed. And the error message seems to say that it can&amp;amp;apos;t serialize my custom class where it should be the dbObject that should be serialized.
Here&amp;amp;apos;s the exception trace :






Exception in thread "main" java.lang.RuntimeException: json can&amp;amp;apos;t serialize type : class kam.albert.domain.test.post.TestConverterThatFails$MyNested




	at com.mongodb.util.JSON.serialize(JSON.java:261)




	at com.mongodb.util.JSON.serialize(JSON.java:210)




	at com.mongodb.util.JSON.serialize(JSON.java:141)




	at com.mongodb.util.JSON.serialize(JSON.java:141)




	at com.mongodb.util.JSON.serialize(JSON.java:58)




	at com.mongodb.BasicDBObject.toString(BasicDBObject.java:84)




	at java.lang.String.valueOf(Unknown Source)




	at java.lang.StringBuilder.append(Unknown Source)




	at org.springframework.data.mongodb.core.MongoTemplate$12.doInCollection(MongoTemplate.java:840)




	at org.springframework.data.mongodb.core.MongoTemplate$12.doInCollection(MongoTemplate.java:826)




	at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:368)




	at org.springframework.data.mongodb.core.MongoTemplate.doUpdate(MongoTemplate.java:826)




	at org.springframework.data.mongodb.core.MongoTemplate.updateFirst(MongoTemplate.java:812)




	at kam.albert.domain.test.post.TestConverterThatFails.test(TestConverterThatFails.java:50)




	at kam.albert.domain.test.post.TestConverterThatFails.main(TestConverterThatFails.java:30)





</description>
			<version>1.0.1</version>
			<fixedVersion>1.3.4 (Babbage SR3), 1.4 GA (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapperUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">354</link>
		</links>
	</bug>
	<bug id="828" opendate="2014-01-21 04:29:09" fixdate="2014-02-17 02:37:26" resolution="Fixed">
		<buginformation>
			<summary>UpdateFirst throws OptimisticLockingFailureException when updating document that does not exist</summary>
			<description>when updating a document that does not exists using MongoTemplage.updateFirst an OptimisticLockingFailureException is thrown in case of a non multi update.






@Test




public void updateFirstShouldDoNothingWhenCalledForEntitiesThatDoNotExist() {




		




	Query q = query(where("id").is(Long.MIN_VALUE));




	Assume.assumeThat(template.findOne(q, VersionedPerson.class), IsNull.nullValue());




		




	template.updateFirst(q, Update.update("lastname", "supercalifragilisticexpialidocious"), VersionedPerson.class);




	Assert.assertThat(template.findOne(q, VersionedPerson.class), IsNull.nullValue());




}





</description>
			<version>1.4 M1 (Codd)</version>
			<fixedVersion>1.3.4 (Babbage SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="354" opendate="2011-12-20 00:14:49" fixdate="2014-02-17 02:55:12" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate does not support multiple $pushAll in one update</summary>
			<description>Update.push uses "addMultiFieldOperation". For some reason Update.pushAll does not. Second pushAll over-writes the first one.</description>
			<version>1.0 RC1</version>
			<fixedVersion>1.4 GA (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.UpdateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.Update.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">410</link>
			<link type="Relate" description="is related to">812</link>
		</links>
	</bug>
	<bug id="404" opendate="2012-02-20 13:36:46" fixdate="2014-02-19 11:14:49" resolution="Fixed">
		<buginformation>
			<summary>Removing a DBRef using pull does not work </summary>
			<description>I&amp;amp;apos;m trying to remove a reference to an object from a document 






Update update = new Update().pull("objects.$id", new ObjectId(objectId));






It does not remove the reference. Using: {$pull : { "objects" : 
{ $id : ObjectId("blah") }
 } } works. Am i doing something wrong here?
</description>
			<version>1.0.1</version>
			<fixedVersion>1.4 GA (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapperUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">855</link>
		</links>
	</bug>
	<bug id="852" opendate="2014-02-19 04:43:31" fixdate="2014-02-21 04:59:44" resolution="Fixed">
		<buginformation>
			<summary>Increase version for update does not traverse DBObject correctly in order to find version property.</summary>
			<description>Version property is nested and therefore not resolved correctly.






{




  $inc : {version : 1}




}





</description>
			<version>1.4 RC1 (Codd)</version>
			<fixedVersion>1.4 GA (Codd)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.Update.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.UpdateTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">811</link>
		</links>
	</bug>
	<bug id="833" opendate="2014-01-24 02:52:54" fixdate="2014-02-25 21:03:24" resolution="Fixed">
		<buginformation>
			<summary>EnumSet is not handled correctly</summary>
			<description>Using EnumSet as collection for enums caused exception when BasicDBList from database is mapped back to EnumSet.
Stack trace when version org.springframework.data:spring-data-mongodb:1.3.3.RELEASE is used:






java.lang.IllegalArgumentException: Could not instantiate Collection type: java.util.EnumSet




	at org.springframework.core.CollectionFactory.createCollection(CollectionFactory.java:258)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.readCollectionOrArray(MappingMongoConverter.java:778)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.readValue(MappingMongoConverter.java:1048)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.access$100(MappingMongoConverter.java:77)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter$MongoDbPropertyValueProvider.getPropertyValue(MappingMongoConverter.java:999)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.getValueInternal(MappingMongoConverter.java:755)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter$1.doWithPersistentProperty(MappingMongoConverter.java:256)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter$1.doWithPersistentProperty(MappingMongoConverter.java:249)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:257)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:249)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:223)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:187)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:183)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:77)




	at org.springframework.data.mongodb.core.MongoTemplate$ReadDbObjectCallback.doWith(MongoTemplate.java:1975)




	at org.springframework.data.mongodb.core.MongoTemplate.executeFindMultiInternal(MongoTemplate.java:1671)




	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:1496)




	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:1480)




	at org.springframework.data.mongodb.core.MongoTemplate.find(MongoTemplate.java:527)




	at org.springframework.data.mongodb.core.MongoTemplate.find(MongoTemplate.java:518)




	...




Caused by: java.lang.InstantiationException: java.util.EnumSet




	at java.lang.Class.newInstance0(Class.java:342)




	at java.lang.Class.newInstance(Class.java:310)




	at org.springframework.core.CollectionFactory.createCollection(CollectionFactory.java:255)




	...





</description>
			<version>1.3.3 (Babbage SR2)</version>
			<fixedVersion>1.4.1 (Codd SR1), 1.5 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">451</link>
		</links>
	</bug>
	<bug id="862" opendate="2014-02-25 19:59:24" fixdate="2014-02-27 07:57:12" resolution="Fixed">
		<buginformation>
			<summary>Update Array Field Using Positional Operator ($) Does Not Work</summary>
			<description>After updating to a newer version of Spring Data MongoDB, I found that I can no longer update array fields. The most recent version I observed this to work correctly is 1.2.x.
In 1.3.x and above, it seems that the positional operator ($) is removed from the key.
For example:
mongoOps.findAndModify(new Query(), new Update().set("options.$.name", "color"), MongoProduct.class);
In the actual command, "options.$.name" turns into "options.name".
This results in the mongodb error: "exception: can&amp;amp;apos;t append to array using string field name: name"</description>
			<version>1.3.4 (Babbage SR3)</version>
			<fixedVersion>1.4.1 (Codd SR1), 1.5 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapperUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">243</link>
		</links>
	</bug>
	<bug id="829" opendate="2014-01-21 05:52:16" fixdate="2014-03-03 06:41:48" resolution="Fixed">
		<buginformation>
			<summary>NearQuery, when used in conjunction with a Query, it sets num=0, unless Query specifies otherwise</summary>
			<description>Hello,
i have built the following query:






public GeoResults&amp;lt;MyObject&amp;gt; findByTypeAndLocationNear(MyObjectType type, Point p, Distance distance) {




   final Query query = Query.query(Criteria.where("type").is(type.name()));




   final NearQuery nearQuery = NearQuery.near(p).maxDistance(distance).query(query);




   log.info("{}",nearQuery.toDBObject());




   return mongoTemplate.geoNear(nearQuery, MyObject.class);




}






And it logs to this:






{ "query" : { "type" : "small"} , "maxDistance" : 1.567855942887398E-4 , "distanceMultiplier" : 6378.137 , "num" : 0 , "near" : [ x , y] , "spherical" : true}






Where is this "num=0" coming from? I did not set any limits.
In the 1.2.1 release, "num" is an Integer and is only used in the DBObject, when it is != null. When i set a Query, "num" is left untouched and therefore it does not appear in the DBObject. See [1]
Starting from 1.2.4 release, "num" is still an Integer, but when i set a Query, this time "num" gets the "limit" value of the Query, which by default is always 0. See [2]
I dont see this subtle change mentioned in the latest change file.
My opinion is, to use the limit value from Query is very convenient and makes sense, but it should only be used, if someone has explicitly set a limit for the Query object (probably its enough to check, if the limit is &amp;gt; 0)
The same applies on "skip", but it is not used in NearQuery anyways.
What do you guys think?
[1] http://grepcode.com/file/repo1.maven.org/maven2/org.springframework.data/spring-data-mongodb/1.2.1.RELEASE/org/springframework/data/mongodb/core/query/NearQuery.java#NearQuery.query%28org.springframework.data.mongodb.core.query.Query%29
[2] http://grepcode.com/file/repo1.maven.org/maven2/org.springframework.data/spring-data-mongodb/1.2.4.RELEASE/org/springframework/data/mongodb/core/query/NearQuery.java#NearQuery.query%28org.springframework.data.mongodb.core.query.Query%29
[3] http://docs.mongodb.org/manual/reference/command/geoNear/
[4] http://docs.spring.io/spring-data/mongodb/docs/1.3.3.RELEASE/changelog.txt</description>
			<version>1.2.4</version>
			<fixedVersion>1.3.5 (Babbage SR4), 1.4.1 (Codd SR1), 1.5 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.query.NearQuery.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.NearQueryUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="821" opendate="2014-01-08 15:11:31" fixdate="2014-03-06 02:38:20" resolution="Fixed">
		<buginformation>
			<summary>MappingException for $size queries on subcollections containing dbrefs</summary>
			<description>For repository method definition like below:






@Query("{meanings: {$not: {$size: 0}}}")




Page&amp;lt;Entry&amp;gt; findAllWithMeanings(Pageable pageable);






Entry documents contain meanings field which is a list of @DBRef s. When I remove @DBRef annotation it works ok, but otherwise I get the following exception:






Exception in thread "main" org.springframework.data.mapping.model.MappingException: No mapping metadata found for class com.mongodb.BasicDBObject




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.createDBRef(MappingMongoConverter.java:729)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.toDBRef(MappingMongoConverter.java:288)




	at org.springframework.data.mongodb.core.convert.QueryMapper.convertAssociation(QueryMapper.java:273)




	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedKeyword(QueryMapper.java:158)




	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedObject(QueryMapper.java:111)




	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:1489)




	at org.springframework.data.mongodb.core.MongoTemplate.doFind(MongoTemplate.java:1480)




	at org.springframework.data.mongodb.core.MongoTemplate.find(MongoTemplate.java:527)




	at org.springframework.data.mongodb.repository.query.AbstractMongoQuery$PagedExecution.execute(AbstractMongoQuery.java:205)




	at org.springframework.data.mongodb.repository.query.AbstractMongoQuery.execute(AbstractMongoQuery.java:93)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:337)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)




	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)










</description>
			<version>1.3.3 (Babbage SR2)</version>
			<fixedVersion>1.4.1 (Codd SR1), 1.5 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQueryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.AbstractPersonRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.PersonRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="863" opendate="2014-02-25 21:30:25" fixdate="2014-03-06 02:48:39" resolution="Fixed">
		<buginformation>
			<summary>QueryMapper.getMappedValue Fails To Handle Arrays Mapped To $in</summary>
			<description>I have a scenario where I run the following update to pull array elements with the given ids:
List&amp;lt;BigInteger&amp;gt; idsToRemove = Arrays.asList(
    BigInteger.valueOf(123), BigInteger.valueOf(234));
Update update = new Update()
        .pull("options",
            new BasicDBObject("_id",
            new BasicDBObject("$in", mongoOps
                .getConverter().convertToMongoType(idsToRemove))));
mongoOps.findAndModify(new Query(), update, MongoProduct.class);
This used to work before version 1.4.
Using version 1.4, I get a java.lang.ClassCastException (see attachment).
This seems to be due to a double call to QueryMapper.getMappedValue(Field, Object) from UpdateMapper.getMappedObjectForField(Field, Object) at line 80 of UpdateMapper, the first of which converts idsToRemove (which is already a BasicDBList) to an array of strings. The second call to getMappedValue from within super.getMappedObjectForField then tries to cast that array to Iterable&amp;lt;?&amp;gt;, which fails.
Finally, this might be a little out of scope, but I feel that if a BasicDBObject is passed to the Spring Data API, it should be taken as is. It should not be re-converted/re-mapped!</description>
			<version>1.4 GA (Codd)</version>
			<fixedVersion>1.4.1 (Codd SR1), 1.5 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="868" opendate="2014-03-04 02:23:16" fixdate="2014-03-06 02:53:47" resolution="Fixed">
		<buginformation>
			<summary>findAndModify method does not increment @Version field.</summary>
			<description>DATAMONGO-811 addresses this issue for update methods. But findAndModify method still lacks the version increment.</description>
			<version>1.3.4 (Babbage SR3)</version>
			<fixedVersion>1.4.1 (Codd SR1), 1.5 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="843" opendate="2014-02-05 13:07:34" fixdate="2014-03-06 02:56:22" resolution="Fixed">
		<buginformation>
			<summary>Unable to use @EnableMongoAuditing annotation in Java config</summary>
			<description>When declaring an @EnableMongoAuditing annotation on a configuration, application startup fails due to an exception: NoSuchBeanDefinitionException: No bean named &amp;amp;apos;mappingContext&amp;amp;apos; is defined.   This error only occurs if auditing is enabled.</description>
			<version>1.4 RC1 (Codd)</version>
			<fixedVersion>1.4.1 (Codd SR1), 1.5 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.config.MongoAuditingRegistrar.java</file>
			<file type="M">org.springframework.data.mongodb.config.AuditingViaJavaConfigRepositoriesTests.java</file>
			<file type="M">org.springframework.data.mongodb.config.GridFsTemplateParser.java</file>
			<file type="M">org.springframework.data.mongodb.config.BeanNames.java</file>
			<file type="M">org.springframework.data.mongodb.config.MongoParser.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.event.AuditingEventListener.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.event.AuditingEventListenerUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.config.MappingMongoConverterParserIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.config.MappingMongoConverterParserValidationIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.config.MappingMongoConverterParser.java</file>
			<file type="M">org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean.java</file>
			<file type="M">org.springframework.data.mongodb.config.MongoTemplateParser.java</file>
			<file type="M">org.springframework.data.mongodb.config.MongoAuditingBeanDefinitionParser.java</file>
			<file type="M">org.springframework.data.mongodb.repository.config.MongoRepositoryConfigurationExtension.java</file>
			<file type="M">org.springframework.data.mongodb.config.MongoDbFactoryParser.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">901</link>
			<link type="Relate" description="relates to">455</link>
		</links>
	</bug>
	<bug id="877" opendate="2014-03-10 04:32:05" fixdate="2014-03-10 05:14:11" resolution="Fixed">
		<buginformation>
			<summary>AbstractMongoConfiguration.getMappingBasePackage() throws NullPointerException if config class resides in default package</summary>
			<description></description>
			<version>1.3.4 (Babbage SR3)</version>
			<fixedVersion>1.3.5 (Babbage SR4), 1.4.1 (Codd SR1), 1.5 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.config.AbstractMongoConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="880" opendate="2014-03-17 09:06:21" fixdate="2014-03-20 02:40:50" resolution="Fixed">
		<buginformation>
			<summary>Error when trying to persist an object containing a DBRef which was lazy loaded.</summary>
			<description>When fetching a property which is annotated as DBRef(lazy = true) the object returned is a CGLIB proxy. If we use this proxy as a value for the property of a new object and try to persist it, the object is not found.






Template.java






// New object we are trying to persist




public class Template {









    private String id;




    @DBRef(lazy = true)




    private Content content;









}











If the template object above is loaded from the database and the content property is used for the message below, then the id of the DbRef is not resolved when saved since the target is a proxy.






Message.java






// New object we are trying to persist




public class Message {









    private String id;




    @DBRef




    private Content content;









}






A workaround would be to switch this object back to eager loading.</description>
			<version>1.4.1 (Codd SR1)</version>
			<fixedVersion>1.5 M1 (Dijkstra), 1.4.2 (Codd SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.DbRefMappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.DefaultDbRefResolver.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.DbRefResolver.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.LazyLoadingTestUtils.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="887" opendate="2014-03-20 21:01:31" fixdate="2014-03-27 04:28:55" resolution="Fixed">
		<buginformation>
			<summary>Repository not instantiated when entity contains field of type TreeMap</summary>
			<description>Repository fails to instantiate when the entity contains a TreeMap with value class that does not have a convertor. I&amp;amp;apos;ve tested with HashMap, HashSet, TreeSet but this only seems to affect TreeMap.






// Repository




public interface SourceRepository extends PagingAndSortingRepository&amp;lt;MyEntity, ObjectId&amp;gt; {




}









// Entity




@Document("test_collection")




public class MyEntity {




private TreeMap&amp;lt;String,MyClass&amp;gt; treeMap;




}









// TreeMap value class




public class MyClass {




private String foo = "bar";




}






This succeeds if i build a convertor for MyClass but it really shouldn&amp;amp;apos;t need one. This is working in 1.4.0.RELEASE but fails in version 1.4.1.RELEASE and beyond.






Throws: java.lang.ArrayIndexOutOfBoundsException: 0




In: org.springframework.data.util.ParameterizedTypeInformation.getComponentType(ParameterizedTypeInformation.java:148)





</description>
			<version>1.4.1 (Codd SR1)</version>
			<fixedVersion>1.5 M1 (Dijkstra), 1.4.2 (Codd SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">479</link>
		</links>
	</bug>
	<bug id="884" opendate="2014-03-19 00:24:34" fixdate="2014-03-31 06:22:23" resolution="Fixed">
		<buginformation>
			<summary>Potential NullPointerException for lazy DBRefs</summary>
			<description>Revised upon request by Thomas Darimont:
NullPointerException occurs when calling overriden Object method of the field with "@DBRef(lazy=true)"
Assume class B has override toString method as below:
public class B
{
   @Id
   private String id;
   private String value;
   @Override
   public String toString()
{
      return String.format("B[id=&amp;amp;apos;%s&amp;amp;apos;, value=&amp;amp;apos;%s&amp;amp;apos;]",id,value);
   }
}

Assume class A contains class B as a field with annotation "DBRef(lazy=true)" as below:

public class A
{
   @Id
   private String id;

   @DBRef(lazy=true)
   public B b;

   @Override
   public String toString()
   {
      return String.format("A[b=&amp;amp;apos;%s&amp;amp;apos;]",b);
   }
}

When a class A object has queried from MongoTemplate and calls to println as below:
A obj = mongoTemplate().findOne(new Query(...), A.class);
System.out.println(obj);

The above code raised exception in "LazyLoadingInterceptor" class within "DefaultDbRefResolver" class:
@Override
public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
   return ReflectionUtils.isObjectMethod(method) ? method.invoke(obj, args) : method.invoke(ensureResolved(), args);
}

It seems that ReflectionUtils.isObjectMethod(method) returns "true" for even the method is an overriden method, so results to call
method.invoke(obj, args); // which result NullPointerException since obj is null.
where it should actually call 
method.invoke(ensureResolved(), args);

p.s. It seems obj is always "null" within the function "DefaultDbRefResolver::LazyLoadingInterceptor::intercept()." I was wondering if there is any reason for checking if the method is an Object method  by "ReflectionUtils.isObjectMethod(method)," since whether it is object method or not, method.invoke(obj,args) will always result NullPointerException due to obj is "null."

------------------------------------------------------------------------------------------------------------------------------------------------------------------
Original Message:

DefaultDbRefResolver.intercept function only check if the method is originally from Object class, but does not check if the method is an override method of Object. when the method is an override method of Object then it should call ensureResolved() instead of just calling method.invoke(obj,args).

For example.

When @DBRef(lazy=true) is used and toString method is override, it result NullPointerException.

public class B
{
   @Id
   private String id;
   private String value;

   @Override
   public String toString(){      return String.format("B[id=&amp;amp;apos;%s&amp;amp;apos;, value=&amp;amp;apos;%s&amp;amp;apos;]",id,value);   }
}
public class A
{
   @DBRef(lazy=true)
   public B b;
   @Override
   public String toString()
   {
      return String.format("A[b=&amp;amp;apos;%s&amp;amp;apos;]",b);
   }
}
So in DefaultDbRefResolver.intercept method should change as below
@Override
public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable 
{
   return ReflectionUtils.isObjectMethod(method) &amp;amp;&amp;amp; method.getDeclaringClass()==Object.class ? method.invoke(obj, args) : method.invoke(ensureResolved(), args);
		}
</description>
			<version>1.4.1 (Codd SR1)</version>
			<fixedVersion>1.5 M1 (Dijkstra), 1.4.2 (Codd SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.DbRefMappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.DefaultDbRefResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="471" opendate="2012-06-27 06:32:03" fixdate="2014-03-31 06:26:52" resolution="Fixed">
		<buginformation>
			<summary>Update operation $addToSet does not support adding a list with $each</summary>
			<description>In MongoDB the $addToSet update operation can be provided either with a single value or a list of values. In order to add multiple values to the set the list is specified with the $each operator. Example:






{ $addToSet : { field : value } }




{ $addToSet : { a : { $each : [ 3 , 5 , 6 ] } } }






The method org.springframework.data.mongodb.core.query.Update.addToSet() only supports adding scalar values but should support adding a list of values. Otherwise there is no way of doing the needed operation within a single update with Spring Data Mongo. Calling the addToSet() method multiple times on a single attribute overwrites the value to be added. Providing a list insert a nested list into the set.</description>
			<version>1.1 M1</version>
			<fixedVersion>1.5 M1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.Update.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapperUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">812</link>
		</links>
	</bug>
	<bug id="888" opendate="2014-03-21 00:13:23" fixdate="2014-04-10 06:47:55" resolution="Fixed">
		<buginformation>
			<summary>Mapping is not applied to SortObject during queries.</summary>
			<description>during find() method with query that has Sort clause. The mapping hasn&amp;amp;apos;t been applied to Sort Object.
For e.g., I defined a filed as Id as followed.
@Id
private String orderId.  
Then I have query condition like this. query.with(new Sort("orderId"));
Then the actual query should be sorted on "_id" (after mapping). But the sort is sent as is with "orderId".
I have found this for find() method. May be the case in all places where the Sort Object is used.</description>
			<version>1.4.1 (Codd SR1)</version>
			<fixedVersion>1.4.2 (Codd SR2), 1.5 RC1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.core.QueryCursorPreparerUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">647</link>
		</links>
	</bug>
	<bug id="901" opendate="2014-04-02 04:55:04" fixdate="2014-04-11 02:07:37" resolution="Fixed">
		<buginformation>
			<summary>MongoRepositoryConfigurationExtension fails to invoke super method</summary>
			<description>The change for DATAMONGO-843 has wiped away the invocation of the registerBeansForRoot() method of the parent class which causes the repository type predicting BeanPostProcessor not being registered.
This might cause repository beans not be available for injection depending on the initialization order.</description>
			<version>1.5 M1 (Dijkstra)</version>
			<fixedVersion>1.5 RC1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.config.MongoRepositoriesRegistrarIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.config.MongoRepositoryConfigurationExtension.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">843</link>
		</links>
	</bug>
	<bug id="908" opendate="2014-04-09 10:53:02" fixdate="2014-04-14 23:00:00" resolution="Fixed">
		<buginformation>
			<summary>Nested field references in group operations broken</summary>
			<description>I have the following mongodb document:






{




   "cmsParameterId":1,




   "examples":null,




   "rules":[




      {




         "ruleType":"CODED",




         "values":[




            "abc",




            "efg"




         ]




      },




      {




         "ruleType":"SEQUENCE",




         "sequence":[




            {




               "value":"a",




               "type":"CONSTANT"




            },




            {




               "value":"2",




               "type":"PARAMETER"




            }




         ]




      }




   ]




}






I use the following query in mongo shell which works fine.






db.domainknowledge.aggregate([




{ $match: {cmsParameterId: { $in: [1] } } },




{ $project: { cmsParameterId : 1 , rules : 1 }},




{ $unwind: "$rules" },




{ $group: { _id: { cmsParameterId: "$cmsParameterId", ruleType: "$rules.ruleType"}, total: { $sum: 1 } } }




]);






using spring-data I have written the following code to produce the same result but it ends up in an Exception:






Aggregation agg = newAggregation(match(Criteria.where("cmsParameterId").in(1)),




                project("cmsParameterId", "rules"), unwind("rules"),




                group("cmsParameterId", "rules.ruleType").count().as("totol"));









        AggregationResults&amp;lt;Summary&amp;gt; aggregate = mongoTemplate.aggregate(agg,




                "domainknowledge", Summary.class);






Here is the stacktrace of exception:






java.lang.IllegalArgumentException: Invalid reference &amp;amp;apos;rules.ruleType&amp;amp;apos;!




	at org.springframework.data.mongodb.core.aggregation.ExposedFieldsAggregationOperationContext.getReference(ExposedFieldsAggregationOperationContext.java:78)




	at org.springframework.data.mongodb.core.aggregation.ExposedFieldsAggregationOperationContext.getReference(ExposedFieldsAggregationOperationContext.java:62)




	at org.springframework.data.mongodb.core.aggregation.GroupOperation.toDBObject(GroupOperation.java:300)




	at org.springframework.data.mongodb.core.aggregation.Aggregation.toDbObject(Aggregation.java:247)




	at org.springframework.data.mongodb.core.MongoTemplate.aggregate(MongoTemplate.java:1405)




	at org.springframework.data.mongodb.core.MongoTemplate.aggregate(MongoTemplate.java:1346)




	at com.etilize.automation.dke.core.domainknowledge.report.DomainKnowledgeReportServiceImpl.generateCategoryWiseReport(DomainKnowledgeReportServiceImpl.java:57)





</description>
			<version>1.4.1 (Codd SR1)</version>
			<fixedVersion>1.4.2 (Codd SR2), 1.5 RC1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.aggregation.ExposedFieldsAggregationOperationContext.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.AggregationUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="897" opendate="2014-04-01 04:38:51" fixdate="2014-04-14 23:48:22" resolution="Fixed">
		<buginformation>
			<summary>FindAndUpdate broken when using @DbRef and interface as target</summary>
			<description>NullPointerException is thrown when using MongoTemplate.findAndModify(...) with @DbRef and interface as @DbRef target. See attached project for more details. Probably regression issue since same test is passing with Spring Data Commons 1.6.3.RELEASE and Spring Data MongoDB 1.3.3.RELEASE.
</description>
			<version>1.4.1 (Codd SR1)</version>
			<fixedVersion>1.4.2 (Codd SR2), 1.5 RC1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="892" opendate="2014-03-28 09:08:03" fixdate="2014-04-15 00:13:36" resolution="Fixed">
		<buginformation>
			<summary>&lt;mongo:mapping-converter&gt; can&amp;apos;t be configured as nested bean definition</summary>
			<description>The sample config which worked in the 1.1.1 version, but doesn&amp;amp;apos;t work now:






&amp;lt;beans:bean id="messageStore" class="org.springframework.integration.mongodb.store.ConfigurableMongoDbMessageStore"&amp;gt;




		&amp;lt;beans:constructor-arg ref="mongoDbFactory"/&amp;gt;




		&amp;lt;beans:constructor-arg&amp;gt;




			&amp;lt;mongo:mapping-converter&amp;gt;




				&amp;lt;mongo:custom-converters&amp;gt;




					&amp;lt;mongo:converter&amp;gt;




						&amp;lt;beans:bean class="org.springframework.integration.mongodb.store.ConfigurableMongoDbMessageGroupStoreTests$MessageReadConverter"/&amp;gt;




					&amp;lt;/mongo:converter&amp;gt;




				&amp;lt;/mongo:custom-converters&amp;gt;




			&amp;lt;/mongo:mapping-converter&amp;gt;




		&amp;lt;/beans:constructor-arg&amp;gt;




		&amp;lt;beans:constructor-arg value="testConfigurableMongoDbMessageStore"/&amp;gt;




	&amp;lt;/beans:bean&amp;gt;






That&amp;amp;apos;s because MappingMongoConverterParser doesn&amp;amp;apos;t check if the parserContext.isNested(), registers BeanDefinition and returns null</description>
			<version>1.4.1 (Codd SR1)</version>
			<fixedVersion>1.4.2 (Codd SR2), 1.5 RC1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.config.MappingMongoConverterParserIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.config.MappingMongoConverterParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="893" opendate="2014-03-28 13:38:15" fixdate="2014-04-15 08:38:38" resolution="Fixed">
		<buginformation>
			<summary>Mapping Convertor does not remove "_class" property on collection of embedded objects</summary>
			<description>Let&amp;amp;apos;s have this example:

one document has embedded field
repository with method which has collection of embedded fields as argument







Foo.java






@Document




public class Foo {




   @Id




   private ObjectId id;




   private EmbeddedClass embedded;




   //getters and setters




}












EmbeddedClass.java






public class EmbeddedClass {




   public String id;




   //getters and setters




   //hashcode and equals




}












IFooRepository.java






@Repository




public interface IFooRepository extends MongoRepository&amp;lt;Foo, ObjectId&amp;gt; {




   public List&amp;lt;Foo&amp;gt; findByEmbeddedIn(List&amp;lt;EmbeddedClass&amp;gt; list);




}






And this repository method is not working (worked in 1.2.1)
in spring-data-mongodb 1.2.1 it generates underlying query:
find: db.foo { "embedded" : { "$in" : [ { "_id" : "0"} , { "_id" : "2"}]} , "_class : "Foo" }
and in affected version 1.4.1 it generates:
find: db.foo { "embedded" : { "$in" : [ { "_class" : "Foo" , "_id" : "0"} , { "_class" : "Foo" , "_id" : "2"}]}}
In my opinion in MappingMongoConverter.convertToMongoType() it should call removeTypeInfoRecursively but it dont.</description>
			<version>1.4.1 (Codd SR1)</version>
			<fixedVersion>1.4.2 (Codd SR2), 1.5 RC1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.PersonRepository.java</file>
			<file type="M">org.springframework.data.mongodb.repository.AbstractPersonRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="912" opendate="2014-04-15 15:40:23" fixdate="2014-04-23 00:07:59" resolution="Fixed">
		<buginformation>
			<summary>Aggregation#project followed by Aggregation#match with custom converter causes IllegalArgumentException</summary>
			<description>I have an aggregation pipeline with two stages (match, project) and a custom converter for the entity being matched by.
When MongoTemplate#aggregate is called with Aggregation.newAggregation(match, project) everything works as expected, but when it is called with Aggregation.newAggregation(project, match) appears the following exception:






Exception in thread "main" java.lang.IllegalArgumentException: can&amp;amp;apos;t serialize class MatchAfterProjectIssue$Age




	at org.bson.BasicBSONEncoder._putObjectField(BasicBSONEncoder.java:272)




	at org.bson.BasicBSONEncoder.putObject(BasicBSONEncoder.java:173)




	at org.bson.BasicBSONEncoder._putObjectField(BasicBSONEncoder.java:228)




	at org.bson.BasicBSONEncoder.putObject(BasicBSONEncoder.java:173)




	at org.bson.BasicBSONEncoder._putObjectField(BasicBSONEncoder.java:228)




	at org.bson.BasicBSONEncoder.putIterable(BasicBSONEncoder.java:297)




	at org.bson.BasicBSONEncoder._putObjectField(BasicBSONEncoder.java:236)




	at org.bson.BasicBSONEncoder.putObject(BasicBSONEncoder.java:173)




	at org.bson.BasicBSONEncoder.putObject(BasicBSONEncoder.java:119)




	at com.mongodb.DefaultDBEncoder.writeObject(DefaultDBEncoder.java:27)




	at com.mongodb.OutMessage.putObject(OutMessage.java:289)




	at com.mongodb.OutMessage.writeQuery(OutMessage.java:211)




	at com.mongodb.OutMessage.query(OutMessage.java:84)




	at com.mongodb.DBApiLayer$MyCollection.__find(DBApiLayer.java:285)




	at com.mongodb.DB.command(DB.java:262)




	at com.mongodb.DB.command(DB.java:244)




	at com.mongodb.DB.command(DB.java:301)




	at com.mongodb.DB.command(DB.java:199)




	at org.springframework.data.mongodb.core.MongoTemplate$1.doInDB(MongoTemplate.java:323)




	at org.springframework.data.mongodb.core.MongoTemplate$1.doInDB(MongoTemplate.java:321)




	at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:391)




	at org.springframework.data.mongodb.core.MongoTemplate.executeCommand(MongoTemplate.java:321)




	at org.springframework.data.mongodb.core.MongoTemplate.aggregate(MongoTemplate.java:1328)




	at org.springframework.data.mongodb.core.MongoTemplate.aggregate(MongoTemplate.java:1305)






Looks like this happens because the project stage, being first, sets the AggregationOperationContext to the newly created ExposedFieldsAggregationOperationContext which does not use custom converters. When match stage goes first it uses the proper AggregationOperationContext - TypeBasedAggregationOperationContext.
The relevant code is Aggregation#toDbObject method.
Attached gist and file contains code to reproduce the problem.
Thank you!</description>
			<version>1.4.1 (Codd SR1)</version>
			<fixedVersion>1.5 RC1 (Dijkstra), 1.4.3 (Codd SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.aggregation.ExposedFieldsAggregationOperationContext.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.Aggregation.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.TypeBasedAggregationOperationContextUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="914" opendate="2014-04-17 04:25:59" fixdate="2014-04-23 00:39:27" resolution="Fixed">
		<buginformation>
			<summary>Improve resolving of LazyLoading proxies for classes that override equals/hashcode</summary>
			<description></description>
			<version>1.4.2 (Codd SR2)</version>
			<fixedVersion>1.5 RC1 (Dijkstra), 1.4.3 (Codd SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.DefaultDbRefResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="913" opendate="2014-04-16 08:39:38" fixdate="2014-04-28 04:11:37" resolution="Fixed">
		<buginformation>
			<summary>Can&amp;apos;t query using lazy DBRef objects </summary>
			<description>public class A {
    @Id
    private String id;
    @DBRef(lazy = true)
    B b;
}
public class B {
    @Id
    private String id;
    private String name;
}
A c = this.mongoTemplate.findById("someId", A.class);
        final Criteria criteria = Criteria.where("b").is(c.getB());
        final A findOne = this.mongoTemplate.findOne(Query.query(criteria), A.class);
org.springframework.data.mapping.model.MappingException: Cannot create a reference to an object with a NULL id.
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.createDBRef(MappingMongoConverter.java:800)
	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.toDBRef(MappingMongoConverter.java:311)</description>
			<version>1.4.2 (Codd SR2)</version>
			<fixedVersion>1.5 RC1 (Dijkstra), 1.4.3 (Codd SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="917" opendate="2014-04-23 01:23:51" fixdate="2014-04-28 04:22:08" resolution="Fixed">
		<buginformation>
			<summary>DefaultDbRefResolver throws NPE when bundled into an uberjar</summary>
			<description>





public class DefaultDbRefResolver implements DbRefResolver {









	private static final boolean IS_SPRING_4_OR_BETTER = SpringVersion.getVersion().startsWith("4");






According to the Spring API documentation, it&amp;amp;apos;s perfectly valid for getVersion to return null, but this code doesn&amp;amp;apos;t check for that scenario.
The SpringVersion.getVersion() will return null when the dependency is packaged using e.g. maven-shade-plugin.
</description>
			<version>1.4.2 (Codd SR2)</version>
			<fixedVersion>1.5 RC1 (Dijkstra), 1.4.3 (Codd SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.DefaultDbRefResolver.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">11726</link>
		</links>
	</bug>
	<bug id="909" opendate="2014-04-09 14:15:16" fixdate="2014-04-28 11:03:27" resolution="Fixed">
		<buginformation>
			<summary>@CompoundIndex on inherited entity classes</summary>
			<description>Whenever an entity class is annotated with @CompoundIndexes, it does create the relevant index in the collection. Yet any other entity class that inherits from the first entity class does not inherit this index and thus the @CompoundIndexes annotation has to be repeated in the child classes even though it references the parent class. Its counter-intuitive and one would expect the annotation to apply to child classes also.</description>
			<version>1.4 GA (Codd)</version>
			<fixedVersion>1.5 RC1 (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolverUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">899</link>
		</links>
	</bug>
	<bug id="924" opendate="2014-05-01 23:11:04" fixdate="2014-05-02 05:48:12" resolution="Fixed">
		<buginformation>
			<summary>Aggregation not working with as() method in project() pipeline operator</summary>
			<description>
Mongo Shell working command.






db.person.aggregate( { $unwind: "$descriptors.carDescriptor.entries" }, {$project: {make: "$descriptors.carDescriptor.entries.make", model: "$descriptors.carDescriptor.entries.model", firstName:"$firstName", lastName: "$lastName"}}, {$group: {_id: "$make"}} )






Equivalent Spring Data representation






Aggregation agg = Aggregation.newAggregation(




            unwind("descriptors.carDescriptor.entries"),




            project()




                .and("descriptors.carDescriptor.entries.make").as("make")




                .and("descriptors.carDescriptor.entries.model").as("model")




                .and("firstName").as("firstName")




                .and("lastName").as("lastName"),




            group("make")









        );






While the Mongo Shell query work fine, Spring MongoTemplate form does not and returns the following error






java.lang.IllegalArgumentException: Invalid reference &amp;amp;apos;make&amp;amp;apos;!




	at org.springframework.data.mongodb.core.aggregation.ExposedFieldsAggregationOperationContext.getReference(ExposedFieldsAggregationOperationContext.java:92)




	at org.springframework.data.mongodb.core.aggregation.ExposedFieldsAggregationOperationContext.getReference(ExposedFieldsAggregationOperationContext.java:62)




	at org.springframework.data.mongodb.core.aggregation.GroupOperation.toDBObject(GroupOperation.java:292)




	at org.springframework.data.mongodb.core.aggregation.Aggregation.toDbObject(Aggregation.java:247)




	at org.springframework.data.mongodb.core.MongoTemplate.aggregate(MongoTemplate.java:1323)




	at org.springframework.data.mongodb.core.MongoTemplate.aggregate(MongoTemplate.java:1306)




	at com.example.samples.MongoTemplateTest.testAggregation(MongoTemplateTest.java:82)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)




	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:74)




	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:83)




	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:72)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:231)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:88)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)




	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)




	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:71)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:309)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:174)




	at org.junit.runner.JUnitCore.run(JUnitCore.java:160)




	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:74)




	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:211)




	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:67)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)






Pojo classes











// getter, setter omitted









@Document




public class Person {









    @Id




    private String id;




    private String firstName;




    private String lastName;




    private Descriptors descriptors;




}









public class Descriptors {




    private CarDescriptor carDescriptor;




}









public class CarDescriptor {




    private List&amp;lt;Entry&amp;gt; entries;









     class Entry {




        private String make;




        private String model;




        private int year;




      }




}











To confirm if "make" is being returned remove the  group("make") operator from the fluent api and the output shows that the make is indeed being returned.
Any pointers / work arounds ?
Thank you,
Adil Fulara
</description>
			<version>1.4.2 (Codd SR2)</version>
			<fixedVersion>1.5 RC1 (Dijkstra), 1.4.3 (Codd SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.aggregation.ExposedFieldsAggregationOperationContext.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.AggregationTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.ExposedFields.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.AggregationUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">834</link>
		</links>
	</bug>
	<bug id="647" opendate="2013-04-09 17:29:02" fixdate="2014-05-19 05:42:41" resolution="Fixed">
		<buginformation>
			<summary>Using "OrderBy" in "query by method name" ignores the @Field annotation for field alias.</summary>
			<description>I created a method using the "query by method name" approach:
Inside my Answer object, I have a field called "Score" that is annotated with
@Field("sr")
int Score
List&amp;lt;Answer&amp;gt; findByQuestionIdOrderByScoreDesc(String questionId)
When the query is run, the database attempts to sort the results by "score" rather than my "sr" field name.</description>
			<version>1.1.1</version>
			<fixedVersion>1.4.3 (Codd SR3), 1.5 GA (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">888</link>
		</links>
	</bug>
	<bug id="928" opendate="2014-05-02 17:49:36" fixdate="2014-05-19 08:09:03" resolution="Fixed">
		<buginformation>
			<summary>Error when using field-naming-strategy-ref</summary>
			<description> org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: Only one of the attributes abbreviate-field-names and field-naming-strategy-ref can be configured!
Occurs whenever field-naming-strategy-ref is used, possibly caused by abbreviate-field-names defaulting to false in the XSD:
&amp;lt;xsd:attribute name="abbreviate-field-names" use="optional" default="false"&amp;gt;</description>
			<version>1.5 RC1 (Dijkstra)</version>
			<fixedVersion>1.5 GA (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.config.MappingMongoConverterParserIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.config.MappingMongoConverterParser.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">925</link>
		</links>
	</bug>
	<bug id="367" opendate="2011-12-30 23:25:39" fixdate="2014-05-19 08:23:45" resolution="Fixed">
		<buginformation>
			<summary>@Indexed field in embedded Object creates new collection</summary>
			<description>Whenever an embedded Object contains an @Indexed field, Spring-Data MongoDB creates an empty collection and index on that collection for the embedded Object and field. However, the actual data is populated correctly within the parent document.
Example objects:






ParentDoc.java






@Document




class ParentDoc {









    private List&amp;lt;ChildDoc&amp;gt; children = new ArrayList&amp;lt;&amp;gt;();









    ...









}












ChildDoc.java






class ChildDoc {









    @Indexed private String childField;









}





</description>
			<version>1.0 GA</version>
			<fixedVersion>1.5 GA (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreatorUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">899</link>
		</links>
	</bug>
	<bug id="926" opendate="2014-05-02 10:08:10" fixdate="2014-05-19 10:15:21" resolution="Fixed">
		<buginformation>
			<summary>Stack Overflow Error with 1.5.0.RC1 Release</summary>
			<description>Changing the version from 1.4.2.RELEASE to 1.5.0.RC1,
webapp fails to start with the following error being the root cause.






Caused by: java.lang.StackOverflowError




	at org.springframework.util.ConcurrentReferenceHashMap$Segment.getReference(ConcurrentReferenceHashMap.java:448)




	at org.springframework.util.ConcurrentReferenceHashMap.getReference(ConcurrentReferenceHashMap.java:247)




	at org.springframework.util.ConcurrentReferenceHashMap.get(ConcurrentReferenceHashMap.java:226)




	at org.springframework.core.GenericTypeResolver.getTypeVariableMap(GenericTypeResolver.java:387)




	at org.springframework.data.util.ClassTypeInformation.&amp;lt;init&amp;gt;(ClassTypeInformation.java:101)




	at org.springframework.data.util.TypeDiscoverer.createInfo(TypeDiscoverer.java:94)




	at org.springframework.data.util.TypeDiscoverer.getComponentType(TypeDiscoverer.java:349)




	at org.springframework.data.util.ClassTypeInformation.getComponentType(ClassTypeInformation.java:40)




	at org.springframework.data.util.TypeDiscoverer.getActualType(TypeDiscoverer.java:292)




	at org.springframework.data.util.ClassTypeInformation.getActualType(ClassTypeInformation.java:40)




	at org.springframework.data.mapping.model.AbstractPersistentProperty.getActualType(AbstractPersistentProperty.java:285)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:46)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:132)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:124)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)





</description>
			<version>1.5 RC1 (Dijkstra)</version>
			<fixedVersion>1.5 GA (Dijkstra)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolverUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="745" opendate="2013-09-03 02:15:08" fixdate="2014-06-17 22:51:44" resolution="Fixed">
		<buginformation>
			<summary>@Query($in) and Pageable in result Page total = 0</summary>
			<description>Hi If I used MongoRepository and anotation Quary and Pageable in response I get true result but getTotalElements == 0
@Query("{&amp;amp;apos;snapshotId&amp;amp;apos; : ?0 ,&amp;amp;apos;defects.id&amp;amp;apos;:{ $in:?1}}")
Page&amp;lt;Test&amp;gt; findBySnapshotIdAndDefects(ObjectId snapshotId, List&amp;lt;Integer&amp;gt; defectIds, Pageable pageable);
Base Struct
{5225a5ece4b0a01629fce9c6={ "_id" : 
{ "$oid" : "5225a5ece4b0a01629fce9c6"}
 , "snapshotId" : 
{ "$oid" : "5225a5ece4b0a01629fce9c5"}
 , "defects" : [ 
{ "_id" : 1 }
]}</description>
			<version>1.2.3</version>
			<fixedVersion>1.4.3 (Codd SR3), 1.5.1 (Dijkstra SR1), 1.6 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.Person.java</file>
			<file type="M">org.springframework.data.mongodb.repository.AbstractPersonRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.PersonRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="938" opendate="2014-05-21 06:09:48" fixdate="2014-06-17 22:56:12" resolution="Fixed">
		<buginformation>
			<summary>Exception when creating geo within Criteria using MapReduce</summary>
			<description>I am getting an IllegalArgumentException when I try to query a MongoDB collection using a Criteria.within and a Box.






Criteria.where("location").within(new Box(lowerLeft, upperRight));






The exception reads:
java.lang.IllegalArgumentException: can&amp;amp;apos;t serialize class org.springframework.data.mongodb.core.query.GeoCommand</description>
			<version>1.5 GA (Dijkstra)</version>
			<fixedVersion>1.4.3 (Codd SR3), 1.5.1 (Dijkstra SR1), 1.6 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.mapreduce.MapReduceTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="948" opendate="2014-06-08 02:37:12" fixdate="2014-06-17 23:30:06" resolution="Fixed">
		<buginformation>
			<summary>Assertion error in MongoTemplate.getMappedSortObject </summary>
			<description>MongoTemplate.executeQuery(Query query, String collectionName, DocumentCallbackHandler dch) creates a QueryCursorPreparer with type=null. 
Specifying a sort condition for a query in that case will cause an error in MongoTemplate.getMappedSortObject which REQUIRES QueryCursorPreparer.type != null
The problem appeared around 1.4.2 I believe and it is still present in 1.5.0</description>
			<version>1.4.2 (Codd SR2)</version>
			<fixedVersion>1.4.3 (Codd SR3), 1.5.1 (Dijkstra SR1), 1.6 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="952" opendate="2014-06-10 22:45:47" fixdate="2014-06-18 03:56:07" resolution="Fixed">
		<buginformation>
			<summary>@Query annotation does not work with only field restrictions</summary>
			<description>If you are using repository based queries and try to use @Query annotation to limit the fetched fields, it has zero effect.
For example repository query:






@Query(fields = "{ &amp;amp;apos;email&amp;amp;apos; : 1 }")




User findByEmail(String email)






The query above returns all fields of the User and the fields definition has no effect at all. If you are using @Query with value attribute to define the query, then the fields limitation is applied though.</description>
			<version>1.4.2 (Codd SR2)</version>
			<fixedVersion>1.4.3 (Codd SR3), 1.5.1 (Dijkstra SR1), 1.6 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.PartTreeMongoQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="963" opendate="2014-06-24 23:41:57" fixdate="2014-06-25 06:54:57" resolution="Fixed">
		<buginformation>
			<summary>Compound index with expireAfterSeconds causes repeating error on mongodb server.</summary>
			<description>Using @CompoundIndex(expireAfterSeconds=10) causes constantly repeating error on mongo server.






ERROR: key for ttl index can only have 1 field







TTL indexes have the following limitations:

Compound indexes are not supported.
...

_http://docs.mongodb.org/manual/core/index-ttl/_
we should either check for the number of keys used for the compound index (1 key is just fine) and raise an error if more than 1 key involved or remove the expireAfterSeconds attribute. 
Maybe we could deprecate the attribute for the 1.5 train.</description>
			<version>1.5 GA (Dijkstra)</version>
			<fixedVersion>1.5.1 (Dijkstra SR1), 1.6 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolverUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.CompoundIndex.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="949" opendate="2014-06-09 09:00:50" fixdate="2014-06-25 06:55:53" resolution="Fixed">
		<buginformation>
			<summary>CyclicPropertyReferenceException in versions 1.5.0 + for MongoDB</summary>
			<description>Hi,
I just upgraded from 1.4.2.RELEASE to 1.5.0.RELEASE (I&amp;amp;apos;ve tried all the other snapshots too) and get the following exception.






Caused by: org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$CyclicPropertyReferenceException: Found cycle for field &amp;amp;apos;dc&amp;amp;apos; in type &amp;amp;apos;DispositionCode&amp;amp;apos; for path &amp;amp;apos;dcl&amp;amp;apos;




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$CycleGuard.protect(MongoPersistentEntityIndexResolver.java:370)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:144)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:138)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:138)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$000(MongoPersistentEntityIndexResolver.java:55)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$1.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:107)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$1.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:101)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForEntity(MongoPersistentEntityIndexResolver.java:101)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:78)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:55)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.checkForAndCreateIndexes(MongoPersistentEntityIndexCreator.java:128)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.checkForIndexes(MongoPersistentEntityIndexCreator.java:121)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.onApplicationEvent(MongoPersistentEntityIndexCreator.java:105)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.onApplicationEvent(MongoPersistentEntityIndexCreator.java:46)




	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:98)




	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:333)




	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:307)




	at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:181)




	at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:141)




	at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:67)




	at org.springframework.data.mongodb.repository.support.MongoRepositoryFactory.getEntityInformation(MongoRepositoryFactory.java:141)




	at org.springframework.data.mongodb.repository.support.MongoRepositoryFactory.getTargetRepository(MongoRepositoryFactory.java:83)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:158)




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.initAndReturn(RepositoryFactoryBeanSupport.java:224)




	at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.afterPropertiesSet(RepositoryFactoryBeanSupport.java:210)




	at org.springframework.data.mongodb.repository.support.MongoRepositoryFactoryBean.afterPropertiesSet(MongoRepositoryFactoryBean.java:108)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1612)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1549)




	... 51 more











My Bean Graph is as follows:






@Document(collection="locationMaster")




@Data public class LocationMaster implements Serializable {




	@Id




	private String locationCode;




	@Field("nm")




	private String locationName;




	@Indexed




	@Field("grp")




	private String mrnGroupId;




	@Field("tz")




	private String timezone;




	@Field("dcl")




	private List&amp;lt;DispositionCode&amp;gt; dispositionCodeList = null;




	@Field("aml")




	private List&amp;lt;DispositionCode&amp;gt; arrivalModeCodeList = null;




       // .... EXCLUDED OTHER PROPERTIES ...




}









@Data public class DispositionCode implements Serializable {




	@Field("dc")




	private String dispositionCode;




	@Field("desc")




	private String description;




	@Field("tnc")




	private Boolean triggerNoCode = false;




}











I&amp;amp;apos;m not sure what the problem is since it worked fine in 1.4.2 and now is having an issue.
Thanks,
Tom</description>
			<version>1.5 GA (Dijkstra)</version>
			<fixedVersion>1.5.1 (Dijkstra SR1), 1.6 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolverUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="970" opendate="2014-06-27 02:37:03" fixdate="2014-06-27 08:01:04" resolution="Fixed">
		<buginformation>
			<summary>Id query cannot be created if object to remove is DBObject</summary>
			<description>If we in insert DBObject in database used method:






protected void populateIdIfNecessary(Object savedObject, Object id) {




  if (id == null) {




    return;




  }




  if (savedObject instanceof BasicDBObject) {




    DBObject dbObject = (DBObject) savedObject;




    dbObject.put(ID_FIELD, id);




    return;




  }




  MongoPersistentProperty idProp = getIdPropertyFor(savedObject.getClass());




  if (idProp == null) {




    return;




  }




  ConversionService conversionService = mongoConverter.getConversionService();




  BeanWrapper&amp;lt;PersistentEntity&amp;lt;Object, ?&amp;gt;, Object&amp;gt; wrapper = BeanWrapper.create(savedObject, conversionService);




  Object idValue = wrapper.getProperty(idProp, idProp.getType(), true);




  if (idValue != null) {




    return;




  }




  wrapper.setProperty(idProp, id);




}






where checked: &amp;amp;apos;savedObject instanceof BasicDBObject&amp;amp;apos; and not store property with &amp;amp;apos;_id&amp;amp;apos;. Then if we remove DBObject from database for create query used:






private Query getIdQueryFor(Object object) {




  Assert.notNull(object);




  Class&amp;lt;?&amp;gt; objectType = object.getClass();




  MongoPersistentEntity&amp;lt;?&amp;gt; entity = mappingContext.getPersistentEntity(objectType);




  MongoPersistentProperty idProp = entity == null ? null : entity.getIdProperty();




  if (idProp == null) {




    throw new MappingException("No id property found for object of type " + objectType);




  }




  ConversionService service = mongoConverter.getConversionService();




  Object idProperty = null;




  idProperty = BeanWrapper.create(object, service).getProperty(idProp, Object.class, true);




  return new Query(where(idProp.getFieldName()).is(idProperty));




}






Where not checked:  &amp;amp;apos;savedObject instanceof BasicDBObject&amp;amp;apos; and throw exception. Why not checked removing object on &amp;amp;apos;savedObject instanceof BasicDBObject&amp;amp;apos; if we insert BAsicDBObject and after remove then.</description>
			<version>1.4 RC1 (Codd)</version>
			<fixedVersion>1.5.1 (Dijkstra SR1), 1.6 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="962" opendate="2014-06-24 08:35:41" fixdate="2014-06-27 10:39:06" resolution="Fixed">
		<buginformation>
			<summary>Cycle found with Spring Data Mongo 1.5</summary>
			<description>Similar to https://jira.spring.io/browse/DATAMONGO-949
Error raised during application loading:

Caused by: org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$CyclicPropertyReferenceException: Found cycle for field &amp;amp;apos;rules&amp;amp;apos; in type &amp;amp;apos;Filter&amp;amp;apos; for path &amp;amp;apos;filter.rules&amp;amp;apos;
at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$CycleGuard.protect(MongoPersistentEntityIndexResolver.java:370) ~[spring-data-mongodb-1.5.0.RELEASE.jar:na]
at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:144) ~[spring-data-mongodb-1.5.0.RELEASE.jar:na]
at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$2.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:138) ~[spring-data-mongodb-1.5.0.RELEASE.jar:na]
at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294) ~[spring-data-commons-1.8.0.RELEASE.jar:na]
Objects involved:






@Document(collection="rules")




public class Rule {









    @Id private String id;









    private String name;









    // other fields









    private Filter filter;









}









public class Filter {









    // for groups




    private String condition;









    private List&amp;lt;Filter&amp;gt; rules = new ArrayList&amp;lt;Filter&amp;gt;();














    // for query




    private String field;









    private String value;









}






The Filter.rules list might have a cyclic reference, and in that case a error must be thrown. But the same structure should work perfectly when there are no cycles. At least Spring could log a warning in that case, but the application must run.
Spring Data MongoDB 1.4.2 accepts this pattern without error nor warnings
In my case these objects are only created from an JSON input, so no cycle possible.</description>
			<version>1.5 GA (Dijkstra)</version>
			<fixedVersion>1.5.1 (Dijkstra SR1), 1.6 M1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolverUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="978" opendate="2014-07-02 11:42:00" fixdate="2014-07-03 05:21:58" resolution="Fixed">
		<buginformation>
			<summary>deleteBy/removeBy repository methods don&amp;apos;t set type information in Before/AfterDeleteEvent</summary>
			<description>In AbstractMongoQuery.java the nested DeleteExecution class has the following method






private Object deleteAndConvertResult(Query query, MongoEntityMetadata&amp;lt;?&amp;gt; metadata) {









			if (method.isCollectionQuery()) {




				return operations.findAllAndRemove(query, metadata.getJavaType());




			}









			WriteResult writeResult = operations.remove(query, metadata.getCollectionName());




			return writeResult != null ? writeResult.getN() : 0L;




		}






Here the javatype is not passed to operations.remove method although there is an overloaded method of remove which accepts the type. The result ends up as having null in the type value inside the Before/AfterDeleteEvent and the result events are although fired but never end up handled in the respective Type&amp;amp;apos;s Event Handlers if any.
A simple fix would be to change it to:






WriteResult writeResult = operations.remove(query, metadata.getJavaType(), metadata.getCollectionName());





</description>
			<version>1.5 GA (Dijkstra)</version>
			<fixedVersion>1.6 M1 (Evans), 1.5.2 (Dijkstra SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.data.mongodb.repository.query.AbstracMongoQueryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="969" opendate="2014-06-26 16:28:13" fixdate="2014-07-09 12:48:45" resolution="Fixed">
		<buginformation>
			<summary>String @id field is not mapped to ObjectId when using QueryDSL .id.in(Collection&lt;String&gt;)</summary>
			<description>This is similar to DATAMONGO-467 which was resolved a while back.
But in this case instead of .eq() I am using .in().






@Document




public class User {




    @Id String id;




}









Collection&amp;lt;String&amp;gt; collection = new ArrayList&amp;lt;&amp;gt;();




collection.add("abcdef.....");




Iterable&amp;lt;User&amp;gt; user = userRepository.findAll(QUser.user.id.in(collection));






This is translating to $in clause with empty collection</description>
			<version>1.5 GA (Dijkstra)</version>
			<fixedVersion>1.6 M1 (Evans), 1.5.2 (Dijkstra SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializerUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializer.java</file>
			<file type="M">org.springframework.data.mongodb.repository.AbstractPersonRepositoryIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="987" opendate="2014-07-14 12:01:52" fixdate="2014-07-17 06:20:13" resolution="Fixed">
		<buginformation>
			<summary>Problem with lazy loading in @DBRef when getting data using MongoTemplate</summary>
			<description>The situation is simple: if we reference on an entity class another entity (both annotated with @Document) called Parent and Child. Here is the code:






@Document




class Parent {




     @Id




     private String id;




     private String name;




     @DBref(lazy=true)




     private Child child;









    // getters and setters ommited




}






and the Child class






@Document




class Child {




      @Id




       private String id;




       private String name;




      //getters and setters ommited




}






The following situation should never happen:






Parent parent = new Parent();




parent.setName("Daddy");




mongoTemplate.save(parent); //ok, it is persisted like we expected.




// Than we try to load this same entity from the database




Criteria criteria = Criteria.where("_id").is(parent.getId());




Parent persisted = mongoTemplate.findOne(new Query(criteria), Parent.class);




// The child attribute should be null, right?




assertNull(persisted.getChild()); // it fails






The null attribute is actually an enhanced class generated by CGLib. It should not be. This brings a lot of problems when you, by accident, persist the same entity. I attached a project with the JUnit test which reproduces the problem for you.</description>
			<version>1.5 GA (Dijkstra)</version>
			<fixedVersion>1.5.2 (Dijkstra SR2), 1.6 RC1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.DbRefMappingMongoConverterUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="420" opendate="2012-03-22 10:09:35" fixdate="2014-07-17 12:51:47" resolution="Fixed">
		<buginformation>
			<summary>Extra quotes being added to @Query values and fields</summary>
			<description>Quotes are being added to values passed into @Query annotations.
@Query( value = "
{ ?0 }
", fields = "
{ ?1 }
" )
someMethod( String values, String fields );
Whatever I pass into "values" or "fields" gets wrapped in quotes when inserted into the query sent to MongoDB.
String values = "value : &amp;amp;apos;things&amp;amp;apos;";
  -&amp;gt; rendered as - 
{ "value : &amp;amp;apos;things&amp;amp;apos;" }
  -&amp;gt; This is not a valid query - the double quotes around it break it.
String values = "field : 0";
  -&amp;gt; rendered as - 
{ "field : 0" }
  -&amp;gt; This is not a valid projection - the double quotes around it break it.
String values = "field\" : \"0";
  -&amp;gt; rendered as - 
{ "field" : "0" }
  -&amp;gt; This is not a valid projection - the double quotes around zero turn it into a string so it renders as "true" instead of 0/undefined.
Thanks.</description>
			<version>1.0.1</version>
			<fixedVersion>1.5.2 (Dijkstra SR2), 1.6 RC1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQueryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQuery.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">1072</link>
		</links>
	</bug>
	<bug id="996" opendate="2014-07-18 08:31:22" fixdate="2014-07-18 10:21:37" resolution="Fixed">
		<buginformation>
			<summary>Pagination broken after introduction of the support for top/first</summary>
			<description>When using MongoRepository and doing a query with pagination support, something like:






@Query(...)




Page&amp;lt;Event&amp;gt; findByWeekday(int weekday, Pageable pageable);






Only the first page is displayed (when page=0 in the Pageable object), all other pages return empty result.
The logic in org.springframework.data.mongodb.repository.query.AbstractMongoQuery$PagedExecution&amp;amp;apos;s execute() method seems having an error.
When I change the line






  boolean pageableOutOfScope = pageable.getOffset() &amp;gt; query.getLimit();






to






  boolean pageableOutOfScope = pageable.getOffset() &amp;gt; count;






everything seems to work fine.
(Note that query.getLimit() defaults to 0, in that case pageableOutOfScope is always true when the page number is greather than 0, and subsequently the method returns an empty list, which is what this issue about)</description>
			<version>1.6 M1 (Evans)</version>
			<fixedVersion>1.6 RC1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQuery.java</file>
			<file type="M">org.springframework.data.mongodb.repository.AbstractPersonRepositoryIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="995" opendate="2014-07-18 08:05:12" fixdate="2014-07-21 11:21:03" resolution="Fixed">
		<buginformation>
			<summary>Parameter binding in String-based query does not bind all parameters</summary>
			<description>In version 1.5.1, the parameter&amp;amp;apos;s pattern is defined (in org.springframework.data.mongodb.repository.query.StringBasedMongoQuery.java) as:






  Pattern PLACEHOLDER = Pattern.compile("\\?(\\d+)")






and in 1.6, it has changed to






  StringBuilder builder = new StringBuilder();




  builder.append("\\?(\\d+)"); // position parameter and parameter index




  builder.append("[^,&amp;amp;apos;\"]*"); // followed by non quotes, non field separators




  builder.append("[,\"&amp;amp;apos;}]?");




  PARAMETER_BINDING_PATTERN = Pattern.compile(builder.toString(), CASE_INSENSITIVE);






With an annotation query like this:
@Query(value = "{$where: &amp;amp;apos;return this.date.getUTCMonth() == ?3 &amp;amp;&amp;amp; this.date.getUTCDay() == ?4;&amp;amp;apos;...}")
In version 1.6, the parameter ?4 gets ignored and it causes a query syntax error (while in 1.5.x, it works as expected).
The is the error I got in the console:
org.springframework.data.mongodb.UncategorizedMongoDbException: 
{ "serverUsed" : "localhost:27017" , "errmsg" : "exception: SyntaxError: Unexpected token ?" , "code" : 16722 , "ok" : 0.0}
; nested exception is com.mongodb.CommandFailureException: 
{ "serverUsed" : "localhost:27017" , "errmsg" : "exception: SyntaxError: Unexpected token ?" , "code" : 16722 , "ok" : 0.0}</description>
			<version>1.6 M1 (Evans)</version>
			<fixedVersion>1.5.2 (Dijkstra SR2), 1.6 RC1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQueryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="1002" opendate="2014-07-23 02:48:09" fixdate="2014-07-23 03:46:33" resolution="Fixed">
		<buginformation>
			<summary>Update.toString() might throw exception</summary>
			<description>The toString() method on Update class is breaking when there are custom mappings used for e.g., Joda DateTime. I think this is falling back to driver&amp;amp;apos;s JSON serializer rather than using Spring Data MongoDB mappings. The following is stacktrace. 






java.lang.RuntimeException: json can&amp;amp;apos;t serialize type : class org.joda.time.DateTime




	at com.mongodb.util.ClassMapBasedObjectSerializer.serialize(ClassMapBasedObjectSerializer.java:77)




	at com.mongodb.util.JSONSerializers$MapSerializer.serialize(JSONSerializers.java:317)




	at com.mongodb.util.ClassMapBasedObjectSerializer.serialize(ClassMapBasedObjectSerializer.java:79)




	at com.mongodb.util.JSONSerializers$MapSerializer.serialize(JSONSerializers.java:317)




	at com.mongodb.util.ClassMapBasedObjectSerializer.serialize(ClassMapBasedObjectSerializer.java:79)




	at com.mongodb.util.JSON.serialize(JSON.java:55)




	at com.mongodb.util.JSON.serialize(JSON.java:40)




	at com.mongodb.BasicDBObject.toString(BasicDBObject.java:83)




	at org.springframework.data.mongodb.core.query.Update.toString(Update.java:375)




	at 





</description>
			<version>1.5.1 (Dijkstra SR1)</version>
			<fixedVersion>1.5.2 (Dijkstra SR2), 1.6 RC1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.query.UpdateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.Update.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">953</link>
		</links>
	</bug>
	<bug id="1001" opendate="2014-07-22 07:21:20" fixdate="2014-07-24 04:51:50" resolution="Fixed">
		<buginformation>
			<summary>Can&amp;apos;t save/update lazy load object</summary>
			<description>Test case:






@Document




public class Child {




    @Id




    private String id;




    private String name;




   //gets/sets




}









@Document




public class Parent {




    @Id




    private String id;




    @DBRef(lazy = true)




    Child child;




   //gets/sets




}









@Test




    public void test01() {









        final Child b = new Child();




        b.setName("name");




        this.mongoTemplate.save(b);









        final Parent tmpl = new Parent();




        tmpl.setChild(b);




        this.mongoTemplate.save(tmpl);









        final Criteria criteria = Criteria.where("child").is(tmpl.getChild());




        final Parent parent = this.mongoTemplate.findOne(Query.query(criteria), Parent.class);




        assertNotNull(parent.getChild().getName());









        final Child relatedChild = parent.getChild();




        final String contentId = relatedChild.getId();




        relatedChild.setName("changing name");









        this.mongoTemplate.save(relatedChild);









        final Child child = this.mongoTemplate.findById(contentId, Child.class);




        System.out.println(child.getName());




        assertEquals(relatedChild.getName(), child.getName());




    }






Lazy loaded references are not being updated.
Should parent.getChild() return the real entity instance and not the proxy instance?
</description>
			<version>1.5 GA (Dijkstra)</version>
			<fixedVersion>1.5.2 (Dijkstra SR2), 1.6 RC1 (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.LazyLoadingProxy.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.DefaultDbRefResolver.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.CustomConversionsUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1008" opendate="2014-07-28 08:11:28" fixdate="2014-07-31 09:14:09" resolution="Fixed">
		<buginformation>
			<summary>IndexOperations fail, when "2dsphere" index is present</summary>
			<description>How to reproduce:
1. Have a collection with a "2dsphere" index (in my case, i have had a "MyModel" annotated with @GeoSpatialIndexed(type=GeoSpatialIndexType.GEO_2DSPHERE)
2. Get a mongoTemplate and execute the code:






       final String collectionName = mongoTemplate.getCollectionName(MyModel.class);




        final IndexOperations indexOps = mongoTemplate.indexOps(collectionName);        




        final List&amp;lt;IndexInfo&amp;gt; indexInfo = indexOps.getIndexInfo();






This raises an exception:






Caused by: 




java.lang.NumberFormatException: For input string: "2dsphere"




	at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:2043)




	at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110)




	at java.lang.Double.parseDouble(Double.java:538)




	at java.lang.Double.&amp;lt;init&amp;gt;(Double.java:608)




	at org.springframework.data.mongodb.core.DefaultIndexOperations$4.getIndexData(DefaultIndexOperations.java:147)




	at org.springframework.data.mongodb.core.DefaultIndexOperations$4.doInCollection(DefaultIndexOperations.java:125)




	at org.springframework.data.mongodb.core.DefaultIndexOperations$4.doInCollection(DefaultIndexOperations.java:122)




	at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:410)




	at org.springframework.data.mongodb.core.DefaultIndexOperations.getIndexInfo(DefaultIndexOperations.java:122)




	at com.example.config.PersistenceConfig.ensureIndex(PersistenceConfig.java:31)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:483)




	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:349)




	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:300)




	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:133)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:407)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1545)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:539)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475)




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304)




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:703)




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:760)




	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482)




	at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:403)




	at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:306)




	at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:106)




	at org.eclipse.jetty.server.handler.ContextHandler.callContextInitialized(ContextHandler.java:771)




	at org.eclipse.jetty.servlet.ServletContextHandler.callContextInitialized(ServletContextHandler.java:424)




	at org.eclipse.jetty.server.handler.ContextHandler.startContext(ContextHandler.java:763)




	at org.eclipse.jetty.servlet.ServletContextHandler.startContext(ServletContextHandler.java:249)




	at org.eclipse.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1250)




	at org.eclipse.jetty.server.handler.ContextHandler.doStart(ContextHandler.java:706)




	at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:492)




	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)




	at org.eclipse.jetty.server.handler.HandlerWrapper.doStart(HandlerWrapper.java:95)




	at org.eclipse.jetty.server.Server.doStart(Server.java:277)




	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:64)




	at runjettyrun.Bootstrap.main(Bootstrap.java:80)






I think, this should not happen. What do you think? IMHO the error did not occur, when using MongoDb 2.6.0</description>
			<version>1.4.3 (Codd SR3)</version>
			<fixedVersion>1.6 RC1 (Evans), 1.5.4 (Dijkstra SR4)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.DefaultIndexOperationsIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.DefaultIndexOperations.java</file>
			<file type="M">org.springframework.data.mongodb.repository.config.MongoRepositoryConfigurationExtension.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">1011</link>
		</links>
	</bug>
	<bug id="1025" opendate="2014-08-14 02:42:25" fixdate="2014-08-26 06:28:53" resolution="Fixed">
		<buginformation>
			<summary>Duplicate index creation on embedded documents </summary>
			<description>Having the documents:






@CompoundIndexes({ @CompoundIndex(collection="timeRead", name = "eventIdAndChip", def = "{eventId : 1, chip : 1}"),




        @CompoundIndex(collection="timeRead", name = "eventIdAndPublish", def = "{ eventId : 1, publish : 1}"),




        @CompoundIndex(collection="timeRead", name = "chipAndTimeReadTickIndex", def = "{&amp;amp;apos;chip&amp;amp;apos; : -1, &amp;amp;apos;timeReadTick&amp;amp;apos; : 1}") })




@Document




public class TimeRead { }






and 






@Document




public class TimeReadChip {









    private Map&amp;lt;String, TimeRead&amp;gt; timeReads;




    private Map&amp;lt;String, TimeRead&amp;gt; pointNameToTimeRead;




}






The Mongo driver tries to create the same indexes twice: once because they are defined as compound on TimeRead (which is correct), and a second time when parsing the TimeReadChip document (incorrect). I&amp;amp;apos;m assuming it sees the Map&amp;lt;String, TimeRead&amp;gt; and tries to create indexes on timeRead collection (again). This bug was introduced after 1.3.5.RELEASE.</description>
			<version>1.5.2 (Dijkstra SR2)</version>
			<fixedVersion>1.5.4 (Dijkstra SR4), 1.6 GA (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolverUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.Indexed.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.GeoSpatialIndexed.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.CompoundIndex.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreatorUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1027</link>
		</links>
	</bug>
	<bug id="1027" opendate="2014-08-16 13:49:22" fixdate="2014-08-26 06:29:39" resolution="Duplicate">
		<buginformation>
			<summary>Collection inherits complex index from embedded class/object</summary>
			<description>Say I have two collections:
Books and Author
Author has a unique compound index and Book has a list of authors as property.
Now if I add different book with the same author to books, the insert is ignored because books inherits the index from authors.
On a subsequent context restart I&amp;amp;apos;m also getting a duplicate key exception:






com.mongodb.MongoException$DuplicateKey: { "serverUsed" : "" , "err" : "E11000 duplicate key error index: db.books.$name_appId_idx  dup key






</description>
			<version>1.5.2 (Dijkstra SR2)</version>
			<fixedVersion>1.5.4 (Dijkstra SR4), 1.6 GA (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolverUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.Indexed.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.GeoSpatialIndexed.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.CompoundIndex.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreatorUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1025</link>
		</links>
	</bug>
	<bug id="1030" opendate="2014-08-21 00:39:07" fixdate="2014-08-26 06:34:45" resolution="Fixed">
		<buginformation>
			<summary>Query methods retuning a single entity does not work with projecting types</summary>
			<description>Assume the following repository:






interface UserRepository extends CrudRepository&amp;lt;User, BigInteger&amp;gt; {









  UserSummary findSummaryByLastnameLike(String lastname);




}






Assuming that UserSummary does not extend User executing the query method will always return null as the collection the query is run against will be derived from UserSummary which it shouldn&amp;amp;apos;t in this case.
The issue is that SingleEntityExecution does not hand the collection name of the MongoEntityMetadata to the template so that the collection is derived from the return type only.</description>
			<version>1.5.2 (Dijkstra SR2)</version>
			<fixedVersion>1.5.4 (Dijkstra SR4), 1.6 GA (Evans)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQuery.java</file>
			<file type="M">org.springframework.data.mongodb.repository.AbstractPersonRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.PersonRepository.java</file>
		</fixedFiles>
	</bug>
	<bug id="1040" opendate="2014-08-28 06:37:12" fixdate="2014-09-04 07:04:49" resolution="Fixed">
		<buginformation>
			<summary>deleteAll repository query don&amp;apos;t use EntityMetadata collection name</summary>
			<description>Unlike other methods, deleteAll repository queries don&amp;amp;apos;t use the collection name provided by MongoEntityMetadata. This prevents me to use multiple collection names for a same Entity.
In AbstractMongoQuery$AbstractMongoQuery :






		private Object deleteAndConvertResult(Query query, MongoEntityMetadata&amp;lt;?&amp;gt; metadata) {









			if (method.isCollectionQuery()) {




				return operations.findAllAndRemove(query, metadata.getJavaType());




			}









			WriteResult writeResult = operations.remove(query, metadata.getJavaType(), metadata.getCollectionName());




			return writeResult != null ? writeResult.getN() : 0L;




		}






A simple change will fix that :






			if (method.isCollectionQuery()) {




				return operations.findAllAndRemove(query, metadata.getJavaType(), metadata.getCollectionName());




			}






Thanks</description>
			<version>1.5.4 (Dijkstra SR4)</version>
			<fixedVersion>1.6 GA (Evans), 1.5.5 (Dijkstra SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQuery.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQueryUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1049" opendate="2014-09-05 07:07:37" fixdate="2014-09-25 03:50:01" resolution="Fixed">
		<buginformation>
			<summary>Reserved field name &amp;apos;language&amp;apos; causes trouble.</summary>
			<description>With having support for full-text-search there seem to be a problem having MongoDB field names &amp;amp;apos;language&amp;amp;apos;.
In a legacy project (with legacy data) there are several entities having a member variable &amp;amp;apos;language&amp;amp;apos; with are using the field name &amp;amp;apos;language&amp;amp;apos; in MongoDB.
This causes the exception






Caused by: org.springframework.dao.InvalidDataAccessApiUsageException: Cannot set language override on language as it is already defined on language.




	at org.springframework.data.mongodb.core.index.TextIndexDefinition$TextIndexDefinitionBuilder.withLanguageOverride(TextIndexDefinition.java:321)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:234)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:226)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.appendTextIndexInformation(MongoPersistentEntityIndexResolver.java:226)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$400(MongoPersistentEntityIndexResolver.java:56)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:256)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:226)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.appendTextIndexInformation(MongoPersistentEntityIndexResolver.java:226)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$400(MongoPersistentEntityIndexResolver.java:56)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:256)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:226)




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.appendTextIndexInformation(MongoPersistentEntityIndexResolver.java:226)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.potentiallyCreateTextIndexDefinition(MongoPersistentEntityIndexResolver.java:205)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForEntity(MongoPersistentEntityIndexResolver.java:99)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:79)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:56)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.checkForAndCreateIndexes(MongoPersistentEntityIndexCreator.java:128)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.checkForIndexes(MongoPersistentEntityIndexCreator.java:121)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.onApplicationEvent(MongoPersistentEntityIndexCreator.java:105)




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.onApplicationEvent(MongoPersistentEntityIndexCreator.java:46)




	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:98)




	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:333)




	at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:307)




	at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:181)




	at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:141)




	at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:67)




	at org.springframework.data.mongodb.repository.support.MongoRepositoryFactory.getEntityInformation(MongoRepositoryFactory.java:141)






In the current Implementation MongoPersistentEntityIndexResolver checks in line 233 if the persistentProperty is a language property. Each object member variable using a field name &amp;amp;apos;language&amp;amp;apos; is recognized as languageProperty.
There should be an annotation like @NoLanguage to mark all member variables which have noting to do with the MongoDB full text search.</description>
			<version>1.6 M1 (Evans)</version>
			<fixedVersion>1.6.1 (Evans SR1), 1.7 M1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.mapping.MongoPersistentProperty.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolverUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.BasicMongoPersistentProperty.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="is depended on by">1053</link>
		</links>
	</bug>
	<bug id="1062" opendate="2014-09-30 03:08:24" fixdate="2014-10-01 00:51:05" resolution="Complete">
		<buginformation>
			<summary>Fix failing test in ServerAddressPropertyEditorUnitTests.</summary>
			<description>The test rejectsAddressConfigWithoutASingleParsableServerAddress fails because the supposedly non-existing hostname "bar" "now" resolves to a real host-address: 
```
tom@gauss ~/Documents/dev/repos/spring/spring-data-mongodb (master)$ ping bar
PING bar (127.0.53.53): 56 data bytes
Request timeout for icmp_seq 0
```</description>
			<version>1.6 GA (Evans)</version>
			<fixedVersion>1.6.1 (Evans SR1), 1.7 M1 (Fowler), 1.5.5 (Dijkstra SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.config.ServerAddressPropertyEditorUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1058" opendate="2014-09-18 11:35:00" fixdate="2014-10-01 01:07:31" resolution="Complete">
		<buginformation>
			<summary>Using @Field("foo") with @Dbref breaking behavior.</summary>
			<description>When transitioning from 1.4.3.RELEASE to 1.6.0.RELEASE, the model below no longer returns with map
Model






@Document(collection="model")




class Model {




	@Id




	ObjectId id;




        




/**




* Currently only works without @Field annotation




*/




    @Field("foo")




	@DBRef




	Map&amp;lt;String, Foo&amp;gt; mapOfFoos ; //assume Foo is a class




}






Repo






public interface ModelDao extends MongoRepository&amp;lt;Model, ObjectId&amp;gt; {




}









public interface FooDao extends MongoRepository&amp;lt;Foo, ObjectId&amp;gt; {




}






Snippet of a unit test






...




Model model = new Model();




Map&amp;lt;String, Foo&amp;gt; mapOfFoos = new HashMap&amp;lt;String, Foo&amp;gt;();




Foo foo = new Foo()




fooDao.save(foo)




mapOfFoo("somestring", foo)




model.setMapOfFoos(mapOfFoo)




modelDao.save(model);




Model  retreivedModel = modelDao.findOne(model.getId());




//retreivedModel.getMapOfFoos() returns null




//EXPECTED (and previous behavior) retreivedModel.getMapOfFoos() not null





</description>
			<version>1.6 GA (Evans)</version>
			<fixedVersion>1.6.1 (Evans SR1), 1.7 M1 (Fowler), 1.5.5 (Dijkstra SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1057" opendate="2014-09-18 10:51:02" fixdate="2014-10-07 22:10:27" resolution="Fixed">
		<buginformation>
			<summary>AbstractMongoQuery.SlicedExecution#execute() skips every nth element</summary>
			<description>AbstractMongoQuery.SlicedExecution#execute() skips every nth element. Say the page size is 20, every 21st element is skipped. This is because of the pageSize increment</description>
			<version>1.6 GA (Evans)</version>
			<fixedVersion>1.6.1 (Evans SR1), 1.7 M1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQuery.java</file>
			<file type="M">org.springframework.data.mongodb.repository.AbstractPersonRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQueryUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1053" opendate="2014-09-12 12:14:49" fixdate="2014-10-10 02:32:22" resolution="Fixed">
		<buginformation>
			<summary>In 1.6, any field in a mapped object named "language" will fail to map if it is a type other than String</summary>
			<description>In 1.6, there is now a restriction that a field named "language" must be a String.  So, in 1.5, the following will map but will not map in 1.6:






package com.instantly.pipeline.engine.model;









import javax.persistence.Id;









public class Foobar {









    @Id




    String id;




    




    private Number language;









    public String getId() {




        return id;




    }









    public void setId(String id) {




        this.id = id;




    }









    public Number getLanguage() {




        return language;




    }









    public void setLanguage(Number language) {




        this.language = language;




    }




}





</description>
			<version>1.6 M1 (Evans)</version>
			<fixedVersion>1.6.1 (Evans SR1), 1.7 M1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.mapping.BasicMongoPersistentEntity.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.BasicMongoPersistentEntityUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">1049</link>
		</links>
	</bug>
	<bug id="1063" opendate="2014-09-30 12:11:41" fixdate="2014-10-10 02:36:41" resolution="Fixed">
		<buginformation>
			<summary>IllegalStateException using any().in() </summary>
			<description>I am using 1.6.0.RELEASE with querydsl 3.4.3.
When doing a Predicate based search using 






entity.listType.any().in(someString)






I am getting IllegalStateException (see below)
It looks like the following issue/commit in querydsl is causing this issue:
https://github.com/querydsl/querydsl/issues/512
https://github.com/querydsl/querydsl/commit/7e934bed158702392086e200cd6ddb17634c5ce6






Caused by: java.lang.IllegalStateException: name property not available for path of type COLLECTION_ANY. Use getElement() to access the generic path element.




	at com.mysema.query.types.PathMetadata.getName(PathMetadata.java:73) ~[querydsl-core-3.4.3.jar:na]




	at org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializer.getPropertyFor(SpringDataMongodbSerializer.java:146) ~[spring-data-mongodb-1.6.0.RELEASE-onshape.jar:na]




	at org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializer.isReference(SpringDataMongodbSerializer.java:103) ~[spring-data-mongodb-1.6.0.RELEASE-onshape.jar:na]




	at com.mysema.query.mongodb.MongodbSerializer.isReference(MongodbSerializer.java:296) ~[querydsl-mongodb-3.4.3.jar:na]




	at com.mysema.query.mongodb.MongodbSerializer.visit(MongodbSerializer.java:113) ~[querydsl-mongodb-3.4.3.jar:na]




	at com.mysema.query.mongodb.MongodbSerializer.visit(MongodbSerializer.java:52) ~[querydsl-mongodb-3.4.3.jar:na]




	at com.mysema.query.types.OperationImpl.accept(OperationImpl.java:91) ~[querydsl-core-3.4.3.jar:na]




	at com.mysema.query.mongodb.MongodbSerializer.handle(MongodbSerializer.java:55) ~[querydsl-mongodb-3.4.3.jar:na]




	at com.mysema.query.mongodb.MongodbSerializer.visit(MongodbSerializer.java:123) ~[querydsl-mongodb-3.4.3.jar:na]




	at com.mysema.query.mongodb.MongodbSerializer.visit(MongodbSerializer.java:52) ~[querydsl-mongodb-3.4.3.jar:na]




	at com.mysema.query.types.OperationImpl.accept(OperationImpl.java:91) ~[querydsl-core-3.4.3.jar:na]




	at com.mysema.query.mongodb.MongodbSerializer.handle(MongodbSerializer.java:55) ~[querydsl-mongodb-3.4.3.jar:na]




	at com.mysema.query.mongodb.MongodbQuery.createQuery(MongodbQuery.java:376) ~[querydsl-mongodb-3.4.3.jar:na]




	at com.mysema.query.mongodb.MongodbQuery.createCursor(MongodbQuery.java:270) ~[querydsl-mongodb-3.4.3.jar:na]




	at com.mysema.query.mongodb.MongodbQuery.createCursor(MongodbQuery.java:265) ~[querydsl-mongodb-3.4.3.jar:na]




	at com.mysema.query.mongodb.MongodbQuery.iterate(MongodbQuery.java:221) ~[querydsl-mongodb-3.4.3.jar:na]




	at org.springframework.data.mongodb.repository.support.QueryDslMongoRepository.findAll(QueryDslMongoRepository.java:118) ~[spring-data-mongodb-1.6.0.RELEASE-onshape.jar:na]





</description>
			<version>1.6 GA (Evans)</version>
			<fixedVersion>1.6.1 (Evans SR1), 1.7 M1 (Fowler), 1.5.5 (Dijkstra SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializer.java</file>
			<file type="M">org.springframework.data.mongodb.repository.Person.java</file>
			<file type="M">org.springframework.data.mongodb.repository.support.QuerydslRepositorySupportUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1070" opendate="2014-10-09 19:47:01" fixdate="2014-10-17 04:26:43" resolution="Fixed">
		<buginformation>
			<summary>Query annotation with $oid leads to a parse error</summary>
			<description>When a query that uses $oid along with a parameter placeholder is written, it leads to a parse error during application load time (This used to work fine in version 1.3.2, but is broken in at least 1.5.4-1.7.x):
(Reproducible project attached)






@Query("{ &amp;amp;apos;organization&amp;amp;apos;: {&amp;amp;apos;$ref&amp;amp;apos;: &amp;amp;apos;organizations&amp;amp;apos;, &amp;amp;apos;$id&amp;amp;apos;: { &amp;amp;apos;$oid&amp;amp;apos;: ?0 } } }")




List&amp;lt;Person&amp;gt; findByOrganization(String organizationId);












Caused by: java.lang.IllegalArgumentException: invalid ObjectId [_param_0]




	at org.bson.types.ObjectId.&amp;lt;init&amp;gt;(ObjectId.java:181)




	at org.bson.types.ObjectId.&amp;lt;init&amp;gt;(ObjectId.java:167)




	at com.mongodb.util.JSONCallback.objectDone(JSONCallback.java:71)




	at com.mongodb.util.JSONParser.parseObject(JSON.java:261)




	at com.mongodb.util.JSONParser.parse(JSON.java:213)




	at com.mongodb.util.JSONParser.parseObject(JSON.java:249)




	at com.mongodb.util.JSONParser.parse(JSON.java:213)




	at com.mongodb.util.JSONParser.parseObject(JSON.java:249)




	at com.mongodb.util.JSONParser.parse(JSON.java:213)




	at com.mongodb.util.JSONParser.parse(JSON.java:163)




	at com.mongodb.util.JSON.parse(JSON.java:99)




	at com.mongodb.util.JSON.parse(JSON.java:79)




	at org.springframework.data.mongodb.repository.query.StringBasedMongoQuery$ParameterBindingParser.parseParameterBindingsFrom(StringBasedMongoQuery.java:214)




	at org.springframework.data.mongodb.repository.query.StringBasedMongoQuery.&amp;lt;init&amp;gt;(StringBasedMongoQuery.java:76)




...





</description>
			<version>1.5.4 (Dijkstra SR4)</version>
			<fixedVersion>1.6.1 (Evans SR1), 1.7 M1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQuery.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreator.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQueryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreatorUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1068" opendate="2014-10-08 19:43:32" fixdate="2014-10-21 03:27:47" resolution="Complete">
		<buginformation>
			<summary>elemMatch of Class Criteria fails to build special cirteria</summary>
			<description>There is an entity like this:  






	




	public class Room {




		private String name;




		private List&amp;lt;Date&amp;gt; occupied;




	}






I need to issue a criteria to fetch all documents in which none of elements of occupied falls into a specified date range. The query JSON is:  






	{




		occupied : {




			$not : {




				$elemMatch : {




					$gte : start,




					$lte : end




				}




			}




		}




	}






Then, I tried on  






	Criteria c1 = new Criteria().gte(start).lte(end);




	Criteria c = Criteria.where("occupied").not().elemMatch(c1);






But the serialization to JSON for c is:






	




{




	occupied : {




		$not : {




			$elemMatch : {




			}




		}




	}




}






It seems that c1 will be explained to empty Map by invoking elemMatch(Criteria) because I haven&amp;amp;apos;t assign a key to it. But really no key I can assign to it.</description>
			<version>1.5.4 (Dijkstra SR4)</version>
			<fixedVersion>1.6.1 (Evans SR1), 1.7 M1 (Fowler), 1.5.5 (Dijkstra SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.query.Criteria.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.CriteriaTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1072" opendate="2014-10-14 16:04:48" fixdate="2014-10-22 05:17:56" resolution="Fixed">
		<buginformation>
			<summary>Query placeholders in keys no longer correctly substituted</summary>
			<description>Between 1.5.1.RELEASE and 1.5.2.RELEASE, processing of query parameters for keys was broken.  Example, this query:






  @Query("{?0 : ?1}")




  List&amp;lt;T&amp;gt; findAllByKeyValue(String key, String value);






When called with these parameters:






  findAllByKeyValue("name", "Joe");






becomes this with 1.5.1: {"name" : "Joe"}
But with 1.5.2, the ?0 is not correctly substituted so this is the broken query that is created: {"?0" : "Joe"}</description>
			<version>1.5.2 (Dijkstra SR2)</version>
			<fixedVersion>1.6.1 (Evans SR1), 1.7 M1 (Fowler), 1.5.5 (Dijkstra SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQueryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.AbstractPersonRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.PersonRepository.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQuery.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">420</link>
		</links>
	</bug>
	<bug id="1076" opendate="2014-10-27 04:43:36" fixdate="2014-10-29 02:19:16" resolution="Fixed">
		<buginformation>
			<summary>Finalizer hit db on lazy dbrefs</summary>
			<description>If we load a Document class that has a lazy annotated DBRef, and we do not navigate through it, the data is not requested to MongoDB as expected, but if we force a GC it seems that the proxy that envelops the attribute with DBRef generates a request to MongoDB.
You can see this issue in logs if trace logs are enabled:
Example to a DBRef to MY_DB.PEOPLE with id=18






2014-10-27 12:24:02.644  INFO 4384 --- [      Finalizer] com.mongodb.TRACE                        : find: MY_DB.PEOPLE { "_id" : 18}






And this is the trace I get debugging:






	at com.testapp.model.People$$EnhancerByCGLIB$$c7ff2ba0.finalize(&amp;lt;generated&amp;gt;)




	at java.lang.System$2.invokeFinalize(System.java:1267)




	at java.lang.ref.Finalizer.runFinalizer(Finalizer.java:98)




	at java.lang.ref.Finalizer.access$100(Finalizer.java:34)




	at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:210)






The problem seems to be at DefaultDbRefResolver creating the LazyLoadingInterceptor inner class.</description>
			<version>1.6 GA (Evans)</version>
			<fixedVersion>1.6.1 (Evans SR1), 1.7 M1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.DbRefMappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.DefaultDbRefResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="1077" opendate="2014-10-27 06:10:06" fixdate="2014-10-30 03:08:30" resolution="Fixed">
		<buginformation>
			<summary>Update removes positional operator $ in key when used on DBRef property</summary>
			<description>Ensure the following works in UpdateMapperUnitTests.






/**




 * @see SO-26556527




 */




@Test




public void shouldNotRemovePositionalParameter() {









	Update update = new Update();




	update.unset("dbRefAnnotatedList.$");









	DBObject mappedUpdate = mapper.getMappedObject(update.getUpdateObject(),




			context.getPersistentEntity(DocumentWithDBRefCollection.class));









	DBObject $unset = DBObjectTestUtils.getAsDBObject(mappedUpdate, "$unset");









	assertThat($unset, equalTo(new BasicDBObjectBuilder().add("dbRefAnnotatedList.$", 1).get()));




}





</description>
			<version>1.5.4 (Dijkstra SR4)</version>
			<fixedVersion>1.6.1 (Evans SR1), 1.7 M1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1080" opendate="2014-10-30 03:28:16" fixdate="2014-10-30 03:40:27" resolution="Fixed">
		<buginformation>
			<summary>AbstractMongoQuery must not eagerly post-process results</summary>
			<description>Currently using Optional with repository query methods doesn&amp;amp;apos;t work correctly as the ConversionService used in AbstractMongoQuery tries to eagerly convert the result returned by the query execution into the methods return type.</description>
			<version>1.5.4 (Dijkstra SR4)</version>
			<fixedVersion>1.6.1 (Evans SR1), 1.7 M1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQuery.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQueryUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">1120</link>
		</links>
	</bug>
	<bug id="1050" opendate="2014-09-09 03:41:12" fixdate="2014-11-10 07:19:13" resolution="Fixed">
		<buginformation>
			<summary>SimpleMongoRepository.findById(id, class)  don&amp;apos;t return ids for nested documents.</summary>
			<description>SimpleMongoRepository.findById(id, class)  don&amp;amp;apos;t return ids for nested documents.
E.g. 






class A {




 private String id; //stored in mongo as "id"




 private String name;




}









class B {




  private String id; // stored in mongo as "_id"




  private List&amp;lt;A&amp;gt; innerDocs;




}






When it return B documents, innerDocs A objects have id == null. If i refactor A.id to A.myId, then it start working correctly.
Saving data (save, updateFirst, etc) always save fields correctly.
A and B objects are pojos (only lombok @Data and @NoArgsConstructor is used to provide getters and setters). Ids are created by mongo.
Could it related somehow  to ids that have 24 characters, but stored not as "_id"?
Easy workaround is to have different field name (not "id").</description>
			<version>1.5.1 (Dijkstra SR1)</version>
			<fixedVersion>1.7 M1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.mapping.BasicMongoPersistentPropertyUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.BasicMongoPersistentProperty.java</file>
		</fixedFiles>
	</bug>
	<bug id="1078" opendate="2014-10-28 02:23:26" fixdate="2014-11-10 07:42:07" resolution="Fixed">
		<buginformation>
			<summary>@Query annotated repository query fails to map complex Id structure.</summary>
			<description>StringBasedMongoQuery converts any complex object to the according mongo type including type restrictions via _class. Therefore annotated queries like:






@Query("{&amp;amp;apos;_id&amp;amp;apos;: {$in: ?0}}")




List&amp;lt;User&amp;gt; findByUserIds(Collection&amp;lt;MyUserId&amp;gt; userIds);






end up being converted to:






{_id:  {$in: [ {_class:"com.sampleuser.MyUserId", userId:"....", sampleId:"...."}, ...






So we need to check for the presence of typeKey when converting id properties.</description>
			<version>1.5.4 (Dijkstra SR4)</version>
			<fixedVersion>1.7 M1 (Fowler), 1.5.5 (Dijkstra SR5), 1.6.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.MyId.java</file>
			<file type="M">org.springframework.data.mongodb.repository.ComplexIdRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.UserWithComplexId.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1088</link>
		</links>
	</bug>
	<bug id="1088" opendate="2014-11-07 03:08:58" fixdate="2014-11-12 23:11:42" resolution="Duplicate">
		<buginformation>
			<summary>@Query $in does not remove "_class" property on collection of embedded objects </summary>
			<description>Following method on repository 






	@Query(value = "{ embedded : { $in : ?0} }")




	List&amp;lt;Foo&amp;gt; findByEmbeddedIn2(Collection&amp;lt;EmbeddedObject&amp;gt; c);






generates incorrect query. 






{ "embedded" : { "$in" : [ {  "_class" : "demo.EmbeddedObject" , "s" : "hello"}]}}






Query should be without _class property e.g.:






{ "embedded" : { "$in" : [ { "s" : "hello"}]}}






I attached test project demonstrating this bug.
This bug is related to https://jira.spring.io/browse/DATAMONGO-893</description>
			<version>1.6.1 (Evans SR1)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.MyId.java</file>
			<file type="M">org.springframework.data.mongodb.repository.ComplexIdRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.UserWithComplexId.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1078</link>
		</links>
	</bug>
	<bug id="1096" opendate="2014-11-17 07:38:45" fixdate="2014-11-26 00:45:45" resolution="Complete">
		<buginformation>
			<summary>RuntimeExceptions during debug query printing in MongoTemplate</summary>
			<description>When printing DEBUG logs for remove and update queries in org.springframework.data.mongodb.core.MongoTemplate, string value of queries should be obtained with org.springframework.data.mongodb.core.query.SerializationUtils#serializeToJsonSafely method.  This protects us from RuntimeException&amp;amp;apos;s as mentioned in DATAMONGO-495</description>
			<version>1.6.1 (Evans SR1)</version>
			<fixedVersion>1.7 M1 (Fowler), 1.5.5 (Dijkstra SR5), 1.6.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="1094" opendate="2014-11-14 03:34:58" fixdate="2014-11-26 01:05:11" resolution="Complete">
		<buginformation>
			<summary>Wrong reference to @DocumentField in error message</summary>
			<description>Looking through the code, it looks like this message is outdated:
https://github.com/spring-projects/spring-data-mongodb/blob/master/spring-data-mongodb/src/main/java/org/springframework/data/mongodb/core/mapping/BasicMongoPersistentEntity.java#L56
I guess it should just refer to the @Field annotation to disambiguate? According to git blame this has been there for quite a while</description>
			<version>1.6.1 (Evans SR1)</version>
			<fixedVersion>1.7 M1 (Fowler), 1.5.5 (Dijkstra SR5), 1.6.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.mapping.MongoMappingContextUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapping.BasicMongoPersistentEntity.java</file>
		</fixedFiles>
	</bug>
	<bug id="1087" opendate="2014-11-06 15:06:49" fixdate="2014-11-28 03:04:36" resolution="Fixed">
		<buginformation>
			<summary>Incorrect warning for MongoPersistentEntityIndexResolver$CyclicPropertyReferenceException: Found cycle for field...</summary>
			<description>The below class returns an incorrect warning about finding a cycle.  It is caused by the names of the fields.  If the name- prefix in nameLast is changed to a different string then the warning is not output.  The class:






@Document




public class CycleExample implements Serializable {









    public class NameComponent {









        private String component;









        public String getComponent() {




            return component;




        }









        public void setNumber(String component) {




            this.component = component;




        }




    }









    private NameComponent name;




    private NameComponent nameLast;









    public NameComponent getName() {




        return name;




    }









    public void setName(NameComponent name) {




        this.name = name;




    }









    public NameComponent getNameLast() {




        return nameLast;




    }









    public void setNameLast(NameComponent nameLast) {




        this.nameLast = nameLast;




    }









}












014-11-06 15:04:56,033 [main] WARN  org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver - Found cycle for field &amp;amp;apos;component&amp;amp;apos; in type &amp;amp;apos;NameComponent&amp;amp;apos; for path &amp;amp;apos;name&amp;amp;apos;




org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$CyclicPropertyReferenceException: Found cycle for field &amp;amp;apos;component&amp;amp;apos; in type &amp;amp;apos;NameComponent&amp;amp;apos; for path &amp;amp;apos;name&amp;amp;apos;




        at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$CycleGuard.protect(MongoPersistentEntityIndexResolver.java:472)




        at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:231)




        at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:226)




        at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




        at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.appendTextIndexInformation(MongoPersistentEntityIndexResolver.java:226)




        at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$400(MongoPersistentEntityIndexResolver.java:56)




        at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:256)




        at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:226)




        at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294)




        at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.appendTextIndexInformation(MongoPersistentEntityIndexResolver.java:226)




        at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.potentiallyCreateTextIndexDefinition(MongoPersistentEntityIndexResolver.java:205)




        at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForEntity(MongoPersistentEntityIndexResolver.java:99)




        at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:79)




        at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:56)




        at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.checkForAndCreateIndexes(MongoPersistentEntityIndexCreator.java:128)




        at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.checkForIndexes(MongoPersistentEntityIndexCreator.java:121)




        at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.onApplicationEvent(MongoPersistentEntityIndexCreator.java:105)




        at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.onApplicationEvent(MongoPersistentEntityIndexCreator.java:46)




        at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:151)




        at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:128)




        at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:331)




        at org.springframework.data.mapping.context.AbstractMappingContext.addPersistentEntity(AbstractMappingContext.java:307)




        at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:181)




        at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:141)




        at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentEntity(AbstractMappingContext.java:67)




        at org.springframework.data.mongodb.repository.support.MongoRepositoryFactory.getEntityInformation(MongoRepositoryFactory.java:141)




        at org.springframework.data.mongodb.repository.support.MongoRepositoryFactory.getTargetRepository(MongoRepositoryFactory.java:83)




        at org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(RepositoryFactorySupport.java:177)




        at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.initAndReturn(RepositoryFactoryBeanSupport.java:239)




        at org.springframework.data.repository.core.support.RepositoryFactoryBeanSupport.afterPropertiesSet(RepositoryFactoryBeanSupport.java:225)




...





</description>
			<version>1.7 M1 (Fowler)</version>
			<fixedVersion>1.7 M1 (Fowler), 1.5.5 (Dijkstra SR5), 1.6.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolverUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">1121</link>
		</links>
	</bug>
	<bug id="1043" opendate="2014-09-01 05:30:48" fixdate="2014-11-28 11:27:09" resolution="Fixed">
		<buginformation>
			<summary>SpEL Expressions in @Document annotations are not re-evaluated for query executions</summary>
			<description>Based on the idea of Oliver Gierke in https://jira.spring.io/browse/DATAMONGO-525 I followed some post like the ones below
http://stackoverflow.com/questions/18129291/mongodb-and-spel-expressions-in-document-annotations
and
http://stackoverflow.com/questions/19807733/mongodb-multi-tenacy-spel-with-document?rq=1
but in the end I realized that the problem is that AbstractMongoQuery is cached between requests(maybe a problem in my config?), and its query-method object of type MongoQueryMethod, which holds the metadata, MongoEntityMetadata. And thus make this approach (use SpEL in @Document annotation) not fully working.
AbstractMongoQuery deals with different kind of executions. All of them but SingleEntityExecution suffers from this problem, and it&amp;amp;apos;s because in SingleEntityExecution mongoOperations is called without passing collectionName and thus letting, in the end, BasicMongoPersistentEntity.getCollection apply SpEL over entity class to obtain the runtime collection name.</description>
			<version>1.5.2 (Dijkstra SR2)</version>
			<fixedVersion>1.7 M1 (Fowler), 1.5.5 (Dijkstra SR5), 1.6.2 (Evans SR2)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.SimpleMongoEntityMetadata.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryMethod.java</file>
		</fixedFiles>
	</bug>
	<bug id="1120" opendate="2014-12-15 13:39:20" fixdate="2014-12-18 07:02:23" resolution="Fixed">
		<buginformation>
			<summary>Pageable queries timeout or return incorrect counts</summary>
			<description>Counts for total elements and pages on some repositories return 0 and some throw a 500 when the socket times out.  This is ONLY occurring on calls that return a Page object and accept a Pageable input.  After debugging a bit, the inputs all seem to be populated from the controller fine.  The query definitions are
findByActiveIsTrue = wrong counts for totalElements and totalPages. both are 0
findByUserId = this collection is large at around 3 million records, but is indexed.
This is only happening in 1.6.1 and works correctly in 1.6.0</description>
			<version>1.6.1 (Evans SR1)</version>
			<fixedVersion>1.6.2 (Evans SR2), 1.7 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQueryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQuery.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoOperations.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.repository.Person.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1126</link>
			<link type="Relate" description="is related to">1080</link>
		</links>
	</bug>
	<bug id="1118" opendate="2014-12-11 05:12:11" fixdate="2015-01-06 06:54:54" resolution="Fixed">
		<buginformation>
			<summary>Custom converters not used for map keys</summary>
			<description>I have an enum with rather long names and shorter per-value "tags" that I want to use for serialization. I&amp;amp;apos;ve implemented a Converter pair that maps the values back and forth. They work properly when saving a Set of the enum.
However, when saving a Map&amp;lt;MyEnum,?&amp;gt;, the converter method is skipped; the enum&amp;amp;apos;s name is still used as the map key saved to Mongo. This would be frustrating but work-aroundable, but the proper converter is applied on reads. This means that when I save an object with a non-empty map and immediately attempt to read it, I get an exception when calling the read converter (since it&amp;amp;apos;s being supplied an invalid argument).
The problem appears to be at MappingMongoConverter:644, where the conversion service is explicitly skipped. This means that converters are applied to all types on read, and to all instances except map keys on write.</description>
			<version>1.6.1 (Evans SR1)</version>
			<fixedVersion>1.5.5 (Dijkstra SR5), 1.6.2 (Evans SR2), 1.7 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.CustomConversions.java</file>
		</fixedFiles>
	</bug>
	<bug id="1123" opendate="2014-12-17 09:39:36" fixdate="2015-01-07 06:15:01" resolution="Fixed">
		<buginformation>
			<summary>geoNear, does not return all matching elements, it returns only a max of 100 documents</summary>
			<description>Aloha,
I have the following query:






public GeoResults&amp;lt;MyObject&amp;gt; findByTypeAndLocationNear(MyObjectType type, Point p, Distance distance) {




   final NearQuery nearQuery = NearQuery.near(p).maxDistance(distance);




   log.info("{}",nearQuery.toDBObject());




   return mongoTemplate.geoNear(nearQuery, MyObject.class);




}






The geoNear method is documented like this:






Returns {@link GeoResults} for all entities matching the given {@link NearQuery}.






I expect 1000 "matching" documents But i only get 100. There is some default being set, that restricts the result to 100. That should be stated in the method. And another method having a pageable should be added.
What do you think?</description>
			<version>1.6.1 (Evans SR1)</version>
			<fixedVersion>1.5.5 (Dijkstra SR5), 1.6.2 (Evans SR2), 1.7 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="1139" opendate="2015-01-12 10:07:34" fixdate="2015-01-12 10:29:25" resolution="Fixed">
		<buginformation>
			<summary>MongoQueryCreator must not create $nearSphere query for neutral Distance</summary>
			<description>MongoQueryCreator.from() compares the Distance&amp;amp;apos;s metric against null which will never result in true as {8Distance}} returns Metric.NEUTRAl by default.</description>
			<version>1.5.4 (Dijkstra SR4)</version>
			<fixedVersion>1.5.5 (Dijkstra SR5), 1.6.2 (Evans SR2), 1.7 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.StubParameterAccessor.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreator.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreatorUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1121" opendate="2014-12-16 11:29:02" fixdate="2015-01-20 03:55:21" resolution="Fixed">
		<buginformation>
			<summary>"Cycle found" false positive</summary>
			<description>





@Document(collection = "normalized_profiles")




public class NormalizedProfile {









    @Id




    private ObjectId id = ObjectId.get();




...




    private ListField&amp;lt;String&amp;gt; firstName;




    private ListField&amp;lt;String&amp;gt; firstNameCanonical;




...




}






So I have 2 properties - firstName and firstNameCanonical, and CycleChecker warns about possible cycle reference on framework startup. Quite misleading, because searchResults.profile.lastNameCanonical is not a subpath of searchResults.profile.lastName (for example).
I believe the problem is with following code in MongoPersistentEntityIndexResolver.Path.cycles():






/**




 * Checks whether the given property is owned by the same entity and if it has been already visited by a subset of




 * the current path. Given {@literal foo.bar.bar} cycles if {@literal foo.bar} has already been visited and




 * {@code class Bar} contains a property of type {@code Bar}. The previously mentioned path would not cycle if




 * {@code class Bar} contained a property of type {@code SomeEntity} named {@literal bar}.




 * 




 * @param property




 * @param path




 * @return




 */




boolean cycles(MongoPersistentProperty property, String path) {









    if (!property.getOwner().equals(this.property.getOwner())) {




        return false;




    }









    return path.contains(this.path);




}






&amp;amp;apos;Contains&amp;amp;apos; should be analyzed in terms of dot-notation (ie properties), rather than a simple string contains.
Full stacktrace:






2014-12-16 22:26:35.419 / [main] WARN  o.s.d.m.c.index.MongoPersistentEntityIndexResolver - Found cycle for field &amp;amp;apos;data&amp;amp;apos; in type &amp;amp;apos;ListField&amp;amp;apos; for path &amp;amp;apos;searchResults.profile.lastName&amp;amp;apos;




org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$CyclicPropertyReferenceException: Found cycle for field &amp;amp;apos;data&amp;amp;apos; in type &amp;amp;apos;ListField&amp;amp;apos; for path &amp;amp;apos;searchResults.profile.lastName&amp;amp;apos;




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$CycleGuard.protect(MongoPersistentEntityIndexResolver.java:472) ~[spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:231) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:226) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294) [spring-data-commons-1.9.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.appendTextIndexInformation(MongoPersistentEntityIndexResolver.java:226) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$400(MongoPersistentEntityIndexResolver.java:56) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:256) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:226) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294) [spring-data-commons-1.9.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.appendTextIndexInformation(MongoPersistentEntityIndexResolver.java:226) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$400(MongoPersistentEntityIndexResolver.java:56) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:256) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:226) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294) [spring-data-commons-1.9.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.appendTextIndexInformation(MongoPersistentEntityIndexResolver.java:226) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.access$400(MongoPersistentEntityIndexResolver.java:56) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:256) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver$3.doWithPersistentProperty(MongoPersistentEntityIndexResolver.java:226) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mapping.model.BasicPersistentEntity.doWithProperties(BasicPersistentEntity.java:294) [spring-data-commons-1.9.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.appendTextIndexInformation(MongoPersistentEntityIndexResolver.java:226) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.potentiallyCreateTextIndexDefinition(MongoPersistentEntityIndexResolver.java:205) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForEntity(MongoPersistentEntityIndexResolver.java:99) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:79) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.resolveIndexForClass(MongoPersistentEntityIndexResolver.java:56) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.checkForAndCreateIndexes(MongoPersistentEntityIndexCreator.java:128) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.checkForIndexes(MongoPersistentEntityIndexCreator.java:121) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.&amp;lt;init&amp;gt;(MongoPersistentEntityIndexCreator.java:87) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.&amp;lt;init&amp;gt;(MongoPersistentEntityIndexCreator.java:64) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.core.MongoTemplate.&amp;lt;init&amp;gt;(MongoTemplate.java:218) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at org.springframework.data.mongodb.config.AbstractMongoConfiguration.mongoTemplate(AbstractMongoConfiguration.java:95) [spring-data-mongodb-1.6.1.RELEASE.jar:na]




	at com.scorr.config.MongoStorageConfig$$EnhancerBySpringCGLIB$$486c2c56.CGLIB$mongoTemplate$8(&amp;lt;generated&amp;gt;) [spring-core-4.0.6.RELEASE.jar:na]




	at com.scorr.config.MongoStorageConfig$$EnhancerBySpringCGLIB$$486c2c56$$FastClassBySpringCGLIB$$8ad6efc3.invoke(&amp;lt;generated&amp;gt;) [spring-core-4.0.6.RELEASE.jar:na]




	at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228) [spring-core-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:312) [spring-context-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at com.scorr.config.MongoStorageConfig$$EnhancerBySpringCGLIB$$486c2c56.mongoTemplate(&amp;lt;generated&amp;gt;) [spring-core-4.0.6.RELEASE.jar:na]




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_25]




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_25]




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_25]




	at java.lang.reflect.Method.invoke(Method.java:483) ~[na:1.8.0_25]




	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:166) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:586) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1094) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:989) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:504) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:302) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:298) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:328) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:108) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1456) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1197) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:302) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:298) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:198) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:271) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1017) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:960) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:858) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:480) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:87) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:289) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1185) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:302) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:298) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:324) [spring-context-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at com.scorr.collector.CollectorWebConfig$$EnhancerBySpringCGLIB$$a7d50d23.userDetailsService(&amp;lt;generated&amp;gt;) [spring-core-4.0.6.RELEASE.jar:na]




	at com.scorr.collector.CollectorWebConfig.configureGlobal(CollectorWebConfig.java:79) [classes/:na]




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_25]




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_25]




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_25]




	at java.lang.reflect.Method.invoke(Method.java:483) ~[na:1.8.0_25]




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredMethodElement.inject(AutowiredAnnotationBeanPostProcessor.java:589) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:87) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:289) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1185) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:302) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:298) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:703) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:760) [spring-context-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482) [spring-context-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:403) [spring-web-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:306) [spring-web-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:106) [spring-web-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at com.scorr.web.EmbeddedWebServer$1.contextInitialized(EmbeddedWebServer.java:86) [classes/:na]




	at org.eclipse.jetty.server.handler.ContextHandler.callContextInitialized(ContextHandler.java:798) [jetty-server-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.servlet.ServletContextHandler.callContextInitialized(ServletContextHandler.java:444) [jetty-servlet-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.server.handler.ContextHandler.startContext(ContextHandler.java:789) [jetty-server-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.servlet.ServletContextHandler.startContext(ServletContextHandler.java:294) [jetty-servlet-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.webapp.WebAppContext.startWebapp(WebAppContext.java:1343) [jetty-webapp-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.webapp.WebAppContext.startContext(WebAppContext.java:1336) [jetty-webapp-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.server.handler.ContextHandler.doStart(ContextHandler.java:741) [jetty-server-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.webapp.WebAppContext.doStart(WebAppContext.java:499) [jetty-webapp-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68) [jetty-util-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.util.component.ContainerLifeCycle.start(ContainerLifeCycle.java:132) [jetty-util-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.util.component.ContainerLifeCycle.doStart(ContainerLifeCycle.java:114) [jetty-util-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.server.handler.AbstractHandler.doStart(AbstractHandler.java:61) [jetty-server-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68) [jetty-util-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.util.component.ContainerLifeCycle.start(ContainerLifeCycle.java:132) [jetty-util-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.server.Server.start(Server.java:387) [jetty-server-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.util.component.ContainerLifeCycle.doStart(ContainerLifeCycle.java:114) [jetty-util-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.server.handler.AbstractHandler.doStart(AbstractHandler.java:61) [jetty-server-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.server.Server.doStart(Server.java:354) [jetty-server-9.2.4.v20141103.jar:9.2.4.v20141103]




	at org.eclipse.jetty.util.component.AbstractLifeCycle.start(AbstractLifeCycle.java:68) [jetty-util-9.2.4.v20141103.jar:9.2.4.v20141103]




	at com.scorr.web.EmbeddedWebServer.start(EmbeddedWebServer.java:106) [classes/:na]




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_25]




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_25]




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_25]




	at java.lang.reflect.Method.invoke(Method.java:483) ~[na:1.8.0_25]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1681) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1620) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1549) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:539) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:302) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:298) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:703) [spring-beans-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:760) [spring-context-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482) [spring-context-4.0.6.RELEASE.jar:4.0.6.RELEASE]




	at com.scorr.service.ServiceLauncher.main(ServiceLauncher.java:48) [classes/:na]





</description>
			<version>1.6.1 (Evans SR1)</version>
			<fixedVersion>1.5.5 (Dijkstra SR5), 1.6.2 (Evans SR2), 1.7 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolverUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">1124</link>
			<link type="Relate" description="is related to">1087</link>
		</links>
	</bug>
	<bug id="1126" opendate="2014-12-21 06:03:21" fixdate="2015-01-20 08:04:31" resolution="Fixed">
		<buginformation>
			<summary>Repository keyword query findByInId with pageable not returning correctly</summary>
			<description>I&amp;amp;apos;ve been trying to use the In-keyword with identifiers and making the query pageable. The query returns results but getTotalElements() and getTotalPages() always returns 0. Also when you try to get any other page than 0, no results return. I&amp;amp;apos;ve tried using In with another member other than id and it works as expected. Below is a strip down example I used for testing;
I&amp;amp;apos;ve created 3 types and 10 items per those types, results in a total of 30 items.






@Document




public class Item {









    @Id




    private String id;




    private String type;




}












public interface ItemRepository extends MongoRepository&amp;lt;Item, String&amp;gt; {









    Page&amp;lt;Item&amp;gt; findByIdIn(Collection ids, Pageable pageable);




    Page&amp;lt;Item&amp;gt; findByTypeIn(Collection types, Pageable pageable);




}












@RunWith(SpringJUnit4ClassRunner.class)




@ContextConfiguration(classes = {MongoDbConfig.class})




@TransactionConfiguration(defaultRollback = false)




public class TestPageableIdIn {









    @Autowired




    private ItemRepository itemRepository;




    




    private List&amp;lt;String&amp;gt; allIds = new LinkedList&amp;lt;&amp;gt;();









    @Before




    public void setUp() {




        itemRepository.deleteAll();




        String[] types = {"SWORD", "SHIELD", "ARMOUR"};









        // 10 items per type




        for (String type : types) {




            for (int i = 0; i &amp;lt; 10; i++) {




                String id = UUID.randomUUID().toString();




                allIds.add(id);




                itemRepository.save(new Item(id, type));




            }




        }




    }









    @Test




    public void testPageableIdIn() {




        




        Pageable pageable = new PageRequest(0, 5);




        




        // expect 5 Items returned, total of 10 Items(SWORDS) in 2 Pages




        Page&amp;lt;Item&amp;gt; results = itemRepository.findByTypeIn(Arrays.asList("SWORD"), pageable);




        Assert.assertEquals(5, results.getContent().size());




        Assert.assertEquals(10, results.getTotalElements());




        Assert.assertEquals(2, results.getTotalPages());




        




        // expect 5 Items returned, total of 30 Items in 6 Pages




        results = itemRepository.findByIdIn(allIds, pageable);




        Assert.assertEquals(5, results.getContent().size());




        Assert.assertEquals(30, results.getTotalElements()); // this is returning 0




        Assert.assertEquals(6, results.getTotalPages());     // this is returning 0




    }




}





</description>
			<version>1.6.1 (Evans SR1)</version>
			<fixedVersion>1.6.2 (Evans SR2), 1.7 RC1 (Fowler)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQueryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.AbstractMongoQuery.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoOperations.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.repository.Person.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1120</link>
		</links>
	</bug>
	<bug id="1180" opendate="2015-03-10 01:55:22" fixdate="2015-03-10 04:25:52" resolution="Fixed">
		<buginformation>
			<summary>Incorrect exception message creation in PartTreeMongoQuery.</summary>
			<description>In PartTreeMongoQuery#createQuery the JSONParseException is passed to the String.format() instead of IllegalStateException.</description>
			<version>1.6.2 (Evans SR2)</version>
			<fixedVersion>1.7 GA (Fowler), 1.6.3 (Evans SR3), 1.5.6 (Dijkstra SR6)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.PartTreeMongoQueryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.PartTreeMongoQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="1208" opendate="2015-04-22 06:03:21" fixdate="2015-05-21 00:02:48" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate.stream() does not consider limit, order, sort etc.</summary>
			<description>I am trying to introduce the operation mongoTemplate.stream in my project.
This is the code I use to create the query-object






    private Query createQuery(Criteria criteria, int pageSize, boolean disableTimeout, boolean limitFrom) {




        Query query = query(criteria)




                .with(




                        new PageRequest(




                                0, pageSize,




                                new Sort(limitFrom ? Sort.Direction.ASC : Sort.Direction.DESC, "timestamp")));









        if (disableTimeout) {




            query = query.maxTime(4, TimeUnit.HOURS);




        }




        return query;




    }






The resulting query contains a value for the limit-field. However, when executing the stream-operation, the limit-value is not taken into account and I retrieve all matching documents.</description>
			<version>1.7 GA (Fowler)</version>
			<fixedVersion>1.8 M1 (Gosling), 1.7.1 (Fowler SR1)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="1133" opendate="2015-01-07 00:20:51" fixdate="2015-05-25 05:03:59" resolution="Fixed">
		<buginformation>
			<summary>Field aliasing is not honored in Aggregation operations</summary>
			<description>the aggretation uses the property name of a class rather than the name designated in @Field.</description>
			<version>1.6.1 (Evans SR1)</version>
			<fixedVersion>1.7 RC1 (Fowler), 1.6.3 (Evans SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.aggregation.MeterData.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.AggregationTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.TypeBasedAggregationOperationContextUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1193" opendate="2015-04-01 01:30:33" fixdate="2015-05-31 23:13:28" resolution="Fixed">
		<buginformation>
			<summary>Prevent unnecessary database lookups when resolving DBRefs on 2.x driver</summary>
			<description>DefaultDbRefResolver looks up a DB instance via the MongoDbFactory whose output will not actually be used in the case of using the MongoDB 2.x Java driver.
This causes a performance degradation especially in collections of DBRef instances.</description>
			<version>1.7 GA (Fowler)</version>
			<fixedVersion>1.8 M1 (Gosling), 1.7.1 (Fowler SR1)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.ReflectiveDBRefResolver.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.DefaultDbRefResolver.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">1194</link>
		</links>
	</bug>
	<bug id="1202" opendate="2015-04-14 02:36:40" fixdate="2015-06-01 00:45:42" resolution="Fixed">
		<buginformation>
			<summary>Indexed annotation problems under generics</summary>
			<description>There is a problem with the @Indexed annotation with the model classes. Under simple scenarios with reflexive DBRef relations works as expected, but if used in conjunction with generics it doesn&amp;amp;apos;t create the index expected.
I provide a github project with two scenarios:

Employer: Very simple reflexive relation that works nicely (EmployerTest)
Customer: A little more complex scenario using GenericCustomer as a base class to allow having many different kinds of customers. This scenario fails at creating the index (CustomerTest).

This test runs without a Mongo server because it uses embedmongo-spring (https://github.com/jirutka/embedmongo-spring) at a random port each time the test runs.
If you run Application it will just create indexes and put some data in customer collection assuming a MongoD is running locally at 27017</description>
			<version>1.6.2 (Evans SR2)</version>
			<fixedVersion>1.8 M1 (Gosling), 1.7.1 (Fowler SR1)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.data.mongodb.core.index.GenericCustomer.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreatorIntegrationTests.java</file>
			<file type="D">org.springframework.data.mongodb.core.index.ConcreteCustomer.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.IndexResolver.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexCreator.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="1216" opendate="2015-05-07 14:47:17" fixdate="2015-06-01 03:14:49" resolution="Fixed">
		<buginformation>
			<summary>Authentication mechanism PLAIN  changes to SCRAM-SHA-1 </summary>
			<description>We have a mongodb properly configured with plain authentication mechanism, and we can successfully log in using mongodb client. However, if we try to connect using mongo driver + spring data, login is incorrect due to authentication mechanism sent is SCRAM-SHA-1 and not PLAIN.
We have made a code review and a full debug and the problem seems to be in MongoDbUtils.doGetDB(Mongo, String, UserCredentials, boolean, String) method, in the synchronized block, since the authentication mechanism seems to get lost there.
Our spring data configuration is:






&amp;lt;mongo:db-factory uri="mongodb://user:pass@ip1:port1,ip2:port2,/logCenter?authSource=$external&amp;amp;amp;authMechanism=PLAIN" /&amp;gt;









&amp;lt;bean id="mongoTemplate" class="org.springframework.data.mongodb.core.MongoTemplate"&amp;gt;




	&amp;lt;constructor-arg name="mongoDbFactory" ref="mongoDbFactory"&amp;gt;&amp;lt;/constructor-arg&amp;gt;




&amp;lt;/bean&amp;gt;




	




&amp;lt;mongo:repositories base-package="com.xxx.repositories" /&amp;gt;





</description>
			<version>1.5.5 (Dijkstra SR5)</version>
			<fixedVersion>1.8 M1 (Gosling), 1.7.1 (Fowler SR1)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoDbUtils.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoDbUtilsUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">1259</link>
			<link type="Relate" description="is related to">1218</link>
		</links>
	</bug>
	<bug id="1210" opendate="2015-04-26 23:05:01" fixdate="2015-06-01 04:29:36" resolution="Fixed">
		<buginformation>
			<summary>Inconsistent property order of _class type hint breaks document equality.</summary>
			<description>findAndModify writes the type hint _class either before or after all other fields, whereas save writes it always after. Because of that, MongoDBs addToSet/forEach treats two objects as different, even though they only differ in the position of _class. As a consequence, findAndModify/addToSet/forEach adds duplicates to collections.
The proposed change fixes this by always writing the type hint after all fields.
Unfortunately, this works only for collection fields of complex documents, when both save and findAndModify write the type hint. Please see my other pull request for a test that demonstrates the erroneous behaviour in case of simple documents, where the type hint is written by findAndModify.

https://github.com/spring-projects/spring-data-mongodb/pull/289 (proposed fix)
https://github.com/spring-projects/spring-data-mongodb/pull/290 (tests)
https://github.com/spring-projects/spring-data-mongodb/pull/291 (tests)</description>
			<version>1.6.2 (Evans SR2)</version>
			<fixedVersion>1.8 M1 (Gosling), 1.6.3 (Evans SR3), 1.7.1 (Fowler SR1)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapperUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.test.util.IsBsonObject.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">1269</link>
			<link type="Relate" description="is related to">1509</link>
			<link type="Supersede" description="supersedes">1209</link>
		</links>
	</bug>
	<bug id="1229" opendate="2015-06-02 11:17:53" fixdate="2015-06-04 22:07:53" resolution="Fixed">
		<buginformation>
			<summary>MongoQueryCreator incorrectly rejects ignoreCase on nested String path</summary>
			<description>I have an embedded field foo.bar in my document class. I can use a repository to define findByFooBar(String bar), but findByFooBarIgnoreCase(String bar) throws an exception at query time:






java.lang.IllegalArgumentException: part Doc.foo.bar must be of type String but was SIMPLE_PROPERTY (1): [Is, Equals]





</description>
			<version>1.7 GA (Fowler)</version>
			<fixedVersion>1.6.3 (Evans SR3), 1.7.1 (Fowler SR1), 1.5.6 (Dijkstra SR6), 1.8 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreator.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreatorUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1166" opendate="2015-02-19 23:36:37" fixdate="2015-06-21 23:56:17" resolution="Fixed">
		<buginformation>
			<summary>ReadPreference not used for Aggregations.</summary>
			<description>From the referenced issue on SO:

It turned out that spring-data-mongodb does not pass the read preference specified on mongoTemplate to the underlying com.mongodb.Mongo connection pool - for aggregations. It would pass the read preference for simple find operations.</description>
			<version>1.6.2 (Evans SR2)</version>
			<fixedVersion>1.6.3 (Evans SR3), 1.7.1 (Fowler SR1), 1.5.6 (Dijkstra SR6), 1.8 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="1232" opendate="2015-06-03 10:27:23" fixdate="2015-06-24 11:21:16" resolution="Fixed">
		<buginformation>
			<summary>IgnoreCase should escape queries</summary>
			<description>The IgnoreCase query generator is subject to a sort of "regex injection" attack, because the query generator simply slaps ^..$ around the string and passes it directly to MongoDB. This fails when the string contains any sort of special characters. In my case, I&amp;amp;apos;m trying to perform a case-insensitive find on an e-mail address with the + sign, a legal character, but the regex interprets this as 1..*.
The query generator needs to properly escape regex-special characters.</description>
			<version>1.6.2 (Evans SR2)</version>
			<fixedVersion>1.6.3 (Evans SR3), 1.7.1 (Fowler SR1), 1.5.6 (Dijkstra SR6), 1.8 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreator.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreatorUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1368</link>
		</links>
	</bug>
	<bug id="1250" opendate="2015-07-03 21:07:44" fixdate="2015-07-04 10:10:16" resolution="Fixed">
		<buginformation>
			<summary>Custom converter implementation not used in updates</summary>
			<description>There does seem to be an issue with the use of customer converters when used in mongoTemplate.update* via an Update object.
I have a custom (de)serialiser for an enumerated type, and it works perfectly when saving and loading a @Document annotated POJO.
It also works when building and executing a Query object.
However when used in an Update, it is either ignored, or called in situations where it shouldn&amp;amp;apos;t.
Please clone https://github.com/patrickherrera/converter_test.git for a full test application.
In brief there is a POJO and for the purposes of the test it has a static enum with the desired converters:






@Document




public class MyPersistantObject {




    public Allocation allocation;




    public BigDecimal value;









    public enum Allocation {




        AVAILABLE("V"),




        ALLOCATED("A");









        private final String code;









        Allocation(String code) {




            this.code = code;




        }









        public static Converter&amp;lt;Allocation, String&amp;gt; writer() {




            return new Converter&amp;lt;Allocation, String&amp;gt;() {




                public String convert(Allocation allocation) {




                    return allocation.getCode();




                }




            };




        }









        public static Converter&amp;lt;String, Allocation&amp;gt; reader() {




            return new Converter&amp;lt;String, Allocation&amp;gt;() {




                public Allocation convert(String source) {




                    return Allocation.getByCode(source);




                }




            };




        }









        public static Allocation getByCode(String code) {




            switch (code) {




                case "V":




                    return AVAILABLE;




                case "A":




                    return ALLOCATED;




            }









            throw new IllegalArgumentException("Unable to get Allocation from: " + code);




        }









        public String getCode() {




            return code;




        }




    }




}






It simply converts back and forward using a short code rather than the full Enum name.
These are registered in the Spring Boot application entry point:






    @Bean




    public CustomConversions customConversions() {




        return new CustomConversions(Arrays.asList(




                MyPersistantObject.Allocation.reader(),




                MyPersistantObject.Allocation.writer()




        ));




    }






There is a unit test that drives a few scenarios:






@Test




    public void testConversion() {




        Update update;




        Query query;




        MyPersistantObject returned;




        MyPersistantObject myPersistantObject = new MyPersistantObject();




        myPersistantObject.allocation = AVAILABLE;




        myPersistantObject.value = new BigDecimal(1234567);









        mongoTemplate.save(myPersistantObject);









        // Check it was saved correctly - first with invalid allocation to confirm conversion in query




        query = query(where("allocation").is(ALLOCATED));




        assertThat(mongoTemplate.findOne(query, MyPersistantObject.class), is(nullValue()));









        // Check it was saved correctly - now with valid allocation to confirm conversion in query




        query = query(where("allocation").is(AVAILABLE));




        returned = mongoTemplate.findOne(query, MyPersistantObject.class);




        assertThat(returned.allocation, is(AVAILABLE));




        assertThat(returned.value.longValue(), is(1234567L));









        try {




            // Update allocation from constant - will fail




            update = update("allocation", ALLOCATED);




            mongoTemplate.updateMulti(query, update, MyPersistantObject.class);




        } catch (Exception e) {




            System.err.println("failed to convert allocation: java.lang.IllegalArgumentException: can&amp;amp;apos;t serialize class converter_test.MyPersistantObject$Allocation");




        }









        // Update allocation from string value - succeeds




        update = update("allocation", ALLOCATED.getCode());




        mongoTemplate.updateMulti(query, update, MyPersistantObject.class);




        // Check allocation update




        query = query(where("allocation").is(ALLOCATED));




        returned = mongoTemplate.findOne(query, MyPersistantObject.class);




        assertThat(returned.allocation, is(ALLOCATED));









        // Update value only - will fail: Caused by: java.lang.IllegalArgumentException: Unable to get MyPersistantObject.Allocation from: 54321




        // Tries to use MyPersistantObject.Allocation converter to String




        update = update("value", new BigDecimal(54321));




        mongoTemplate.updateMulti(query, update, MyPersistantObject.class);




        // Check value update




        returned = mongoTemplate.findAll(MyPersistantObject.class).get(0);




        assertThat(returned.value.longValue(), is(54321L));




    }






Hopefully that makes sense.
Firstly it saves and queries for the object to demonstrate that the converters are called correctly on the document.  I have confirmed that the document in the database correctly stores the Enum code rather than the name.
By use of a positive and negative case, it appears that the converter is being called correctly when used in the Query builder.
When it comes to an Update, the Enum is unable to be serialised correctly, and an exception is thrown to that effect.
If I change it to use the code (a String), it works and we confirm that by Querying it back from the DB.
So it appears that the customer converter for converting from my Enum is not called in this situation.
Next I try and update the other value in the Document.  The BigDecimal is converted to a String by an existing converter I assume, but then my customer converter is called to try and convert the numeric String into an Allocation Enum which of course fails.
I tried to debug the code and it seems that there is an overloaded method in CustomConversions: getCustomWriteTarget that takes one or two arguments, the second being a requestedTargetType.  That second variant never seems to be called in MappingMongoConverter, but perhaps if that type information was passed then it would not use my Allocation converter.
Without type information it seems the default is just to use the first converter that can handle the input type, in this case a String.  It is my custom one which is picked up first but can&amp;amp;apos;t actually handle it.
Please advise if there is something I am missing, as I can&amp;amp;apos;t find a workaround either - I have resorted to the Mongo Driver itself to do the update.
</description>
			<version>1.6.3 (Evans SR3)</version>
			<fixedVersion>1.7.2 (Fowler SR2), 1.8 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1251" opendate="2015-07-06 06:14:49" fixdate="2015-07-07 05:54:07" resolution="Fixed">
		<buginformation>
			<summary>update / findAndModify throws NullPointerException</summary>
			<description>Following code throws a NullPointerException:






mongoOperations.updateFirst(




	new Query(),




	new Update().set("date", null),




	TestEntity.class




);






Where TestEntity simply this:






@Document(collection="test")




public class TestEntity {




	@Id




	private String id;




	public String getId() { return id; }




	




	private LocalDate date;




	public LocalDate getDate() { return date; }




	public void setDate(LocalDate date) { this.date = date; }	




}






StackTrace:






java.lang.NullPointerException: null




	at org.springframework.data.mongodb.core.convert.UpdateMapper.processTypeHintForNestedDocuments(UpdateMapper.java:155)




	at org.springframework.data.mongodb.core.convert.UpdateMapper.getTypeHintForEntity(UpdateMapper.java:145)




	at org.springframework.data.mongodb.core.convert.UpdateMapper.delegateConvertToMongoType(UpdateMapper.java:70)




	at org.springframework.data.mongodb.core.convert.QueryMapper.convertSimpleOrDBObject(QueryMapper.java:362)




	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedValue(QueryMapper.java:308)




	at org.springframework.data.mongodb.core.convert.UpdateMapper.getMappedObjectForField(UpdateMapper.java:93)




	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedObject(QueryMapper.java:123)




	at org.springframework.data.mongodb.core.convert.QueryMapper.convertSimpleOrDBObject(QueryMapper.java:359)




	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedKeyword(QueryMapper.java:242)




	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedObject(QueryMapper.java:100)




	at org.springframework.data.mongodb.core.MongoTemplate$12.doInCollection(MongoTemplate.java:1095)




	at org.springframework.data.mongodb.core.MongoTemplate$12.doInCollection(MongoTemplate.java:1086)




	at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:461)




	at org.springframework.data.mongodb.core.MongoTemplate.doUpdate(MongoTemplate.java:1086)




	at org.springframework.data.mongodb.core.MongoTemplate.updateFirst(MongoTemplate.java:1060)






Using mongoOperations.save / insert works as expected. And using field of type String works as well.
I tried to debug it, but I can&amp;amp;apos;t figure out why this happens. It looks like it treats LocalDate as a MongoPersistentEntity, but it doesn&amp;amp;apos;t do that for a String ?!
I also tried to provide my own Converter for LocalDate to Date and backwords, but this results in the same exception.
Here&amp;amp;apos;s the full code: http://pastebin.com/xEq54Umh
And pom.xml: http://pastebin.com/wDhWzx8s
It also happens with mongo-java-driver 2.12.5 and/or spring-data-mongodb 1.6.3</description>
			<version>1.7.1 (Fowler SR1)</version>
			<fixedVersion>1.7.2 (Fowler SR2), 1.8 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1244" opendate="2015-06-20 07:44:00" fixdate="2015-07-08 01:23:47" resolution="Fixed">
		<buginformation>
			<summary>StringBasedMongoQuery handles complex expression parameters incorrectly.</summary>
			<description>Currently the regex based expression parameter scanning is too weak to handle nested object expressions like:






{&amp;amp;apos;id&amp;amp;apos;:?#{ [0] ? { $exists :true} : [1] }}






which currently yields the invalid mongo query:






{&amp;amp;apos;id&amp;amp;apos;:?expr0 : [1] }}






instead of:






{&amp;amp;apos;id&amp;amp;apos;:&amp;amp;apos;?expr0&amp;amp;apos;}






Further more, if complex parameter objects are passed as expressions 
they get unnecessarily quoted which could yield wrong results.
E.g:






@{&amp;amp;apos;id&amp;amp;apos;:?#{ [0] ? { $exists :true} : [1] }, &amp;amp;apos;foo&amp;amp;apos;:42, &amp;amp;apos;bar&amp;amp;apos;: ?#{ [0] ? { $exists :false} : [1] }}






Currently results in:






@{&amp;amp;apos;id&amp;amp;apos;:"{ \"$exists\" :true}", &amp;amp;apos;foo&amp;amp;apos;:42, &amp;amp;apos;bar&amp;amp;apos;: &amp;amp;apos;foo&amp;amp;apos; }}






when finally rendered.
This prevents the effective use of SpEL based parameter expressions
to be used for dynamic filtering with Spring Security as it is currently possible
with Spring Data JPA.
With this fixed one could easily perform filtering based on Spring Security context information in Spring Data MongoDB Repositories:






public interface PersonRepository extends CrudRepository&amp;lt;Person, String&amp;gt; {









	@Query("{id: ?#{ hasRole(&amp;amp;apos;ROLE_ADMIN&amp;amp;apos;) ? {$exists:true} : principal.id}}")




	List&amp;lt;Person&amp;gt; findAllForCurrentUserById();




}





</description>
			<version>1.8 M1 (Gosling)</version>
			<fixedVersion>1.8 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQueryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="1236" opendate="2015-06-08 11:17:11" fixdate="2015-07-08 01:26:13" resolution="Fixed">
		<buginformation>
			<summary>MongoOperations findAndModify and updateFirst do not include the _class in Map values</summary>
			<description>When a map of type LinkedHashMap&amp;lt;String, Object&amp;gt;  is updated via MongoOperations findAndModify or updateFirst, the _class field is not saved for the map values.  Therefore, later reads of the data do not convert the value to the correct type, instead leaving it as LinkedHashMap. 
Please see attached maven project for test illustrating the problem. </description>
			<version>1.6.2 (Evans SR2)</version>
			<fixedVersion>1.6.3 (Evans SR3), 1.7.1 (Fowler SR1), 1.8 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1257" opendate="2015-07-20 12:08:51" fixdate="2015-07-27 04:50:43" resolution="Fixed">
		<buginformation>
			<summary>mongo:mongo-client namespace does not support usernames with a comma</summary>
			<description>When using a mongo database with X-509 authentication, the username of the user is the subject DN from the X-509 certificate (see http://docs.mongodb.org/manual/tutorial/configure-x509-client-authentication/). The subject DN usually contains commas in it. This causes problems with trying to setup the mongo client using the mongo:mongo-client namespace with xml configuration since it expects credentials to be a comma separated list of usernames and splits on comma (,)
Another problem is that the credential is expected to be in username:password@database format, but when using X-509 authentication there is no password.
A third issue that I noticed was that there seems to be a bug in 
org.springframework.data.mongodb.config.MongoCredentialPropertyEditor since when it checks for the presence of : and @ in the property, it does so on the original property, not the split string, which can cause NPEs if the colon or @ exists in the property but not on each split.</description>
			<version>1.7.1 (Fowler SR1)</version>
			<fixedVersion>1.7.2 (Fowler SR2), 1.8 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.config.MongoCredentialPropertyEditor.java</file>
			<file type="M">org.springframework.data.mongodb.config.MongoCredentialPropertyEditorUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1254" opendate="2015-07-13 13:21:28" fixdate="2015-07-27 05:19:54" resolution="Fixed">
		<buginformation>
			<summary>Group after Project in aggregation uses incorrect field name</summary>
			<description>When creating an aggregation, if a new field is named in the project, the new field name is converted to something else in a group by following the projection; the name passed in the group by is ignored.  This causes the results to be incorrect. See test case for an example. </description>
			<version>1.6.3 (Evans SR3)</version>
			<fixedVersion>1.7.2 (Fowler SR2), 1.8 RC1 (Gosling)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.aggregation.AggregationUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.ProjectionOperation.java</file>
		</fixedFiles>
	</bug>
	<bug id="1269" opendate="2015-08-04 23:04:39" fixdate="2015-08-06 11:19:12" resolution="Fixed">
		<buginformation>
			<summary>QueryMapper drops numeric keys in Maps.</summary>
			<description>As of 1.7.1 numeric keys get dropped in query mapping.






@Test




public void SO_31799474() {









	SomeContent content = new SomeContent();




	content.text = "foo";









	SO31799474 entity = new SO31799474();




	entity.id = "id-1";









	entity.map = Collections.singletonMap(Integer.valueOf(1), content);









	template.save(entity);









	assertThat(template.findOne(query(where("map.1.text").is("foo")), SO31799474.class), notNullValue());




}









static class SO31799474 {




	String id;




	Map&amp;lt;Integer, SomeContent&amp;gt; map;









	@Override




	public String toString() {




		return "SO31799474 [id=" + id + ", map=" + map + "]";




	}









}





</description>
			<version>1.7.1 (Fowler SR1)</version>
			<fixedVersion>1.8 GA (Gosling), 1.7.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">1210</link>
		</links>
	</bug>
	<bug id="1307" opendate="2015-10-20 12:33:45" fixdate="2015-10-20 17:24:35" resolution="Duplicate">
		<buginformation>
			<summary>Stop converting user-defined runtime exceptions to NPEs</summary>
			<description>MongoTemplate has code like this in many places:
} catch (RuntimeException ex) {
	throw exceptionTranslator.translateExceptionIfPossible(ex);
MongoExceptionTranslator, however, often does NOT return an exception. If it encounters an unknown exception it does this:
// If we get here, we have an exception that resulted from user code,
// rather than the persistence provider, so we return null to indicate
// that translation should not occur.
return null;
MongoTemplate then "eats" the original exception and throws a null-pointer exception instead.
MongoTemplate should throw the original exception if it gets null back from the exception translator.</description>
			<version>1.7.2 (Fowler SR2)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1276</link>
		</links>
	</bug>
	<bug id="1276" opendate="2015-08-19 02:31:58" fixdate="2015-10-21 13:12:38" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate.CloseableIterableCursorAdapter does not null check return values from PersistenceExceptionTranslator.</summary>
			<description>Using the Stream support in a MongoRepository I suddenly started getting exceptions like these:






java.lang.NullPointerException: null




	at org.springframework.data.mongodb.core.MongoTemplate$CloseableIterableCusorAdapter.next(MongoTemplate.java:2389)




	at java.util.Iterator.forEachRemaining(Iterator.java:116)




	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)




	at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:512)




	at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:502)




	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:708)




	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)




	at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:499)




...






After a bit if investigation it turns out that due to some domain model changes I appear to be getting an org.springframework.data.mapping.model.MappingException in the data mapping and since MongoExceptionTranslator does not specifically know about it. So it just returns null.
That appears to be fine according to the PersistenceExceptionTranslator interface. But it appears that the Spring Data MongoDB code will often throw the result without any null checks. Provoking an NPE and hiding the actual reason for the exception.</description>
			<version>1.7.2 (Fowler SR2)</version>
			<fixedVersion>1.8.1 (Gosling SR1), 1.9 M1 (Hopper), 1.7.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1295</link>
			<link type="Duplicate" description="is duplicated by">1307</link>
		</links>
	</bug>
	<bug id="1293" opendate="2015-09-24 13:32:49" fixdate="2015-10-29 14:27:36" resolution="Fixed">
		<buginformation>
			<summary>MongoDbFactoryParser should allow id attribute in addition to client-uri</summary>
			<description>The following isn&amp;amp;apos;t working: &amp;lt;mongo:db-factory id="myMongoDbFactory" client-uri="mongodb://localhost:27020/test"/&amp;gt;. The following exception is thrown:






Caused by: org.springframework.beans.factory.parsing.BeanDefinitionParsingException: Configuration problem: Configure either Mongo URI or details individually!




Offending resource: class path resource [jingit-financial-services-event-mongo.xml]




	at org.springframework.beans.factory.parsing.FailFastProblemReporter.error(FailFastProblemReporter.java:70)




	at org.springframework.beans.factory.parsing.ReaderContext.error(ReaderContext.java:85)




	at org.springframework.beans.factory.parsing.ReaderContext.error(ReaderContext.java:72)




	at org.springframework.data.mongodb.config.MongoDbFactoryParser.parseInternal(MongoDbFactoryParser.java:77)





</description>
			<version>1.8 GA (Gosling)</version>
			<fixedVersion>1.8.1 (Gosling SR1), 1.9 M1 (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.config.MongoDbFactoryParserIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.config.MongoDbFactoryParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="1295" opendate="2015-09-27 09:57:42" fixdate="2015-11-02 09:21:59" resolution="Duplicate">
		<buginformation>
			<summary>The MongoTemplate.CloseableIterableCusorAdapter runs into an NPE when a MappingException was raised</summary>
			<description>When a MappingException occurs, the MongoTemplate.CloseableIterableCusorAdapter will run into an NPE and swallow the source MappingException. That makes the stack trace unusable. CloseableIterableCursorAdapter is used for the new java.util.Stream support. The source of this issue here. The MongoExceptionTranslator.translateExceptionIfPossible(...)  returns null in case of mapping exceptions.
The stack trace (where the nice MappingException is swallowed):






Exception in thread "main" java.lang.IllegalStateException: Failed to execute CommandLineRunner




	at org.springframework.boot.SpringApplication.runCommandLineRunners(SpringApplication.java:676)




	at org.springframework.boot.SpringApplication.afterRefresh(SpringApplication.java:691)




	at org.springframework.boot.SpringApplication.run(SpringApplication.java:322)




	at org.springframework.boot.SpringApplication.run(SpringApplication.java:967)




	at org.springframework.boot.SpringApplication.run(SpringApplication.java:956)




	at com....ExtractorApplication.main(ExtractorApplication.java:25)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:483)




	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)




Caused by: java.lang.NullPointerException &amp;lt;---- That should be the Mapping Exception




	at org.springframework.data.mongodb.core.MongoTemplate$CloseableIterableCusorAdapter.next(MongoTemplate.java:2395)




	at java.util.Iterator.forEachRemaining(Iterator.java:116)




	at java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)




	at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580)




	at com......(XXX.java:48)




	at com.....ExtractorApplication.run(ExtractorApplication.java:37)




	at org.springframework.boot.SpringApplication.runCommandLineRunners(SpringApplication.java:673)




	... 10 more





</description>
			<version>1.8 GA (Gosling)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1276</link>
		</links>
	</bug>
	<bug id="1263" opendate="2015-07-30 09:03:41" fixdate="2015-11-09 19:09:44" resolution="Fixed">
		<buginformation>
			<summary>Missing indexes in associations involving generic types</summary>
			<description>When an association between documents involves generic types, the type information is not correctly inferred at startup time resulting in missing indexes.
Please, see https://github.com/agustisanchez/SpringDataMongoDBBug, for code samples.
Given:

class Book with index on "ISBN" attribute
super class AbstractProduct with index on "name" attribute
class ProductWrapper holding attribute "content" of generic type "T extends AbstractProduct"

When defining a class Catalog with a list of "wrapped" books:

List&amp;lt;ProductWrapper&amp;lt;Book&amp;gt;&amp;gt; books2 = new ArrayList&amp;lt;&amp;gt;

The index "name" inherited from AbstractProduct is created (book2.content.name) inside "catalog" , but the index defined on the Book class itself (isbn) is not created as Spring Data Mongo is only inferring type infromation from the ProductWrapper class definition (ProductWrapper &amp;lt;T extends AbstractProduct&amp;gt;).
Spring Data MongoDB should be able to infer type information from the list declaration ( List&amp;lt;ProductWrapper&amp;lt;Book&amp;gt;&amp;gt; ), becoming aware that Catalog contains a list of Books, hence indexes defined on Book should be created.
If the wrapper class is defined as ProductWrapper&amp;lt;T&amp;gt;, then no indexes are created at all on Catalog.books2.content.</description>
			<version>1.6.3 (Evans SR3)</version>
			<fixedVersion>1.8 RC1 (Gosling), 1.7.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolverUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="1297" opendate="2015-09-28 22:14:19" fixdate="2015-11-13 16:54:07" resolution="Fixed">
		<buginformation>
			<summary>Unique Index on DBRef</summary>
			<description>I&amp;amp;apos;m not able to uniquely index a property if it&amp;amp;apos;s a reference.
For example: 











@DBRef




@Indexed(unique = true) // This does not work because of @DBRef




private User user1;









@Indexed(unique = true) // This works fine




private User user1;











I know that it&amp;amp;apos;s possible to unique index a DBRef, so I&amp;amp;apos;m not sure why this doesn&amp;amp;apos;t work. It seems like a pretty important piece of functionality. </description>
			<version>1.6.3 (Evans SR3)</version>
			<fixedVersion>1.8.1 (Gosling SR1), 1.9 M1 (Hopper), 1.7.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolverUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.index.MongoPersistentEntityIndexResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="1204" opendate="2015-04-15 06:14:25" fixdate="2015-11-20 11:52:10" resolution="Fixed">
		<buginformation>
			<summary>ObjectPath equality check breaks due to changes MongoDB V3.</summary>
			<description>The equality check for ObjectPathItem item id&amp;amp;apos;s in ObjectPath seems to break when used with MongoDB V3 due to contract changes of MongoDB&amp;amp;apos;s ObjectID. 
From the referenced commit in the mongo-java-driver:
https://github.com/mongodb/mongo-java-driver/commit/aa4b4355c808e045ce00cc1dfbdd0bf78fb6901a
(ObjectId.)equals method will no longer compare equal to anything but an ObjectId</description>
			<version>1.7 GA (Fowler)</version>
			<fixedVersion>1.8.2 (Gosling SR2), 1.9 M1 (Hopper), 1.7.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1290" opendate="2015-09-17 15:30:23" fixdate="2015-11-20 12:25:32" resolution="Fixed">
		<buginformation>
			<summary>@Query annotation with byte[] parameter does not work</summary>
			<description>In a repository, these finders should be equivalent:






Optional&amp;lt;SampleDomainObject&amp;gt; findBySampleData(byte[] sampleDate);









@Query("{ &amp;amp;apos;sampleData&amp;amp;apos; : ?0 }")




Optional&amp;lt;SampleDomainObject&amp;gt; findBySampleDateWithAnnotation(byte[] sampleData);






... but only the first works. Please find an example project with test attached!</description>
			<version>1.6.3 (Evans SR3)</version>
			<fixedVersion>1.8.2 (Gosling SR2), 1.9 M1 (Hopper), 1.7.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.ExpressionEvaluatingParameterBinder.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQuery.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQueryUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1335" opendate="2015-11-24 16:20:40" fixdate="2015-11-25 15:20:56" resolution="Fixed">
		<buginformation>
			<summary>DBObjectAccessor doesn&amp;apos;t write properties correctly if multiple ones are nested</summary>
			<description>When DBObjectAccessor is building the BasicDBObject it could check if the current dbObject already holds a BasicDBObject for the given key
And thus documents like the one below will be inserted correctly (now only "id" and "desc"  are inserted)






    public class One {




      @Id String id;




      @Field("DATA.TITLE") String title;




      @Field("DATA.DESC") String desc;




     ....




    }






I have provided a sample projecte with a few tests in order to verify the behaviour before and after the proposed change.
I am aware that field names cannot contain the dot (.) character (https://docs.mongodb.org/manual/core/document/#field-names), and that data structures like the one before should be mapped with a Map BUT now the read process can cope with this kind of data structures so I am wondering if we can improve the write process to cover this case.  JUST AN IDEA</description>
			<version>1.7.2 (Fowler SR2)</version>
			<fixedVersion>1.8.2 (Gosling SR2), 1.9 M1 (Hopper), 1.7.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.DBObjectAccessor.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.DBObjectAccessorUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1190" opendate="2015-03-26 00:50:50" fixdate="2015-11-26 14:10:22" resolution="Duplicate">
		<buginformation>
			<summary>Please consider adding BulkWriteOperations, in particular unorderedBulkInsert</summary>
			<description>Please consider adding bulk write operations to mongoOperations.
E.g. initializeUnorderedBulkOperation  which allows bulk writes that do not abort on the first error, and are potentially faster (allowing reordering &amp;amp; parallelism). 
A naive start would be :
class MongoTemplate {
public BulkWriteResult  insert(List&amp;lt;Object&amp;gt; list, boolean isOrdered, String collectionName){
        DBCollection col=mongoOperations.getCollection(colName);
        BulkWriteOperation bulk=isOrdered?     
              col.initializeOrderdBulkOperation():
              col.initializeUnorderedBulkOperation();
        MongoConverter converter= mongoOperations.getConverter();
        for(String Object o:list)
{
            DBObject dbDoc=new BasicDBObject();
            maybeEmitEvent(new BeforeConvertEvent&amp;lt;T&amp;gt;(o));
            converter.write(element, dbDoc);
            maybeEmitEvent(new BeforeSaveEvent&amp;lt;T&amp;gt;(o, dbDoc));
            bulk.insert(dbDoc);                    	
        }
       ... // loop and emit "AfterSaveEvent"s
        return bulk.execute(writeConcern);
}
This is a naive start, i&amp;amp;apos;d appreciate other people&amp;amp;apos;s view on additional design considerations:
(1) Major issue - it&amp;amp;apos;s a problem to get the returned IDs and match them to the original objects!
(2) should it be generalized to other bulk operations
thanks,
Pelit</description>
			<version>1.4.2 (Codd SR2)</version>
			<fixedVersion></fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.BulkOperationException.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoExceptionTranslator.java</file>
			<file type="M">org.springframework.data.mongodb.core.DefaultBulkOperations.java</file>
			<file type="D">org.springframework.data.mongodb.util.Tuple.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoOperations.java</file>
			<file type="M">org.springframework.data.mongodb.core.DefaultBulkOperationsIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.BulkOperations.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoActionOperation.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">934</link>
			<link type="Relate" description="is related to">665</link>
		</links>
	</bug>
	<bug id="934" opendate="2014-05-14 01:45:14" fixdate="2015-11-26 17:00:21" resolution="Fixed">
		<buginformation>
			<summary>Add support for the bulk operations introduced in MongoDB 2.6.</summary>
			<description>Latest version of spring data mongodb have no support for the bulk operations introduced in MongoDB 2.6 and mongodb recommends using the new write protocols and new bulk api for bulk opertations.</description>
			<version>1.4.2 (Codd SR2)</version>
			<fixedVersion>1.9 M1 (Hopper)</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.BulkOperationException.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoExceptionTranslator.java</file>
			<file type="M">org.springframework.data.mongodb.core.DefaultBulkOperations.java</file>
			<file type="D">org.springframework.data.mongodb.util.Tuple.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoOperations.java</file>
			<file type="M">org.springframework.data.mongodb.core.DefaultBulkOperationsIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.BulkOperations.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoActionOperation.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1190</link>
		</links>
	</bug>
	<bug id="1342" opendate="2015-11-25 16:21:53" fixdate="2015-12-15 14:48:53" resolution="Fixed">
		<buginformation>
			<summary>Potential NullPointerException in MongoQueryCreator.nextAsArray()</summary>
			<description>A null value is handed to a contains-clause of a repository query method will cause a NullPointerException rather than being treated like a single element object array.</description>
			<version>1.7.2 (Fowler SR2)</version>
			<fixedVersion>1.8.2 (Gosling SR2), 1.9 M1 (Hopper), 1.7.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreator.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreatorUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1289" opendate="2015-09-17 11:43:51" fixdate="2015-12-16 10:47:48" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException when saving an object with no "id" field or @Id annotation</summary>
			<description>According to the documentation:

If no field or property specified above is present in the Java class then an implicit &amp;amp;apos;_id&amp;amp;apos; file will be generated by the driver but not mapped to a property or field of the Java class.

Instead of this, I&amp;amp;apos;m seeing a NullPointerException when attempting to save an object that doesn&amp;amp;apos;t have an "id" field or an @Id annotated field.
This was working in 1.6.0, but seems to have changed at least in 1.6.2 (did not test 1.6.1) and is still not working as I expect in newer versions</description>
			<version>1.7.1 (Fowler SR1)</version>
			<fixedVersion>1.8.2 (Gosling SR2), 1.9 M1 (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.support.MongoRepositoryFactory.java</file>
			<file type="M">org.springframework.data.mongodb.repository.support.MappingMongoEntityInformation.java</file>
			<file type="M">org.springframework.data.mongodb.core.NoExplicitIdTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1334" opendate="2015-11-23 09:36:14" fixdate="2015-12-16 11:41:04" resolution="Fixed">
		<buginformation>
			<summary>MapResultOptions limit not implemented</summary>
			<description>As I can see in the code and with the behavior I&amp;amp;apos;m currently experiencing, it seems that limit on MapReduceOptions is not working.
In the source code, there&amp;amp;apos;s no attribute set with the provided param, the limit(int limit) method only return the current instance.






public MapReduceOptions limit(int limit) {




    return this;




}





</description>
			<version>1.8.1 (Gosling SR1)</version>
			<fixedVersion>1.8.2 (Gosling SR2), 1.9 M1 (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.mapreduce.MapReduceOptions.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.core.mapreduce.MapReduceOptionsTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1360" opendate="2016-01-16 07:47:34" fixdate="2016-01-20 14:42:07" resolution="Fixed">
		<buginformation>
			<summary>Cannot query with JSR310</summary>
			<description>I have a MongoDb document I successfully store using Spring Data MongoDb. It looks like this:






{




    "_id" : "1",




    "_class" : "SomeClass",




    "createdDate" : ISODate("2016-01-16T07:05:45.656Z"),




    "lastUpdate" : ISODate("2016-01-16T07:05:45.656Z")




}






When I create a custom Criteria query that looks like this:






query.addCriteria(where("createdDate").lte(LocalDateTime.now()));






The resulting MongoDb query looks like this:






{ "createdDate" : { "$lte" : { $java : 2016-01-16T14:36:50.656 } } }






It consequently fails with this message:
java.lang.IllegalArgumentException: can&amp;amp;apos;t serialize class java.time.LocalDateTime
at org.bson.BasicBSONEncoder._putObjectField(BasicBSONEncoder.java:299)
It does not fail when I use a java.util.Date in my query even though I have stilled persisted my document with a java.time.LocalDateTime object. The query then looks slightly different like this:






{ "createdDate" : { "$lte" : { "$date" : "2016-01-16T07:35:19.985Z"}}}






I&amp;amp;apos;m hoping there is a way to not have to convert my LocalDateTime objects to Date objects for querying.
Please advise.
Cheers,
Bjorn</description>
			<version>1.8.2 (Gosling SR2)</version>
			<fixedVersion>1.9 M1 (Hopper), 1.8.4 (Gosling SR4), 1.7.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
			<file type="M">org.springframework.data.mongodb.core.geo.AbstractGeoSpatialTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.Venue.java</file>
		</fixedFiles>
	</bug>
	<bug id="1361" opendate="2016-01-17 03:38:06" fixdate="2016-01-21 11:44:28" resolution="Fixed">
		<buginformation>
			<summary>geoNear() queries fail when the accompanying query returns no results </summary>
			<description>I found that if I a run a geoNear query with an accompanying search query that doesn&amp;amp;apos;t return any results, I encounter an NPE here.






java.lang.NullPointerException




	at org.springframework.data.mongodb.core.MongoTemplate.geoNear(MongoTemplate.java:667)




	at org.springframework.data.mongodb.core.MongoTemplate.geoNear(MongoTemplate.java:618)






Example document:






{




	"id": "1",




	"available": false,




        "location": {




            "type": "Point",




            "coordinates": [




              40.758934,




              -73.992514




            ]




        }




}






if the query looks like this:






NearQuery q = NearQuery.near(point).maxDistance(new Distance(maxDistance, Metrics.KILOMETERS));




q.query(where("available").is(true));






You get the NPE. Let me know if you need more information from me.</description>
			<version>1.8.2 (Gosling SR2)</version>
			<fixedVersion>1.9 M1 (Hopper), 1.8.4 (Gosling SR4), 1.7.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="1288" opendate="2015-09-16 23:51:16" fixdate="2016-02-11 13:09:46" resolution="Fixed">
		<buginformation>
			<summary>Update.inc(String, Number) method fails to work with AtomicInteger</summary>
			<description>Even though the org.springframework.data.mongodb.core.query.Update.inc(String, Number) method takes the parameter as Number, it doesn&amp;amp;apos;t actually work right with things that aren&amp;amp;apos;t simple primitive object wrappers.  For example, if you pass in an AtomicInteger, the update fails to execute, as the generated json isn&amp;amp;apos;t correct.</description>
			<version>1.7.2 (Fowler SR2)</version>
			<fixedVersion>1.9 M1 (Hopper)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.NumberToNumberConverterFactoryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.CustomConversions.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MongoConverters.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapperUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">1302</link>
			<link type="Relate" description="is related to">13938</link>
		</links>
	</bug>
	<bug id="1397" opendate="2016-03-13 16:19:33" fixdate="2016-03-16 16:56:43" resolution="Fixed">
		<buginformation>
			<summary>MongoTemplate.geoNear() do not log the Query</summary>
			<description>MongoTemplate.geoNear() do not log the queries using class LOGGER instance...</description>
			<version>1.8.4 (Gosling SR4)</version>
			<fixedVersion>1.9 RC1 (Hopper), 1.8.4 (Gosling SR4), 1.7.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="1387" opendate="2016-02-24 18:36:58" fixdate="2016-03-18 18:39:20" resolution="Fixed">
		<buginformation>
			<summary>BasicQuery.fields().include() doesn&amp;apos;t stick, even though Query.fields().include() does</summary>
			<description>I am attempting to use BasicQuery with a defined list of fields. It appears that the fields list is being ignored. 






String queryString = ... // json-formatted string




Query query = new BasicQuery(queryString);




query.fields().include("myField");




final List&amp;lt;MyObject&amp;gt; results = mongoOps.find(query, MyObject.class);




// MyObject includes all fields, not just myField






I was digging through the source and it looks like org.springframework.data.mongodb.core.query.Query and org.springframework.data.mongodb.core.query.BasicQuery do things a little differently. Query defines fields() and BasicQuery does not, but getFieldsObject is different in the two implementations. 






Query.getFieldsObject






	public DBObject getFieldsObject() {




		return this.fieldSpec == null ? null : fieldSpec.getFieldsObject();




	}












BasicQuery.getFieldsObject






	public DBObject getFieldsObject() {




		return fieldsObject;




	}






It looks like when I use BasicQuery.fields() it does successfully create a fieldspec in the object. But later, when I pass that BasicQuery object into MongoOps, it calls query.getFieldsObject() and it&amp;amp;apos;s null, because I never set an explicit fieldsObject. 
Am I using BasicQuery incorrectly? I am not clear why BasicQuery needs to override getFieldsObject as the behavior in the parent class seems to be the one that you&amp;amp;apos;d want.
Thanks!</description>
			<version>1.8.2 (Gosling SR2)</version>
			<fixedVersion>1.9 RC1 (Hopper), 1.8.4 (Gosling SR4), 1.7.3 (Fowler SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.query.BasicQuery.java</file>
			<file type="M">org.springframework.data.mongodb.core.query.BasicQueryUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1401" opendate="2016-03-22 11:33:58" fixdate="2016-03-31 07:39:58" resolution="Fixed">
		<buginformation>
			<summary>GeoJsonPoint error on update</summary>
			<description>If i try to do an update on Entity with a GeoJsonPoint properties i get the following:






org.springframework.data.mapping.context.InvalidPersistentPropertyPath: No property type found on org.springframework.data.mongodb.core.geo.GeoJsonPoint!









	at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentPropertyPath(AbstractMappingContext.java:256)




	at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentPropertyPath(AbstractMappingContext.java:229)




	at org.springframework.data.mapping.context.AbstractMappingContext.getPersistentPropertyPath(AbstractMappingContext.java:204)




	at org.springframework.data.mongodb.core.convert.QueryMapper$MetadataBackedField.getPath(QueryMapper.java:838)




	at org.springframework.data.mongodb.core.convert.QueryMapper$MetadataBackedField.&amp;lt;init&amp;gt;(QueryMapper.java:729)




	at org.springframework.data.mongodb.core.convert.QueryMapper$MetadataBackedField.&amp;lt;init&amp;gt;(QueryMapper.java:706)




	at org.springframework.data.mongodb.core.convert.UpdateMapper$MetadataBackedUpdateField.&amp;lt;init&amp;gt;(UpdateMapper.java:193)




	at org.springframework.data.mongodb.core.convert.UpdateMapper.createPropertyField(UpdateMapper.java:164)




	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedObject(QueryMapper.java:122)




	at org.springframework.data.mongodb.core.convert.QueryMapper.convertSimpleOrDBObject(QueryMapper.java:359)




	at org.springframework.data.mongodb.core.convert.UpdateMapper.getMappedObjectForField(UpdateMapper.java:77)




	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedObject(QueryMapper.java:123)




	at org.springframework.data.mongodb.core.convert.QueryMapper.convertSimpleOrDBObject(QueryMapper.java:359)




	at org.springframework.data.mongodb.core.convert.UpdateMapper.getMappedObjectForField(UpdateMapper.java:77)




	at org.springframework.data.mongodb.core.convert.QueryMapper.getMappedObject(QueryMapper.java:123)




	at org.springframework.data.mongodb.core.MongoTemplate$12.doInCollection(MongoTemplate.java:1108)




	at org.springframework.data.mongodb.core.MongoTemplate$12.doInCollection(MongoTemplate.java:1099)




	at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:462)




	at org.springframework.data.mongodb.core.MongoTemplate.doUpdate(MongoTemplate.java:1099)




	at org.springframework.data.mongodb.core.MongoTemplate.doSaveVersioned(MongoTemplate.java:973)




	at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:937)




	at org.springframework.data.mongodb.core.MongoTemplate.save(MongoTemplate.java:921)






</description>
			<version>1.8 GA (Gosling)</version>
			<fixedVersion>1.9 GA (Hopper), 1.8.5 (Gosling SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1350</link>
		</links>
	</bug>
	<bug id="1425" opendate="2016-04-26 13:04:25" fixdate="2016-05-09 11:31:21" resolution="Fixed">
		<buginformation>
			<summary>NOT_CONTAINS keyword issues CONTAINS query.</summary>
			<description></description>
			<version>1.6.4 (Evans SR4)</version>
			<fixedVersion>1.9.2 (Hopper SR2), 1.10 M1 (Ingalls), 1.8.5 (Gosling SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.AbstractPersonRepositoryIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.PersonRepository.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreator.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreatorUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1436" opendate="2016-05-24 02:53:21" fixdate="2016-05-24 12:06:13" resolution="Duplicate">
		<buginformation>
			<summary>CustomConversions complains about built-in converters</summary>
			<description>When registering any custom converters for MongoDB, the CustomConversions constructor adds a whole slew of hard-coded converters to the list. These include NumberToNumberConverterFactory, which apparently converts java.lang.Number-&amp;gt;java.lang.Number and causes warnings to be logged.</description>
			<version>1.9.1 (Hopper SR1)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MongoConvertersUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MongoConverters.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1416</link>
		</links>
	</bug>
	<bug id="1416" opendate="2016-04-10 15:43:11" fixdate="2016-05-24 16:25:27" resolution="Fixed">
		<buginformation>
			<summary>Standard bootstrap issues warning in converter registration</summary>
			<description>I just upgraded to 1.9.1 from 1.8.4 and keep getting these warnings. 






org.springframework.data.mongodb.core.convert.CustomConversions:229 - Registering converter from class java.lang.Number to class java.lang.Number as writing converter although it doesn&amp;amp;apos;t convert to a Mongo supported type! You might wanna check you annotation setup at the converter implementation






 I have NO custom converters configured.  Not sure where this is coming from or how to fix.</description>
			<version>1.9.1 (Hopper SR1)</version>
			<fixedVersion>1.9.2 (Hopper SR2), 1.10 M1 (Ingalls)</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MongoConvertersUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MongoConverters.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1436</link>
			<link type="Duplicate" description="is duplicated by">1438</link>
		</links>
	</bug>
	<bug id="1423" opendate="2016-04-20 11:55:44" fixdate="2016-05-25 15:38:40" resolution="Fixed">
		<buginformation>
			<summary>Nested document update doesn&amp;apos;t apply converters on embedded maps</summary>
			<description>When trying to perform a direct update a nested document which is a map by






 $set : {&amp;amp;apos;metadata.thumbnails&amp;amp;apos; : Map&amp;lt;Enum, String&amp;gt;}






the the map keys are not converted
Meanwhile, updating the core level object works properly 






$set : {a: metadata}






For example: 
Entity class






public class Video {




    ....




    private VideoMetadata metadata;




    ....




}






Nested object






public class VideoMetadata {




    ....




 	private Map&amp;lt;ThumbnailType, String&amp;gt; thumbnails;




    ....




}






Enum






public enum ThumbnailType {




	DEFAULT,  MEDIUM, HIGH, STANDARD, MAXRES




}






Invoked Dao method to update thumbnails






Query query = Query.query(Criteria.where("_id").is(id);




Update update = new Update()




	.set("metadata.thumbnails", metadata.getThumbnails());




	.set("metadata2", metadata);




}




mongoOps.updateFirst(query, update, Video.class);






Just after performing the update my objects looks like 






{ 




    "_id" : ... ,




    "_class" :  ... ,




    ......




    "metadata" : {




        "thumbnails" : {




            "MEDIUM" : "a", 




            "DEFAULT" : "b", 




            "STANDARD" : "c"




        }, 




    "metadata2" : {




        "thumbnails" : {




            "medium" : "a", 




            "default" : "b", 




            "standard" : "c"




        }




    }




}






The only workaround I can find is to call converter manually : 






	DBObject dbObject = new BasicDBObject();




	mongoOps.getConverter().write(metadata.getThumbnails(), dbObject);




	dbObject.removeField("_class");




	update.set("metadata.thumbnails", dbObject);






</description>
			<version>1.8.4 (Gosling SR4)</version>
			<fixedVersion>1.9.2 (Hopper SR2), 1.10 M1 (Ingalls), 1.8.5 (Gosling SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapperUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">1486</link>
		</links>
	</bug>
	<bug id="1438" opendate="2016-05-26 14:01:14" fixdate="2016-05-26 14:03:47" resolution="Duplicate">
		<buginformation>
			<summary>I get a warning in my logs since switched to Spring Data MongoDB Hopper-SR1 Release Train in Spring Boot 1.3.5</summary>
			<description>When I start my Spring Boot 1.3.5 application with no custom conversions and with Spring Data MongoDB Release Train Hopper-SR1 I get following warning in my logs:






Registering converter from class java.lang.Number to class java.lang.Number as writing converter although it doesn&amp;amp;apos;t convert to a Mongo supported type! You might wanna check you annotation setup at the converter implementation.






With the in Spring Boot 1.3.5 integrated version the warning is not exists..
I have alle my Domain classes they are saved in MongoDB annotated with @Document (see DATAMONGO-1413)</description>
			<version>1.9.1 (Hopper SR1)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MongoConvertersUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MongoConverters.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1416</link>
		</links>
	</bug>
	<bug id="1437" opendate="2016-05-24 09:54:42" fixdate="2016-06-02 07:27:07" resolution="Fixed">
		<buginformation>
			<summary>DefaultDbRefResolver swallows cause of non DataAccessException translatable Exception.</summary>
			<description></description>
			<version>1.6.4 (Evans SR4)</version>
			<fixedVersion>1.9.2 (Hopper SR2), 1.10 M1 (Ingalls), 1.8.5 (Gosling SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.data.mongodb.core.convert.LazyLoadingInterceptorUntiTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.DefaultDbRefResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="1453" opendate="2016-06-23 08:19:28" fixdate="2016-06-24 12:25:10" resolution="Complete">
		<buginformation>
			<summary>Parse error into GeoJsonPoint if coordinates are "integers"</summary>
			<description>When mapping a document containing a GeoJSON location into a GeoJsonPoint object, if the location coordinates are "round" numbers (e.g. [0,0]) I get a ClassCastException: 






Failed to convert from type \[com.mongodb.BasicDBObject\] to type \[org.springframework.data.mongodb.core.geo.GeoJsonPoint\] for value &amp;amp;apos;\{ "type" : "Point" , "coordinates" : [ 0 , 0]\}&amp;amp;apos;; nested exception is java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.Double





</description>
			<version>1.8.4 (Gosling SR4)</version>
			<fixedVersion>1.10 M1 (Ingalls), 1.8.5 (Gosling SR5), 1.9.3 (Hopper SR3)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.geo.GeoJsonTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.GeoConverters.java</file>
		</fixedFiles>
	</bug>
	<bug id="1394" opendate="2016-03-09 10:36:46" fixdate="2016-07-27 09:01:01" resolution="Fixed">
		<buginformation>
			<summary>References not handled correctly when using QueryDSL</summary>
			<description>Trying to use eq on reference&amp;amp;apos;s $id, with no luck. 
This is an example code:






Book.java






public class Book {




     @DBRef




     private Library library;




} 












Library.java






public class Library {




     @Id




     private String id;




}












BookService.java






String library_id = [SOME_ID];




QBook book = QBook.book;




BooleanExpression exp = book.library.id.eq(library_id);




    




List&amp;lt;Book&amp;gt; list = bookRepository.findAll(exp);  // EMPTY






Doing:






BookService.java






Library library = libraryRepository.findById(library_id);




QBook book = QBook.book;




BooleanExpression exp = book.library.eq(library);









List&amp;lt;Book&amp;gt; list = bookRepository.findAll(exp);  // EXPECTED ITEMS






or:






BookService.java






List&amp;lt;Book&amp;gt; list = bookRepository.findByLibraryId(library_id) // EXPECTED ITEMS





</description>
			<version>1.8.1 (Gosling SR1)</version>
			<fixedVersion>1.10 M1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializer.java</file>
			<file type="M">org.springframework.data.mongodb.repository.support.QuerydslRepositorySupportTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1471" opendate="2016-08-01 05:04:37" fixdate="2016-08-17 14:59:43" resolution="Fixed">
		<buginformation>
			<summary>MappingMongoConverter attempts to set null value on potentially primitive identifier</summary>
			<description>An exception occurs when there is no _id in the query result(the id attribute is a primitive type, such as long). This also happens on _id of embedded object.






Exception in thread "main" java.lang.IllegalArgumentException: Can not set long field Employee.id to null value




	at sun.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException(UnsafeFieldAccessorImpl.java:167)




	at sun.reflect.UnsafeFieldAccessorImpl.throwSetIllegalArgumentException(UnsafeFieldAccessorImpl.java:171)




	at sun.reflect.UnsafeLongFieldAccessorImpl.set(UnsafeLongFieldAccessorImpl.java:80)




	at java.lang.reflect.Field.set(Field.java:764)




	at org.springframework.util.ReflectionUtils.setField(ReflectionUtils.java:122)




	at org.springframework.data.mapping.model.BeanWrapper.setProperty(BeanWrapper.java:59)




	at org.springframework.data.mapping.model.ConvertingPropertyAccessor.setProperty(ConvertingPropertyAccessor.java:58)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:265)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.read(MappingMongoConverter.java:232)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.readValue(MappingMongoConverter.java:1196)




	at org.springframework.data.mongodb.core.convert.MappingMongoConverter.access$200(MappingMongoConverter.java:79)





</description>
			<version>1.9.2 (Hopper SR2)</version>
			<fixedVersion>1.8.5 (Gosling SR5), 1.9.3 (Hopper SR3), 1.10 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.DBObjectAccessor.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.DBObjectAccessorUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1476" opendate="2016-08-19 13:44:31" fixdate="2016-08-23 08:16:05" resolution="Fixed">
		<buginformation>
			<summary>New stream method only partially makes use of collection name</summary>
			<description>The new stream Method allowing to specify the collection name, should also make use of the collection name on read callback time. </description>
			<version>1.10 M1 (Ingalls)</version>
			<fixedVersion>1.10 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="1465" opendate="2016-07-22 14:43:27" fixdate="2016-08-23 13:02:32" resolution="Fixed">
		<buginformation>
			<summary>String arguments passed to DefaultScriptOperations.execute() appear quoted in script</summary>
			<description>DefaultScriptOperations.execute() calls convertScriptArgs() to convert the script&amp;amp;apos;s arguments. For Strings it performs a local single-quoting.
This is necessary for DefaultScriptOperations.call() arguments (as the function call is constructed as a string) but not for execute() (as the arguments will be transfered in a DBObject.</description>
			<version>1.9.2 (Hopper SR2)</version>
			<fixedVersion>1.8.5 (Gosling SR5), 1.9.3 (Hopper SR3), 1.10 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.DefaultScriptOperations.java</file>
			<file type="M">org.springframework.data.mongodb.core.DefaultScriptOperationsTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1406" opendate="2016-04-04 18:59:49" fixdate="2016-08-25 11:50:06" resolution="Fixed">
		<buginformation>
			<summary>Query mapper does not use @Field field name when querying nested fields in combination with nested keywords</summary>
			<description>we have a document class;






@Document(collection = "Computer")




public class Computer




{




   @Id




   private String _id;









   private String batchId;









  @Field("stat")




   private String status;









   @Field("disp")




   private List&amp;lt;Monitor&amp;gt; displays;









   //setters and getters




}









public class Monitor {




   @Field("res")




   private String resolution;









  // setters/getters




}






In MongoTemplate.java, the call to :






protected &amp;lt;S, T&amp;gt; List&amp;lt;T&amp;gt; doFind(String collectionName, DBObject query, DBObject fields, Class&amp;lt;S&amp;gt; entityClass,




			CursorPreparer preparer, DbObjectCallback&amp;lt;T&amp;gt; objectCallback)









DBObject mappedQuery = queryMapper.getMappedObject(query, entity);






resolves the fields to the input query to the ones in the @Field annotations, except for these in embedded arrays. So, in the example above, resolution fields in DBObject remains resolution. While, the status field resolves to stat. 
Note the queries in the inner list, are setup as elemMatch.
The query submitted to mongo after getMappedObject is called:






{ "$and" : [ { "stat" : "A"} , { "disp" : { "$elemMatch" : { "$and" : [ { "resolution" : { "$ne" :  null }} , { "resolution" : { "$ne" : ""}}]}}}] , "batchId" : "5d0f1c53-92a2-48cb-8c84-1061769962c1"}






Which doesn&amp;amp;apos;t get any data, because there is no field called resolution (the field in mongo is res). 
Note: The query input to getMappedObject is:






{ "$and" : [ { "status" : "A"} , { "displays" : { "$elemMatch" : { "$and" : [ { "resolution" : { "$ne" :  null }} , { "resolution" : { "$ne" : ""}}]}}}] , "batchId" : "5d0f1c53-92a2-48cb-8c84-1061769962c1"}






Notice the status and displays fields correctly get converted to the value in the @Field annotation. 
The correct query from getMappedObject should be:






{ "$and" : [ { "stat" : "A"} , { "disp" : { "$elemMatch" : { "$and" : [ { "res" : { "$ne" :  null }} , { "res" : { "$ne" : ""}}]}}}] , "batchId" : "5d0f1c53-92a2-48cb-8c84-1061769962c1"}






This basically means that any queries that operate on fields (with a name different from the peristed name) in the inner list will fail. 
</description>
			<version>1.7.2 (Fowler SR2)</version>
			<fixedVersion>1.8.5 (Gosling SR5), 1.9.3 (Hopper SR3), 1.10 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapper.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.QueryMapperUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1486" opendate="2016-09-07 16:46:53" fixdate="2016-09-08 08:31:45" resolution="Fixed">
		<buginformation>
			<summary>Changes to MappingMongoConverter Result in Class Cast Exception</summary>
			<description>I am upgrading our software to use Spring Boot 1.4 + Spring 4.3. As part of this upgrade, we are also using Spring Data Mongo 1.9.2.RELEASE. I am assuming that is 1.9.2 (Hopper SR2)?
We have a situation where we have a model object that looks like the following: 






Map&amp;lt;Integer, Map&amp;lt;Platform, String&amp;gt;&amp;gt; descriptions = new HashMap&amp;lt;&amp;gt;();






Where "Platform is Enum", although this is not the core issue. When we execute the following: 






	public void setAlternateDescriptionMap(int compositeId, Map&amp;lt;Integer, Map&amp;lt;Platform, String&amp;gt;&amp;gt; alternateDescriptionsMap) {




		Query query = new Query();




		query.addCriteria(Criteria.where("_id").is(compositeId));




		Update update = new Update();




		update.set("alternateDescriptionMap", alternateDescriptionsMap);









		coreMongoTemplate.updateFirst(query, update, "product");




	}






We end up getting the following exception: 






java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String




	at com.mongodb.DBObjectCodec.encodeMap(DBObjectCodec.java:222)




	at com.mongodb.DBObjectCodec.writeValue(DBObjectCodec.java:199)




	at com.mongodb.DBObjectCodec.encodeMap(DBObjectCodec.java:223)




	at com.mongodb.DBObjectCodec.writeValue(DBObjectCodec.java:199)




	at com.mongodb.DBObjectCodec.encode(DBObjectCodec.java:131)




	at com.mongodb.DBObjectCodec.encode(DBObjectCodec.java:62)




	at org.bson.codecs.BsonDocumentWrapperCodec.encode(BsonDocumentWrapperCodec.java:63)




	at org.bson.codecs.BsonDocumentWrapperCodec.encode(BsonDocumentWrapperCodec.java:29)




	at com.mongodb.connection.RequestMessage.addDocument(RequestMessage.java:253)




	at com.mongodb.connection.RequestMessage.addDocument(RequestMessage.java:205)




	at com.mongodb.connection.UpdateMessage.encodeMessageBodyWithMetadata(UpdateMessage.java:80)




	at com.mongodb.connection.RequestMessage.encodeWithMetadata(RequestMessage.java:160)




	at com.mongodb.connection.WriteProtocol.execute(WriteProtocol.java:89)




	at com.mongodb.connection.UpdateProtocol.execute(UpdateProtocol.java:67)




	at com.mongodb.connection.UpdateProtocol.execute(UpdateProtocol.java:42)




	at com.mongodb.connection.DefaultServer$DefaultServerProtocolExecutor.execute(DefaultServer.java:168)




	at com.mongodb.connection.DefaultServerConnection.executeProtocol(DefaultServerConnection.java:289)




	at com.mongodb.connection.DefaultServerConnection.update(DefaultServerConnection.java:88)




	at com.mongodb.operation.UpdateOperation.executeProtocol(UpdateOperation.java:66)




	at com.mongodb.operation.BaseWriteOperation$1.call(BaseWriteOperation.java:144)




	at com.mongodb.operation.BaseWriteOperation$1.call(BaseWriteOperation.java:134)




	at com.mongodb.operation.OperationHelper.withConnectionSource(OperationHelper.java:232)




	at com.mongodb.operation.OperationHelper.withConnection(OperationHelper.java:223)




	at com.mongodb.operation.BaseWriteOperation.execute(BaseWriteOperation.java:134)




	at com.mongodb.operation.BaseWriteOperation.execute(BaseWriteOperation.java:61)




	at com.mongodb.Mongo.execute(Mongo.java:827)




	at com.mongodb.Mongo$2.execute(Mongo.java:810)




	at com.mongodb.DBCollection.executeWriteOperation(DBCollection.java:333)




	at com.mongodb.DBCollection.updateImpl(DBCollection.java:495)




	at com.mongodb.DBCollection.update(DBCollection.java:455)




	at com.mongodb.DBCollection.update(DBCollection.java:432)




	at org.springframework.data.mongodb.core.MongoTemplate$12.doInCollection(MongoTemplate.java:1153)




	at org.springframework.data.mongodb.core.MongoTemplate$12.doInCollection(MongoTemplate.java:1132)




	at org.springframework.data.mongodb.core.MongoTemplate.execute(MongoTemplate.java:462)




	at org.springframework.data.mongodb.core.MongoTemplate.doUpdate(MongoTemplate.java:1132)




	at org.springframework.data.mongodb.core.MongoTemplate.updateFirst(MongoTemplate.java:1110)




	at com.build.dao.product.ProductStorageDaoImpl.setAlternateDescriptionMap(ProductStorageDaoImpl.java:1170)




	at com.build.dao.product.ProductStorageDaoImpl$$FastClassBySpringCGLIB$$4e03147e.invoke(&amp;lt;generated&amp;gt;)




	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)




	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:720)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)




	at org.springframework.dao.support.PersistenceExceptionTranslationInterceptor.invoke(PersistenceExceptionTranslationInterceptor.java:136)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:655)




	at com.build.dao.product.ProductStorageDaoImpl$$EnhancerBySpringCGLIB$$8602f8b4.setAlternateDescriptionMap(&amp;lt;generated&amp;gt;)




	at com.build.dao.product.ProductStorageDaoIT.testSaveAlternateDescriptionsToCacheAndFetch(ProductStorageDaoIT.java:335)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:497)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)




	at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75)




	at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86)




	at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84)




	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:252)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:94)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)




	at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61)




	at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)




	at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:191)




	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)




	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)











We do not get this exception in spring-data-mongodb-1.9.1-RELEASE.
After a lot of debugging, It appears to be related to the code in MappingMongoConverter.convertMongoType(). It looks like the Issue DATAMONGO-1423 may have introduced this issue: 
https://github.com/spring-projects/spring-data-mongodb/commit/0e60630393980cf2bb4634c8a9c1a5a50407c471
I am going to work on just overriding this default method with a custom mapper. I suspect this code will also break in other cases where the key is mapped into anything other than a string. 
Let me know if you need any further input.
</description>
			<version>1.9.2 (Hopper SR2)</version>
			<fixedVersion>1.9.3 (Hopper SR3), 1.10 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.UpdateMapperUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">1423</link>
		</links>
	</bug>
	<bug id="1485" opendate="2016-09-07 08:59:33" fixdate="2016-09-19 05:03:18" resolution="Fixed">
		<buginformation>
			<summary>Querydsl MongodbSerializer does not take registered converters for Enums into account</summary>
			<description>MongodbSerializer#visit(Constant&amp;lt;?&amp;gt; expr, Void context)
should check for custom conversions availability to enable typesafe querydsl expressions containing enums. Currently it performs the following:






if (Enum.class.isAssignableFrom(expr.getType())) {




            @SuppressWarnings("unchecked") //Guarded by previous check




            Constant&amp;lt;? extends Enum&amp;lt;?&amp;gt;&amp;gt; expectedExpr = (Constant&amp;lt;? extends Enum&amp;lt;?&amp;gt;&amp;gt;) expr;




            return expectedExpr.getConstant().name();




        } else {




            return expr.getConstant();




        }






Assuming the following model:






class Connection {




  private String id;




  private ConnectionType type;




}









enum ConnectionType {




        A(0),




	B(1),




	C(2);









	private final int value;









        ConnectionType(int value){




		this.value = value;




	}




}






and registered conversions: 






@ReadingConverter




@Component




public class ConnectionTypeReadConverter implements Converter&amp;lt;Integer, ConnectionType&amp;gt; {




    @Override




    public ConnectionType convert(Integer source) {




        return source == null ? null : ConnectionType.getConnectionType((Integer)source);




    }




}









@WritingConverter




@Component




public class ConnectionTypeWriteConverter implements Converter&amp;lt;ConnectionType, Integer&amp;gt; {




    @Override




    public Integer convert(ConnectionType source) {




        return source == null ? null : source.getValue();




    }




}






then the following query generates the enum name (A) instead of value(0) as condition:






ConnectionType type = ConnectionType.A;




QConnection qConnection = QConnection.connection;




Predicate predicate = qConnection.type.eq(type);









connectionRepository.findOne(predicate);}}





</description>
			<version>1.8.4 (Gosling SR4)</version>
			<fixedVersion>1.8.5 (Gosling SR5), 1.9.3 (Hopper SR3), 1.10 RC1 (Ingalls)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializer.java</file>
			<file type="M">org.springframework.data.mongodb.repository.support.SpringDataMongodbSerializerUnitTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="1497" opendate="2016-09-22 08:53:43" fixdate="2016-09-22 16:10:20" resolution="Fixed">
		<buginformation>
			<summary>MappingMongoConverter&amp;apos;s check for whether a value is available for a property should use DbObjectAccessor</summary>
			<description>MappingMongoConverter&amp;amp;apos;s read method when dealing with remaining properties and associations not already set in the constructor should use a DBObjectAccessor instead of accessing the DBObject directly.
</description>
			<version>1.8.5 (Gosling SR5)</version>
			<fixedVersion>1.7.3 (Fowler SR3), 1.9.4 (Hopper SR4), 1.8.6 (Gosling SR6)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverterUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.convert.MappingMongoConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1498" opendate="2016-09-25 22:21:26" fixdate="2016-09-28 14:34:11" resolution="Fixed">
		<buginformation>
			<summary>MongoMappingContext doesn&amp;apos;t know about types usually auto-detected (JodaTime, JDK 8 date time types)</summary>
			<description>(not sure if this issue should be opened for Spring Data REST or Spring Data Mongo, since the problem manifests itself in the contents rendered by SDR but the fix might probably go to the SD MongoDB)
As described in this SO thread, in Spring Boot 1.3.6, Spring Data 1.8.4, Spring Data REST 2.4.4 the Spring Data MongoDB entities that have a property of Joda DateTime type:






    @JsonProperty("myDate")




    private DateTime myDate;






gets rendered into in the REST representation of my Spring Data entity as 






    "myDate": "2016-09-25T15:58:37.486Z"






With Spring Boot 1.4.1, Spring Data MongoDB 1.9.3, Spring Data REST 2.5.3 same properties suddenly get represented as  






    "myDate": {




        "content": "2016-09-25T15:58:37.486Z"




    },






It looks like Joda&amp;amp;apos;s DateTime started to get treated as data entity again:
https://jira.spring.io/browse/DATAMONGO-624
Adding Jackson2 @JsonUnwrapped annotation to the property helps to get representation back:






    @JsonProperty("myDate")




    @JsonUnwrapped




    private DateTime myDate;






But this cannot be a solution since in case of auto-generated properties, e.g. from JSON schema. there is only limited options to control generated annotations, especially since the @JsonUnwrapped must be set on all child/empbedded objects.
The Javadoc for the CustomConversions class states that 

These types will be considered simple ones (which means they neither
need deeper inspection nor nested conversion. Thus the
CustomConversions also act as factory for SimpleTypeHolder
Which is in fact not true for Spring Data REST [any more], from what I can tell debugging my code.
The types that are added via default CustomConversions are not treated as simple ones when rendering JSON and properties of those types get serialised as embedded entity objects.
Here is the place in the Spring Data REST PersistentEntityJackson2Module that calls to Spring Data MongoDB PersistentEntity implementation to check whether the property type is simple or not. And since the simpleTypeHolder in the Spring Data Commons AbstractMappingContext does not contain the types for which Spring Boot auto-configuration adds Joda DateTime converters, the DateTime field is treated as complex object.
This one presents a major problem upgrading from Spring Boot 1.3 to 1.4, since it breaks REST APIs by default with no generic solution known so far for all Joda DateTime properties in the project.</description>
			<version>1.9.3 (Hopper SR3)</version>
			<fixedVersion>1.10 RC1 (Ingalls), 1.9.4 (Hopper SR4)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.config.MongoAuditingRegistrar.java</file>
			<file type="M">org.springframework.data.mongodb.config.AuditingViaJavaConfigRepositoriesTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.config.MongoRepositoryConfigurationExtension.java</file>
		</fixedFiles>
	</bug>
	<bug id="1368" opendate="2016-01-29 22:58:48" fixdate="2016-11-02 18:25:24" resolution="Works as Designed">
		<buginformation>
			<summary>findByIgnoreCase Not Escaping Parenthesis</summary>
			<description>This was tested on 1.7.0.RELEASE.
I have a method in the interface like:
Object findOneByIdAndNameIgnoreCase(String id, String name);
I call the function like this:
dao.findOneByIdAndNameIgnoreCase("uid", "Engineer (TX)");
This causes the following query to be generated (as seen in the debug log):
(MongoTemplate.java:2066) - findOne using query: { "id" : "uid" , "name" : { "$regex" : "^Engineer (TX)$" , "$options" : "i"}} in db.collection
Which fails to find the record having:
{
"id" : "uid",
"name" : "Engineer (TX)"
}

Because the regex sees the parenthesis as part of the regex (as a group matcher) when it should see them as part of the plaintext.  i.e. they are not being escaped.
</description>
			<version>1.7.2 (Fowler SR2)</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreator.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.MongoQueryCreatorUnitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1232</link>
		</links>
	</bug>
	<bug id="1513" opendate="2016-10-25 09:44:29" fixdate="2016-11-03 08:16:02" resolution="Fixed">
		<buginformation>
			<summary>Non-ObjectId identifiers generated by event listeners are not populated if documents are inserted as batch</summary>
			<description>We have observed issues when persisting multiple entities at a time. The id does not get populated. It&amp;amp;apos;s caused by insertDBObjectList() handling ids different compared to insertDBObject(). In our use case we define our own ids when persisting to Mongo. They are Strings. We use a MongoEventListener to set the id like this:






public void onBeforeSave(BaseEntity p, DBObject dbo) {




        if (p.isNew()) {




            String id = ....;




            dbo.put("_id", id);




        }




    }






This works fine when we persist only one instance at a time because the insertDBObject() does not care about the type of the id, but insertDBObjectList() does. It goes like this:






if (id instanceof ObjectId) {




    ids.add((ObjectId) id);




} else {




    // no id was generated




    ids.add(null);




}






Result is that we do no get the id populated in the entities we persist.</description>
			<version>1.8.6 (Gosling SR6)</version>
			<fixedVersion>1.10 RC1 (Ingalls), 1.8.7 (Gosling SR7), 1.9.5 (Hopper SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplateTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.MongoTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">1519</link>
		</links>
	</bug>
	<bug id="1500" opendate="2016-09-28 17:50:06" fixdate="2016-11-03 08:37:57" resolution="Fixed">
		<buginformation>
			<summary>RuntimeException for query methods with fields declaration and Pageable parameters</summary>
			<description>When I upgrade from version 1.8.4.RELEASE to 1.9.3.RELEASE, I have some problems with serialization of DBRef and Enum






@Query(fields = "{ &amp;amp;apos;text&amp;amp;apos; : 0, &amp;amp;apos;statistics&amp;amp;apos; : 0}")




Page&amp;lt;DocumentManualRevision&amp;gt; findByRevisor(User revisor, Pageable p);






the execution of the previous function (where revisor is a dbref of other collection) return the following exception






java.lang.RuntimeException: json can&amp;amp;apos;t serialize type : class database.models.security.User




	at com.mongodb.util.ClassMapBasedObjectSerializer.serialize(ClassMapBasedObjectSerializer.java:79)




	at com.mongodb.util.JSONSerializers$MapSerializer.serialize(JSONSerializers.java:323)




	at com.mongodb.util.ClassMapBasedObjectSerializer.serialize(ClassMapBasedObjectSerializer.java:82)




	at com.mongodb.util.JSON.serialize(JSON.java:53)




	at com.mongodb.util.JSON.serialize(JSON.java:39)




	at com.mongodb.BasicDBObject.toString(BasicDBObject.java:196)




	at org.springframework.data.mongodb.repository.query.PartTreeMongoQuery.createQuery(PartTreeMongoQuery.java:113)




	at org.springframework.data.mongodb.repository.query.AbstractMongoQuery.execute(AbstractMongoQuery.java:81)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:482)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.invoke(RepositoryFactorySupport.java:460)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:61)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)




	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:213)




	at com.sun.proxy.$Proxy56.findByRevisorAndCreatedBetween(Unknown Source)












@Query(fields = "{ &amp;amp;apos;text&amp;amp;apos; : 0, &amp;amp;apos;statistics&amp;amp;apos; : 0}")




Page&amp;lt;DocumentManualRevision&amp;gt; findByState(State state, Pageable p)






the execution of the previous function (where state is enum) return the following exception






java.lang.RuntimeException: json can&amp;amp;apos;t serialize type : class database.models.revision.DocumentManualRevision$State









	at com.mongodb.util.ClassMapBasedObjectSerializer.serialize(ClassMapBasedObjectSerializer.java:79)




	at com.mongodb.util.JSONSerializers$MapSerializer.serialize(JSONSerializers.java:323)




	at com.mongodb.util.ClassMapBasedObjectSerializer.serialize(ClassMapBasedObjectSerializer.java:82)




	at com.mongodb.util.JSON.serialize(JSON.java:53)




	at com.mongodb.util.JSON.serialize(JSON.java:39)




	at com.mongodb.BasicDBObject.toString(BasicDBObject.java:196)




	at org.springframework.data.mongodb.repository.query.PartTreeMongoQuery.createQuery(PartTreeMongoQuery.java:113)




	at org.springframework.data.mongodb.repository.query.AbstractMongoQuery.execute(AbstractMongoQuery.java:81)




	at org.springframework.data.repository.core.support.RepositoryFactorySupport$QueryExecutorMethodInterceptor.doInvoke(RepositoryFactorySupport.java:482)





</description>
			<version>1.9.3 (Hopper SR3)</version>
			<fixedVersion>1.10 RC1 (Ingalls), 1.9.5 (Hopper SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.PartTreeMongoQueryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.PartTreeMongoQuery.java</file>
		</fixedFiles>
	</bug>
	<bug id="1521" opendate="2016-11-03 13:47:42" fixdate="2016-11-03 14:05:28" resolution="Fixed">
		<buginformation>
			<summary>Aggregation.skip(...) expects int but new SkipOperation(...) supports long</summary>
			<description>Currently the class SkipOperation takes an long as only parameter, the static factory method Aggregation.skip() takes an int. As the skip-operation seems to support long, should the static factory-method also use long?






public static SkipOperation skip(int elementsToSkip) {




		return new SkipOperation(elementsToSkip);




}









public SkipOperation(long skipCount) {




		Assert.isTrue(skipCount &amp;gt;= 0, "Skip count must not be negative!");




		this.skipCount = skipCount;




}





</description>
			<version>1.9.4 (Hopper SR4)</version>
			<fixedVersion>1.10 RC1 (Ingalls), 1.8.7 (Gosling SR7), 1.9.5 (Hopper SR5)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.aggregation.Aggregation.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.AggregationTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.aggregation.SkipOperation.java</file>
		</fixedFiles>
	</bug>
	<bug id="1534" opendate="2016-11-23 11:23:10" fixdate="2016-11-28 08:18:25" resolution="Fixed">
		<buginformation>
			<summary>Type hint is missing when using BulkOperations.insert</summary>
			<description>when inserting a list of documents






mongoTemplate.bulkOps(BulkOperations.BulkMode.UNORDERED, FOO.class, collectionName)




  .insert(foos);






the type info written in _class element is missing.
as a result, the class cannot be read back.
This make bulkOps insert method unusable.</description>
			<version>1.9.4 (Hopper SR4)</version>
			<fixedVersion>1.10 RC1 (Ingalls), 1.9.6 (Hopper SR6), 2.0 M2 (Kay)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.core.DefaultBulkOperationsIntegrationTests.java</file>
			<file type="M">org.springframework.data.mongodb.core.DefaultBulkOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="1565" opendate="2016-12-14 23:33:20" fixdate="2016-12-19 17:16:57" resolution="Fixed">
		<buginformation>
			<summary>Placeholders in manually defined queries not escaped properly</summary>
			<description>





collection.findByApplicationIdAndName("fff?1fff", "This is outside of quotations");









interface MyCollection  extends MongoRepository&amp;lt;MyObject, String&amp;gt; {




     @Query(value="{ &amp;amp;apos;applicationId&amp;amp;apos; : ?0, &amp;amp;apos;name&amp;amp;apos; :?1}");




     List&amp;lt;MyObject&amp;gt; findByApplicationIdAndName(String id, String name);




}






Resulting query:






{&amp;amp;apos;applicationId&amp;amp;apos;: "fff"This is outside of quotations"fff", &amp;amp;apos;name&amp;amp;apos;:?1}





</description>
			<version>1.9.5 (Hopper SR5)</version>
			<fixedVersion>1.10 RC1 (Ingalls), 1.9.6 (Hopper SR6), 2.0 M2 (Kay)</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.data.mongodb.repository.query.StringBasedMongoQueryUnitTests.java</file>
			<file type="M">org.springframework.data.mongodb.repository.query.ExpressionEvaluatingParameterBinder.java</file>
		</fixedFiles>
	</bug>
</bugrepository>