<?xml version = "1.0" encoding = "UTF-8" ?>
<bugrepository name="CONFIGURATION">
	<bug id="214" opendate="2006-05-26 21:35:46" fixdate="2006-06-02 02:55:45" resolution="Fixed">
		<buginformation>
			<summary>Adding an integer and getting it as a long causes an exception</summary>
			<description>Try this in a BeanShell:
bsh % p = new org.apache.commons.configuration.PropertiesConfiguration();
bsh % p.setProperty("foo", 6);
bsh % p.getLong("foo");
// Error: // Uncaught Exception: Method Invocation p.getLong : at Line: 3 : in file: &amp;lt;unknown file&amp;gt; : p .getLong ( "foo" )
Target exception: org.apache.commons.configuration.ConversionException: &amp;amp;apos;foo&amp;amp;apos; doesn&amp;amp;apos;t map to a Long object
org.apache.commons.configuration.ConversionException: &amp;amp;apos;foo&amp;amp;apos; doesn&amp;amp;apos;t map to a Long object
        at org.apache.commons.configuration.AbstractConfiguration.getLong(AbstractConfiguration.java:667)
The problem is that when an object in a property is not a Long, the only attempt of PropertyConverter.toLong() is that of treating it as a string. It could try to convert it to a Number first and then try to convert it to a long. It is a very confusing behaviour, because if you save and reload the properties everything works fine (as now the integer is a string).</description>
			<version>1.2</version>
			<fixedVersion>1.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestBaseConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.PropertyConverter.java</file>
			<file type="M">org.apache.commons.configuration.TestPropertyConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="220" opendate="2006-08-14 23:59:22" fixdate="2006-08-15 20:27:44" resolution="Fixed">
		<buginformation>
			<summary>getDateArray(String key, Date[] defaultValue, String format) ignores format argument</summary>
			<description>getDateArray(String key, Date[] defaultValue, String format) in DataConfiguration takes a format argument, but it is not used in the call to getDateList(key). This call should probably be getDateList(key, format).</description>
			<version>1.2</version>
			<fixedVersion>1.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestDataConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.DataConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="228" opendate="2006-09-22 11:34:34" fixdate="2006-10-16 20:26:45" resolution="Fixed">
		<buginformation>
			<summary>XMLConfiguration.subset() with FileChangedReloadingStrategy does *not* &amp;apos;see&amp;apos; file changes</summary>
			<description>XMLConfiguration.subset() with FileChangedReloadingStrategy does not &amp;amp;apos;see&amp;amp;apos; file changes
Configuration.xml:
&amp;lt;conf&amp;gt;
    &amp;lt;parent-item&amp;gt;
        &amp;lt;sub-item&amp;gt;old_value&amp;lt;/sub-item&amp;gt;
    &amp;lt;/parent-item&amp;gt;
&amp;lt;/conf&amp;gt;
1. XMLConfiguration is loaded:
            config = new XMLConfiguration("c:conf.xml");
            config.setReloadingStrategy(new FileChangedReloadingStrategy());
2. Now, &amp;lt;sub-item&amp;gt; node value changes to "new_value",
and the code:
            Configuration parentItemConfig = config.subset("parent-item"); [AA]
            String ss2 = parentItemConfig.getString("sub-item");
returns "old_value" !!!
while:  config.getString("parent-item.sub-item"); returns new refreshed value.
It is a bug, we have FileChangedReloadingStrategy, we create new subset in [AA] but receive old values.
[for now, workaround for config users is to call config.reload() when strategy.hasChanged()]
</description>
			<version>1.2</version>
			<fixedVersion>1.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="230" opendate="2006-10-13 04:09:08" fixdate="2006-10-21 15:23:54" resolution="Fixed">
		<buginformation>
			<summary>XPathExpressionEngine nodeKey method create a wrong key for attribute node</summary>
			<description>In org.apache.commons.configuration.tree.xpath.XPathExpressionEngine line 178
            if (node.isAttribute())
            {
                buf.append(ATTR_DELIMITER);
            }

should be changed to 
            if (node.isAttribute()) 
{
	buf.append(NODE_PATH_DELIMITERS);
            }

Using ATTR_DELIMITER will create key like element@attribute rather than element/@attribute and make config reload fail.</description>
			<version>1.3</version>
			<fixedVersion>1.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.tree.xpath.TestXPathExpressionEngine.java</file>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.tree.xpath.XPathExpressionEngine.java</file>
		</fixedFiles>
	</bug>
	<bug id="233" opendate="2006-10-21 18:16:07" fixdate="2006-10-28 15:11:24" resolution="Fixed">
		<buginformation>
			<summary>Incomplete interpolation in CompositeConfiguration.getList()</summary>
			<description>Interpolsation is mostly done by AbstractConfiguration. All classes that override get methods of AbstractConfiguration need to be careful not to break interpolsation.
The class CompositeConfiguration overrides getList() to easily chain the results of getList for its subconfigurations. The calls to getList() in the subconfigurations does interpolsation but only inside the subconfiguration. The combined lists never get interpolated in the whole CompositeConfiguration. So whenever a reference in the value refers to a property in another subconfiguration, interpolation breaks.
Since all the scalar get methods correctly interpolate between different sub configurations, I assume, that this special behavior in getList() is not intended.
A simple test case would be using the ConfigurationFactory with a config.xml, that uses two property files x.properties:
x.1=a
x.2=b
and y.properties:
y=$
{x.1}
, $
{x.2}

and then calling getList for the key "y".
The attached patch fixes the problem locally in CompositeConfiguration. It&amp;amp;apos;s not very elegant, but tries to keep the fix local.
The patch should work for 1.2, 1.3 and trunk, since getList() in CompositeConfiguration ist the same in these versions.</description>
			<version>1.3</version>
			<fixedVersion>1.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestCompositeConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.CompositeConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="227" opendate="2006-09-18 19:53:39" fixdate="2006-10-30 20:24:56" resolution="Fixed">
		<buginformation>
			<summary>ConfigurationDynaBean does not work well with all types of configurations</summary>
			<description>The current implementation of ConfigurationDynaBean makes some assumptions about the underlying Configuration object that are not met by all configuration implementations. Especially setting values for indexed properties by calling getList() and manipulating mapped properties through a subset configuration do not work for configurations derived from HierarchicalConfiguration.</description>
			<version>1.2</version>
			<fixedVersion>1.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.beanutils.ConfigurationDynaBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="235" opendate="2006-10-26 17:49:49" fixdate="2006-10-30 20:52:16" resolution="Fixed">
		<buginformation>
			<summary>variable interpolation problem</summary>
			<description>interpolation of variables in Subsets doesn&amp;amp;apos;t work, if they are not accessed via getString(). The following
example illustrates the problem:
BaseConfiguration oBase = new BaseConfiguration();
oBase.addProperty( "a.b", new Integer(2) );
oBase.addProperty( "a.c", "$
{a.b}
" );
// as expected: 2
int iValueBaseConfig = oBase.getInt( "a.c" );
String strValueBaseConfig = oBase.getString("a.c");
// as expected: 2
String strValueSubset = oBase.subset("a").getString("c");
// ConversionException, &amp;amp;apos;c&amp;amp;apos; doesn&amp;amp;apos;t map to an Integer object
int iValueSubset = oBase.subset("a").getInt("c");
</description>
			<version>1.3</version>
			<fixedVersion>1.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestBaseConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.SubsetConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="229" opendate="2006-10-03 14:52:04" fixdate="2006-11-02 21:28:00" resolution="Fixed">
		<buginformation>
			<summary>config : load for a configuration node is called before parsing is complete : attributes ignored</summary>
			<description>Hi there
i have noticed the following issue which appears to be a bug. (Tested on 1.3 however the version doesn&amp;amp;apos;t appear above)
createObject from FileConfigurationFactory(DigesterConfigurationFactory) set fileName and fires load of properties : 
public Object createObject(Attributes attributes) throws Exception
        {
            FileConfiguration conf = createConfiguration(attributes);
            conf.setBasePath(getBasePath());
            conf.setFileName(attributes.getValue(ATTR_FILENAME));
            try
            {
                log.info("Trying to load configuration " + conf.getFileName());
                conf.load();
            }

However digester invokes createObject when the object is instancied and before setting any attributes. 
All other attributes beside fileName and basePath are not read in time and therefore are ignored during load.
I guess load should be called when node initialization is complete, possibly using a proper digester rule. 
Regards,
andr
</description>
			<version>1.3</version>
			<fixedVersion>1.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestConfigurationFactory.java</file>
			<file type="M">org.apache.commons.configuration.ConfigurationFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="242" opendate="2006-12-02 18:09:41" fixdate="2006-12-02 18:22:36" resolution="Fixed">
		<buginformation>
			<summary>The configuration returned by HierarchicalConfiguration.subset() does not globally interpolate</summary>
			<description>Interpolation is only performed in the subset configuration itself. If the referenced property is not in the subset (but somewhere else in the parent configuration), it cannot be resolved. Interpolation should take all properties of the parent configuration into account.</description>
			<version>1.3</version>
			<fixedVersion>1.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestSubnodeConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestHierarchicalConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="241" opendate="2006-12-02 00:03:48" fixdate="2006-12-02 18:45:38" resolution="Fixed">
		<buginformation>
			<summary>clearProperty() does not generate events</summary>
			<description>I am loading configuration information from multiple sources and have registered a listener with the resulting configuration object. Unfortunately the listener does not receive "clear property" events. I&amp;amp;apos;ve confirmed that it can properly receive other events (like "set property"), and that calls to "clearProperty()" do actually clear the property, so I believe this may be a bug in commons-configuration. I&amp;amp;apos;ve tried setting "details" to true, which had no effect. Below is a watered down version of what I am doing (note, my configuration file simply pulls in a property file containing this property: name.first=Mike):
ConfigurationFactory configurationFactory = new ConfigurationFactory();
URL configFileURL = ... get the config file ...
configurationFactory.setConfigurationURL(configFileURL);
Configuration configuration = ConfigurationFactory.getConfiguration();
configuration.addConfigurationListener(new ConfigurationListener() {
    public void configurationChanged(ConfigurationEvent e) 
{
        System.out.println(e.getPropertyName() + ": " + e.getPropertyValue());
    }
});
System.out.println(configuration.getProperty("name.first")); // prints "Mike"
configuration.claerProperty("name.first")); // no output whatsoever
System.out.println(configuration.getProperty("name.first")); // prints "null"</description>
			<version>1.3</version>
			<fixedVersion>1.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestCompositeConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.CompositeConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="232" opendate="2006-10-16 12:23:51" fixdate="2006-12-22 18:22:43" resolution="Fixed">
		<buginformation>
			<summary>ConfigurationUtils spews directly on std.err when exceptions</summary>
			<description>ConfigurationUtils:
public static URL locate(String base, String name) {
  3 x :
  catch ([Malformed|IO]URLException e) 
{
    e.printStackTrace();
  }
}
.. say no more.
But while we&amp;amp;apos;re at it, the log-message (which, for some reason, actually goes to a logger, not uglily to the system) states "Configuration loaded from ..", which isn&amp;amp;apos;t true: The thing isn&amp;amp;apos;t loaded yet; it will be loaded.  "Loading configuration from .." would be better, or maybe "Will be loading configuration from ..". In addition, these log-lines could state what was the "base", and in particular the case where it loads from "base path", the whole line reads wrong.
For example: "Loading configuration ["+name+"] from base path ["+base+"].." and similar for the other lines.</description>
			<version>1.3</version>
			<fixedVersion>1.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.AbstractFileConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.ConfigurationUtils.java</file>
			<file type="M">org.apache.commons.configuration.plist.XMLPropertyListConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="252" opendate="2007-02-01 15:19:07" fixdate="2007-02-03 16:20:50" resolution="Fixed">
		<buginformation>
			<summary>Detection of absolute fileNames when configuration sources are defined in a JAR file</summary>
			<description>When using several configuration sources, the sources are defined in a an xml attribute like 
fileName="usergui.properties"
The method org.apache.commons.configuration.ConfigurationUtils.getFile(String basePath, String fileName) converts the basePath and fileName into a File.
The JavaDoc says: "The parameter strings can be relative files, absolute files and URLs as well."
The file containing the definition of the configuration sources will become the basePath of this method.
After a log of debugging I found, that if the basePath start with "jar:" the method assumes that the fileName is relative, evene if it&amp;amp;apos;s absolute. This happens, because there&amp;amp;apos;s a ProtocolHandler for Jar files and "jar:" is a valid protocol. So the statement "new URL(new URL(basePath), fileName)" doesn&amp;amp;apos;t throw a MalformedUrlException.
Since the URL is valid, it&amp;amp;apos;s never checked, if the fileName may be absolute. 
Attention: this is only the case on Unix/Linux, since this is a valid URL
jar:file:/C:/myjar.jar!/my-config.xml/someprops.properties
while under Windows, a MalformedUrlException will be thrown, when the fileName is absolute: 
jar:file:/C:/myjar.jar!/my-config.xml/c:/someprops.properties
I attached a patch that checks, whether the URL protocol is "jar" and the fileName is absolute. If so, the absolute file will be used.</description>
			<version>1.3</version>
			<fixedVersion>1.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.ConfigurationUtils.java</file>
			<file type="M">org.apache.commons.configuration.TestConfigurationUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="254" opendate="2007-02-28 21:22:26" fixdate="2007-03-01 21:20:54" resolution="Fixed">
		<buginformation>
			<summary>Wrong creation of XMLFileConfigurationDelegate in XMLConfiguration.clone()</summary>
			<description>The clone() operation on a XMLConfiguration does not work correctly due to the following problem:
private class XMLFileConfigurationDelegate extends FileConfigurationDelegate
{
     public void load(InputStream in) throws ConfigurationException
     {
            XMLConfiguration.this.load(in);
      }
}
Obviously the delegate references the XMLConfiguration instance it is created in. Thus when calling
public Object clone()
{
      XMLConfiguration copy = (XMLConfiguration) super.clone();
       // clear document related properties
       copy.document = null;
       copy.setDelegate(createDelegate());
       // clear all references in the nodes, too
       copy.getRoot().visit(new NodeVisitor()
       {
            public void visitBeforeChildren(Node node, ConfigurationKey key)
            {
                node.setReference(null);
             }
        }, null);
        return copy;
}
the delegate still references the original XMLConfiguration, thus will save the content of the original one
to file instead of the clone as expected! Changing the code like this
        copy.setDelegate(copy.createDelegate());
solves the problem! Now the cloned XMLConfiguration with all its  applied changes can be saved!</description>
			<version>1.3</version>
			<fixedVersion>1.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.XMLConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="255" opendate="2007-03-01 18:20:24" fixdate="2007-03-03 20:23:32" resolution="Fixed">
		<buginformation>
			<summary>DatabaseConfiguration doesn&amp;apos;t support list delimiters in property values</summary>
			<description>The getList() and getStringArray() methods always return a one element list/array, when used with DatabaseConfiguration, even if the value of the queried property contains the list delimiter character.</description>
			<version>1.3</version>
			<fixedVersion>1.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.DatabaseConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestDatabaseConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="256" opendate="2007-03-05 13:02:03" fixdate="2007-03-06 21:20:50" resolution="Fixed">
		<buginformation>
			<summary>MapConfiguration does not decode escaped Delimiters</summary>
			<description>Hello, I don&amp;amp;apos;t know how to reopen resolved bug. See: https://issues.apache.org/jira/browse/CONFIGURATION-30
There is BAD implementation in MapConfiguration.getProperty(String key) method:
As "return value" should be list.get(0) instead of "value".
PropertyConverter.split removes escape chars....
Suggested correction:
    public Object getProperty(String key)
    {
        Object value = map.get(key);
        if ((value instanceof String) &amp;amp;&amp;amp; (!isDelimiterParsingDisabled()))
        {
            List list = PropertyConverter.split((String) value, getListDelimiter());
            //MP: return list.size() &amp;gt; 1 ? list : value;
            return list.size() &amp;gt; 1 ? list : list.get(0); //MP: split removes escape chars
        }
        else
        {
            return value;
        }
    }
Test code:
Map m = new HashMap();
m.put("foo", "bar,baz");
m.put("bar", "bar, baz");
MapConfiguration mc = new MapConfiguration(m);
mc.setDelimiterParsingDisabled(false);
mc.setListDelimiter(&amp;amp;apos;,&amp;amp;apos;);
Configuration c = mc;
String bad = c.getString("foo"); //&amp;lt;-- returns "bar, baz" expected "bar, baz"
String ok = c.getString("bar"); // &amp;lt;-- returns "bar"
System.err.println("Bad: " + bad);
System.err.println("OK: " + ok);
Current result is:
Bad: bar\,baz
OK: bar</description>
			<version>1.3</version>
			<fixedVersion>1.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.web.ServletConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.web.TestServletFilterConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.web.AppletConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestAbstractConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.web.ServletContextConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.MapConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.web.ServletFilterConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestMapConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.web.BaseWebConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.web.TestServletContextConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.web.TestAppletConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.web.TestServletRequestConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.web.TestServletConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.web.ServletRequestConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="259" opendate="2007-03-28 08:47:56" fixdate="2007-03-30 09:35:55" resolution="Fixed">
		<buginformation>
			<summary>ConfigurationFactory Merge is broken</summary>
			<description>I am trying to merge two Configuration using the ConfigurationFactory and the additional tag. It turns out that subsequent operations on the merged data provide wrong results. In particular, after creating a particular subset from a loaded configuration, the subset is empty. Strangely enough, when using DefaultConfigurationBuilder to load exactly the same configurations this works properly. 
So when initializing the configuration as follows, I get the following error:
URL configURL = getClass().getResource(configFile);
ConfigurationFactory factory = new ConfigurationFactory();
factory.setConfigurationURL(configURL);
myConfig = factory.getConfiguration();
60043
java.util.NoSuchElementException: &amp;amp;apos;HvNr&amp;amp;apos; doesn&amp;amp;apos;t map to an existing object
	at org.apache.commons.configuration.AbstractConfiguration.getLong(AbstractConfiguration.java:743)
	at de.awd.vertriebsportal.portal.person.TestConfiguration.main(TestConfiguration.java:84)
Exception in thread "main" 
But when initializing it like this everything works properly
DefaultConfigurationBuilder builder = new DefaultConfigurationBuilder();
            builder.setURL(configURL);
            myConfig = builder.getConfiguration();
60043
54564
I will attach full source code and xml files</description>
			<version>1.3</version>
			<fixedVersion>1.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.ConfigurationFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="263" opendate="2007-04-14 14:15:37" fixdate="2007-04-17 19:54:44" resolution="Fixed">
		<buginformation>
			<summary>XMLConfiguration drops attributes if a property value is a list</summary>
			<description>When the following test is run with the following xml the second assertEquals statement fails:
XML:
&amp;lt;?xml version="1.0" encoding="ISO-8859-1" ?&amp;gt;
&amp;lt;test&amp;gt;
&amp;lt;a name="X"&amp;gt;ABC&amp;lt;/a&amp;gt;
&amp;lt;a name="Y"&amp;gt;1,2,3&amp;lt;/a&amp;gt;
&amp;lt;/test
TEST:
public void testXMLConfig() throws Exception {
  File file = new File("/xml/xmlConfigTest.xml");
  XMLConfiguration xmlConfig = new XMLConfiguration(file);
  xmlConfig.load();
  assertEquals("X",xmlConfig.getProperty("a(0)[@name]"));
  assertEquals("Y",xmlConfig.getProperty("a(1)[@name]"));
}</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.XMLConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="264" opendate="2007-04-14 14:22:27" fixdate="2007-04-21 14:35:13" resolution="Fixed">
		<buginformation>
			<summary>SubnodeConfiguration does not see reloads of its parent configuration</summary>
			<description>The problem can be reproduced as follows:
1 config = new XMLConfiguration("c:conf.xml");
2 config.setReloadingStrategy(new FileChangedReloadingStrategy());
3 SubnodeConfiguration parentItemConfig = config.configurationAt("parent-item");
4 String ss2 = parentItemConfig.getString("sub-item");
5 //Now, &amp;lt;sub-item&amp;gt; node value changes to "new_value"
6 ss2 = parentItemConfig.getString("sub-item"); // still returns old_value</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestSubnodeConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.SubnodeConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="265" opendate="2007-04-17 00:06:51" fixdate="2007-04-22 18:59:05" resolution="Fixed">
		<buginformation>
			<summary>XMLConfiguration with setAutoSave(true) doesn&amp;apos;t save if SubnodeConfiguration is changed</summary>
			<description>config.xml file
&amp;lt;conf&amp;gt;
    &amp;lt;parent-item&amp;gt;
        &amp;lt;sub-item&amp;gt;old_value&amp;lt;/sub-item&amp;gt;
    &amp;lt;/parent-item&amp;gt;
&amp;lt;/conf&amp;gt;
The problem can be reproduced as follows: 
 1 XMLConfiguration config = new XMLConfiguration("c:conf.xml"); 
 2 config.setAutoSave(true) ;
 3 SubnodeConfiguration parentItemConfig = config.configurationAt("parent-item"); 
 4 parentItemConfig.setProperty("sub-item","new_value");
 5. System.out.println(config.getString("parent-item.sub-item");  // will print new_value
 // if you look at the config.xml sub-item still has old_value
 // also if you try to do 
 5 XMLConfiguration config2 = new XMLConfiguration("c:conf.xml");
 6. System.out.println(config2.getString("parent-item.sub-item");  // will print old_value</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.event.TestHierarchicalConfigurationEvents.java</file>
			<file type="M">org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.event.AbstractTestConfigurationEvents.java</file>
			<file type="M">org.apache.commons.configuration.SubnodeConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="267" opendate="2007-04-23 02:20:47" fixdate="2007-04-23 09:41:03" resolution="Fixed">
		<buginformation>
			<summary>INIConfiguration.save() doesn&amp;apos;t save file correctly</summary>
			<description>The PrintWriter used by save() method implemented in INIConfiguration is not flushed so that configurations maybe not saved completely.</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.INIConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="268" opendate="2007-05-06 19:44:31" fixdate="2007-05-08 20:58:54" resolution="Fixed">
		<buginformation>
			<summary>XMLConfiguration does not fully support disabled delimiter parsing</summary>
			<description>A call to setDelimiterParsingDisabled(true) should completely turn off the mechanism for searching for list delimiters and splitting property values.
However XMLConfiguration.save() escapes list delimiters even in this mode. When later such a configuration file is loaded and delimiter parsing is turned off, the values of affected properties will contain the escape character.</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.XMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.PropertyConverter.java</file>
			<file type="M">org.apache.commons.configuration.TestPropertyConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="270" opendate="2007-05-22 16:25:02" fixdate="2007-05-22 23:10:46" resolution="Fixed">
		<buginformation>
			<summary>INIConfiguration Does not support multi value keys</summary>
			<description>The INIConfiguration save(Writer writer) uses PrintWriter instead of using a class like PropertiesConfiguration.PropertiesWriter.
Because of that the method uses getString(String key) to get the keys value (which return onlt the first element of the list) and in doing so there is no support for multi value keys.</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestINIConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.INIConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="269" opendate="2007-05-21 20:31:01" fixdate="2007-05-24 11:33:29" resolution="Fixed">
		<buginformation>
			<summary>PropertiesConfiguration.save() generates superfluous escaping character when delimiter parsing is disabled</summary>
			<description>PropertiesConfiguration.save() ignores the delimiter parsing disabled flag and escapes all delimiter characters it encounters. When the configuration is loaded again (with delimiter parsing disabled) the values of affected properties contain the escaping character.
This bug is very similar to CONFIGURATION-268, but for PropertiesConfiguration.</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.PropertiesConfigurationLayout.java</file>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.PropertiesConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="274" opendate="2007-05-24 20:39:24" fixdate="2007-05-24 20:43:44" resolution="Fixed">
		<buginformation>
			<summary>PropertiesConfiguration.save() does not support escaping the escape character</summary>
			<description>When a new property is added to a PropertiesConfiguration, it is possible to escape the escaping character for list delimiters, e.g.
conf.addProperty("test.dirs", "C:\\Temp\\\\,D:\\Data");
Here the Backslash after Temp must be escaped, otherwise the list delimiter won&amp;amp;apos;t be recognized. This works, but when the configuration is saved and loaded again, the backslash that escapes the escape character is dropped. The property is then treated as a single value property with an escaped list delimiter.</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.PropertiesConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="253" opendate="2007-02-15 09:23:51" fixdate="2007-05-26 19:38:51" resolution="Fixed">
		<buginformation>
			<summary>FileConfiguration getFile(), getFileName(), getBasePath() are not always consistent</summary>
			<description>Taken from the maillinglist:
&amp;gt; I have a properties configuration which is loaded without a problem.
&amp;gt; Later in my application I will access the file which is aligned to 
&amp;gt; this configuration.
&amp;gt; 
&amp;gt;  
&amp;gt; 
&amp;gt; final IFileConfiguration _productConf = 
&amp;gt; _conf.getProductConfigurations().get(_productId);
&amp;gt; 
&amp;gt; log.debug("product conf file " + _productConf.getFile());
&amp;gt; 
&amp;gt; log.debug("product conf filename " + _productConf.getFileName());
&amp;gt; 
&amp;gt; log.debug("product conf base path " + _productConf.getBasePath());
&amp;gt; 
&amp;gt;  
&amp;gt; 
&amp;gt; The methods _productConf.getFile() and _productConf.getFileName() 
&amp;gt; returning null but the getBasePath() returns a path which is correct 
&amp;gt; (like file:/C:/Projects/workspace/myProject/project.properties). Seems 
&amp;gt; for me like a bug because the PropertiesConfiguration is loaded 
&amp;gt; correct and works.
&amp;gt; 
&amp;gt;  
&amp;gt; 
&amp;gt; By side: I have also set a file reloading strategy for this 
&amp;gt; configuration.
&amp;gt; 
&amp;gt;  
&amp;gt; 
&amp;gt; Any ideas what&amp;amp;apos;s happen in this case or where I can find the problem? 
&amp;gt; It would be nicer to get the File() instead the BasePath which has to 
&amp;gt; be converted into a URL before I can access the whole properties file.
&amp;gt; 
&amp;gt;  
&amp;gt; 
&amp;gt; Thanks in advance,
&amp;gt; 
&amp;gt;  
&amp;gt; 
&amp;gt; - Thomas Wabner
&amp;gt; 
&amp;gt; 
Thomas,
you are right, the conversions between a base path, a file name, and a File are not always consistent. How did you load the configuration (this determines, which internal fields are set)?
I would recommend to work with URLs, i.e. the method getURL(). A file-based configuration&amp;amp;apos;s URL is always defined.
If you like, you can open a Jira ticket for this problem.
Thanks.
Oliver
The file is loaded in this way:
_productConf = new ProductConfiguration();
_productConf.load(FileTools.getPathForList(_propductPathList).getPath());
means the load method gets an String and not an File.
</description>
			<version>1.3</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestFileConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.AbstractFileConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="279" opendate="2007-06-01 12:51:34" fixdate="2007-06-02 20:03:17" resolution="Fixed">
		<buginformation>
			<summary>PropertiesConfiguration dysfunctional if constructed with nonexistent File</summary>
			<description>When PropertiesConfiguration is constructed around a File that does not exist, everything seemingly goes well, but saving the configuration only results in an empty file. This differs from constructing a PropertiesConfiguration around a file name passed as String, which appropriately fails at construction-time, since it tries to load() the configuration, which fails.
When the nonexistent configuration file is passed as File, this does not happen, since the File constructor in AbstractFileConfiguration specifically tests if the file exists before calling load() and succeeds even if it wasn&amp;amp;apos;t called. However, if load() is not called, no PropertiesConfigurationLayout is created or registered to the EventSource, and thus nothing is saved when save() is called on the PropertiesConfiguration. Calling save() actually calls getLayout(), which creates a layout and registers it, but the properties set between construction of the PropertiesConfiguration and calling save() on it are still lost.</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.PropertiesConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="280" opendate="2007-06-07 21:33:35" fixdate="2007-06-10 16:11:36" resolution="Fixed">
		<buginformation>
			<summary>autoSave and FileChangedReloadingStrategy corrupts configuration</summary>
			<description>First of all, sorry if this is not a bug. I may have missed some information on how to make autoSave and FileChangedReloadingStrategy work.
When a change has been detected by the FileChangedReloadingStrategy code, a clear() followed by a load() is executed in the AbstractFileConfiguration class (around line 809 of version 1.4). The clear() method leads to a possiblySave() call which overwrites the configuration. At the end of the clear() method, the configuration file is empty and the following load() method loads this empty configuration. The possiblySave() call is invoked via the work-around (according to the comment in the code) in AbstractConfiguration (line 538).
I&amp;amp;apos;m using the following code:
CompositeConfiguration config = new CompositeConfiguration();
XMLConfiguration xmlconfig = new XMLConfiguration("config.xml");
FileChangedReloadingStrategy fcrs = new FileChangedReloadingStrategy();
xmlconfig.setReloadingStrategy(fcrs);
config.addConfiguration(new SystemConfiguration());
config.addConfiguration(xmlconfig);
xmlconfig.setAutoSave(true);
...wait for config changes...		
A workaround for the problem is to deactivate autoSave in the reload() method of the AbstractFileConfiguration class. After the configuration is cleared and loaded, the original autoSave is restored. See the diff below:
806a807,808
&amp;gt;                         boolean autoSaveBak = this.isAutoSave(); // save the current state
&amp;gt;                         this.setAutoSave(false); // deactivate autoSave to prevent information loss
813a816
&amp;gt;                               this.setAutoSave(autoSaveBak); // set autoSave to previous value
The code fragment looks like:
--------------------------
                    if (strategy.reloadingRequired())
                    {
                        if (getLogger().isInfoEnabled())
                        {
                            getLogger().info("Reloading configuration. URL is " + getURL());
                        }
                        fireEvent(EVENT_RELOAD, null, getURL(), true);
                        setDetailEvents(false);
                        boolean autoSaveBak = this.isAutoSave(); // save the current state
                        this.setAutoSave(false); // deactivate autoSave to prevent information loss
                        try
                        {
                            clear();
                            load();
                        }
                        finally
                        {
                                this.setAutoSave(autoSaveBak); // set autoSave to previous value
                            setDetailEvents(true);
                        }
                        fireEvent(EVENT_RELOAD, null, getURL(), false);
                        // notify the strategy
                        strategy.reloadingPerformed();
                    }
--------------------------
I hope this is a valid fix. </description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.AbstractFileConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="277" opendate="2007-05-30 13:52:55" fixdate="2007-06-12 20:06:47" resolution="Fixed">
		<buginformation>
			<summary>AbstractConfiguration should handle UnsupportedOperationExceptions in Iterator.remove() gracefully</summary>
			<description>Hi,
In AbstractConfiguration method clear() on line 533 (see code below) a possible UnsupportedOperationException is not caught resulting in the malfunctioning of the whole method. However, the documentation of the getKeys() method itself warns about relying on the remove() method of interface Iterator. The clear() method should not propagate that exception, it should catch it and try the clearProperty(String) approach if the remove() method is not supported.
            Iterator it = getKeys();
            while (it.hasNext())
            {
                String key = (String) it.next();
                it.remove();                                          &amp;lt;------- EVIL!
                if (containsKey(key))
                {
                    // workaround for Iterators that do not remove the property on calling remove()
                    clearProperty(key);
                }

Best regards,
Michael</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.AbstractConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="281" opendate="2007-06-20 18:31:05" fixdate="2007-06-21 20:00:56" resolution="Fixed">
		<buginformation>
			<summary>JNDIConfiguration::recursiveGetKeys goes out of stack</summary>
			<description>There can be cycles in contexts. Websphere 5.1 certainly does have them.
When getKeys() is called on a JNDIConfiguration, eventually recursiveGetKeys() is called, which calls itself for every subcontext. This will never stop if there is a cycle.
I would like to suggest the following changes to recursiveGetKeys() to fix this:
1) check for each subcontext if it has been processed before. If so, don&amp;amp;apos;t process it. An additional stack argument to recursiveGetKeys() should do the trick here.
2) a maxDepth attribute, like &amp;lt;jndi maxDepth="4"/&amp;gt;. If the number of subcontexts is equal to maxDepth, stop processing. The maxDepth attribute should be optional of course, and have a default value like 911or so. The stack argument could be used to check the amount of subcontexts processed.
Because I want to be able to dump the configuration for debugging purposes, this item is of somewhat importance to me.
I tested this in 1.2 at work, so I cannot easily test this against 1.4. But as the code of 1.4 seems to be more or less the same, I think the problem still exists.
</description>
			<version>1.2</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestJNDIConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.JNDIConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.MockInitialContextFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="275" opendate="2007-05-25 17:12:43" fixdate="2007-07-09 20:36:22" resolution="Fixed">
		<buginformation>
			<summary>ConfigurationUtils.append() doesn&amp;apos;t merge list properties</summary>
			<description>ConfigurationUtils.append() appends the list object instead of the list elements to the target list. If the list [X, Y] is appended to the list [A, B], the result is [A, B, [X, Y]] instead of [A, B, X, Y]
</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.AbstractConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestAbstractConfigurationBasicFeatures.java</file>
		</fixedFiles>
	</bug>
	<bug id="283" opendate="2007-07-02 12:38:23" fixdate="2007-07-12 20:02:18" resolution="Fixed">
		<buginformation>
			<summary>CombinedConfiguration doesn&amp;apos;t take escaped characters into account.</summary>
			<description>Hi, 
I&amp;amp;apos;ve tried to used CombinedConfiguration but it seems escaped characters are not taken into account :
import org.apache.commons.configuration.CombinedConfiguration;
import org.apache.commons.configuration.ConfigurationException;
import org.apache.commons.configuration.PropertiesConfiguration;
import junit.framework.TestCase;
public class TestProp extends TestCase {
	public void testprop() throws ConfigurationException 
{
		// test.properties contains :
		//    without_escape=aa,bb
		//    with_escape=aa\,bb
		//    with_2escapes=aa\\,bb
		
		String prop_filename = "c:\\tmp\\test.properties";
		PropertiesConfiguration properties_config = new PropertiesConfiguration(prop_filename);
		CombinedConfiguration   combined_config   = new CombinedConfiguration();
		combined_config.addConfiguration(properties_config);
		
		System.out.println("Properties config");
		System.out.println(properties_config.getString("without_escape"));
		System.out.println(properties_config.getString("with_escape"));
		System.out.println(properties_config.getString("with_2escapes"));

		System.out.println("\nCombined config");
		System.out.println(combined_config.getString("without_escape"));
		System.out.println(combined_config.getString("with_escape"));
		System.out.println(combined_config.getString("with_2escapes"));
		
	}
}
Result : 
---------
Properties config
aa
aa,bb
aa,bb
Combined config
aa
aa
aa
Thanks !
Franck</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.ConfigurationUtils.java</file>
			<file type="M">org.apache.commons.configuration.TestConfigurationUtils.java</file>
			<file type="M">org.apache.commons.configuration.TestCombinedConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="282" opendate="2007-06-26 06:49:27" fixdate="2007-07-18 19:36:12" resolution="Fixed">
		<buginformation>
			<summary>NPE in HierarchicalConfiguration.fetchNodeList after redeployment</summary>
			<description>java.lang.NullPointerException
        at org.apache.commons.configuration.HierarchicalConfiguration.fetchNodeList(HierarchicalConfiguration.java:721)
        at org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.fetchNodeList(AbstractHierarchicalFileConfiguration.java:338)
        at org.apache.commons.configuration.HierarchicalConfiguration.getProperty(HierarchicalConfiguration.java:284)
        at org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.getProperty(AbstractHierarchicalFileConfiguration.java:319)
        at org.apache.commons.configuration.AbstractConfiguration.resolveContainerStore(AbstractConfiguration.java:1222)
        at org.apache.commons.configuration.AbstractConfiguration.getBoolean(AbstractConfiguration.java:667)
        at org.apache.commons.configuration.AbstractConfiguration.getBoolean(AbstractConfiguration.java:633)
java.lang.NullPointerException
        at org.apache.commons.configuration.HierarchicalConfiguration.fetchNodeList(HierarchicalConfiguration.java:721)
        at org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.fetchNodeList(AbstractHierarchicalFileConfiguration.java:338)
        at org.apache.commons.configuration.HierarchicalConfiguration.getProperty(HierarchicalConfiguration.java:284)
        at org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.getProperty(AbstractHierarchicalFileConfiguration.java:319)
        at org.apache.commons.configuration.AbstractConfiguration.resolveContainerStore(AbstractConfiguration.java:1222)
        at org.apache.commons.configuration.AbstractConfiguration.getString(AbstractConfiguration.java:1097)
        at org.apache.commons.configuration.AbstractConfiguration.getString(AbstractConfiguration.java:1077)</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="285" opendate="2007-07-11 12:30:33" fixdate="2007-07-21 19:09:43" resolution="Fixed">
		<buginformation>
			<summary>&lt;configuration fileName="local-configuration.xml" config-optional="true" /&gt; does not report parsing errors in local-configuration.xml</summary>
			<description>I&amp;amp;apos;m trying to build a configuration system to be shared between our Java applications.  I therefore want to have optional configurations included from the main configuration file read by DefaultConfigurationBuilder
&amp;lt;configuration fileName="local-configuration.xml" config-optional="true" /&amp;gt;
I have found that if the sub-configuration file is invalid the error is silently ignored.  The same without config-options="true" results in a ConfigurationException to be thrown (which wraps a ConfigurationRuntimeException which wraps the ConfigurationException which wraps the SAXException).
I believe that the behaviour is incorrect.  The sub-configuration file should be skipped if not found, but any errors found when parsing the existing file should be logged.
</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.DefaultConfigurationBuilder.java</file>
			<file type="M">org.apache.commons.configuration.TestDefaultConfigurationBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="287" opendate="2007-07-26 14:05:49" fixdate="2007-07-26 20:17:03" resolution="Fixed">
		<buginformation>
			<summary>XMLConfiguration.addNodes() problem using other configuration Nodes</summary>
			<description>Trying to use the method XMLConfiguration.addNodes() to add a tree of configuration properties to a node in other tree fails. 
Example:
public static void main(String ...args){            
try
{
           configDestination = new XMLConfiguration("output.xml");
           configSource = new XMLConfiguration("input.xml");
       }
       catch(ConfigurationException cex)
{
           System.out.println("File not found");
       }
             Collection collection = new ArrayList();
       collection = configSource.getRoot().getChildren();
             configDestination.addNodes("newNodes", collection);                  
try 
{
           configDestination.save();
            }
 catch (ConfigurationException e) 
{
           System.out.println("Error saving");
       }
}
The XML files:
input.xml
&amp;lt;rootNode&amp;gt;
   &amp;lt;newNodeChild&amp;gt;
       &amp;lt;newNodeChildChild&amp;gt;child value&amp;lt;/newNodeChildChild&amp;gt;
       &amp;lt;newNodeChildChild&amp;gt;child value 2&amp;lt;/newNodeChildChild&amp;gt;
       &amp;lt;newNodeChildChild&amp;gt;child value 3&amp;lt;/newNodeChildChild&amp;gt;
   &amp;lt;/newNodeChild&amp;gt;
&amp;lt;/rootNode&amp;gt;
output.xml
&amp;lt;testRootNode&amp;gt;
   &amp;lt;test&amp;gt;TEST&amp;lt;/test&amp;gt;
&amp;lt;/testRootNode&amp;gt;
output.xml after running the code:
&amp;lt;testRootNode&amp;gt;
   &amp;lt;test&amp;gt;TEST&amp;lt;/test&amp;gt;
   &amp;lt;newNodes/&amp;gt;
&amp;lt;/testRootNode&amp;gt;
Expected output.xml:
&amp;lt;testRootNode&amp;gt;
   &amp;lt;test&amp;gt;TEST&amp;lt;/test&amp;gt;
   &amp;lt;newNodes&amp;gt;
       &amp;lt;newNodeChild&amp;gt;
           &amp;lt;newNodeChildChild&amp;gt;child value&amp;lt;/newNodeChildChild&amp;gt;
           &amp;lt;newNodeChildChild&amp;gt;child value 2&amp;lt;/newNodeChildChild&amp;gt;
           &amp;lt;newNodeChildChild&amp;gt;child value 3&amp;lt;/newNodeChildChild&amp;gt;
       &amp;lt;/newNodeChild&amp;gt;
   &amp;lt;newNodes/&amp;gt;
&amp;lt;/testRootNode&amp;gt; 
Apparently "the copied nodes still contain a reference to their old configuration (because you directly fetched them from the root node of the source configuration). Because of this reference they are not detected as new nodes when the destination configuration is saved, and hence not written to disk.
I think addNodes() should reset this reference, so that the added nodes can be detected as new nodes. (But then you have to be aware that you break the source configuration because a node can only be contained in exactly one configuration.) " </description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestHierarchicalConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="291" opendate="2007-08-10 01:16:39" fixdate="2007-08-11 14:52:26" resolution="Fixed">
		<buginformation>
			<summary>addNodes() doesn&amp;apos;t trigger auto saving</summary>
			<description>When I add nodes the XMLConfiguration with autoSave enabled the file doen&amp;amp;apos;t change to reflect new nodes. Here is an example
XMLConfiguration config = new XMLConfiguration("c:conf.xml"); 
config.setAutoSave(true) ;
ConfigurationNode childNode = new HierarchicalConfiguration.Node("ChildNodeName","ChildNodeValue");
List nodes = new ArrayList();
nodes.add(childNode);
config.addNodes(null,nodes);
config.xml didn&amp;amp;apos;t change to include child node.
</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="272" opendate="2007-05-22 20:15:02" fixdate="2007-08-20 17:59:56" resolution="Fixed">
		<buginformation>
			<summary>ConfigurationUtils.copy results in escaped "," characters no longer being escaped</summary>
			<description>When using ConfigurationUtils.copy to go between configuration formats any escaped out "," characters are put into the output configuration without the escape character.  This results in a different value being returned from getString calls as it now things the property is a list.  If 4 escape characters are used instead of the expected 1 then the copy will end up with the correct value, but then the original will end up with the escape character as part of the property value.  
Example:
SomeLongProperty=This is a test\, it is only a test

Ends up right in the copy, but not right in the original
SomeOtherProperty=This is also a test\\\\, it is also only a test

After copy:

Missing "\" before ","
SomeLongProperty=This is a test, it is only a test
SomeOtherProperty=This is also a test\, it is also only a test

</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.AbstractConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestAbstractConfigurationBasicFeatures.java</file>
			<file type="M">org.apache.commons.configuration.ConfigurationUtils.java</file>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="294" opendate="2007-08-23 18:04:47" fixdate="2007-08-24 09:38:07" resolution="Fixed">
		<buginformation>
			<summary>Trying to set values in the newly added node (using XMLConfiguration) doesn&amp;apos;t work</summary>
			<description>I&amp;amp;apos;m using XMLConfiguration to manipulate my xml configuration file. Here is what I did,
1) Add a new node using "addNodes"
2) Save the configuration (using save method)
3) The new node gets added to the configuration file   &amp;lt;--- Good
4) Now try setting a value in the just added new node using "setProperty" method.
5) Save the configuration (using save method)
6) The save method still writes the configuration that was in step 3        &amp;lt;------- Bug
Looks like for some reason the save still holds the old configuration in cache that after the add nodes. If I call "reload" after each save then everything works fine. 
Just a setProperty on its own (without addNodes) work fine. It&amp;amp;apos;s only when you try to addNodes and then do setProperty that this fails.
I&amp;amp;apos;ve tried this with the latest nightly build (1.5), released 1.4 and 1.3 --&amp;gt; all of them fail in this situation.
</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.XMLConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="295" opendate="2007-09-10 09:29:59" fixdate="2007-09-14 20:27:56" resolution="Fixed">
		<buginformation>
			<summary>HierarchicalConfiguration.subset(...) misses an entry with the key equal to the subset prefix.</summary>
			<description>Having a HierarchicalConfiguration with entries alike:
    test.sample = subset title
    test.sample.boolean = true
    test.sample.int = 123456
    test.sample.text = I wish it worked!
When performing subset("test.sample"), I get a configuration of only three entries, the "subset title" value is not present (should have an empty string key).
The behaviour is in contradiction to Javadoc of the Configuration interface http://commons.apache.org/configuration/apidocs/org/apache/commons/configuration/Configuration.html#subset(java.lang.String)
Seems to me, that the bug is hidden in iterating the cloned configuration, where only children of the clone are processed, but not the root itself.</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestHierarchicalConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="296" opendate="2007-09-22 15:03:59" fixdate="2007-09-23 16:23:14" resolution="Fixed">
		<buginformation>
			<summary>XMLConfiguration and attributes on the root node</summary>
			<description>With XMLConfiguration it is not possible to change the value of an attribute of the root element.
New attributes on the root level can be created, e.g.:
XMLConfiguration config = new XMLConfiguration();
config.addProperty("[@test]", "true");
would create a new "test" attribute of the root element. However if this configuration is saved and loaded again, a
config.setProperty("[@test]", "false");
only temporarily changes the value: getProperty() returns the new value, but when the configuration is saved, the old value is written.</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.XMLConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="299" opendate="2007-10-25 19:49:42" fixdate="2007-10-25 20:02:57" resolution="Fixed">
		<buginformation>
			<summary>Interpolation of ${const:xxx} variables can cause a ClassCastException</summary>
			<description>If ConstantLookup is used for resolving a variable that is of a different type than String, a ClassCastException can be thrown:
The first access to this variable obtains the value and stores it in an internal cache. If this variable is requested again, the value is fetched from the cache and a type cast to String is performed. This will fail with a ClassCastException.</description>
			<version>1.4</version>
			<fixedVersion>1.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.interpol.TestConstantLookup.java</file>
			<file type="M">org.apache.commons.configuration.interpol.ConstantLookup.java</file>
		</fixedFiles>
	</bug>
	<bug id="302" opendate="2007-12-14 12:37:52" fixdate="2007-12-25 19:06:52" resolution="Fixed">
		<buginformation>
			<summary>FileChangedReloadingStrategy.reloadingRequired() can fail</summary>
			<description>If reloadingRequired() returns true and you call it again before calling reloadingPerformed(), the 2nd time it can return false (but you have not yet reloaded!) because it doesn&amp;amp;apos;t check the file system again until the refresh delay is expired.
Of course this is a very unusual test case (usually you reload immediately) but the behaviour of the method should be consistent in this case too: if reloadingRequired() returns true any subsequent call to this method should return true until reloadingPerformed() is called.
In my project I have fixed the method by promoting the flag called "reloading" to class scope so I that can check whether the previous call returned true or false:
protected boolean reloading = false;
public boolean reloadingRequired()
{
	if (!reloading)
	{
		long now = System.currentTimeMillis();
		if (now &amp;gt; lastChecked + refreshDelay)
		{
			lastChecked = now;
			if (hasChanged())
			{
				reloading = true;
			}
		}
	}
	return reloading;
}
Of course I reset this flag in init() and reloadingPerformed().</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.reloading.FileChangedReloadingStrategy.java</file>
			<file type="M">org.apache.commons.configuration.reloading.TestFileChangedReloadingStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="306" opendate="2008-02-01 19:23:54" fixdate="2008-02-09 16:53:15" resolution="Fixed">
		<buginformation>
			<summary>INIConfiguration: Quoted values should not be trimmed</summary>
			<description>I am reading in .ini files with quoted strings.  Here is an example of a line:
CmdPrompt="[sdog@rosco ~]$ "
In Commons Configuration 1.4, this incorrectly reads in as "[sdog@rosco ~]$ ".  When I saw that this had been addressed in 1.5, I was excited... until I started using 1.5.  Now I don&amp;amp;apos;t get quotes, but I also don&amp;amp;apos;t get my trailing space, which is the reason I&amp;amp;apos;m using quotes in the first place.  I expect the offending line is the final line in the parseValue(String) method of INIConfiguration:
line 403:
        return result.toString().trim();
Expected behavior: INIConfiguration should read in the exact string between the quotes, not a trimmed version.
I&amp;amp;apos;m going back to 1.4 and my own code to strip the quotes.  Please address this as I cannot move to future versions without it.</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestINIConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.INIConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="300" opendate="2007-11-14 18:53:06" fixdate="2008-02-17 23:22:06" resolution="Fixed">
		<buginformation>
			<summary>Can not create a PropertiesConfiguration if the filename contains a &amp;apos;#&amp;apos;</summary>
			<description>It is not possible to load a properties file if there is a &amp;amp;apos;#&amp;amp;apos; in the filename.
To reproduce:
    public static void main(String[] args) throws Exception
    {
        File file = new File("myProperties #1.properties");
        try
        {
            file.createNewFile();
            
            Configuration configuration = new PropertiesConfiguration(file);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        finally
        {
            file.delete();
        }
}
The method that drops the &amp;amp;apos;#&amp;amp;apos; is : ConfigurationUtils.fileFromURL...</description>
			<version>1.4</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.AbstractFileConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.ConfigurationUtils.java</file>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="315" opendate="2008-02-27 06:53:08" fixdate="2008-03-02 21:09:10" resolution="Fixed">
		<buginformation>
			<summary>CombinedConfiguration fire EVENT_COMBINED_INVALIDATE even before the contained configuration is updated</summary>
			<description>CombinedConfiguration.configurationChanged doesn&amp;amp;apos;t check the !event.isBeforeUpdate() and trigger the invalidate call. The invalidate call fire the EVENT_COMBINED_INVALIDATE. so now when a contained config is changed, EVENT_COMBINED_INVALIDATE is fired twice by the CombinedConfiguration. However it should only fire it after the contained FileConfiguration is updated.</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestCombinedConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.CombinedConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="316" opendate="2008-03-12 13:40:31" fixdate="2008-03-23 19:31:18" resolution="Fixed">
		<buginformation>
			<summary>Constructor XMLConfiguration(HierarchicalConfiguration) invalidates text in singular top element</summary>
			<description>When using the XMLConfiguration(HierarchicalConfiguration) constructor for copying an XMLConfiguration e.g. originally read from the XML string &amp;lt;e a="v"&amp;gt;example&amp;lt;/e&amp;gt;, the "example" text can still be retrieved from the copy using getString(""). When saving the copy to an XML file, however, the text is not written; the resulting XML string is just &amp;lt;configuration a="v"/&amp;gt;. I will attach sample code that illustrates this.
Whether it is intended that the name of the top-level element gets lost as well, I don&amp;amp;apos;t know (but that is not my focus here).</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.XMLConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="318" opendate="2008-03-23 19:10:10" fixdate="2008-03-24 16:37:39" resolution="Fixed">
		<buginformation>
			<summary>Constructor XMLConfiguration(HierarchicalConfiguration) loses the name of the root element</summary>
			<description>When creating an XMLConfiguration from another one using the copy constructor the name of the root element (i.e. the document element) is dropped. When the configuration is saved, the default root name ("configuration") is used.</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestHierarchicalConfigurationXMLReader.java</file>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.XMLConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="320" opendate="2008-04-06 15:32:06" fixdate="2008-04-07 15:50:37" resolution="Fixed">
		<buginformation>
			<summary>XMLPropertyListConfiguration is limited to 32 bits integers</summary>
			<description>XMLPropertyListConfiguration parses integers as 32 bits values, but the plist spec doesn&amp;amp;apos;t limit the size of the integers. It should at least support Long values, and maybe BigIntegers.</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.plist.XMLPropertyListConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.plist.TestXMLPropertyListConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="322" opendate="2008-04-30 09:30:14" fixdate="2008-04-30 11:02:35" resolution="Fixed">
		<buginformation>
			<summary>ConfigurationDynaBean doesn&amp;apos;t work with indexed properties stored internally as arrays</summary>
			<description>ConfigurationDynaBean is not fully tested for properties stored in the configuration as arrays. This case is rare because any array added to a configuration is automatically transformed into a List. To reproduce this issue the configuration must be a wrapper of a source that already contains an array, such as a MapConfiguration or a JNDIConfiguration.
</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.AbstractConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.beanutils.ConfigurationDynaBean.java</file>
			<file type="M">org.apache.commons.configuration.beanutils.TestConfigurationDynaBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="328" opendate="2008-05-17 21:49:04" fixdate="2008-05-20 12:11:53" resolution="Fixed">
		<buginformation>
			<summary>XMLConfiguration addNodes() not behaving correctly</summary>
			<description>Things used to work fine in 1.3, but now when I&amp;amp;apos;m trying 1.5 my JUnit test suite is breaking when adding new properties. Here is what I&amp;amp;apos;m doing,
1) I already have a configuration as following,

 &amp;lt;test&amp;gt;
  &amp;lt;property name="isOk"&amp;gt;
    &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
    &amp;lt;default&amp;gt;false&amp;lt;/default&amp;gt;
  &amp;lt;/property&amp;gt;
  &amp;lt;property name="intProperty"&amp;gt;
    &amp;lt;value&amp;gt;900&amp;lt;/value&amp;gt;
    &amp;lt;default&amp;gt;500&amp;lt;/default&amp;gt;
  &amp;lt;/property&amp;gt;
  &amp;lt;property extra="0" name="stringProperty"&amp;gt;
    &amp;lt;default&amp;gt;Bye&amp;lt;/default&amp;gt;
  &amp;lt;/property&amp;gt;
&amp;lt;/test&amp;gt;


2) Now I need to add two new properties under &amp;lt;test&amp;gt;,

&amp;lt;property  name="newFirst"&amp;gt;
  &amp;lt;value&amp;gt;first&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property name="newSecond"&amp;gt;
  &amp;lt;value&amp;gt;second&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;


3) Here is the code I&amp;amp;apos;m using,
        a) First create a new HierarchicalConfiguration.Node

private HierarchicalConfiguration.Node createNode(String name, Object value)  {
    HierarchicalConfiguration.Node node = new HierarchicalConfiguration.Node(name);
    node.setValue(value);
    return node;
}


       b) Add the node to the list

List&amp;lt;HierarchicalConfiguration.Node&amp;gt; attrNodes = new ArrayList&amp;lt;HierarchicalConfiguration.Node&amp;gt;();
Node attrNode = createNode(attrName, newPropertyName);
attrNode.setAttribute(true);
attrNodes.add(attrNode);


       c) Call addNodes on XMLConfiguration,

    conf.addNodes(attrPath, attrNodes);


I run this in a look for each new property I need to add. For first property, I get element count for the test.property as 3 (conf.getMaxIndex(key)) - so I insert at test.property(3), which is right, but for the second property I get element count as 5 --&amp;gt; This is wrong, it should have been 4 (because I just added 1). 
I check the saved the configuration file after adding those two new properties and it looks wrong too. Here is what I get,

&amp;lt;test&amp;gt;
  &amp;lt;property name="isOk"&amp;gt;
    &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
    &amp;lt;default&amp;gt;false&amp;lt;/default&amp;gt;
  &amp;lt;/property&amp;gt;
  &amp;lt;property name="intProperty"&amp;gt;
    &amp;lt;value&amp;gt;900&amp;lt;/value&amp;gt;
    &amp;lt;default&amp;gt;500&amp;lt;/default&amp;gt;
  &amp;lt;/property&amp;gt;
  &amp;lt;property extra="0" name="stringProperty"&amp;gt;
    &amp;lt;value&amp;gt;Hi&amp;lt;/value&amp;gt;
    default&amp;gt;Bye&amp;lt;/default&amp;gt;
  &amp;lt;/property&amp;gt;
  &amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;newFirst&amp;lt;/name&amp;gt;
  &amp;lt;/property&amp;gt;
  &amp;lt;property&amp;gt;
    &amp;lt;value&amp;gt;first&amp;lt;/value&amp;gt;
  &amp;lt;/property&amp;gt;
  &amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;newSecond&amp;lt;/name&amp;gt;
  &amp;lt;/property&amp;gt;
  &amp;lt;property&amp;gt;
    &amp;lt;value&amp;gt;second&amp;lt;/value&amp;gt;
  &amp;lt;/property&amp;gt;
&amp;lt;/test&amp;gt;


The total element count for test.property gives me 7 ==&amp;gt; I was expecting 5.
There seems to have some code change in 1.5 releated to addNodes (for ex., CONFIGURATION-287). I&amp;amp;apos;m not sure if I need to change the way I was calling addNodes before. It works fine with 1.3, but 1.5 completely fails on adding new properties. 
I do need 1.5 for other bug fixes ( CONFIGURATION-268 and some other), but I can&amp;amp;apos;t use it until the addNodes behave correctly. 
Marking this as blocker as I&amp;amp;apos;m blocked because of this issue. If there is a workaround then please let me know.</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.XMLConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="332" opendate="2008-07-04 15:54:10" fixdate="2008-08-01 19:48:30" resolution="Fixed">
		<buginformation>
			<summary>PropertiesConfiguration.save() doesn&amp;apos;t persist properties added through a DataConfiguration</summary>
			<description>There is a regression in Commons Configuration with PropertiesConfiguration wrapped into a DataConfiguration. The properties added through a DataConfiguration aren&amp;amp;apos;t persisted when the configuration is saved, but they can be queried normally. Commons Configuration 1.4 wasn&amp;amp;apos;t affected by this issue.
The following test fails on the last assertion :

public void testSaveWithDataConfiguration() throws ConfigurationException
{
    File file = new File("target/testsave.properties");
    if (file.exists()) {
        assertTrue(file.delete());
    }

    PropertiesConfiguration config = new PropertiesConfiguration(file);

    DataConfiguration dataConfig = new DataConfiguration(config);

    dataConfig.setProperty("foo", "bar");
    assertEquals("bar", config.getProperty("foo"));
    config.save();

    // reload the file
    PropertiesConfiguration config2 = new PropertiesConfiguration(file);
    assertFalse("empty configuration", config2.isEmpty());
}

</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.DataConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="334" opendate="2008-08-11 19:14:12" fixdate="2008-08-12 09:41:47" resolution="Fixed">
		<buginformation>
			<summary>Inconsistent parent nodes in HierarchicalConfiguration when using setRootNode()</summary>
			<description>HierarchicalConfiguration allows setting a root node explicitly using either setRootNode() or setRoot(). The latter exists for backwards compatibility only and operates on the type HierarchicalConfiguration.Node rather than ConfigurationNode. To support a corresponding getRoot() method a new instance of HierarchicalConfiguration.Node is created, and the child nodes of the root node are added to it. Thus these nodes become child nodes of this new node.
If now addProperty() is called for adding new properties to the configuration, the nodes created for the new properties are added to the node passed to the setRootNode() method. So they have a different parent node than the existing nodes.
As long as only methods of the Configuration interface are used for querying or manipulating the configuration, this does not seem to have any strange effects. But when working with the nodes directly it is certainly confusing.</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestHierarchicalConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="339" opendate="2008-10-13 20:10:34" fixdate="2008-10-16 20:21:48" resolution="Fixed">
		<buginformation>
			<summary>ConfigurationConverter does not handle CompositeConfiguration correctly</summary>
			<description>ConfigurationConverter doesn&amp;amp;apos;t seem to respect the ordering of a composite configuration. I am having problems describing the behavior, but I thinks the following test case illustrates it best:
	@Test
	public void showBug() {
		PropertiesConfiguration p = new PropertiesConfiguration();
		p.addProperty("foo", "initial");
		p.addProperty("bar", "$
{foo}
");
		p.addProperty("prefix.foo", "override");
		CompositeConfiguration cfg = new CompositeConfiguration();
		cfg.addConfiguration(p.subset("prefix"));
		cfg.addConfiguration(p);
		// this assertion passes as expected since the subset
		// was added first to the composite configuration
		Assert.assertEquals("override", cfg.getString("bar"));
		// after converting to properties, this assertion fails and
		// reports that the value is &amp;amp;apos;initial&amp;amp;apos;
		Properties properties = ConfigurationConverter.getProperties(cfg);
		Assert.assertEquals("override", properties.getProperty("bar"));
	}</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestCompositeConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.CompositeConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="341" opendate="2008-10-17 18:59:07" fixdate="2008-10-20 19:57:13" resolution="Fixed">
		<buginformation>
			<summary>FileChangedReloadingStrategy not working for SubnodeConfiguration with a CombinedConfiguration parent</summary>
			<description>A SubnodeConfiguration that has a CombinedConfiguration as its parent, doesn&amp;amp;apos;t "hot" reload properties even if the combined configuration consists of XMLConfigurations that have the FileChangedReloadingStrategy set, the combined configuration has the setForceReloadCheck flag set and the SubnodeConfiguration was obtained by calling configurationAt method and passing in true for the "supportUpdates" flag.  
Here&amp;amp;apos;s some code that shows the problem where the final assertion will fail.
 @Test
  public void testSubnodeReadload() throws ConfigurationException 
{
    XMLConfiguration xmlConfiguration = new XMLConfiguration("service.xml");
    FileChangedReloadingStrategy fileReloadStrategy = new FileChangedReloadingStrategy();
    fileReloadStrategy.setRefreshDelay(1000);
    xmlConfiguration.setReloadingStrategy(fileReloadStrategy);
    XMLConfiguration config2 = new XMLConfiguration("environment.xml");
    FileChangedReloadingStrategy fileReloadStrategy2 = new FileChangedReloadingStrategy();
    fileReloadStrategy2.setRefreshDelay(1000);
    xmlConfiguration.setReloadingStrategy(fileReloadStrategy2);

    CombinedConfiguration combinedConfig = new CombinedConfiguration();
    combinedConfig.setForceReloadCheck(true);
    combinedConfig.addConfiguration(xmlConfiguration);
    combinedConfig.addConfiguration(config2);
    int queue0threads2 = xmlConfiguration.getInt("messaging-new.queue(0).threads");
    assert 2 == queue0threads2;

    //change the value in service.xml to 4
    int queue0threads4 = xmlConfiguration.getInt("messaging-new.queue(0).threads");
    assert 4 == queue0threads4;


    SubnodeConfiguration subConfigHier = xmlConfiguration.configurationAt("messaging-new.queue(0)", true);
    int queue0threadsCombinedSub4 = subConfigHier.getInt("threads");
    assert queue0threadsCombinedSub4 == 4;

    //change the value service.xml to 8
    int queue0threadsCombinedSub8 = subConfigHier.getInt("threads");
    assert queue0threadsCombinedSub8 == 8;


    SubnodeConfiguration subNodeConfigParentIsCombinedConfig = combinedConfig.configurationAt("messaging-new.queue(0)", true);
    int queue0threadsSub8 = subNodeConfigParentIsCombinedConfig.getInt("threads");
    assert queue0threadsSub8 == 8;

    //change the value service.xml file to 16
    int queue0threadsSub16 = subNodeConfigParentIsCombinedConfig.getInt("threads");
    assert queue0threadsSub16 == 16;         //THIS TEST FAILS

  }
</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestCombinedConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.CombinedConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="346" opendate="2008-11-03 20:51:22" fixdate="2008-11-03 21:12:09" resolution="Fixed">
		<buginformation>
			<summary>ConfigurationUtils.convertToHierarchical() does not correctly handle properties with multiple values</summary>
			<description>If a property has multiple values, the resulting hierarchical configuration will contain a node whose value is a list with these values. There should, however, be a single node for each value. Some queries, especially those containing indices, do not work on such structures.</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.ConfigurationUtils.java</file>
			<file type="M">org.apache.commons.configuration.TestConfigurationUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="336" opendate="2008-09-29 07:49:06" fixdate="2008-11-04 21:19:45" resolution="Fixed">
		<buginformation>
			<summary>Brackets in property key causes NumberFormatException</summary>
			<description>Hi,
When using brackets in property key we get an exception every time.
Escaping brackets with \ doesn&amp;amp;apos;t help.
Example
#property in property file
test(ef)=false
causes 
java.lang.NumberFormatException: For input string: "ef" at
java.lang.NumberFormatException.forInputString(NumberFormatException.java:48)
        at java.lang.Integer.parseInt(Integer.java:447)
        at java.lang.Integer.parseInt(Integer.java:497)
        at org.apache.commons.configuration.tree.DefaultConfigurationKey
$KeyIterator.checkIndex(DefaultConfigurationKey.java:834)
        at org.apache.commons.configuration.tree.DefaultConfigurationKey
$KeyIterator.nextKey(DefaultConfigurationKey.java:511) at
org.apache.commons.configuration.tree.DefaultExpressionEngine.findNodesForKey(DefaultExpressionEngine.java:462) at
org.apache.commons.configuration.tree.DefaultExpressionEngine.query(DefaultExpressionEngine.java:286) at
org.apache.commons.configuration.HierarchicalConfiguration.fetchNodeList(HierarchicalConfiguration.java:925 at
org.apache.commons.configuration.HierarchicalConfiguration.setProperty(HierarchicalConfiguration.java:735) at
org.apache.commons.configuration.ConfigurationUtils.copy(ConfigurationUtils.java:143) at
org.apache.commons.configuration.ConfigurationUtils.convertToHierarchical(ConfigurationUtils.java:199)  at org.apache.commons.configuration.CombinedConfiguration
$ConfigData.getTransformedRoot(CombinedConfiguration.java:794)  at
org.apache.commons.configuration.CombinedConfiguration.constructCombinedNode(CombinedConfiguration.java:653) at
org.apache.commons.configuration.CombinedConfiguration.getRootNode(CombinedConfiguration.java:504) at
org.apache.commons.configuration.HierarchicalConfiguration.fetchNodeList(HierarchicalConfiguration.java:925) at
org.apache.commons.configuration.HierarchicalConfiguration.getProperty(HierarchicalConfiguration.java:327) at
org.apache.commons.configuration.CombinedConfiguration.getProperty(CombinedConfiguration.java:578) at
org.apache.commons.configuration.AbstractConfiguration.resolveContainerStore(AbstractConfiguration.java:1155) at
org.apache.commons.configuration.AbstractConfiguration.getString(AbstractConfiguration.java:1034)  at
org.apache.commons.configuration.AbstractConfiguration.getString(AbstractConfiguration.java:1017) 
Explanation i got in mailing list from Oliver Heger
I guess you use DefaultConfigurationBuilder for loading a combined 
configuration?
The exception is due to the fact that brackets have a special meaning in 
the query syntax for hierarchical configurations. 
(DefaultConfigurationBuilder transforms all configuration sources into 
hierarchical configurations, so also for properties, which are not 
hierarchical by default, the same rules apply.)
So far escaping brackets or other specific characters in property keys 
is not supported. It seems to be rather unusual to use brackets in 
property keys, so you may well be the first one who noticed this problem.
Unfortunately I don&amp;amp;apos;t have a working solution for this problem right 
now.</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestCombinedConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.CombinedConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.ConfigurationUtils.java</file>
			<file type="M">org.apache.commons.configuration.TestConfigurationUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Cloners" description="is cloned by">404</link>
		</links>
	</bug>
	<bug id="347" opendate="2008-11-05 21:06:22" fixdate="2008-11-06 07:29:11" resolution="Fixed">
		<buginformation>
			<summary>Iterating over the keys of a file-based configuration can cause a ConcurrentModificationException</summary>
			<description>Some implementations of FileConfiguration return an iterator in their getKeys() method that is directly connected to the underlying data store. When now a reload is performed (which can happen at any time) the data store is modified, and the iterator becomes invalid.
This behavior is very confusing because ConcurrentModificationExceptions are typically related to multi-threading access. But even if the code performing the iteration is the only instance that accesses the configuration, the exception can be thrown.</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestFileConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.AbstractFileConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="344" opendate="2008-10-30 11:46:39" fixdate="2008-11-08 15:53:53" resolution="Fixed">
		<buginformation>
			<summary>Deadlock during refresh properties</summary>
			<description>Hi
Commons configurations get itself stuck in deadlock when refreshing
properties using Managed reloading strategy. It seems to me it get stuck
because of fireEvent in reload method. Another access grabs lock on
synchronized (getNodeCombiner()) when trying to rebuild but Combined
configuration is one of the listeners for event es well and it gets
stuck when processing invalidate. Can anyone suggest quick fix please?
Relevant information follows.
Thanks
Pavel
Configuration:


&amp;lt;configuration&amp;gt; 
  &amp;lt;override&amp;gt;
    &amp;lt;system/&amp;gt;    
    &amp;lt;properties fileName="gsxweb.properties" throwExceptionOnMissing="false"
       config-name="gsxweb" config-optional="false" listDelimiter="|"&amp;gt;
       &amp;lt;reloadingStrategy config-class="org.apache.commons.configuration.reloading.ManagedReloadingStrategy"/&amp;gt;      
    &amp;lt;/properties&amp;gt;    
  &amp;lt;/override&amp;gt; 
&amp;lt;/configuration&amp;gt;


Our Reload code:


        int ln = combinedConfiguration.getNumberOfConfigurations();
        int reloaded = 0;
        for (int i = 0; i &amp;lt; ln; i++) {
            Configuration conf = combinedConfiguration.getConfiguration(i);
            if (conf instanceof PropertiesConfiguration) {
                ManagedReloadingStrategy strat = null;
                ReloadingStrategy strategy = ((PropertiesConfiguration) conf).getReloadingStrategy();
                //refresh if managed strategy
                if (strategy instanceof ManagedReloadingStrategy) {
                    ((ManagedReloadingStrategy) strategy).refresh();
                //reload if file changed strategy    
                } else if (strategy instanceof FileChangedReloadingStrategy) {                    
                    ((PropertiesConfiguration) conf).reload();
                }
                reloaded++;
            }
        }




Stack trace of deadlock threads
Name: http-10980-1
State: BLOCKED on
org.apache.commons.configuration.tree.OverrideCombiner@8511bb owned by:
http-10980-6
Total blocked: 154  Total waited: 2

Stack trace: 
org.apache.commons.configuration.CombinedConfiguration.invalidate(CombinedConfiguration.java:474)
org.apache.commons.configuration.CombinedConfiguration.configurationChanged(CombinedConfiguration.java:488)
org.apache.commons.configuration.event.EventSource.fireEvent(EventSource.java:249)
org.apache.commons.configuration.AbstractFileConfiguration.fireEvent(AbstractFileConfiguration.java:911)
org.apache.commons.configuration.AbstractFileConfiguration.reload(AbstractFileConfiguration.java:828)
   - locked java.lang.Object@127e34c
org.apache.commons.configuration.AbstractFileConfiguration.isEmpty(AbstractFileConfiguration.java:927)
org.apache.commons.configuration.reloading.ManagedReloadingStrategy.refresh(ManagedReloadingStrategy.java:91)
com.gsx.properties.PropertyProviderImpl.reset(PropertyProviderImpl.java:203)
   - locked java.lang.Class@109bcda
org.apache.jsp.test.testPropertyProvider_jsp._jspService(testPropertyProvider_jsp.java:60)
org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70)
javax.servlet.http.HttpServlet.service(HttpServlet.java:717)
org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:374)
org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:342)
org.apache.jasper.servlet.JspServlet.service(JspServlet.java:267)
javax.servlet.http.HttpServlet.service(HttpServlet.java:717)
org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290)


Name: http-10980-6
State: BLOCKED on java.lang.Object@127e34c owned by: http-10980-1
Total blocked: 115  Total waited: 2

Stack trace: 
org.apache.commons.configuration.AbstractFileConfiguration.reload(AbstractFileConfiguration.java:814)
org.apache.commons.configuration.AbstractFileConfiguration.getKeys(AbstractFileConfiguration.java:939)
org.apache.commons.configuration.ConfigurationUtils.copy(ConfigurationUtils.java:139)
org.apache.commons.configuration.ConfigurationUtils.convertToHierarchical(ConfigurationUtils.java:199)
org.apache.commons.configuration.CombinedConfiguration
$ConfigData.getTransformedRoot(CombinedConfiguration.java:794)
org.apache.commons.configuration.CombinedConfiguration.constructCombinedNode(CombinedConfiguration.java:653)
org.apache.commons.configuration.CombinedConfiguration.getRootNode(CombinedConfiguration.java:504)
   - locked
org.apache.commons.configuration.tree.OverrideCombiner@8511bb
org.apache.commons.configuration.HierarchicalConfiguration.fetchNodeList(HierarchicalConfiguration.java:925)
org.apache.commons.configuration.HierarchicalConfiguration.getProperty(HierarchicalConfiguration.java:327)
org.apache.commons.configuration.CombinedConfiguration.getProperty(CombinedConfiguration.java:578)
org.apache.commons.configuration.AbstractConfiguration.resolveContainerStore(AbstractConfiguration.java:1155)
org.apache.commons.configuration.AbstractConfiguration.getString(AbstractConfiguration.java:1034)
org.apache.jsp.test.testPropertyProvider_jsp._jspService(testPropertyProvider_jsp.java:69)
org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70)
javax.servlet.http.HttpServlet.service(HttpServlet.java:717)
org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:374)
org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:342)
org.apache.jasper.servlet.JspServlet.service(JspServlet.java:267)
javax.servlet.http.HttpServlet.service(HttpServlet.java:717)

</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.AbstractFileConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestCombinedConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.CombinedConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">390</link>
		</links>
	</bug>
	<bug id="348" opendate="2008-11-08 16:29:36" fixdate="2008-11-08 16:39:13" resolution="Fixed">
		<buginformation>
			<summary>AbstractHierarchicalFileConfiguration does not trigger a reload for the getKeys() method</summary>
			<description>In getKeys() the obligatory call to reload() was forgotten.</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="345" opendate="2008-11-03 10:45:49" fixdate="2008-11-08 21:17:02" resolution="Fixed">
		<buginformation>
			<summary>PropertiesConfiguration does not use the default encoding to load files</summary>
			<description>The piece of code
PropertiesConfiguration.java
    // initialization block to set the encoding before loading the file in the constructors
    {
        setEncoding(DEFAULT_ENCODING);
    }


seems to set correctly the default encoding, but this block is called after "super()" in constructors.
So when using either PropertiesConfiguration(java.io.File file), PropertiesConfiguration(java.lang.String fileName) or PropertiesConfiguration(java.net.URL url), the super() statement is called, and it loads the file without the default encoding.</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.PropertiesConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="349" opendate="2008-11-10 08:27:54" fixdate="2008-11-11 21:25:39" resolution="Fixed">
		<buginformation>
			<summary>XMLConfigurationProvider cannot create a class that extends XMLConfiguration</summary>
			<description>XMLConfigurationProvider in DefaultConfigurationBuilder has default scope. When configuring a new ConfigurationProvider to use a class that extends XMLConfiguration an Exception is raised because the setConfigurationClass method cannot be called from the bean utility classes.</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.DefaultConfigurationBuilder.java</file>
			<file type="M">org.apache.commons.configuration.TestDefaultConfigurationBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="335" opendate="2008-08-14 17:27:13" fixdate="2008-11-30 21:13:58" resolution="Fixed">
		<buginformation>
			<summary>XMLConfiguration: Can&amp;apos;t disable attribute splitting </summary>
			<description>My XML configuration has the following attribute:
&amp;lt;some-element some-attribute="
" /&amp;gt;
But XML Configuration is trying to split this string and trims it after splitting. I don&amp;amp;apos;t need this behaviour, but setting setDelimiterParsingDisabled() just changing delimeter to "|" and not disables attribute trimming.
Need either to disable trimming/splitting if setDelimiterParsingDisabled() is set to TRUE (incompatible change), or add something like setParseAttributesAsIs() that will prevent attributes to be trimmed and splitted</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.XMLConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Cloners" description="is cloned by">400</link>
		</links>
	</bug>
	<bug id="321" opendate="2008-04-13 22:39:21" fixdate="2008-12-01 21:30:55" resolution="Fixed">
		<buginformation>
			<summary>AbstractHierarchicalConfiguration.getKeys(key) doesn&amp;apos;t return the key</summary>
			<description>The getKeys(String prefix) implementation of AbstractHierarchicalConfiguration doesn&amp;amp;apos;t return anything if the prefix used is the key of an existing property. The iterator returned should at least contain the key used as the prefix.
Here is the test method for TestHierarchicalConfiguration, currently the first assertion fails:

public void testGetKeysWithKeyAsPrefix()
{
    Iterator&amp;lt;?&amp;gt; it = config.getKeys("order.key1");
    assertTrue("no key found", it.hasNext());
    assertEquals("1st key", "order.key1", it.next());
    assertFalse("more keys than expected", it.hasNext());
}

</description>
			<version>1.5</version>
			<fixedVersion>1.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestHierarchicalConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="357" opendate="2008-12-30 17:19:05" fixdate="2009-01-02 16:47:15" resolution="Fixed">
		<buginformation>
			<summary>ConversionException message is incorrect for AbstractConfiguration.getBigInteger(String,BigInteger)</summary>
			<description>The message in the ConfigurationException thrown from AbstractConfiguration.getBigInteger(String,BigInteger) reads "BigDecimal" but should read "BigInteger".</description>
			<version>1.5</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.AbstractConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestAbstractConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="368" opendate="2009-03-07 08:42:06" fixdate="2009-03-08 19:26:40" resolution="Fixed">
		<buginformation>
			<summary>CombinedConfiguration: java.util.NoSuchElementException after reload of enclosed SubnodeConfiguration/XMLConfiguration</summary>
			<description>Steps to repeat:

create a XMLConfiguration based on a XML config file (xml file content e.g.:  &amp;lt;config&amp;gt;&amp;lt;foo&amp;gt;&amp;lt;bar&amp;gt;0&amp;lt;/bar&amp;gt;&amp;lt;/for&amp;gt;&amp;lt;/config&amp;gt;)
assign file reloading strategy to the XMLConfiguration
create a SubnodeConfiguration based on this XMLConfiguration (prefix e.g.: &amp;amp;apos;foor&amp;amp;apos;)
create a CombinedConfiguration
add the SubnodeConfiguration to this CombinedConfiguration
get a configuration value from the CombinedConfiguration (e.g. &amp;amp;apos;bar&amp;amp;apos;) -&amp;gt; OK, this works
touch the underlying xml configuration
try to get a configuration value from the CombinedConfiguration again (e.g. &amp;amp;apos;bar&amp;amp;apos;) -&amp;gt;  java.util.NoSuchElementException

See also attached TestCase.</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestSubnodeConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.SubnodeConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestCombinedConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.CombinedConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="369" opendate="2009-03-09 19:50:43" fixdate="2009-03-22 01:00:20" resolution="Fixed">
		<buginformation>
			<summary>SubsetConfiguration ignores local StrLookups</summary>
			<description>For an AbstractConfiguration it is normally possible to register local StrLookup instances. These are simply ignored by the SubsetConfiguration.</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.interpol.ConfigurationInterpolator.java</file>
			<file type="M">org.apache.commons.configuration.TestSubnodeConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.SubnodeConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestSubsetConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.SubsetConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="385" opendate="2009-06-03 19:35:10" fixdate="2009-06-06 15:34:24" resolution="Fixed">
		<buginformation>
			<summary>clearProperty does not generate events in DatabaseConfiguration</summary>
			<description>clearProperty does not generate a EVENT_CLEAR_PROPERTY event because it overrides AbstractConfiguration.clearProperty instead of AbstractConfiguration.clearPropertyDirect as recommended by the superclass.  </description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.DatabaseConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestDatabaseConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="362" opendate="2009-02-02 23:25:52" fixdate="2009-06-21 17:38:14" resolution="Fixed">
		<buginformation>
			<summary>XMLPropertyListConfiguration doesn&amp;apos;t handle empty dictionary correctly</summary>
			<description>Empty "dict" elements are not handled properly.   During printing of a configuration, configuration nodes that have no children and no value are assumed to be "strings" (see XMLPropertyListConfiguration.java:printValue()&amp;amp;apos;s last "else" clause).   &amp;lt;dict/&amp;gt; is parsed in such a way (see startElement() and endElement() of that same file) that it ends up creating a configuration node with no children and no value.  Thus printing out a parsed property list will print &amp;lt;string&amp;gt;null&amp;lt;/string&amp;gt; everywhere an empty dictionary was in the input.</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.plist.XMLPropertyListConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.plist.TestXMLPropertyListConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="388" opendate="2009-06-22 00:56:29" fixdate="2009-06-22 03:35:37" resolution="Fixed">
		<buginformation>
			<summary>When updating an element or attribute that contains the list delimiter the character is escaped even if delimiting is disabled.</summary>
			<description>When updating an attribute or element using an XMLConfiguration, if the new value contains a delimiter the delimiter will be escaped with a &amp;amp;apos;\&amp;amp;apos; even if delimiters have been disabled.</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.XMLConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="393" opendate="2009-08-22 14:47:21" fixdate="2009-08-22 15:42:38" resolution="Fixed">
		<buginformation>
			<summary>BaseConfiguration.clone() does not work with list properties</summary>
			<description>In the clone() implementation the map storing the configuration data is also cloned. For properties with multiple values this map contains lists. Because no deep clone is performed these lists are simply copied into the cloned map. So if the corresponding properties are changed on either the original or the clone, the other object is affected, too.</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.BaseConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestBaseConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="396" opendate="2009-09-14 10:22:11" fixdate="2009-09-27 20:08:40" resolution="Fixed">
		<buginformation>
			<summary>In HierarchicalConfiguration$Node visits the ConfigurationKey  points to the parent path in visitAfterChildren call</summary>
			<description>When visiting a child the key is aggregated to have the child node name, and a call to visitBeforeChildren and grandChildren&amp;amp;apos;s visits are made.
However, before calling  visitAfterChildren,  the resetting of the key to that of it&amp;amp;apos;s parent&amp;amp;apos;s, seems inconsistent.
Last lines in visit(NodeVisitor visitor, ConfigurationKey key) 
            if (key != null)
            {
                key.setLength(length);
            }
            visitor.visitAfterChildren(this, key);</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestHierarchicalConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="399" opendate="2009-10-06 04:59:14" fixdate="2009-11-08 21:15:34" resolution="Fixed">
		<buginformation>
			<summary>interpolator for reading environment variables</summary>
			<description>Hello there,
This is an extension of issue Id CONFIGURATION-284
The "env" interpolator prefix still does not seem to work. On investigation, I noticed that we have a new java class to support reading environment variables from different OSes, but there is no interpolator class (extending StrLookup) that supports the "env" prefix.
Could someone look into this? For the moment, I have put in a class myself locally. Will add to the repository once I find some time.. 
Regards.</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.interpol.ConfigurationInterpolator.java</file>
			<file type="M">org.apache.commons.configuration.TestAbstractConfigurationBasicFeatures.java</file>
		</fixedFiles>
	</bug>
	<bug id="403" opendate="2010-01-14 12:35:59" fixdate="2010-01-23 16:44:50" resolution="Fixed">
		<buginformation>
			<summary>XMLConfiguration isEmpty has altered behaviour between 1.4  and 1.6</summary>
			<description>Given xml configuration file

 
&amp;lt;?xml version="1.0" encoding="ISO-8859-1" ?&amp;gt;
&amp;lt;empty&amp;gt;&amp;lt;/empty&amp;gt;




XMLConfiguration xml = new XMLConfiguration(file);
assertTrue(xml.isEmpty());


isEmpty() returned true on version 1.4 ?, now it returns false, and the configuration contains a single empty string as key.
Not sure if this should be considered a bug, but the documnetation reads: Checks if this configuration is empty. Empty means that there are no keys with any values, though there can be some (empty) nodes. 
</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.XMLConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">6</link>
		</links>
	</bug>
	<bug id="405" opendate="2010-01-15 23:48:32" fixdate="2010-01-24 16:51:10" resolution="Fixed">
		<buginformation>
			<summary>Using load(InputStream) on a new XMLPropertyListConfiguration results in a thrown ConfigurationException</summary>
			<description>I&amp;amp;apos;m trying to use XMLPropertyListConfiguration to load a property-list from a byte array.  My code looks like:
     XMLPropertyListConfiguration plist = new XMLPropertyListConfiguration();
     //	plist.setRootNode(new PListNode());	// HACK to work around internal cast exception
     plist.load(new ByteArrayInputStream(bytes));
This causes a ConfigurationException caused by a class exception (reproduced below).  The exception can be avoided by uncommenting the second line.
org.apache.commons.configuration.ConfigurationException: Unable to parse the configuration file
	at org.apache.commons.configuration.plist.XMLPropertyListConfiguration.load(XMLPropertyListConfiguration.java:250)
	at org.apache.commons.configuration.AbstractHierarchicalFileConfiguration$FileConfigurationDelegate.load(AbstractHierarchicalFileConfiguration.java:449)
	at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:358)
	at org.apache.commons.configuration.AbstractFileConfiguration.load(AbstractFileConfiguration.java:324)
	at org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.load(AbstractHierarchicalFileConfiguration.java:184)
	at testcc.TestCC.main(TestCC.java:29)
Caused by: java.lang.ClassCastException: org.apache.commons.configuration.HierarchicalConfiguration$Node cannot be cast to org.apache.commons.configuration.plist.XMLPropertyListConfiguration$PListNode
	at org.apache.commons.configuration.plist.XMLPropertyListConfiguration$XMLPropertyListHandler.endElement(XMLPropertyListConfiguration.java:534)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.endElement(AbstractSAXParser.java:601)
	at com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDValidator.endNamespaceScope(XMLDTDValidator.java:2077)
	at com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDValidator.handleEndElement(XMLDTDValidator.java:2028)
	at com.sun.org.apache.xerces.internal.impl.dtd.XMLDTDValidator.endElement(XMLDTDValidator.java:901)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanEndElement(XMLDocumentFragmentScannerImpl.java:1774)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2930)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:648)
	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:510)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:807)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737)
	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:107)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205)
	at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:522)
	at org.apache.commons.configuration.plist.XMLPropertyListConfiguration.load(XMLPropertyListConfiguration.java:246)
	... 5 more</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.plist.XMLPropertyListConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.plist.TestXMLPropertyListConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="404" opendate="2010-01-15 05:13:40" fixdate="2010-01-27 07:07:44" resolution="Fixed">
		<buginformation>
			<summary>Revisit - Brackets in property key causes NumberFormatException</summary>
			<description>Hi,
When using brackets in property key we get an exception every time.
Escaping brackets with \ doesn&amp;amp;apos;t help.
Example
#property in property file
test(ef)=false
causes 
java.lang.NumberFormatException: For input string: "ef" at
java.lang.NumberFormatException.forInputString(NumberFormatException.java:48)
        at java.lang.Integer.parseInt(Integer.java:447)
        at java.lang.Integer.parseInt(Integer.java:497)
        at org.apache.commons.configuration.tree.DefaultConfigurationKey
$KeyIterator.checkIndex(DefaultConfigurationKey.java:834)
        at org.apache.commons.configuration.tree.DefaultConfigurationKey
$KeyIterator.nextKey(DefaultConfigurationKey.java:511) at
org.apache.commons.configuration.tree.DefaultExpressionEngine.findNodesForKey(DefaultExpressionEngine.java:462) at
org.apache.commons.configuration.tree.DefaultExpressionEngine.query(DefaultExpressionEngine.java:286) at
org.apache.commons.configuration.HierarchicalConfiguration.fetchNodeList(HierarchicalConfiguration.java:925 at
org.apache.commons.configuration.HierarchicalConfiguration.setProperty(HierarchicalConfiguration.java:735) at
org.apache.commons.configuration.ConfigurationUtils.copy(ConfigurationUtils.java:143) at
org.apache.commons.configuration.ConfigurationUtils.convertToHierarchical(ConfigurationUtils.java:199)  at org.apache.commons.configuration.CombinedConfiguration
$ConfigData.getTransformedRoot(CombinedConfiguration.java:794)  at
org.apache.commons.configuration.CombinedConfiguration.constructCombinedNode(CombinedConfiguration.java:653) at
org.apache.commons.configuration.CombinedConfiguration.getRootNode(CombinedConfiguration.java:504) at
org.apache.commons.configuration.HierarchicalConfiguration.fetchNodeList(HierarchicalConfiguration.java:925) at
org.apache.commons.configuration.HierarchicalConfiguration.getProperty(HierarchicalConfiguration.java:327) at
org.apache.commons.configuration.CombinedConfiguration.getProperty(CombinedConfiguration.java:578) at
org.apache.commons.configuration.AbstractConfiguration.resolveContainerStore(AbstractConfiguration.java:1155) at
org.apache.commons.configuration.AbstractConfiguration.getString(AbstractConfiguration.java:1034)  at
org.apache.commons.configuration.AbstractConfiguration.getString(AbstractConfiguration.java:1017) 
Explanation i got in mailing list from Oliver Heger
I guess you use DefaultConfigurationBuilder for loading a combined 
configuration?
The exception is due to the fact that brackets have a special meaning in 
the query syntax for hierarchical configurations. 
(DefaultConfigurationBuilder transforms all configuration sources into 
hierarchical configurations, so also for properties, which are not 
hierarchical by default, the same rules apply.)
So far escaping brackets or other specific characters in property keys 
is not supported. It seems to be rather unusual to use brackets in 
property keys, so you may well be the first one who noticed this problem.
Unfortunately I don&amp;amp;apos;t have a working solution for this problem right 
now.</description>
			<version>1.5</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.tree.DefaultConfigurationKey.java</file>
			<file type="M">org.apache.commons.configuration.TestHierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.tree.TestDefaultConfigurationKey.java</file>
		</fixedFiles>
		<links>
			<link type="Cloners" description="is a clone of">336</link>
		</links>
	</bug>
	<bug id="407" opendate="2010-02-06 17:04:32" fixdate="2010-02-08 21:04:22" resolution="Fixed">
		<buginformation>
			<summary>HierarchicalINIConfiguration can throw an exception if the global section is accessed concurrently</summary>
			<description>If the global section of a hierarchical INI configuration is requested, a new ViewNode is created which becomes the root node of a new configuration for the global section. Nodes representing properties of the global section are added to this ViewNode. This operation temporarily changes the parent node of these nodes which may cause problems if the method is called by multiple threads concurrently. Because access to a section is a read-only operation, this should be thread-safe.
The probability that this error happens is pretty low IMO. Therefore it should be hard to create a unit test.
The issue can be fixed by synchronizing the add operation to the ViewNode.</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalINIConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestHierarchicalINIConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="409" opendate="2010-03-01 18:05:38" fixdate="2010-03-06 20:46:38" resolution="Fixed">
		<buginformation>
			<summary>Key containing escapedDelimiter does not save() properly</summary>
			<description>It seems that a key containing the escapedDelimiter is stored without the delimiter and the escape is not recreated when saving the configuration. 

test.java

HierarchicalINIConfiguration inicfg = new HierarchicalINIConfiguration();
inicfg.setProperty( "Andrew L.. Cooper.first", "Andrew" );
inicfg.setProperty( "Andrew L.. Cooper.last", "Cooper" );
inicfg.setProperty( "Andrew L.. Cooper.mail", "andrew.cooper@example.com" );
inicfg.save( System.out );
System.out.println( inicfg.get( "Andrew L..Cooper.mail" );


Expected Output

[Andrew L. Cooper]
first = Andrew
last = Cooper
mail = andrew.cooper@example.com

andrew.cooper@example.com


Actual Output

[Andrew L. Cooper]

andrew.cooper@example.com

</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalINIConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestHierarchicalINIConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="408" opendate="2010-02-11 01:01:05" fixdate="2010-03-14 14:35:48" resolution="Fixed">
		<buginformation>
			<summary>When I save a URL as a property value, the forward slashes are getting escaped</summary>
			<description>When I save a URL as a property value, the forward slashes are getting escaped.
ie: 
foo = http:\/\/www.google.com\/
Example Code : 
public static void main(String[] args)
  {
    try
    {
      PropertiesConfiguration config = new PropertiesConfiguration();     
      File newProps = new File("foo.properties");
      config.setProperty("foo", "http://www.google.com/");     
      config.save(newProps);
      
    }
    catch (Exception e){}
  }</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="413" opendate="2010-03-30 23:58:37" fixdate="2010-04-04 18:05:34" resolution="Fixed">
		<buginformation>
			<summary>Subset configuration does not support events</summary>
			<description></description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.SubsetConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="412" opendate="2010-03-17 21:39:01" fixdate="2010-04-07 20:28:47" resolution="Fixed">
		<buginformation>
			<summary>Cannot use DatabaseConfiguration if the datasource has autocommit = false</summary>
			<description>If using a DatabaseConfiguration object with a datasource that has autocommit = false, the setProperty method fails with a duplicate key error.
This happens because in the setProperty method the two calls clearProperty(key) and addProperty(key, value) can retrieve two different connections from the database.</description>
			<version>1.2</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.DatabaseConfigurationTestHelper.java</file>
			<file type="M">org.apache.commons.configuration.DatabaseConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestDatabaseConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="415" opendate="2010-05-19 22:55:24" fixdate="2010-05-29 14:25:16" resolution="Fixed">
		<buginformation>
			<summary>ConfigurationUtils.fileFromURL mangles files with &amp;apos;+&amp;apos; (plus sign) in the name</summary>
			<description>Attached is a sample program that demonstrates the problem.  The following is the method in ConfigurationUtils in question:
public static File fileFromURL(URL url)
{
...
        return new File(URLDecoder.decode(url.getPath()));
...
}

URLDecoder (poorly named) decodes data encoded in the application/x-www-form-urlencoded MIME format.  This format is commonly used to encode HTML form data.  It is not intended for encoding URLs, though the formats are similar.
The operative difference is that the MIME format allows the use of the plus sign (&amp;amp;apos;+&amp;amp;apos;) to represent spaces, whereas URLs must have spaces hex encoded (&amp;amp;apos;%20&amp;amp;apos;).  Files may have plus signs in the name, and therefore, decoding the plus sign as a space produces a different path.
See attached code demonstrating the problem.
Reference:  http://www.w3.org/MarkUp/html-spec/html-spec_8.html#SEC8.2.1
and http://www.ietf.org/rfc/rfc1738.txt</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestFileConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.ConfigurationUtils.java</file>
			<file type="M">org.apache.commons.configuration.TestConfigurationUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="423" opendate="2010-08-27 22:26:41" fixdate="2010-08-27 23:18:49" resolution="Fixed">
		<buginformation>
			<summary>TestFileChangedReloadingStrategy fails incorrectly in testFromClasspath() </summary>
			<description>testFromClassPath() can fail when it should not because of inconsistent escaping of output from PropertiesConfiguration.getURL() and FileChangedReloadingStrategy.getFile().toURL().</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.reloading.TestFileChangedReloadingStrategy.java</file>
		</fixedFiles>
	</bug>
	<bug id="428" opendate="2010-11-10 06:43:46" fixdate="2010-11-11 21:11:41" resolution="Fixed">
		<buginformation>
			<summary>The Windows file path cannot be saved correctly as expected in XMLConfiguration</summary>
			<description>I want to generate a XML as:


&amp;lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&amp;gt;
&amp;lt;Test&amp;gt;
    &amp;lt;Cluster&amp;gt;
        &amp;lt;Server location="C:\Server92"/&amp;gt;
    &amp;lt;/Cluster&amp;gt;
&amp;lt;/Test&amp;gt;


Java Code:
Test.java

XMLConfiguration config = new XMLConfiguration();
config.setRootElementName("Test");
config.addProperty("Cluster.Server[@location]",  "C:\\Server92");
config.save("C:\\NEW.xml");


BUT after running the Java Code, the generated XML looks like:


&amp;lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&amp;gt;
&amp;lt;Test&amp;gt;
&amp;lt;Cluster&amp;gt;
&amp;lt;Server location="C:\\Server92"/&amp;gt;
&amp;lt;/Cluster&amp;gt;
&amp;lt;/Test&amp;gt;


You will find that the location is "C:\ \Server92", BUT what I expected is "C:\Server92".</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.PropertyConverter.java</file>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.XMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestPropertyConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="433" opendate="2011-02-06 17:28:56" fixdate="2011-02-07 20:41:24" resolution="Fixed">
		<buginformation>
			<summary>ConfigurationDynaBean does not work as advertised regarding indexed properties</summary>
			<description>The Javadoc of ConfigurationDynaBean says: "Setting an indexed property always throws an exception." However, there is a reasonable implementation for setting indexed properties.
The get() method for indexed properties tries to figure out whether a property is indexed and throws an exception if not. However, it does not discover all cases of invalid access to non-indexed properties.</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.beanutils.ConfigurationDynaBean.java</file>
			<file type="M">org.apache.commons.configuration.beanutils.TestConfigurationDynaBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="432" opendate="2011-02-02 00:24:09" fixdate="2011-02-07 21:07:12" resolution="Fixed">
		<buginformation>
			<summary>ConfugrationConverter treats properties different by type</summary>
			<description>The ConfigurationConverter is behaving differently depending on if I added an int or a string to a configuration object.
Consider the following code:
01       Configuration confInt = new BaseConfiguration();
02       Configuration confString = new BaseConfiguration();
03       confInt.setProperty("port", 80);
04       confString.setProperty("port", "80");
05       assertEquals(80, confInt.getInt("port"));
06       assertEquals(80, confString.getInt("port"));
07
08       Properties propString = ConfigurationConverter.getProperties(confString);
09       assertEquals("80", propString.getProperty("port"));
10
11       Properties propInt = ConfigurationConverter.getProperties(confInt);
12
13       assertEquals("80", propInt.getProperty("port"));
As you can see the code is basically duplicated one set uses an int the other set uses a String.  However an exception blows out of line 11.
&amp;amp;apos;port&amp;amp;apos; doesn&amp;amp;apos;t map to a List object: 80, a java.lang.Integer
org.apache.commons.configuration.ConversionException: &amp;amp;apos;port&amp;amp;apos; doesn&amp;amp;apos;t map to a List object: 80, a java.lang.Integer
        at org.apache.commons.configuration.AbstractConfiguration.getList(AbstractConfiguration.java:1144)
        at org.apache.commons.configuration.AbstractConfiguration.getList(AbstractConfiguration.java:1109)
        at org.apache.commons.configuration.ConfigurationConverter.getProperties(ConfigurationConverter.java:116) 
I interpreted the interface to mean that everything up to and include line 13 would pass.</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.AbstractConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestAbstractConfigurationBasicFeatures.java</file>
			<file type="M">org.apache.commons.configuration.TestConfigurationConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="434" opendate="2011-02-08 10:02:18" fixdate="2011-02-09 21:16:10" resolution="Fixed">
		<buginformation>
			<summary>In HierarchicalINIConfiguration, after saving a property by calling setProperty() and save() methods, the contents after semicolon disappeared in the saved file.</summary>
			<description>Hi!
I am developing an application using Commons Configuration API.
And I got this problem.
In the ini file like this:
[Environment]
Application Type=any
Class Path=C:\Program Files\jar\manage.jar;C:\Program Files\jar\guiLauncher.jar;C:\Program Files\jar\appStart.jar;%USERPROFILE%;
I changed the value of &amp;amp;apos;Application Type&amp;amp;apos; from &amp;amp;apos;any&amp;amp;apos; to &amp;amp;apos;gui&amp;amp;apos; by using class HierarchicalINIConfiguration.
The value was successfully modified, but instead the value of &amp;amp;apos;Class Path&amp;amp;apos; was cut in the middle.
It is reduced like this :  &amp;amp;apos;Class Path=C:\Program Files\jar\manage.jar&amp;amp;apos;
In my opinion, the Configuration System regards the contents after &amp;amp;apos;;&amp;amp;apos; as comments, which disappeared from the file.
Is this a kind of bug? Or is there a way to show all the contents after &amp;amp;apos;;&amp;amp;apos; properly?
I appreciate if you give comments on this.
Thank you.
</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalINIConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestHierarchicalINIConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="446" opendate="2011-04-15 08:46:38" fixdate="2011-04-20 20:16:24" resolution="Fixed">
		<buginformation>
			<summary>XMLConfiguration removes empty attributes on update</summary>
			<description>Consider an XML configuration file config.xml containing:
&amp;lt;configuration&amp;gt;
&amp;lt;foo attr="aValue"&amp;gt;
&amp;lt;/foo&amp;gt;
&amp;lt;/configuration&amp;gt;
Update the configuration to set an attribute to empty:
    XMLConfiguration config = new XMLConfiguration("config.xml");
    config.setExpressionEngine(new XPathExpressionEngine());
    config.setProperty("foo/@attr", "");
    config.save();
The file has been modified as follows:
&amp;lt;configuration&amp;gt;
&amp;lt;foo/&amp;gt;
&amp;lt;/configuration&amp;gt;
The attribute shouldn&amp;amp;apos;t be removed as an empty attribute is different from a missing attribute.
Method removing the attribute: XMLConfiguration$XMLBuilderVisitor.updateAttribute(Node node, Element elem, String name, char listDelimiter)</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.XMLConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="448" opendate="2011-04-28 23:12:48" fixdate="2011-05-10 05:53:26" resolution="Fixed">
		<buginformation>
			<summary>INI config can&amp;apos;t have = in the value when using : seperators</summary>
			<description>If I load an INI file with these values:
username: identity
password: abc=123
It actually considers the second line to have the key "password: abc" and the value "123:G". </description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalINIConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestHierarchicalINIConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="458" opendate="2011-08-01 20:02:44" fixdate="2011-08-02 20:17:14" resolution="Fixed">
		<buginformation>
			<summary>SubnodeConfiguration.clear() does not work correctly</summary>
			<description>If clear() is called on a SubnodeConfiguration obtained through the configurationAt() method of HierarchicalConfiguration, the node structure of the parent configuration (outside of the area of the sub configuration) may also be manipulated. Properties added to the SubnodeConfiguration after a clear() are not visible from the parent configuration.
The problem is caused by the implementation of the clear() method inherited from AbstractConfiguration. This will call clearProperty() for each property found in the configuration. clearProperty() in turn clears the value of nodes and recursively clears the parent node if it does not contain any data. Here the structure owned by the SubnodeConfiguration can be left so that the parent gets manipulated.
A possible solution would be to provide a specific implementation of clear() for hierarchical configurations. This could also be more efficient than the base implementation.</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestHierarchicalConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="is depended upon by">455</link>
		</links>
	</bug>
	<bug id="455" opendate="2011-07-20 15:53:27" fixdate="2011-08-03 20:27:38" resolution="Fixed">
		<buginformation>
			<summary>HierachicalINIConfiguration section access without dotted notation</summary>
			<description>Setting section properties of previously non-existent Sections using getSection().setProperty() fails.
Using a non existing filename for f, the following produces an empty file.
ini = HierarchicalINIConfiguration(f)
section = ini.getSection("section")
section.setProperty("foo", "bar")
ini.save()
Accessing SubnodeConfigurations after clearing them fails.
using an existing file with an existing section, produces an empty file.
ini = new HierarchicalINIConfiguration(f);
subnode = ini.getSection("section");
if (! subnode.isEmpty() ) 
{
   subnode.clear();
}
subnode.setProperty("foo", "bar");
ini.save();
</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalINIConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestHierarchicalINIConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="depends upon">458</link>
		</links>
	</bug>
	<bug id="456" opendate="2011-07-29 07:32:14" fixdate="2011-08-04 20:09:54" resolution="Fixed">
		<buginformation>
			<summary>AbstractConfiguration.getKeys(String prefix) docs doesn&amp;apos;t say about the point (&amp;apos;.&amp;apos;)</summary>
			<description>For the method org.apache.commons.configuration.AbstractConfiguration.getKeys(String prefix) the documentation doesn&amp;amp;apos;t say that to the prefix will be added a point character (&amp;amp;apos;.&amp;amp;apos;) to filter the keys list (http://commons.apache.org/configuration/apidocs/org/apache/commons/configuration/AbstractConfiguration.html#getKeys%28java.lang.String%29). I discovered it only reading the source.
Maybe I should have known this behaviour, but I think a lot of occasional users could face this unpredictable behaviour. Specifying this would be very helpfull.
Many thanks for your wonderful libraries!</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.AbstractConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.HierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.Configuration.java</file>
		</fixedFiles>
	</bug>
	<bug id="452" opendate="2011-06-10 18:12:42" fixdate="2011-08-04 20:12:10" resolution="Fixed">
		<buginformation>
			<summary>HierarchicalConfiguration with XPathExpressionEngine does not work when setting a new property</summary>
			<description>The following code does not work as expected
Bug.java

public class Bug {

	public static void main(String[] args) {
		try {
			XMLConfiguration config = new XMLConfiguration();
			// works
			config.setProperty("test.property[@attribute]", "value");
			config.setExpressionEngine(new XPathExpressionEngine());
			config.save(System.out);
			// works
			config.setProperty("test/property/@attribute", "value");
                        // does not work
			config.setProperty("test/property/@attribute2", "value");
		} catch (ConfigurationException e) {
			// @FIXME Traitement d&amp;amp;apos;exception par defaut
			throw new RuntimeException(e);
		}

	}
}


hangs with the following exception:
Exception in thread "main" java.lang.IllegalArgumentException: prepareAdd: Passed in key must contain a whitespace!
	at org.apache.commons.configuration.tree.xpath.XPathExpressionEngine.prepareAdd(XPathExpressionEngine.java:223)
	at org.apache.commons.configuration.HierarchicalConfiguration.addPropertyDirect(HierarchicalConfiguration.java:371)
	at org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.addPropertyDirect(AbstractHierarchicalFileConfiguration.java:140)
	at org.apache.commons.configuration.HierarchicalConfiguration.setProperty(HierarchicalConfiguration.java:749)
	at org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.setProperty(AbstractHierarchicalFileConfiguration.java:158)
	at Bug.main(Bug.java:29)
the setProperty() method does not work if the property have to be added. This behavior is not really wanted, because in some generic cases, we don&amp;amp;apos;t know if the property is set or not before trying to set it.</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.tree.xpath.TestXPathExpressionEngine.java</file>
			<file type="M">org.apache.commons.configuration.tree.xpath.XPathExpressionEngine.java</file>
		</fixedFiles>
	</bug>
	<bug id="460" opendate="2011-08-11 17:59:50" fixdate="2011-08-15 20:22:32" resolution="Fixed">
		<buginformation>
			<summary>reloadStrategy does not work for files inside &lt;additional&gt; tag using DefaultConfigurationBuilder</summary>
			<description>In the configuration file that DefaultConfigurationBuilder reads to build a CombinedConfiguration, it&amp;amp;apos;s possible to include configuration file either inside &amp;lt;override&amp;gt; or &amp;lt;additional&amp;gt; xml elements.
Each such declaration, of a file, allows a realodStrategy to be specified (see example below). It appears that the reload occurs only for the files inside &amp;lt;override&amp;gt; and not for the ones inside &amp;lt;additional&amp;gt;.
Example:
&amp;lt;configuration&amp;gt;
  &amp;lt;header&amp;gt;
    &amp;lt;result forceReloadCheck="true"&amp;gt;
      &amp;lt;expressionEngine config-class="org.apache.commons.configuration.tree.xpath.XPathExpressionEngine"/&amp;gt;
    &amp;lt;/result&amp;gt;
  &amp;lt;/header&amp;gt;
  &amp;lt;override&amp;gt;
    &amp;lt;properties fileName="user.properties" config-optional="true"&amp;gt;
      &amp;lt;reloadingStrategy refreshDelay="100"
                         config-class="org.apache.commons.configuration.reloading.FileChangedReloadingStrategy"/&amp;gt;
    &amp;lt;/properties&amp;gt;
  &amp;lt;/override&amp;gt;
  &amp;lt;additional&amp;gt;
    &amp;lt;properties fileName="application.properties"&amp;gt;
      &amp;lt;reloadingStrategy refreshDelay="100"
                         config-class="org.apache.commons.configuration.reloading.FileChangedReloadingStrategy"/&amp;gt;
    &amp;lt;/properties&amp;gt;
  &amp;lt;/additional&amp;gt;
&amp;lt;/configuration&amp;gt;
In above example, both user.properties and application.properties are supposed to reload upon change. However, as tested by the following code, one user.properties gets reloaded:
		DefaultConfigurationBuilder dcb = new DefaultConfigurationBuilder("example.xml");
		Configuration conf = dcb.getConfiguration();
		System.out.println("user: " + conf.getBoolean("user"));
		System.out.println("application: " + conf.getBoolean("application"));
		System.out.println("Change files and then press  to continue...");
		System.in.read();
		System.out.println("user: " + conf.getBoolean("user"));
		System.out.println("application: " + conf.getBoolean("application"));
Output from above code:
user: true
application: true
Change files and then press  to continue...
0 [main] INFO org.apache.commons.configuration.PropertiesConfiguration  - Reloading configuration. URL is file:&amp;lt;snipped&amp;gt;/user.properties
user: false
application: true
</description>
			<version>1.6</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.DefaultConfigurationBuilder.java</file>
			<file type="M">org.apache.commons.configuration.TestDefaultConfigurationBuilder.java</file>
			<file type="M">org.apache.commons.configuration.TestCombinedConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="397" opendate="2009-09-27 21:58:40" fixdate="2011-08-21 02:06:35" resolution="Fixed">
		<buginformation>
			<summary>Schema validation exceptions in a combined configuration often result in an empty configuration being include with no exception or error message.</summary>
			<description>When using DefaultConfigurationBuilder to construct a combined configuration using MultiFileHierarchicalConfiguration (the override file) followed by XMLConfiguration (the default file), if one of the override files has a schema validation error the exception is not thrown nor is an error logged. Instead, an empty configuration is returned.
If schema violation exceptions occur they should always throw exceptions, regardless of whether a file is optional or not.</description>
			<version>1.7</version>
			<fixedVersion>1.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestWebdavConfigurationBuilder.java</file>
			<file type="M">org.apache.commons.configuration.CombinedConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestAbstractConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestMultiFileHierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.DynamicCombinedConfiguration.java</file>
			<file type="D">org.apache.commons.configuration.reloading.TestVFSFileMonitorReloadingStrategy.java</file>
			<file type="M">org.apache.commons.configuration.reloading.FileChangedReloadingStrategy.java</file>
			<file type="M">org.apache.commons.configuration.DefaultFileSystem.java</file>
			<file type="M">org.apache.commons.configuration.TestCatalogResolver.java</file>
			<file type="M">org.apache.commons.configuration.reloading.TestFileChangedReloadingStrategy.java</file>
			<file type="M">org.apache.commons.configuration.AbstractHierarchicalFileConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.XMLConfiguration.java</file>
			<file type="D">org.apache.commons.configuration.reloading.VFSFileMonitorReloadingStrategy.java</file>
			<file type="M">org.apache.commons.configuration.MultiFileHierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.AbstractFileConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.SubnodeConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestCombinedConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestVFSConfigurationBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="476" opendate="2012-01-15 21:21:05" fixdate="2012-01-15 21:33:33" resolution="Fixed">
		<buginformation>
			<summary>Possible ClassCastException in CompositeConfiguration if a special in-memory configuration is used</summary>
			<description>Some methods of CompositeConfiguration expect that the in-memory configuration is of type BaseConfiguration (a configuration of this type is created if no specific in-memory configuration was provided).
However, there are constructors accepting an arbitrary Configuration object as in-memory configuration. If here a configuration is specified which does not extend BaseConfiguration, the casts performed by these methods will fail. The casts should only be performed if possible.
The following methods are affected:

setListDelimiter()
setDelimiterParsingDisabled()

</description>
			<version>1.7</version>
			<fixedVersion>1.8</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestCompositeConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.CompositeConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="471" opendate="2011-11-10 09:14:07" fixdate="2012-01-18 20:55:11" resolution="Fixed">
		<buginformation>
			<summary>CompositeConfiguration delivers value from wrong child</summary>
			<description>I create a composite configuration with two PropertyConfigurations: a user configuration and a default configuration, with the userConfiguration as inMemoryConfiguration.
If both configurations contain the same key, the value from defaultConfiguration is returned although the user configuration was added first. If no inMemoryConfiguration is specified, it&amp;amp;apos;s working ok:
Configuration defaultConf = new PropertiesConfiguration();
defaultConf.addProperty("prop1", "fromDefaultConfig");
Configuration userConf = new PropertiesConfiguration();
userConf.addProperty("prop1", "fromUserConfig");
CompositeConfiguration noMemoryConfig = new CompositeConfiguration();
noMemoryConfig.addConfiguration(userConf);
noMemoryConfig.addConfiguration(defaultConf);
System.out.println("noMemoryConfig: " + noMemoryConfig.getString("prop1")); // Shows "fromUserConfig" 
CompositeConfiguration withMemoryConfig = new CompositeConfiguration(userConf);
withMemoryConfig.addConfiguration(userConf);
withMemoryConfig.addConfiguration(defaultConf);
System.out.println("withMemoryConfig: " + withMemoryConfig.getString("prop1")); // Shows "fromDefaultConfig"</description>
			<version>1.7</version>
			<fixedVersion>1.8</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestCompositeConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.CompositeConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="463" opendate="2011-09-27 19:47:52" fixdate="2012-01-20 20:37:48" resolution="Fixed">
		<buginformation>
			<summary>AbstractFileConfiguration.load(String filename) returns with current directory changed</summary>
			<description>

    PropertiesConfiguration pc = new PropertiesConfiguration();
    ...
    for (String f : cl.getArgs())
    {
        pc.load(f);
    }


Invoked in directory /home/me/test with several relative paths, i.e. ./sub1/a.cfg ./sub2/b.cfg
First file loads successfully. Upon return from the first invocation of pc.load(f), the current directory has been changed to the absolute path of the loaded file (/home/me/test/sub1).  Thus, subsequent paths given as relative references to the original user.dir fail to be found.
If this is the expected behavior, it should be documented.</description>
			<version>1.6</version>
			<fixedVersion>1.8</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.AbstractFileConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="474" opendate="2012-01-06 18:27:58" fixdate="2012-01-21 17:05:10" resolution="Fixed">
		<buginformation>
			<summary>Lists don&amp;apos;t seem to work whean loading INI files</summary>
			<description>After loading an INI file with HierarchicalINIConfiguration, getList() and getStringArray() alaways return 1-size sets even if the parameter is in the right form in the file. To reproduce one only need to create a small INI file with the following content :
key=val1,val2,val3
The following code returns a 1-sized list :


HierarchicalINIConfiguration c = new HierarchicalINIConfiguration();
c.load("test.ini");
List&amp;lt;?&amp;gt; l = c.getList("val");


=&amp;gt; l = ["val1,val2,val3"] instead of ["val1","val2","val3"]
I tried to change the list delimiter, but it didn&amp;amp;apos;t work. Maybe it&amp;amp;apos;s expected, but I haven&amp;amp;apos;t found anything in the doc.</description>
			<version>1.7</version>
			<fixedVersion>1.8</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestHierarchicalINIConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.HierarchicalINIConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="465" opendate="2011-10-03 17:28:04" fixdate="2012-01-22 16:25:04" resolution="Fixed">
		<buginformation>
			<summary>OSGI issue - configuration depends on Jexl 1.0 which does not have OSGI release</summary>
			<description>I updated to use commons-configuration 1.7 (from 1.6) and am running into the following resolution error under Eclipse Equinox OSGi framework.
        An Import-Package could not be resolved. Caused by missing constraint in bundle &amp;lt;org.apache.commons.configuration_1.7.0&amp;gt;
             constraint: &amp;lt;Import-Package: org.apache.commons.jexl; version="0.0.0"&amp;gt;
According to the Import-Package header in 1.7&amp;amp;apos;s MANIFEST.MF, commons-configuration now has a required dependency on org.apache.commons.jexl.  Problem is, there is no OSGi enabled version of Apache Commons jexl that exports this package.
In jexl 2.0 the packages were renamed and org.apache.commons.jexl2 is exported.  The 1.x codeline, although using org.apache.commons.jexl, does not have the appropriate MANIFEST.MF headers to be used as an OSGi bundle.
As such, you cannot consume commons-configuration 1.7 in an OSGi environment.</description>
			<version>1.7</version>
			<fixedVersion>1.8</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.interpol.ExprLookup.java</file>
		</fixedFiles>
	</bug>
	<bug id="481" opendate="2012-02-26 20:27:46" fixdate="2012-02-29 21:15:55" resolution="Fixed">
		<buginformation>
			<summary>Variable interpolation across files broken in 1.7 &amp; 1.8</summary>
			<description>With Commons Configuration 1.6, I was able to declare a variable in a properties file, and then reference it in a XML file using the ${myvar} syntax.
For example:
global.properties:

myvar=abc

test.xml:


&amp;lt;products&amp;gt;
  &amp;lt;product name="abc"&amp;gt;
    &amp;lt;desc&amp;gt;${myvar}-product&amp;lt;/desc&amp;gt;
  &amp;lt;/product&amp;gt;
&amp;lt;/products&amp;gt;


config.xml:


&amp;lt;properties fileName="global.properties"/&amp;gt;
&amp;lt;xml fileName="test.xml" config-name="test"&amp;gt;
  &amp;lt;expressionEngine config-class="org.apache.commons.configuration.tree.xpath.XPathExpressionEngine"/&amp;gt;
&amp;lt;/xml&amp;gt;


When I try to retrieve the value, like so:

combinedConfig.getConfiguration("test").configurationAt("products/product[@name=&amp;amp;apos;abc&amp;amp;apos;]", true).getString("desc")

I get "${myvar}-product" instead of "abc-product".
This was working in Commons Configuration 1.6, but seems to be broken in 1.7 and 1.8.</description>
			<version>1.7</version>
			<fixedVersion>1.9</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestDefaultConfigurationBuilder.java</file>
			<file type="M">org.apache.commons.configuration.DefaultConfigurationBuilder.java</file>
			<file type="M">org.apache.commons.configuration.interpol.ConfigurationInterpolator.java</file>
		</fixedFiles>
	</bug>
	<bug id="487" opendate="2012-03-17 17:03:03" fixdate="2012-03-17 20:11:31" resolution="Fixed">
		<buginformation>
			<summary>DataConfiguration.get() cannot handle a trivial conversion</summary>
			<description>A call to DataConfiguration.get() eventually invokes the PropertyConverter.to() method. Here a number of supported data types are checked and corresponding conversions are done.
However, the case that the value does not need to be converted at all - because it already has the expected type - is not taken into account. This is especially a problem for string values: there is not conversion to string, so the get() method fails even if the value is already a string.</description>
			<version>1.8</version>
			<fixedVersion>1.9</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.PropertyConverter.java</file>
			<file type="M">org.apache.commons.configuration.TestDataConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestPropertyConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="495" opendate="2012-04-25 20:14:15" fixdate="2012-04-26 06:13:50" resolution="Fixed">
		<buginformation>
			<summary>If delimiter parsing is disabled, adding of list properties to an AbstractConfiguration does not work correctly</summary>
			<description>When calling addProperty() or setProperty() with a collection or an array as value it is expected that the single elements are added rather than the container. However, if delimiter parsing is disabled, this check is not performed, and the complex value is directly added. This causes strange effects, for instance when the configuration is saved: then the complex value is just converted to a string. Loading the same configuration again will then produce different values for those properties.</description>
			<version>1.8</version>
			<fixedVersion>1.9</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.HierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="483" opendate="2012-03-01 03:04:14" fixdate="2012-05-30 20:18:45" resolution="Fixed">
		<buginformation>
			<summary>DatabaseConfiguration unclosed resultset</summary>
			<description>An error ocurred when invoking method DatabaseConfiguration.close because the resultset is not closed.
ERROR: [PoolConnection@19859608] close() : Got 1 unclosed ResultSets !
	uk.org.primrose.pool.core.PoolConnection.checkAndCloseResultSets(PoolConnection.java:46)
	uk.org.primrose.pool.core.PoolConnection.close(PoolConnection.java:133)
	org.apache.commons.configuration.DatabaseConfiguration.close(DatabaseConfiguration.java:596)
	org.apache.commons.configuration.DatabaseConfiguration.containsKey(DatabaseConfiguration.java:394)
	org.apache.commons.configuration.CompositeConfiguration.getProperty(CompositeConfiguration.java:190)
	org.apache.commons.configuration.AbstractConfiguration.resolveContainerStore(AbstractConfiguration.java:1160)
	org.apache.commons.configuration.AbstractConfiguration.getString(AbstractConfiguration.java:1035)
	org.apache.commons.configuration.AbstractConfiguration.getString(AbstractConfiguration.java:1018)</description>
			<version>1.6</version>
			<fixedVersion>1.9</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.DatabaseConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="501" opendate="2012-07-30 19:52:32" fixdate="2012-07-30 20:02:13" resolution="Fixed">
		<buginformation>
			<summary>XMLPropertyListConfiguration swallows exceptions about invalid date properties</summary>
			<description>XMLPropertyListConfiguration.PListNode in its setDateValue() method just ignores parsing exceptions caused by invalid date property values. The values are not added to the newly created configuration object.
It makes sense that parsing is robust and error-tolerant. However, rather than simply swallowing exceptions, there should at least be a log output, so that users have a chance to determine that something went wrong during loading of a configuration.
Maybe we can later add a strict mode which fails on loading configuration files with invalid properties.</description>
			<version>1.8</version>
			<fixedVersion>1.9</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.plist.XMLPropertyListConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.plist.TestXMLPropertyListConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="504" opendate="2012-08-21 14:18:46" fixdate="2012-09-21 19:13:10" resolution="Fixed">
		<buginformation>
			<summary>HierarchicalConfiguration clear() method doesn&amp;apos;t remove the node from its parent anymore in XML source</summary>
			<description>Using an XML source file, I used to call HierarchicalConfiguration.clear() on an object to remove it from its parent. Now, it just clear the text and the subnodes, but not the node itself, nor its own attribute, when the file is saved.
Here is the code that works :


ConfigurationNode oldNode = configuration.getRootNode();
oldNode.getParentNode().removeChild(oldNode);


configuration belong to a list of HierarchicalConfiguration that I obtained from configurationsAt. I didn&amp;amp;apos;t see any other way to remove a node I got from that method, without explicit casting to SubnodeConfiguration.</description>
			<version>1.8</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestDefaultConfigurationBuilder.java</file>
			<file type="M">org.apache.commons.configuration.PatternSubtreeConfigurationWrapper.java</file>
			<file type="M">org.apache.commons.configuration.beanutils.XMLBeanDeclaration.java</file>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.MultiFileHierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.DynamicCombinedConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestHierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.HierarchicalConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.DefaultConfigurationBuilder.java</file>
			<file type="M">org.apache.commons.configuration.SubnodeConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="521" opendate="2013-01-17 11:07:47" fixdate="2013-01-23 20:50:49" resolution="Fixed">
		<buginformation>
			<summary>fileFromUrl: decoding of encoded % character does not work</summary>
			<description>If ConfigurationUtils.fileFromUrl(URL) should create a file from a URL containing an enoced % sign (%25), then it does not work.
I saw that the code apache.commons.io now is really different, but seems to work. Why isn&amp;amp;apos;t apache.commons.io directly used?</description>
			<version>1.9</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.ConfigurationUtils.java</file>
			<file type="M">org.apache.commons.configuration.TestConfigurationUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="525" opendate="2013-02-14 19:35:14" fixdate="2013-03-16 17:54:43" resolution="Fixed">
		<buginformation>
			<summary>PropertiesConfigurationLayout does not preserve comments at bottom of a file</summary>
			<description>Example:
helloWorld.properties
hello = world
#this comments would not be preserved</description>
			<version>1.9</version>
			<fixedVersion>2.0, 1.10</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.PropertiesConfigurationLayout.java</file>
			<file type="M">org.apache.commons.configuration.PropertiesConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfigurationLayout.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">552</link>
		</links>
	</bug>
	<bug id="534" opendate="2013-03-16 20:28:18" fixdate="2013-03-17 18:12:06" resolution="Fixed">
		<buginformation>
			<summary>PropertyConfiguration&amp;apos;s handling of includes depends on the existence of a base path</summary>
			<description>PropertiesConfiguration has a property which controls whether include files are allowed. This property does not have a set method, it is set to true automatically if a base path is set. There may be scenarios in which it makes sense to support include files anyway, e.g. if they are specified as fully qualified file names or URIs or can be retrieved by the standard lookup mechanism.
So the set method should be public, and it makes sense to set this property to true per default. If a file contains an include property, the files it refers to should propably be loaded.
Also the get method for the property which controls file inclusion does not conform to the Java Beans specification; returning a boolean, it should start with the prefix is.</description>
			<version>1.9</version>
			<fixedVersion>2.0, 1.10</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.PropertiesConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="537" opendate="2013-03-24 16:19:53" fixdate="2013-03-24 20:28:06" resolution="Fixed">
		<buginformation>
			<summary>Remove deprecated ConfigurationFactory class</summary>
			<description>ConfigurationFactory has been deprecated in the 1.x series. In version 2.0, this class can be removed.</description>
			<version>1.9</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.commons.configuration.ConfigurationFactory.java</file>
			<file type="D">org.apache.commons.configuration.TestConfigurationFactory.java</file>
			<file type="M">org.apache.commons.configuration.TestSubsetConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestEqualBehaviour.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">310</link>
		</links>
	</bug>
	<bug id="516" opendate="2012-11-20 15:44:19" fixdate="2013-04-05 13:12:22" resolution="Fixed">
		<buginformation>
			<summary>PropertiesConfiguration.save escapes double qoutes " unecessary</summary>
			<description>Add a property with a value containing " (double quote character) and saving it back to file will result in the value being modified and unecessary escaping of the quote character.
The reason is that PropertiesConfig calls into the StringEscapeUtils#escapeJavaStyleString that escapes quotes. This is not correct for propertiesfiles. http://docs.oracle.com/javase/7/docs/api/java/util/Properties.html#load(java.io.Reader) says "Escapes are not necessary for single and double quotes"
Here is a test case:
@Test
public void shouldNotEscapeQuotesInTheResult() throws ConfigurationException, IOException {
    final String value = "-Djava.io.tmpdir=\"$
{TEST_TEMP_DIR}
\"";
    PropertiesConfiguration testConfig = new PropertiesConfiguration();
    testConfig.addProperty("testKey1", value);
    File testFile = new File(tempTestDir.getPath() + "prop-with-quotes.properties");
    testConfig.save(testFile) ;
    String testFileContent = FileUtils.readFileToString(testFile);
    Assert.assertTrue(testFileContent.contains(value));
}</description>
			<version>1.9</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.PropertiesConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">515</link>
		</links>
	</bug>
	<bug id="540" opendate="2013-04-11 10:43:44" fixdate="2013-04-13 14:46:37" resolution="Fixed">
		<buginformation>
			<summary>SystemConfiguration copies System.getProperties() instead of directly using it since 1.8</summary>
			<description>In commons-configuration-1.7 the SystemConfiguration directly used the Map of System.getProperties(). Thus when changing the properties inside the SystemConfiguration, the changes were visible in the Map of System.getProperties().
Since commons-configuration-1.8 the SystemConfiguration creates a new Map as a copy of System.getProperties() and thus changes in the SystemConfiguration Map are not visible in the System.getProperties() Map.
In 1.7 this super constructor is used by SystemProperties:


public MapConfiguration(Map map) {
    this.map = map;
}


In 1.9 this super constructor is used by SystemProperties:


public MapConfiguration(Properties props) {
    map = convertPropertiesToMap(props);
}


A fix could look like this:


public SystemConfiguration() {
    super((Map)System.getProperties());
}


This breaks the functionality I expected to be able to use SystemConfiguration as a replacement API for accessing and manipulating SystemProperties. For me this is a regression.
My workaround is currently not to use:


new SystemConfiguration();


but instead use:


new MapConfiguration((Map) System.getProperties());

</description>
			<version>1.8</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.MapConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestSystemConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">581</link>
		</links>
	</bug>
	<bug id="546" opendate="2013-06-09 12:02:54" fixdate="2013-06-12 20:12:58" resolution="Fixed">
		<buginformation>
			<summary>ClassCastException in BeanHelper constructing beans with a list of child beans</summary>
			<description>If you wish to create a bean that has a collection as a property where that collection contains multiple beans, the code crashes as it assumes that you can only ever have single bean declarations as children. 
For example the following brief construct is not possible to build
class A 
{
   String name;
}

class B 
{
   List&amp;lt;A&amp;gt; children;
}

The result is the following stack trace 
Caused by: java.lang.ClassCastException: java.util.ArrayList cannot be cast to org.apache.commons.configuration.beanutils.BeanDeclaration
	at org.apache.commons.configuration.beanutils.BeanHelper.initBean(BeanHelper.java:212)
	at org.apache.commons.configuration.beanutils.TestBeanHelper$TestBeanFactory.createBean(TestBeanHelper.java:579)
	at org.apache.commons.configuration.beanutils.BeanHelper.createBean(BeanHelper.java:342)
	... 33 more
It&amp;amp;apos;s pretty easy to see why when you look at the code beginning line 208:
  for (Map.Entry&amp;lt;String, Object&amp;gt; e : nestedBeans.entrySet())
  {
     String propName = e.getKey();
     Class&amp;lt;?&amp;gt; defaultClass = getDefaultClass(bean, propName);
     initProperty(bean, propName, createBean(
 	   (BeanDeclaration) e.getValue(), defaultClass));
  }

Note the silly assumption that e.getValue() only ever has BeanDeclaration instances, where it could be BeanDeclaration[], or Collection&amp;lt;BeanDeclaration&amp;gt; as other possible options - which is what the above example show. 
Extended version of the existing unit test to follow that illustrates the problem.</description>
			<version>1.8</version>
			<fixedVersion>2.0, 1.10</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.beanutils.TestBeanHelper.java</file>
			<file type="M">org.apache.commons.configuration.beanutils.BeanHelper.java</file>
		</fixedFiles>
	</bug>
	<bug id="547" opendate="2013-06-19 14:05:13" fixdate="2013-06-29 19:17:56" resolution="Duplicate">
		<buginformation>
			<summary>Handling of backslashes</summary>
			<description>Consider the following Unit Test:


    @Test
    public void properlyProcessesBackslash() throws Exception
    {
        final String key = "key";
        final String value = "\\\\";

        final XMLConfiguration xmlConfig = new XMLConfiguration();
        xmlConfig.addProperty(key, value);
        final StringWriter stringWriter = new StringWriter();
        xmlConfig.save(stringWriter);

        final String xml = stringWriter.toString();

        final XMLConfiguration roundTrippedXmlConfig = new XMLConfiguration();
        roundTrippedXmlConfig.load(new StringReader(xml));

        assertEquals(xmlConfig.getString(key), roundTrippedXmlConfig.getString(key));
    }


The test case fails and I think it shouldn&amp;amp;apos;t. The version that introduced this behaviour was 1.7, 1.6 works fine.</description>
			<version>1.7</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.PropertiesConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">418</link>
		</links>
	</bug>
	<bug id="418" opendate="2010-05-31 14:49:18" fixdate="2013-07-13 19:48:04" resolution="Fixed">
		<buginformation>
			<summary>incorrect backslash parsing</summary>
			<description>I am using Commons Configuration (PropertiesConfiguration) and some of my data are windows shares: share1 or share2. The problem is the parsing return different things depending how the keys are defined. For example, these keys
share=\\\\share1
share=\\\\share2
are different than:
share=\\\\share1, \\\\share2
The first one returns two backslashes ("share1" and "share2") and the second returns just one ("\share1" and "\share2"). I think the problem is in PropertyConverter line 525, cos the backslash is hidden twice when multivalue parsing is done:
if (c != delimiter &amp;amp;&amp;amp; c != LIST_ESC_CHAR) 
                {
                    // no, also add escape character
                    token.append(LIST_ESC_CHAR);
                }

In my understanding the second condition produces this strange issue and it should be like this:

if (c != delimiter) 
                {
                    // no, also add escape character
                    token.append(LIST_ESC_CHAR);
                }

Check that cos I can be missing something...
TIA</description>
			<version>1.6</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.PropertiesConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">547</link>
		</links>
	</bug>
	<bug id="552" opendate="2013-08-12 09:54:02" fixdate="2013-08-12 20:26:57" resolution="Duplicate">
		<buginformation>
			<summary>save() causes trailing comments to be deleted</summary>
			<description>If there are comments at the end of a properties file, they are dropped when save is called.</description>
			<version>1.9</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.PropertiesConfigurationLayout.java</file>
			<file type="M">org.apache.commons.configuration.PropertiesConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfigurationLayout.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">525</link>
		</links>
	</bug>
	<bug id="555" opendate="2013-09-24 23:14:48" fixdate="2013-09-29 20:20:08" resolution="Fixed">
		<buginformation>
			<summary>XMLConfiguration doesn&amp;apos;t seem to be preserving whitespace for the current node where xml:space="preserve" is set.</summary>
			<description>if I give this in the configuration:
&amp;lt;test xml:space="preserve"&amp;gt; a b c &amp;lt;/test&amp;gt;
It does not seem to preserve the whitespace on the current node.  However, if I do
&amp;lt;space xml:space="preserve&amp;gt;
   &amp;lt;test&amp;gt; a b c &amp;lt;/test&amp;gt;
&amp;lt;/space&amp;gt;
it does preserve it. I would like to be able to turn on whitespace preservation on the current node without changing the path to my node.
I tested my values by printing out values retrieved from getList() method.</description>
			<version>1.9</version>
			<fixedVersion>2.0, 1.10</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.XMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestXMLConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="567" opendate="2014-02-05 15:52:21" fixdate="2014-04-27 17:35:41" resolution="Fixed">
		<buginformation>
			<summary>XMLBeanDeclaration.getNestedBeanDeclarations() doesn&amp;apos;t escape the node name when query the child node</summary>
			<description>When query the nested bean declaration, the child name may contain the special character. So when call "HierarchicalConfiguration.configurationsAt()", the node name should be escaped by the expression engine first as the following


getConfiguration().getExpressionEngine().nodeKey(node,"")


Call sequence to the problem code:

getNestedBeanDeclarations()
-&amp;gt;nested.put(child.getName(), createBeanDeclaration(child));
   -&amp;gt;List&amp;lt;HierarchicalConfiguration&amp;gt; list = getConfiguration().configurationsAt(node.getName());

</description>
			<version>1.10</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.beanutils.TestXMLBeanDeclaration.java</file>
			<file type="M">org.apache.commons.configuration.beanutils.XMLBeanDeclaration.java</file>
		</fixedFiles>
	</bug>
	<bug id="573" opendate="2014-04-03 08:49:53" fixdate="2014-04-29 20:39:01" resolution="Fixed">
		<buginformation>
			<summary>The values of XML configuration keys having namespace prefix are null</summary>
			<description>Consider such snippet:


public void testElementWithNameSpace() throws Exception {
    String xml =
            "&amp;lt;Config&amp;gt;\n" +
            "&amp;lt;dsig:Transforms xmlns:dsig=\"http://www.w3.org/2000/09/xmldsig#\"&amp;gt;\n" +
            "  &amp;lt;dsig:Transform Algorithm=\"http://www.w3.org/TR/1999/REC-xpath-19991116\"&amp;gt;\n" +
            "    &amp;lt;dsig:XPath xmlns:ietf=\"http://www.ietf.org\" xmlns:pl=\"http://test.test\"&amp;gt;self::pl:policy1&amp;lt;/dsig:XPath&amp;gt;\n" +
            "  &amp;lt;/dsig:Transform&amp;gt;\n" +
            "  &amp;lt;dsig:Transform Algorithm=\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"/&amp;gt;\n" +
            "&amp;lt;/dsig:Transforms&amp;gt;" +
            "&amp;lt;/Config&amp;gt;";
    final XMLConfiguration config = new XMLConfiguration();
    config.setAttributeSplittingDisabled(true);
    config.setDelimiterParsingDisabled(true);
    config.setExpressionEngine(new XPathExpressionEngine());

    config.load(new StringReader(xml));
    System.out.println(ConfigurationUtils.toString(config));
}


It prints all keys as null:


dsig:Transforms/dsig:Transform/dsig:XPath=null
dsig:Transforms/dsig:Transform/dsig:XPath/@xmlns:ietf=null
dsig:Transforms/dsig:Transform/dsig:XPath/@xmlns:pl=null
dsig:Transforms/dsig:Transform/@Algorithm=null
dsig:Transforms/@xmlns:dsig=null


Without XPathExpressionEngine set it prints correct values:


dsig:Transforms.dsig:Transform.dsig:XPath=self::pl:policy1
dsig:Transforms.dsig:Transform.dsig:XPath[@xmlns:ietf]=http://www.ietf.org
dsig:Transforms.dsig:Transform.dsig:XPath[@xmlns:pl]=http://test.test
dsig:Transforms.dsig:Transform[@Algorithm]=[http://www.w3.org/TR/1999/REC-xpath-19991116, http://www.w3.org/TR/2001/REC-xml-c14n-20010315]
dsig:Transforms[@xmlns:dsig]=http://www.w3.org/2000/09/xmldsig#


JXPath 1.3 version dependecy was used.
Am I missing something?</description>
			<version>1.10</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.tree.xpath.TestXPathExpressionEngineInConfig.java</file>
			<file type="M">org.apache.commons.configuration.tree.xpath.ConfigurationNodeIteratorChildren.java</file>
			<file type="M">org.apache.commons.configuration.tree.xpath.ConfigurationNodeIteratorAttribute.java</file>
			<file type="M">org.apache.commons.configuration.tree.xpath.ConfigurationNodeIteratorBase.java</file>
			<file type="M">org.apache.commons.configuration.tree.xpath.TestConfigurationIteratorAttributes.java</file>
			<file type="M">org.apache.commons.configuration.tree.xpath.TestConfigurationNodeIteratorChildren.java</file>
		</fixedFiles>
	</bug>
	<bug id="581" opendate="2014-06-05 06:39:42" fixdate="2014-06-10 20:34:29" resolution="Duplicate">
		<buginformation>
			<summary>SystemConfiguration can not get the correct system property</summary>
			<description>Currently the SystemConfiguration does not handle the scenario like below
  System.setProperty("demoId", "demoValue");
  SystemConfiguration sysConf = new SystemConfiguration ();
  System.setProperties(new Properties(System.getProperties())));
 System.setProperty("demoId", "newDemoValue");
 String propertyFromSysConf = sysConf.getProperty("demoId")
In the above code the value of propertyFromSysConf is demoValue but not newDemoValue, and I think the correct value should be newDemoValue</description>
			<version>1.10</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.MapConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestSystemConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">540</link>
		</links>
	</bug>
	<bug id="570" opendate="2014-03-06 21:34:20" fixdate="2014-09-09 18:00:06" resolution="Fixed">
		<buginformation>
			<summary>Passing SystemConfiguration() into PropertiesConfiguration() can cause a ConcurrentModificationException</summary>
			<description>This was encountered in a release of Accumulo. I&amp;amp;apos;m not sure if this is in the realm of commons configuration, but I figured I should put in a ticket-
A. just in case it is or
B. So others can be aware of this issue
We had a piece of code which interpolates java properties (SystemConfiguration) with other variables. This code worked as follows


      PropertiesConfiguration pconf = new PropertiesConfiguration();
      pconf.append(new SystemConfiguration());
      pconf.addProperty("hack_default_value", this.defaultValue);
      String v = pconf.getString("hack_default_value");


However, after we added a monitor thread which calls System.setProperty before this code is hit, we would occasionally get a ConcurrentModificationException.
I traced it down to pconf.append doing an iteration over the Configuration (AbstractConfiguration, line 1233 in 1.6). The configuration being passed in, SystemConfiguration, is just a MapConfiguration from the result of System.getProperties. This is an exact copy of the map the System maintains.
There are two accessors to that map, setProperty and setProperties in System. Set property basically just falls to Properties.setProperty, while setProperties will copy the existing properties, add new ones, and then replace the object. We are using setProperty in our code.
Properties.setProperty is a synchronized call, so we resolved it by replacing our code with


      PropertiesConfiguration pconf = new PropertiesConfiguration();
      Properties systemProperties = System.getProperties();
      synchronized (systemProperties) {
        pconf.append(new MapConfiguration(systemProperties));
      }
      pconf.addProperty("hack_default_value", this.defaultValue);
      String v = pconf.getString("hack_default_value");


I&amp;amp;apos;m not quite sure if/how it should be handled in commons configuration. I&amp;amp;apos;m thinking if it IS in the scope of this project, then SystemConfiguration should create a snapshot of System.getProperties. Or a new Configuration/configuration flag should be added to create a snapshot of it instead of the map directly.</description>
			<version>1.6</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.SystemConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestSystemConfiguration.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">2425</link>
		</links>
	</bug>
	<bug id="582" opendate="2014-06-18 04:51:18" fixdate="2014-09-10 14:17:51" resolution="Fixed">
		<buginformation>
			<summary>PropertiesConfigurationLayout.getCanonicalComment throws StringIndexOutOfBoundsException when line before property has a single space</summary>
			<description>When a properties file has a line with a single space in it, calling getCanonicalComment(&amp;lt;propertyKey&amp;gt;, false) on the PropertiesConfigurationLayout will throw a StringIndexOutOfBoundsException. Below is the stack trace:


java.lang.StringIndexOutOfBoundsException: String index out of range: 1
	at java.lang.String.charAt(String.java:686)
	at org.apache.commons.configuration.PropertiesConfigurationLayout.stripCommentChar(PropertiesConfigurationLayout.java:768)
	at org.apache.commons.configuration.PropertiesConfigurationLayout.trimComment(PropertiesConfigurationLayout.java:741)
	at org.apache.commons.configuration.PropertiesConfigurationLayout.constructCanonicalComment(PropertiesConfigurationLayout.java:900)
	at org.apache.commons.configuration.PropertiesConfigurationLayout.getCanonicalComment(PropertiesConfigurationLayout.java:212)

</description>
			<version>1.10</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration.PropertiesConfigurationLayout.java</file>
			<file type="M">org.apache.commons.configuration.TestPropertiesConfigurationLayout.java</file>
		</fixedFiles>
	</bug>
	<bug id="310" opendate="2008-02-19 10:57:14" fixdate="2014-09-13 19:10:54" resolution="Duplicate">
		<buginformation>
			<summary>Remove ConfigurationFactory</summary>
			<description>ConfigurationBuilder provides an equivalent alternative to ConfigurationFactory and can be removed. Without this class we no longer depend on Digester.</description>
			<version>1.9</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Task</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.commons.configuration.ConfigurationFactory.java</file>
			<file type="D">org.apache.commons.configuration.TestConfigurationFactory.java</file>
			<file type="M">org.apache.commons.configuration.TestSubsetConfiguration.java</file>
			<file type="M">org.apache.commons.configuration.TestEqualBehaviour.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">537</link>
		</links>
	</bug>
	<bug id="427" opendate="2010-11-03 22:53:18" fixdate="2014-10-29 20:29:12" resolution="Fixed">
		<buginformation>
			<summary>XMLPropertyListConfiguration cannot save arrays in the correct plist form</summary>
			<description>

groovy&amp;gt; import org.apache.commons.configuration.plist.* 
groovy&amp;gt; def config = new XMLPropertyListConfiguration() 
groovy&amp;gt; config.addProperty("things", [&amp;amp;apos;chair&amp;amp;apos;, &amp;amp;apos;hat&amp;amp;apos;, &amp;amp;apos;door&amp;amp;apos;])  
groovy&amp;gt; config.save(System.out) 


results in


&amp;lt;?xml version="1.0"?&amp;gt;
&amp;lt;!DOCTYPE plist SYSTEM "file://localhost/System/Library/DTDs/PropertyList.dtd"&amp;gt;
&amp;lt;plist version="1.0"&amp;gt;
    &amp;lt;dict&amp;gt;
        &amp;lt;key&amp;gt;things&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;chair&amp;lt;/string&amp;gt;

        &amp;lt;key&amp;gt;things&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;hat&amp;lt;/string&amp;gt;

        &amp;lt;key&amp;gt;things&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;door&amp;lt;/string&amp;gt;
    &amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;


expecting


&amp;lt;?xml version="1.0"?&amp;gt;
&amp;lt;!DOCTYPE plist SYSTEM "file://localhost/System/Library/DTDs/PropertyList.dtd"&amp;gt;
&amp;lt;plist version="1.0"&amp;gt;
    &amp;lt;dict&amp;gt;
        &amp;lt;key&amp;gt;things&amp;lt;/key&amp;gt;
        &amp;lt;array&amp;gt;
          &amp;lt;string&amp;gt;chair&amp;lt;/string&amp;gt;
          &amp;lt;string&amp;gt;hat&amp;lt;/string&amp;gt;
          &amp;lt;string&amp;gt;door&amp;lt;/string&amp;gt;
      &amp;lt;/array&amp;gt;
    &amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;

</description>
			<version>1.6</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration2.plist.XMLPropertyListConfiguration.java</file>
			<file type="M">org.apache.commons.configuration2.plist.TestXMLPropertyListConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="564" opendate="2014-01-29 15:43:09" fixdate="2014-11-26 21:24:20" resolution="Fixed">
		<buginformation>
			<summary>PropertiesReader.doParseProperty() version 1.8+ not backward compatible</summary>
			<description>We have a legacy application using a library with properties configuration files where some properties are only keys; Example:
property.key
instead of 
property.key=value or property.key=
Until version 1.7 those properties where present with no value in our CompositeConfiguration instance.
Starting with version 1.8 (introducing a private not overridable regex pattern) those properties are now left out of our application configuration.
Since we don&amp;amp;apos;t own the lib we can&amp;amp;apos;t move to latest version of commons-configuration and are stuck with version 1.7</description>
			<version>1.8</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration2.PropertiesConfiguration.java</file>
			<file type="M">org.apache.commons.configuration2.TestPropertiesConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="598" opendate="2015-04-10 12:38:48" fixdate="2015-04-10 20:13:09" resolution="Fixed">
		<buginformation>
			<summary>There are 2 different ConfigurationBuilder interfaces</summary>
			<description>(This is my first time entering a bug here; at least searching with ConfigurationBuilder here did not bring any relevant issues so I wanted to post this)
There are 2 different ConfigurationBuilder interfaces: 
one is org.apache.commons.configuration2.ConfigurationBuilder and other is
org.apache.commons.configuration2.builder.ConfigurationBuilder
The base package has 


Configuration 	getConfiguration()


while the builder package has 


T 	getConfiguration()


and the (&amp;lt;T extends Configuration&amp;gt; as generic parameter in the interface)
I assume this is a bug, since nothing implements the base package one and all ConfigurationBuilder implementations implement the one in the builder subpackage. It is at least confusing in case the base package one is intended just for clients to implement. Also documentation points to the builder package one.
</description>
			<version>2.0-alpha1</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.apache.commons.configuration2.ConfigurationBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="604" opendate="2015-07-03 18:47:00" fixdate="2015-07-13 20:22:59" resolution="Fixed">
		<buginformation>
			<summary>combining properties which use 3+ part names discards entries as of Commons 1.6+</summary>
			<description>When two property files are combined using commons config 1.5, the aggregate configuration returns an expected result of 6 entries. If Commons configuration 1.6 or higher is used, the resulting set drops to  which is not expected. 
The property names include 2, 3 or 4 part names X.Y, X.Y.Z etc and it appears that as of 1.6 if the names are arranged in 2 part, then 3 part etc that the combiner returns the expected result.
There does not appear to be any release notes etc that would suggest  that this isn&amp;amp;apos;t a defect versus an intended implementation change.
</description>
			<version>1.6</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration2.ConfigurationUtils.java</file>
			<file type="M">org.apache.commons.configuration2.TestConfigurationUtils.java</file>
			<file type="M">org.apache.commons.configuration2.tree.TestOverrideCombiner.java</file>
		</fixedFiles>
	</bug>
	<bug id="609" opendate="2015-08-25 12:19:06" fixdate="2015-09-01 14:27:29" resolution="Fixed">
		<buginformation>
			<summary>When using a VFSFileSystem on a PropertiesConfiguration, processing an include token defaults back to DefaultFileSystem</summary>
			<description>I have uploaded two files to HDFS.

bob.properties:
==
include=fred.properties
==

fred.properties
==
key=value
==

If I load fred.properties and evaluated the "key", value is returned as expected. If I load bob.properties, I get a ConfigurationException.
Here is the code snippet, please change setFileName() to reflect both cases:
		FileSystem fsTest = new VFSFileSystem();
		fsTest.setFileOptionsProvider(new HDFSOptionsProvider());
		Parameters params = new Parameters();
		FileBasedConfigurationBuilder&amp;lt;FileBasedConfiguration&amp;gt; builder =
		    new FileBasedConfigurationBuilder&amp;lt;FileBasedConfiguration&amp;gt;(PropertiesConfiguration.class)
		    .configure(params.fileBased()
		    	.setLocationStrategy(new FileSystemLocationStrategy())
		    	.setBasePath("hdfs://localhost:8020/user/myusername")
		        .setFileName("bob.properties")
		        .setFileSystem(fsTest));
		Configuration config;
		try 
{
			config = builder.getConfiguration();
			System.out.println(config.getString("key"));
		}
 catch (ConfigurationException e) 
{
			e.printStackTrace();
		}

--------------------
HDFSOptionsProvider.java:
==
public class HDFSOptionsProvider implements FileOptionsProvider {
	@Override
	public Map&amp;lt;String, Object&amp;gt; getOptions() 
{
		Map&amp;lt;String, Object&amp;gt; opts = new HashMap&amp;lt;String, Object&amp;gt;();
		opts.put("DefaultProvider", HdfsFileProvider.class);
		return  opts;
	}
}
==
-------------
Here is the Exception trace:
15/08/25 14:14:46 INFO impl.StandardFileSystemManager: Using "/tmp/vfs_cache" as temporary files store.
15/08/25 14:14:47 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable
org.apache.commons.configuration2.ex.ConfigurationException: Unable to load the configuration from the URL hdfs://localhost:8020/user/myusername/fred.properties
	at org.apache.commons.configuration2.io.DefaultFileSystem.getInputStream(DefaultFileSystem.java:56)
	at org.apache.commons.configuration2.io.FileHandler.load(FileHandler.java:979)
	at org.apache.commons.configuration2.io.FileHandler.load(FileHandler.java:740)
	at org.apache.commons.configuration2.PropertiesConfiguration.loadIncludeFile(PropertiesConfiguration.java:1419)
	at org.apache.commons.configuration2.PropertiesConfiguration.propertyLoaded(PropertiesConfiguration.java:571)
	at org.apache.commons.configuration2.PropertiesConfigurationLayout.load(PropertiesConfigurationLayout.java:494)
	at org.apache.commons.configuration2.PropertiesConfiguration.read(PropertiesConfiguration.java:509)
	at org.apache.commons.configuration2.io.FileHandler.loadFromReader(FileHandler.java:1124)
	at org.apache.commons.configuration2.io.FileHandler.loadFromTransformedStream(FileHandler.java:1110)
	at org.apache.commons.configuration2.io.FileHandler.loadFromStream(FileHandler.java:1049)
	at org.apache.commons.configuration2.io.FileHandler.load(FileHandler.java:980)
	at org.apache.commons.configuration2.io.FileHandler.load(FileHandler.java:963)
	at org.apache.commons.configuration2.io.FileHandler.load(FileHandler.java:692)
	at org.apache.commons.configuration2.builder.FileBasedConfigurationBuilder.initFileHandler(FileBasedConfigurationBuilder.java:312)
	at org.apache.commons.configuration2.builder.FileBasedConfigurationBuilder.initResultInstance(FileBasedConfigurationBuilder.java:291)
	at org.apache.commons.configuration2.builder.FileBasedConfigurationBuilder.initResultInstance(FileBasedConfigurationBuilder.java:60)
	at org.apache.commons.configuration2.builder.BasicConfigurationBuilder.createResult(BasicConfigurationBuilder.java:421)
	at org.apache.commons.configuration2.builder.BasicConfigurationBuilder.getConfiguration(BasicConfigurationBuilder.java:285)
	at com.secureops.config.TestLoadConf.main(TestLoadConf.java:33)
Caused by: java.io.IOException: VFS URLs can only be used with VFS APIs
	at org.apache.commons.configuration2.io.VFSFileSystem$VFSURLStreamHandler.openConnection(VFSFileSystem.java:368)
	at java.net.URL.openConnection(URL.java:975)
	at java.net.URL.openStream(URL.java:1041)
	at org.apache.commons.configuration2.io.DefaultFileSystem.getInputStream(DefaultFileSystem.java:52)
	... 18 more</description>
			<version>2.0</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration2.PropertiesConfiguration.java</file>
			<file type="M">org.apache.commons.configuration2.TestPropertiesConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="610" opendate="2015-09-09 19:06:51" fixdate="2015-11-20 20:39:54" resolution="Fixed">
		<buginformation>
			<summary>Improve Configuration Variable Documentation</summary>
			<description>The JavaDoc for Class PropertiesConfiguration  lists a very handy feature of Configuration, which is variable substitution.  The behavior can be seen in the example file on the JavaDoc (good).
But it&amp;amp;apos;s not in the preceding list of features.  It would be nice to have a little writeup describing the intended behavior:  What is supposed to happen if you have an undefined ref?  What about nested refs?  What about circular refs? 
And it was interesting to find that the substitution occurred during get time rather than load (unexpected), and that if one calls the wrong get() method then the substitution will not happen.  (Is that intended behavior?)  This should be called out in the description as well as the individual method JavaDocs.</description>
			<version>2.0-alpha1</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration2.XMLConfiguration.java</file>
			<file type="M">org.apache.commons.configuration2.INIConfiguration.java</file>
			<file type="M">org.apache.commons.configuration2.PropertiesConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="618" opendate="2016-02-05 08:07:39" fixdate="2016-02-07 18:15:12" resolution="Fixed">
		<buginformation>
			<summary>Accessing missing properties of immutable subset throws UndeclaredThrowableException instead of NoSuchElementException</summary>
			<description>When I access a non-existing property of a configuration that has ThrowExceptionOnMissing set an java.lang.reflect.UndeclaredThrowableException is thrown. I think the desired behaviour would be to pass the underlying java.util.NoSuchElementException through from the ImmutableConfigurationInvocationHandler.
Example code:


import org.apache.commons.configuration2.ImmutableConfiguration;
import org.apache.commons.configuration2.PropertiesConfiguration;

public class ImmutableConfigurationStacktraceTest {

	public static void main(String[] args) {
		//create empty PropertiesConfiguration
		PropertiesConfiguration propertiesConfiguration = new PropertiesConfiguration();
		//throw error when non-existing property is requested
		propertiesConfiguration.setThrowExceptionOnMissing(true);
		
		//get immutable subset handled by ImmutableConfigurationInvocationHandler
		ImmutableConfiguration subset = propertiesConfiguration.immutableSubset("");
		
		//this should throw java.util.NoSuchElementException
		subset.getString("whoops!");
	}

}


gives the stacktrace:


Exception in thread "main" java.lang.reflect.UndeclaredThrowableException
	at com.sun.proxy.$Proxy0.getString(Unknown Source)
	at test.main(test.java:10)
Caused by: java.lang.reflect.InvocationTargetException
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at org.apache.commons.configuration2.ImmutableConfigurationInvocationHandler.invoke(ImmutableConfigurationInvocationHandler.java:79)
	... 2 more
Caused by: java.util.NoSuchElementException: Key &amp;amp;apos;whoops!&amp;amp;apos; does not map to an existing object!
	at org.apache.commons.configuration2.AbstractConfiguration.throwMissingPropertyException(AbstractConfiguration.java:1873)
	at org.apache.commons.configuration2.AbstractConfiguration.convert(AbstractConfiguration.java:1784)
	at org.apache.commons.configuration2.AbstractConfiguration.getString(AbstractConfiguration.java:1343)
	... 7 more

</description>
			<version>2.0-beta2</version>
			<fixedVersion>2.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration2.TestImmutableConfiguration.java</file>
			<file type="M">org.apache.commons.configuration2.ImmutableConfigurationInvocationHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="622" opendate="2016-04-13 20:59:47" fixdate="2016-04-16 15:02:56" resolution="Fixed">
		<buginformation>
			<summary>Writing INI file, keys with . become ..</summary>
			<description>Here is sample input config:
[learningtask]
trains.lp = 5
after new INIConfiguration(conf).write() it becomes:
[learningtask]
trains..lp = 5
seems related to the escaping of keys in the ExpressionEngine</description>
			<version>2.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration2.INIConfiguration.java</file>
			<file type="M">org.apache.commons.configuration2.TestINIConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="632" opendate="2016-05-23 01:25:02" fixdate="2016-05-27 18:46:00" resolution="Fixed">
		<buginformation>
			<summary>Composite configuration list variable interpolation return first element only</summary>
			<description>CompositeConfiguration.getStringArray, with variable interpolation returns only the first element of the list
e.g.
key1=a,b,c
key2=$
{key1}

CompositeConfiguration.getStringArray(key2) = a</description>
			<version>1.9</version>
			<fixedVersion>2.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration2.CompositeConfiguration.java</file>
			<file type="M">org.apache.commons.configuration2.TestCompositeConfiguration.java</file>
		</fixedFiles>
	</bug>
	<bug id="634" opendate="2016-06-21 17:32:18" fixdate="2016-06-24 15:52:33" resolution="Fixed">
		<buginformation>
			<summary>BasePath is incorrectly computed while init of CompositeConfiguration</summary>
			<description>The base path should be just "app" instead of 

file:///C:/path/to/app

 because of which the code is trying to locate config.properties in the following path: 

C:\path\to\file:\C:\path\to\app\config.properties

In the below snippet basepath is good when handler.locate() runs but fails when running handler.load()
org.apache.commons.configuration2.builder.FileLocatorUtils

protected void initFileHandler(FileHandler handler)
            throws ConfigurationException
    {
        initEncoding(handler);
        if (handler.isLocationDefined())
        {
            handler.locate();
            handler.load();
        }
    }


If you would like to see the basepath being manipulated keep a debug point at file.isFile() in the below snippet
org.apache.commons.configuration2.io.HomeDirectoryLocationStrategy

public URL locate(FileSystem fileSystem, FileLocator locator)
    {
        if (StringUtils.isNotEmpty(locator.getFileName()))
        {
            String basePath = fetchBasePath(locator);
            File file =
                    FileLocatorUtils.constructFile(basePath,
                            locator.getFileName());
            if (file.isFile())
            {
                return FileLocatorUtils.convertFileToURL(file);
            }
        }

        return null;
    }


Snippet failing:


CompositeConfiguration config = new CompositeConfiguration();
config.addConfiguration(new SystemConfiguration());

final FileBasedConfigurationBuilder&amp;lt;FileBasedConfiguration&amp;gt; homeDirConfigurationBuilder
        = new FileBasedConfigurationBuilder&amp;lt;&amp;gt;(PropertiesConfiguration.class);
final PropertiesBuilderParameters homeDirProperties = new Parameters().properties();
final FileBasedConfigurationBuilder&amp;lt;FileBasedConfiguration&amp;gt; configurationBuilder
        = new FileBasedConfigurationBuilder&amp;lt;&amp;gt;(PropertiesConfiguration.class);
final PropertiesBuilderParameters properties = new Parameters().properties();

FileBasedConfigurationBuilder&amp;lt;FileBasedConfiguration&amp;gt; builder1 = homeDirConfigurationBuilder.configure(
        homeDirProperties.setLocationStrategy(new HomeDirectoryLocationStrategy(true))
                .setBasePath("app")
                .setListDelimiterHandler(new DefaultListDelimiterHandler(&amp;amp;apos;,&amp;amp;apos;))
                .setFileName("config.properties"));
FileBasedConfigurationBuilder&amp;lt;FileBasedConfiguration&amp;gt; builder2 = configurationBuilder.configure(
        properties.setLocationStrategy(new ClasspathLocationStrategy())
                .setListDelimiterHandler(new DefaultListDelimiterHandler(&amp;amp;apos;,&amp;amp;apos;))
                .setFileName("default_config.properties"));
try {
    // TODO Fails due to a bug in commons configuration FileLocatorUtils#createFullyInitializedLocatorFromURL
    config.addConfiguration(builder1.getConfiguration());
    config.addConfiguration(builder2.getConfiguration());
} catch (ConfigurationException e) {
    log.warn(configMarker, "Failed to load the properties file, loading defaults", e);
}


Stacktrace:

org.apache.commons.configuration2.ex.ConfigurationException: Could not locate: org.apache.commons.configuration2.io.FileLocator@353d0772[fileName=config.properties,basePath=file:///C:/path/to/app/,sourceURL=file:/C:/path/to/app/config.properties,encoding=ISO-8859-1,fileSystem=&amp;lt;null&amp;gt;,locationStrategy=org.apache.commons.configuration2.io.HomeDirectoryLocationStrategy@10e41621]
	at org.apache.commons.configuration2.io.FileLocatorUtils.locateOrThrow(FileLocatorUtils.java:346) ~[commons-configuration2-2.0.jar:2.0]
	at org.apache.commons.configuration2.io.FileHandler.load(FileHandler.java:972) ~[commons-configuration2-2.0.jar:2.0]
	at org.apache.commons.configuration2.io.FileHandler.load(FileHandler.java:702) ~[commons-configuration2-2.0.jar:2.0]
	at org.apache.commons.configuration2.builder.FileBasedConfigurationBuilder.initFileHandler(FileBasedConfigurationBuilder.java:312) ~[commons-configuration2-2.0.jar:2.0]
	at org.apache.commons.configuration2.builder.FileBasedConfigurationBuilder.initResultInstance(FileBasedConfigurationBuilder.java:291) ~[commons-configuration2-2.0.jar:2.0]
	at org.apache.commons.configuration2.builder.FileBasedConfigurationBuilder.initResultInstance(FileBasedConfigurationBuilder.java:60) ~[commons-configuration2-2.0.jar:2.0]
	at org.apache.commons.configuration2.builder.BasicConfigurationBuilder.createResult(BasicConfigurationBuilder.java:421) ~[commons-configuration2-2.0.jar:2.0]
	at org.apache.commons.configuration2.builder.BasicConfigurationBuilder.getConfiguration(BasicConfigurationBuilder.java:285) ~[commons-configuration2-2.0.jar:2.0]

</description>
			<version>2.0</version>
			<fixedVersion>2.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration2.io.FileLocatorUtils.java</file>
			<file type="M">org.apache.commons.configuration2.builder.TestFileBasedConfigurationBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="627" opendate="2016-05-04 22:54:12" fixdate="2016-10-06 19:54:41" resolution="Fixed">
		<buginformation>
			<summary>BeanHelper exception on XMLConfiguration builder.getConfiguration()</summary>
			<description>Creating an XMLConfiguration from a file with a builder:


builder =
        new FileBasedConfigurationBuilder&amp;lt;XMLConfiguration&amp;gt;(
                XMLConfiguration.class)
                        .configure(params.xml()
                                .setFileName(
                                        propsFile.getCanonicalPath())
                                .setValidating(false));

config = builder.getConfiguration();


Causes a non-halting exception originating in org.apache.commons.configuration2.beanutils.BeanHelper, method 
private static boolean isPropertyWriteable(Object bean, String propName) with parameters XMLConfiguration, "validating".
The exception:

    May 04, 2016 3:29:26 PM org.apache.commons.beanutils.FluentPropertyBeanIntrospector introspect
    WARNING: Error when creating PropertyDescriptor for public final void org.apache.commons.configuration2.AbstractConfiguration.setProperty(java.lang.String,java.lang.Object)! Ignoring this property.
    java.beans.IntrospectionException: bad write method arg count: public final void org.apache.commons.configuration2.AbstractConfiguration.setProperty(java.lang.String,java.lang.Object)
        at java.beans.PropertyDescriptor.findPropertyType(PropertyDescriptor.java:657)
        at java.beans.PropertyDescriptor.setWriteMethod(PropertyDescriptor.java:327)
        at java.beans.PropertyDescriptor.&amp;lt;init&amp;gt;(PropertyDescriptor.java:139)
        at org.apache.commons.beanutils.FluentPropertyBeanIntrospector.createFluentPropertyDescritor(FluentPropertyBeanIntrospector.java:177)
        at org.apache.commons.beanutils.FluentPropertyBeanIntrospector.introspect(FluentPropertyBeanIntrospector.java:140)
        at org.apache.commons.beanutils.PropertyUtilsBean.fetchIntrospectionData(PropertyUtilsBean.java:2234)
        at org.apache.commons.beanutils.PropertyUtilsBean.getIntrospectionData(PropertyUtilsBean.java:2215)
        at org.apache.commons.beanutils.PropertyUtilsBean.getPropertyDescriptor(PropertyUtilsBean.java:950)
        at org.apache.commons.beanutils.PropertyUtilsBean.isWriteable(PropertyUtilsBean.java:1466)
        at org.apache.commons.configuration2.beanutils.BeanHelper.isPropertyWriteable(BeanHelper.java:521)
        at org.apache.commons.configuration2.beanutils.BeanHelper.initProperty(BeanHelper.java:357)
        at org.apache.commons.configuration2.beanutils.BeanHelper.initBeanProperties(BeanHelper.java:273)
        at org.apache.commons.configuration2.beanutils.BeanHelper.initBean(BeanHelper.java:192)
        at org.apache.commons.configuration2.beanutils.BeanHelper$BeanCreationContextImpl.initBean(BeanHelper.java:669)
        at org.apache.commons.configuration2.beanutils.DefaultBeanFactory.initBeanInstance(DefaultBeanFactory.java:162)
        at org.apache.commons.configuration2.beanutils.DefaultBeanFactory.createBean(DefaultBeanFactory.java:116)
        at org.apache.commons.configuration2.beanutils.BeanHelper.createBean(BeanHelper.java:459)
        at org.apache.commons.configuration2.beanutils.BeanHelper.createBean(BeanHelper.java:479)
        at org.apache.commons.configuration2.beanutils.BeanHelper.createBean(BeanHelper.java:492)
        at org.apache.commons.configuration2.builder.BasicConfigurationBuilder.createResultInstance(BasicConfigurationBuilder.java:447)
        at org.apache.commons.configuration2.builder.BasicConfigurationBuilder.createResult(BasicConfigurationBuilder.java:417)
    at org.apache.commons.configuration2.builder.BasicConfigurationBuilder.getConfiguration(BasicConfigurationBuilder.java:285)

</description>
			<version>2.0</version>
			<fixedVersion>2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration2.builder.TestPropertiesBuilderParametersImpl.java</file>
		</fixedFiles>
		<links>
			<link type="Blocker" description="is blocked by">492</link>
			<link type="Duplicate" description="duplicates">477</link>
		</links>
	</bug>
	<bug id="640" opendate="2016-09-29 15:03:27" fixdate="2016-10-07 20:08:29" resolution="Fixed">
		<buginformation>
			<summary>Colon in properties file value no longer unescaped in commons configuration 2</summary>
			<description>A properties file create with java escape a colon in for example a path like 
C:\test as 

C\:\\test

When reading this property value in commons configuration the colon is unescaped, C:\test
When reading the property value in commons configuration 2 the colon is no longer unescaped, C\:\test.
Snipped of the code I used for reading the property



final ConfigurationBuilder&amp;lt;PropertiesConfiguration&amp;gt; builder =                            new FileBasedConfigurationBuilder&amp;lt;&amp;gt;(PropertiesConfiguration.class).configure(new Parameters().properties().setFile(path.toFile());

final PropertiesConfiguration propertiesConfiguration = builder.getConfiguration();
Assert.assertEquals("C:\\test", propertiesConfiguration.getString("test2"));



I&amp;amp;apos;ve read this section so I&amp;amp;apos;m aware of the changes to escaping, but I&amp;amp;apos;m not sure how the escaping of the colon fits into this and if there is a way around this.</description>
			<version>2.1</version>
			<fixedVersion>2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.configuration2.PropertiesConfiguration.java</file>
			<file type="M">org.apache.commons.configuration2.TestPropertiesConfiguration.java</file>
		</fixedFiles>
	</bug>
</bugrepository>