<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Fri Nov 18 22:30:18 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/MATH-631/MATH-631.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[MATH-631] &quot;RegulaFalsiSolver&quot; failure</title>
                <link>https://issues.apache.org/jira/browse/MATH-631</link>
                <project id="12310485" key="MATH">Commons Math</project>
                    <description>&lt;p&gt;The following unit test:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
@Test
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void testBug() {
    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; UnivariateRealFunction f = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; UnivariateRealFunction() {
            @Override
            &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; value(&lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; x) {
                &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Math&lt;/span&gt;.exp(x) - &lt;span class=&quot;code-object&quot;&gt;Math&lt;/span&gt;.pow(&lt;span class=&quot;code-object&quot;&gt;Math&lt;/span&gt;.PI, 3.0);
            }
        };

    UnivariateRealSolver solver = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RegulaFalsiSolver();
    &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; root = solver.solve(100, f, 1, 10);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;fails with&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;illegal state: maximal count (100) exceeded: evaluations
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Using &quot;PegasusSolver&quot;, the answer is found after 17 evaluations.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12515172">MATH-631</key>
            <summary>&quot;RegulaFalsiSolver&quot; failure</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="erans">Gilles</reporter>
                        <labels>
                    </labels>
                <created>Sat, 23 Jul 2011 23:48:27 +0000</created>
                <updated>Sat, 24 Mar 2012 16:16:52 +0000</updated>
                            <resolved>Thu, 8 Sep 2011 12:13:59 +0000</resolved>
                                                    <fixVersion>3.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                <comments>
                            <comment id="13070074" author="erans" created="Sat, 23 Jul 2011 23:50:45 +0000"  >&lt;p&gt;Reported by Axel Kramer in &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-599&quot; title=&quot;Re-implementation of Secant-based root finding algorithms&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MATH-599&quot;&gt;&lt;del&gt;MATH-599&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="13080478" author="erans" created="Sat, 6 Aug 2011 22:44:58 +0000"  >&lt;p&gt;The problem was due to the fact that at some point, the update formula always gave the same value: Nothing was being updated and the loop went on until the number of evaluations was exhausted.&lt;/p&gt;

&lt;p&gt;I&apos;ve committed a tentative solution in revision 1154614.&lt;br/&gt;
However:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;I&apos;m not sure that it doesn&apos;t have any adverse side-effects on the bracketing property.&lt;/li&gt;
	&lt;li&gt;It is quite probably not a pristine &quot;regula falsi&quot; algorithm anymore.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Please review.&lt;/p&gt;

&lt;p&gt;Anyways, for the function that triggered the problem (see &quot;testIssue631&quot; in &quot;RegulaFalsiSolverTest.java&quot;), the (modified) &lt;tt&gt;RegulaFalsiSolver&lt;/tt&gt; takes 3624 evaluations (versus 17 for &lt;tt&gt;PegasusSolver&lt;/tt&gt;). We should probably add a word of warning in the class Javadoc.&lt;/p&gt;</comment>
                            <comment id="13080575" author="dhendriks" created="Sun, 7 Aug 2011 13:03:23 +0000"  >&lt;p&gt;I just got back from a 3 week vacation, so I couldn&apos;t reply earlier.&lt;/p&gt;

&lt;p&gt;The documentation for the RegulaFalsiSolver states: &quot;Unlike the Secant method, convergence is guaranteed by maintaining a bracketed solution.&quot; While this is theoretically true, in this case it is not so, because (if I understand correctly) only a single bound is updated repeatedly, and the update is too small to matter (has no effect), due to the double representation.&lt;/p&gt;

&lt;p&gt;The change you propose (which is difficult to see as you also change other things in the same commit) is to modify x0 and f0 if the new value of x and x1 are equal. As I see it, this changes the algorithm, and it is no longer the Regula Falsi method as known from literature. I&apos;m therefore against this change.&lt;/p&gt;

&lt;p&gt;The problem that is identified in this issue is very similar to the well-known problem of the Regula Falsi method: it converges very slowly for certain problems, due to one side being updated all the time, while the other one stays the same. The Illinois and Pegasus algorithms solve exactly this problem, and are well-documented in literature.&lt;/p&gt;

&lt;p&gt;I therefore think it would be better if the RegulaFalsiSolver kept it&apos;s original implementation, and for this problem the Illinois or Pegasus method should then be used instead.&lt;/p&gt;

&lt;p&gt;The other changes (if statements to switch with default, extracting bound switch statements, etc) can be kept, if you wish.&lt;/p&gt;

&lt;p&gt;The suggestion to add a warning to the Secant and Regula Falsi solvers that this is a possible problem, and the solution (use Illinois or Pegasus), would indeed be a good idea. In general, adding a note that the Illinois and Pegasus algorithms perform better, would be a good idea regardless of this issue.&lt;/p&gt;

&lt;p&gt;Once more, to be clear, I don&apos;t think this issue is a bug. It is a result of the limited convergence of the Regula Falsi method combined with the implications of limited double precision. The limited convergence of the algorithm is a property of the algorithm, and should in my opinion not be changed. I also don&apos;t think that trying to work around the limited double precision would be a good idea.&lt;/p&gt;</comment>
                            <comment id="13080608" author="erans" created="Sun, 7 Aug 2011 17:38:03 +0000"  >&lt;p&gt;&amp;gt; (which is difficult to see as you also change other things in the same commit)&lt;/p&gt;

&lt;p&gt;Sorry, but I didn&apos;t hit the solution right away, i.e. before changing those two additional little things to make the code clearer (for me)...&lt;/p&gt;

&lt;p&gt;The only actual change is that the &lt;tt&gt;REGULA_FALSI&lt;/tt&gt; enum was not used (i.e. with the &lt;tt&gt;switch&lt;/tt&gt; little change, the corresponding &lt;tt&gt;case&lt;/tt&gt; would have been empty) whereas now it contains the update of x0 to avoid an infinite loop.&lt;/p&gt;

&lt;p&gt;The other (cosmetic) change was to take these two statements&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
x1 = x;
f1 = fx;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;out of the previous &lt;tt&gt;if&lt;/tt&gt; and &lt;tt&gt;else&lt;/tt&gt; blocks, as they were duplicated there (which made me wonder whether it was a bug that they were &lt;em&gt;not&lt;/em&gt; different).&lt;/p&gt;

&lt;p&gt;You say&lt;br/&gt;
&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt; convergence is guaranteed &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;br/&gt;
&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt; it converges very slowly for certain problems, &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;br/&gt;
&amp;gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt; The limited convergence of the algorithm is a property of the algorithm, &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;All the above imply that one expects that the algorithm &lt;em&gt;can&lt;/em&gt; find the solution.&lt;br/&gt;
However, in this implementation, it &lt;em&gt;can&apos;t&lt;/em&gt;.&lt;br/&gt;
Therefore there is a bug, somewhere.&lt;/p&gt;

&lt;p&gt;I agree that it is a limitation of double precision. But, IMHO, leaving the code as-is is not a good idea because because it leads to the impression that the &quot;Regula Falsi&quot; mathematical algorithm can fail to converge, which is not correct (IIUC).&lt;br/&gt;
Therefore, we could add a comment stating that the &lt;em&gt;implementation&lt;/em&gt; with limited precision can fail to converge but that would be akin to saying to users: &quot;Here is a code, but don&apos;t use it.&quot;&lt;br/&gt;
Personally, I would prefer to say: &quot;Because of limited precision, the implementation can fail to converge. In those cases, we slightly modified the original algorithm in order to avoid failure.&quot;&lt;/p&gt;</comment>
                            <comment id="13080629" author="luc" created="Sun, 7 Aug 2011 19:06:52 +0000"  >&lt;blockquote&gt;
&lt;p&gt;All the above imply that one expects that the algorithm can find the solution.&lt;br/&gt;
However, in this implementation, it can&apos;t.&lt;br/&gt;
Therefore there is a bug, somewhere.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Here, the bug is in the algorithm itself, not in the implementation.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;it leads to the impression that the &quot;Regula Falsi&quot; mathematical algorithm can fail to converge, which is not correct (IIUC).&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It is correct. Regula Falsi fails to converge, or rather it can take a too large number of iteration to converge. This is exactly this behavior that has lead to the construction of other algorithms like Illinois or Pegasus. These two algorithms try to detect the case when the same end of the interval is always updated, and the other end remains unchanged. Once they have detected this, they slightly change the value at one end to trick the linear evaluation into choosing a value that is very likely to have the required sign to update this other end. In fact, in many cases depending of the sign of the curvature near the root, as soon as one end is very close to the root the linear interpolation will always remain on the same side of the root and hence will update this end.&lt;/p&gt;

&lt;p&gt;I agree with Dennis here, the change needed to ensure convergence is not tool long is to choose a better algorithm, such as Illinois, Pegasus ... or the nth order bracketing solver I recently added. Regula Falsi should remain the reference Regula Falsi, just as secant and Brent should remain the reference ones.&lt;/p&gt;</comment>
                            <comment id="13080641" author="erans" created="Sun, 7 Aug 2011 20:28:56 +0000"  >&lt;p&gt;&quot;fails to converge&quot; and &quot;large number of iteration to converge&quot; are completely different things.&lt;/p&gt;

&lt;p&gt;The documentation says: &quot;convergence is guaranteed&quot;. Is &lt;em&gt;that&lt;/em&gt; false?&lt;/p&gt;

&lt;p&gt;Moreover, for the function reported in this issue, the problem is not that it takes a large number iterations, it is that the loop is &lt;em&gt;literally&lt;/em&gt; infinite because at some point, nothing changes anymore.&lt;/p&gt;

&lt;p&gt;Stated otherwise: If implemented with larger/infinite precision, would it converge?&lt;br/&gt;
In the affirmative, then in my opinion it means that the plain &quot;Regula Falsi&quot; method cannot be implemented with double precision (or that its convergence properties are not as stated in the docs) or that there is a bug in the implementation.&lt;/p&gt;

&lt;p&gt;In the former case, why keep something that will never be used (as we&apos;ll warn users that they should use &quot;Pegasus&quot; or &quot;Illinois&quot; but certainly not &quot;RegulaFalsi&quot;)? IMHO, we could just state in the docs that &quot;RegulaFalsi&quot; was not implemented because it is demonstrably less efficient and sometimes fails to work.&lt;/p&gt;

&lt;p&gt;A less radical alternative would be to keep the test I&apos;ve inserted in the code (at line 186) and throw a &lt;tt&gt;MathIllegalStateException&lt;/tt&gt; if it passes. The previous behaviour (infinite loop) is a bug in CM.&lt;/p&gt;</comment>
                            <comment id="13080665" author="luc" created="Sun, 7 Aug 2011 21:00:25 +0000"  >&lt;blockquote&gt;
&lt;p&gt;The documentation says: &quot;convergence is guaranteed&quot;. Is that false?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It depends on what is called convergence.&lt;br/&gt;
If convergence is evaluated only as the best of the two endpoints (measured along y axis), yes convergence is guaranteed and in this case it is very slow. This is what appears in many analysis books.&lt;br/&gt;
If convergence is evaluated by ensuring the bracketing interval (measured along x axis) reduces to zero (i.e. both endpoints converge to the root), convergence is not guaranteed.&lt;/p&gt;

&lt;p&gt;The first case is achieved with our implementation by using the function accuracy setting. The second case is achieved with our implementation by using relative accuracy and absolute accuracy settings, which both are computed along x axis.&lt;/p&gt;

&lt;p&gt;I fear that there are several different references about convergence for this method (just as for Brent). So we already are able to implement both views.&lt;/p&gt;

&lt;p&gt;Without any change to our implementation, we reach convergence for this example by setting the function accuracy to 7.4e-13 or above, and it is slow (about 3500 evaluations). The default setting for function accuracy is very low (1.0e-15) and in this case, given the variation rate of the function near the root, it is equivalent to completely ignore convergence on y on only check the convergence on the interval length along x. &lt;/p&gt;</comment>
                            <comment id="13080673" author="psteitz" created="Sun, 7 Aug 2011 21:41:03 +0000"  >&lt;p&gt;I think we should either stick with the standard implementation of Regula Falsi or drop the class altogether.  Different rootfinders are going to perform better / worse for different functions and parameter values and I don&apos;t think it is a good idea to try to modify our implementations of the algorithms to try to work around their shortcomings for problem instances for which they are not well-suited.  It is much better to stick with standard algorithms, document them, and leave it to users to choose among implementations.  &lt;/p&gt;

&lt;p&gt;Regula Falsi is not a good general-purpose rootfinder, but it does perform well for some problems (or parts of problems) and the original submission was a working implementation, so I would say revert the changes and keep it.&lt;/p&gt;</comment>
                            <comment id="13080675" author="erans" created="Sun, 7 Aug 2011 21:42:13 +0000"  >&lt;p&gt;I understand what you say. But however you put it, there is a bug; if not in the implementation, then in the API. It is not expected behaviour that something which must be changed (function accuracy threshold) to ensure correct behaviour (avoid an undetected infinite loop) is not a mandatory parameter.&lt;br/&gt;
To debug this, I started by raising the absolute accuracy threshold (the first default parameter, thus the first obvious thing to do) to 1e-2 and was stunned that I couldn&apos;t get anything after 1000000 iterations!&lt;/p&gt;

&lt;p&gt;Therefore I maintain that, at a minimum, we put a line that will detect the infinite loop and raise an exception identifying &lt;em&gt;that&lt;/em&gt; problem and not let the user wait for &quot;TooManyEvaluationsException&quot; to be raised, as that will induce the unaware (me) to just allow more evaluations and try again.&lt;/p&gt;

&lt;p&gt;This solution does not corrupt the algorithm; it just adds protection.&lt;/p&gt;</comment>
                            <comment id="13080682" author="psteitz" created="Sun, 7 Aug 2011 22:11:18 +0000"  >&lt;p&gt;I disagree with your statement about setting accuracy.  All of this is configurable and if not set, you get the (documented) defaults.  This is all documented.  If the documentation is not clear, then we can improve it.  A user who applies Regula Falsi to the problem instance being examined here will end up maxing iterations.  I see no problem with that and in fact I see it as &lt;b&gt;correct&lt;/b&gt; behavior (given the documented execution context of the algorithm).  &lt;/p&gt;</comment>
                            <comment id="13080689" author="erans" created="Sun, 7 Aug 2011 22:57:05 +0000"  >&lt;p&gt;How can it be correct to have an infinite loop?&lt;br/&gt;
The problem is not slow convergence, which you can overcome by allowing more iterations.&lt;br/&gt;
It is too low function value accuracy which you cannot overcome by allowing more iterations. Thus my point: We must raise the appropriate exception (the doc for which will state that it can happen if the function value accuracy is too low for the implementation to provide a result).&lt;/p&gt;</comment>
                            <comment id="13080690" author="erans" created="Sun, 7 Aug 2011 23:06:51 +0000"  >&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;My comment starting with &amp;quot;I understand what you say.&amp;quot; was an answer to Luc. I hadn&amp;#39;t read Phil&amp;#39;s previous one which was posted while I was writing mine.&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;I agree that it is better not to change the standard algorithm, as I indicated in my first comment.&lt;br/&gt;
The fix which I&apos;m proposing is not an algorithm change, it is an implementation detail similar to the many hundreds checks performed in CM. Just it is not a precondition test. It adequately indicates that something went wrong and can help the user figure out what it was. It makes the implementation more robust.&lt;/p&gt;</comment>
                            <comment id="13080695" author="erans" created="Sun, 7 Aug 2011 23:46:58 +0000"  >&lt;p&gt;The original implementation, for the &quot;problem instance being examined here&quot;, would find the root with absolute accuracy lower than &lt;b&gt;10e-12&lt;/b&gt; after 3560 evaluations (note: using the default value of &lt;b&gt;1e-6&lt;/b&gt;).&lt;br/&gt;
In fact, the root was found, at the required accuracy, after around 2200 evaluations.&lt;/p&gt;

&lt;p&gt;That does not sound like correct behavior.&lt;br/&gt;
The problem is that, &quot;x0&quot; never being updated, the convergence test always fails... until we reach the limitation of double precision, which entails an infinite loop.&lt;/p&gt;

&lt;p&gt;In fact my fix should not be necessary, as things have gone awry before it would apply, but there is a bug to fix nonetheless.&lt;/p&gt;</comment>
                            <comment id="13080697" author="psteitz" created="Sun, 7 Aug 2011 23:54:54 +0000"  >&lt;p&gt;Is there actually a possibility of an infinite loop in the code?  Looks to me like the max evaluations bound will stop the while loop, so there is no potential for an infinite loop.  Apologies if I am misreading the code and the loop can fail to terminate, in which case I agree this is a problem.  (As a side note, from a style perspective, I prefer to explicitly bound loops to avoid this kind of uncertainty.  The natural hard bound here is the evaluation count.)&lt;/p&gt;

&lt;p&gt;Trying to detect when a sequence of iterates has gotten &quot;stuck&quot; and is destined to hit max iterations without converging is walking down a path that I think is unwise for us and users.  I see no reason not to stick with the standard impl here, which is nicely documented in the original submission.  Trying to workaround numerical problems in simple algorithms and change contracts to include these workarounds is asking for trouble - both for us and users.  In a simple case like this, it is much better to just stick with the documented algorithm, which should in this case (again unless I am missing something) end with max evaluations exceeded, which is the right exception to report. &lt;/p&gt;</comment>
                            <comment id="13080792" author="erans" created="Mon, 8 Aug 2011 07:24:48 +0000"  >&lt;p&gt;I surely hope that your last post is not an answer to mine from 23:46.&lt;/p&gt;

&lt;p&gt;I&apos;ll try to answer here in case it was in reply to my previous one (23:06).&lt;br/&gt;
Of course, the code will not run forever because of the &quot;maxeval&quot; bound.&lt;br/&gt;
But it will run for a time that depends on the value of &quot;maxeval&quot; &lt;b&gt;with no added benefit&lt;/b&gt;! From a certain point, the loop is like&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;) {
  &lt;span class=&quot;code-comment&quot;&gt;// Do nothing useful, just count!
&lt;/span&gt;  ++count;
  &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (count &amp;gt; maxeval) {
    &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TooManyEvalutationsException(maxeval);
  }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;from a style perspective, I prefer to explicitly bound loops&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;From an &lt;b&gt;OO&lt;/b&gt; style perspective, the reuse of the &quot;Incrementor&quot; is better, and you don&apos;t have to rewrite the same &quot;test and throw exception if failed&quot; boiler plate code each time there is such a loop.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Trying to detect when a sequence of iterates has gotten &quot;stuck&quot; and is destined to hit max iterations without converging is walking down a path that I think is unwise for us and users.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Why?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I see no reason not to stick with the standard impl here&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;A busy idle loop is a compelling reason IMO.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Trying to workaround numerical problems in simple algorithms and change contracts to include these workarounds is asking for trouble&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The trouble is there with the current implementation. I&apos;m not criticizing the contribution but this issue shows that it should be made more robust.&lt;br/&gt;
Also, the documentation about &quot;convergence is guaranteed&quot; can lead to a false sense of security.&lt;br/&gt;
Moreover, is the &quot;regula falsi&quot; a mathematical algorithm (with a guaranteed converge property if computed with infinite precision) or a numerical one, which this issue proves that it cannot guarantee convergence? In the former case, CM&apos;s (numerical) implementation is not strictly &quot;regula falsi&quot; and there would be no such thing as respect for an original/standard implementation if we can make it more robust.&lt;/p&gt;

&lt;p&gt;I&apos;ve already indicated that the fix does &lt;b&gt;not&lt;/b&gt; change the contract; it stops the busy idle loop as soon as it is detected and reports that it won&apos;t do any good to increase the number of iterations. That&apos;s &lt;em&gt;obviously&lt;/em&gt; more robust.&lt;/p&gt;

&lt;p&gt;Now, if you were answering to my 23:46 post, I&apos;d be glad to read an explanation of why the first paragraph describes expected behaviour.&lt;/p&gt;
</comment>
                            <comment id="13080817" author="luc" created="Mon, 8 Aug 2011 08:37:31 +0000"  >&lt;p&gt;I don&apos;t understand.&lt;/p&gt;

&lt;p&gt;When it was created, the maxIteration threshold was exactly designed for this purpose: get out of infinite loops. It was later renamed maxEvaluation but the purpose is still the same: don&apos;t get stuck. The reason why we get stuck is irrelevant. This limit is simply a safety limit, not a tuning parameter that user are expected to raise once they hit it hoping they will converge later on. If they could raise it later, then they should set it to an appropriate value at once. Hitting it implies computation failed. Regula falsi just like any algorithm can fail if applied with the wrong parameters or to the wrong function (in fact, even with a good setting of function accuracy, it fails to converge if we require a bracket selection on the side that does not move).&lt;/p&gt;

&lt;p&gt;Also detecting one bound is not updated is what Illinois and Pegasus are designed to do.&lt;/p&gt;

&lt;p&gt;So I think we should completely get rid of regula falsi and only keep the better algorithms.&lt;/p&gt;</comment>
                            <comment id="13080873" author="erans" created="Mon, 8 Aug 2011 09:57:17 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I think we should completely get rid of regula falsi and only keep the better algorithms.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That was my first idea. And that would be the simplest one, the safest one, and the only viable one as I can&apos;t seem to state clearly enough that&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Problem 1: When the doc says &quot;guaranteed convergence&quot;, the algorithm should provide the answer.&lt;/li&gt;
	&lt;li&gt;Problem 2: When the (absolute) accuracy threshold is set to 1e-6, and the correct root &lt;b&gt;is&lt;/b&gt; found (after 2200 iterations) within the requirements, it should be returned, instead running idle and finish with an exception&lt;/li&gt;
&lt;/ul&gt;


&lt;blockquote&gt;
&lt;p&gt;The reason why we get stuck is irrelevant.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;But why? If we &lt;b&gt;can&lt;/b&gt; be more precise on the cause of failure, why not do it?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This limit is simply a safety limit, not a tuning parameter that user are expected to raise once they hit it hoping they will converge later on.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;In principle, some possible use would be to compare the efficiency of different methods where the main criterion would be a time limitation (assuming that the function evaluation time overwhelms the of the root solver algorithm time). Thus with the function that triggered this issue:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;If you set maxeval to &quot;3000&quot;, then both &quot;Pegasus&quot; (17 evals) and (a fixed) &quot;RegulaFalsi&quot; (2200 evals) would fill the bill.&lt;/li&gt;
	&lt;li&gt;If you set maxeval to &quot;1000&quot;, then &quot;Pegasus&quot; will be the only winner.&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;Anyways:&lt;br/&gt;
+1 for removing it altogether, and include somewhere the reason for it not being implemented in CM.&lt;/p&gt;</comment>
                            <comment id="13081104" author="psteitz" created="Mon, 8 Aug 2011 18:23:21 +0000"  >&lt;p&gt;I am OK removing Reg Falsi, but stand by comments above that it is a very bad idea to hack standard algorithms and agree with Luc that maxing iterations is the correct behavior in the case we have been discussing. It is kind of pathetic that the compromise is to drop the impl; but in this case I don&apos;t see it as a real loss, since I can&apos;t think of any examples where Reg Falsi would be preferable to one of the other solvers - other than for educational purposes.&lt;/p&gt;</comment>
                            <comment id="13081150" author="erans" created="Mon, 8 Aug 2011 19:36:19 +0000"  >&lt;p&gt;May I please know &lt;b&gt;why it is OK that a bit of code does loop counting and repeatedly computes the same thing&lt;/b&gt;!&lt;/p&gt;

&lt;p&gt;You insist that I&apos;d be &quot;hacking&quot; whereas I&apos;ve indicated 3 or 4 times that there is no hack: just a test that will exit the loop as soon as it detects that the algorithm has failed. Why is it not understandable that the busy loop could last for a long time? The function is potentially evaluated millions of times at the same point. What if the evaluation is costly? Imagine the computation running for days, only to discover that it could have been be stopped after a few seconds. Is that robust code and good advertising for a library? It is one thing to expect that there are unknown bugs in CM, but refusing to fix a known one is so obviously wrong...&lt;/p&gt;

&lt;p&gt;And may I please know &lt;b&gt;why it is OK that an algorithm that finds the right result does not return it&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;I had been trying to provide alternatives to the removal, but I can&apos;t do much more if nobody answers the above two questions.&lt;br/&gt;
You just have to run the code and print &quot;x&quot; and &quot;x1&quot; to see what is going on!&lt;/p&gt;</comment>
                            <comment id="13081162" author="luc" created="Mon, 8 Aug 2011 20:13:43 +0000"  >&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
May I please know *why it is OK that a bit of code does loop counting and repeatedly computes the same thing!*
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We didn&apos;t say that. We said that regula falsi is a standard &lt;b&gt;bad&lt;/b&gt; algorithm. We said that very smart people have enhanced it 40 years ago and the enhanced versions are known and already implemented in Commons Math. These algorithms are &lt;b&gt;not&lt;/b&gt; blind loop counters and they insert smart target shifts that &lt;b&gt;prevent&lt;/b&gt; the behavior we observe here. These algorithms not only detect the problem, they fix it! They allow convergence along x. They allow selection of the side of the root.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
The function is potentially evaluated millions of times at the same point.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The maxEvaluations is already here to prevent this, and in fact now this max number is even mandatory in the solve method (you placed it if I remember correctly). So the function is called millions of time only if the users wishes so by setting the maxEvaluations to a number in the range of millions.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
And may I please know *why it is OK that an algorithm that finds the right result does not &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; it.*
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the user asked for a convergence in x or for a convergence on y on the side that is stuck, then no, the algorithm did not find the right result. One of its bounds converged but the users asked for something else.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
You just have to run the code and print &lt;span class=&quot;code-quote&quot;&gt;&quot;x&quot;&lt;/span&gt; and &lt;span class=&quot;code-quote&quot;&gt;&quot;x1&quot;&lt;/span&gt; to see what is going on!
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We know exactly what is going on! We know the algorithm is stuck. We know why it is stuck. We know why it did not detect it is stuck. We know it will finally hit the safety maxEvaluation threshold that is just waiting for that. And we know that removing all these problems is done by using other algorithms which are already there.&lt;/p&gt;

&lt;p&gt;Regula falsi is doomed. It is an algorithm used for educational purposes, or for comparison purposes, not something suited for production use. It is just like Euler for ODE (and by the way we did implement Euler for ODE and we don&apos;t recommend users to use it as we also did implement better algorithms that were also designed by smart mathematicians decades ago).&lt;/p&gt;</comment>
                            <comment id="13081180" author="erans" created="Mon, 8 Aug 2011 20:44:19 +0000"  >&lt;blockquote&gt;
&lt;p&gt;So the function is called millions of time only if the users wishes so by setting the maxEvaluations to &lt;br/&gt;
a number in the range of millions.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;No, the user should not expect that any algorithm will go on a single iteration more than necessary.&lt;br/&gt;
This is a plain bug.&lt;/p&gt;

&lt;p&gt;Why do you see that a test such as I proposed (exit the loop early) is wrong while CM (and any good program) is full of tests to ensure that you don&apos;t do useless computations?&lt;br/&gt;
This has nothing to do with &quot;regula falsi&quot;, it is robustness in the face of limited precision.&lt;/p&gt;

&lt;p&gt;However, if you insist that the bug (failing to detect that it is stuck) is really an integral part of the algorithm, then removing it is not a &quot;pathetic compromise&quot;, it is the only right thing to do!&lt;/p&gt;
</comment>
                            <comment id="13081193" author="psteitz" created="Mon, 8 Aug 2011 21:00:20 +0000"  >&lt;p&gt;This is a pointless discussion.  Gilles, you obviously don&apos;t share the views that Luc and I have on implementing standard algorithms or even what the meaning of a numerical algorithm is. Some algorithms perform well for some classes of problems and not others.  There is an art to choosing the right algorithm for the problem instance at hand.  If we modify our implementations to try to work around shortcomings of the algorithms we implement, then we are not implementing the standard algorithms, and we need to document exactly what it is that we are implementing, because in this case we are actually making it harder for users to choose (because we are not longer advertising standard numerics).  This is what I meant when I said it is both harder for us (because we have to document the hacks and non-standard contracts) and users (because the standard numerical analysis theory that they may be using to choose among implementations will no longer apply).  It is, IMO, a &quot;pathetic compromise&quot; to drop the implementation because we can&apos;t agree on what it means to implement the algorithm. So be it. Lets drop it and resolve this issue as &quot;fixed.&quot;&lt;/p&gt;</comment>
                            <comment id="13081242" author="erans" created="Mon, 8 Aug 2011 22:08:19 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Gilles, you obviously don&apos;t share the views that Luc and I have on implementing standard algorithms &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That&apos;s simply &lt;em&gt;not true&lt;/em&gt;.&lt;br/&gt;
I was the one pointing out that standard algorithms should have precedence: Please recall that it was considered fine that &quot;Levenberg-Marquardt&quot; and &quot;Brent&quot; would be, unknowingly to the user, &quot;twisted&quot; to perform &lt;em&gt;non-standard&lt;/em&gt; convergences check.&lt;br/&gt;
In those cases, there was the risk that the result of the algorithm would not be the same as the reference implementation.&lt;/p&gt;

&lt;p&gt;In this case, there is no such thing as deviating from standard numerics! It was just a matter of throwing the right exception. So: &quot;The algorithm fails? Let&apos;s tell it sooner rather than later.&quot;&lt;/p&gt;

&lt;p&gt;Very interesting question that you ask: &quot;what it means to implement the algorithm&quot;. But please note that I asked it several posts ago&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;, and an answer would have helped sort out this discussion. What is your definition?&lt;/p&gt;


&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; 08/Aug/11 07:24&lt;/p&gt;</comment>
                            <comment id="13081633" author="erans" created="Tue, 9 Aug 2011 13:51:58 +0000"  >&lt;p&gt;Also:&lt;/p&gt;

&lt;p&gt;Phil,&lt;/p&gt;

&lt;p&gt;Could you please leave out dismissive qualifiers such as &quot;pointless&quot; and &quot;pathetic&quot; (and, elsewhere, &quot;silly&quot;) and stick to more or less objective arguments?&lt;br/&gt;
That will certainly help keep the conversation tone to a courteous level.&lt;/p&gt;

&lt;p&gt;Luc,&lt;/p&gt;

&lt;p&gt;Thanks for stating in full details what you meant by &quot;convergence&quot; in this case. However, it is still a &quot;post-mortem&quot; description.&lt;br/&gt;
Do you really expect that the average user of the CM library (a.o. me and the original reporter of the issue) to be able to figure out that &quot;obvious&quot; explanation just by getting a &quot;TooManyEvalutationsException&quot;, setting the along-x accuracy threshold to a ridiculously high value and still getting the same exception?&lt;br/&gt;
If just for educational purposes, don&apos;t you think that it is more instructive to get a specific hint that the algorithm is stuck, rather than hit the ultimate fail-safe barrier much much later, and then download the source code and sprinkle the code with &quot;println&quot; statements to do forensic analysis?&lt;/p&gt;

&lt;p&gt;Phil,&lt;/p&gt;

&lt;p&gt;I tried to handle this issue out of respect for a real user who reported an issue that would have looked suspicious to many CM users. &lt;span class=&quot;error&quot;&gt;&amp;#91;How many of them would be experts in numerical analysis?&amp;#93;&lt;/span&gt;&lt;br/&gt;
You do not do me a favour by removing this algorithm; I don&apos;t want it to be a &lt;em&gt;compromise&lt;/em&gt; (pathetic or not). If you prefer to keep it, I don&apos;t care anymore. But, in that case, &lt;em&gt;you&lt;/em&gt; should have answered to Axel Kramer to go and read some books on numerical analysis.&lt;/p&gt;</comment>
                            <comment id="13082210" author="psteitz" created="Wed, 10 Aug 2011 07:27:47 +0000"  >&lt;p&gt;Gilles, I apologize for tone of comments.&lt;/p&gt;</comment>
                            <comment id="13084113" author="dhendriks" created="Fri, 12 Aug 2011 13:29:12 +0000"  >&lt;p&gt;The discussions for this issue have left me with a lack of overview, so I&apos;ll (try to) objectively summerize the discussions above:&lt;/p&gt;

&lt;p&gt;The problems are:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Regula Falsi states it always converges, but the implementation doesn&apos;t.&lt;/li&gt;
	&lt;li&gt;The main loop may continue, even when it no longer makes any progress, and subsequently ends with a TooManyEvaluationsException exception.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;The cause of both problems is:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The limited/finite precision of the Java double type.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Proposed solutions:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;The patch from revision 1154614, which modifies the Regula Falsi algorithm.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;Consensus seems to be that this change, which modifies the algorithm, is undesireable. We should keep the original algorithm.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Detect that the algorithm no longer makes progress and throw an exception, instead of continuing the loop which no longer makes progress.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;This is just earlier detection of the algorithm getting stuck.&lt;/li&gt;
		&lt;li&gt;We could throw the TooManyEvaluationsException exception, that continuing the loop would also get us.
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;The class only states &quot;Exception to be thrown when the maximal number of evaluations is exceeded.&quot;.&lt;/li&gt;
			&lt;li&gt;The exception message only states: &quot;illegal state: maximal count (100) exceeded: evaluations&quot;&lt;/li&gt;
			&lt;li&gt;Both may benefit from more extended documentation/messages.&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
		&lt;li&gt;We could also throw an other exception that more clearly states this issue (NoMoreProgressException, AlgorithmStuckException, ...?).
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;It could for instance mention that changing the function value accuracy may be a solution, or asking for a different kind of solution?&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Add documentation to the Regula Falsi algorithm that it is not intended to be used for actual problems, but only to compare algorithms, for testing, educational purposes, etc.&lt;/li&gt;
	&lt;li&gt;Add documentation to the Regula Falsi algorithm that users should use Illinois or Pegasus instead, which should outperform the algorithm for most if not all problems.&lt;/li&gt;
	&lt;li&gt;Add documentation to the Regula Falsi algorithm that it theoretically converges, but the implementation may not, due to the limited/finite precision of Java&apos;s double type. This will result in an exception (or 2 if we also do solution number 2).&lt;/li&gt;
	&lt;li&gt;Remove the Regula Falsi algorithm, and document why it is not included/implemented.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;This seems to have been accepted as a last resort solution only.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Other notes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;The following problem was also indicated: a solution is found after a certain number of iterations, but the algorithm does not return the solution (it does not terminate)
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;This should only happen if the user asked for a different solution. That is, there are several accuracy parameters, as well as an allowedSolution parameter.&lt;/li&gt;
		&lt;li&gt;If the solution requested by the user is found, it should return the solution immediately, otherwise it is a bug.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;New notes:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I think the Regula Falsi algorithm does not state a fixed convergence criteria: it is left to the user to decide on one.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;When I implemented the algorithm, I think I copied the convergence checks for Brent.&lt;/li&gt;
		&lt;li&gt;I subsequently modified the convergence criteria when I added the allowedSolution parameter.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;My personal opinions on the proposed solutions:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(1) Revert part of 1154614, so get the original algorithm back. The other changes of that commit, that don&apos;t change the actual algorith, can stay.&lt;/li&gt;
	&lt;li&gt;(2) If we keep the algorithm, earlier detection would be nice. Not sure which exception to throw in these cases.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;This would result in a single &apos;if&apos; that detects that the new approximation is the same as the previous one, and we thus no longer make progress, in which case we throw the exception earlier, instead of later.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;(3-5) If we keep the algorith, all 3 documentation extensions would be a good idea.&lt;/li&gt;
	&lt;li&gt;(6) If possible, keep the algorithm, and don&apos;t remove it.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;New issue:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;TooManyEvaluationsException currently seems to use LocalizedFormats.MAX_COUNT_EXCEEDED(&quot;maximal count (
{0}) exceeded&quot;), but maybe should use LocalizedFormats.MAX_EVALUATIONS_EXCEEDED(&quot;maximal number of evaluations ({0}
&lt;p&gt;) exceeded&quot;) instead?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13084242" author="erans" created="Fri, 12 Aug 2011 16:51:30 +0000"  >&lt;p&gt;Thanks for the neat summary!&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
	&lt;li&gt;(1) Revert part of 1154614, so get the original algorithm back. The other changes of that commit, that don&apos;t change the actual algorith, can stay.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Done in revision 1157185.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
	&lt;li&gt;(2) If we keep the algorithm, earlier detection would be nice. Not sure which exception to throw in these cases.
	&lt;ul&gt;
		&lt;li&gt;This would result in a single &apos;if&apos; that detects that the new approximation is the same as the previous one, and we thus no longer make progress, in which case we throw the exception earlier, instead of later.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;+1 (my position in the &quot;07/Aug/11 20:28&quot; post)&lt;br/&gt;
As suggested there, the exception could be &quot;MathIllegalStateException&quot; but with a clear message stating that the algorithm is stuck. Or maybe a new subclass of it which we could call &quot;NumericalPrecisionException&quot; or even a general-purpose &quot;ImplementationException&quot;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt; all 3 documentation extensions would be a good idea.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;

&lt;p&gt;About the &quot;new issue&quot;, the message string:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&quot;illegal state: maximal count (100) exceeded: evaluations&quot;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;contains everything:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;error type: illegal state&lt;/li&gt;
	&lt;li&gt;failure description: maximal count (100) exceeded&lt;/li&gt;
	&lt;li&gt;context: evaluations&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;I proposed to use this approach (combining message items with the &quot;addMessage&quot; method of &quot;ExceptionContext&quot;) in order to reduce the number of messages in the &quot;LocalizedFormats&quot; enum. Too many of them are just slight variations on a same theme.&lt;/p&gt;</comment>
                            <comment id="13084454" author="dhendriks" created="Fri, 12 Aug 2011 23:12:15 +0000"  >&lt;blockquote&gt;&lt;p&gt;contains everything&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I agree. I was just wondering why a message that seems to be exactly the same as the exception was not used, as it kind of looked like it was created just for this purpose...&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I proposed to use this approach (combining message items with the &quot;addMessage&quot; method of &quot;ExceptionContext&quot;) in order to reduce the number of messages in the &quot;LocalizedFormats&quot; enum. Too many of them are just slight variations on a same theme.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Ah, so then the MAX_EVALUATIONS_EXCEEDED is just a remnant of the past that should be eliminated, by replacing it everywhere by the more general MAX_COUNT_EXCEEDED?&lt;/p&gt;</comment>
                            <comment id="13084473" author="erans" created="Fri, 12 Aug 2011 23:38:37 +0000"  >&lt;p&gt;Yes. In the file &quot;LocalizedFormats.java&quot;, I&apos;ve started to write&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;/* keep */
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;after each enum that is supposedly to be kept. All the others are still to be examined for redundancy with another one, or the possibility to create something close using the &quot;multi-item&quot; approach.&lt;/p&gt;</comment>
                            <comment id="13095871" author="dhendriks" created="Fri, 2 Sep 2011 08:58:17 +0000"  >&lt;p&gt;The &apos;ticket631.patch&apos; file is my attempt to resolve this issue with a solution (or maybe I should call it a compromise?) that is satisfactory for all people that participated in the discussions for this issue, without having to remove the Regula Falsi algorithm from Commons Math.&lt;/p&gt;

&lt;p&gt;I changed the following:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Added early detection of no longer making progress (&apos;getting stuck&apos;), and documented it.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;I used ConvergenceException for this, as it seems to fit... Do we want a custom error message with it?&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Extended RegulaFalsiSolver documentation to indicate:
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;that the algorithm should not be used for actual problems.&lt;/li&gt;
		&lt;li&gt;that Illinois and Pegasus are improved versions and should be prefered.&lt;/li&gt;
		&lt;li&gt;that the implementation does not guarantee convergence, while the algorithm theoretically does.&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;Extended IllinoisSolver and PegasusSolver documentation to indicate that they don&apos;t suffer from the RegulaFalsiSolver&apos;s implementation/convergence issues.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Please comment on whether this patch is an acceptable solution/compromise, and if not, why it is not.&lt;/p&gt;</comment>
                            <comment id="13095914" author="erans" created="Fri, 2 Sep 2011 11:15:21 +0000"  >&lt;p&gt;Committed (with minor additional Javadoc fixes) in revision 1164474.&lt;/p&gt;

&lt;p&gt;Leaving open until confirmation that &lt;tt&gt;ConvergenceException&lt;/tt&gt; is the right one to use. I thought that we could make a difference between &lt;em&gt;theoretical&lt;/em&gt; and &lt;em&gt;implementation&lt;/em&gt; convergence failures. But it might not be worth introducing the distinction just for this one case, especially since it is quite clear clear now that the class should not be used.&lt;/p&gt;</comment>
                            <comment id="13100253" author="erans" created="Thu, 8 Sep 2011 12:13:59 +0000"  >&lt;p&gt;No objection raised; setting to &quot;Resolved&quot;.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12511216">MATH-599</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12492726" name="ticket631.patch" size="6669" author="dhendriks" created="Fri, 2 Sep 2011 08:58:17 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sun, 7 Aug 2011 13:03:23 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>61924</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            5 years, 11 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0ap3z:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>60341</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>