<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat Nov 19 22:00:57 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/MATH-1300/MATH-1300.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[MATH-1300] BitsStreamGenerator#nextBytes(byte[]) is wrong</title>
                <link>https://issues.apache.org/jira/browse/MATH-1300</link>
                <project id="12310485" key="MATH">Commons Math</project>
                    <description>&lt;p&gt;Sequential calls to the BitsStreamGenerator#nextBytes(byte[]) must generate the same sequence of bytes, no matter by chunks of which size it was divided. This is also how java.util.Random#nextBytes(byte[]) works.&lt;/p&gt;

&lt;p&gt;When nextBytes(byte[]) is called with a bytes array of length multiple of 4 it makes one unneeded call to next(int) method. This is wrong and produces an inconsistent behavior of classes like MersenneTwister.&lt;/p&gt;

&lt;p&gt;I made a new implementation of the BitsStreamGenerator#nextBytes(byte[]) see attached code.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12923189">MATH-1300</key>
            <summary>BitsStreamGenerator#nextBytes(byte[]) is wrong</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="rosti.bsd">Rostislav Krasny</reporter>
                        <labels>
                    </labels>
                <created>Sat, 19 Dec 2015 01:57:14 +0000</created>
                <updated>Mon, 25 Jan 2016 20:28:00 +0000</updated>
                            <resolved>Thu, 31 Dec 2015 23:21:58 +0000</resolved>
                                    <version>3.5</version>
                                    <fixVersion>3.6</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="15065149" author="rosti.bsd" created="Sat, 19 Dec 2015 02:03:13 +0000"  >&lt;p&gt;Attaching the code.&lt;/p&gt;

&lt;p&gt;New BitsStreamGenerator#nextBytes(byte[]) implementation, made as an overriden method of MersenneTwister. Copy this nextBytes(byte[]) implementation into the BitsStreamGenerator code.&lt;/p&gt;

&lt;p&gt;The second file is a Unit test that demonstrates the wrong and the right nextBytes(byte[]) behaviors.&lt;/p&gt;</comment>
                            <comment id="15065416" author="erans" created="Sat, 19 Dec 2015 15:50:58 +0000"  >&lt;p&gt;Thanks for pointing out that problem.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Sequential calls to [...] nextBytes must generate the same sequence of bytes, no matter by chunks of which size it was divided.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Attempting to figure out how general the claim is, I&apos;ve implemented a more general unit test based on your suggestion:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void checkNexBytesChunks(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; chunkSize,
                                     &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; numChunks) {
        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; RandomGenerator rg = makeGenerator();
        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; seed = 1234567L;

        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] b1 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[chunkSize * numChunks];
        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] b2 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[chunkSize];

        &lt;span class=&quot;code-comment&quot;&gt;// Generate the chunks in a single call.                                                                                                                                                                              
&lt;/span&gt;        rg.setSeed(seed);
        rg.nextBytes(b1);

        &lt;span class=&quot;code-comment&quot;&gt;// Reset.                                                                                                                                                                                                             
&lt;/span&gt;        rg.setSeed(seed);
        &lt;span class=&quot;code-comment&quot;&gt;// Generate the chunks in consecutive calls.                                                                                                                                                                          
&lt;/span&gt;        &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; numChunks; i++) {
            rg.nextBytes(b2);
        }

        &lt;span class=&quot;code-comment&quot;&gt;// Store last 128 bytes chunk of b1 into b3.                                                                                                                                                                          
&lt;/span&gt;        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] b3 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[chunkSize];
        &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.arraycopy(b1, b1.length - b3.length, b3, 0, b3.length);

        &lt;span class=&quot;code-comment&quot;&gt;// Sequence of calls must be the same.                                                                                                                                                                                
&lt;/span&gt;        Assert.assertArrayEquals(&lt;span class=&quot;code-quote&quot;&gt;&quot;chunkSize=&quot;&lt;/span&gt; + chunkSize + &lt;span class=&quot;code-quote&quot;&gt;&quot; numChunks=&quot;&lt;/span&gt; + numChunks,
                                 b2, b3);
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The original CM code always fails it, as you observed.&lt;br/&gt;
In your example test case (chunkSize=128 and numChunks=8), your fix makes the test pass.&lt;/p&gt;

&lt;p&gt;However, it fails whenever the size of the array (argument to &quot;nextBytes&quot;) is not a multiple of 4.&lt;br/&gt;
That is, the &quot;chunkSize&quot; does matter.&lt;/p&gt;

&lt;p&gt;And &quot;nextBytes&quot; in the JDK&apos;s &lt;tt&gt;Random&lt;/tt&gt; class also fails the test when the array&apos;s size is not a multiple of 4.&lt;/p&gt;

&lt;p&gt;So there are several issues:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Do you have a reference that the behaviour &lt;em&gt;must&lt;/em&gt; be as your described?&lt;/li&gt;
	&lt;li&gt;Is the requested behaviour supposed to work only when the array&apos;s size is a multiple of 4?  If so, should we add some note about it in the documentation?&lt;/li&gt;
	&lt;li&gt;Is there a way to implement &quot;nextBytes&quot; in &lt;tt&gt;BitsStreamGenerator&lt;/tt&gt; so that the property holds for any size?  And if so, should we consider  making the change (given that &lt;tt&gt;Random&lt;/tt&gt; does not work that way)?&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="15065423" author="erans" created="Sat, 19 Dec 2015 16:12:33 +0000"  >&lt;p&gt;Independently of the above discussion, I propose to replace the current code of &quot;nextBytes&quot; with the following:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
   &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void nextBytes(&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] bytes) {
        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; mask = 0xff;
        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; numBytesChunk = 4;
        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; shift = 8;
        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; numBits = numBytesChunk * shift;

        &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; index = 0;
        &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; remainingBytes = bytes.length;
        &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (remainingBytes &amp;gt;= numBytesChunk) {
            &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; random = next(numBits);
            &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; j = 0; j &amp;lt; numBytesChunk; j++) {
                bytes[index++] = (&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;) ((random &amp;gt;&amp;gt; (j * shift)) &amp;amp; mask);
                --remainingBytes;
            }
        }

        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (remainingBytes &amp;gt; 0) {
            &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; random = next(remainingBytes * shift);
            &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; j = 0; j &amp;lt; remainingBytes; j++) {
                bytes[index++] = (&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;) ((random &amp;gt;&amp;gt; (j * shift)) &amp;amp; mask);
            }
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;which I find much more legible (no unrolled loop, no repeated hard-coded constants, explicit variables names).&lt;br/&gt;
It however changes the semantics in the part that fills the &quot;remainingBytes&quot;, where the argument to &quot;next&quot; requests only the required number of bits, thus potentially &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; changing the bytes sequence.  All the CM tests still pass, and perhaps there should be a unit test that assert the expected semantics.&lt;/p&gt;</comment>
                            <comment id="15065450" author="rosti.bsd" created="Sat, 19 Dec 2015 17:44:28 +0000"  >&lt;p&gt;My first statement about the same bytes sequence generated by differently sized chunks was too optimistic. Indeed even java.util.Random doesn&apos;t guarantee this. But neither java.util.Random nor org.spaceroots.mantissa.random.MersenneTwister make unneeded calls to the nextInt() method (that just calls next(32)). Obviously the same bytes sequence guarantee can&apos;t be done without a significant performance degradation.&lt;/p&gt;

&lt;p&gt;Also MersenneTwister#next() always generates int but return only asked number of bits.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; y &amp;gt;&amp;gt;&amp;gt; (32 - bits);&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;BTW the spaceroots&apos;s implementation of MersenneTwister was the reference to me. You can download it (including source code) from www.spaceroots.org/downloads.html in their mantissa library.&lt;/p&gt;

&lt;p&gt;I still propose to change the nextBytes() code to my version because of the performance. I tested the performance of the four implementations and my implementation is better. I did it by running following test code:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
	@Test
	&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void test4() {
		&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; start;
		&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; end;
		&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; iterations = 20000000;
		&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; chunkSize = 123;

		org.spaceroots.mantissa.random.MersenneTwister referenceMt = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; org.spaceroots.mantissa.random.MersenneTwister();
		org.apache.commons.math3.random.MersenneTwister cmMt = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; org.apache.commons.math3.random.MersenneTwister();
		MersenneTwister2 mt2 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MersenneTwister2();
		MersenneTwister3 mt3 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MersenneTwister3();
		&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] buf = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[chunkSize];

		referenceMt.setSeed(1234567L);
		cmMt.setSeed(1234567L);
		mt2.setSeed(1234567L);
		mt3.setSeed(1234567L);

		start = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
		&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; iterations; i++) {
			referenceMt.nextBytes(buf);
		}
		end = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
		&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.err.printf(&lt;span class=&quot;code-quote&quot;&gt;&quot;Spaceroots MersenneTwister %d iterations:\t%8d ms.\n&quot;&lt;/span&gt;, iterations, (end - start));

		start = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
		&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; iterations; i++) {
			cmMt.nextBytes(buf);
		}
		end = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
		&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.err.printf(&lt;span class=&quot;code-quote&quot;&gt;&quot;CM 3.5 MersenneTwister %d iterations:\t%8d ms.\n&quot;&lt;/span&gt;, iterations, (end - start));

		start = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
		&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; iterations; i++) {
			mt2.nextBytes(buf);
		}
		end = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
		&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.err.printf(&lt;span class=&quot;code-quote&quot;&gt;&quot;Rostislav MersenneTwister %d iterations:\t%8d ms.\n&quot;&lt;/span&gt;, iterations, (end - start));

		start = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
		&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; iterations; i++) {
			mt3.nextBytes(buf);
		}
		end = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.currentTimeMillis();
		&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.err.printf(&lt;span class=&quot;code-quote&quot;&gt;&quot;Gilles MersenneTwister %d iterations:\t%8d ms.\n&quot;&lt;/span&gt;, iterations, (end - start));
	}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;On my (pretty old) computer (Pentium 4 Prescott2M 3.2GHz, 2GB RAM, JDK 7u80 32-bit) I got following results (two runs):&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Spaceroots MersenneTwister 20000000 iterations:	   22937 ms.
CM 3.5 MersenneTwister 20000000 iterations:	   17532 ms.
Rostislav MersenneTwister 20000000 iterations:	   15812 ms.
Gilles MersenneTwister 20000000 iterations:	   24235 ms.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Spaceroots MersenneTwister 20000000 iterations:	   27937 ms.
CM 3.5 MersenneTwister 20000000 iterations:	   16735 ms.
Rostislav MersenneTwister 20000000 iterations:	   15547 ms.
Gilles MersenneTwister 20000000 iterations:	   23953 ms.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="15065457" author="erans" created="Sat, 19 Dec 2015 17:57:43 +0000"  >&lt;blockquote&gt;&lt;p&gt;BTW the spaceroots&apos;s implementation of MersenneTwister was the reference to me.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;If you found a discrepancy between CM and Mantissa, we should leave the creator of Mantissa and the main CM developer to discuss that between themselves. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/biggrin.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15065484" author="rosti.bsd" created="Sat, 19 Dec 2015 19:00:39 +0000"  >&lt;p&gt;According to the code comments both the CM and the Mantissa implementations of MersenneTwister are based on the same code &quot;developed by Makoto Matsumoto and Takuji Nishimura during 1996-1997&quot;. The main difference between them is that Mantissa implementation extends the standard java.util.Random and uses JDK&apos;s nextBytes() method while the CM implementation extends its own BitsStreamGenerator with its own nextBytes() method implementation. So the reference behavior for the nextBytes() method must be the java.util.Random since it is a part of the JDK and so it is the standard.&lt;/p&gt;

&lt;p&gt;BTW I  looked at my code again and found that &amp;amp; 0xff operations are not needed. Narrowing Primitive Conversion just discards all unneded bits above the byte, so we don&apos;t need to do it by ourself before int to byte type casting.&lt;br/&gt;
&lt;a href=&quot;http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.3&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So I propose this new code of the BitsStreamGenerator#nextBytes() method with even a little bit better performance&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
	@Override
	&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void nextBytes(&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] bytes) {
		&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; random;
		&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; index = 0;
		&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; max = bytes.length &amp;amp; 0x7ffffffc; index &amp;lt; max;) {
			random = next(32);
			bytes[index++] = (&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;) random;
			bytes[index++] = (&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;) (random &amp;gt;&amp;gt;&amp;gt; 8);
			bytes[index++] = (&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;) (random &amp;gt;&amp;gt;&amp;gt; 16);
			bytes[index++] = (&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;) (random &amp;gt;&amp;gt;&amp;gt; 24);
		}

		&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (index &amp;lt; bytes.length) {
			random = next(32);
			&lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;) {
				bytes[index++] = (&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;) random;
				&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (index &amp;lt; bytes.length) {
					random &amp;gt;&amp;gt;&amp;gt;= 8;
				} &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
					&lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
				}
			}
		}
	}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="15065489" author="erans" created="Sat, 19 Dec 2015 19:13:19 +0000"  >&lt;p&gt;Two runs from me: &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;nextBytes (calls per timed block: 200000, timed blocks: 100, time unit: ms)
       name      time/call      std error total time      ratio      difference
  Rostislav 2.27207249e-04 5.12523201e-05 4.5441e+03 1.0000e+00  0.00000000e+00
     Gilles 2.41729594e-04 3.13763057e-05 4.8346e+03 1.0639e+00  2.90446893e+02
CommonsMath 2.25267632e-04 3.46659491e-05 4.5054e+03 9.9146e-01 -3.87923460e+01
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;nextBytes (calls per timed block: 200000, timed blocks: 100, time unit: ms)
       name      time/call      std error total time      ratio      difference
  Rostislav 2.32682559e-04 3.84982763e-05 4.6537e+03 1.0000e+00  0.00000000e+00
     Gilles 2.49178627e-04 3.92662253e-05 4.9836e+03 1.0709e+00  3.29921360e+02
CommonsMath 2.26983378e-04 2.72215448e-05 4.5397e+03 9.7551e-01 -1.13983632e+02
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I&apos;m still ~7% slower than you, but that&apos;s far from the ~50% which your benchmark indicates.&lt;br/&gt;
In your benchmark, your code is faster that the current CM code; but in mine, it&apos;s the other way around...&lt;/p&gt;</comment>
                            <comment id="15065519" author="rosti.bsd" created="Sat, 19 Dec 2015 20:12:11 +0000"  >&lt;p&gt;We definitly have a different hardware and most likely different operating system and JDK.&lt;/p&gt;

&lt;p&gt;I&apos;ve run my benchmarks several times on JDK 7u80 32-bit with different chunk sizes and numbers of iterations; the results were always similar to what I posted above. Anyway even in your benchmarks your code is ~7% slower, that is +1 voting for my code to be committed &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15065574" author="erans" created="Sat, 19 Dec 2015 23:30:05 +0000"  >&lt;p&gt;Personally, I&apos;m always in favour of cleaining up in the sense to make the code safer and more understandable, before trying to grab a few milliseconds in a micro-benchmark.&lt;br/&gt;
If we want to focus on performance, it would be better to have a realistic use-case (e.g. estimate how much time is spent in &quot;nextBytes&quot; relative to the usage of the generated numbers).&lt;/p&gt;

&lt;p&gt;I think that we need to determine how to resolve the original issue, and perhaps open another report for the performance improvement.&lt;/p&gt;</comment>
                            <comment id="15065584" author="psteitz" created="Sun, 20 Dec 2015 00:28:09 +0000"  >&lt;p&gt;I am not sure that I buy the fact that this is a bug.  We don&apos;t advertise this invariant and I don&apos;t see the need to constrain implementations to satisfy it.  Unless I am misunderstanding, we &lt;b&gt;do&lt;/b&gt; provide seed-consistency with constant output buffer size and that is what practical implementations should depend on.  Is there a practical use case that requires the invariant asked for in this issue?&lt;/p&gt;</comment>
                            <comment id="15065695" author="tn" created="Sun, 20 Dec 2015 09:55:27 +0000"  >&lt;p&gt;The Random class does not guarantee that for any chunk size the same sequence is generated. In fact it always gets the next 32 bits and uses as much as needed.&lt;/p&gt;

&lt;p&gt;This means that for chunk sizes that are not multiples of 4, the test from Gilles will also fail.&lt;/p&gt;

&lt;p&gt;I do see a problem in the nextBytes implementation in BitStreamGenerator, as there are unnecessary calls to next(int) in case the chunk size is a multiple of 4. I think the proposed patches could be further improved into something like that:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void nextBytes(&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] bytes) {
        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; len = bytes.length;
        &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; len;) {
            &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; random = nextInt();
            &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;code-object&quot;&gt;Math&lt;/span&gt;.min(len - i, 4);
            &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (n-- &amp;gt; 0) {
                bytes[i++] = (&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;) random;
                random &amp;gt;&amp;gt;= 8;
            }
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="15065723" author="erans" created="Sun, 20 Dec 2015 12:07:43 +0000"  >&lt;blockquote&gt;&lt;p&gt;there are unnecessary calls to next(int) in case the chunk size is a multiple of 4&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Indeed, that&apos;s what Rostislav proposed to solve in the first place.&lt;br/&gt;
Depending on the answers to the questions in my first comment, we could make this as a new feature request.&lt;br/&gt;
Or we can explicitly document that consecutive calls to nextBytes won&apos;t provide the same sequence as single call (as per the above unit test).&lt;br/&gt;
The feature will work when size is a multiple of 4 (just with the fix that removes the additional call when not necessary).&lt;/p&gt;

&lt;p&gt;Then there was the issue (or not) of performance.&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;nextBytes (calls per timed block: 200000, timed blocks: 100, time unit: ms)
       name      time/call      std error total time      ratio      difference
CommonsMath 1.21513910e-04 3.20776342e-05 2.4303e+03 1.0000e+00  0.00000000e+00
  Rostislav 1.23101061e-04 2.58350393e-05 2.4620e+03 1.0131e+00  3.17430180e+01
     Thomas 2.14572528e-04 2.55932836e-05 4.2915e+03 1.7658e+00  1.86117237e+03
    Gilles1 1.28583021e-04 1.04224889e-05 2.5717e+03 1.0582e+00  1.41382220e+02
    Gilles2 1.21604685e-04 9.00060879e-06 2.4321e+03 1.0007e+00  1.81551100e+00
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;nextBytes (calls per timed block: 200000, timed blocks: 100, time unit: ms)
       name      time/call      std error total time      ratio      difference
CommonsMath 1.24257845e-04 2.47466019e-05 2.4852e+03 1.0000e+00  0.00000000e+00
  Rostislav 1.27903613e-04 2.89947446e-05 2.5581e+03 1.0293e+00  7.29153600e+01
     Thomas 2.23244881e-04 4.19456869e-05 4.4649e+03 1.7966e+00  1.97974071e+03
    Gilles1 1.34765909e-04 2.56119543e-05 2.6953e+03 1.0846e+00  2.10161271e+02
    Gilles2 1.28621420e-04 2.35835928e-05 2.5724e+03 1.0351e+00  8.72714880e+01
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&quot;Gilles1&quot; is my above proposal (minus the unnecessary mask operation).&lt;br/&gt;
&quot;Gilles2&quot; is a variant of Rostislav&apos;s code but using static variables rather than hard-coded numbers.&lt;/p&gt;

&lt;p&gt;Based on this not really reliable kind of benchmarks, my position is that we should strive to make the code&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;not use hard-coded numbers&lt;/li&gt;
	&lt;li&gt;self-documenting&lt;/li&gt;
	&lt;li&gt;simple&lt;/li&gt;
	&lt;li&gt;more documented (not at the Javadoc level but explaining the statements)&lt;/li&gt;
	&lt;li&gt;safe (calling an overrideable method in a constructor is not - see e.g. &lt;tt&gt;MersenneTwister&lt;/tt&gt;)&lt;/li&gt;
	&lt;li&gt;thread-safe&lt;/li&gt;
	&lt;li&gt;fast&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Thomas&apos; version is the simplest but the performance obviously &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; suffers.&lt;br/&gt;
Rostislav&apos;s is (often) the fastest, but it is (much) harder to understand, relatively to the small number of lines.&lt;/p&gt;</comment>
                            <comment id="15065726" author="luc" created="Sun, 20 Dec 2015 12:21:27 +0000"  >&lt;p&gt;In fact, the code from Apache Commons Math come from the mantissa project.&lt;br/&gt;
Mantissa is obsolete, it was a single person project (myself). I joined&lt;br/&gt;
the Apache Commons project to continue the work there. The complete Mantissa&lt;br/&gt;
library was donated to Apache at that time and merged. The Apache version of&lt;br/&gt;
this code is therefore the  most up to date one.&lt;/p&gt;</comment>
                            <comment id="15065729" author="luc" created="Sun, 20 Dec 2015 12:34:30 +0000"  >&lt;p&gt;My position would be that even if having values independent of chunk size is a nice features,&lt;br/&gt;
it is not worth degrading either understandability or performances for it. So just advertising&lt;br/&gt;
the fact this property does &lt;b&gt;not&lt;/b&gt; hold would be fine to me.&lt;/p&gt;

&lt;p&gt;I&apos;m also not sure losing much time with Mersenne twister is worth it. This generator was the&lt;br/&gt;
best one a few years ago but has been superseded with the WELL family of generators&lt;br/&gt;
almost 10 years ago (see &lt;a href=&quot;http://www.iro.umontreal.ca/~panneton/WELLRNG.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.iro.umontreal.ca/~panneton/WELLRNG.html&lt;/a&gt;, where&lt;br/&gt;
a mink to the reference paper can be found). According to the paper, the Mersenne twister&lt;br/&gt;
suffers fro a lack of chaos at the start (i.e. the first few millions generations) that the WELL&lt;br/&gt;
generators fix.&lt;/p&gt;</comment>
                            <comment id="15065740" author="erans" created="Sun, 20 Dec 2015 13:12:45 +0000"  >&lt;p&gt;But do you agree to remove the unnecessary call to &quot;next(32)&quot;? Or is there a standard reference (such that the RNG must reproduce the same sequence as that one for the same seed)?&lt;/p&gt;

&lt;p&gt;IMO, there is much that could be done to improve the understandability of the code (starting with the simple rule: no hard-coded numbers...).&lt;/p&gt;

&lt;p&gt;However, if there are algorithms that are superseded, I of course agree that it&apos;s not worth spending any time on them.&lt;br/&gt;
Perhaps it is now a good opportunity to indicate in the Javadoc which RNGs are definitely obsolete (and deprecate them?) and which are recommended, so that uninformed people would not start investigating outdated code...&lt;/p&gt;</comment>
                            <comment id="15065748" author="luc" created="Sun, 20 Dec 2015 13:21:50 +0000"  >&lt;p&gt;If it is unnecessary, sure it can be removed.&lt;/p&gt;

&lt;p&gt;Indicating that the WELL generators are considered more up to date than the Mersenne Twister would be nice too.&lt;/p&gt;</comment>
                            <comment id="15065797" author="erans" created="Sun, 20 Dec 2015 15:10:40 +0000"  >&lt;p&gt;Minimal change committed as 1d635088f697178660b6e1c9a89d2b7d3bbe2d29 in &quot;master&quot; branch (4.0).&lt;/p&gt;

&lt;p&gt;A unit test shows that the property referred to in the description of this issue passes if the array size is a multiple of 4.&lt;br/&gt;
Another test is &quot;@Ignore&quot;d as a reminder of the limitation.  Can be removed if deemed useless.&lt;/p&gt;

&lt;p&gt;We have yet to decide whether to upgrade the Javadoc to mention the feature.&lt;/p&gt;

&lt;p&gt;Since the behaviour has changed, perhaps this should not be backported to 3.x &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/help_16.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;For improving the code (e.g. performance), another report should be created.&lt;/p&gt;</comment>
                            <comment id="15065858" author="rosti.bsd" created="Sun, 20 Dec 2015 18:07:34 +0000"  >&lt;p&gt;WELL generators in CM inherite the same nextBytes() of BitsStreamGenerator. They extend an AbstractWell that extends the BitsStreamGenerator class. The discussed issue of the BitsStreamGenerator#nextBytes() relates to all BitsStreamGenerator descendants. I used the MersenneTwister class just for the demonstration.&lt;/p&gt;

&lt;p&gt;After looking at the Gilles commit I&apos;ve a few questions:&lt;br/&gt;
&lt;a href=&quot;https://git1-us-west.apache.org/repos/asf?p=commons-math.git;a=commitdiff;h=1d635088f697178660b6e1c9a89d2b7d3bbe2d29&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://git1-us-west.apache.org/repos/asf?p=commons-math.git;a=commitdiff;h=1d635088f697178660b6e1c9a89d2b7d3bbe2d29&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1. Why did you do the change so minimal with many unneded operations still in the code instead of taking the code I&apos;ve proposed? I&apos;m talking about the unneded &amp;amp; 0xff operations, not optimal index incrementation and cases where the last shift right 8 bits isn&apos;t needed. If you think my code is hard to understand you may add comments into it. In my opinion this is very simple code. Anyway I think the performance is important.&lt;/p&gt;

&lt;p&gt;2. I&apos;ve just noticed the AbstractRandomGenerator has its own implementation of the nextBytes() method. Why does it need a differently implemented nextBytes()? And why that implementation is so strange? After Gilles commit it&apos;s even stranger.&lt;/p&gt;

&lt;p&gt;before commit:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
     @Override
     &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void nextBytes(&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] bytes) {
         &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; bytesOut = 0;
         &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (bytesOut &amp;lt; bytes.length) {
           &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; randInt = nextInt();
           &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++) {
               &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; ( i &amp;gt; 0) {
                  randInt &amp;gt;&amp;gt;= 8;
               }
               bytes[bytesOut++] = (&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;) randInt;
               &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (bytesOut == bytes.length) {
                   &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
               }
           }
         }
     }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;after commit:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
     @Override
     &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void nextBytes(&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] bytes) {
         &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; bytesOut = 0;
         &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (bytesOut &amp;lt; bytes.length) {
             &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; randInt = nextInt();
             &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++) {
                 &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (i &amp;gt; 0) {
                     randInt &amp;gt;&amp;gt;= 8;
                 }
             }
             &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (bytesOut &amp;lt; bytes.length) {
                 bytes[bytesOut++] = (&lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;) randInt;
                 &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (bytesOut == bytes.length) {
                     &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
                 }
             }
         }
     }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The original version before commit is not optimized but this is not the only issue. It uses only three bytes of the random int, doesn&apos;t it? And after Gilles commit it uses only one byte of the random int, making many unneeded actions around. Both versions of the AbstractRandomGenerator need more calls to nextInt() than java.util.Random. Both versions look as a bug.&lt;/p&gt;

&lt;p&gt;In my opinion both the BitsStreamGenerator and the AbstractRandomGenerator should use the same nextBytes() code that I proposed above.&lt;/p&gt;</comment>
                            <comment id="15065919" author="erans" created="Sun, 20 Dec 2015 23:15:29 +0000"  >&lt;blockquote&gt;&lt;p&gt;WELL generators in CM inherite the same nextBytes() of BitsStreamGenerator. They extend an AbstractWell that extends the BitsStreamGenerator class. The discussed issue of the BitsStreamGenerator#nextBytes() relates to all BitsStreamGenerator descendants. I used the MersenneTwister class just for the demonstration.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sure.&lt;br/&gt;
My comment about deprecating the &lt;tt&gt;MersenneTwister&lt;/tt&gt; class was not meant to imply that the redundant call should not be removed.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;1. Why did you do the change so minimal with many unneded operations still in the code instead of taking the code I&apos;ve proposed?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Because we generally prefer one commit per issue.&lt;br/&gt;
This issue (&lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-1300&quot; title=&quot;BitsStreamGenerator#nextBytes(byte[]) is wrong&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MATH-1300&quot;&gt;&lt;del&gt;MATH-1300&lt;/del&gt;&lt;/a&gt;) was about a redundant call that prevented the property which you expected.&lt;br/&gt;
Fixing that first does not prevent further changes.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;I&apos;m talking about the unneded &amp;amp; 0xff operations,&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I&apos;m going to do that in another commit.&lt;br/&gt;
Usually this should also require another report, but I&apos;ll just refer to the discussion here in the commit message.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;not optimal index incrementation and cases where the last shift right 8 bits isn&apos;t needed.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;See above discussion.&lt;br/&gt;
Please open another issue, as it is not related to your original statement (IMHO: &quot;wrong != suboptimal&quot;).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;If you think my code is hard to understand you may add comments into it. In my opinion this is very simple code.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The &quot;for&quot; statement in your code is not easy to understand (for a &quot;for&quot; statement, that is).&lt;br/&gt;
If I&apos;m not mistaken, a CM unwritten rule for code is &quot;No hard-coded numbers&quot;.  So I would not just commit your code as is.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Anyway I think the performance is important.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed, just not at all cost, IMO.&lt;br/&gt;
Maintenance is also a parameter to take into account, especially if the gain of less clear code is quite small (and subject to erratic variations between HW and JVM).&lt;br/&gt;
This does not mean that I prefer to leave it at that; just it should also be another issue.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;2. I&apos;ve just noticed the AbstractRandomGenerator has its own implementation of the nextBytes() method. Why does it need a differently implemented nextBytes()?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It doesn&apos;t; I just grouped it in the same commit because it is the same problem, to be fixed in the most obvious way before further changing the code (another CM rule).&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;And why that implementation is so strange? After Gilles commit it&apos;s even stranger.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Sorry, my mistake; I&apos;ll fix ASAP.  Thanks for the review.  I hope I&apos;ll get it right in the next commit.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;In my opinion both the BitsStreamGenerator and the AbstractRandomGenerator should use the same nextBytes() code&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Agreed.&lt;br/&gt;
But they are not in the same hierarchy. It&apos;s a pity.  If it should be the same code, then the code should be shared.  Suggestions on how to achieve that are welcome.&lt;/p&gt;</comment>
                            <comment id="15065934" author="ole" created="Mon, 21 Dec 2015 00:04:04 +0000"  >&lt;blockquote&gt;&lt;p&gt;Or is there a standard reference (such that the RNG must reproduce the same sequence as that one for the same seed)?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It&apos;s nice to know that running the same simulation with the same seed always produces the same result.  Matlab&apos;s documentation also states that the seed is used to produce a predictable sequence of numbers.&lt;br/&gt;
&lt;a href=&quot;http://www.mathworks.com/help/matlab/ref/rng.html?requestedDomain=www.mathworks.com&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.mathworks.com/help/matlab/ref/rng.html?requestedDomain=www.mathworks.com&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15065947" author="erans" created="Mon, 21 Dec 2015 00:42:29 +0000"  >&lt;blockquote&gt;&lt;p&gt;It&apos;s nice to know that running the same simulation with the same seed always produces the same result. &lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;As Phil noted, CM abides by this.&lt;br/&gt;
The question was whether &lt;em&gt;different&lt;/em&gt; implementations should produce the exact same sequence.&lt;br/&gt;
In this case, if the reference also contained the sometimes redundant call, then fixing it in CM would consequently make its sequences differ from the reference.&lt;/p&gt;</comment>
                            <comment id="15065953" author="rosti.bsd" created="Mon, 21 Dec 2015 00:53:01 +0000"  >&lt;p&gt;I made a new Jira &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-1305&quot; title=&quot;Improve performance of nextBytes() method of BitsStreamGenerator and AbstractRandomGenerator &quot; class=&quot;issue-link&quot; data-issue-key=&quot;MATH-1305&quot;&gt;&lt;del&gt;MATH-1305&lt;/del&gt;&lt;/a&gt; ticket with my code of nextBytes() with better performance.&lt;br/&gt;
I&apos;ve improved its readability and added a few comments. Please review.&lt;/p&gt;</comment>
                            <comment id="15076184" author="erans" created="Thu, 31 Dec 2015 23:21:46 +0000"  >&lt;p&gt;Backport in c9c252bf26165e7fafd093cd892af35b23aa8f3f&lt;/p&gt;</comment>
                            <comment id="15115962" author="luc" created="Mon, 25 Jan 2016 20:28:00 +0000"  >&lt;p&gt;Closing all resolved issues that were included in 3.6 release.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12923314">MATH-1304</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12923315">MATH-1305</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12778648" name="MersenneTwister2.java" size="812" author="rosti.bsd" created="Sat, 19 Dec 2015 02:03:13 +0000"/>
                            <attachment id="12778649" name="TestMersenneTwister.java" size="806" author="rosti.bsd" created="Sat, 19 Dec 2015 02:03:13 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Sat, 19 Dec 2015 15:50:58 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_12310250" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10430"><![CDATA[Patch]]></customfieldvalue>
    <customfieldvalue key="10431"><![CDATA[Important]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            42 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2q49z:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>