<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Sat Nov 19 22:30:34 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/MATH-579/MATH-579.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[MATH-579] FastMath.pow much slower than Math.pow</title>
                <link>https://issues.apache.org/jira/browse/MATH-579</link>
                <project id="12310485" key="MATH">Commons Math</project>
                    <description>&lt;p&gt;calculating FastMath.pow(10, 0.1 / 20) is approximately 65 times slower as the Math.pow() function.&lt;br/&gt;
Ether this is a bug or a javadoc comment is missing.&lt;/p&gt;</description>
                <environment>&lt;p&gt;java version &quot;1.6.0_22&quot;&lt;br/&gt;
OpenJDK Runtime Environment (IcedTea6 1.10.1) (6b22-1.10.1-0ubuntu1)&lt;br/&gt;
OpenJDK 64-Bit Server VM (build 20.0-b11, mixed mode)&lt;/p&gt;


&lt;p&gt;java version &quot;1.6.0_24&quot;&lt;br/&gt;
Java(TM) SE Runtime Environment (build 1.6.0_24-b07)&lt;br/&gt;
Java HotSpot(TM) 64-Bit Server VM (build 19.1-b02, mixed mode)&lt;/p&gt;</environment>
        <key id="12507487">MATH-579</key>
            <summary>FastMath.pow much slower than Math.pow</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="aploese">Arne Pl&#246;se</reporter>
                        <labels>
                    </labels>
                <created>Tue, 17 May 2011 13:14:59 +0000</created>
                <updated>Sat, 24 Mar 2012 16:16:53 +0000</updated>
                            <resolved>Wed, 18 May 2011 09:50:25 +0000</resolved>
                                    <version>3.0</version>
                                    <fixVersion>3.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                <comments>
                            <comment id="13034948" author="luc" created="Tue, 17 May 2011 18:33:05 +0000"  >&lt;p&gt;This is strange. Could you run the FastMathTestPerformance junit test (in the utils package).&lt;br/&gt;
On my personal computer (which is also a 64 bits machine running Ubuntu), FastMath.pow is about 28% faster than either StrictMath.pow or Math.pow on Java 5 and 26% faster on Java 6.&lt;/p&gt;</comment>
                            <comment id="13034952" author="aploese" created="Tue, 17 May 2011 18:36:22 +0000"  >&lt;p&gt;This happens only on the first! run.&lt;br/&gt;
So take a separate project and run this test case:&lt;/p&gt;


&lt;p&gt;    @Test&lt;br/&gt;
    public void testPowDuration() {&lt;br/&gt;
        int n = 10;&lt;br/&gt;
        long t1 = System.currentTimeMillis();&lt;br/&gt;
        for (int i = 0; i &amp;lt; n; i++) &lt;/p&gt;
{
            double x1 = FastMath.pow(10, 0.1 / 20);
        }
&lt;p&gt;        long t2 = System.currentTimeMillis();&lt;br/&gt;
        for (int i = 0; i &amp;lt; n; i++) &lt;/p&gt;
{
            double x1 = Math.pow(10, 0.1 / 20);
        }
&lt;p&gt;        long t3 = System.currentTimeMillis();&lt;br/&gt;
        double d1 = t2 - t1;&lt;br/&gt;
        double d2 = t3 - t2;&lt;br/&gt;
          if (d2 == 0) &lt;/p&gt;
{
            d2 = 1;
        }
&lt;p&gt;        if (d1 / d2 &amp;gt; 2.0)&lt;br/&gt;
            throw new RuntimeException(&quot;pow(10, 0.1 / 20) ratio&quot; + (d1 / d2));&lt;br/&gt;
    }&lt;br/&gt;
Looks like some initialization takes quite long ...&lt;/p&gt;</comment>
                            <comment id="13034996" author="luc" created="Tue, 17 May 2011 19:34:06 +0000"  >&lt;p&gt;This is normal and is probably the same for all FastMath methods (I just checked for sin, abs and sqrt, knowing that FastMath.sqrt simply calls Math.sqrt). The initialization occurs at class loading as many tables are computed, so this overhead occurs only one per program run and does not change with the number of calls.&lt;/p&gt;

&lt;p&gt;The number of calls is also important as the native code optimizing compilers kicks of only after the same part of code has been used many times. FastMath relies heavily on this and attempts to be fast for large scale computation. The side effect you see is that it is much slower for very short programs like the benchmark above.&lt;/p&gt;

&lt;p&gt;Also note that 10 runs is far too low with regard to both the resolution of currentTimeMillis (one can use System.nanoTime() instead) and for results significance.&lt;/p&gt;

&lt;p&gt;So I would like to close this as WONTFIX. Perhaps we should add in the javadoc that FastMath targets large scale computation.&lt;/p&gt;</comment>
                            <comment id="13035012" author="sebb@apache.org" created="Tue, 17 May 2011 20:01:32 +0000"  >&lt;p&gt;AIUI FastMath is also targetted at faster calculation over the full range of the operands.&lt;/p&gt;

&lt;p&gt;The performance test does not (currently) use suitable ranges for all the functions.&lt;/p&gt;</comment>
                            <comment id="13035029" author="aploese" created="Tue, 17 May 2011 20:30:21 +0000"  >&lt;p&gt;If you add a hint in the javadocs of class FastMath -&amp;gt; usage for large scale (and initilaization time up to 100 ms) this issue is FIXED&lt;/p&gt;

&lt;p&gt;So having small numbers of computation, stick with Math.* , except you need asinh, ... &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  &lt;/p&gt;</comment>
                            <comment id="13035103" author="erans" created="Tue, 17 May 2011 22:40:25 +0000"  >&lt;p&gt;I don&apos;t think that a remark like &quot;targets large scale computation&quot; adds any more information here (i.e. for &quot;FastMath&quot;) than it would on any other class (slow initialization and JIT compiler behaviour is the same).&lt;br/&gt;
Also, I guess that if one fires up a Java application that only does a few math functions calls, there wouldn&apos;t be any noticeable time differences; they will be dwarfed by the JVM startup time.&lt;/p&gt;

&lt;p&gt;OK for &quot;won&apos;t fix&quot;.&lt;/p&gt;</comment>
                            <comment id="13035213" author="aploese" created="Wed, 18 May 2011 06:04:22 +0000"  >&lt;p&gt;How it I stumbled over it:&lt;/p&gt;

&lt;p&gt;I did debug my app, and came across the call to FastMath.pow() (first call) it took some time (100 ms) to complete the call.&lt;br/&gt;
Then I searched the javadoc for pow - nothing the same for class FastMath - nothing. So I decided must be a bug.&lt;/p&gt;

&lt;p&gt;As you wrote FastMath is no general replacement of Math as the name Fast* would suggest, but it is intended for large scale operation.&lt;br/&gt;
If you want prevent confusion by end users (developers), a hint would be fine. &lt;/p&gt;</comment>
                            <comment id="13035258" author="luc" created="Wed, 18 May 2011 09:50:25 +0000"  >&lt;p&gt;So I have added a thorough explanation in the class javadoc without any code change as of r1124151.&lt;/p&gt;

&lt;p&gt;Thanks for reporting the issue and discussing about it.&lt;/p&gt;</comment>
                            <comment id="13035259" author="erans" created="Wed, 18 May 2011 09:53:46 +0000"  >&lt;p&gt;In the end, it is the &lt;em&gt;absolute&lt;/em&gt; running time that counts. If you call &quot;pow&quot; &lt;em&gt;once&lt;/em&gt; in an application, why would it matter that it takes 100 ms or 1 ms?&lt;/p&gt;

&lt;p&gt;Could it be that the &quot;Math&quot; class is already loaded (as part of the JVM initialization), so that &quot;FastMath&quot; is at a disadvantage in your benchmark (because it still needs to be loaded at the first call to &quot;pow&quot;)?&lt;/p&gt;

&lt;p&gt;I maintain that such a disclaimer (&quot;large scale usage&quot;) provides more confusion that it clears: What is large-scale? People who are worried will profile their (complete) application and can decide which implementation (of any interface) to use, based on realistic timings, not on a micro-benchmark (which can provide contradictory results).&lt;/p&gt;

&lt;p&gt;What we could do is add a link to the performance test class.&lt;/p&gt;</comment>
                            <comment id="13035426" author="psteitz" created="Wed, 18 May 2011 15:05:30 +0000"  >&lt;p&gt;I think Luc did a great job providing the right information to users.  In answer to your question, Gilles, there are some applications where 100ms is a big deal and if they just make one or two calls, the associated latency will be surprising and could cause problems for them.  If we get a lot of feedback from users indicating that this latency is a material practical problem for them, or prevents them using the library, we may want to consider making the embedded use configurable.  I can think of only a few cases in my experience where this might be an issue; but I am thankful to Arne for having pointed it out and Luc for improving the documentation.&lt;/p&gt;</comment>
                            <comment id="13035464" author="erans" created="Wed, 18 May 2011 16:02:49 +0000"  >&lt;blockquote&gt;
&lt;p&gt;In answer to your question, Gilles, there are some applications where 100ms is a big deal and if they just make one or two calls &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This does not answer my question, which could be restated as: How can 100 ms matter when the JVM can take several seconds to start up?&lt;br/&gt;
I&apos;m curious of what real applications (that use CM) would run for less than a few seconds...&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If we get a lot of feedback from users indicating that this latency is a material practical problem for them, or prevents them using the library, we may want to consider making the embedded use configurable.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I surely hope that micro-benchmarks are not going to be taken into consideration...&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I am thankful to Arne for having pointed it out &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;At the time &quot;FastMath&quot; was introduced, I had already pointed out the relative slowness of some functions, to which it had been answered that the &quot;fast&quot; in &quot;FastMath&quot; would kick in only when doing several millions calls (i.e. after the JIT compiler would compile the methods to native code).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I am thankful to &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt; Luc for improving the documentation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;+1&lt;/p&gt;</comment>
                            <comment id="13035501" author="luc" created="Wed, 18 May 2011 17:21:52 +0000"  >&lt;blockquote&gt;
&lt;p&gt;This does not answer my question, which could be restated as: How can 100 ms matter when the JVM can take several seconds to start up?&lt;br/&gt;
I&apos;m curious of what real applications (that use CM) would run for less than a few seconds...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think mainly about hosted application, in environments like Eclipse, web servers, service oriented architectures, perhaps even Android devices. The JVM is already started but I&apos;m not sure the class are reused between requests, I think a new fresh context is set up with a new classloader, which involves reloading the class.&lt;/p&gt;

&lt;p&gt;For sure, micro-benchmark should be avoided. Despite it is quite old, the paper about flawed micro benchmark by Brian Goetz &lt;a href=&quot;http://www.ibm.com/developerworks/java/library/j-jtp02225/index.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.ibm.com/developerworks/java/library/j-jtp02225/index.html&lt;/a&gt; is really enlightening.&lt;/p&gt;

&lt;p&gt;If we get further reports about this latency, we may look at a way to pre-compute the tables at compile time rather than at runtime to see if we can save some milliseconds.&lt;/p&gt;</comment>
                            <comment id="13035648" author="erans" created="Wed, 18 May 2011 20:33:27 +0000"  >&lt;blockquote&gt;
&lt;p&gt;hosted application, in environments like &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt; web servers, &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;From what I&apos;ve just been reading, servlets are only reloaded when their &quot;.class&quot; file has changed. And they refer to this as a feature (to allow code to be modified without needing a server restart) but also as a hack (because the usual class loader of the JVM does not do that)...&lt;/p&gt;

&lt;p&gt;I don&apos;t know how Eclipse or Android works but I don&apos;t see why a class would be reloaded inside a given application. For Android, the recompilation argument doesn&apos;t even apply.&lt;/p&gt;</comment>
                            <comment id="13036004" author="aploese" created="Thu, 19 May 2011 06:05:19 +0000"  >&lt;blockquote&gt;&lt;p&gt;This does not answer my question, which could be restated as: How can 100 ms matter when the JVM can take several seconds to start up?&lt;br/&gt;
I&apos;m curious of what real applications (that use CM) would run for less than a few seconds...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I could imagin of an GUI app where the users put some values (maybe a 3x3 matix) ant hit the calc button and wait. In a GUI 100 ms are a long time.&lt;/p&gt;

&lt;p&gt;So the developer can load FastMath (if she really want to use FastMath) in a separate thread at startup ...&lt;/p&gt;

&lt;p&gt;Thist hwole issue is more about usabillity and expected behavior and not the fact that it takes up to 100ms to initialize FastMath.&lt;/p&gt;

&lt;p&gt;If I use a lib where I am not really satified with, I will try to replace it. If I know there is a startup penalty, I know it, and I can put the startup time in a place where it does not hurt - its fine.   &lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Tue, 17 May 2011 18:33:05 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>150674</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            5 years, 27 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0rtnb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>160447</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>