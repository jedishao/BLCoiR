<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Thu Dec 01 20:31:39 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/COMPRESS-357/COMPRESS-357.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[COMPRESS-357] BZip2CompressorOutputStream can affect output stream incorrectly</title>
                <link>https://issues.apache.org/jira/browse/COMPRESS-357</link>
                <project id="12310904" key="COMPRESS">Commons Compress</project>
                    <description>&lt;p&gt;BZip2CompressorOutputStream has an unsynchronized finished() method, and an unsynchronized finalize method. Finish checks to see if the output stream is null, and if it is not it calls various methods, some of which write to the output stream. &lt;/p&gt;

&lt;p&gt;Now, consider something like this sequence.&lt;/p&gt;

&lt;p&gt;BZip2OutputStream s = ...&lt;br/&gt;
...&lt;br/&gt;
s.close();&lt;br/&gt;
s = null;&lt;/p&gt;

&lt;p&gt;After the s = null, the stream is garbage. At some point the garbage collector call finalize(), which calls finish(). But, since the GC may be on a different thread, there is no guarantee that the assignment this.out = null in finish() has actually been made visible to the GC thread, which results in bad data in the output stream.&lt;/p&gt;

&lt;p&gt;This is not a theoretical problem; In a part of a large project I&apos;m working on, this happens about 2% of the time. &lt;/p&gt;

&lt;p&gt;The fixes are simple&lt;/p&gt;

&lt;p&gt;1) synchronize finish() or&lt;/p&gt;

&lt;p&gt;2) don&apos;t call finish from finalize().&lt;/p&gt;

&lt;p&gt;A workaround is to derive a class and override the finalize() method. &lt;/p&gt;
</description>
                <environment>&lt;p&gt;multithreaded&lt;/p&gt;</environment>
        <key id="12972789">COMPRESS-357</key>
            <summary>BZip2CompressorOutputStream can affect output stream incorrectly</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.png">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="rashapiro83">Richard Shapiro</reporter>
                        <labels>
                            <label>easyfix</label>
                    </labels>
                <created>Wed, 25 May 2016 17:50:50 +0000</created>
                <updated>Wed, 15 Jun 2016 04:19:38 +0000</updated>
                            <resolved>Wed, 15 Jun 2016 04:19:37 +0000</resolved>
                                    <version>1.9</version>
                    <version>1.11</version>
                                    <fixVersion>1.12</fixVersion>
                                    <component>Compressors</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                    <timeoriginalestimate seconds="3600">1h</timeoriginalestimate>
                            <timeestimate seconds="3600">1h</timeestimate>
                                        <comments>
                            <comment id="15302198" author="bodewig" created="Thu, 26 May 2016 15:04:02 +0000"  >&lt;p&gt;Yes, you are totally correct, many thanks.&lt;/p&gt;

&lt;p&gt;I&apos;ve made &lt;tt&gt;finish&lt;/tt&gt; synchronized with commit 952a503&lt;/p&gt;</comment>
                            <comment id="15324410" author="bodewig" created="Fri, 10 Jun 2016 13:01:50 +0000"  >&lt;p&gt;There is a third option, the one I&apos;ve now taken with git commits 8769bb6 and bdc5ad4 - use a volatile boolean rather than checking out for null-ness.&lt;/p&gt;</comment>
                            <comment id="15324548" author="sebb@apache.org" created="Fri, 10 Jun 2016 14:44:55 +0000"  >&lt;p&gt;The &apos;close&apos; field is now volatile and published safely, but what about the other variables that the finalize() method depends on?&lt;/p&gt;

&lt;p&gt;For example runLength.&lt;/p&gt;</comment>
                            <comment id="15324556" author="bodewig" created="Fri, 10 Jun 2016 14:47:59 +0000"  >&lt;p&gt;I didn&apos;t intend to make finish thread-safe (the class is labeled as NotThreadSafe after all), all I wanted to avoid is running finish twice in the sceario described by this issue.&lt;/p&gt;</comment>
                            <comment id="15325493" author="sebb@apache.org" created="Fri, 10 Jun 2016 23:25:17 +0000"  >&lt;p&gt;I understand, but AFAIK replacing synch. with a volatile changes the behaviour wrt. safe publication.&lt;/p&gt;

&lt;p&gt;If the user code fails to run finish, then it won&apos;t set closed=true and finalize will attempt to run finish.&lt;br/&gt;
For finalize to work, it needs to have access to the latest values of other variables which have been updated in another thread.&lt;/p&gt;

&lt;p&gt;In fact this is exactly the problem detailed in the description - the variable was not published safely.&lt;/p&gt;

&lt;p&gt;The code now publishes &apos;closed&apos; OK, so finalize won&apos;t run finish a second time, but what about other variables that finalize may need to run finish successfully?&lt;/p&gt;</comment>
                            <comment id="15325504" author="sebb@apache.org" created="Fri, 10 Jun 2016 23:32:32 +0000"  >&lt;p&gt;As mentioned on the mailing list, it&apos;s tricky to get finalize working properly.&lt;/p&gt;

&lt;p&gt;Rather than try to fix up bad code, maybe the finalize method should just report if it detects failure to close the resource.&lt;br/&gt;
&lt;span class=&quot;error&quot;&gt;&amp;#91;It should report unclosed resources anyway.&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Also, are there any use-cases where the app code deliberately does not want to close the resource?&lt;/p&gt;</comment>
                            <comment id="15325914" author="bodewig" created="Sat, 11 Jun 2016 15:35:35 +0000"  >&lt;p&gt;I&apos;m not sure whether there is a good use case, but finalize has done so for many releases and the javadocs say so.&lt;/p&gt;

&lt;p&gt;A third approach: git comit abc2d23 which synchronizes the meat of finish.&lt;/p&gt;</comment>
                            <comment id="15325939" author="sebb@apache.org" created="Sat, 11 Jun 2016 16:20:02 +0000"  >&lt;p&gt;Unfortunately AFAICT that still does not guarantee that all the variables will be safely published.&lt;/p&gt;

&lt;p&gt;A variable is only safely published if the write happens-before the read.&lt;/p&gt;

&lt;p&gt;One way to do this is where both the writer and reader synchronize on the &lt;b&gt;same&lt;/b&gt; lock.&lt;/p&gt;

&lt;p&gt;Another way I think is a shared volatile.&lt;br/&gt;
If thread A updates some fields and then writes the volatile, when thread B reads the same volatile it will see any such updates.&lt;br/&gt;
But if thread A has since updated some fields, thread B could see either the original or a later value.&lt;/p&gt;
</comment>
                            <comment id="15325974" author="bodewig" created="Sat, 11 Jun 2016 17:43:31 +0000"  >&lt;p&gt;I&apos;m not convinced we need to think about any publication other than the one of &lt;tt&gt;out&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;This issue is about a thread calling &lt;tt&gt;finish&lt;/tt&gt; and then the GC comes in and runs &lt;tt&gt;finalize&lt;/tt&gt; which in turn runs &lt;tt&gt;finish&lt;/tt&gt; again and the GC thread hasn&apos;t seen &lt;tt&gt;out&lt;/tt&gt; having become &lt;tt&gt;null&lt;/tt&gt;. There shouldn&apos;t be any concurrent reads to any other variables at all as the GC thread is the only one I want to care about - the rest is covered by declaring the whole class not thread safe.&lt;/p&gt;</comment>
                            <comment id="15326670" author="sebb@apache.org" created="Sun, 12 Jun 2016 22:59:29 +0000"  >&lt;p&gt;There are two cases to consider:&lt;br/&gt;
A) the main code runs finish(), and finalize must be prevented from calling finish() again.&lt;br/&gt;
B) the main code does not run finish(), so finalize must call finish()&lt;/p&gt;

&lt;p&gt;Case A is easy to handle; just ensure that the indicator variable (out) is properly published.&lt;/p&gt;

&lt;p&gt;In case B, the finalize method detects that it needs to call finish().&lt;br/&gt;
So far so good, the finalizer thread has only accessed the properly published variable.&lt;br/&gt;
But the finish() method will only work properly if it sees the correct values for all the variables it uses.&lt;br/&gt;
Other variables have not been safely published, so the values seen by the finalizer thread may be arbitrarily stale.&lt;/p&gt;

&lt;p&gt;Note that this is not a problem of concurrent access - it is a problem of safe publication, i.e. ensuring that the variable values written in the main thread are seen by the finalizer thread. &lt;/p&gt;

&lt;p&gt;This is exactly the problem reported in the description; the correct out field value was not seen by the finalizer thread.&lt;/p&gt;

&lt;p&gt;One way to fix this would be to make &lt;b&gt;all&lt;/b&gt; the variables used by finish() volatile.&lt;br/&gt;
I don&apos;t know if that would cause a serious performance hit.&lt;/p&gt;</comment>
                            <comment id="15326728" author="rashapiro83" created="Mon, 13 Jun 2016 01:27:48 +0000"  >&lt;p&gt;I just want to point out that the real problem with this is the presence of a finalize() method. Any code that requires that finalize() be run is almost certainly incorrect, as you can never rely on it ever being called. Since the class is thread-unsafe, there is in practice no additional performance cost to synchronizing both flush() and finish(), since if the lock isn&apos;t essentially free, you aren&apos;t using the class correctly either (i.e., you&apos;d better be calling write() and flush() inside some other synchronized block, or else guarantee they are on the same thread). &lt;/p&gt;

&lt;p&gt;The other thing to remember is that if it&apos;s incorrect, it doesn&apos;t matter how fast something is, and bzip2 is already so slow that I doubt you will ever see the synchronization cost even if you do multi-thread it.&lt;/p&gt;

&lt;p&gt;By far the most correct solution is to get rid of finish().   &lt;/p&gt;</comment>
                            <comment id="15327027" author="sebb@apache.org" created="Mon, 13 Jun 2016 08:59:08 +0000"  >&lt;p&gt;I agree about dropping the code.&lt;/p&gt;

&lt;p&gt;However, rather than eliminate the finalize method entirely, maybe change it to log/print a warning that the stream has not been properly closed.&lt;br/&gt;
This goes some way towards supporting the previously advertised functionality - but of course only for cases where the finalizer is actually called.&lt;/p&gt;

&lt;p&gt;Regarding synch. of flush() and finish(): that isn&apos;t sufficient to solve the safe publication issue.&lt;/p&gt;

&lt;p&gt;Happens-before ordering depends on using the same lock for the writer and reader threads.&lt;br/&gt;
Lock release happens-before lock acquire, and actions (e.g. writes) in a single thread happen-before actions that come later in the program order.&lt;br/&gt;
Unless all methods called by the main thread are synch. then the main thread can write variables after the last shared lock.&lt;/p&gt;

&lt;p&gt;There are various ways to ensure the fields are safely published.&lt;/p&gt;

&lt;p&gt;However as has been pointed out, finalize() may never get run, so app code cannot rely on finish() being called.&lt;br/&gt;
So it does not matter if finish() does not get called even if the finalize() method does get run.&lt;/p&gt;</comment>
                            <comment id="15327032" author="bodewig" created="Mon, 13 Jun 2016 09:06:43 +0000"  >&lt;p&gt;Many thanks for pointing out my flaw of overlooking the case where finalize calls finish on a non-closed stream.&lt;/p&gt;

&lt;p&gt;I&apos;ll start a thread on the mailing list about dropping this specific functionality here. ZipFile is the only other case with finalize and I know of a (valid IMHO) use case for. This seems to be safe, though.&lt;/p&gt;</comment>
                            <comment id="15331116" author="bodewig" created="Wed, 15 Jun 2016 04:19:38 +0000"  >&lt;p&gt;git commit 2424036 has been changed so that &lt;tt&gt;finish&lt;/tt&gt; is no longer called from &lt;tt&gt;finalize&lt;/tt&gt;.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Thu, 26 May 2016 15:04:02 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_12310250" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10430"><![CDATA[Patch]]></customfieldvalue>
    <customfieldvalue key="10431"><![CDATA[Important]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            24 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2yhrb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>