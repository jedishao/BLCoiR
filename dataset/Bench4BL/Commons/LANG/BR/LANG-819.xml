<!-- 
RSS generated by JIRA (6.3.4#6332-sha1:51bc225ef474afe3128b2f66878477f322397b16) at Wed Nov 30 23:14:08 UTC 2016

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary add field=key&field=summary to the URL of your request.
For example:
https://issues.apache.org/jira/si/jira.issueviews:issue-xml/LANG-819/LANG-819.xml?field=key&amp;field=summary
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>6.3.4</version>
        <build-number>6332</build-number>
        <build-date>15-08-2014</build-date>
    </build-info>

<item>
            <title>[LANG-819] EnumUtils.generateBitVector needs a &quot;? extends&quot;</title>
                <link>https://issues.apache.org/jira/browse/LANG-819</link>
                <project id="12310481" key="LANG">Commons Lang</project>
                    <description>&lt;p&gt;    public static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; long generateBitVector(Class&amp;lt;E&amp;gt; enumClass, Iterable&amp;lt;E&amp;gt; values) {&lt;/p&gt;

&lt;p&gt;Should be Iterable&amp;lt;? extends E&amp;gt;.&lt;/p&gt;

&lt;p&gt;This is because although no subclasses of E can exist, the &quot;? extends&quot; is a common idiom for marking the collection as readonly, or not &quot;owned&quot; by the current object.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12606786">LANG-819</key>
            <summary>EnumUtils.generateBitVector needs a &quot;? extends&quot;</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/images/icons/issuetypes/bug.png">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.png">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="arren">Shevek</reporter>
                        <labels>
                    </labels>
                <created>Sun, 9 Sep 2012 18:40:37 +0000</created>
                <updated>Tue, 4 Mar 2014 17:19:18 +0000</updated>
                            <resolved>Fri, 10 Jan 2014 15:42:32 +0000</resolved>
                                    <version>3.0.1</version>
                                    <fixVersion>3.3</fixVersion>
                                    <component>lang.*</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                <comments>
                            <comment id="13452132" author="mbenson" created="Mon, 10 Sep 2012 16:46:49 +0000"  >&lt;p&gt;Do you have any kind of evidence to support your claim that this is a &quot;common idiom&quot; on the order of an unspoken rule?  Due to type erasure a change of this type &lt;em&gt;ought&lt;/em&gt; to be drop-in compatible, but we&apos;d need to be sure.  That hurdle cleared, I have no problem with this.&lt;/p&gt;</comment>
                            <comment id="13452658" author="arren" created="Tue, 11 Sep 2012 02:31:01 +0000"  >&lt;p&gt;Officially:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.oracle.com/javase/tutorial/extra/generics/morefun.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://docs.oracle.com/javase/tutorial/extra/generics/morefun.html&lt;/a&gt; etc etc etc&lt;/p&gt;

&lt;p&gt;From Google:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/1368166/what-is-a-difference-between-super-e-and-extends-e&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://stackoverflow.com/questions/1368166/what-is-a-difference-between-super-e-and-extends-e&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://www.javabeat.net/2008/09/using-super-in-generics-java-5-0/&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.javabeat.net/2008/09/using-super-in-generics-java-5-0/&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;http://www.coderanch.com/t/417919/java-programmer-SCJP/certification/Generic-declarations-super-Vs-extends&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.coderanch.com/t/417919/java-programmer-SCJP/certification/Generic-declarations-super-Vs-extends&lt;/a&gt;&lt;br/&gt;
etc etc etc - the internet is filthy with this stuff.&lt;/p&gt;

&lt;p&gt;See also the javadocs for guice, guava, and other competing libraries - they&apos;re maintained by a group of people who are highly formally trained and very aware of type semantics, and they tend to get this stuff very much correct.&lt;/p&gt;

&lt;p&gt;Basically, people NEED to use ? extends and ? super wherever appropriate, especially in things like transformer and predicate libraries and implementations, otherwise the only way to usefully use polymorphism is to have hard casts, which defeats the entire purpose of using generics. Serializer libraries tend to be notoriously badly written, and defeat the purpose of their own attempted type safety.&lt;/p&gt;

&lt;p&gt;Commons should be audited for this kind of thing overall.&lt;/p&gt;</comment>
                            <comment id="13452659" author="arren" created="Tue, 11 Sep 2012 02:32:52 +0000"  >&lt;p&gt;Note also that you can capture a ? token by creating a separate method&lt;/p&gt;

&lt;p&gt;&amp;lt;T&amp;gt; void foo(A&amp;lt;T&amp;gt; a, B&amp;lt;T&amp;gt; b) { }&lt;/p&gt;

&lt;p&gt;and call this with an A&amp;lt;?&amp;gt; and a B&amp;lt;?&amp;gt; (from different sources, e.g. a Map&amp;lt;Class&amp;lt;?&amp;gt;, A&amp;lt;?&amp;gt;&amp;gt; without a type warning - there&apos;s no way to parameterize that in Java, so one then can&apos;t call value.method(key) as the ?s won&apos;t match, even though everyone knows that ClassToInstanceMap, or Provider, or any other type-safe factory pattern causes it to be the case.&lt;/p&gt;</comment>
                            <comment id="13804661" author="mbenson" created="Thu, 24 Oct 2013 20:53:45 +0000"  >&lt;p&gt;None of these examples convince me (by way of disclosure, I fail to see how your previous comment relates to the discussion at all!).  If enums were extensible I could accept your argument.  If the parameter were &lt;tt&gt;Collection&lt;/tt&gt; instead of &lt;tt&gt;Iterable&lt;/tt&gt; I could accept your argument.  &quot;Just because a bunch of other superficially similar methods look this way&quot; does not seem, to me, to justify changing the method signature for no discernible benefit.  Feel free to reopen if you can provide a working example of (somewhat, at least) sensible code that would be possible with this change and is not possible without it.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Matt&lt;/p&gt;</comment>
                            <comment id="13805137" author="britter" created="Fri, 25 Oct 2013 07:55:56 +0000"  >&lt;p&gt;A good proof that this has to be changed would be a unit test that fails with the current method signature.&lt;/p&gt;</comment>
                            <comment id="13805245" author="mbenson" created="Fri, 25 Oct 2013 11:56:00 +0000"  >&lt;p&gt;In this case I&apos;m expecting that such a sample won&apos;t even compile properly,  but whichever.  &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.gif&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13862742" author="arren" created="Mon, 6 Jan 2014 03:27:13 +0000"  >&lt;p&gt;You misunderstand type bounds. Anyway, here is an example.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; class EnumTest {
    &lt;span class=&quot;code-keyword&quot;&gt;enum&lt;/span&gt; Foo {
        A, B, C;
    }

    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void main(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] args) {
        Set&amp;lt;? &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; Foo&amp;gt; set = EnumSet.allOf(Foo.class);
        &lt;span class=&quot;code-comment&quot;&gt;// set.add(Foo.B);  // Fails to compile: Set is typed read-only. See references above.
&lt;/span&gt;        EnumUtils.generateBitVector(Foo.class, set);    &lt;span class=&quot;code-comment&quot;&gt;// Also fails to compile, even though legitimate.
&lt;/span&gt;        generateBitVector(Foo.class, set); &lt;span class=&quot;code-comment&quot;&gt;// Compiles fine, as method has correct type.
&lt;/span&gt;    }

    &lt;span class=&quot;code-comment&quot;&gt;// Note method signature now has correct type &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; a method which only reads from the given set.
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &amp;lt;E &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; Enum&amp;lt;E&amp;gt;&amp;gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; generateBitVector(&lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt;&amp;lt;E&amp;gt; enumClass, Iterable&amp;lt;? &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; E&amp;gt; values) {
        &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; total = 0;
        &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (E constant : values)
            total |= 1 &amp;lt;&amp;lt; constant.ordinal();
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; total;
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="13862772" author="mbenson" created="Mon, 6 Jan 2014 05:24:59 +0000"  >&lt;p&gt;What have I said to lead you to conclude that I misunderstand type bounds?  It almost seems (and I hope I&apos;m wrong) that I understand them in such a fundamental way that I cannot be easily talked into doing something that makes &lt;em&gt;perfect&lt;/em&gt; sense in the general case, but feels totally useless in this specific one.&lt;/p&gt;

&lt;p&gt;Your example is all well and good &lt;em&gt;for non-&lt;tt&gt;final&lt;/tt&gt; types&lt;/em&gt;, but &lt;tt&gt;Set&amp;lt;? extends Foo&amp;gt;&lt;/tt&gt; is IMHO a red herring.  &lt;tt&gt;EnumSet.allOf(Foo.class)&lt;/tt&gt; returns &lt;tt&gt;EnumSet&amp;lt;Foo&amp;gt;&lt;/tt&gt;, &lt;em&gt;not&lt;/em&gt; &lt;tt&gt;EnumSet&amp;lt;? extends Foo&amp;gt;&lt;/tt&gt;; therefore the entire example is contrived.  If for some reason you were using a &lt;tt&gt;Set&lt;/tt&gt; of whatever element type that you didn&apos;t already &lt;em&gt;know&lt;/em&gt; was &lt;tt&gt;enum&lt;/tt&gt; you&apos;d never &lt;em&gt;pass&lt;/em&gt; that &lt;tt&gt;Set&lt;/tt&gt; to &lt;tt&gt;EnumUtils#generateBitVector()&lt;/tt&gt; without first somehow checking that, at which point you&apos;d have to cast the &lt;tt&gt;Set&lt;/tt&gt; anyway to call the bit vector method.&lt;/p&gt;

&lt;p&gt;I comprehend that you are saying the &lt;tt&gt;? extends E&lt;/tt&gt; idiom makes the compiler disallow the modification of a &lt;tt&gt;Collection&lt;/tt&gt; (an &lt;tt&gt;Iterable&lt;/tt&gt; can&apos;t be modified without casting to &lt;tt&gt;Collection&lt;/tt&gt; anyway) and I can make the logical leap that &lt;em&gt;because of this&lt;/em&gt; it may be a visual shorthand for &quot;read-only,&quot; yet I &lt;em&gt;still&lt;/em&gt; stubbornly refuse to be bullied by this fact when you have not:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;explained your (lacking clarification, striking me as rude and condescending) assertion that I &quot;misunderstand type bounds&quot;&lt;/li&gt;
	&lt;li&gt;provided a realistic example of code that suffers because of the current parameter specification&lt;/li&gt;
	&lt;li&gt;explained how &lt;a href=&quot;https://issues.apache.org/jira/browse/LANG-819?focusedCommentId=13452659&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-13452659&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;this comment&lt;/a&gt; is germane to the discussion&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Regards,&lt;br/&gt;
Matt&lt;/p&gt;</comment>
                            <comment id="13863128" author="arren" created="Mon, 6 Jan 2014 17:23:52 +0000"  >&lt;p&gt;Set&amp;lt;? extends Foo&amp;gt; isn&apos;t a visual shorthand. It&apos;s a concrete statement to the compiler. Your assertion on this point demonstrates that you misunderstand type bounds. All your comments about the possibility of extensibility of enums, Collection/Iterable are concerned with possible runtime behaviour, rather than the ability to prove code correct at compile time. My caller wants a static assertion that the (parent) routine will not modify the collection, and a prior Set&amp;lt;? extends E&amp;gt; can only generate an Iterable&amp;lt;? extends E&amp;gt; without an unchecked cast, which defeats the point.&lt;/p&gt;

&lt;p&gt;Anyway, I was only trying to help within the bounds of my limited remaining patience for the ASF, so I admit to being rude.&lt;/p&gt;</comment>
                            <comment id="13863140" author="mbenson" created="Mon, 6 Jan 2014 17:34:30 +0000"  >&lt;p&gt;I am sorry to contribute to anyone&apos;s impatience with Apache; however, let&apos;s take this one step at a time.  You said:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;My caller wants a static assertion that the (parent) routine will not modify the collection&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I think by this you mean:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;My [consuming code] wants a [compile-time] assertion that the [&lt;tt&gt;EnumUtils#generateBitVector()&lt;/tt&gt;] routine will not modify the collection&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;How does declaring the parameter as &lt;tt&gt;Iterable&lt;/tt&gt;, even if it were raw, not satisfy that requirement? (Once you cast to any other type, all bets are off anyway.)&lt;/p&gt;</comment>
                            <comment id="13867645" author="arren" created="Fri, 10 Jan 2014 09:20:28 +0000"  >&lt;p&gt;I didn&apos;t explain that last point very well due to lack of patience. Hopefully this will help, if you forgive the background:&lt;/p&gt;

&lt;p&gt;There&apos;s an almost-requirement in C/C++ (auto_ptr aside) that a data structure have an &quot;owner&quot; and a number of referrents. The same happens in Java as good style, rather than requirement-to-avoid-leak. A complex class may own a Set&amp;lt;E&amp;gt;. The getter of this set may be typed Set&amp;lt;? extends E&amp;gt;. This tells any other person who takes that reference that they should not (and can not, due to compile failure) modify that set. On the other hand, if it&apos;s a factory method, the method may be typed Set&amp;lt;E&amp;gt;. This tells the person who takes the reference that they may (and can) modify that set, as they are now the primary (usually exclusive) owner of it. This Set&amp;lt;E&amp;gt; type generally comes with the assumption that unsynchronized mutation of the set is also permitted, modifying it will not break the encapsulation of the provider, and it isn&apos;t shared with any other threads. Yes, there are loopholes in this, but it&apos;s pretty good, vastly improves the ability of the compiler to show code correct, and reduces programmer mistakes (unnecessary copies, accidental modifications, etc).&lt;/p&gt;

&lt;p&gt;It isn&apos;t really a surprise to anyone who has coded in Erlang or any monad-based language that it&apos;s actually relatively easy to write Java code where the majority of structures are never mutated after construction. Some languages have this as a restriction, but it turns out to be a fairly good idea even in Java: Most sensible ways to pass values between threads create a happen-before relationship in the JMM, and remembering that final variables have a happen-before relationship with the end of a constructor (something explicitly NOT true for nonfinal variables - not nearly enough people know this), this also makes it much easier to write highly threaded code correctly.  The vast majority of instance variables can be final, and modern IDEs tend to provide this as a default hint if they detect non-mutation, so this really is hitting mainstream. By this set of practices we get a applications where the majority of Collections are typed ? extends, the majority of variables are final, etc, etc.&lt;/p&gt;

&lt;p&gt;Anyway, this is all a suite of techniques for creating compile-time checked, reliable, threaded, idiot-developer-safe Java code.&lt;/p&gt;

&lt;p&gt;At this point, it isn&apos;t about whether EnumUtils will modify the set. I know it won&apos;t. It&apos;s the fact that the code that CALLED EnumUtils only ever had a Collection&amp;lt;? extends E&amp;gt; in the first place, because the &lt;em&gt;actual&lt;/em&gt; owner of the collection, several calls back, decided to export it only as readonly.&lt;/p&gt;

&lt;p&gt;The Guava library (which I mostly use these days) is very well written with respect to all these techniques, and applies them universally. See &lt;a href=&quot;http://docs.guava-libraries.googlecode.com/git/javadoc/index.html?com/google/common/collect/Iterables.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://docs.guava-libraries.googlecode.com/git/javadoc/index.html?com/google/common/collect/Iterables.html&lt;/a&gt; - which shows how Guava handles iterables. The type within the Iterable is irrelevant. The point is, the caller of Iterables (and even back several frames from there) only had a Set&amp;lt;? extends&amp;gt; or a Collection&amp;lt;? extends&amp;gt; and the CALLER would have to upcast it in order to call EnumUtils with the current prototype.&lt;/p&gt;

&lt;p&gt;So, you see, it isn&apos;t about a tiny religious issue about whether I like the current prototype or not. It&apos;s that in any code written with these good coding practices, I CAN&apos;T call EnumUtils without upcasting the Set&amp;lt;? extends E&amp;gt; to a Set&amp;lt;E&amp;gt; in the previous frame, and if I upcast, my code won&apos;t pass review. If I use a raw type, my code won&apos;t pass review. There is NO WAY in which I can call this function and get code past review. I CAN NOT USE MUCH OF COMMONS. Guava, on the other hand, uses ? extends in every case where it&apos;s legal to do so, and can always be called from well-written type-safe code, and has consequently become the go-to library of choice. (That&apos;s also why this ticket languished for a year: we also ported away from commons to guava. But I did come back to try to help.)&lt;/p&gt;

&lt;p&gt;Bootnote on Guava: It&apos;s Google&apos;s policy not to include any routine for which it does not have an internal customer. Apache does not have the same policy. In a recent experience, I submitted correct code and patches to Apache, with test suites, only to have the Apache authors fix up the original broken code to (just) pass the cases in my test suites, but still contain bugs because they fundamentally aren&apos;t internal customers for it and don&apos;t use it in anger or in generality. So it remains broken in Apache. My last experience with that was type (reflection) manipulation routines - my job is writing compilers, so I&apos;m very hot on them, and familiarity breeds ease of spotting bugs, especially in type systems. But I won&apos;t play whack-a-mole submitting test suites to ASF when I have working code anyway. I&apos;ll just use my code. So there&apos;s some additional background to my frustration with ASF maintainers. While Google publish smaller libraries, the quality is unquestionably much higher because of this policy of (colloquially) &quot;If we can&apos;t dogfood it, we won&apos;t even publish it.&quot; They are also 100% familiar with the techniques I described in this comment, and reading any of their libraries in C++ or Java is an education in high-performance compile-time-checked coding. Of course what they don&apos;t do is put JSR305 annotations on their public APIs. I wish they did. I wish Apache would use JSR305, too.&lt;/p&gt;</comment>
                            <comment id="13867789" author="tn" created="Fri, 10 Jan 2014 13:37:35 +0000"  >&lt;p&gt;The idea of using &amp;lt;? extends X&amp;gt; collections to prevent modification by compile-time checks is new to me I have to admit. Although the add-type methods may not work, the resulting collections are still modifiable, e.g. calling clear() or remove() will still work, thus I am unsure if this is really sufficient and the right tool for this purpose. Afaik a better way is to pass unmodifiable collections in such cases.&lt;/p&gt;

&lt;p&gt;Anyway, your rant is a bit unfair, as we normally also allow this idiom as input argument where possible, see for example the latest collections release.&lt;/p&gt;

&lt;p&gt;btw. the guys at google do great stuff, so there surely must be a good reason why they do not use the idiom all the time:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/EnumMultiset.html#create%28java.lang.Iterable,%20java.lang.Class%29&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/EnumMultiset.html#create%28java.lang.Iterable,%20java.lang.Class%29&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Feel free to rant also on their mailinglist ...&lt;/p&gt;</comment>
                            <comment id="13867911" author="mbenson" created="Fri, 10 Jan 2014 15:35:23 +0000"  >&lt;p&gt;This has never been about the &lt;em&gt;correctness&lt;/em&gt; of &lt;tt&gt;? extends&lt;/tt&gt; in this case, rather about the &lt;em&gt;necessity&lt;/em&gt;.  A few days ago I was strongly tempted to just give in and do it just to put the discussion to bed.  I&apos;m glad I did not, because then you, Shevek, wouldn&apos;t have written that nice bit of exposition.  At this point I feel willing to make this change based on the general notion that there may be some sensible call stack of general-purpose methods that results in a &lt;tt&gt;Set&amp;lt;? extends E&amp;gt;&lt;/tt&gt; where &lt;tt&gt;E extends Enum&amp;lt;E&amp;gt;&lt;/tt&gt; which could not otherwise be passed to the method in question.&lt;/p&gt;

&lt;p&gt;It does seem Thomas&apos;s counter-example would result in the same problem.  Can you confirm you wouldn&apos;t be able to call that method and pass review either? Also: &lt;a href=&quot;http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Iterables.html#transform(java.lang.Iterable&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/collect/Iterables.html#transform(java.lang.Iterable&lt;/a&gt;, com.google.common.base.Function)&lt;/p&gt;

&lt;p&gt;I don&apos;t know about your other recent experience, but I personally am very interested in Java reflection and type utilities.  If we&apos;re doing something wrong thereabouts I&apos;d be glad to know about it.  Thanks for your patience.&lt;/p&gt;</comment>
                            <comment id="13867922" author="mbenson" created="Fri, 10 Jan 2014 15:42:32 +0000"  >&lt;p&gt;Committed revision 1557159.&lt;/p&gt;</comment>
                            <comment id="13868294" author="arren" created="Fri, 10 Jan 2014 21:01:18 +0000"  >&lt;p&gt;Thank you very much for the responses.&lt;/p&gt;

&lt;p&gt;C++ can do &quot;Foo const * const * const *&quot; which tells you whether it&apos;s the pointer or the target which is immutable. Java can basically only make the pointers immutable without a little help from this trick. Yes, you &lt;em&gt;can&lt;/em&gt; mutate the collection with Iterator.remove() or Collection.clear() but at least the programmer has already been forced to declare their knowledge that this is Naughty(tm). Also, clear() is presumably slower than the garbage collector if the object is still in eden space, so who does that anyway? Also, see all Google&apos;s typed-immutable collections, which, in return for being immutable, save memory and improve performance.&lt;/p&gt;

&lt;p&gt;Yes, I think that last Google case from Thomas can&apos;t &lt;em&gt;quite&lt;/em&gt; be expressed in the Java type system - it&apos;s not actually quite complete and consistent. You get wrapped up in &quot;? super (? extends E)&quot; which isn&apos;t sufficiently well defined in the lattice. Some of us would love to reduce that to &quot;? super E&quot; which would suffice for practical purposes, but isn&apos;t mathematically correct. Don&apos;t take this comment as gospel - check yourself. I don&apos;t tend to use transform() or map-reduce structures as much as I used to because I tend to be working with very large implicit collections where C*&apos;s OpenBitSet is more relevant than java.util.BitSet or generateBitVector().&lt;/p&gt;</comment>
                            <comment id="13868404" author="arren" created="Fri, 10 Jan 2014 22:24:30 +0000"  >&lt;p&gt;Oh, to answer the last question, to use transform() without upcasting, I might have to wrap Iterable in Iterable. I don&apos;t know. One of the other tricks that works is defining a method whose only purpose is to do type capture. I don&apos;t really like that, but it&apos;s the only way Java lets you have a type (non-first-class) in lexical scope.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310220" key="com.atlassian.jira.ext.charting:firstresponsedate">
                        <customfieldname>Date of First Response</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>Mon, 10 Sep 2012 16:46:49 +0000</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                            <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>251206</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            2 years, 46 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                            <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0b5h3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>62999</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12310222" key="com.atlassian.jira.ext.charting:timeinstatus">
                        <customfieldname>Time in Status</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>