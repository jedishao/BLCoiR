<bugrepository name="rocketmq">
    <bug id="1986" opendate="2020-05-13 00:00:00" fixdate="2022-10-02 00:00:00" resolution="Fixed">
        <buginformation>
            <summary>IndexService#getAndCreateLastIndexFile threadsafe issue.
            </summary>
            <description>The issue tracker is ONLY used for bug report(feature request need to follow RIP process).
                Keep in mind, please check whether there is an existing same report before your raise a new one.
                Alternately (especially if your communication is not a bug report), you can send mail to our mailing
                lists. We welcome any friendly suggestions, bug fixes, collaboration and other improvements.
                Please ensure that your bug report is clear and that it is complete. Otherwise, we may be unable to
                understand it or to reproduce it, either of which would prevent us from fixing the bug. We strongly
                recommend the report(bug report or feature request) could include some hints as the following:
                BUG REPORT

                Please describe the issue you observed:


                What did you do (The steps to reproduce)?


                What did you expect to see?
                thread safe in function getAndCreateLastIndexFile


                What did you see instead?


                Please tell us about your environment:


                Other information (e.g. detailed explanation, logs, related issues, suggestions how to fix, etc):


                FEATURE REQUEST

                Please describe the feature you are requesting.

                getAndCreateLastIndexFile execute in thread ReputMessageService, and ReputMessageService is single
                thread. so

                1、getAndCreateLastIndexFile do not need to use lock readWriteLock。
                2、if want to use readWriteLock，where IndexFile is null we try to create new file，it's not thread safe。

                public IndexFile getAndCreateLastIndexFile() {
                IndexFile indexFile = null;
                IndexFile prevIndexFile = null;
                long lastUpdateEndPhyOffset = 0;
                long lastUpdateIndexTimestamp = 0;

                {
                this.readWriteLock.readLock().lock();
                if (!this.indexFileList.isEmpty()) {
                IndexFile tmp = this.indexFileList.get(this.indexFileList.size() - 1);
                if (!tmp.isWriteFull()) {
                indexFile = tmp;
                } else {
                lastUpdateEndPhyOffset = tmp.getEndPhyOffset();
                lastUpdateIndexTimestamp = tmp.getEndTimestamp();
                prevIndexFile = tmp;
                }
                }

                this.readWriteLock.readLock().unlock();
                }

                // not thread safe here
                if (indexFile == null) {
                try {
                String fileName =
                this.storePath + File.separator
                + UtilAll.timeMillisToHumanString(System.currentTimeMillis());
                indexFile =
                new IndexFile(fileName, this.hashSlotNum, this.indexNum, lastUpdateEndPhyOffset,
                lastUpdateIndexTimestamp);
                this.readWriteLock.writeLock().lock();
                this.indexFileList.add(indexFile);
                } catch (Exception e) {
                log.error("getLastIndexFile exception ", e);
                } finally {
                this.readWriteLock.writeLock().unlock();
                }

                if (indexFile != null) {
                final IndexFile flushThisFile = prevIndexFile;
                Thread flushThread = new Thread(new Runnable() {
                @Override
                public void run() {
                IndexService.this.flush(flushThisFile);
                }
                }, "FlushIndexFileThread");

                flushThread.setDaemon(true);
                flushThread.start();
                }
                }

                return indexFile;
                }


                Provide any additional detail on your proposed use case for this feature.


                Indicate the importance of this issue to you (blocker, must-have, should-have, nice-to-have). Are you
                currently using any workarounds to address this issue?


                If there are some sub-tasks using -[] for each subtask and create a corresponding issue to map to the
                sub task:


                sub-task1-issue-number: sub-task1 description here,
                sub-task2-issue-number: sub-task2 description here,
                ...

            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.apache.rocketmq.broker.filter.ConsumerFilterManager.java</file>
            <file type="M">org.apache.rocketmq.common.message.MessageExt.java</file>
            <file type="M">org.apache.rocketmq.store.StoreStatsService.java</file>
            <file type="M">org.apache.rocketmq.store.index.IndexService.java</file>
            <file type="M">org.apache.rocketmq.store.StoreStatsServiceTest.java</file>
            <file type="M">org.apache.rocketmq.store.index.IndexServiceTest.java</file>
        </fixedFiles>
    </bug>
    <bug id="4143" opendate="2022-04-10 00:00:00" fixdate="2022-08-12 00:00:00" resolution="Fixed">
        <buginformation>
            <summary>Unnecessary file lock in IndexFile and IndexService.
            </summary>
            <description>The FileLock used in IndexFile and IndexService is unnecessary, so we can remove it.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.apache.rocketmq.store.index.IndexFile.java</file>
            <file type="M">org.apache.rocketmq.store.index.IndexService.java</file>
            <file type="M">org.apache.rocketmq.store.index.IndexFileTest.java</file>
        </fixedFiles>
    </bug>
    <bug id="4686" opendate="2022-07-25 00:00:00" fixdate="2022-07-26 00:00:00" resolution="Fixed">
        <buginformation>
            <summary>The lock was released in the wrong position.
            </summary>
            <description>BUG REPORT
                Please describe the issue you observed:
                What did you do (The steps to reproduce)?

                In org.apache.rocketmq.namesrv.kvconfig.KVConfigManager#putKVConfig


                try {
                this.lock.writeLock().lockInterruptibly();
                try {
                HashMap#String, String> kvTable = this.configTable.get(namespace);
                if (null == kvTable) {
                kvTable = new HashMap();
                this.configTable.put(namespace, kvTable);
                log.info("putKVConfig create new Namespace {}", namespace);
                }

                final String prev = kvTable.put(key, value);
                if (null != prev) {
                log.info("putKVConfig update config item, Namespace: {} Key: {} Value: {}",
                namespace, key, value);
                } else {
                log.info("putKVConfig create new config item, Namespace: {} Key: {} Value: {}",
                namespace, key, value);
                }
                } finally {
                this.lock.writeLock().unlock();
                }
                } catch (InterruptedException e) {
                log.error("putKVConfig InterruptedException", e);
                }

                The lock should be released in the outermost layer in case the lock cannot be released due to an
                exception after it is acquired

                What is expected to see?

                The lock is released in the correct position

                What did you see instead?

                The lock is released in the wrong position

                Please tell us about your environment:

                develop

                Other information (e.g. detailed explanation, logs, related issues, suggestions on how to fix, etc):

                The thread should return to the interrupted state after being interrupted
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.apache.rocketmq.namesrv.kvconfig.KVConfigManager.java</file>
        </fixedFiles>
    </bug>
    <bug id="5039" opendate="2022-09-09 00:00:00" fixdate="2022-09-20 00:00:00" resolution="Fixed">
        <buginformation>
            <summary>localHostName() get stuck when constructing the BrokerIdentity object.
            </summary>
            <description>"main" #1 prio=5 os_prio=31 tid=0x00007ff911809000 nid=0x1603 runnable [0x000070000933d000]
                java.lang.Thread.State: RUNNABLE
                at java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)
                at java.net.InetAddress$2.lookupAllHostAddr(InetAddress.java:929)
                at java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1324)
                at java.net.InetAddress.getLocalHost(InetAddress.java:1501)
                - locked#0x00000006c00da5d0> (a java.lang.Object)
                at org.apache.rocketmq.common.BrokerIdentity.localHostName(BrokerIdentity.java:104)
                at org.apache.rocketmq.common.BrokerIdentity.#init>(BrokerIdentity.java:38)
                at org.apache.rocketmq.broker.BrokerController.getBrokerIdentity(BrokerController.java:1998)
                at org.apache.rocketmq.broker.BrokerController.doRegisterBrokerAll(BrokerController.java:1685)
                at org.apache.rocketmq.broker.BrokerController.registerBrokerAll(BrokerController.java:1661)
                - locked#0x00000006c0090950> (a org.apache.rocketmq.broker.BrokerController)
                at org.apache.rocketmq.broker.BrokerController.start(BrokerController.java:1525)
                at org.apache.rocketmq.test.base.IntegrationTestBase.createAndStartBroker(IntegrationTestBase.java:160)
                at org.apache.rocketmq.test.base.IntegrationTestBase.createAndStartBroker(IntegrationTestBase.java:148)
                at org.apache.rocketmq.test.base.BaseConf.#clinit>(BaseConf.java:86)
                at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
                at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
                at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
                at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
                at org.junit.runners.BlockJUnit4ClassRunner.createTest(BlockJUnit4ClassRunner.java:250)
                at org.junit.runners.BlockJUnit4ClassRunner.createTest(BlockJUnit4ClassRunner.java:260)
                at org.junit.runners.BlockJUnit4ClassRunner$2.runReflectiveCall(BlockJUnit4ClassRunner.java:309)
                at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
                at org.junit.runners.BlockJUnit4ClassRunner.methodBlock(BlockJUnit4ClassRunner.java:306)
                at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)
                at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)
                at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)
                at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)
                at org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)
                at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)
                at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)
                at org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)
                at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)
                at org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)
                at org.junit.runners.ParentRunner.run(ParentRunner.java:413)
                at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
                at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)
                at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)
                at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:220)
                at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:53)

                The BrokerIdentity is frequently constructed in many cases. It's not a good idea to initialize an
                instance of InetAddress every time.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.apache.rocketmq.common.BrokerIdentity.java</file>
        </fixedFiles>
    </bug>
</bugrepository>