Bug 174423  [Progress] org.eclipse.ui.progress.DeferredTreeContentManager adds duplicate items in a treeBuild ID: M20060921-0945

Steps To Reproduce:
1. Tree content provider should query children using org.eclipse.ui.progress.DeferredTreeContentManager
2. Try refreshing a node in a tree by pressing and holding some key (accelerator for your tree)
3. After holding for some time and releasing the key, each child-node in a tree will be duplicated.


More information:
I am using DeferredTreeContentManager this way in my ContentProvider implements ITreeContentProvider:
    public Object [] getChildren(Object parentElement)
    {
        Object children[] = getDeferredManager().getChildren(model);
        return children;
    }
    /**
     * 
     * @return manager that loads children in a separete thread
     */
    private DeferredTreeContentManager getDeferredManager()
    {
        if (manager == null)
        {
            manager = new DeferredTreeContentManager(this, treeViewer);
        }
        return manager;
    }
So, the problem is in this method in DeferredTreeContentManager:
    /**
     * Create a UIJob to add the children to the parent in the tree viewer.
     * 
     * @param parent
     * @param children
     * @param monitor
     */
    protected void addChildren(final Object parent, final Object[] children,
            IProgressMonitor monitor) {
        WorkbenchJob updateJob = new WorkbenchJob(
				ProgressMessages.DeferredTreeContentManager_AddingChildren) {
            /*
             * (non-Javadoc)
             * 
             * @see org.eclipse.ui.progress.UIJob#runInUIThread(org.eclipse.core.runtime.IProgressMonitor)
             */
            public IStatus runInUIThread(IProgressMonitor updateMonitor) {
                //Cancel the job if the tree viewer got closed
                if (treeViewer.getControl().isDisposed()) {
					return Status.CANCEL_STATUS;
				}
                treeViewer.add(parent, children);
                return Status.OK_STATUS;
            }
        };
        updateJob.setSystem(true);
        updateJob.schedule();

    }
The problems is that within a job there is no consulting with the progress monitor - there should be a simple check if it is cancelled. If the monitor was not cancelled, then only add the children. It happens because once a new job is started for quering children all the previous are cancelled, but nevertheless within that job there is no check for that.