<bugrepository name="eclipse.jdt.core">
    <bug id="291322" opendate="2009-10-05 06:46:33" fixdate="2010-01-21 10:05:34" resolution="Fixed">
        <buginformation>
            <summary>Test errors when running JDT Core tests on Windows 7.
            </summary>
            <description>Some tests randomly cause exceptions on tear down when running on Windows 7.
                This is caused by a known Windows issue that a lock on a file might not get freed immediately and hence
                subsequent calls to e.g. delete the file fails.
                Pattern is to retry several times.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.apt.tests.TestUtil.java</file>
        </fixedFiles>
    </bug>
    <bug id="58314" opendate="2004-04-13 11:45:43" fixdate="2004-05-18 13:10:06" resolution="Fixed">
        <buginformation>
            <summary>Make ASTs thread-safe for multiple readers.
            </summary>
            <description>20040413
                Found this exception in the console.
                My guess is that came from visiting the AST from multiple threads.
                The cursor managment doesn't seem to be thread save.
                java.lang.NullPointerException
                at java.lang.Throwable.#init>(Throwable.java)
                at java.lang.Throwable.#init>(Throwable.java)
                at java.lang.NullPointerException.#init>(NullPointerException.java:60)
                at org.eclipse.jdt.core.dom.ASTNode$NodeList.releaseCursor
                (ASTNode.java)
                at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java)
                at org.eclipse.jdt.core.dom.CompilationUnit.accept0
                (CompilationUnit.java
                )
                at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java)
                at
                org.eclipse.jdt.internal.ui.javaeditor.OverrideIndicatorManager.updat
                eAnnotations(OverrideIndicatorManager.java)
                at
                org.eclipse.jdt.internal.ui.javaeditor.OverrideIndicatorManager.recon
                ciled(OverrideIndicatorManager.java:271)
                at
                org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.reconcil
                ed(CompilationUnitEditor.java)
                at
                org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconci
                le(JavaReconcilingStrategy.java)
                at
                org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconci
                le(JavaReconcilingStrategy.java:118)
                at
                org.eclipse.jface.text.reconciler.CompositeReconcilingStrategy.reconc
                ile(CompositeReconcilingStrategy.java)
                at
                org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.rec
                oncile(JavaCompositeReconcilingStrategy.java)
                at org.eclipse.jface.text.reconciler.MonoReconciler.process
                (MonoReconcil
                er.java:76)
                at
                org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread
                .run(AbstractReconciler.java)
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.core.dom.AbstractTypeDeclaration.java</file>
            <file type="M">org.eclipse.jdt.core.dom.ForStatement.java</file>
            <file type="M">org.eclipse.jdt.core.dom.FieldDeclaration.java</file>
            <file type="M">org.eclipse.jdt.core.dom.PostfixExpression.java</file>
            <file type="M">org.eclipse.jdt.core.dom.ThrowStatement.java</file>
            <file type="M">org.eclipse.jdt.core.dom.ConditionalExpression.java</file>
            <file type="M">org.eclipse.jdt.core.dom.Annotation.java</file>
            <file type="M">org.eclipse.jdt.core.dom.MemberRef.java</file>
            <file type="M">org.eclipse.jdt.core.dom.SwitchStatement.java</file>
            <file type="M">org.eclipse.jdt.core.dom.PrefixExpression.java</file>
            <file type="M">org.eclipse.jdt.core.dom.SimpleType.java</file>
            <file type="M">org.eclipse.jdt.core.dom.TypeParameter.java</file>
            <file type="M">org.eclipse.jdt.core.dom.InstanceofExpression.java</file>
            <file type="M">org.eclipse.jdt.core.dom.CatchClause.java</file>
            <file type="M">org.eclipse.jdt.core.dom.VariableDeclarationExpression.java</file>
            <file type="M">org.eclipse.jdt.core.dom.EnhancedForStatement.java</file>
            <file type="M">org.eclipse.jdt.core.dom.SingleVariableDeclaration.java</file>
            <file type="M">org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration.java</file>
            <file type="M">org.eclipse.jdt.core.dom.QualifiedName.java</file>
            <file type="M">org.eclipse.jdt.core.dom.ArrayType.java</file>
            <file type="M">org.eclipse.jdt.core.dom.Assignment.java</file>
            <file type="M">org.eclipse.jdt.core.dom.InfixExpression.java</file>
            <file type="M">org.eclipse.jdt.core.dom.SuperMethodInvocation.java</file>
            <file type="M">org.eclipse.jdt.core.dom.IfStatement.java</file>
            <file type="M">org.eclipse.jdt.core.dom.MethodRef.java</file>
            <file type="M">org.eclipse.jdt.core.dom.AssertStatement.java</file>
            <file type="M">org.eclipse.jdt.core.dom.QualifiedType.java</file>
            <file type="M">org.eclipse.jdt.core.dom.EnumConstantDeclaration.java</file>
            <file type="M">org.eclipse.jdt.core.dom.SingleMemberAnnotation.java</file>
            <file type="M">org.eclipse.jdt.core.dom.VariableDeclarationStatement.java</file>
            <file type="M">org.eclipse.jdt.core.dom.TypeLiteral.java</file>
            <file type="M">org.eclipse.jdt.core.dom.WhileStatement.java</file>
            <file type="M">org.eclipse.jdt.core.dom.PackageDeclaration.java</file>
            <file type="M">org.eclipse.jdt.core.dom.ParameterizedType.java</file>
            <file type="M">org.eclipse.jdt.core.dom.DoStatement.java</file>
            <file type="M">org.eclipse.jdt.core.dom.ImportDeclaration.java</file>
            <file type="M">org.eclipse.jdt.core.dom.ExpressionStatement.java</file>
            <file type="M">org.eclipse.jdt.core.dom.TypeDeclarationStatement.java</file>
            <file type="M">org.eclipse.jdt.core.dom.ArrayAccess.java</file>
            <file type="M">org.eclipse.jdt.core.dom.ParenthesizedExpression.java</file>
            <file type="M">org.eclipse.jdt.core.dom.Initializer.java</file>
            <file type="M">org.eclipse.jdt.core.dom.SuperFieldAccess.java</file>
            <file type="M">org.eclipse.jdt.core.dom.SwitchCase.java</file>
            <file type="M">org.eclipse.jdt.core.dom.ASTNode.java</file>
            <file type="M">org.eclipse.jdt.core.dom.MemberValuePair.java</file>
            <file type="M">org.eclipse.jdt.core.dom.ClassInstanceCreation.java</file>
            <file type="M">org.eclipse.jdt.core.dom.CastExpression.java</file>
            <file type="M">org.eclipse.jdt.core.dom.SynchronizedStatement.java</file>
            <file type="M">org.eclipse.jdt.core.dom.VariableDeclarationFragment.java</file>
            <file type="M">org.eclipse.jdt.core.dom.LabeledStatement.java</file>
            <file type="M">org.eclipse.jdt.core.dom.ArrayCreation.java</file>
            <file type="M">org.eclipse.jdt.core.dom.MethodInvocation.java</file>
            <file type="M">org.eclipse.jdt.core.dom.MethodDeclaration.java</file>
            <file type="M">org.eclipse.jdt.core.dom.TryStatement.java</file>
            <file type="M">org.eclipse.jdt.core.dom.FieldAccess.java</file>
            <file type="M">org.eclipse.jdt.core.dom.MethodRefParameter.java</file>
        </fixedFiles>
    </bug>
    <bug id="327143" opendate="2010-10-06 13:37:20" fixdate="2011-02-01 09:59:34" resolution="Fixed">
        <buginformation>
            <summary>IndexManager should not accept new jobs if the processing thread is null.
            </summary>
            <description>I ran into a case where a simulateExit() was called and the next touch(..) call failed.
                The consequence was that the simulateRestart() was never called.
                But a new jar file added ended up being added into the waiting jobs and the index manager was in an
                infinite loop and the number of awaiting jobs was always 1 and since the processing thread was null,
                that job was never run.
                So we must make sure that the index manager doesn't accept new jobs if the processing thread is null or
                if stops the loop when there is an awaiting job but the thread is null.
                Right now the loop never ends unless the number of awaiting jobs is 0.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.compiler.batch.messages.properties</file>
            <file type="M">org.eclipse.jdt.internal.core.search.processing.JobManager.java</file>
        </fixedFiles>
    </bug>
    <bug id="464570" opendate="2015-04-14 03:41:53" fixdate="2015-08-20 22:25:31" resolution="Fixed">
        <buginformation>
            <summary>race condition on static field CodeStream.noVisibleLocals in method CodeStream.init().
            </summary>
            <description>weblogic make use of JDT to compile the translated java source from jsp files to java bytecode
                with multi-threads, ArrayIndexOutOfBoundsException occurs intermittently as following stack showing
                (weblogic repackaged the jdt jar for avoiding potential class conflict):
                java.lang.ArrayIndexOutOfBoundsException
                at java.lang.System.arraycopy(Native Method)
                at com.bea.core.repackaged.jdt.internal.compiler.codegen.CodeStream.init(CodeStream.java:4114)
                at
                com.bea.core.repackaged.jdt.internal.compiler.codegen.StackMapFrameCodeStream.init(StackMapFrameCodeStream.java:426)
                at
                com.bea.core.repackaged.jdt.internal.compiler.codegen.TypeAnnotationCodeStream.init(TypeAnnotationCodeStream.java:149)
                at com.bea.core.repackaged.jdt.internal.compiler.codegen.CodeStream.reset(CodeStream.java:6665)
                at
                com.bea.core.repackaged.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:330)
                at
                com.bea.core.repackaged.jdt.internal.compiler.ast.AbstractMethodDeclaration.generateCode(AbstractMethodDeclaration.java:281)
                at
                com.bea.core.repackaged.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:567)
                at
                com.bea.core.repackaged.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:636)
                at
                com.bea.core.repackaged.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:368)
                at com.bea.core.repackaged.jdt.internal.compiler.Compiler.process(Compiler.java:814)
                at com.bea.core.repackaged.jdt.internal.compiler.Compiler.processCompiledUnits(Compiler.java:488)
                at com.bea.core.repackaged.jdt.internal.compiler.Compiler.compile(Compiler.java:453)
                at weblogic.jsp.internal.java.JDTJavaCompiler.generateByteCode(JDTJavaCompiler.java:137)
                at weblogic.jsp.internal.java.JavaSourceFile._codeGen(JavaSourceFile.java:211)
                at weblogic.jsp.internal.java.JavaSourceFile.codeGen(JavaSourceFile.java:201)
                at weblogic.jsp.internal.ProxySourceFile.compileGeneratedFiles(ProxySourceFile.java:330)
                at weblogic.jsp.internal.ProxySourceFile.codeGen(ProxySourceFile.java:258)
                at weblogic.jsp.internal.SourceFile.codeGen(SourceFile.java:327)
                at weblogic.jsp.internal.client.ClientUtilsImpl$CodeGenJob.run(ClientUtilsImpl.java:622)
                at weblogic.jsp.internal.client.Job.performJob(Job.java:85)
                at weblogic.jsp.internal.client.ThreadPool$WorkerThread.run(ThreadPool.java:219)
                This AIOOBE should be caused by race-condition on the shared static field
                org.eclipse.jdt.internal.compiler.codegen.CodeStream.noVisibleLocals, it's easy to figure out a case
                which can reproduce such AIOOBE, one of the possible fixes may be:
                index 8a1c987..58e40b7 100644
                --- a/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
                +++ b/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/codegen/CodeStream.java
                @@ -4108,29 +4108,37 @@ public void init(ClassFile targetClassFile) {
                this.pcToSourceMapSize = 0;
                this.lastEntryPC = 0;
                int length = this.visibleLocals.length;
                + LocalVariableBinding[] noVisibleLocals = this.noVisibleLocals;
                if (noVisibleLocals.length length) {
                noVisibleLocals = new LocalVariableBinding[length];
                + this.noVisibleLocals = noVisibleLocals;
                }
                System.arraycopy(noVisibleLocals, 0, this.visibleLocals, 0, length);
                this.visibleLocalsCount = 0;
                length = this.locals.length;
                + LocalVariableBinding[] noLocals = this.noLocals;
                if (noLocals.length length) {
                noLocals = new LocalVariableBinding[length];
                + this.noLocals = noLocals;
                }
                System.arraycopy(noLocals, 0, this.locals, 0, length);
                this.allLocalsCounter = 0;
                length = this.exceptionLabels.length;
                + ExceptionLabel[] noExceptionHandlers = this.noExceptionHandlers;
                if (noExceptionHandlers.length length) {
                noExceptionHandlers = new ExceptionLabel[length];
                + this.noExceptionHandlers = noExceptionHandlers;
                }
                System.arraycopy(noExceptionHandlers, 0, this.exceptionLabels, 0, length);
                this.exceptionLabelsCounter = 0;
                length = this.labels.length;
                + BranchLabel[] noLabels = this.noLabels;
                if (noLabels.length length) {
                noLabels = new BranchLabel[length];
                + this.noLabels = noLabels;
                }
                System.arraycopy(noLabels, 0, this.labels, 0, length);
                this.countLabels = 0;
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.compiler.codegen.CodeStream.java</file>
        </fixedFiles>
    </bug>
    <bug id="29585" opendate="2003-01-15 18:22:34" fixdate="2003-02-10 10:21:56" resolution="Fixed">
        <buginformation>
            <summary>Core Exception as resource tree is locked initializing classpath container.
            </summary>
            <description>Java Model Exception: Core Exception [code 4] The resource tree is locked for modifications.
                at org.eclipse.jdt.core.JavaCore.setClasspathContainer(JavaCore.java:2705)
                at org.eclipse.jdt.internal.launching.JREContainerInitializer.initialize
                (JREContainerInitializer.java:59)
                at org.eclipse.jdt.core.JavaCore$1.run(JavaCore.java:827)
                at org.eclipse.core.internal.runtime.InternalPlatform.run
                (InternalPlatform.java:852)
                at org.eclipse.core.runtime.Platform.run(Platform.java:413)
                at org.eclipse.jdt.core.JavaCore.getClasspathContainer(JavaCore.java:822)
                at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath
                (JavaProject.java:1490)
                at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath
                (JavaProject.java:1406)
                at org.eclipse.jdt.internal.core.JavaProject.getResolvedClasspath
                (JavaProject.java:1382)
                at org.eclipse.jdt.internal.core.DeltaProcessor.initializeRoots
                (DeltaProcessor.java:1076)
                at org.eclipse.jdt.internal.core.DeltaProcessor.processResourceDelta
                (DeltaProcessor.java:1349)
                at org.eclipse.jdt.internal.core.DeltaProcessor.resourceChanged
                (DeltaProcessor.java:1636)
                at org.eclipse.core.internal.events.NotificationManager$1.run
                (NotificationManager.java:137)
                at org.eclipse.core.internal.runtime.InternalPlatform.run
                (InternalPlatform.java:852)
                at org.eclipse.core.runtime.Platform.run(Platform.java:413)
                at org.eclipse.core.internal.events.NotificationManager.notify
                (NotificationManager.java:152)
                at org.eclipse.core.internal.events.NotificationManager.broadcastChanges
                (NotificationManager.java:67)
                at org.eclipse.core.internal.resources.Workspace.broadcastChanges
                (Workspace.java:154)
                at org.eclipse.core.internal.resources.Workspace.endOperation
                (Workspace.java:885)
                at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1585)
                at org.eclipse.debug.internal.core.BreakpointManager$5.run
                (BreakpointManager.java:690)
                at java.lang.Thread.run(Thread.java:536)
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.core.JavaCore.java</file>
            <file type="M">org.eclipse.jdt.internal.core.JavaElement.java</file>
            <file type="M">org.eclipse.jdt.core.tests.model.ClasspathInitializerTests.java</file>
        </fixedFiles>
    </bug>
    <bug id="421473" opendate="2013-11-11 13:09:28" fixdate="2013-11-12 08:40:20" resolution="Fixed">
        <buginformation>
            <summary>Delayed assignment of declaring scope for arguments creates a race condition.
            </summary>
            <description>BETA_JAVA8:
                Staring at LocalVariableBinding.getAnnotations(), I see that there is a potential race condition there:
                The setting of declaringScope happens far away from the creation of LVB and if there are calls in
                between to getAnnotations(), we can't retrieve it from the annotation holder since this requires a
                handle to enclosing source type which is obtainable only from a scope.
                To circumvent this, there is a block of code in this method that manufactures an array of annotation
                bindings and returns it without going to the holder.
                However, this is problematic since with Java 8 some of the annotations could actually be type
                annotations which should be detached from the parameters. This block of code itself cannot filter the
                type annotations because there are clients that need to see all the annotations to transfer the type
                annotations to type.
                I think the solution is to set the declaring scope eagerly.
                At least for arguments, I don't know what side effects ensue for doing this for all locals.
                Patch will follow shortly.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.compiler.apt.tests.processors.elements.Java8ElementProcessor.java</file>
            <file type="M">org.eclipse.jdt.compiler.apt.tests.resources.targets.model8.InterfaceTest.java</file>
            <file type="M">org.eclipse.jdt.compiler.apt.tests.resources.targets.model8.a.TypeParameterTest.java</file>
            <file type="M">org.eclipse.jdt.compiler.apt.tests.Java8ElementsTests.java</file>
            <file type="M">org.eclipse.jdt.internal.compiler.lookup.AptSourceLocalVariableBinding.java</file>
            <file type="M">org.eclipse.jdt.internal.compiler.ast.ASTNode.java</file>
            <file type="M">org.eclipse.jdt.internal.compiler.ast.Argument.java</file>
            <file type="M">org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding.java</file>
            <file type="M">org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.java</file>
        </fixedFiles>
    </bug>
    <bug id="431275" opendate="2014-03-26 14:08:36" fixdate="2014-06-16 02:38:17" resolution="Fixed">
        <buginformation>
            <summary>Deadlock in JavaModelManager$PerProjectInfo and DeltaProcessingState.
            </summary>
            <description>An adopter product (IBM) than runs in headless mode is hitting a deadlock with monitors
                org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo and
                org/eclipse/jdt/internal/core/DeltaProcessingState.
                This product started to hit this deadlock with JDT 3.6.50.v_B79_R36x_J7
                (org.eclipse.jdt.core_3.6.50.v_B79_R36x_J7.jar).
                They did not see this deadlock when they were using 3.6.4.v_A79_R36x
                (org.eclipse.jdt.core_3.6.4.v_A79_R36x).
                I noticed that the patch in bugzilla https://bugs.eclipse.org/bugs/show_bug.cgi?id=338006 was put into
                the stream between those two versions (although the bugzilla was targeted to 3.7.
                maybe was backported), and the code added there appears in all the stack traces I have collected
                (specifically, the call to the new method DeltaProcessor.addPackageFragmentRoot in
                DeltaProcessor.addToParentInfo).
                BTW, I compared the code with the latest code in master, and the code path involved in these stacks has
                not changed, so I believe this could happen in master as well.
                Below are the stack traces.
                Thread Name
                Worker-2
                State
                Deadlock/Blocked
                Monitor
                Owns Monitor Lock on org/eclipse/jdt/internal/core/DeltaProcessingState@0x0000000007292CF8
                Waiting for Monitor Lock on
                org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo@0x000000001603D008
                Java Stack
                at org/eclipse/jdt/internal/core/JavaProject.getResolvedClasspath(JavaProject.java:1956)
                at
                org/eclipse/jdt/internal/core/PackageFragmentRoot.getResolvedClasspathEntry(PackageFragmentRoot.java:563)
                at org/eclipse/jdt/internal/core/DeltaProcessor.addPackageFragmentRoot(DeltaProcessor.java:325)
                at org/eclipse/jdt/internal/core/DeltaProcessor.addToParentInfo(DeltaProcessor.java:297)
                at org/eclipse/jdt/internal/core/DeltaProcessor.elementAdded(DeltaProcessor.java:1156)
                at org/eclipse/jdt/internal/core/DeltaProcessor.updateCurrentDeltaAndIndex(DeltaProcessor.java:2483)
                at org/eclipse/jdt/internal/core/DeltaProcessingState.updateRoots(DeltaProcessingState.java:621)
                at org/eclipse/jdt/internal/core/DeltaProcessor.updateCurrentDeltaAndIndex(DeltaProcessor.java:2479)
                at org/eclipse/jdt/internal/core/DeltaProcessor.traverseDelta(DeltaProcessor.java:2206)
                at org/eclipse/jdt/internal/core/DeltaProcessor.processResourceDelta(DeltaProcessor.java:1894)
                at org/eclipse/jdt/internal/core/DeltaProcessor.resourceChanged(DeltaProcessor.java:2067)
                at org/eclipse/jdt/internal/core/DeltaProcessingState.resourceChanged(DeltaProcessingState.java:470)
                at org/eclipse/core/internal/events/NotificationManager$2.run(NotificationManager.java:291)
                at org/eclipse/core/runtime/SafeRunner.run(SafeRunner.java:42)
                at org/eclipse/core/internal/events/NotificationManager.notify(NotificationManager.java:285)
                at org/eclipse/core/internal/events/NotificationManager.broadcastChanges(NotificationManager.java:149)
                at org/eclipse/core/internal/resources/Workspace.broadcastPostChange(Workspace.java:327)
                at org/eclipse/core/internal/resources/Workspace.endOperation(Workspace.java:1181)
                at org/eclipse/core/internal/resources/Workspace.run(Workspace.java:1984)
                at org/eclipse/core/internal/events/NotificationManager$NotifyJob.run(NotificationManager.java:40)
                at org/eclipse/core/internal/jobs/Worker.run(Worker.java:54)
                Thread Name
                main
                State
                Deadlock/Blocked
                Monitor
                Owns Monitor Lock on org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo@0x000000001603D008
                Waiting for Monitor Lock on org/eclipse/jdt/internal/core/DeltaProcessingState@0x0000000007292CF8
                Java Stack
                at
                org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo.addClasspathChange(JavaModelManager.java:1209)
                at
                org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo.setClasspath(JavaModelManager.java:1190)
                at
                org/eclipse/jdt/internal/core/JavaModelManager$PerProjectInfo.setResolvedClasspath(JavaModelManager.java:1229)
                at org/eclipse/jdt/internal/core/JavaProject.resolveClasspath(JavaProject.java:2859)
                at org/eclipse/jdt/internal/core/JavaProject.getResolvedClasspath(JavaProject.java:1991)
                at
                org/eclipse/jem/workbench/utility/JemProjectUtilities.collectClasspathURLs(JemProjectUtilities.java:452)
                at
                org/eclipse/jem/workbench/utility/JemProjectUtilities.getClasspathAsURLArray(JemProjectUtilities.java:436)
                ...
                (Adopter code)
                ...
                at org/eclipse/core/internal/resources/Workspace.run(Workspace.java:1975)
                at org/eclipse/core/internal/resources/Workspace.run(Workspace.java:1957)
                ...
                (Adopter code)
                ...
                at sun/reflect/NativeMethodAccessorImpl.invoke0(Native Method)
                at sun/reflect/NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:60)
                at sun/reflect/DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)
                at java/lang/reflect/Method.invoke(Method.java:611)
                at
                org/eclipse/equinox/internal/app/EclipseAppContainer.callMethodWithException(EclipseAppContainer.java:587)
                at org/eclipse/equinox/internal/app/EclipseAppHandle.run(EclipseAppHandle.java:198)
                at
                org/eclipse/core/runtime/internal/adaptor/EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
                at org/eclipse/core/runtime/internal/adaptor/EclipseAppLauncher.start(EclipseAppLauncher.java:79)
                at org/eclipse/core/runtime/adaptor/EclipseStarter.run(EclipseStarter.java:369)
                ...
                (Adopter code)
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.core.DeltaProcessingState.java</file>
        </fixedFiles>
    </bug>
</bugrepository>