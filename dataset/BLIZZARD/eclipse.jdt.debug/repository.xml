<bugrepository name="eclipse.jdt.debug">
    <bug id="7392" opendate="2002-01-09 13:00:02" fixdate="2002-01-10 16:10:54" resolution="Fixed">
        <buginformation>
            <summary>JDIThreads show #not responding> at startup.
            </summary>
            <description>Some of our threads are showing as
                #not responding>
                startup because our model thinks they are suspended but when the out of synch code tries to get stack
                frames, we get an incompatible thread state exception.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">oorg.eclipse.jdi.internal.ThreadReferenceImpl.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.core.JDIThread.java</file>
        </fixedFiles>
    </bug>
    <bug id="64951" opendate="2004-06-01 10:06:31" fixdate="2004-07-29 19:39:40" resolution="Fixed">
        <buginformation>
            <summary>suspended thread while evaluating condition - no labels.
            </summary>
            <description>RC1/IBM1.4.2
                * condition in for loop on line breakpoint (i == 53)
                * selected thread while debugging and paused it
                * all labels appear as "..." and never update
                * variables appear for the stack frame, but toString() (details) do not work
                will attach screen shot.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.core.model.JDIThread.java</file>
        </fixedFiles>
    </bug>
    <bug id="169542" opendate="2007-01-04 08:00:08" fixdate="2007-04-25 17:45:04" resolution="Fixed">
        <buginformation>
            <summary>A ThreadGroup (and all its Threads) is not displayed in the Debug view when its parent didn't
                contain any threads.
            </summary>
            <description>Build ID: M20060629-1905
                Steps To Reproduce:
                1.Create new ThreadGroup(first) using the code "new ThreadGroup("#some name>")" - the parent of the
                newly created thread group will be the "main" thread group
                2.
                After that create another thread group(second) under the first one
                3.
                Create and start one or more threads under the second thread group
                4.
                After running the program in debug mode and looking to the Debug view one will note that nor first nor
                second thread groups appear.
                More information:
                In my opinion, the bug is not in JVM, because I checked - entire thread groups and thread hierarchy is
                correct and traversable in the Variables view.
                More careful research resulted in a simple workaround found: before creating the second thread group,
                one must create and start at least one thread under the first thread group and then both thread groups
                appear in the Debug view correctly.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.java</file>
        </fixedFiles>
    </bug>
    <bug id="66413" opendate="2004-06-09 16:27:38" fixdate="2004-06-15 18:16:06" resolution="Fixed">
        <buginformation>
            <summary>Illegal thread state when debugging to conditional BP on startup.
            </summary>
            <description>Further strangeness to bug 64951
                * condition is i == 57
                * change to Java perspective
                * shutdown workspace
                * restart workspace
                * re-launch last (debug mode)
                * Error dialog appears claiming a runtime exception occurred in the condition.
                The error dialog appears 4 to 6 times (stacked) and this is in the log:
                com.sun.jdi.IncompatibleThreadStateException: Thread was not suspended
                at java.lang.Throwable.#init>(Throwable.java)
                at java.lang.Throwable.#init>(Throwable.java)
                at com.sun.jdi.IncompatibleThreadStateException.#init>(IncompatibleThreadStateException.java:17)
                at org.eclipse.jdi.internal.ThreadReferenceImpl.frameCount(ThreadReferenceImpl.java:152)
                at org.eclipse.jdt.internal.debug.core.model.JDIThread.getUnderlyingFrameCount(JDIThread.java:629)
                at org.eclipse.jdt.internal.debug.core.model.JDIThread.computeStackFrames(JDIThread.java)
                at org.eclipse.jdt.internal.debug.core.model.JDIThread.computeNewStackFrames(JDIThread.java:528)
                at
                org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.handleConditionalBreakpointEvent(JavaLineBreakpoint.java:441)
                at
                org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.handleBreakpointEvent(JavaLineBreakpoint.java:367)
                at org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.handleEvent(JavaBreakpoint.java:263)
                at org.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch(EventDispatcher.java)
                at org.eclipse.jdt.internal.debug.core.EventDispatcher.run(EventDispatcher.java:221)
                at java.lang.Thread.run(Thread.java:806)
                Terminating and restarting the target works OK.
                Seems to be a problem with evaluating the condition on startup.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.java</file>
        </fixedFiles>
    </bug>
    <bug id="148006" opendate="2006-06-21 05:10:06" fixdate="2006-07-13 15:47:40" resolution="Fixed">
        <buginformation>
            <summary>deadlock in ConsoleDocument during ant execution in autobuild.
            </summary>
            <description>I20060620-1010
                Got this after starting up with the build, importing plug-ins as binary, and waiting for autobuild to
                complete:
                Full thread dump Java HotSpot(TM) Client VM (1.4.2_06-b02 mixed mode):
                [..]
                Found one Java-level deadlock:
                =============================
                "Thread-12":
                waiting to lock monitor 0x080930fc (object 0x48ac6540, a
                org.eclipse.ui.internal.console.ConsoleDocument),
                which is held by "Worker-8"
                "Worker-8":
                waiting to lock monitor 0x08092cd4 (object 0x56c9ddb0, a java.lang.Class),
                which is held by "Thread-12"
                Java stack information for the threads listed above:
                ===================================================
                "Thread-12":
                at org.eclipse.ui.internal.console.ConsoleDocument.get(ConsoleDocument.java:29)
                - waiting to lock#x48ac6540> (a org.eclipse.ui.internal.console.ConsoleDocument)
                at org.eclipse.ant.internal.ui.launchConfigurations.TaskLinkManager.addLink(TaskLinkManager.java:145)
                at
                org.eclipse.ant.internal.ui.launchConfigurations.TaskLinkManager.addTaskHyperlink(TaskLinkManager.java:118)
                - locked#x56c9ddb0> (a java.lang.Class)
                at
                org.eclipse.ant.internal.ui.antsupport.logger.AntProcessBuildLogger.appendAndLink(AntProcessBuildLogger.java:145)
                at
                org.eclipse.ant.internal.ui.antsupport.logger.AntProcessBuildLogger.adornMessage(AntProcessBuildLogger.java:122)
                at
                org.eclipse.ant.internal.ui.antsupport.logger.AntProcessBuildLogger.logMessage(AntProcessBuildLogger.java:76)
                at
                org.eclipse.ant.internal.ui.antsupport.logger.AntProcessBuildLogger.messageLogged(AntProcessBuildLogger.java:317)
                at org.apache.tools.ant.Project.fireMessageLoggedEvent(Project.java:2009)
                - locked#x48abcae0> (a org.apache.tools.ant.Project)
                at org.apache.tools.ant.Project.fireMessageLogged(Project.java:2058)
                at org.apache.tools.ant.Project.log(Project.java:367)
                at org.apache.tools.ant.Task.log(Task.java:346)
                at org.apache.tools.ant.Task.log(Task.java:334)
                at org.apache.tools.ant.taskdefs.Delete.execute(Delete.java:465)
                at org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:275)
                at org.apache.tools.ant.Task.perform(Task.java:364)
                at org.apache.tools.ant.Target.execute(Target.java:341)
                at org.apache.tools.ant.Target.performTasks(Target.java:369)
                at org.apache.tools.ant.Project.executeSortedTargets(Project.java:1216)
                at org.apache.tools.ant.Project.executeTarget(Project.java:1185)
                at org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:40)
                at
                org.eclipse.ant.internal.core.ant.EclipseDefaultExecutor.executeTargets(EclipseDefaultExecutor.java:32)
                at org.apache.tools.ant.Project.executeTargets(Project.java:1068)
                at org.eclipse.ant.internal.core.ant.InternalAntRunner.run(InternalAntRunner.java:706)
                at org.eclipse.ant.internal.core.ant.InternalAntRunner.run(InternalAntRunner.java:457)
                at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
                at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
                at java.lang.reflect.Method.invoke(Method.java:324)
                at org.eclipse.ant.core.AntRunner.run(AntRunner.java:356)
                at org.eclipse.ant.internal.ui.launchConfigurations.AntLaunchDelegate$1.run(AntLaunchDelegate.java:230)
                at java.lang.Thread.run(Thread.java:534)
                "Worker-8":
                at
                org.eclipse.ant.internal.ui.launchConfigurations.TaskLinkManager.processNewLine(TaskLinkManager.java:166)
                - waiting to lock#x56c9ddb0> (a java.lang.Class)
                at org.eclipse.ant.internal.ui.console.TaskLineTracker.lineAppended(TaskLineTracker.java:43)
                at
                org.eclipse.debug.internal.ui.views.console.ConsoleLineNotifier.lineAppended(ConsoleLineNotifier.java:126)
                at
                org.eclipse.debug.internal.ui.views.console.ConsoleLineNotifier.matchFound(ConsoleLineNotifier.java:118)
                at org.eclipse.ui.internal.console.ConsolePatternMatcher$MatchJob.run(ConsolePatternMatcher.java:130)
                - locked#x48ac6540> (a org.eclipse.ui.internal.console.ConsoleDocument)
                at org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)
                Found 1 deadlock.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.ui.console.JavaStackTraceConsole.java</file>
        </fixedFiles>
    </bug>
    <bug id="312038" opendate="2010-05-07 06:33:40" fixdate="2011-04-21 05:28:31" resolution="Fixed">
        <buginformation>
            <summary>JREContainer hasChildren locks up the UI for more than 30s.
            </summary>
            <description>Created attachment 167452 [details]
                backtrace and example of recursive stat 3.6M7
                I'm seeing this very frequently.
                Changing a Manifest.MF, for example, causes the entire Eclipse UI to lockup.
                There seems to be an issue in the way that the JDT discovers whether a source directory is available.
                Using jstack multiple times, I see that the main thread is locked up in java.io.File.isFile(), called as
                a result of TreeViewer.isExpandable():
                java.lang.Thread.State: RUNNABLE
                at java.io.UnixFileSystem.getBooleanAttributes0(Native Method)
                at java.io.UnixFileSystem.getBooleanAttributes(UnixFileSystem.java:228)
                at java.io.File.isFile(File.java:778)
                at
                org.eclipse.jdt.internal.launching.StandardVMType.getDefaultSystemLibrarySource(StandardVMType.java:237)
                at org.eclipse.jdt.internal.launching.StandardVMType.getDefaultLibraryLocations(StandardVMType.java:310)
                at org.eclipse.jdt.launching.JavaRuntime.getLibraryLocations(JavaRuntime.java:1639)
                at org.eclipse.jdt.internal.launching.JREContainer.computeClasspathEntries(JREContainer.java:293)
                ...
                Stracing the process shows that's it's iterating up the tree recursively looking for src.zip / src.jar.
                When it hits a NFS automount directory the thread main thread is context switched out, and the stat is
                100+ times slower.
                It seems to be doing this again and again on the UI thread:
                [pid 4095] 11:08:21 stat("/tools/oss/packages/x86_64-rhel4/java/jdk1.6.0_11/jre/lib/src.jar",
                0x402288d0) = -1 ENOENT (No such file or directory)#.000017>
                [pid 4095] 11:08:21 stat("/tools/oss/packages/x86_64-rhel4/java/jdk1.6.0_11/jre/lib/src.zip",
                0x402288d0) = -1 ENOENT (No such file or directory)#.000013>
                [pid 4095] 11:08:21 stat("/tools/oss/packages/x86_64-rhel4/java/jdk1.6.0_11/jre/src.jar", 0x402288d0) =
                -1 ENOENT (No such file or directory)#.000012>
                [pid 4095] 11:08:21 stat("/tools/oss/packages/x86_64-rhel4/java/jdk1.6.0_11/jre/src.zip", 0x402288d0) =
                -1 ENOENT (No such file or directory)#.000012>
                [pid 4095] 11:08:21 stat("/tools/oss/packages/x86_64-rhel4/java/jdk1.6.0_11/src.jar", 0x402288d0) = -1
                ENOENT (No such file or directory)#.000011>
                [pid 4095] 11:08:21 stat("/tools/oss/packages/x86_64-rhel4/java/jdk1.6.0_11/src.zip", 0x402288d0) = -1
                ENOENT (No such file or directory)#.000012>
                [pid 4095] 11:08:21 stat("/tools/oss/packages/x86_64-rhel4/java/src.jar", 0x402288d0) = -1 ENOENT (No
                such file or directory)#.000015>
                [pid 4095] 11:08:21 stat("/tools/oss/packages/x86_64-rhel4/java/src.zip", 0x402288d0) = -1 ENOENT (No
                such file or directory)#.000010>
                [pid 4095] 11:08:21 stat("/tools/oss/packages/x86_64-rhel4/src.jar", 0x402288d0) = -1 ENOENT (No such
                file or directory)#.000013>
                [pid 4095] 11:08:21 stat("/tools/oss/packages/x86_64-rhel4/src.zip", 0x402288d0) = -1 ENOENT (No such
                file or directory)#.000010>
                [pid 4095] 11:08:21 stat("/tools/oss/packages/src.jar", 0x402288d0) = -1 ENOENT (No such file or
                directory)#.000011>
                [pid 4095] 11:08:21 stat("/tools/oss/packages/src.zip", 0x402288d0) = -1 ENOENT (No such file or
                directory)#.000010>
                [pid 4095] 11:08:21 stat("/tools/oss/src.jar", 0x402288d0) = -1 ENOENT (No such file or directory)
                0.000007>
                [pid 4095] 11:08:21 stat("/tools/oss/src.zip", 0x402288d0) = -1 ENOENT (No such file or directory)
                0.000008>
                [pid 4095] 11:08:21 stat("/tools/src.jar",
                unfinished
                ...>
                This is really bad for performance, and hurts automounters badly.
                I attached strace some time after the start of the hang and I have 28M of stat()s...
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.launching.StandardVMType.java</file>
        </fixedFiles>
    </bug>
    <bug id="24579" opendate="2002-10-09 10:33:11" fixdate="2002-10-11 12:04:15" resolution="Fixed">
        <buginformation>
            <summary>Deadlock on first checkout of java project.
            </summary>
            <description>Build 20021008
                Exact steps followed:
                1) Open new workspace
                2) Go to Preferences-> Plugin Development -> Java Build Path Control
                3) Uncheck all check boxes
                4) Open new CVS perspective
                5) Create anonymous connect to eclipse.org
                6) Checkout org.eclipse.core.resources
                Deadlock.
                Note: this is not a core bug, I'm just logging it here until I can investigate further.
                The problem is that someone is launching a ModalContext thread from the UI, and not blocking until it
                finishes.
                Then another ModalContext is forked, so we have:
                ModalContext1: holding Workspace lock, attempts syncExec
                ModalContext2: waiting on workspace lock
                UI thread: blocked on ModalContext 2
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.launching.LaunchingPlugin.java</file>
        </fixedFiles>
    </bug>
    <bug id="261837" opendate="2009-01-21 09:48:42" fixdate="2009-10-13 11:25:43" resolution="Fixed">
        <buginformation>
            <summary>RuntimeProcess should synchronize access to fTerminated and fExitValue.
            </summary>
            <description>Access to fTerminated and fExitValue need to be synchronized.
                The following example leads to an endless loop.
                Thread 1: while( !process.isTerminated()) {}
                Thread 2: process.terminate();
                Despite the termination clearly being executed, and the process ACTUALLY being killed, fTerminated in
                Thread 1 will always return false.
                Comment from a user:
                I was so curious what is wrong here that I couldn't keep back.
                So I decided to learn how to develope JBossTools.
                After installing, studying and debuging I find what is wrong.
                The problem is in threading, more precisely in Memory Consistency Errors (look
                http://java.sun.com/docs/books/tutorial/essential/concurrency/memconsist.html).
                Because writing and reading of the fTerminated variable in RuntimeProcess class is from the two
                different threads, memory consistency error is happend.
                So the method stopProcess.isTerminated() is returnig false all the time altough ProcessMonitor thread is
                already set the fTerminated variable to true.
                The solution is to synchronize the reading and writing of the fTerminated variable which is actually an
                eclipse bug.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.debug.tests.core.ProcessTests.java</file>
        </fixedFiles>
    </bug>
    <bug id="229394" opendate="2008-04-29 12:46:17" fixdate="2008-05-29 12:16:24" resolution="Fixed">
        <buginformation>
            <summary>NPE from JFace when using cell editor in variables view.
            </summary>
            <description>Steps do not consistently reproduce, but I have encontered the NPE multiple times while
                debugging.
                Possible race condition in JFace.
                There is a null check before the NPE location, but another thread could call dispose.
                1) Run a java program with an array of chars.
                2) Stop on a breakpoint, display the array of chars in the var view.
                3) Select an array entry's value in the var view to open cell editor
                4) Delete the value
                5) Click outside of the cell
                6) Two errors, first error (Invalid Type) is correct, second is NPE
                eclipse.buildId=I20080429-0100
                java.version=1.5.0_09
                java.vendor=Sun Microsystems Inc.
                BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=en_US
                Command-line arguments: -os win32 -ws win32 -arch x86
                Error
                Tue Apr 29 11:40:28 CDT 2008
                Problems occurred when invoking code from plug-in: "org.eclipse.jface".
                java.lang.NullPointerException
                at org.eclipse.jface.viewers.ColumnViewerEditor.applyEditorValue(ColumnViewerEditor.java:343)
                at org.eclipse.jface.viewers.ColumnViewerEditor$2.applyEditorValue(ColumnViewerEditor.java:152)
                at org.eclipse.jface.viewers.CellEditor$1.run(CellEditor.java:329)
                at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)
                at org.eclipse.core.runtime.Platform.run(Platform.java:880)
                at org.eclipse.ui.internal.JFaceUtil$1.run(JFaceUtil.java:48)
                at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:175)
                at org.eclipse.jface.viewers.CellEditor.fireApplyEditorValue(CellEditor.java:327)
                at org.eclipse.jface.viewers.CellEditor.focusLost(CellEditor.java:712)
                at org.eclipse.jface.viewers.TextCellEditor$5.focusLost(TextCellEditor.java:185)
                at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:136)
                at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
                at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1002)
                at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1026)
                at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1007)
                at org.eclipse.swt.widgets.Control.sendFocusEvent(Control.java:2423)
                at org.eclipse.swt.widgets.Widget.wmKillFocus(Widget.java:1764)
                at org.eclipse.swt.widgets.Control.WM_KILLFOCUS(Control.java:4124)
                at org.eclipse.swt.widgets.Control.windowProc(Control.java:3814)
                at org.eclipse.swt.widgets.Text.windowProc(Text.java:2074)
                at org.eclipse.swt.widgets.Display.windowProc(Display.java:4498)
                at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method)
                at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:2259)
                at org.eclipse.swt.widgets.Tree.callWindowProc(Tree.java:1521)
                at org.eclipse.swt.widgets.Tree.WM_LBUTTONDOWN(Tree.java:6338)
                at org.eclipse.swt.widgets.Control.windowProc(Control.java:3816)
                at org.eclipse.swt.widgets.Tree.windowProc(Tree.java:5689)
                at org.eclipse.swt.widgets.Display.windowProc(Display.java:4498)
                at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method)
                at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:2345)
                at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3377)
                at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2380)
                at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2344)
                at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2210)
                at org.eclipse.ui.internal.Workbench$5.run(Workbench.java:494)
                at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:288)
                at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:489)
                at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
                at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:112)
                at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:193)
                at
                org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
                at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
                at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:379)
                at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
                at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
                at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
                at java.lang.reflect.Method.invoke(Unknown Source)
                at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:549)
                at org.eclipse.equinox.launcher.Main.basicRun(Main.java:504)
                at org.eclipse.equinox.launcher.Main.run(Main.java:1236)
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.ui.actions.JavaObjectValueEditor.java</file>
        </fixedFiles>
    </bug>
    <bug id="187000" opendate="2007-05-15 09:21:00" fixdate="2007-05-24 20:32:58" resolution="Fixed">
        <buginformation>
            <summary>Debugger looses selection/focus a lot on the thread stack where you debug.
            </summary>
            <description>Build ID: I20070503-1400
                Steps To Reproduce:
                Just start debugging and press with the mouse the step over constantly.
                In my enviroment windows xp java 6 (and i have seen it now also on a co workers linux machine) many
                times the debugger looses the selection/focus on a stacktrace.
                Even the complete tree is collapsed and i really have to search for what thread is in suspend so that i
                can select it press step over once and then the tree expands again.
                I always had some problems with this in older releases.
                But currently it is really bad it pretty much happens multiply times when i debug.
                The selection and focus should just stick as much as possible because if it looses focus i can't press
                step over.
                I have to wait and select the right thread again before i can go on.
                More information:
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.ui.monitors.JavaThreadContentProvider.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.core.model.JDIThread.java</file>
        </fixedFiles>
    </bug>
    <bug id="343039" opendate="2011-04-16 10:39:25" fixdate="2012-02-29 12:50:50" resolution="Fixed">
        <buginformation>
            <summary>Turn on monitors by default.
            </summary>
            <description>The JDT debugger has the ability to show monitors owned by a thread.
                this is turned off by default.
                Dunno how long this option has been here but many people (including me) never knew it was there and
                would have greatly benefitted from its use in time-consuming race and deadlock debugging sessions.
                Please consider turning it on by default.
            </description>
            <version>1.1.0</version>
            <fixedVersion>3.8 M6</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.ui.JDIDebugUIPreferenceInitializer.java</file>
        </fixedFiles>
    </bug>
    <bug id="372030" opendate="2012-02-20 09:56:19" fixdate="2012-08-23 09:03:25" resolution="Fixed">
        <buginformation>
            <summary>Cannot resume single thread after VM suspended.
            </summary>
            <description>N20120217-2000
                I cannot resume a single thread in a Remote Java Application launch configuration.
                I remote-debugged my workspace to investigate bug 361758, and then suspended the VM.
                Then I wanted to resume a single thread, but when I selected it and performed Resume (F8), the whole VM
                resumed, instead of only the the selected thread.
                I haven't checked, but I'm pretty sure this once used to work.
                Workaround is to select all threads (but not the VM) and then click Suspend.
                Drawback: It's tedious, and all threads end up expanded in the Debug view.
            </description>
            <version>1.1.0</version>
            <fixedVersion>4.3 M2</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.core.model.JDIThread.java</file>
        </fixedFiles>
    </bug>
    <bug id="12695" opendate="2002-04-03 10:55:18" fixdate="2002-04-06 21:13:41" resolution="Fixed">
        <buginformation>
            <summary>Need to get full set of breakpoints hit from thread.
            </summary>
            <description>When creating super adapters on top of the Java debug adapter we set hidden temporary
                breakpoints in order to control the Java debug adapter.
                If the user also sets a breakpoint at the same spot as one of our temporary breakpoints then when we get
                a suspend event due to a breakpoint from the Java thread we need to be able to ask the thread for the
                list of breakpoints that were hit.
                Currently we can only get one breakpoint from the thread.
                If we only see our temporary breakpoint which we might choose to ignore and don't see the user
                breakpoint then we will run away.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.ui.snippeteditor.JavaSnippetEditor.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.core.model.JDIThread.java</file>
        </fixedFiles>
    </bug>
    <bug id="52474" opendate="2004-02-19 08:45:49" fixdate="2004-05-25 17:21:04" resolution="Fixed">
        <buginformation>
            <summary>UI Blocked when opening Java Perspective during CVS check out.
            </summary>
            <description>build I20040218
                - start eclipse with a new workspace
                - switch to CVS Repository Exploring perspective
                - check out a number of projects (i checkout Platform UI module)
                - now attempt to switch to the Java Perspective
                NOTE that at this point the "UI is blocked" dialog is opened.
                Probably due to the fact that starting the Java Perspective requires the workbench lock?
                The point here is that this will be a common pattern and it would be nice if we could investigate
                makeing this scenario work more smoothly.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.launching.LaunchingPlugin.java</file>
            <file type="M">org.eclipse.jdt.launching.JavaRuntime.java</file>
        </fixedFiles>
    </bug>
    <bug id="33712" opendate="2003-03-03 17:57:42" fixdate="2003-03-03 20:39:34" resolution="Fixed">
        <buginformation>
            <summary>"The resource tree is locked for modifications" from JavaDebugOptionsManager.
            </summary>
            <description>I found the following in my log.
                I'd recently created a new Java Project and then created a new Main method, following the steps in Bug
                33612 comment #5.
                !SESSION Mar 03, 2003 16:40:03.154 ---------------------------------------------
                java.version=1.4.1-rc
                java.vendor=Sun Microsystems Inc.
                BootLoader constants: OS=linux, ARCH=x86, WS=gtk, NL=en_US
                Command-line arguments: -dev bin -feature org.eclipse.platform -data /home/jburns/runtime-workspace -os
                linux -ws gtk -arch x86 -nl en_US -configuration
                file:/home/jburns/target/.metadata/.plugins/org.eclipse.pde.core/_home_jburns_runtime-workspace/platform.cfg
                -install file:/home/jburns/host/eclipse/
                !ENTRY org.eclipse.ant.core 4 3 Mar 03, 2003 16:40:03.158
                !MESSAGE The library file:/home/jburns/target/org.eclipse.jdt.core/jdtCompilerAdapter.jar specified via
                the extraClasspathEntries extension point of Java Development Tools Core does not exist
                !ENTRY org.eclipse.jdt.debug.ui 4 150 Mar 03, 2003 16:47:16.45
                !MESSAGE Internal Error
                !STACK 1
                org.eclipse.core.internal.resources.ResourceException: The resource tree is locked for modifications.
                at org.eclipse.core.internal.resources.Workspace.beginOperation(Workspace.java:144)
                at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1587)
                at
                org.eclipse.jdt.internal.debug.ui.JavaDebugOptionsManager.breakpointsAdded(JavaDebugOptionsManager.java:800)
                at org.eclipse.debug.internal.core.BreakpointManager$BreakpointsNotifier.run(BreakpointManager.java:816)
                at org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:867)
                at org.eclipse.core.runtime.Platform.run(Platform.java:413)
                at
                org.eclipse.debug.internal.core.BreakpointManager$BreakpointsNotifier.notify(BreakpointManager.java:841)
                at org.eclipse.debug.internal.core.BreakpointManager.fireUpdate(BreakpointManager.java:683)
                at org.eclipse.debug.internal.core.BreakpointManager.addBreakpoints(BreakpointManager.java:419)
                at org.eclipse.debug.internal.core.BreakpointManager.loadBreakpoints(BreakpointManager.java:141)
                at org.eclipse.debug.internal.core.BreakpointManager.initializeBreakpoints(BreakpointManager.java:285)
                at org.eclipse.debug.internal.core.BreakpointManager.getBreakpoints0(BreakpointManager.java:256)
                at org.eclipse.debug.internal.core.BreakpointManager.getBreakpoints(BreakpointManager.java:265)
                at org.eclipse.jdt.internal.debug.ui.JavaModelListener.elementChanged(JavaModelListener.java:51)
                at org.eclipse.jdt.internal.core.JavaModelManager$2.run(JavaModelManager.java:792)
                at org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:867)
                at org.eclipse.core.runtime.Platform.run(Platform.java:413)
                at org.eclipse.jdt.internal.core.JavaModelManager.notifyListeners(JavaModelManager.java:787)
                at org.eclipse.jdt.internal.core.JavaModelManager.firePostChangeDelta(JavaModelManager.java:756)
                at org.eclipse.jdt.internal.core.JavaModelManager.fire(JavaModelManager.java:719)
                at org.eclipse.jdt.internal.core.DeltaProcessor.resourceChanged(DeltaProcessor.java:1717)
                at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:137)
                at org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:867)
                at org.eclipse.core.runtime.Platform.run(Platform.java:413)
                at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:152)
                at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:67)
                at org.eclipse.core.internal.resources.Workspace.broadcastChanges(Workspace.java:161)
                at org.eclipse.core.internal.resources.Workspace.endOperation(Workspace.java:892)
                at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1593)
                at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:2699)
                at org.eclipse.jdt.internal.ui.actions.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:32)
                at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:296)
                at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:246)
                at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:752)
                at org.eclipse.jdt.internal.ui.wizards.NewElementWizard.performFinish(NewElementWizard.java:90)
                at org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:602)
                at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:315)
                at org.eclipse.jface.dialogs.Dialog$1.widgetSelected(Dialog.java:417)
                at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:87)
                at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:77)
                at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:902)
                at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1507)
                at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1324)
                at org.eclipse.jface.window.Window.runEventLoop(Window.java:577)
                at org.eclipse.jface.window.Window.open(Window.java:557)
                at org.eclipse.ui.internal.NewWizardShortcutAction.run(NewWizardShortcutAction.java:87)
                at org.eclipse.jface.action.Action.runWithEvent(Action.java:842)
                at
                org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:456)
                at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:403)
                at org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:397)
                at
                org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:72)
                at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:77)
                at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:902)
                at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1507)
                at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1324)
                at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1271)
                at org.eclipse.ui.internal.Workbench.run(Workbench.java:1254)
                at org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:845)
                at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461)
                at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
                at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
                at java.lang.reflect.Method.invoke(Method.java:324)
                at org.eclipse.core.launcher.Main.basicRun(Main.java:247)
                at org.eclipse.core.launcher.Main.run(Main.java:703)
                at org.eclipse.core.launcher.Main.main(Main.java:539)
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.debug.tests.core.BreakpointListenerTests.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.ui.JavaDebugOptionsManager.java</file>
        </fixedFiles>
    </bug>
    <bug id="43197" opendate="2003-09-17 00:54:49" fixdate="2004-11-16 15:57:14" resolution="Fixed">
        <buginformation>
            <summary>Race condition between console line tracker and debug terminate event.
            </summary>
            <description>I have both a console line tracker and a debug event listener registered for the same process.
                When the process terminates, I want to do different things in the plugin based on the messages that were
                written out by the process.
                However, sometimes I'm getting the process terminated event before the last call to the line tracker is
                made.
                It looks like the process termination event is handled by a Job worker thread, while the console line
                comes in on the main thread.
                They appear to happen at about the same time so it's a race to see which is actually called first.
                I tried to use the IConsoleLineTracker.dispose() method to perform the action but that is not called
                until the launch is removed.
                There doesn't appear to be a way for the console line tracker to know if it has the last line or not.
                If the code that fires the termination event were changed to wait until the last
                IConsoleLineTracker.lineAppended() method was called and returns first, that would take care of it.
                Another way would be to have a new method, say IConsoleLineTracker.term(), to mirror the init() method.
                It would be called after the last lines had been appended and the process was terminated, and I could
                put my what-to-do-after-termination logic there.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.debug.tests.AutomatedSuite.java</file>
            <file type="M">org.eclipse.jdt.debug.tests.core.LineTrackerTests.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.ui.console.J9ConsoleTracker.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.ui.console.JavaConsoleTracker.java</file>
            <file type="M">org.eclipse.jdt.debug.tests.ProjectCreationDecorator.java</file>
            <file type="M">org.eclipse.jdt.debug.testplugin.ConsoleLineTracker.java</file>
            <file type="M">org.eclipse.jdt.debug.tests.testprograms.FloodConsole.java</file>
            <file type="M">org.eclipse.jdt.debug.tests.core.CommandArgumentTests.java</file>
            <file type="M">org.eclipse.jdt.debug.tests.AbstractDebugTest.java</file>
            <file type="M">org.eclipse.jdt.debug.tests.testprograms.OneToTenPrint.java</file>
        </fixedFiles>
    </bug>
    <bug id="161781" opendate="2006-10-20 15:36:59" fixdate="2008-04-16 15:46:44" resolution="Fixed">
        <buginformation>
            <summary>Suspend status ignored on initial remote debug connection.
            </summary>
            <description>I have a modified VM with a "waitForDebugger()" function that suspends the current thread.
                The idea is to leave it suspended until the debugger arrives, so the debugger can inspect the current
                state before continuing.
                When Eclipse attaches (through a socket on port 8000), it queries with a JDWP ThreadReference.Status
                message.
                The VM sends back RUNNING/SUSPEND_STATUS_SUSPENDED for the main thread and WAIT/0 for the other (VM)
                threads.
                However, Eclipse shows all threads as "running".
                If I ask Eclipse to suspend the thread, everything works as expected, but when I hit "resume" it won't
                actually resume because the "suspend count" is still nonzero.
                At no time does Eclipse issue a SuspendCount query.
                I can modify the VM to "fake" the first suspend, which will leave the books in order, but it doesn't
                help with the initial condition -- you still have to suspend the thread (or VM) manually.
                Eclipse should use the suspend status from the Status call to set its initial concept of thread state.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.core.breakpoints.JavaBreakpoint.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.core.model.JDIThread.java</file>
        </fixedFiles>
    </bug>
    <bug id="125868" opendate="2006-01-31 12:12:52" fixdate="2006-05-04 15:30:13" resolution="Fixed">
        <buginformation>
            <summary>Invalid Thread Access when launching.
            </summary>
            <description>Running HEAD.
                1.
                restart eclipse
                2.
                start a jdt debug session and resulted in this exception
                It seems to only happen on the first launch.
                Subsequent launches do not result in exceptions.
                org.eclipse.swt.SWTException: Invalid thread access
                at java.lang.Throwable.#init>(Throwable.java)
                at java.lang.Throwable.#init>(Throwable.java)
                at org.eclipse.swt.SWTException.#init>(SWTException.java:87)
                at org.eclipse.swt.SWT.error(SWT.java:3283)
                at org.eclipse.swt.SWT.error(SWT.java:3206)
                at org.eclipse.swt.SWT.error(SWT.java:3177)
                at org.eclipse.swt.widgets.Display.error(Display.java:974)
                at org.eclipse.swt.widgets.Display.checkDevice(Display.java)
                at org.eclipse.swt.widgets.Display.disposeExec(Display.java:919)
                at
                org.eclipse.jdt.internal.ui.viewsupport.ImageDescriptorRegistry.hookDisplay(ImageDescriptorRegistry.java:85)
                at org.eclipse.jdt.internal.ui.viewsupport.ImageDescriptorRegistry.#init>
                (ImageDescriptorRegistry.java:48)
                at org.eclipse.jdt.internal.ui.viewsupport.ImageDescriptorRegistry.#init>
                (ImageDescriptorRegistry.java:36)
                at org.eclipse.jdt.internal.ui.JavaPlugin.internalGetImageDescriptorRegistry(JavaPlugin.java:861)
                at org.eclipse.jdt.internal.ui.JavaPlugin.getImageDescriptorRegistry(JavaPlugin.java:337)
                at
                org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getJavaElementImageRegistry(JDIModelPresentation.java:1881)
                at
                org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getVariableImage(JDIModelPresentation.java:870)
                at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getImage(JDIModelPresentation.java:658)
                at org.eclipse.debug.internal.ui.LazyModelPresentation.getImage(LazyModelPresentation.java:106)
                at
                org.eclipse.debug.internal.ui.DelegatingModelPresentation.getImage(DelegatingModelPresentation.java:141)
                at
                org.eclipse.debug.internal.ui.views.launch.DebugElementHelper.getImageDescriptor(DebugElementHelper.java:55)
                at
                org.eclipse.debug.internal.ui.elements.adapters.AsynchronousDebugLabelAdapter.getImageDescriptors(AsynchronousDebugLabelAdapter.java:85)
                at
                org.eclipse.debug.internal.ui.viewers.provisional.AsynchronousLabelAdapter.computeLabels(AsynchronousLabelAdapter.java:81)
                at
                org.eclipse.debug.internal.ui.elements.adapters.AsynchronousDebugLabelAdapter.computeLabels(AsynchronousDebugLabelAdapter.java)
                at
                org.eclipse.debug.internal.ui.viewers.provisional.AsynchronousLabelAdapter$2.run(AsynchronousLabelAdapter.java:48)
                at org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.java</file>
        </fixedFiles>
    </bug>
    <bug id="182237" opendate="2007-04-12 17:52:57" fixdate="2007-04-26 10:46:04" resolution="Fixed">
        <buginformation>
            <summary>Invalid thread access exceptions in Java Variables view.
            </summary>
            <description>Since updating to M6, I have been getting these exceptions when I first open the variables
                view.
                org.eclipse.swt.SWTException: Invalid thread access
                at org.eclipse.swt.SWT.error(SWT.java:3499)
                at org.eclipse.swt.SWT.error(SWT.java:3422)
                at org.eclipse.swt.SWT.error(SWT.java:3393)
                at org.eclipse.swt.widgets.Display.error(Display.java:1135)
                at org.eclipse.swt.widgets.Display.checkDevice(Display.java:664)
                at org.eclipse.swt.widgets.Display.disposeExec(Display.java:1080)
                at
                org.eclipse.jdt.internal.ui.viewsupport.ImageDescriptorRegistry.hookDisplay(ImageDescriptorRegistry.java:87)
                at org.eclipse.jdt.internal.ui.viewsupport.ImageDescriptorRegistry.#init>
                (ImageDescriptorRegistry.java:49)
                at org.eclipse.jdt.internal.ui.viewsupport.ImageDescriptorRegistry.#init>
                (ImageDescriptorRegistry.java:37)
                at org.eclipse.jdt.internal.ui.JavaPlugin.internalGetImageDescriptorRegistry(JavaPlugin.java:860)
                at org.eclipse.jdt.internal.ui.JavaPlugin.getImageDescriptorRegistry(JavaPlugin.java:328)
                at
                org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getJavaElementImageRegistry(JDIModelPresentation.java:1900)
                at
                org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getVariableImage(JDIModelPresentation.java:860)
                at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getImage(JDIModelPresentation.java:633)
                at org.eclipse.debug.internal.ui.LazyModelPresentation.getImage(LazyModelPresentation.java:110)
                at
                org.eclipse.debug.internal.ui.DelegatingModelPresentation.getImage(DelegatingModelPresentation.java:147)
                at
                org.eclipse.debug.internal.ui.views.launch.DebugElementHelper.getImageDescriptor(DebugElementHelper.java:76)
                at
                org.eclipse.debug.internal.ui.model.elements.DebugElementLabelProvider.getImageDescriptor(DebugElementLabelProvider.java:68)
                at
                org.eclipse.debug.internal.ui.model.elements.VariableLabelProvider.getImageDescriptor(VariableLabelProvider.java:70)
                at
                org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider.retrieveLabel(ElementLabelProvider.java:183)
                at
                org.eclipse.jdt.internal.debug.ui.variables.JavaVariableLabelProvider.retrieveLabel(JavaVariableLabelProvider.java:121)
                at
                org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider$LabelUpdater.run(ElementLabelProvider.java:137)
                at
                org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider$LabelJob.run(ElementLabelProvider.java:60)
                at org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.ui.variables.JavaVariableLabelProvider.java</file>
        </fixedFiles>
    </bug>
    <bug id="446040" opendate="2014-10-06 08:33:35" fixdate="2014-11-17 10:08:51" resolution="Fixed">
        <buginformation>
            <summary>Invalid thread access in RuntimeClasspathViewer$1.preferenceChange (err_grp: 87791828).
            </summary>
            <description>Hello committers,
                we received a new error report for Eclipse 4.4.1.M20140925-0400.
                General Information:
                anonymous-id: 24ad43ce-0a9e-4ffd-a544-d73b21063102
                eclipse-build-id: 4.4.1.M20140925-0400
                eclipse-product: org.eclipse.epp.package.jee.product
                operating system: Windows7 6.1.0 (x86_64) - win32
                java-runtime-version: 1.8.0_20-b26
                The following plug-ins were present on the execution stack (*):
                1.
                org.eclipse.core.runtime_3.10.0.v20140318-2214
                2.
                org.eclipse.jdt.debug.ui_3.6.300.v20140512-1926
                3.
                org.eclipse.jdt.debug_3.8.101.v20140902-1548
                4.
                org.eclipse.jdt_3.10.0.v20140925-0400
                5.
                org.eclipse.jface_3.10.1.v20140813-1009
                6.
                org.eclipse.swt_3.103.1.v20140903-1938
                Error Status:
                code: 2
                plugin: org.eclipse.equinox.preferences_3.5.200.v20140224-1527
                message: Problems occurred when invoking code from plug-in: "org.eclipse.equinox.preferences".
                fingerprint: 87791828
                exception class: org.eclipse.swt.SWTException
                exception message: Invalid thread access
                number of children: 0
                org.eclipse.swt.SWTException: Invalid thread access
                at org.eclipse.swt.SWT.error(SWT.java:4441)
                at org.eclipse.swt.SWT.error(SWT.java:4356)
                at org.eclipse.swt.SWT.error(SWT.java:4327)
                at org.eclipse.swt.widgets.Widget.error(Widget.java:476)
                at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:367)
                at org.eclipse.swt.widgets.Tree.getSelection(Tree.java:3446)
                at org.eclipse.jface.viewers.TreeViewer.getSelection(TreeViewer.java:232)
                at org.eclipse.jface.viewers.TreeViewer.setSelection(TreeViewer.java:311)
                at org.eclipse.jface.viewers.AbstractTreeViewer.setSelectionToWidget(AbstractTreeViewer.java:2524)
                at org.eclipse.jface.viewers.StructuredViewer.setSelectionToWidget(StructuredViewer.java:1751)
                at org.eclipse.jface.viewers.AbstractTreeViewer.setSelectionToWidget(AbstractTreeViewer.java:2977)
                at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1443)
                at org.eclipse.jface.viewers.TreeViewer.preservingSelection(TreeViewer.java:366)
                at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1397)
                at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1525)
                at org.eclipse.jface.viewers.ColumnViewer.refresh(ColumnViewer.java:533)
                at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1481)
                at
                org.eclipse.jdt.internal.debug.ui.classpath.RuntimeClasspathViewer$1.preferenceChange(RuntimeClasspathViewer.java:58)
                at org.eclipse.core.internal.preferences.EclipsePreferences$3.run(EclipsePreferences.java:896)
                at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
                at
                org.eclipse.core.internal.preferences.EclipsePreferences.firePreferenceEvent(EclipsePreferences.java:899)
                at org.eclipse.core.internal.preferences.EclipsePreferences.put(EclipsePreferences.java:912)
                at org.eclipse.jdt.internal.debug.ui.jres.JREsUpdater$1.run(JREsUpdater.java:91)
                at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
                Messages, stacktraces, and nested status objects may be shortened.
                Please visit http://dev.eclipse.org/recommenders/committers/confess/0.5/reports/54328c1ee4b0a33678b204b7
                for the complete error log.
                Some general information and guidelines about how to use this bug report:
                1.
                Feel free to move this bug to your own product and components.
                Please note that this bug is only accessible to Eclipse committers.
                If you move this bug please make sure that it's still in the "Security Advisor" group.
                2.
                The bug contents of the fields status, resolution, keywords, and whitelist are presented to reporters.
                If you needs more information, please set the keyword "needinfo".
                This will trigger a specialized dialog asking the user to provide further details.
                3.
                Use the following resolutions for the following situations:
                * CLOSED / FIXED: This bug has been fixed.
                Please provide additional information in the whiteboard field.
                * CLOSED / WORKSFORME: Use this resolution if you can't reproduce this issue
                and request further information.
                Please use the whiteboard text to specify
                more details what a user should provide and how.
                * CLOSED / INVALID: Use this resolution if the reported problem is a
                'user-configuration' problem.
                Please consider giving hints how to fix
                these issues in the whiteboard field.
                * CLOSED / NOT ECLIPSE: Use this if the problem is caused by another plugin
                not developed at Eclipse.org
                * CLOSED / MOVED: If this bug has been moved else where.
                Please provide more
                information (e.g.
                a link) in the whiteboard field.
                4.
                Please remember that only committers can view and comment on this bug.
                You may, however, manually add the reporting user to the bug's cc list.
                But keep in mind that the report may contains sensitive information.
                5.
                If you are missing a feature, please file a enhancement request here:
                https://bugs.eclipse.org/bugs/enter_bug.cgi?product=Recommenders.Incubator#component=Stacktraces
                Thank you for your assistance.
                Your friendly error-reports-inbox.
                --
                * Note: The list of present bundles and their respective versions was
                calculated by package naming heuristics.
                This may or may not reflect reality.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">.org.eclipse.jdt.internal.debug.ui.classpath.RuntimeClasspathViewer.java</file>
        </fixedFiles>
    </bug>
    <bug id="239950" opendate="2008-07-08 07:51:00" fixdate="2009-06-22 16:22:00" resolution="Fixed">
        <buginformation>
            <summary>Debugging Spring app causes ClassCastException.
            </summary>
            <description>Build ID: I20080617-2000
                Steps To Reproduce:
                1.TestCase for spring application extends AbstractTransactionalSpringContextTests
                2.
                Run as: JUnit Test
                3.
                Error "'JDI thread evaluations' has encountered a problem.
                Exception processing async thread queue"
                More information:
                !SESSION 2008-07-08 13:45:06.737 -----------------------------------------------
                eclipse.buildId=I20080617-2000
                java.version=1.5.0_15
                java.vendor=Sun Microsystems Inc.
                BootLoader constants: OS=linux, ARCH=x86, WS=gtk, NL=de_AT
                Command-line arguments: -os linux -ws gtk -arch x86 -clean
                !ENTRY org.eclipse.ui 2 0 2008-07-08 13:45:52.324
                !MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' extension point
                !SUBENTRY 1 org.eclipse.ui 2 0 2008-07-08 13:45:52.324
                !MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.tm.terminal',
                id='org.eclipse.tm.terminal.command1'
                !SUBENTRY 1 org.eclipse.ui 2 0 2008-07-08 13:45:52.324
                !MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.tm.terminal',
                id='org.eclipse.tm.terminal.command1'
                !SUBENTRY 1 org.eclipse.ui 2 0 2008-07-08 13:45:52.324
                !MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.tm.terminal',
                id='org.eclipse.tm.terminal.command1'
                !SUBENTRY 1 org.eclipse.ui 2 0 2008-07-08 13:45:52.324
                !MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.tm.terminal',
                id='org.eclipse.tm.terminal.command1'
                !SUBENTRY 1 org.eclipse.ui 2 0 2008-07-08 13:45:52.324
                !MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.tm.terminal',
                id='org.eclipse.tm.terminal.command1'
                !SUBENTRY 1 org.eclipse.ui 2 0 2008-07-08 13:45:52.324
                !MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.tm.terminal',
                id='org.eclipse.tm.terminal.command1'
                !SUBENTRY 1 org.eclipse.ui 2 0 2008-07-08 13:45:52.324
                !MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.tm.terminal',
                id='org.eclipse.tm.terminal.command1'
                !SUBENTRY 1 org.eclipse.ui 2 0 2008-07-08 13:45:52.324
                !MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.tm.terminal',
                id='org.eclipse.tm.terminal.command1'
                !SUBENTRY 1 org.eclipse.ui 2 0 2008-07-08 13:45:52.324
                !MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.tm.terminal',
                id='org.eclipse.tm.terminal.command1'
                !SUBENTRY 1 org.eclipse.ui 2 0 2008-07-08 13:45:52.324
                !MESSAGE Cannot bind to an undefined command: plug-in='org.eclipse.tm.terminal',
                id='org.eclipse.tm.terminal.command1'
                !ENTRY org.eclipse.jdt.debug 4 120 2008-07-08 13:46:39.919
                !MESSAGE Exception processing async thread queue
                !SUBENTRY 1 org.eclipse.jdt.debug 4 120 2008-07-08 13:46:39.937
                !MESSAGE Exception processing async thread queue
                !STACK 0
                java.lang.ClassCastException: org.eclipse.jdt.internal.debug.core.model.JDINullValue
                at org.eclipse.jdt.internal.debug.eval.ast.instructions.ArrayAccess.execute(ArrayAccess.java:36)
                at org.eclipse.jdt.internal.debug.eval.ast.engine.Interpreter.execute(Interpreter.java:61)
                at
                org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine$1$EvaluationRunnable.run(ASTEvaluationEngine.java:481)
                at org.eclipse.jdt.internal.debug.core.model.JDIThread.runEvaluation(JDIThread.java:640)
                at
                org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine$EvalRunnable.run(ASTEvaluationEngine.java:517)
                at org.eclipse.jdt.internal.debug.core.model.JDIThread$ThreadJob.run(JDIThread.java:2614)
                at org.eclipse.core.internal.jobs.Worker.run(Worker.java:55)
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.eval.ast.instructions.ArrayAccess.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.eval.ast.instructions.InstructionsEvaluationMessages.java</file>
        </fixedFiles>
    </bug>
    <bug id="33297" opendate="2003-02-26 12:18:32" fixdate="2003-03-05 15:55:33" resolution="Fixed">
        <buginformation>
            <summary>Unneccessary error logging from detail formatter manager.
            </summary>
            <description>There are two places in the detail formatter manager where errors are logged and displayed to
                the user when a 'toString()' evaluation fails.
                Since the error is displayed to the user, we do not need to log the errors.
                We currently do not log "thread not suspended errors", but no errors need to be logged.
                see #resolveFormatter # EvaluationListener#evaluationComplete
                try {
                valueToString(result.getValue());
                } catch (DebugException e) {
                if (e.getStatus().getCode() != IJavaThread.ERR_THREAD_NOT_SUSPENDED) {
                // don't log 'thread not suspended' errors
                JDIDebugUIPlugin.log(e);
                }
                fListener.detailComputed(fValue, e.getStatus().getMessage());
                }
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.java</file>
        </fixedFiles>
    </bug>
    <bug id="506865" opendate="2016-11-01 18:56:48" fixdate="2016-11-18 14:16:52" resolution="Fixed">
        <buginformation>
            <summary>Race condition in AbstractVMInstallType.createVMInstall.
            </summary>
            <description>AbstractVMInstallType.createVMInstall may cause creation of two VMs with the same id since
                checking for existence of the VM being created is done outside of the synchronized block.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.launching.AbstractVMInstallType.java</file>
        </fixedFiles>
    </bug>
    <bug id="57467" opendate="2004-04-05 11:42:16" fixdate="2004-04-13 19:18:02" resolution="Fixed">
        <buginformation>
            <summary>race condition causes invalid stack frames.
            </summary>
            <description>I was finding that I got "transisent" "invalid stack frame" exceptions when I ran the debug
                tests.
                I traced it down to this: two threads are asking a thread for stack frames at the same time - the ui is
                populating frame labels in the background, and the test methods is accessing/testing something about the
                top stack frame.
                The issue is in deciding whether to 'preserve' stack frames in the "computeStackFrames" method of
                JDIThread.
                We compare the current TOS with the old TOS and attempt to re-use stack frames.
                To compare frames, we use the underlying method (or "fLastMethod") in the case of the old stack frames.
                However, the "fLastMethod" is only populated the first time we retrieve the underlying method for a
                stack frame.
                Thus, if we ask for stack frames twice, before an underlying method has been retrieved, the second
                requestor will always get invalid frames, as our logic compares "currMethod.equals (lastMethod)" where
                lastMethod is null (which fails, and thus invalidates the previously computed stack frames).
                The fix is to say that if the "last method" is null, then the frames are equal since the index of the
                frames is the same, and no info of the underlying frame has been retrieved yet (so it cannot be stale
                yet).
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.core.model.JDIStackFrame.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.core.model.JDIThread.java</file>
        </fixedFiles>
    </bug>
    <bug id="22005" opendate="2002-07-29 12:04:22" fixdate="2002-08-12 16:15:41" resolution="Fixed">
        <buginformation>
            <summary>Review UI runnables.
            </summary>
            <description>We should review the runnables we post to the UI thread via calls to Display.asynchExec and
                Display.synchExec.
                It is important to Eclipse's UI performance that we run as little code as necessary in the UI thread.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.ui.JavaHotCodeReplaceListener.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.ui.ErrorDialogWithToggle.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.ui.JavaDebugOptionsManager.java</file>
        </fixedFiles>
    </bug>
    <bug id="101118" opendate="2005-06-21 15:33:15" fixdate="2005-06-23 10:56:03" resolution="Fixed">
        <buginformation>
            <summary>eclipse-SDK-3.1RC3-win32 - Exception processing async thread queue.
            </summary>
            <description>Hi,
                Using eclipse-SDK-3.1RC3-win32 in a multithreaded application.
                Have problem when trying debug the source code.
                Have tried with older version of Eclipse (RC1 and M7) but nothing changed.
                !SESSION 2005-06-21 20:52:46.761 -----------------------------------------------
                eclipse.buildId=I20050617-1618
                java.version=1.5.0_02
                java.vendor=Sun Microsystems Inc.
                BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=sv_SE
                Command-line arguments: -os win32 -ws win32 -arch x86
                !ENTRY org.eclipse.jdt.debug 4 120 2005-06-21 21:05:22.147
                !MESSAGE Exception processing async thread queue
                !SUBENTRY 1 org.eclipse.jdt.debug 4 120 2005-06-21 21:05:22.147
                !MESSAGE Exception processing async thread queue
                !STACK 0
                java.lang.NullPointerException
                at
                org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.getJavaProject(JavaDetailFormattersManager.java:206)
                at
                org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.getCompiledExpression(JavaDetailFormattersManager.java:312)
                at
                org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.resolveFormatter(JavaDetailFormattersManager.java:156)
                at
                org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.access$0(JavaDetailFormattersManager.java:149)
                at
                org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager$4.run(JavaDetailFormattersManager.java:137)
                at org.eclipse.jdt.internal.debug.core.model.JDIThread$ThreadJob.run(JDIThread.java:2446)
                at org.eclipse.core.internal.jobs.Worker.run(Worker.java:76)
                !ENTRY org.eclipse.jdt.debug 4 120 2005-06-21 21:23:40.206
                !MESSAGE Exception processing async thread queue
                !SUBENTRY 1 org.eclipse.jdt.debug 4 120 2005-06-21 21:23:40.206
                !MESSAGE Exception processing async thread queue
                !STACK 0
                java.lang.NullPointerException
                at
                org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.getJavaProject(JavaDetailFormattersManager.java:206)
                at
                org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.getCompiledExpression(JavaDetailFormattersManager.java:312)
                at
                org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.resolveFormatter(JavaDetailFormattersManager.java:156)
                at
                org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.access$0(JavaDetailFormattersManager.java:149)
                at
                org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager$4.run(JavaDetailFormattersManager.java:137)
                at org.eclipse.jdt.internal.debug.core.model.JDIThread$ThreadJob.run(JDIThread.java:2446)
                at org.eclipse.core.internal.jobs.Worker.run(Worker.java:76)
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.ui.JavaDetailFormattersManager.java</file>
        </fixedFiles>
    </bug>
    <bug id="65149" opendate="2004-06-01 16:10:13" fixdate="2004-06-10 14:26:46" resolution="Fixed">
        <buginformation>
            <summary>Resource exception in JavaDebugOptionsManager.initializeProblemHandling.
            </summary>
            <description>3.0 RC1
                Got the following in my log after replacing a local project with a project at some other date in CVS.
                org.eclipse.core.internal.resources.ResourceException: The resource tree is locked for modifications.
                at org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:93)
                at
                org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:1628)
                at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1668)
                at
                org.eclipse.jdt.internal.debug.ui.JavaDebugOptionsManager.initializeProblemHandling(JavaDebugOptionsManager.java:263)
                at
                org.eclipse.jdt.internal.debug.ui.JavaDebugOptionsManager.activate(JavaDebugOptionsManager.java:781)
                at
                org.eclipse.jdt.internal.debug.ui.JavaDebugOptionsManager.launchChanged(JavaDebugOptionsManager.java:800)
                at
                org.eclipse.debug.internal.core.LaunchManager$LaunchNotifier.run(LaunchManager.java:1336)
                at
                org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:615)
                at org.eclipse.core.runtime.Platform.run(Platform.java:758)
                at
                org.eclipse.debug.internal.core.LaunchManager$LaunchNotifier.notify(LaunchManager.java:1355)
                at org.eclipse.debug.internal.core.LaunchManager.fireUpdate(LaunchManager.java:363)
                at org.eclipse.debug.core.Launch.fireChanged(Launch.java:399)
                at org.eclipse.debug.core.Launch.launchConfigurationRemoved(Launch.java:516)
                at
                org.eclipse.debug.internal.core.LaunchManager$ConfigurationNotifier.run(LaunchManager.java:1484)
                at
                org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:615)
                at org.eclipse.core.runtime.Platform.run(Platform.java:758)
                at
                org.eclipse.debug.internal.core.LaunchManager$ConfigurationNotifier.notify(LaunchManager.java:1505)
                at
                org.eclipse.debug.internal.core.LaunchManager.launchConfigurationDeleted(LaunchManager.java:736)
                at
                org.eclipse.debug.internal.core.LaunchManager$LaunchManagerVisitor.visit(LaunchManager.java:1067)
                at org.eclipse.core.internal.events.ResourceDelta.accept(ResourceDelta.java:68)
                at org.eclipse.core.internal.events.ResourceDelta.accept(ResourceDelta.java:77)
                at org.eclipse.core.internal.events.ResourceDelta.accept(ResourceDelta.java:77)
                at org.eclipse.core.internal.events.ResourceDelta.accept(ResourceDelta.java:77)
                at org.eclipse.core.internal.events.ResourceDelta.accept(ResourceDelta.java:49)
                at
                org.eclipse.debug.internal.core.LaunchManager.resourceChanged(LaunchManager.java:939)
                at
                org.eclipse.core.internal.events.NotificationManager$2.run(NotificationManager.java:283)
                at
                org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:615)
                at org.eclipse.core.runtime.Platform.run(Platform.java:758)
                at
                org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:277)
                at
                org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:151)
                at
                org.eclipse.core.internal.resources.Workspace.broadcastChanges(Workspace.java:172)
                at org.eclipse.core.internal.resources.Workspace.endOperation(Workspace.java:900)
                at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1682)
                at
                org.eclipse.core.internal.events.NotificationManager$NotifyJob.run(NotificationManager.java:38)
                at org.eclipse.core.internal.jobs.Worker.run(Worker.java:66)
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.ui.DebugUIMessages.properties</file>
            <file type="M">org.eclipse.jdt.internal.debug.ui.JavaDebugOptionsManager.java</file>
        </fixedFiles>
    </bug>
    <bug id="78534" opendate="2004-11-12 13:13:10" fixdate="2005-01-26 17:03:49" resolution="Fixed">
        <buginformation>
            <summary>ConcurrentModificationException in ThreadMonitorManager.
            </summary>
            <description>I got this exception while debugging a test case.
                Apparently, HashMap#clone() is not thread safe.
                !ENTRY org.eclipse.debug.core 4 120 2004-11-12 09:51:02.64
                !MESSAGE An exception occurred while dispatching debug events.
                !STACK 0
                java.util.ConcurrentModificationException
                at java.util.HashMap$HashIterator.nextEntry(HashMap.java:787)
                at java.util.HashMap$EntryIterator.next(HashMap.java:829)
                at java.util.HashMap$EntryIterator.next(HashMap.java:827)
                at java.util.HashMap.putAllForCreate(HashMap.java:427)
                at java.util.HashMap.clone(HashMap.java:659)
                at
                org.eclipse.jdt.internal.debug.ui.monitors.ThreadMonitorManager.handleSuspendResume(ThreadMonitorManager.java:113)
                at
                org.eclipse.jdt.internal.debug.ui.monitors.ThreadMonitorManager.handleDebugEvents(ThreadMonitorManager.java:100)
                at
                org.eclipse.debug.core.DebugPlugin$EventNotifier.run(DebugPlugin.java:965)
                at
                org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:616)
                at org.eclipse.core.runtime.Platform.run(Platform.java:747)
                at
                org.eclipse.debug.core.DebugPlugin$EventNotifier.dispatch(DebugPlugin.java:997)
                at
                org.eclipse.debug.core.DebugPlugin.fireDebugEventSet(DebugPlugin.java:345)
                at
                org.eclipse.jdt.internal.debug.core.model.JDIDebugElement.fireEvent(JDIDebugElement.java:148)
                at
                org.eclipse.jdt.internal.debug.core.model.JDIDebugElement.fireResumeEvent(JDIDebugElement.java:172)
                at
                org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.resume(JDIDebugTarget.java:1072)
                at
                org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.resume(JDIDebugTarget.java:1040)
                at
                org.eclipse.jdt.internal.debug.core.model.JDIDebugTarget.handleVMStart(JDIDebugTarget.java:335)
                at
                org.eclipse.jdt.internal.debug.core.EventDispatcher.dispatch(EventDispatcher.java:149)
                at
                org.eclipse.jdt.internal.debug.core.EventDispatcher.run(EventDispatcher.java:221)
                at java.lang.Thread.run(Thread.java:595)
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.ui.monitors.ThreadMonitorManager.java</file>
        </fixedFiles>
    </bug>
    <bug id="21801" opendate="2002-07-23 08:46:13" fixdate="2002-07-31 10:29:51" resolution="Fixed">
        <buginformation>
            <summary>ThreadGroupReference related data should be cached.
            </summary>
            <description>In the current implementation of the JDI client, a jdwp command is send each time the thread
                group of a thread, the name or the parent of a thread group is asked.
                These data are never modify (there is no API for that in the base java library), they should be cached
                for reduce the number of jdwp command.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdi.internal.ThreadGroupReferenceImpl.java</file>
            <file type="M">rg.eclipse.jdi.internal.ThreadReferenceImpl.java</file>
        </fixedFiles>
    </bug>
    <bug id="65107" opendate="2004-06-01 14:38:06" fixdate="2004-12-27 16:01:25" resolution="Fixed">
        <buginformation>
            <summary>ClassCastException processing async thread queue.
            </summary>
            <description>Debugging some (horrible) code I got the following exception:
                Error Jun 01, 2004 13:30:30.703 Exception processing async thread queue
                java.lang.ClassCastException
                at org.eclipse.jdt.internal.debug.eval.ast.instructions.Instruction.popValue(Instruction.java:115)
                at
                org.eclipse.jdt.internal.debug.eval.ast.instructions.PushFieldVariable.execute(PushFieldVariable.java:49)
                at org.eclipse.jdt.internal.debug.eval.ast.engine.Interpreter.execute(Interpreter.java:50)
                at
                org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine$1$EvaluationRunnable.run(ASTEvaluationEngine.java:317)
                at org.eclipse.jdt.internal.debug.core.model.JDIThread.runEvaluation(JDIThread.java:659)
                at
                org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine$EvalRunnable.run(ASTEvaluationEngine.java:351)
                at org.eclipse.jdt.internal.debug.core.model.JDIThread$ThreadJob.run(JDIThread.java:2510)
                at org.eclipse.core.internal.jobs.Worker.run(Worker.java:66)
                Steps to reproduce...
                1 Debug this:
                public class WatchpointTest {
                int total;
                public static void main(String[] args) {
                startThread("T1!");
                startThread("T2!");
                }
                private static void startThread(String threadName) {
                Thread t = new Thread(new Runnable() {
                public void run() {
                new WatchpointTest().doHighschoolMath();
                }
                }, threadName);
                t.start();
                }
                private void doHighschoolMath() {
                for (int i = 0; i
                30; i++) {
                total+=i; //---------- breakpoint here!!
                }
                }
                }
                2.
                In DebugView switch stack frames a few times, alternating between "T1!" and "T2!"
                Note: I had watches on total and i when I discovered this bug.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.eval.ast.engine.EvaluationSourceGenerator.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.eval.ast.engine.SourceBasedSourceGenerator.java</file>
        </fixedFiles>
    </bug>
    <bug id="178912" opendate="2007-03-22 18:20:53" fixdate="2014-04-16 01:54:35" resolution="Fixed">
        <buginformation>
            <summary>IVMInstallType api and AbstractVMInstallType impl are not thread safe.
            </summary>
            <description>The IVMInstallType.createVMInstall(id>) method call immediately makes the vm install visible
                to everyone.
                I hit a race condition that looked like this:
                Thread 1
                ========
                IVMInstall vm = type.createVMInstall(vmId);
                vm.setInstallLocation( vmLocation );
                vm.setName(vmName);
                Thread 2
                ========
                java.lang.NullPointerException
                at org.eclipse.jdt.launching.AbstractVMInstallType.findVMInstallByName(AbstractVMInstallType.java:146)
                at org.eclipse.jdt.internal.launching.JREContainerInitializer.resolveVM(JREContainerInitializer.java:82)
                at
                org.eclipse.jdt.internal.launching.JREContainerInitializer.initialize(JREContainerInitializer.java:52)
                at org.eclipse.jdt.internal.launching.LaunchingPlugin$VMChanges.rebind(LaunchingPlugin.java:279)
                at org.eclipse.jdt.internal.launching.LaunchingPlugin$VMChanges.access$0(LaunchingPlugin.java:244)
                at org.eclipse.jdt.internal.launching.LaunchingPlugin$1.run(LaunchingPlugin.java:232)
                at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:39)
                at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:720)
                at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1737)
                at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:4024)
                at org.eclipse.jdt.internal.launching.LaunchingPlugin$VMChanges.doit(LaunchingPlugin.java:236)
                at org.eclipse.jdt.internal.launching.LaunchingPlugin$JREUpdateJob.run(LaunchingPlugin.java:316)
                at org.eclipse.core.internal.jobs.Worker.run(Worker.java:58)
                public IVMInstall findVMInstallByName(String name) {
                for (int i= 0; i fVMs.size(); i++) {
                IVMInstall vm= (IVMInstall)fVMs.get(i);
                if (vm.getName().equals(name)) {-- NPE right here
                return vm;
                }
                }
                return null;
                }
                There are two thread safety problems here:
                1.
                IVMInstallType api causes new runtimes to be made available to everyone before they can be fully
                initialized.
                2.
                AbstractVMInstallType internally does not use synchronization.
                Most specifically, access to fVMs list member variable is not synchronized.
                Potential fix:
                Can't change existing IVMInstallType api, but the AbstractVMInstallType implementation can be changed to
                synchronize on the vm type object for all getter and setter methods that deal with vm instances.
                That directly addresses #2 and allows #1 to be worked around by adding a synchronized block around code
                in Thread 1 above...
                synchronized( type )
                {
                IVMInstall vm = type.createVMInstall(vmId);
                vm.setInstallLocation( vmLocation );
                vm.setName(vmName);
                }
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.launching.AbstractVMInstallType.java</file>
        </fixedFiles>
    </bug>
    <bug id="88923" opendate="2005-03-23 15:23:25" fixdate="2009-08-30 02:16:44" resolution="Fixed">
        <buginformation>
            <summary>Evaluations create compiled expression in UI thread.
            </summary>
            <description>The #evaluate(..) methods on IEvaluationEngine create compiled expressions in the UI thread
                before performing an evaluation asynchronously.
                All evaluation processing should be done asynchronously.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.ui.actions.JavaObjectValueEditor.java</file>
            <file type="M">org.eclipse.jdt.internal.debug.ui.actions.EvaluateAction.java</file>
        </fixedFiles>
    </bug>
    <bug id="8683" opendate="2002-01-29 11:32:54" fixdate="2002-02-07 10:44:42" resolution="Fixed">
        <buginformation>
            <summary>NPE after suspending VM attempting to step on system thread.
            </summary>
            <description>20020124++
                Suspend the VM.
                Select the SignalDispatcher thread.
                Hit step over.
                Our code assumes that there is a top stack frame.
                java.lang.NullPointerException
                at org.eclipse.jdt.internal.debug.core.model.JDIThread$StepHandler.step(JDIThread.java:1510)
                at org.eclipse.jdt.internal.debug.core.model.JDIThread.stepReturn(JDIThread.java:1115)
                at
                org.eclipse.debug.internal.ui.actions.StepReturnActionDelegate.stepAction(StepReturnActionDelegate.java:29)
                at org.eclipse.debug.internal.ui.actions.StepActionDelegate.doAction(StepActionDelegate.java:22)
                at org.eclipse.debug.internal.ui.actions.ControlActionDelegate$1.run(ControlActionDelegate.java:91)
                at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:56)
                at org.eclipse.debug.internal.ui.actions.ControlActionDelegate.run(ControlActionDelegate.java:86)
                at org.eclipse.debug.internal.ui.actions.ControlActionDelegate.run(ControlActionDelegate.java:123)
                at org.eclipse.ui.internal.PluginAction.runWithEvent(PluginAction.java:204)
                at
                org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:407)
                at org.eclipse.jface.action.ActionContributionItem.handleWidgetEvent(ActionContributionItem.java:361)
                at org.eclipse.jface.action.ActionContributionItem.access$0(ActionContributionItem.java:352)
                at
                org.eclipse.jface.action.ActionContributionItem$ActionListener.handleEvent(ActionContributionItem.java:47)
                at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:74)
                at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:637)
                at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:1413)
                at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1205)
                at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:852)
                at org.eclipse.ui.internal.Workbench.run(Workbench.java:835)
                at org.eclipse.core.internal.boot.InternalBootLoader.run(InternalBootLoader.java:878)
                at org.eclipse.core.boot.BootLoader.run(BootLoader.java:321)
                at SlimLauncher.main(SlimLauncher.java:14)
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.core.model.JDIThread.java</file>
        </fixedFiles>
    </bug>
    <bug id="16930" opendate="2002-05-22 13:43:39" fixdate="2002-05-28 21:08:13" resolution="Fixed">
        <buginformation>
            <summary>Eval: incompatible thread state.
            </summary>
            <description>When I pause a thread (manually), and perform an evaluation, I get an
                InvalidThreadStateException - which is expected.
                We should provide a better error message for the user, as the 'toString' area does - i.e. must be
                suspended after a step or breakpoint to perform an evaluation.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.ui.actions.EvaluateAction.java</file>
        </fixedFiles>
    </bug>
    <bug id="165174" opendate="2006-11-20 11:40:44" fixdate="2006-11-20 17:22:56" resolution="Fixed">
        <buginformation>
            <summary>selection is lost in launch view after stepping into sync block.
            </summary>
            <description>using the following code, selection in the launch view is lost after stepping into the sync
                block with show monitors turned on.
                public class Main {
                public static void main(String[] args) {
                System.out.println("bp on this line");
                synchronized (new Object()) {
                System.out.println("bp on this line");
                }
                }
                }
                will attach a screenshot.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.ui.threadgroups.JavaThreadEventHandler.java</file>
        </fixedFiles>
    </bug>
    <bug id="287834" opendate="2009-08-27 10:22:16" fixdate="2009-09-08 11:54:11" resolution="Fixed">
        <buginformation>
            <summary>JavaLineBreakpoint is not thread-safe and causes 100% CPU.
            </summary>
            <description>Build ID: Eclipse 3.5
                Steps To Reproduce:
                I was in a normal debug session.
                When I wanted to pause a thread, the request timed-out.
                Afterward, the CPU went to 100%.
                I needed to restart to fix it.
                It looks like JavaLineBreakpoint can be accessed by multiple threads at the same time.
                This may be unintentional.
                The stacks I have show that there are two EventDispatcher threads active.
                The comments for that class say that there should only be 1 active at a time.
                If for some reason more than one is active, they can be simultaneously accessing the JavaLineBreakpoint.
                Accessing a hashmap from more than one thread can corrupt its internal structure and it can go into an
                infinite loop.
                (See http://mailinator.blogspot.com/2009/06/beautiful-race-condition.html)
                Attaching several stacks I took while the CPU was at 100%.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.jdt.internal.debug.core.breakpoints.JavaLineBreakpoint.java</file>
        </fixedFiles>
    </bug>
</bugrepository>