<?xml version = "1.0" encoding = "UTF-8" ?>
<bugrepository name="LANG">
	<bug id="261" opendate="2006-06-01 00:10:25" fixdate="2006-06-06 02:37:22" resolution="Fixed">
		<buginformation>
			<summary>Error in an example in the javadoc of the StringUtils.splitPreserveAllTokens() method</summary>
			<description>There is an error in the javadoc of the org.apache.commons.lang.StringUtils.splitPreserveAllTokens(String str,char separatorChar) method.
Here the original line :
StringUtils.splitPreserveAllTokens("a..b.c", &amp;amp;apos;.&amp;amp;apos;)   = ["a", "b", "c"]
But it should be :
StringUtils.splitPreserveAllTokens("a..b.c", &amp;amp;apos;.&amp;amp;apos;)   = ["a", "", "b", "c"]</description>
			<version>2.1</version>
			<fixedVersion>2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.StringUtilsTest.java</file>
			<file type="M">org.apache.commons.lang.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="100" opendate="2005-11-29 21:57:38" fixdate="2006-06-27 07:28:09" resolution="Fixed">
		<buginformation>
			<summary>[lang] RandomStringUtils.random() family of methods create invalid unicode sequences</summary>
			<description>Problem are surrogate pairs: 
E.g. RandomStringUtils.random(int) may create strings with a high surrogate not
followed by a low surrogate character.
When processing them, we get errors in string-conversion-functions later on.</description>
			<version>2.1</version>
			<fixedVersion>2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.RandomStringUtils.java</file>
			<file type="M">org.apache.commons.lang.RandomStringUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="59" opendate="2005-10-26 07:22:00" fixdate="2006-07-21 05:15:42" resolution="Fixed">
		<buginformation>
			<summary>[lang] DateUtils.truncate method is buggy when dealing with DST switching hours</summary>
			<description>Try to truncate 2004-10-31 01:00:00 MDT by hour and you&amp;amp;apos;ll actually get 2004-10-
31 01:00:00 MST, which is one hour after the input hour.
    // truncate 2004-10-31 01:00:00 MDT
    Date oct31_01MDT = new Date(1099206000000L);    
    Date result = DateUtils.truncate(oct31_01MDT, Calendar.HOUR_OF_DAY);
    assertEquals(oct31_01MDT, result);</description>
			<version>2.1</version>
			<fixedVersion>2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.time.DateUtilsTest.java</file>
			<file type="M">org.apache.commons.lang.time.DateUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">654</link>
		</links>
	</bug>
	<bug id="271" opendate="2006-07-08 23:51:26" fixdate="2006-08-10 21:25:47" resolution="Fixed">
		<buginformation>
			<summary>LocaleUtils test fails under Mustang</summary>
			<description>Testsuite: org.apache.commons.lang.LangTestSuite
Tests run: 635, Failures: 1, Errors: 0, Time elapsed: 4.467 sec
------------- Standard Output ---------------
------------- ---------------- ---------------
Testcase: testLanguagesByCountry(org.apache.commons.lang.LocaleUtilsTest):      FAILED
expected:&amp;lt;1&amp;gt; but was:&amp;lt;2&amp;gt;
junit.framework.AssertionFailedError: expected:&amp;lt;1&amp;gt; but was:&amp;lt;2&amp;gt;
        at org.apache.commons.lang.LocaleUtilsTest.assertLanguageByCountry(LocaleUtilsTest.java:396)
        at org.apache.commons.lang.LocaleUtilsTest.testLanguagesByCountry(LocaleUtilsTest.java:426)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)</description>
			<version>2.1</version>
			<fixedVersion>2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.LocaleUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="259" opendate="2006-05-22 21:10:15" fixdate="2006-08-18 22:21:34" resolution="Fixed">
		<buginformation>
			<summary>ValuedEnum.compareTo(Object other) not typesafe - it easily could be...</summary>
			<description>int org.apache.commons.lang.enums.ValuedEnum.compareTo(Object other)
 is not typesafe - if the int-values are the same, it will return "0" even for two totally different sub-classes of ValuedEnum</description>
			<version>2.1</version>
			<fixedVersion>2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.enums.ValuedEnumTest.java</file>
			<file type="M">org.apache.commons.lang.enums.EnumEqualsTest.java</file>
			<file type="M">org.apache.commons.lang.enums.ValuedEnum.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">258</link>
		</links>
	</bug>
	<bug id="277" opendate="2006-08-30 06:22:04" fixdate="2006-08-30 18:19:44" resolution="Fixed">
		<buginformation>
			<summary>Javadoc errors on StringUtils.splitPreserveAllTokens(String, char)</summary>
			<description>In the Javadoc for StringUtils.splitPreserveAllTokens(String, char) there are a couple of mistakes.  I didn&amp;amp;apos;t check for similar mistakes in the similar functions with different signatures.
StringUtils.splitPreserveAllTokens("a..b.c", &amp;amp;apos;.&amp;amp;apos;)   = ["a", "b", "c"]
should read
StringUtils.splitPreserveAllTokens("a..b.c", &amp;amp;apos;.&amp;amp;apos;)   = ["a", "", "b", "c"]
These two lines have the same input giving different outputs.  I think that the input string on the second call should be "a b c  ".
StringUtils.splitPreserveAllTokens("a b c ", &amp;amp;apos; &amp;amp;apos;)   = ["a", "b", "c", ""]
StringUtils.splitPreserveAllTokens("a b c ", &amp;amp;apos; &amp;amp;apos;)   = ["a", "b", "c", "", ""]</description>
			<version>2.1</version>
			<fixedVersion>2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.StringUtilsTest.java</file>
			<file type="M">org.apache.commons.lang.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="278" opendate="2006-09-12 12:09:36" fixdate="2006-09-12 15:26:19" resolution="Fixed">
		<buginformation>
			<summary>javadoc for StringUtils.removeEnd is incorrect</summary>
			<description>The javadoc for StringUtils.removeEnd(String, String) lists a number of examples, one of which is wrong:
StringUtils.removeEnd("www.domain.com", ".com.")  = "www,domain"
The actual result of this is just "www.domain.com"</description>
			<version>2.1</version>
			<fixedVersion>2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.StringUtilsTest.java</file>
			<file type="M">org.apache.commons.lang.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="281" opendate="2006-10-05 16:51:37" fixdate="2006-10-07 00:23:28" resolution="Fixed">
		<buginformation>
			<summary>DurationFormatUtils returns wrong result</summary>
			<description>DurationFormatUtils returns wrong result.  oddly, it is only when Date is set to Dec 31, 2005
The following code will result in a String of -2 which is way off.
I&amp;amp;apos;ve tested against 2.1 and 2.2.
        Calendar cal = Calendar.getInstance();
        cal.set(Calendar.MONTH, Calendar.DECEMBER);
        cal.set(Calendar.DAY_OF_MONTH, 31);
        cal.set(Calendar.YEAR, 2005);
        cal.set(Calendar.HOUR_OF_DAY, 0);
        cal.set(Calendar.MINUTE, 0);
        cal.set(Calendar.SECOND, 0);
        cal.set(Calendar.MILLISECOND, 0);
        String result = DurationFormatUtils.formatPeriod(cal.getTimeInMillis(), System.currentTimeMillis(), "MM");
        System.out.println(result);</description>
			<version>2.1</version>
			<fixedVersion>2.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.time.DurationFormatUtilsTest.java</file>
			<file type="M">org.apache.commons.lang.time.DurationFormatUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="294" opendate="2006-10-31 11:07:08" fixdate="2006-10-31 22:15:27" resolution="Fixed">
		<buginformation>
			<summary>StrBuilder.replaceAll and StrBuilder.deleteAll can throw ArrayIndexOutOfBoundsException.</summary>
			<description>StrBuilder.replaceAll and StrBuilder.deleteAll can thrown ArrayIndexOutOfBoundsException&amp;amp;apos;s. Here are a couple of additions to the StrBuilderTest class that demonstrate this problem:
StrBuilder.deleteAll() - added to testDeleteAll_String():
        sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");
        sb.deleteAll("\n%BLAH%");
        assertEquals("\nDo more stuff\neven more stuff\n", sb.toString());
this causes the following error:
java.lang.ArrayIndexOutOfBoundsException
	at java.lang.System.arraycopy(Native Method)
	at org.apache.commons.lang.text.StrBuilder.deleteImpl(StrBuilder.java:1114)
	at org.apache.commons.lang.text.StrBuilder.deleteAll(StrBuilder.java:1188)
	at org.apache.commons.lang.text.StrBuilderTest.testDeleteAll_String(StrBuilderTest.java:606)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)
StrBuilder.replaceAll() - added to testReplaceAll_String_String():
        sb = new StrBuilder("\n%BLAH%\nDo more stuff\neven more stuff\n%BLAH%\n");
        sb.replaceAll("\n%BLAH%", "");
        assertEquals("\nDo more stuff\neven more stuff\n", sb.toString());
this causes the exception:
java.lang.ArrayIndexOutOfBoundsException
	at java.lang.System.arraycopy(Native Method)
	at org.apache.commons.lang.text.StrBuilder.replaceImpl(StrBuilder.java:1256)
	at org.apache.commons.lang.text.StrBuilder.replaceAll(StrBuilder.java:1339)
	at org.apache.commons.lang.text.StrBuilderTest.testReplaceAll_String_String(StrBuilderTest.java:763)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at org.eclipse.jdt.internal.junit.runner.junit3.JUnit3TestReference.run(JUnit3TestReference.java:128)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:673)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:386)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</description>
			<version>2.2</version>
			<fixedVersion>2.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.text.StrBuilderTest.java</file>
			<file type="M">org.apache.commons.lang.text.StrBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="299" opendate="2006-12-11 11:58:25" fixdate="2006-12-12 22:35:59" resolution="Fixed">
		<buginformation>
			<summary>Bug in method appendFixedWidthPadRight of class StrBuilder causes an ArrayIndexOutOfBoundsException</summary>
			<description>There&amp;amp;apos;s a bug in method appendFixedWidthPadRight of class StrBuilder:
public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {
        if (width &amp;gt; 0) {
            ensureCapacity(size + width);
            String str = (obj == null ? getNullText() : obj.toString());
            int strLen = str.length();
            if (strLen &amp;gt;= width) 
{
 ==&amp;gt;            str.getChars(0, strLen, buffer, size);   &amp;lt;==== BUG: it should be str.getChars(0, width, buffer, size);
            }
 else {
                int padLen = width - strLen;
                str.getChars(0, strLen, buffer, size);
                for (int i = 0; i &amp;lt; padLen; i++) 
{
                    buffer[size + strLen + i] = padChar;
                }
            }
            size += width;
        }
        return this;
    }
This is causing an ArrayIndexOutOfBoundsException, so this method is unusable when strLen &amp;gt; width.
It&amp;amp;apos;s counterpart method appendFixedWidthPadLeft seems to be ok.</description>
			<version>2.2</version>
			<fixedVersion>2.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.text.StrBuilderAppendInsertTest.java</file>
			<file type="M">org.apache.commons.lang.text.StrBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="300" opendate="2006-12-19 17:47:43" fixdate="2006-12-19 21:50:46" resolution="Fixed">
		<buginformation>
			<summary>NumberUtils.createNumber throws NumberFormatException for one digit long</summary>
			<description>NumberUtils.createNumber throws a NumberFormatException when parsing "1l", "2l" .. etc...
It works fine if you try to parse "01l" or "02l".  The condition isDigits(numeric.substring(1)), line 455 return false as numeric.substring(1) is an empty string for "1l"</description>
			<version>2.2</version>
			<fixedVersion>2.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.math.NumberUtils.java</file>
			<file type="M">org.apache.commons.lang.NumberUtils.java</file>
			<file type="M">org.apache.commons.lang.math.NumberUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">457</link>
		</links>
	</bug>
	<bug id="304" opendate="2006-12-22 20:32:58" fixdate="2006-12-22 20:35:51" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException in isAvailableLocale(Locale)</summary>
			<description>FindBugs pointed out:
   UwF: Field not initialized in constructor: org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet
cAvailableSet is used directly once in the source - and if availableLocaleSet() hasn&amp;amp;apos;t been called it will cause a NullPointerException.</description>
			<version>2.2</version>
			<fixedVersion>2.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.LocaleUtils.java</file>
			<file type="M">org.apache.commons.lang.LocaleUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="303" opendate="2006-12-22 19:55:34" fixdate="2006-12-26 22:08:27" resolution="Fixed">
		<buginformation>
			<summary>FastDateFormat.mRules is not transient or serializable</summary>
			<description>Reported by FindBugs.
Either we need to make the Rule interface Serializable, or make mRules transient and add deserializing code to kick off init().</description>
			<version>2.2</version>
			<fixedVersion>2.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.time.FastDateFormatTest.java</file>
			<file type="M">org.apache.commons.lang.time.FastDateFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="102" opendate="2006-04-24 13:19:35" fixdate="2007-01-01 23:29:28" resolution="Fixed">
		<buginformation>
			<summary>[lang] Refactor Entities methods</summary>
			<description>The pairs of escape and unescape methods in Entities need to be modified so that
they call each other (one escape to the other escape etc). Otherwise there&amp;amp;apos;s a
large chunk of repeated code that gives us a high chance of errors.</description>
			<version>2.2</version>
			<fixedVersion>2.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.Entities.java</file>
		</fixedFiles>
	</bug>
	<bug id="313" opendate="2007-01-16 07:26:30" fixdate="2007-01-17 03:58:45" resolution="Fixed">
		<buginformation>
			<summary>Wrong behavior of Entities.unescape</summary>
			<description>Hi,
    There&amp;amp;apos;s seems to be a bug at Entities.unescape. Try for example StringEscapeUtils.unescapeHtml("&amp;amp; &amp;amp;"). It outputs "&amp;amp; &amp;amp;" instead of "&amp;amp; &amp;amp;". The problem is at this piece of code:
                if (entityValue == -1) 
{
                    buf.append(&amp;amp;apos;&amp;amp;&amp;amp;apos;);
                    buf.append(entityName);
                    buf.append(&amp;amp;apos;;&amp;amp;apos;);
                }
 else 
{
                    buf.append((char) (entityValue));
                }
                i = semi;
     The method always skips to the next ";", even if it doesn&amp;amp;apos;t finds the entity value and then disregarding any entity that may be actually be referred inside.
Regards,
Thiago Souza</description>
			<version>2.1</version>
			<fixedVersion>2.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.StringEscapeUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="69" opendate="2005-08-07 05:14:30" fixdate="2007-02-06 21:10:31" resolution="Fixed">
		<buginformation>
			<summary>[lang] ToStringBuilder throws StackOverflowError when an Object cycle exists</summary>
			<description>Hi,
The ToStringBuilder throws a StackOverflowError if you have a cycle in the
object graph. For instance, the following toString() method will cause a
StackOverflowError:
public class ObjectCycle {
    Object obj;
    public String toString() 
{
        return new ToStringBuilder(this).append(obj).toString();
    }
}
public void testObjectCycle() {
    ObjectCycle a = new ObjectCycle();
    ObjectCycle b = new ObjectCycle();
    a.obj = b;
    b.obj = a;
    a.toString();  // ouch: StackOverflowError    	
}
I&amp;amp;apos;ll submit some patches that fixes this problem...
regards,
Maarten</description>
			<version>2.1</version>
			<fixedVersion>2.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.builder.ToStringStyle.java</file>
			<file type="M">org.apache.commons.lang.builder.ToStringBuilderTest.java</file>
			<file type="M">org.apache.commons.lang.builder.ReflectionToStringBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="315" opendate="2007-02-06 13:52:59" fixdate="2007-02-06 22:49:59" resolution="Fixed">
		<buginformation>
			<summary>StopWatch: suspend() acts as split(), if followed by stop()</summary>
			<description>In my opinion, it is a bug that suspend() acts as split(), if followed by stop(); see below:
        StopWatch sw = new StopWatch();
        sw.start();
        Thread.sleep(1000);
        sw.suspend();
        // Time 1 (ok)
        System.out.println(sw.getTime());
        Thread.sleep(2000);
        // Time 1 (again, ok)
        System.out.println(sw.getTime());
        sw.resume();
        Thread.sleep(3000);
        sw.suspend();
        // Time 2 (ok)
        System.out.println(sw.getTime());
        Thread.sleep(4000);
        // Time 2 (again, ok)
        System.out.println(sw.getTime());
        Thread.sleep(5000);
        sw.stop();
        // Time 2 (should be, but is Time 3 =&amp;gt; NOT ok)
        System.out.println(sw.getTime());
suspend/resume is like a pause, where time counter doesn&amp;amp;apos;t continue. So a following stop()-call shouldn&amp;amp;apos;t increase the time counter, should it?</description>
			<version>2.0</version>
			<fixedVersion>2.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.time.StopWatch.java</file>
			<file type="M">org.apache.commons.lang.time.StopWatchTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="328" opendate="2007-04-16 23:11:44" fixdate="2007-05-01 23:50:11" resolution="Fixed">
		<buginformation>
			<summary>LocaleUtils.toLocale() rejects strings with only language+variant</summary>
			<description>LocaleUtils.toLocale() throws an exception on strings containing a language and a variant but no country code. For example : fr__POSIX
This string can be produced with the JDK by instanciating a Locale with an empty string for the country : new Locale("fr", "", "POSIX").toString(). According to the javadoc for the Locale class a variant is allowed with just a language code or just a country code.
Commons Configuration handles this case in its PropertyConverter.toLocale() method. I&amp;amp;apos;d like to replace our implementation by the one provided by LocaleUtils, but our tests fail due to this case.</description>
			<version>2.3</version>
			<fixedVersion>2.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.LocaleUtils.java</file>
			<file type="M">org.apache.commons.lang.LocaleUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="346" opendate="2007-07-06 20:06:55" fixdate="2007-08-09 00:25:20" resolution="Fixed">
		<buginformation>
			<summary>Dates.round() behaves incorrectly for minutes and seconds</summary>
			<description>Get unexpected output for rounding by minutes or seconds.
public void testRound()
{
    Calendar testCalendar = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
    testCalendar.set(2007, 6, 2, 8, 9, 50);
    Date date = testCalendar.getTime();
    System.out.println("Before round() " + date);
    System.out.println("After round()  " + DateUtils.round(date, Calendar.MINUTE));
}
--2.1 produces
Before round() Mon Jul 02 03:09:50 CDT 2007
After round()  Mon Jul 02 03:10:00 CDT 2007  this is what I would expect
--2.2 and 2.3 produces
Before round() Mon Jul 02 03:09:50 CDT 2007
After round()  Mon Jul 02 03:01:00 CDT 2007  this appears to be wrong</description>
			<version>2.2</version>
			<fixedVersion>2.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.time.DateUtilsTest.java</file>
			<file type="M">org.apache.commons.lang.time.DateUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">414</link>
		</links>
	</bug>
	<bug id="361" opendate="2007-10-22 15:24:05" fixdate="2007-10-23 05:32:23" resolution="Fixed">
		<buginformation>
			<summary>BooleanUtils toBooleanObject javadoc does not match implementation</summary>
			<description>The javadoc description for the BooleanUtils method toBooleanObject(String, String, String, String) states that it returns null if the input string does not match the true, false, or null string values.  However, the implementation throws and IllegalArgumentException when the input string does not match the other string values.</description>
			<version>2.3</version>
			<fixedVersion>2.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.BooleanUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="364" opendate="2007-10-24 18:32:41" fixdate="2007-10-25 06:25:23" resolution="Fixed">
		<buginformation>
			<summary>Documentation bug for ignoreEmptyTokens accessors in StrTokenizer</summary>
			<description>The javadoc for the accessors of the ignoreEmptyTokens property currently states that the default value is false, when it is actually true.</description>
			<version>2.3</version>
			<fixedVersion>2.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.text.StrTokenizer.java</file>
		</fixedFiles>
	</bug>
	<bug id="363" opendate="2007-10-23 07:12:48" fixdate="2007-10-26 06:09:17" resolution="Fixed">
		<buginformation>
			<summary>StringEscapeUtils.escapeJavaScript() method did not escape &amp;apos;/&amp;apos; into &amp;apos;\/&amp;apos;, it will make IE render page uncorrectly</summary>
			<description>If Javascripts including&amp;amp;apos;/&amp;amp;apos;, IE will parse the scripts uncorrectly, actually &amp;amp;apos;/&amp;amp;apos; should be escaped to &amp;amp;apos;\/&amp;amp;apos;.
For example, document.getElementById("test").value = &amp;amp;apos;&amp;lt;script&amp;gt;alert(\&amp;amp;apos;aaa\&amp;amp;apos;);&amp;lt;/script&amp;gt;&amp;amp;apos;;this expression will make IE render page uncorrect, it should be document.getElementById("test").value = &amp;amp;apos;&amp;lt;script&amp;gt;alert(\&amp;amp;apos;aaa\&amp;amp;apos;);&amp;lt;\/script&amp;gt;&amp;amp;apos;;
Btw, Spring&amp;amp;apos;s JavascriptEscape behavor is correct.
Try  to run below codes, you will find the difference:
  String s = "&amp;lt;script&amp;gt;alert(&amp;amp;apos;aaa&amp;amp;apos;);&amp;lt;/script&amp;gt;";
  String str = org.springframework.web.util.JavaScriptUtils.javaScriptEscape(s);
  System.out.println("Spring JS Escape : "+str);
  str = org.apache.commons.lang.StringEscapeUtils.escapeJavaScript(s);
  System.out.println("Apache Common Lang JS Escape : "+ str);</description>
			<version>2.3</version>
			<fixedVersion>2.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.StringEscapeUtilsTest.java</file>
			<file type="M">org.apache.commons.lang.StringEscapeUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">437</link>
		</links>
	</bug>
	<bug id="367" opendate="2007-10-30 13:25:17" fixdate="2007-11-05 09:55:33" resolution="Fixed">
		<buginformation>
			<summary>FastDateFormat thread safety</summary>
			<description>FastDateFormat has several static HashMaps. These are currently not final, so there is no guarantee that they will be visible to all threads.
Patch to follow.
Also, as far as I can make out, the class shares SimpleDateFormat instances between threads.
It does not document why this is OK.
I&amp;amp;apos;m guessing that it assumes that instances of the SimpleDateFormat class are thread-safe provided that they have the same attributes, but this is not documented. If this is the case, it&amp;amp;apos;s not clear that it is a valid assumption.
</description>
			<version>2.2</version>
			<fixedVersion>2.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.time.FastDateFormat.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">429</link>
		</links>
	</bug>
	<bug id="380" opendate="2007-11-29 16:24:43" fixdate="2007-11-29 16:34:28" resolution="Fixed">
		<buginformation>
			<summary>infinite loop in Fraction.reduce when numerator == 0</summary>
			<description>Summary pretty much says it all.</description>
			<version>2.3</version>
			<fixedVersion>2.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.math.Fraction.java</file>
			<file type="M">org.apache.commons.lang.math.FractionTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="381" opendate="2007-11-30 13:17:41" fixdate="2008-01-06 23:59:19" resolution="Fixed">
		<buginformation>
			<summary>NumberUtils.min(floatArray) returns wrong value if floatArray[0] happens to be Float.NaN</summary>
			<description>The min() method of NumberUtils returns the wrong result if  the first value of the array happens to be Float.NaN. The following code snippet shows the behaviour:
        float a[] = new float[] 
{(float) 1.2, Float.NaN, (float) 3.7, (float) 27.0, (float) 42.0, Float.NaN}
;
        float b[] = new float[] 
{Float.NaN, (float) 1.2, Float.NaN, (float) 3.7, (float) 27.0, (float) 42.0, Float.NaN}
;
        float min = NumberUtils.min(a);
        System.out.println("min(a): " + min); // output: 1.2
        min = NumberUtils.min(b);
        System.out.println("min(b): " + min); // output: NaN
This problem may exist for double-arrays as well. 
Proposal: Use Float.compare(float, float) or NumberUtils.compare(float, float) to achieve a consistent result.</description>
			<version>2.3</version>
			<fixedVersion>2.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.math.NumberUtils.java</file>
			<file type="M">org.apache.commons.lang.math.NumberUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="393" opendate="2008-01-03 13:46:49" fixdate="2008-01-13 07:00:40" resolution="Fixed">
		<buginformation>
			<summary>EqualsBuilder don&amp;apos;t compare BigDecimals correctly </summary>
			<description>When comparing a BigDecimal, the comparing is made using equals, not compareTo, which is more appropriate in the case of BigDecimal.  </description>
			<version>2.3</version>
			<fixedVersion>2.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.builder.EqualsBuilderTest.java</file>
			<file type="M">org.apache.commons.lang.builder.EqualsBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">1113</link>
			<link type="Reference" description="is related to">468</link>
		</links>
	</bug>
	<bug id="412" opendate="2008-02-13 04:23:25" fixdate="2008-02-13 05:45:03" resolution="Fixed">
		<buginformation>
			<summary>StrBuilder appendFixedWidth does not handle nulls</summary>
			<description>Appending a null value with fixed width causes a null pointer exception if getNullText() has not been set.</description>
			<version>2.3</version>
			<fixedVersion>2.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.text.StrBuilderTest.java</file>
			<file type="M">org.apache.commons.lang.text.StrBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="depends upon">407</link>
		</links>
	</bug>
	<bug id="414" opendate="2008-02-22 10:17:13" fixdate="2008-02-24 04:24:58" resolution="Duplicate">
		<buginformation>
			<summary>DateUtils.round() often fails</summary>
			<description>The example below shows the failure of DateUtils.round(Date,int). With version 2.1 round() works fine.

        Now                                 DateUtils                        calculated directly     
2008-02-22T11:09:06,680 Rounded:   2008-02-22T11:00:01,000         2008-02-22T11:09:07,000    ERROR
2008-02-22T11:09:06,680 Truncated: 2008-02-22T11:09:06,000         2008-02-22T11:09:06,000    ok
2008-02-22T11:09:07,040 Rounded:   2008-02-22T11:09:07,000         2008-02-22T11:09:07,000    ok
2008-02-22T11:09:07,040 Truncated: 2008-02-22T11:09:07,000         2008-02-22T11:09:07,000    ok
2008-02-22T11:09:07,399 Rounded:   2008-02-22T11:09:07,000         2008-02-22T11:09:07,000    ok
2008-02-22T11:09:07,399 Truncated: 2008-02-22T11:09:07,000         2008-02-22T11:09:07,000    ok
2008-02-22T11:09:07,743 Rounded:   2008-02-22T11:00:01,000         2008-02-22T11:09:08,000    ERROR
2008-02-22T11:09:07,743 Truncated: 2008-02-22T11:09:07,000         2008-02-22T11:09:07,000    ok
2008-02-22T11:09:08,102 Rounded:   2008-02-22T11:09:08,000         2008-02-22T11:09:08,000    ok
2008-02-22T11:09:08,102 Truncated: 2008-02-22T11:09:08,000         2008-02-22T11:09:08,000    ok
2008-02-22T11:09:08,446 Rounded:   2008-02-22T11:09:08,000         2008-02-22T11:09:08,000    ok
2008-02-22T11:09:08,446 Truncated: 2008-02-22T11:09:08,000         2008-02-22T11:09:08,000    ok
2008-02-22T11:09:08,805 Rounded:   2008-02-22T11:00:01,000         2008-02-22T11:09:09,000    ERROR
2008-02-22T11:09:08,805 Truncated: 2008-02-22T11:09:08,000         2008-02-22T11:09:08,000    ok
2008-02-22T11:09:09,149 Rounded:   2008-02-22T11:09:09,000         2008-02-22T11:09:09,000    ok
2008-02-22T11:09:09,149 Truncated: 2008-02-22T11:09:09,000         2008-02-22T11:09:09,000    ok
2008-02-22T11:09:09,508 Rounded:   2008-02-22T11:00:01,000         2008-02-22T11:09:10,000    ERROR
2008-02-22T11:09:09,508 Truncated: 2008-02-22T11:09:09,000         2008-02-22T11:09:09,000    ok
2008-02-22T11:09:09,852 Rounded:   2008-02-22T11:00:01,000         2008-02-22T11:09:10,000    ERROR
2008-02-22T11:09:09,852 Truncated: 2008-02-22T11:09:09,000         2008-02-22T11:09:09,000    ok
2008-02-22T11:09:10,211 Rounded:   2008-02-22T11:09:10,000         2008-02-22T11:09:10,000    ok
2008-02-22T11:09:10,211 Truncated: 2008-02-22T11:09:10,000         2008-02-22T11:09:10,000    ok
2008-02-22T11:09:10,555 Rounded:   2008-02-22T11:00:01,000         2008-02-22T11:09:11,000    ERROR
2008-02-22T11:09:10,555 Truncated: 2008-02-22T11:09:10,000         2008-02-22T11:09:10,000    ok
2008-02-22T11:09:10,915 Rounded:   2008-02-22T11:00:01,000         2008-02-22T11:09:11,000    ERROR
2008-02-22T11:09:10,915 Truncated: 2008-02-22T11:09:10,000         2008-02-22T11:09:10,000    ok
2008-02-22T11:09:11,258 Rounded:   2008-02-22T11:09:11,000         2008-02-22T11:09:11,000    ok
2008-02-22T11:09:11,258 Truncated: 2008-02-22T11:09:11,000         2008-02-22T11:09:11,000    ok
2008-02-22T11:09:11,618 Rounded:   2008-02-22T11:00:01,000         2008-02-22T11:09:12,000    ERROR
2008-02-22T11:09:11,618 Truncated: 2008-02-22T11:09:11,000         2008-02-22T11:09:11,000    ok
2008-02-22T11:09:11,961 Rounded:   2008-02-22T11:00:01,000         2008-02-22T11:09:12,000    ERROR
2008-02-22T11:09:11,961 Truncated: 2008-02-22T11:09:11,000         2008-02-22T11:09:11,000    ok
2008-02-22T11:09:12,321 Rounded:   2008-02-22T11:09:12,000         2008-02-22T11:09:12,000    ok
2008-02-22T11:09:12,321 Truncated: 2008-02-22T11:09:12,000         2008-02-22T11:09:12,000    ok
2008-02-22T11:09:12,665 Rounded:   2008-02-22T11:00:01,000         2008-02-22T11:09:13,000    ERROR
2008-02-22T11:09:12,665 Truncated: 2008-02-22T11:09:12,000         2008-02-22T11:09:12,000    ok


Example Code
java.text.SimpleDateFormat dtFormat = new java.text.SimpleDateFormat("yyyy-MM-dd&amp;amp;apos;T&amp;amp;apos;HH:mm:ss,SSS");

System.out.println(
    "        Now            "
    + "            "
    + "   DateUtils  "
    + "         "
    + "       calculated directly "
    + "    ");
int errorCnt = 0;
while(errorCnt &amp;lt; 10)
{
  java.util.Date now = new java.util.Date();
  
  java.util.Date roundedByUtils = org.apache.commons.lang.time.DateUtils.round(now, java.util.Calendar.SECOND);
  java.util.Date truncatedByUtils = org.apache.commons.lang.time.DateUtils.truncate(now, java.util.Calendar.SECOND);
  
  long rest = now.getTime() % 1000;
  java.util.Date rounded;
  java.util.Date truncated = new java.util.Date(now.getTime() - rest);
  if (rest &amp;lt; 500)
    rounded = truncated;
  else
    rounded = new java.util.Date(now.getTime() + (1000 - rest));
  boolean roundError = !roundedByUtils.equals(rounded);
  boolean truncateError = !truncatedByUtils.equals(truncated);
  if (roundError || truncateError)
    errorCnt++;

  System.out.println(
      dtFormat.format(now)
      + " Rounded:   "
      + dtFormat.format(roundedByUtils)
      + "         "
      + dtFormat.format(rounded)
      + "    "
      + (roundError ? "ERROR" : "ok"));
  System.out.println(
      dtFormat.format(now)
      + " Truncated: "
      + dtFormat.format(truncatedByUtils)
      + "         "
      + dtFormat.format(truncated)
      + "    "
      + (truncateError ? "ERROR" : "ok"));
  Thread.sleep(351);
}

</description>
			<version>2.2</version>
			<fixedVersion>2.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.time.DateUtilsTest.java</file>
			<file type="M">org.apache.commons.lang.time.DateUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">346</link>
		</links>
	</bug>
	<bug id="418" opendate="2008-03-24 19:24:50" fixdate="2008-03-25 07:36:02" resolution="Fixed">
		<buginformation>
			<summary>Javadoc incorrect for StringUtils.endsWithIgnoreCase</summary>
			<description>The javadoc for StringUtils.endsWithIgnoreCase() shows an example that appears incorrect.  It currently looks like the following:
    StringUtils.endsWithIgnoreCase("def", "ABCDEF") = false
I believe that should return true.
It also appears that the examples in the javadoc have the parameters backwards, as the signature shows the second parameter as the "suffix", yet the suffix in the examples is the first parameter.  The following sample I think would be more correct:
    StringUtils.endsWithIgnoreCase("ABCDEF", "def") = true
</description>
			<version>2.4</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.StringUtilsStartsEndsWithTest.java</file>
			<file type="M">org.apache.commons.lang.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="421" opendate="2008-04-02 15:42:39" fixdate="2008-04-02 16:07:57" resolution="Fixed">
		<buginformation>
			<summary>StringEscapeUtils.escapeJava(String) escapes &amp;apos;/&amp;apos; characters</summary>
			<description>Commons Lang 2.4 StringEscapeUtils.escapeJava(String) now escapes &amp;amp;apos;/&amp;amp;apos; characters, which is not a valid "escapable" character in Java strings.  I haven&amp;amp;apos;t tried the other Java escape/unescape methods to see if they have a similar problem, or that only Java "escapable" characters are escaped by escapeJava(String).
This bug may have appeared as an unintended side-effect of the fix for LANG-363.
Also the javadoc for escapeJava is now a little off, in that &amp;amp;apos;/&amp;amp;apos; should now be included in the sentence describing the differences between Java and Javascript strings, with respect to escaping rules.
The following is a JUnit3 test demonstrating the bug.
import junit.framework.TestCase;
import org.apache.commons.lang.StringEscapeUtils;
public class StringEscapeUtilsTest extends TestCase {
    public void testEscapeJavaWithSlash() 
{
        final String input = "String with a slash (/) in it";
        
        final String expected = input;
        final String actual   = StringEscapeUtils.escapeJava( input );

        /**
         * In 2.4 StringEscapeUtils.escapeJava(String) escapes &amp;amp;apos;/&amp;amp;apos; characters,
         * which are not a valid character to escape in a Java string.  
         */
        assertEquals( expected, actual );
    }
}
</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.StringEscapeUtils.java</file>
			<file type="M">org.apache.commons.lang.StringEscapeUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">423</link>
			<link type="Duplicate" description="is duplicated by">473</link>
			<link type="Reference" description="is related to">437</link>
		</links>
	</bug>
	<bug id="423" opendate="2008-04-11 15:36:18" fixdate="2008-04-11 17:53:14" resolution="Duplicate">
		<buginformation>
			<summary>StringEscapeUtils.escapeJava() behavior changed; backslash escapes &amp;apos;/&amp;apos; characters</summary>
			<description>StringEscapeUtils.escapeJava(String str) escapes forward-slash ("/") characters.  Prior to 2.4, this was not the case.  This is caused by the patch in LANG-363, which changed the behavior of StringEscapeUtils.escapeJavaScript(String str) to escape forward-slashes for compatibliity with IE.  The change was implemented in code common to both methods; StringEscapeUtils.escapeJavaStyleString() .
This side-effect change to StringEscapeUtils.escapeJava() is a problem in my project.  I don&amp;amp;apos;t see any reason why it is necessary to escape forward-slashes in escapeJava(), so I suggest the behavior be changed so that escapeJavaScript() escapes forward-slashes, but escapeJava() does not.</description>
			<version>2.4</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.StringEscapeUtils.java</file>
			<file type="M">org.apache.commons.lang.StringEscapeUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">421</link>
		</links>
	</bug>
	<bug id="419" opendate="2008-03-26 17:05:47" fixdate="2008-05-11 05:18:15" resolution="Fixed">
		<buginformation>
			<summary>WordUtils.abbreviate bug when lower is greater than str.length</summary>
			<description>In WordUtils.abbreviate, upper is adjusted to the length of the string, then to lower.
But lower is never adjusted to the length of the string, so if lower is greater than str.lengt(), upper will be too...
Then, str.substring(0, upper) throw a StringIndexOutOfBoundsException
The fix is to adjust lower to the length of the string</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.WordUtilsTest.java</file>
			<file type="M">org.apache.commons.lang.WordUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="302" opendate="2006-12-22 19:47:10" fixdate="2008-05-11 05:58:13" resolution="Fixed">
		<buginformation>
			<summary>StrBuilder does not implement clone()</summary>
			<description>As reported by FindBugs.
Does StrBuilder need to be Cloneable?</description>
			<version>2.2</version>
			<fixedVersion>2.6, 3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.text.StrBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">603</link>
		</links>
	</bug>
	<bug id="429" opendate="2008-04-24 13:04:57" fixdate="2008-05-17 05:24:02" resolution="Duplicate">
		<buginformation>
			<summary>NullPointerException (NPE) in FastDateFormat.getInstance(FastDateFormat.java:211)</summary>
			<description>Sometimes (sadly this is not reproducible) the following method call results in a NullPointerException (NPE):
Stacktrace:
java.lang.NullPointerException
        at org.apache.commons.lang.time.FastDateFormat.getInstance(FastDateFormat.java:211)
        at org.apache.commons.lang.time.DateFormatUtils.format(DateFormatUtils.java:258)
        at org.apache.commons.lang.time.DateFormatUtils.format(DateFormatUtils.java:232)
I don&amp;amp;apos;t know how this is actually possible, since the exception is being raised when accessing a static field &amp;amp;apos;cInstanceCache&amp;amp;apos; that will be implicitly initialized...
Could this have something to do with class gc?</description>
			<version>2.2</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.time.FastDateFormat.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">367</link>
		</links>
	</bug>
	<bug id="459" opendate="2008-09-15 16:09:36" fixdate="2008-09-16 16:36:51" resolution="Fixed">
		<buginformation>
			<summary>Issue in HashCodeBuilder which only shows up under high load multi-threaded usage.</summary>
			<description>We found we were having problems with HashCodeBuilder under multi-threaded high load.
I narrowed this down to the following attached test case.
When I dug into the code, I found the problem was solved by commenting out the isRegistered method (though this would break the infinite loop problem).
( I did a lot of other digging that I wont bore you with).
So instead I replaced the HashSet with an ArrayList and just added the object, rather than the toIdentityHashCodeInteger(object)
This results in about 5 lines of change.  
My suspicion is that System.identityHashCode does not return unique values (it is after all a hashcode method).  The code assumes it will return a unique value and this causes the problem at high loads.
The downside is a List vs. a Set, but I believe this is necessary.
I&amp;amp;apos;d like to submit this fix and have it verified (and perhaps improved).  I am convinced it is a necessary fix which we have seen show up under high loads.
Kindest regards, 
Andrew.</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.builder.HashCodeBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="460" opendate="2008-09-17 08:27:57" fixdate="2008-09-17 23:27:39" resolution="Fixed">
		<buginformation>
			<summary>Wrong, interchanged parameters in Dokumentation of StringUtils.startsWith[IgnoreCase](String, String)</summary>
			<description>The parameters in the examples of the JavaDoc of StringUtils.startsWithIgnoreCase(String, String) and StringUtils.startsWith(String, String) are interchanged.</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.StringUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">679</link>
		</links>
	</bug>
	<bug id="440" opendate="2008-06-02 20:47:48" fixdate="2008-11-05 17:01:09" resolution="Fixed">
		<buginformation>
			<summary>DateUtils.round doesn&amp;apos;t work correct for Calendar.AM_PM</summary>
			<description>The provided JUnit-tests test with wrong expected values
original DateUtilsTest.java

dateAmPm1 = dateTimeParser.parse("February 3, 2002 01:10:00.000");
dateAmPm2 = dateTimeParser.parse("February 3, 2002 11:10:00.000");
dateAmPm3 = dateTimeParser.parse("February 3, 2002 13:10:00.000");
dateAmPm4 = dateTimeParser.parse("February 3, 2002 19:10:00.000");

assertEquals("truncate ampm-1 failed",
                dateTimeParser.parse("February 3, 2002 00:00:00.000"),
                DateUtils.round(dateAmPm1, Calendar.AM_PM));
        assertEquals("truncate ampm-2 failed",
                dateTimeParser.parse("February 4, 2002 00:00:00.000"),
                DateUtils.round(dateAmPm2, Calendar.AM_PM));
        assertEquals("truncate ampm-3 failed",
                dateTimeParser.parse("February 3, 2002 12:00:00.000"),
                DateUtils.round(dateAmPm3, Calendar.AM_PM));
        assertEquals("truncate ampm-4 failed",
                dateTimeParser.parse("February 4, 2002 12:00:00.000"),
                DateUtils.round(dateAmPm4, Calendar.AM_PM));


but expected values must be


dateTimeParser.parse("February 3, 2002 00:00:00.000");
dateTimeParser.parse("February 3, 2002 12:00:00.000");
dateTimeParser.parse("February 3, 2002 12:00:00.000");
dateTimeParser.parse("February 4, 2002 00:00:00.000");


Also in the junit-comment the word &amp;amp;apos;truncate&amp;amp;apos; must be replaced with &amp;amp;apos;round&amp;amp;apos;</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.time.TimeTestSuite.java</file>
			<file type="M">org.apache.commons.lang.time.DateUtils.java</file>
			<file type="M">org.apache.commons.lang.time.DateUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="dependent" description="is depended upon by">434</link>
		</links>
	</bug>
	<bug id="464" opendate="2008-10-01 20:54:42" fixdate="2008-11-06 20:29:33" resolution="Duplicate">
		<buginformation>
			<summary>EqualsBuilder doesn&amp;apos;t compile in 2.4 source code release</summary>
			<description>Line 381 of org.apache.commons.lang.EqualsBuilder fails to compile because the compareTo call requires a BigDecimal rather than an object.
376 public EqualsBuilder append(Object lhs, Object rhs) {
...
379         if (!lhsClass.isArray()) {
380             if (lhs instanceof java.math.BigDecimal) 
{
381                 isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0);
382             }
 else {
I&amp;amp;apos;m using Sun&amp;amp;apos;s JDK 1.6.0_07 in Eclipse, not sure if this is a JDK version issue or not.</description>
			<version>2.4</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.builder.EqualsBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">468</link>
		</links>
	</bug>
	<bug id="468" opendate="2008-11-05 15:58:22" fixdate="2008-11-06 20:36:54" resolution="Fixed">
		<buginformation>
			<summary>JDK 1.5 build/runtime failure on LANG-393 (EqualsBuilder)</summary>
			<description>See LANG-393</description>
			<version>2.4</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.builder.EqualsBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">464</link>
			<link type="Reference" description="relates to">393</link>
		</links>
	</bug>
	<bug id="477" opendate="2009-01-09 10:05:53" fixdate="2009-01-09 22:08:19" resolution="Fixed">
		<buginformation>
			<summary>ExtendedMessageFormat: OutOfMemory with custom format registry and a pattern containing single quotes</summary>
			<description>When using ExtendedMessageFormat with a custom format registry and a pattern conatining single quotes, an OutOfMemoryError will occur.
Example that will cause error:
ExtendedMessageFormatTest.java


private static Map&amp;lt;String, Object&amp;gt; formatRegistry = new HashMap&amp;lt;String, Object&amp;gt;();    
    static {
        formatRegistry.put(DummyFormatFactory.DUMMY_FORMAT, new DummyFormatFactory());
    }
    
    public static void main(String[] args) {
        ExtendedMessageFormat mf = new ExtendedMessageFormat("it&amp;amp;apos;&amp;amp;apos;s a {dummy} &amp;amp;apos;test&amp;amp;apos;!", formatRegistry);
        String formattedPattern = mf.format(new String[] {"great"});
        System.out.println(formattedPattern);
    }
}



The following change starting at line 421 on the 2.4 release seems to fix the problem:
ExtendedMessageFormat.java

CURRENT (Broken):
if (escapingOn &amp;amp;&amp;amp; c[start] == QUOTE) {
        return appendTo == null ? null : appendTo.append(QUOTE);
}

WORKING:
if (escapingOn &amp;amp;&amp;amp; c[start] == QUOTE) {
        next(pos);
        return appendTo == null ? null : appendTo.append(QUOTE);
}

</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.text.ExtendedMessageFormatTest.java</file>
			<file type="M">org.apache.commons.lang.text.ExtendedMessageFormat.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">509</link>
		</links>
	</bug>
	<bug id="480" opendate="2009-01-20 17:36:44" fixdate="2009-03-01 20:55:06" resolution="Fixed">
		<buginformation>
			<summary>StringEscapeUtils.escapeHtml incorrectly converts unicode characters above U+00FFFF into 2 characters</summary>
			<description>Characters that are represented as a 2 characters internaly by java are incorrectly converted by the function. The following test displays the problem quite nicely:
import org.apache.commons.lang.*;
public class J2 {
    public static void main(String[] args) throws Exception {
        // this is the utf8 representation of the character:
        // COUNTING ROD UNIT DIGIT THREE
        // in unicode
        // codepoint: U+1D362
        byte[] data = new byte[] 
{ (byte)0xF0, (byte)0x9D, (byte)0x8D, (byte)0xA2 }
;
        //output is: &amp;amp;#55348;&amp;amp;#57186;
        // should be: &amp;amp;#119650;
        System.out.println("&amp;amp;apos;" + StringEscapeUtils.escapeHtml(new String(data, "UTF8")) + "&amp;amp;apos;");
    }
}
Should be very quick to fix, feel free to drop me an email if you want a patch.</description>
			<version>2.4</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.Entities.java</file>
			<file type="M">org.apache.commons.lang.StringEscapeUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="478" opendate="2009-01-09 10:12:28" fixdate="2009-03-01 21:18:29" resolution="Fixed">
		<buginformation>
			<summary>StopWatch does not resist to system time changes</summary>
			<description>org.apache.commons.lang.time.StopWatch seems to be relying on wall clock, i.e. by calling java.lang.System.currentTimeMillis() to sample current time.
When a system time change occurs (user action, NTP synchronization...) between 2 calls to StopWatch.getTime(), the difference between the 2 samples is wrong: the measured duration may noticeably differ from the real one. Moreover, should the system time change consist in a backward adjustment, the difference could be negative.
In order to make StopWatch resistant to system time changes, would it be possible to use the process time, i.e. by making implementation calling java.lang.System.nanoTime() -multiplied by appropriate factor, of course.
Thanks a lot,
Regis.</description>
			<version>2.3</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.time.StopWatch.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">323</link>
		</links>
	</bug>
	<bug id="323" opendate="2007-02-15 09:18:44" fixdate="2009-03-14 09:29:32" resolution="Duplicate">
		<buginformation>
			<summary>StopWatch: increase precision by using System.nanoTime()</summary>
			<description>In Java5, theres a new, more precise way to measure elapsed timespans:
http://java.sun.com/j2se/1.5.0/docs/api/java/lang/System.html#nanoTime()
It will probably break the class contract of the current StopWatch class, as the returned timestamps cannot be transformed to Dates etc., but it will add precision to the stopwatch aspect (as opposed to the timewatch aspect) of the class.
Perhaps the way to go is to introduce a new HighPrecisionStopWatch class.</description>
			<version>2.3</version>
			<fixedVersion></fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.time.StopWatch.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">478</link>
		</links>
	</bug>
	<bug id="509" opendate="2009-06-08 06:57:58" fixdate="2009-06-09 19:13:40" resolution="Duplicate">
		<buginformation>
			<summary>OutOfMemory Error caused by ExtendedMessageFormat</summary>
			<description>It is possible to let ExtendedMessageFormat cause an OutOfMemory Error (Java heap space) - no matter how large you define the memory, because the code produces an endless loop that extends a StringBuffer ad infinitum.
Code to reproduce:
instantiate an ExtendedMessageFormat object using the constructor 
public ExtendedMessageFormat(String pattern, Locale locale, Map registry) 
locale and registry (not null) don&amp;amp;apos;t matter actually, but pattern as String looks like this:
{{The field &amp;amp;apos;&amp;amp;apos;
{0}
&amp;amp;apos;&amp;amp;apos; must be completed}}
notice the doubled single quotes.
The constructor then executes applyPattern(pattern)
In applyPattern, line 158 (that is inside the loop over the pattern length)  appendQuotedString(pattern, pos, stripCustom, true); is called, it is the last statement for that case in the loop. 
In  appendQuotedString, line 422 the quote character gets appended to the return StringBuffer, then return. The problem in fact is, that the pointer (ParsePosition pos) isn&amp;amp;apos;t updated and after return the procedure will check the same character again and again and again. 
Primitive workaround: no use of single quotes in messages as input of ExtendedMessageFormat.
</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.text.ExtendedMessageFormatTest.java</file>
			<file type="M">org.apache.commons.lang.text.ExtendedMessageFormat.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">477</link>
		</links>
	</bug>
	<bug id="66" opendate="2006-01-10 18:18:56" fixdate="2009-07-19 18:30:42" resolution="Fixed">
		<buginformation>
			<summary>[lang] StringEscaper.escapeXml() escapes characters &gt; 0x7f</summary>
			<description>StringEscaper.escapeXml() escapes characters &amp;gt; 0x7f. That&amp;amp;apos;s both undesired and
undocumented.</description>
			<version>2.1</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.StringEscapeUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">448</link>
			<link type="Reference" description="relates to">505</link>
			<link type="Reference" description="relates to">515</link>
			<link type="Reference" description="is related to">339</link>
		</links>
	</bug>
	<bug id="339" opendate="2007-06-10 15:30:53" fixdate="2009-07-19 18:41:12" resolution="Fixed">
		<buginformation>
			<summary>StringEscapeUtils.escapeHtml() escapes multibyte characters like Chinese, Japanese, etc.</summary>
			<description>StringEscapeUtils.escapeHtml() escapes multibyte characters like Chinese, Japanes, etc.</description>
			<version>2.3</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.StringEscapeUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">66</link>
			<link type="Reference" description="relates to">505</link>
			<link type="Reference" description="relates to">515</link>
		</links>
	</bug>
	<bug id="535" opendate="2009-09-22 19:53:54" fixdate="2009-10-15 07:31:51" resolution="Fixed">
		<buginformation>
			<summary>ClassUtils.getShortClassName() will not work with an array;  it seems to add a semicolon to the end.</summary>
			<description>A semicolon is introduced into the class name at the end for all arrays...
String sArray[] = new String[2];
sArray[0] = "mark";
sArray[1] = "is cool";
String simpleString = "chris";
assertEquals("String", ClassUtils.getShortClassName(simpleString, null));
assertEquals("String;", ClassUtils.getShortClassName(sArray, null));</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.ClassUtilsTest.java</file>
			<file type="M">org.apache.commons.lang.ClassUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="432" opendate="2008-04-25 16:02:31" fixdate="2009-10-22 05:47:05" resolution="Fixed">
		<buginformation>
			<summary>Fix case-insensitive string handling</summary>
			<description>String.to*Case() is locale-sensitive, this is usually not intended for case-insensitive comparisions. Please see Common Bug #3 for details.</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.StringUtilsEqualsIndexOfTest.java</file>
			<file type="M">org.apache.commons.lang.StringUtils.java</file>
			<file type="M">org.apache.commons.lang.SystemUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="467" opendate="2008-10-27 09:53:57" fixdate="2009-11-14 10:10:43" resolution="Fixed">
		<buginformation>
			<summary>EqualsBuilder and HashCodeBuilder treat java.math.BigDecimal inconsistantly and break general contract of hashCode</summary>
			<description>A POJO with a BigDecimal field and equals() and hashCode() methods implemented using EqualsBuilder and HashCodeBuilder breaks the general contract of Object.hashCode();
EqualsBuilder treats BigDecimal specially by comparing it using BigDecimal.compareTo() == 0 rather than BigDecimal.equals()
Using BigDecimal.compareTo() ignores the scale of the BigDecimal()
However the append(Object o) method of HashCodeBuilder uses BigDecimal.hashCode() in the case that o is a BigDecimal, which takes the scale into account when generating the hashCode.
The following test case shows the problem!
TestApacheCommonsLangHashCodeBuilder.java

// package declaration and imports not shown
public class TestApacheCommonsLangHashCodeBuilder extends TestCase {
    
    public void testHashCode() {
        MyPojo myPojo1 = new MyPojo(new String("foo"), new BigDecimal("10.2"));
        MyPojo myPojo2 = new MyPojo(new String("foo"), new BigDecimal("10.20"));
        
        // equals method ignores the scale of the big decimal
        // so this test passes
        assertTrue(myPojo1.equals(myPojo2));
        
        // however in the case the equals returns true the
        // hashCode must be the same according to the contract
        // TEST FAILS AT THIS LINE
        assertEquals(myPojo1.hashCode(), myPojo2.hashCode());
    }
    
    private class MyPojo {
        private String name;
        private BigDecimal value;
        
        public MyPojo(String name, BigDecimal value) {
            this.name = name;
            this.value = value;
        }
        
        public String getName() {
            return name;
        }
        public BigDecimal getValue() {
            return value;
        }
        /**
         * equals method implemented using EqualsBuilder 
         * as documented by apache commons
         */
        @Override public boolean equals(Object obj) {
            if(this == obj) {
                return true;
            }
            
            if(!(obj instanceof MyPojo)) {
                return false;
            }
            
            MyPojo other = (MyPojo) obj;
            return new EqualsBuilder()
                .append(name, other.getName())
                .append(value, other.getValue())
                .isEquals();
        }
        
        /**
         * hashCode method implemented using HashCodeBuilder
         * as documented by apache commons
         */
        @Override public int hashCode() {
            HashCodeBuilder hcb = new HashCodeBuilder(17, 31);
            return hcb
                .append(name)
                .append(value)
                .toHashCode();
        }
    }
}


Note that the only reason I haven&amp;amp;apos;t provided a patch is because I could not think of one which I thought was reasonable.
Option 1
Always set the scale to some value and then get the hashCode()
Example change in HashCodeBuilder.append(Object) add the following:


else if (object instanceof BigDecimal) {
	append(((BigDecimal) object).setScale(DEFAULT_BIGDECIMAL_SCALE, RoundingMode.DOWN).hashCode());
}


However what is a reasonable scale for calculating this hashCode? I cannot see a reasonanble scale to choose, that depends on the circumstance
Option 2
stripTrailingZeros() before calculating the hashCode()
Example change in HashCodeBuilder.append(Object) add the following:


else if (object instanceof BigDecimal) {
	append(((BigDecimal) object).stripTrailingZeros().hashCode());
}


The performance of this method under different circumstances is not documented.
Option 3
Document the problem and propose that the client solves the problem.
For example change HashCodeBuilder documentation as follows


/*
 * ...
 * public class Person {
 *   String name;
 *   int age;
 *   boolean smoker;
 *   BigDecimal netWorth;
 *   ...
 *
 *   public int hashCode() {
 *     // you pick a hard-coded, randomly chosen, non-zero, odd number
 *     // ideally different for each class
 *     return new HashCodeBuilder(17, 37).
 *       append(name).
 *       append(age).
 *       append(smoker).
 *       // take special care when using BigDecimal as scale takes 
 *       // is included in the hashCode calculation breaking hashCode contract
 *       // choose a scale which is reasonable for hashCode calculation
 *       append(netWorth == null ? null : netWorth.setScale(2)).
 *       toHashCode();
 *   }
 * }
 * ...
 */

</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.builder.EqualsBuilderTest.java</file>
			<file type="M">org.apache.commons.lang.builder.EqualsBuilder.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">1113</link>
		</links>
	</bug>
	<bug id="552" opendate="2009-11-09 12:40:57" fixdate="2009-12-14 07:51:45" resolution="Fixed">
		<buginformation>
			<summary>StringUtils replaceEach - Bug or Missing Documentation </summary>
			<description>The following Test Case for replaceEach fails with a null pointer exception.
I have expected that all StringUtils methods are "null-friendly"
The use case is that i will stuff Values into the replacementList of which I do not want to check whether they are null.
I admit the use case is not perfect, because it is unclear what happens on the replace.
I outlined three expectations in the test case, of course only one should be met.
If it is decided that none of them should be possible, I propose to update the documentation with what happens when null is passed as replacement string


import static org.junit.Assert.assertEquals;

import org.apache.commons.lang.StringUtils;
import org.junit.Test;


public class StringUtilsTest {

	@Test
	public void replaceEach(){
		String original = "Hello World!";
		String[] searchList = {"Hello", "World"};
		String[] replacementList = {"Greetings", null};
		String result = StringUtils.replaceEach(original, searchList, replacementList);
		assertEquals("Greetings !", result);
		//perhaps this is ok as well
                //assertEquals("Greetings World!", result);
                //or even
		//assertEquals("Greetings null!", result);
	}

	
}

</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="538" opendate="2009-10-16 16:47:39" fixdate="2009-12-17 06:05:11" resolution="Fixed">
		<buginformation>
			<summary>DateFormatUtils.format does not correctly change Calendar TimeZone in certain situations</summary>
			<description>If a Calendar object is constructed in certain ways a call to Calendar.setTimeZone does not correctly change the Calendars fields.  Calling Calenar.getTime() seems to fix this problem.  While this is probably a bug in the JDK, it would be nice if DateFormatUtils was smart enough to detect/resolve this problem.
For example, the following unit test fails:

  public void testFormat_CalendarIsoMsZulu() {
    final String dateTime = "2009-10-16T16:42:16.000Z";

    // more commonly constructed with: cal = new GregorianCalendar(2009, 9, 16, 8, 42, 16)
    // for the unit test to work in any time zone, constructing with GMT-8 rather than default locale time zone
    GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));
    cal.clear();
    cal.set(2009, 9, 16, 8, 42, 16);


    FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd&amp;amp;apos;T&amp;amp;apos;HH:mm:ss.SSS&amp;amp;apos;Z&amp;amp;apos;", TimeZone.getTimeZone("GMT"));
    assertEquals("dateTime", dateTime, format.format(cal));
  }


However, this unit test passes:

  public void testFormat_CalendarIsoMsZulu() {
    final String dateTime = "2009-10-16T16:42:16.000Z";
    GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));
    cal.clear();
    cal.set(2009, 9, 16, 8, 42, 16);
    cal.getTime();

    FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd&amp;amp;apos;T&amp;amp;apos;HH:mm:ss.SSS&amp;amp;apos;Z&amp;amp;apos;", TimeZone.getTimeZone("GMT"));
    assertEquals("dateTime", dateTime, format.format(cal));
  }

</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDateFormat.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateFormatTest.java</file>
		</fixedFiles>
		<links>
			<link type="Cloners" description="is cloned by">916</link>
		</links>
	</bug>
	<bug id="530" opendate="2009-09-08 14:38:38" fixdate="2009-12-17 07:21:50" resolution="Fixed">
		<buginformation>
			<summary>parseDate cannot parse ISO8601 dates produced by FastDateFormat</summary>
			<description>I cannot see why this is failing but here is my code:
   Date parseDate(String dateStr) {
       Date d = null;
       if (dateStr != null &amp;amp;&amp;amp; ! "".equals(dateStr)) {
           try {
               // try to parse the date from ISO8601, general
formats, and RFC-2822
               d = DateUtils.parseDate(dateStr, new String[] 
{

DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern()
                       }
);
           } catch (ParseException e) 
{
               // nothing to do
               log.info("Failed to parse: " + dateStr + ":" + e, e);
               d = null;
           }
       }
       return d;
   }
The string I am sending in to that method was generated like this:
String isoDateStr = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(date);
The exception is:
2009-09-03 13:29:37,644 [399355530@qtp3-2] INFO
search.SOLRSearchService  - Failed to parse:
2009-09-03T13:29:30+01:00:java.text.ParseException: Unable to parse
the date: 2009-09-03T13:29:30+01:00
java.text.ParseException: Unable to parse the date: 2009-09-03T13:29:30+01:00
       at org.apache.commons.lang.time.DateUtils.parseDate(DateUtils.java:285)
       at org.steeple.impl.search.SOLRSearchService.parseDate(SOLRSearchService.java:412)
       at org.steeple.impl.search.SOLRSearchService.execute(SOLRSearchService.java:311)
....
</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.DateUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.time.DateUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">462</link>
		</links>
	</bug>
	<bug id="521" opendate="2009-08-04 22:21:38" fixdate="2009-12-22 08:08:26" resolution="Fixed">
		<buginformation>
			<summary>NumberUtils.isNumber() Should Return True for Valid Number with a Trailing Decimal Place</summary>
			<description>NumberUtils.isNumber() should return true for a valid number ending in a trailing decimal place; e.g., "2." should be considered a number because new BigDecimal("2.") works fine.  This could be done by adding the code below after line 1444, which is the if (chars[i] == &amp;amp;apos;e&amp;amp;apos; || chars[i] == &amp;amp;apos;E&amp;amp;apos;) block.
if (chars[i] == &amp;amp;apos;.&amp;amp;apos;) {
    if (hasDecPoint || hasExp) 
{
        // two decimal points or dec in exponent   
        return false;
    }
    return foundDigit; // single trailing decimal point after non-exponent is ok
}</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.NumberUtils.java</file>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="575" opendate="2009-12-22 09:12:17" fixdate="2010-01-09 11:44:17" resolution="Fixed">
		<buginformation>
			<summary>HashCodeBuilder reflectionAppend creates unnecessary copy of excludeFields</summary>
			<description>See http://svn.apache.org/viewvc/commons/proper/lang/trunk/src/java/org/apache/commons/lang3/builder/HashCodeBuilder.java?view=markup
Please review the implementation for reflectionAppend (lines 174 to 202)...  Specifically, see line 182:


List&amp;lt;String&amp;gt; excludedFieldList = excludeFields != null ? Arrays.asList(excludeFields) : Collections.&amp;lt;String&amp;gt;emptyList();


Note that if you are in the habit of passing in a String array for excluding fields (String[] excludeFields)  which is a best practice when using Hibernate (to skip primary keys (@id) and version fields (@version) that change upon persistence)  EVERY TIME the hashCode is calculated, an ArrayList is being created  generating fodder for the garbage collector.
I thought I might get around this by passing a Collection&amp;lt;String&amp;gt; instead of a String[], but ironically the implementation of the reflectionHashCode(Object object, Collection&amp;lt;String&amp;gt; excludeFields) (see lines 475 to 477), for example, transforms the Collection&amp;lt;String&amp;gt; into a String[] only to have it transformed internally into a temporary ArrayList&amp;lt;String&amp;gt;.
I would expect the implementation to use and read what is submitted, whether that is a String[] or a Collection&amp;lt;String&amp;gt;.  I don&amp;amp;apos;t think it needs to create another copy just to have a convenient contains method.  Efficiency is important, especially in the event of rehashing.</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.builder.CompareToBuilder.java</file>
			<file type="M">org.apache.commons.lang3.builder.EqualsBuilder.java</file>
			<file type="M">org.apache.commons.lang3.builder.HashCodeBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="581" opendate="2010-01-14 07:42:29" fixdate="2010-01-15 03:28:05" resolution="Fixed">
		<buginformation>
			<summary>Javadoc bug in org.apache.commons.lang.StringUtils.removeEndIgnoreCase()</summary>
			<description>the org.apache.commons.lang.StringUtils online document 
http://commons.apache.org/lang/api-release/org/apache/commons/lang/StringUtils.html#removeEndIgnoreCase%28java.lang.String,%20java.lang.String%29
at removeEndIgnoreCase()  description, there is one line 
StringUtils.removeEnd("www.domain.com", ".com.")  = "www.domain.com."
it should be 
StringUtils.removeEnd("www.domain.com", ".com.")  = "www.domain.com"
</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="481" opendate="2009-01-23 19:48:12" fixdate="2010-01-16 08:04:53" resolution="Fixed">
		<buginformation>
			<summary>Possible race-conditions in hashCode of the range classes</summary>
			<description>The hashCode() methods of the range classes look very suspicious to me. The value is lazily initialized, but the calculation is done _on the cached value. With some unlucky timing a caller may get an incomplete hash.
An unlucky sequence of Code could be something like
T1:        if (hashCode == 0) // true
T1:            hashCode = 17;
T2:         if (hashCode == 0) // now false because hashCode was already set to 17
T2:         return hashCode; // return 17
T1:            hashCode = 37 * hashCode...........
where T1 and T2 are different threads accessing the method in parallel and T2 gets the wrong hash "17".
Affected classes are
org.apache.commons.lang.math.DoubleRange
org.apache.commons.lang.math.FloatRange
org.apache.commons.lang.math.IntRange
org.apache.commons.lang.math.LongRange
org.apache.commons.lang.math.NumberRange
org.apache.commons.lang.math.Range
Possible fix: calculate the hash on a temporary variable and finally assign it to the member</description>
			<version>2.4</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.Range.java</file>
			<file type="M">org.apache.commons.lang.math.DoubleRange.java</file>
			<file type="M">org.apache.commons.lang.math.IntRange.java</file>
			<file type="M">org.apache.commons.lang.math.FloatRange.java</file>
			<file type="M">org.apache.commons.lang.math.LongRange.java</file>
			<file type="M">org.apache.commons.lang.math.NumberRange.java</file>
		</fixedFiles>
	</bug>
	<bug id="584" opendate="2010-01-28 18:22:48" fixdate="2010-02-02 23:37:20" resolution="Fixed">
		<buginformation>
			<summary>ExceptionUtils uses mutable lock target</summary>
			<description>ExceptionUtils uses a mutable lock target: both the methods removeCauseMethodName() and addCauseMethodName() take out a lock on CAUSE_METHOD_NAMES but then modify it.
That doesn&amp;amp;apos;t work - locks need to be immutable.
</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.exception.ExceptionUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">369</link>
		</links>
	</bug>
	<bug id="587" opendate="2010-02-05 21:30:56" fixdate="2010-02-05 21:35:08" resolution="Fixed">
		<buginformation>
			<summary>ClassUtils.toClass(Object[]) throws NPE on null array element</summary>
			<description>see summary</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.ClassUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.ClassUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="473" opendate="2008-11-26 16:50:11" fixdate="2010-02-25 20:39:52" resolution="Duplicate">
		<buginformation>
			<summary>StringEscapeUtils.escapeJava () not escaping forward slash correctly.</summary>
			<description>We are trying to escape forward slash using StringEscapeUtils.escapeJava ()  method. The output returned by this method is no longer a valid Java String. 
e.g. 
String s = "a/b/c";
System.out.println(StringEscapeUtils.escapeJava (s));
The output returned is a\/b\/c which is not a even a valid Java String.
This was working fine in 2.0 release of this jar.
</description>
			<version>2.4</version>
			<fixedVersion>2.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.StringEscapeUtils.java</file>
			<file type="M">org.apache.commons.lang.StringEscapeUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">421</link>
		</links>
	</bug>
	<bug id="602" opendate="2010-03-07 09:55:21" fixdate="2010-03-08 22:22:11" resolution="Fixed">
		<buginformation>
			<summary>ContextedRuntimeException no longer an &amp;apos;unchecked&amp;apos; exception</summary>
			<description>The purpose of ContextedRuntimeException was to provide an &amp;amp;apos;unchecked&amp;amp;apos; exception with contexted features.  the fact that it now extends &amp;amp;apos;java.langException&amp;amp;apos; makes it a checked exception identical to ContextedException and doesn&amp;amp;apos;t fulfill its purpose.
Recommend you either just remove ContextedRuntimeException (as it&amp;amp;apos;s now redundant with ContextedException) or revert the change that has it extending java.lang.Exception back so that it extends java.lang.RuntimeException.  I would prefer keeping ContextedRuntimeException and having it extend RuntimeException.
I apologize for not catching this earlier.  I only caught it now in attempt to use ContextedRuntimeException on one of my projects and discovering that it is no longer unchecked.
Thanks for looking at this.</description>
			<version>3.0</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.exception.ContextedRuntimeException.java</file>
		</fixedFiles>
	</bug>
	<bug id="606" opendate="2010-03-13 20:10:02" fixdate="2010-03-20 20:17:03" resolution="Fixed">
		<buginformation>
			<summary>EqualsBuilder causes StackOverflowException</summary>
			<description>EqualsBuilder causes StackOverflowException when comparing objects with cyclical object references.
e,g.
static class TestObjectReference {
		@SuppressWarnings("unused")
		private TestObjectReference reference;
    	@SuppressWarnings("unused")
		private TestObject one;
    	public TestObjectReference(int one) 
{
			this.one = new TestObject(one);
		}

    	public void setObjectReference(
    			TestObjectReference reference) 
{
			this.reference = reference;
		}

		@Override
		public boolean equals(Object obj) 
{
			return EqualsBuilder.reflectionEquals(this, obj);
		}
    }</description>
			<version>2.5</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.builder.EqualsBuilder.java</file>
			<file type="M">org.apache.commons.lang3.builder.EqualsBuilderTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="631" opendate="2010-07-05 09:29:44" fixdate="2010-07-06 07:28:05" resolution="Fixed">
		<buginformation>
			<summary>StringUtils JavaDoc contains erroneous examples</summary>
			<description>For the method: static int 	lastIndexOf(String str, String searchStr) 
@
(v2.5): http://commons.apache.org/lang/api-release/org/apache/commons/lang/StringUtils.html#lastIndexOf(java.lang.String,%20java.lang.String)
(v3.0): http://commons.apache.org/lang/api/org/apache/commons/lang3/StringUtils.html#lastIndexOf(java.lang.String,%20java.lang.String)
These results are wrong:
 StringUtils.lastIndexOf("aabaabaa", "a")  = 0
 StringUtils.lastIndexOf("aabaabaa", "b")  = 2
 StringUtils.lastIndexOf("aabaabaa", "ab") = 1
Correct values:
1st = 7
2nd = 5
3rd = 4</description>
			<version>2.5</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="635" opendate="2010-07-20 10:02:24" fixdate="2010-07-20 18:11:17" resolution="Fixed">
		<buginformation>
			<summary>CompareToBuilder.reflectionCompare(Object lhs, Object rhs, boolean compareTransients, Class reflectUpToClass) ignores third parameter</summary>
			<description>The parameter "compareTransients" is ignored and false is always used, as a short look in the code shows:

    return reflectionCompare(lhs, rhs, false, reflectUpToClass, null);</description>
			<version>2.5</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.builder.CompareToBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="638" opendate="2010-08-02 10:59:38" fixdate="2010-08-03 04:42:18" resolution="Fixed">
		<buginformation>
			<summary>NumberUtils createNumber throws a StringIndexOutOfBoundsException when argument containing "e" and "E" is passed in</summary>
			<description>NumberUtils createNumber throws a StringIndexOutOfBoundsException instead of NumberFormatException when a String containing both possible exponent indicators is passed in.
One example of such a String is "1eE".</description>
			<version>2.5</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.math.NumberUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="643" opendate="2010-08-13 14:52:35" fixdate="2010-08-29 22:39:13" resolution="Fixed">
		<buginformation>
			<summary>Javadoc StringUtils.left() claims to throw on negative len, but doesn&amp;apos;t</summary>
			<description>The Javadoc comment for StringUtils.left() claims to throw an exception "if len is negative" (and that input argument len "must be zero or positive"):
http://commons.apache.org/lang/api/org/apache/commons/lang3/StringUtils.html#left(java.lang.String,%20int)
http://commons.apache.org/lang/api-2.5/org/apache/commons/lang/StringUtils.html#left(java.lang.String,%20int)
public static String left(String str, int len)
    Gets the leftmost len characters of a String.
    If len characters are not available, or the String is null, the String will be returned without an exception. An exception is thrown if len is negative.
     StringUtils.left(null, *)    = null
     StringUtils.left(*, -ve)     = ""
     StringUtils.left("", *)      = ""
     StringUtils.left("abc", 0)   = ""
     StringUtils.left("abc", 2)   = "ab"
     StringUtils.left("abc", 4)   = "abc"
    Parameters:
        str - the String to get the leftmost characters from, may be null
        len - the length of the required String, must be zero or positive
    Returns:
        the leftmost characters, null if null String input
But it  doesn&amp;amp;apos;t. (Luckily and preferably anyway .)
Instead an empty string will be returned. (Which is good.) As is seen from the implementation code ...

........
        if (len &amp;lt; 0) {
            return EMPTY;
        }
        ...

..., and by example, too:

$ cat StringUtilsTest.java
import org.apache.commons.lang.StringUtils;

public final class StringUtilsTest {
    public static void main(final String[] args) {
        final String result = StringUtils.left("foobar", -42);
        System.out.println("&amp;gt;" + result + "&amp;lt;");
    }
}

$ javac -classpath commons-lang.jar StringUtilsTest.java

$ java -classpath .:commons-lang.jar StringUtilsTest
&amp;gt;&amp;lt;

The Javadoc comment should be updated.
Same issue for right() and mid(), by the way.
Volker Glave</description>
			<version>2.5</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="596" opendate="2010-03-01 12:17:48" fixdate="2010-08-29 22:54:57" resolution="Fixed">
		<buginformation>
			<summary>StrSubstitutor should also handle the default properties of a java.util.Properties class</summary>
			<description>The following program show a problem with a shortcoming of the java.util.Properties class. 
The default properties are not substituted by the StrSubstitutor.
StrSubstTest.java

import org.apache.commons.lang.text.StrSubstitutor;

public class StrSubstTest
{
    public static void main(String[] args)
    {
        String org = "${doesnotwork}";
        System.setProperty("doesnotwork", "It work&amp;amp;apos;s!");

        // create a new Poperties object with the System.getProperties as default
        Properties props = new Properties(System.getProperties());

        String subst = StrSubstitutor.replace(org, props);
        // is ${doesnotwork} substituted?
        System.out.println(subst);

    }
}


The following method could be added to the StrSubstitutor class to fix this problem in an easy way:


    /**
     * Replaces all the occurrences of variables in the given source object with their matching
     * values from the properties.
     * 
     * @param source the source text containing the variables to substitute, null returns null
     * @param properties the properties with values, may be null
     * @return the result of the replace operation
     */
    public static String replace(Object source, Properties valueProperties)
    {
        if (valueProperties == null) {
            return source;
        }
        Map valueMap = new HashMap();
        Enumeration propNames = valueProperties.propertyNames();
        while (propNames.hasMoreElements())
        {
            String propName = (String)propNames.nextElement();
            String propValue = valueProperties.getProperty(propName);
            valueMap.put(propName, propValue);
        }
        return StrSubstitutor.replace(source, valueMap);
    }

</description>
			<version>2.5</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.StrSubstitutorTest.java</file>
			<file type="M">org.apache.commons.lang3.text.StrSubstitutor.java</file>
		</fixedFiles>
	</bug>
	<bug id="645" opendate="2010-08-20 14:11:08" fixdate="2010-09-08 06:10:03" resolution="Fixed">
		<buginformation>
			<summary>FastDateFormat.format() outputs incorrect week of year because locale isn&amp;apos;t respected</summary>
			<description>FastDateFormat apparently doesn&amp;amp;apos;t respect the locale it was sent on creation when outputting week in year (e.g. "ww") in format(). It seems to use the settings of the system locale for firstDayOfWeek and minimalDaysInFirstWeek, which (depending on the year) may result in the incorrect week number being output.
Here is a simple test program to demonstrate the problem by comparing with SimpleDateFormat, which gets the week number right:


import java.util.Calendar;
import java.util.Date;
import java.util.Locale;
import java.text.SimpleDateFormat;

import org.apache.commons.lang.time.FastDateFormat;

public class FastDateFormatWeekBugDemo {
    public static void main(String[] args) {
        Locale.setDefault(new Locale("en", "US"));
        Locale locale = new Locale("sv", "SE");

        Calendar cal = Calendar.getInstance(); // setting locale here doesn&amp;amp;apos;t change outcome
        cal.set(2010, 0, 1, 12, 0, 0);
        Date d = cal.getTime();
        System.out.println("Target date: " + d);

        FastDateFormat fdf = FastDateFormat.getInstance("EEEE&amp;amp;apos;, week &amp;amp;apos;ww", locale);
        SimpleDateFormat sdf = new SimpleDateFormat("EEEE&amp;amp;apos;, week &amp;amp;apos;ww", locale);
        System.out.println("FastDateFormat:   " + fdf.format(d)); // will output "FastDateFormat:   fredag, week 01"
        System.out.println("SimpleDateFormat: " + sdf.format(d)); // will output "SimpleDateFormat: fredag, week 53"
    }
}


If sv/SE is passed to Locale.setDefault() instead of en/US, both FastDateFormat and SimpleDateFormat output the correct week number.</description>
			<version>2.5</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDateFormatTest.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="617" opendate="2010-04-13 15:25:28" fixdate="2010-09-17 05:12:00" resolution="Fixed">
		<buginformation>
			<summary>StringEscapeUtils.escapeXML() can&amp;apos;t process UTF-16 supplementary characters</summary>
			<description>Supplementary characters in UTF-16 are those whose code points are above 0xffff, that is, require more than 1 Java char to be encoded, as explained here: http://java.sun.com/developer/technicalArticles/Intl/Supplementary/
Currently, StringEscapeUtils.escapeXML() isn&amp;amp;apos;t aware of this coding scheme and treats each char as one character, which is not always right.
A possible solution in class Entities would be:
    public void escape(Writer writer, String str) throws IOException {
        int len = str.length();
        for (int i = 0; i &amp;lt; len; i++) {
            int code = str.codePointAt;
            String entityName = this.entityName(code);
            if (entityName != null) 
{
                writer.write(&amp;amp;apos;&amp;amp;&amp;amp;apos;);
                writer.write(entityName);
                writer.write(&amp;amp;apos;;&amp;amp;apos;);
            }
 else if (code &amp;gt; 0x7F) 
{
                    writer.write("&amp;amp;#");
                    writer.write(code);
                    writer.write(&amp;amp;apos;;&amp;amp;apos;);
            }
 else 
{
                    writer.write((char) code);
            }

            if (code &amp;gt; 0xffff) 
{
                    i++;
            }
        }
    }
Besides fixing escapeXML(), this will also affect HTML escaping functions. I guess that&amp;amp;apos;s a good thing, but please remember I have only tested escapeXML().</description>
			<version>2.4</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.translate.NumericEntityUnescaper.java</file>
			<file type="M">org.apache.commons.lang3.text.translate.NumericEntityEscaperTest.java</file>
			<file type="M">org.apache.commons.lang3.text.translate.NumericEntityEscaper.java</file>
		</fixedFiles>
	</bug>
	<bug id="656" opendate="2010-11-08 08:55:37" fixdate="2010-11-08 15:20:11" resolution="Fixed">
		<buginformation>
			<summary>Example StringUtils.indexOfAnyBut("zzabyycdxx", &amp;apos;&amp;apos;) = 0 incorrect</summary>
			<description>I recognized the following example in class StringUtils:


      StringUtils.indexOfAnyBut("zzabyycdxx", &amp;amp;apos;&amp;amp;apos;) = 0


According to Niall Pembertons answer on the user mailing list (Oct, 27th 2010) I should report an issue on this.
He suggested the following replacement:

      StringUtils.indexOfAnyBut("zzabyycdxx", "")   = -1


Regards,
Dirk</description>
			<version>2.5</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="658" opendate="2010-11-13 14:31:25" fixdate="2010-11-13 16:52:16" resolution="Fixed">
		<buginformation>
			<summary>Some Entitys like &amp;Ouml; are not matched properly against its ISO8859-1 representation</summary>
			<description>In EntityArrays 
In
 private static final String[][] ISO8859_1_ESCAPE 
some matching is wrong, for example

 
        {"\u00D7", "&amp;amp;Ouml;"}, //  - uppercase O, umlaut
        {"\u00D8", "&amp;amp;times;"}, // multiplication sign


but this must be   

 
       {"\u00D6", "&amp;amp;Ouml;"}, //  - uppercase O, umlaut
        {"\u00D7", "&amp;amp;times;"}, // multiplication sign


according to http://www.fileformat.info/info/unicode/block/latin_supplement/list.htm
First look:
u00CA is missing in the array and all following entries are matched wrong by an offset of 1.
Found on http://stackoverflow.com/questions/4172784/bug-in-apache-commons-stringescapeutil/4172915#4172915</description>
			<version>3.0</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.translate.EntityArrays.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">705</link>
		</links>
	</bug>
	<bug id="659" opendate="2010-11-13 15:54:42" fixdate="2010-11-13 16:54:37" resolution="Fixed">
		<buginformation>
			<summary>EntityArrays typo: {"\u2122", "&amp;minus;"}, // minus sign, U+2212 ISOtech</summary>
			<description>EntityArrays typo in HTML40_EXTENDED_ESCAPE: 

      {"\u2122", "&amp;amp;minus;"}, // minus sign, U+2212 ISOtech


should be

      {"\u2212", "&amp;amp;minus;"}, // minus sign, U+2212 ISOtech


as is obvious from the comment and the position in the list.</description>
			<version>3.0</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.translate.EntityArrays.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">705</link>
		</links>
	</bug>
	<bug id="662" opendate="2010-12-06 22:40:30" fixdate="2011-01-17 04:30:27" resolution="Fixed">
		<buginformation>
			<summary>org.apache.commons.lang3.math.Fraction does not reduce (Integer.MIN_VALUE, 2^k)</summary>
			<description>The greatestCommonDivisor method in class Fraction does not find the gcd of Integer.MIN_VALUE and 2^k, and this case can be triggered by taking Integer.MIN_VALUE as the numerator. Note that the case of taking Integer.MIN_VALUE as the denominator is handled explicitly in the getReducedFraction factory method.
FractionTest.java

	// additional test cases
	public void testReducedFactory_int_int() {
		// ...
		f = Fraction.getReducedFraction(Integer.MIN_VALUE, 2);
		assertEquals(Integer.MIN_VALUE / 2, f.getNumerator());
		assertEquals(1, f.getDenominator());

	public void testReduce() {
		// ...
		f = Fraction.getFraction(Integer.MIN_VALUE, 2);
		result = f.reduce();
		assertEquals(Integer.MIN_VALUE / 2, result.getNumerator());
		assertEquals(1, result.getDenominator());

 </description>
			<version>3.0</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.FractionTest.java</file>
			<file type="M">org.apache.commons.lang3.math.Fraction.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">663</link>
		</links>
	</bug>
	<bug id="646" opendate="2010-08-22 17:46:02" fixdate="2011-01-17 05:35:23" resolution="Fixed">
		<buginformation>
			<summary>StringEscapeUtils.unescapeJava doesn&amp;apos;t handle octal escapes and Unicode with extra u</summary>
			<description>CODE TO REPRODUCE BUG:

System.out.println("\45");
// %
System.out.println(StringEscapeUtils.unescapeJava("\\45"));
// 45, should be %

System.out.println("\uu0030");
// 0
System.out.println(StringEscapeUtils.unescapeJava("\\uu0030"));
// throws NestableRuntimeException:


This is not compliant with the JLS, which allows both [OctalEscape] and extraneous u for [UnicodeMarker] in Java string literal.
REFERENCES:
3.10.6 Escape Sequences for Character and String Literals
http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#3.10.6
3.3 Unicode Escapes
http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#3.3
EXTERNAL LINKS:
http://stackoverflow.com/questions/3537706/howto-unescape-a-java-string-literal-in-java/</description>
			<version>2.5</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringEscapeUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="672" opendate="2011-01-17 15:29:32" fixdate="2011-01-23 05:25:34" resolution="Fixed">
		<buginformation>
			<summary>Doc bug in DateUtils#ceiling</summary>
			<description>
For example, if you had the datetime of 28 Mar 2002
     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar
     * 2002 13:00:00.000.  If this was passed with MONTH, it would
     * return 1 Mar 2002 0:00:00.000. 

Looks like copy-paste from truncate. (the dates are incorrect)</description>
			<version>2.5</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.DateUtils.java</file>
			<file type="M">org.apache.commons.lang3.time.DateUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Cloners" description="is cloned by">800</link>
		</links>
	</bug>
	<bug id="624" opendate="2010-05-27 21:09:29" fixdate="2011-02-01 16:31:42" resolution="Fixed">
		<buginformation>
			<summary>SystemUtils.getJavaVersionAsFloat throws StringIndexOutOfBoundsException on Android runtime/Dalvik VM</summary>
			<description>Can be replicated in the Android emulator quite easily.
Stack trace:


at org.apache.commons.lang.builder.ToStringBuilder.&amp;lt;clinit&amp;gt;(ToStringBuilder.java:98)
E/AndroidRuntime( 1681): 	... 17 more
E/AndroidRuntime( 1681): Caused by: java.lang.ExceptionInInitializerError
E/AndroidRuntime( 1681): 	at org.apache.commons.lang.builder.ToStringStyle$MultiLineToStringStyle.&amp;lt;init&amp;gt;(ToStringStyle.java:2276)
E/AndroidRuntime( 1681): 	at org.apache.commons.lang.builder.ToStringStyle.&amp;lt;clinit&amp;gt;(ToStringStyle.java:94)
E/AndroidRuntime( 1681): 	... 18 more
E/AndroidRuntime( 1681): Caused by: java.lang.StringIndexOutOfBoundsException
E/AndroidRuntime( 1681): 	at java.lang.String.substring(String.java:1571)
E/AndroidRuntime( 1681): 	at org.apache.commons.lang.SystemUtils.getJavaVersionAsFloat(SystemUtils.java:1153)
E/AndroidRuntime( 1681): 	at org.apache.commons.lang.SystemUtils.&amp;lt;clinit&amp;gt;(SystemUtils.java:818)

</description>
			<version>2.5</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.SystemUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.ClassUtils.java</file>
			<file type="M">org.apache.commons.lang3.text.ExtendedMessageFormatTest.java</file>
			<file type="M">org.apache.commons.lang3.time.DateUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.ClassUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.SystemUtils.java</file>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.LocaleUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.CharEncodingTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="428" opendate="2008-04-24 10:28:10" fixdate="2011-03-01 06:32:13" resolution="Fixed">
		<buginformation>
			<summary>StringUtils.isNumeric</summary>
			<description>StringUtils.isNumeric.
if we put empty string as parameter we got true.
StringUtils.isNumeric("") return true.</description>
			<version>2.3</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtilsIsTest.java</file>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="679" opendate="2011-03-02 08:36:57" fixdate="2011-03-03 23:55:30" resolution="Duplicate">
		<buginformation>
			<summary>StringUtils.startsWithIgnoreCase whrong documentation</summary>
			<description>Examples within JavaDoc misleads about parameters - according to examples the string and the prefix misplaced.</description>
			<version>2.4</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang.StringUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">460</link>
		</links>
	</bug>
	<bug id="705" opendate="2011-06-08 15:50:02" fixdate="2011-06-08 16:10:31" resolution="Duplicate">
		<buginformation>
			<summary>StringEscapeUtil generate wrong output for some entities</summary>
			<description>The entities such as "" are not correctly encoded in the org.apache.commons.lang3.text.translate.EntityArrays. E.g. "" is encoded as "00E4" according to the ISO-8859-1 standard, but is assigned to "00E5" in the class EntityArrays.
The consequence is, that StringEscapeUtil can not produce correct output.</description>
			<version>3.0</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.translate.EntityArrays.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">658</link>
			<link type="Duplicate" description="duplicates">659</link>
		</links>
	</bug>
	<bug id="710" opendate="2011-07-01 20:57:30" fixdate="2011-07-09 05:09:46" resolution="Fixed">
		<buginformation>
			<summary>StringIndexOutOfBoundsException when calling unescapeHtml4("&amp;#03")</summary>
			<description>When calling unescapeHtml4() on the String "&amp;amp;#03" (or any String that contains these characters) an Exception is thrown:
Exception in thread "main" java.lang.StringIndexOutOfBoundsException: String index out of range: 4
	at java.lang.String.charAt(String.java:686)
	at org.apache.commons.lang3.text.translate.NumericEntityUnescaper.translate(NumericEntityUnescaper.java:49)
	at org.apache.commons.lang3.text.translate.AggregateTranslator.translate(AggregateTranslator.java:53)
	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:88)
	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:60)
	at org.apache.commons.lang3.StringEscapeUtils.unescapeHtml4(StringEscapeUtils.java:351)</description>
			<version>3.0</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.translate.NumericEntityUnescaperTest.java</file>
			<file type="M">org.apache.commons.lang3.text.translate.NumericEntityUnescaper.java</file>
		</fixedFiles>
	</bug>
	<bug id="719" opendate="2011-07-13 17:00:52" fixdate="2011-07-13 17:02:13" resolution="Fixed">
		<buginformation>
			<summary>FastDateFormat formats year differently than SimpleDateFormat in Java 7</summary>
			<description>Starting with Java 7 does SimpleDateFormat format a year pattern of &amp;amp;apos;Y&amp;amp;apos; or &amp;amp;apos;YYY&amp;amp;apos; as &amp;amp;apos;2003&amp;amp;apos; instead of &amp;amp;apos;03&amp;amp;apos; as in former Java releases. According Javadoc this pattern should have been always been formatted as number, therefore the new behavior seems to be a bug fix in the JDK. FastDateFormat is adjusted to behave the same.</description>
			<version>2.5</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDateFormatTest.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateFormat.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">593</link>
		</links>
	</bug>
	<bug id="720" opendate="2011-07-14 13:24:55" fixdate="2011-07-14 18:50:17" resolution="Fixed">
		<buginformation>
			<summary>StringEscapeUtils.escapeXml(input) outputs wrong results when an input contains characters in Supplementary Planes.</summary>
			<description>Hello.
I use StringEscapeUtils.escapeXml(input) to escape special characters for XML.
This method outputs wrong results when input contains characters in Supplementary Planes.
String str1 = "\uD842\uDFB7" + "A";
String str2 = StringEscapeUtils.escapeXml(str1);
// The value of str2 must be equal to the one of str1,
// because str1 does not contain characters to be escaped.
// However, str2 is diffrent from str1.
System.out.println(URLEncoder.encode(str1, "UTF-16BE")); //%D8%42%DF%B7A
System.out.println(URLEncoder.encode(str2, "UTF-16BE")); //%D8%42%DF%B7%FF%FD
The cause of this problem is that the loop to translate input character by character is wrong.
In CharSequenceTranslator.translate(CharSequence input, Writer out),
loop counter "i" moves from 0 to Character.codePointCount(input, 0, input.length()),
but it should move from 0 to input.length().</description>
			<version>3.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringEscapeUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.text.translate.CharSequenceTranslator.java</file>
		</fixedFiles>
	</bug>
	<bug id="593" opendate="2010-02-21 19:35:01" fixdate="2011-07-19 03:52:56" resolution="Fixed">
		<buginformation>
			<summary>Testing with JDK 1.7</summary>
			<description>I ran the tests for the Lang 2.5 RC2 using JDK 1.7.0-b78 and they all passed except the testFormat() in FastDateFormatTest.
The problem seems to be that in JDK 1.7 the "yyy" and "y" patterns now cause a four digit year with SimpleDateFormat - whereas previous JDK versions resulted in a 2 digit year (as FastDateFormat does).
JDK 1.7 hasn&amp;amp;apos;t yet been released and that may be fixed in the JDK by the time it is, but I thought it worth making a note.</description>
			<version>2.5</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDateFormatTest.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateFormat.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">719</link>
		</links>
	</bug>
	<bug id="728" opendate="2011-07-16 08:09:49" fixdate="2011-07-19 05:10:17" resolution="Fixed">
		<buginformation>
			<summary>StringEscapeUtils.escapeXml(str) does not support supplemental characters.</summary>
			<description>Hello.
StringEscapeUtils.escapeXml(str) escapes Unicode characters greater than 0x7f to their numerical u equivalent:
String str = StringEscapeUtils.escapeXml("\uD84C\uDFB4");
System.out.println(str);
//
But, the output should be .
According to W3C document "Using character escapes in markup and CSS," We must use the single, code point value for supplemental character.
http://www.w3.org/International/questions/qa-escapes
In fact,  is not rendered correctly in some web browsers e.g., Firefox 5.0 and Chrome 12.0.</description>
			<version>2.6</version>
			<fixedVersion>3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringEscapeUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="734" opendate="2011-08-02 17:59:48" fixdate="2011-08-02 18:16:48" resolution="Fixed">
		<buginformation>
			<summary>The CHAR_ARRAY cache in CharUtils duplicates the cache in java.lang.Character</summary>
			<description>The CHAR_ARRAY cache in CharUtils duplicates the cache in java.lang.Character.</description>
			<version>3.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.CharUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="727" opendate="2011-07-15 06:58:19" fixdate="2011-08-06 15:44:14" resolution="Fixed">
		<buginformation>
			<summary>ToStringBuilderTest.testReflectionHierarchyArrayList fails with IBM JDK 6</summary>
			<description>The unit test fails when running with IBM JDK 6:

Failed tests:
testReflectionHierarchyArrayList(org.apache.commons.lang3.builder.ToStringBuilderTest):null
expected:&amp;lt;....ArrayList@115b115b[[elementData={&amp;lt;null&amp;gt;,&amp;lt;null&amp;gt;,&amp;lt;null&amp;gt;,&amp;lt;null&amp;gt;,&amp;lt;null&amp;gt;,&amp;lt;null&amp;gt;,&amp;lt;null&amp;gt;,null&amp;gt;,null&amp;gt;,null&amp;gt;},size=0],modCount=0]&amp;gt;
but was:&amp;lt;....ArrayList@115b115b[[firstIndex=0,lastIndex=0,array={&amp;lt;null&amp;gt;,&amp;lt;null&amp;gt;,&amp;lt;null&amp;gt;,&amp;lt;null&amp;gt;,&amp;lt;null&amp;gt;,&amp;lt;null&amp;gt;,&amp;lt;null&amp;gt;,null&amp;gt;,null&amp;gt;,null&amp;gt;}],modCount=0]&amp;gt;


Actually the test is wrong, because it makes wrong assumptions about the implementation of ArrayList in the runtime.</description>
			<version>3.0</version>
			<fixedVersion>3.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.builder.ToStringBuilderTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="736" opendate="2011-08-02 18:19:53" fixdate="2011-08-16 14:07:08" resolution="Fixed">
		<buginformation>
			<summary>CharUtils static final array CHAR_STRING is not needed to compute CHAR_STRING_ARRAY</summary>
			<description>CharUtils static final array CHAR_STRING is not needed to compute CHAR_STRING_ARRAY.
This:


    private static final String CHAR_STRING = 
        "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007" +
        "\b\t\n\u000b\f\r\u000e\u000f" +
        "\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017" +
        "\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f" +
        "\u0020\u0021\"\u0023\u0024\u0025\u0026\u0027" +
        "\u0028\u0029\u002a\u002b\u002c\u002d\u002e\u002f" +
        "\u0030\u0031\u0032\u0033\u0034\u0035\u0036\u0037" +
        "\u0038\u0039\u003a\u003b\u003c\u003d\u003e\u003f" +
        "\u0040\u0041\u0042\u0043\u0044\u0045\u0046\u0047" +
        "\u0048\u0049\u004a\u004b\u004c\u004d\u004e\u004f" +
        "\u0050\u0051\u0052\u0053\u0054\u0055\u0056\u0057" +
        "\u0058\u0059\u005a\u005b\\\u005d\u005e\u005f" +
        "\u0060\u0061\u0062\u0063\u0064\u0065\u0066\u0067" +
        "\u0068\u0069\u006a\u006b\u006c\u006d\u006e\u006f" +
        "\u0070\u0071\u0072\u0073\u0074\u0075\u0076\u0077" +
        "\u0078\u0079\u007a\u007b\u007c\u007d\u007e\u007f";

// snip

        for (int i = 127; i &amp;gt;= 0; i--) {
            CHAR_STRING_ARRAY[i] = CHAR_STRING.substring(i, i + 1);
        }


Can be recoded as:


        for (char c = 0; c &amp;lt; CHAR_STRING_ARRAY.length; c++) {
            CHAR_STRING_ARRAY[c] = String.valueOf(c);
        }


With the lang 3.0 code, using the Oracle Java 5 String impl, the 128 Strings share the underlying CHAR_STRING char[] because of the way Sun implemented String#substring(int,int).
The proposed implementation does not reply on this private implementation detail but creates one char[1] array per String. 
Thoughts?</description>
			<version>3.0</version>
			<fixedVersion>3.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.CharUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="746" opendate="2011-08-23 12:32:12" fixdate="2011-08-23 12:33:42" resolution="Fixed">
		<buginformation>
			<summary>NumberUtils does not handle upper-case hex: 0X and -0X</summary>
			<description>NumberUtils.createNumber() should work equally for 0x1234 and 0X1234; currently 0X1234 generates a NumberFormatException
Integer.decode() handles both upper and lower case hex.</description>
			<version>3.0</version>
			<fixedVersion>3.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.math.NumberUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="744" opendate="2011-08-22 10:41:12" fixdate="2011-10-10 02:22:20" resolution="Fixed">
		<buginformation>
			<summary>StringUtils throws java.security.AccessControlException on Google App Engine</summary>
			<description>In the static initializer of org.apache.commons.lang3.StringUtils, there is an attempt to load the class sun.text.Normalizer.
Such a class is prohibited on Google App Engine, and the static intializer throws a java.security.AccessControlException.


Caused by: java.security.AccessControlException: access denied (java.lang.RuntimePermission accessClassInPackage.sun.text)
	at java.security.AccessControlContext.checkPermission(AccessControlContext.java:374)
	at java.security.AccessController.checkPermission(AccessController.java:546)
	at java.lang.SecurityManager.checkPermission(SecurityManager.java:532)
	at com.google.appengine.tools.development.DevAppServerFactory$CustomSecurityManager.checkPermission(DevAppServerFactory.java:166)
	at java.lang.SecurityManager.checkPackageAccess(SecurityManager.java:1512)
	at java.lang.Class.checkMemberAccess(Class.java:2164)
	at java.lang.Class.getMethod(Class.java:1602)
	at org.apache.commons.lang3.StringUtils.&amp;lt;clinit&amp;gt;(StringUtils.java:739)


The exception should be caught in the catch clauses around loadClass("sun.text.Normalizer").
Commons lang 2 worked fine on GAE.</description>
			<version>3.0.1</version>
			<fixedVersion>3.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="772" opendate="2011-11-15 12:37:17" fixdate="2011-11-16 03:14:41" resolution="Fixed">
		<buginformation>
			<summary>ClassUtils.PACKAGE_SEPARATOR javadoc contains garbage text</summary>
			<description>javadoc description of ClassUtils.PACKAGE_SEPARATOR is as follows:
The package separator String: "&amp;amp;#x2e;".
It should be something like the following:
The package separator String: ".".</description>
			<version>3.0.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.ClassUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="773" opendate="2011-11-16 13:03:08" fixdate="2011-11-16 13:44:27" resolution="Fixed">
		<buginformation>
			<summary>ImmutablePair doc contains nonsense text</summary>
			<description>Description of this class contains the following nonsense text:
#ThreadSafe# if the objects are threadsafe</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.tuple.ImmutablePair.java</file>
		</fixedFiles>
	</bug>
	<bug id="775" opendate="2011-11-17 23:38:26" fixdate="2011-11-18 00:02:15" resolution="Fixed">
		<buginformation>
			<summary>TypeUtils.getTypeArguments() misses type arguments for partially-assigned classes</summary>
			<description>failing test code to add to TypeUtilsTest.testGetTypeArguments():


typeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class);
Assert.assertEquals(2, typeVarAssigns.size());
Assert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0]));
Assert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1]));


These should pass based on:



public interface This&amp;lt;K, V&amp;gt; {
}

public class Other&amp;lt;T&amp;gt; implements This&amp;lt;String, T&amp;gt; {
}


This case fails because the current code ignores the Other class due to its specifying its own type variables, which is obviously incorrect.  This report is extrapolated from an offline report received by Hen.</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.reflect.TypeUtils.java</file>
			<file type="M">org.apache.commons.lang3.reflect.TypeUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">776</link>
		</links>
	</bug>
	<bug id="776" opendate="2011-11-17 23:55:21" fixdate="2011-11-18 00:02:32" resolution="Fixed">
		<buginformation>
			<summary>TypeUtilsTest contains incorrect type assignability assertion due to lost/skipped type variable information during the decision process</summary>
			<description>TypeUtilsTest originally contained the following under #testIsAssignable():


Assert.assertTrue("WRONG!", TypeUtils.isAssignable(dingType, disType));


For background:


public interface This&amp;lt;K, V&amp;gt; {
}

public class Other&amp;lt;T&amp;gt; implements This&amp;lt;String, T&amp;gt; {
}

public class Thing&amp;lt;Q&amp;gt; extends Other&amp;lt;B&amp;gt; {
}


&amp;lt;B&amp;gt; refers to a type parameter on the TypeUtilsTest class itself.
disType and dingType refer to the generic types of the following fields, respectively:


public This&amp;lt;String, String&amp;gt; dis;
public Thing ding;


Thus the assertion in question declares that type Thing is assignable to This&amp;lt;String, String&amp;gt;.  If we start at This we can see that the implementing class Other maps its T type parameter to the V type parameter of This.  From this point we can proceed down to Thing and see that it maps the B type parameter of the enclosing TypeUtilsTest class to the T type parameter of Other.  Thus it is fairly obvious that only a TypeUtilsTest&amp;lt;String&amp;gt;.Thing is assignable to This&amp;lt;String, String&amp;gt;.  From this we can determine that the intent of the message in the original test assertion must indeed have been to flag an incorrect assertion.  This is the associated bug report.</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.reflect.TypeUtils.java</file>
			<file type="M">org.apache.commons.lang3.reflect.TypeUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">775</link>
		</links>
	</bug>
	<bug id="783" opendate="2011-12-16 08:38:25" fixdate="2011-12-28 05:58:37" resolution="Fixed">
		<buginformation>
			<summary>Documentation bug: StringUtils.split</summary>
			<description>The documentation for StringUtils.split(String, String, int) contains wrong strings:
StringUtils.split("ab de fg", null, 0)   = ["ab", "cd", "ef"]
StringUtils.split("ab   de fg", null, 0) = ["ab", "cd", "ef"]
This should read:
StringUtils.split("ab cd ef", null, 0)   = ["ab", "cd", "ef"]
StringUtils.split("ab   cd ef", null, 0) = ["ab", "cd", "ef"]</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="764" opendate="2011-11-09 12:26:40" fixdate="2011-12-28 06:33:45" resolution="Fixed">
		<buginformation>
			<summary>StrBuilder has a serialVersionUID but is not serializable - this is inconsistent</summary>
			<description>StrBuilder has a serialVersionUID but is not serializable.
Is StrBuilder supposed to be Serializable?
If so, then add the interface; if not remove the field.</description>
			<version>3.0.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.StrBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="788" opendate="2012-02-11 12:36:48" fixdate="2012-02-29 14:39:49" resolution="Fixed">
		<buginformation>
			<summary>SerializationUtils throws ClassNotFoundException when cloning primitive classes</summary>
			<description>If a serializable object contains a reference to a primitive class, e.g. int.class or int[].class, the SerializationUtils throw a ClassNotFoundException when trying to clone that object.

import org.apache.commons.lang3.SerializationUtils;
import org.junit.Test;


public class SerializationUtilsTest {

	
	@Test
	public void primitiveTypeClassSerialization(){
		Class&amp;lt;?&amp;gt; primitiveType = int.class;
		
		Class&amp;lt;?&amp;gt; clone = SerializationUtils.clone(primitiveType);
		assertEquals(primitiveType, clone);
	}
}


The problem was already reported as a java bug http://bugs.sun.com/view_bug.do?bug_id=4171142 and ObjectInputStream is fixed since java version 1.4.
The SerializationUtils problem arises because the SerializationUtils internally use the ClassLoaderAwareObjectInputStream that overrides the ObjectInputStream&amp;amp;apos;s
resoleClass method without delegating to the super method in case of a ClassNotFoundException.
I understand the intention of the ClassLoaderAwareObjectInputStream, but this implementation should also implement a fallback to the original implementation.
For example:

        protected Class&amp;lt;?&amp;gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {
            String name = desc.getName();
            try {
                return Class.forName(name, false, classLoader);
            } catch (ClassNotFoundException ex) {
            	try {
            	     return Class.forName(name, false, Thread.currentThread().getContextClassLoader());
            	} catch (Exception e) {
		     return super.resolveClass(desc);
		}
            }
        }


Here is the code in ObjectInputStream that fixed the java bug.

    protected Class&amp;lt;?&amp;gt; resolveClass(ObjectStreamClass desc)
	throws IOException, ClassNotFoundException
    {
	String name = desc.getName();
	try {
	    return Class.forName(name, false, latestUserDefinedLoader());
	} catch (ClassNotFoundException ex) {
	    Class cl = (Class) primClasses.get(name);
	    if (cl != null) {
		return cl;
	    } else {
		throw ex;
	    }
	}
    }

</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.SerializationUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.SerializationUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="800" opendate="2012-04-18 05:10:12" fixdate="2012-04-24 12:56:54" resolution="Fixed">
		<buginformation>
			<summary>Javadoc bug in DateUtils#ceiling for Calendar and Object versions.</summary>
			<description>The documentation has only been corrected for the ceiling method that takes a Date, but not for those that take a Calendar or an Object, respectively.

For example, if you had the datetime of 28 Mar 2002
     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar
     * 2002 13:00:00.000.  If this was passed with MONTH, it would
     * return 1 Mar 2002 0:00:00.000. 

Looks like copy-paste from truncate. (the dates are incorrect)</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.DateUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Cloners" description="is a clone of">672</link>
		</links>
	</bug>
	<bug id="802" opendate="2012-05-25 10:18:08" fixdate="2012-05-25 14:40:09" resolution="Fixed">
		<buginformation>
			<summary>LocaleUtils - unnecessary recursive call in SyncAvoid class</summary>
			<description>The SyncAvoid class calls availableLocaleList() which is a method in the containing class that returns SyncAvoid.AVAILABLE_LOCALE_LIST.
This is unnecessarily complex. The code should use the local variable "list" instead.</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.LocaleUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="805" opendate="2012-06-09 13:46:34" fixdate="2012-06-09 15:06:42" resolution="Fixed">
		<buginformation>
			<summary>RandomStringUtils.random(count, 0, 0, false, false, universe, random) always throws java.lang.ArrayIndexOutOfBoundsException</summary>
			<description>In commons-lang 2.6 line 250 :

ch = chars[random.nextInt(gap) + start];

This line of code takes a random int to fetch a char in the chars array regardless of its size.
(Besides start is useless here)
Fixed version would be :

//ch = chars[random.nextInt(gap)%chars.length];

When user pass 0 as end or when the array is not null but empty this line ends up with an exception</description>
			<version>2.5</version>
			<fixedVersion>3.2, 2.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.RandomStringUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.RandomStringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="807" opendate="2012-06-10 12:11:51" fixdate="2012-06-10 12:41:58" resolution="Fixed">
		<buginformation>
			<summary>RandomStringUtils throws confusing IAE when end &lt;= start</summary>
			<description>RandomUtils invokes Random#nextInt where n = end - start.
If end &amp;lt;= start, then Random throws:
java.lang.IllegalArgumentException: n must be positive
This is confusing, and does not identify the source of the problem.</description>
			<version>2.6</version>
			<fixedVersion>3.2, 2.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.RandomStringUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.RandomStringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="813" opendate="2012-07-14 00:15:04" fixdate="2012-07-14 00:54:12" resolution="Fixed">
		<buginformation>
			<summary>StringUtils.equalsIgnoreCase doesn&amp;apos;t check string reference equality</summary>
			<description>This looks like a regression from .lang versions prior to 3. If the 2 given CharSequences are strings (and both not null) you should check reference equality before delegating to regionMatches()</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="814" opendate="2012-08-03 17:16:57" fixdate="2012-08-03 17:44:39" resolution="Fixed">
		<buginformation>
			<summary>[Method|Constructor]Utils.invoke*(*, Object... args) variants cannot handle null values</summary>
			<description>throws NPE</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.reflect.ConstructorUtils.java</file>
			<file type="M">org.apache.commons.lang3.reflect.ConstructorUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.reflect.MethodUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.reflect.MethodUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="817" opendate="2012-09-04 15:09:22" fixdate="2012-09-04 15:11:38" resolution="Fixed">
		<buginformation>
			<summary>Add org.apache.commons.lang3.SystemUtils.IS_OS_WINDOWS_8</summary>
			<description>Add org.apache.commons.lang3.SystemUtils.IS_OS_WINDOWS_8 to check for version "6.2".</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.SystemUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="810" opendate="2012-07-07 02:06:06" fixdate="2012-09-12 21:54:18" resolution="Fixed">
		<buginformation>
			<summary>StringUtils.join() endIndex, bugged for loop</summary>
			<description>endIndex is described as index, but for loop still checks it as "array length".
Basically missing equal sign
commons-lang3-3.1-sources.jar, StringUtils.java lines 3309, 3394:
        for (int i = startIndex; i &amp;lt; endIndex; i++) {
should be:
        for (int i = startIndex; i &amp;lt;= endIndex; i++) {
</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="799" opendate="2012-04-12 21:45:37" fixdate="2012-09-22 13:24:57" resolution="Fixed">
		<buginformation>
			<summary>DateUtils#parseDate uses default locale; add Locale support</summary>
			<description>Similar issue as https://issues.apache.org/jira/browse/HTTPCLIENT-471
Following line throws an ParseException on a German system:
d = DateUtils.parseDate("Wed, 09 Apr 2008 23:55:38 GMT", new String[] 
{"EEE, dd MMM yyyy HH:mm:ss zzz"}
);
Reason: parseDate internally calls SimpleDateFormat without providing a locale. This causes "MMM" to be interpreted using the system locale. If the system is German, the date is trying to be interpreted as German date.
I see following solutions:
 A) Always instantiate SimpleDateFormat with Locale.ENGLISH
 B) Make two instances of SimpleDateFormat. One without providing a locale and one with Locale.ENGLISH. Try two parsings
 C) Make as many SimpleDateFormat instances as locales are availble iterate over all instances at the parsing attempts.
 D) provide an additional (optional) parameter to parseDate for providing a Locale
I would prefer B) as this seems the best trade-off between internationalization and local usage.
What do you think?</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.DateUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.time.DateUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">1202</link>
		</links>
	</bug>
	<bug id="826" opendate="2012-09-25 01:03:19" fixdate="2012-09-25 01:08:06" resolution="Fixed">
		<buginformation>
			<summary>FastDateParser does not handle non-ASCII digits correctly</summary>
			<description>The FastDateParser class assumes that all numbers are ascii digits.
However, that is not the case for some locales such as
ja_JP_JP, hi_IN, th_TH, and th_TH_TH
Rather than using "\d", the code needs to match using "\p
{IsNd}
" which is the Unicode class for numeric digits.</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDateParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="828" opendate="2012-09-25 16:24:16" fixdate="2012-09-26 18:04:51" resolution="Fixed">
		<buginformation>
			<summary>FastDateParser does not handle non-Gregorian calendars properly</summary>
			<description>The following calendars are non-Gregorian [1]:
ja_JP_JP - Japanese Imperial)
th_TH (with any variant) - Thai Buddhist
This causes errors when testing round-trip conversions.
The simplest solution is to fall back to SimpleDateFormat for these calendars.
[1] http://docs.oracle.com/javase/6/docs/technotes/guides/intl/calendar.doc.html</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDateParser.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateParserTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="838" opendate="2012-09-28 22:38:31" fixdate="2012-09-28 23:33:21" resolution="Fixed">
		<buginformation>
			<summary>ArrayUtils removeElements methods clone temporary index arrays unnecessarily</summary>
			<description>The private method removeAll(Object array, int... indices) sorts the indices array, so arrays passed in by application code need to be cloned first.
However, where the index array is generated locally, that is unnecessary.
The removeElements() methods currently call the public removeAll(&amp;lt;type&amp;gt;[] array, int... indices) methods, which clone the indices before calling the private removeAll() method.
The removeElements() methods should call the private method directly, avoiding the unnecessary clone call.</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.ArrayUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="849" opendate="2012-11-06 01:49:14" fixdate="2012-11-06 02:00:18" resolution="Fixed">
		<buginformation>
			<summary>FastDateFormat and FastDatePrinter generates Date objects wastefully</summary>
			<description>The code:
    @Override
    public String format(long millis) 
{
        return format(new Date(millis));
    }

should be:
    @Override
    public String format(long millis) 
{
        return printer.format(millis);
    }

There is no need to create the extra Date object.</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinter.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateFormat.java</file>
		</fixedFiles>
	</bug>
	<bug id="822" opendate="2012-09-12 21:22:47" fixdate="2012-11-11 13:18:53" resolution="Fixed">
		<buginformation>
			<summary>NumberUtils#createNumber - bad behaviour for leading "--"</summary>
			<description>NumberUtils#createNumber checks for a leading "--" in the string, and returns null if found. This is documented as a work round for a bug in BigDecimal.
Returning nulll is contrary to the Javadoc and the behaviour for other methods which would throw NumberFormatException.
It&amp;amp;apos;s not clear whether the BigDecimal problem still exists with recent versions of Java. However, if it does exist, then the check needs to be done for all invocations of BigDecimal, i.e. needs to be moved to createBigDecimal.</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.math.NumberUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="857" opendate="2012-11-20 12:36:14" fixdate="2012-11-20 20:47:52" resolution="Fixed">
		<buginformation>
			<summary>StringIndexOutOfBoundsException in CharSequenceTranslator</summary>
			<description>I found that there is bad surrogate pair handling in the CharSequenceTranslator
This is a simple test case for this problem.
\uD83D\uDE30 is a surrogate pair.


@Test
public void testEscapeSurrogatePairs() throws Exception {
    assertEquals("\uD83D\uDE30", StringEscapeUtils.escapeCsv("\uD83D\uDE30"));
}


You&amp;amp;apos;ll get the exception as shown below.


java.lang.StringIndexOutOfBoundsException: String index out of range: 2
	at java.lang.String.charAt(String.java:658)
	at java.lang.Character.codePointAt(Character.java:4668)
	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95)
	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59)
	at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)


Patch attached, the method affected:

public final void translate(CharSequence input, Writer out) throws IOException

</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.translate.CharSequenceTranslator.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">862</link>
		</links>
	</bug>
	<bug id="865" opendate="2013-01-03 01:38:59" fixdate="2013-01-03 06:20:30" resolution="Fixed">
		<buginformation>
			<summary>LocaleUtils.toLocale does not parse strings starting with an underscore</summary>
			<description>Hi,
Javadocs of Locale.toString() states that "If the language is missing, the string will begin with an underbar.". This is not handled in the LocaleUtils.toLocale method if it is meant to be the inversion method of Locale.toString().
The fix for the ticket 328 does not handle well the case "fr__P", which I found out during fixing the first bug.
I am attaching the patch for both problems.</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.LocaleUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.LocaleUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="881" opendate="2013-03-27 08:43:48" fixdate="2013-03-27 16:31:48" resolution="Fixed">
		<buginformation>
			<summary> NumberUtils.createNumber() Javadoc says it does not work for octal numbers</summary>
			<description>The javadoc for NumberUtils.createNumber() states:
"Values with leading 0&amp;amp;apos;s will not be interpreted as octal."
However,
assertEquals(25, NumberUtils.createNumber("0025"));
fails, because NumberUtils.createNumber("0025") returns 21.</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.NumberUtils.java</file>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="754" opendate="2011-09-19 12:46:07" fixdate="2013-04-20 15:18:47" resolution="Fixed">
		<buginformation>
			<summary>embedded objects are not toString-ed like top-level objects</summary>
			<description>I have a simple class &amp;amp;apos;A&amp;amp;apos; defined as follows:
======================================
public class A 
{
  int p1;
  String p2;
  B b;
}
======================================
While I execute the following instructions:
ToStringBuilder builder = new ReflectionToStringBuilder(a);
System.out.println(builder.toString());
The output is:
A@3ea981ca[p1=0,p2=&amp;lt;null&amp;gt;,b=B@1ee7b241]
that&amp;amp;apos;s normal, without recursion
So, I defined my own style, for recursive toString-ing display:
======================================
class MyStyle extends ToStringStyle {
  private final static ToStringStyle instance = new MyStyle();
  public MyStyle() 
{
    setArrayContentDetail(true);
    setUseShortClassName(true);
    setUseClassName(true);
    setUseIdentityHashCode(true);
    setFieldSeparator(", ");
  }

  public static ToStringStyle getInstance() 
{
    return instance;
  }
;
  @Override
  public void appendDetail(final StringBuffer buffer, final String fieldName, final Object value) {
    if (!value.getClass().getName().startsWith("java")) 
{
      buffer.append(ReflectionToStringBuilder.toString(value, instance));
    }
 else 
{
      super.appendDetail(buffer, fieldName, value);
    }
  }
  @Override
  public void appendDetail(final StringBuffer buffer, final String fieldName, final Collection value) 
{
    appendDetail(buffer, fieldName, value.toArray());
  }

}
======================================
When I use my custom MyStyle:
String s = ReflectionToStringBuilder.toString(a, MyStyle.getInstance());
System.out.println(s);
The output is:
A@3ea981ca[p1=0, p2=&amp;lt;null&amp;gt;, b=byte@1ee7b241[p4=234]]
So, the name of the class &amp;amp;apos;B&amp;amp;apos; is not displayed.
I expected something like: b=B@1ee7b241[p4=234]
Instead, the name of the class &amp;amp;apos;B&amp;amp;apos; is replaced with &amp;amp;apos;byte&amp;amp;apos;.
I don&amp;amp;apos;t know why.</description>
			<version>2.5</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.ClassUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="882" opendate="2013-03-28 16:25:26" fixdate="2013-04-23 06:03:28" resolution="Fixed">
		<buginformation>
			<summary>LookupTranslator accepts CharSequence as input, but fails to work with implementations other than String</summary>
			<description>The core of org.apache.commons.lang3.text.translate is a HashMap&amp;lt;CharSequence, CharSequence&amp;gt; lookupMap.
From the Javadoc of CharSequence (emphasis mine):

This interface does not refine the general contracts of the equals and hashCode methods. The result of comparing two objects that implement CharSequence is therefore, in general, undefined. Each object may be implemented by a different class, and there is no guarantee that each class will be capable of testing its instances for equality with those of the other. It is therefore inappropriate to use arbitrary CharSequence instances as elements in a set or as keys in a map.
The current implementation causes code such as the following to not work as expected:


CharSequence cs1 = "1 &amp;lt; 2";
CharSequence cs2 = CharBuffer.wrap("1 &amp;lt; 2".toCharArray());

System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs1));
System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs2));


... which gives the following results (but should be identical):

1 &amp;amp;lt; 2
1 &amp;lt; 2


The problem, at a minimum, is that CharBuffer.equals is even documented in the Javadoc that:

A char buffer is not equal to any other type of object.
... so a lookup on a CharBuffer in the Map will always fail when compared against the String implementations that it contains.
An obvious work-around is to instead use something along the lines of either of the following:


System.out.println(StringEscapeUtils.ESCAPE_HTML4.translate(cs2.toString()));
System.out.println(StringEscapeUtils.escapeHtml4(cs2.toString()));


... which forces everything back to a String.  However, this is not practical when working with large sets of data, which would require significant heap allocations and garbage collection concerns.  (As such, I was actually trying to use the translate method that outputs to a Writer - but simplified the above examples to omit this.)
Another option that I&amp;amp;apos;m considering is to use a custom CharSequence wrapper around a char[] that implements hashCode() and equals() to work with those implemented on String.  (However, this will be interesting due to the symmetric assumption - which is further interesting that String.equals is currently implemented using instanceof - even though String is final...)</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.translate.LookupTranslatorTest.java</file>
			<file type="M">org.apache.commons.lang3.text.translate.LookupTranslator.java</file>
		</fixedFiles>
	</bug>
	<bug id="862" opendate="2012-12-10 12:04:44" fixdate="2013-05-16 21:35:38" resolution="Duplicate">
		<buginformation>
			<summary>CharSequenceTranslator causes StringIndexOutOfBoundsException during translation of unicode codepoints with length &gt; 1 character</summary>
			<description>When translating a string with unicode characters in, I&amp;amp;apos;ve encountered an index exception:


	java.lang.StringIndexOutOfBoundsException: String index out of range: 50
	at java.lang.String.charAt(String.java:686)
	at java.lang.Character.codePointAt(Character.java:2335)
	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:95)
	at org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequenceTranslator.java:59)
	at org.apache.commons.lang3.StringEscapeUtils.escapeCsv(StringEscapeUtils.java:556)
	...


The input string was from a twitter status:
org.apache.commons.lang3.StringEscapeUtils.escapeCsv("pink &amp;amp; black adidas suit for this rainy weather \ud83d\udc4d");
Both those characters are &amp;amp;apos;Invalid&amp;amp;apos; unicode characters, so presumably there is a conversion error somewhere. However, this shouldn&amp;amp;apos;t cause the translator to crash.
At line 94, the loop which generates the exception increments the position by the size of the codepoint, which seems to grow faster than the number of characters. I don&amp;amp;apos;t really know how codepoints work, but it looks to me like there are two indexes which are treated as if they are the same one by this loop:

pt is incrementing by one character each iteration
pos is incrementing by one or more characters each iteration
pos is being used to index into the character array
pt is the value actually being tested in the loop test, so pos can be bigger than pt, causing an index problem at the end of the array

My guess would be that the loop should read something like:


            for (int pt = 0; pt &amp;lt; consumed;) {
                int count = Character.charCount(Character.codePointAt(input, pos));
                pt += count;
                pos += count;
            }


I&amp;amp;apos;m not sure if that was the intention, hope it makes some sense!
Stepping through that code with the input string " \ud83d\udc4d":

the input string becomes " \ud83d\udc4d\u008d" (appended &amp;amp;apos;Reverse Line Feed&amp;amp;apos; - no idea why)
consumed == 4
Iterating the loop gives pt=0, pos=0 -&amp;gt; pt=1, pos=1 -&amp;gt; pt=2, pos=3 -&amp;gt; pt-3, pos=4 (Index exception)

So \ud83d\udc4d seems to be a codepoint with a width of 2, which puts the index off by one after that.
Anyway, hope that helps,
Regards,
Mike.</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.translate.CharSequenceTranslator.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">857</link>
		</links>
	</bug>
	<bug id="693" opendate="2011-04-13 09:04:54" fixdate="2013-05-19 10:37:07" resolution="Fixed">
		<buginformation>
			<summary>Method createNumber from NumberUtils doesn&amp;apos;t work for floating point numbers other than Float</summary>
			<description>Method createNumber from NumberUtils is trying to parse a string with a floating point number always first as a Float, that will cause that if we send a string with a number that will need a Double or even a BigDecimal the number will be truncate to accommodate into the Float without an exception to be thrown, so in fact we will no be returning ever neither a Double nor a BigDecimal.</description>
			<version>2.6</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.math.NumberUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="879" opendate="2013-03-18 21:46:29" fixdate="2013-05-30 22:13:22" resolution="Fixed">
		<buginformation>
			<summary>LocaleUtils test fails with new Locale "ja_JP_JP_#u-ca-japanese" of JDK7</summary>
			<description>The Test below fails with the following error on JDK7, but succeeds on JDK6:
testAllLocales
"java.lang.AssertionError: 
Expected: &amp;lt;ja_JP_JP_#u-ca-japanese&amp;gt;
     but: was &amp;lt;ja_JP_JP_#u-ca-japanese&amp;gt;
	at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)
	at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:8)
	at com.scispike.foundation.test.unit.i18n.LocaleStringConverterTest.testStringToLocale(LocaleStringConverterTest.java:20)
	at com.scispike.foundation.test.unit.i18n.LocaleStringConverterTest.testAllLocales(LocaleStringConverterTest.java:28)
	at org.apache.maven.surefire.testng.TestNGExecutor.run(TestNGExecutor.java:76)
	at org.apache.maven.surefire.testng.TestNGDirectoryTestSuite.executeMulti(TestNGDirectoryTestSuite.java:161)
	at org.apache.maven.surefire.testng.TestNGDirectoryTestSuite.execute(TestNGDirectoryTestSuite.java:101)
	at org.apache.maven.surefire.testng.TestNGProvider.invoke(TestNGProvider.java:115)
	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)
	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)
	at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:103)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:74)
... Removed 25 stack frames
 java.lang.AssertionError: 
Expected: &amp;lt;ja_JP_JP_#u-ca-japanese&amp;gt;
     but: was &amp;lt;ja_JP_JP_#u-ca-japanese&amp;gt;
	at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)
	at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:8)
	at com.scispike.foundation.test.unit.i18n.LocaleStringConverterTest.testStringToLocale(LocaleStringConverterTest.java:20)
	at com.scispike.foundation.test.unit.i18n.LocaleStringConverterTest.testAllLocales(LocaleStringConverterTest.java:28)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.testng.internal.MethodInvocationHelper.invokeMethod(MethodInvocationHelper.java:80)
	at org.testng.internal.Invoker.invokeMethod(Invoker.java:715)
	at org.testng.internal.Invoker.invokeTestMethod(Invoker.java:907)
	at org.testng.internal.Invoker.invokeTestMethods(Invoker.java:1237)
	at org.testng.internal.TestMethodWorker.invokeTestMethods(TestMethodWorker.java:127)
	at org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:111)
	at org.testng.TestRunner.privateRun(TestRunner.java:767)
	at org.testng.TestRunner.run(TestRunner.java:617)
	at org.testng.SuiteRunner.runTest(SuiteRunner.java:334)
	at org.testng.SuiteRunner.runSequentially(SuiteRunner.java:329)
	at org.testng.SuiteRunner.privateRun(SuiteRunner.java:291)
	at org.testng.SuiteRunner.run(SuiteRunner.java:240)
	at org.testng.SuiteRunnerWorker.runSuite(SuiteRunnerWorker.java:51)
	at org.testng.SuiteRunnerWorker.run(SuiteRunnerWorker.java:85)
	at org.testng.TestNG.runSuitesSequentially(TestNG.java:1197)
	at org.testng.TestNG.runSuitesLocally(TestNG.java:1122)
	at org.testng.TestNG.run(TestNG.java:1030)
	at org.apache.maven.surefire.testng.TestNGExecutor.run(TestNGExecutor.java:76)
	at org.apache.maven.surefire.testng.TestNGDirectoryTestSuite.executeMulti(TestNGDirectoryTestSuite.java:161)
	at org.apache.maven.surefire.testng.TestNGDirectoryTestSuite.execute(TestNGDirectoryTestSuite.java:101)
	at org.apache.maven.surefire.testng.TestNGProvider.invoke(TestNGProvider.java:115)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)
	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)
	at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:103)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:74)
"
org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)
org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:8)
com.scispike.foundation.test.unit.i18n.LocaleStringConverterTest.testStringToLocale(LocaleStringConverterTest.java:20)
com.scispike.foundation.test.unit.i18n.LocaleStringConverterTest.testAllLocales(LocaleStringConverterTest.java:28)
sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
java.lang.reflect.Method.invoke(Method.java:601)
org.testng.internal.MethodInvocationHelper.invokeMethod(MethodInvocationHelper.java:80)
org.testng.internal.Invoker.invokeMethod(Invoker.java:715)
org.testng.internal.Invoker.invokeTestMethod(Invoker.java:907)
org.testng.internal.Invoker.invokeTestMethods(Invoker.java:1237)
org.testng.internal.TestMethodWorker.invokeTestMethods(TestMethodWorker.java:127)
org.testng.internal.TestMethodWorker.run(TestMethodWorker.java:111)
org.testng.TestRunner.privateRun(TestRunner.java:767)
org.testng.TestRunner.run(TestRunner.java:617)
org.testng.SuiteRunner.runTest(SuiteRunner.java:334)
org.testng.SuiteRunner.runSequentially(SuiteRunner.java:329)
org.testng.SuiteRunner.privateRun(SuiteRunner.java:291)
org.testng.SuiteRunner.run(SuiteRunner.java:240)
org.testng.SuiteRunnerWorker.runSuite(SuiteRunnerWorker.java:51)
org.testng.SuiteRunnerWorker.run(SuiteRunnerWorker.java:85)
org.testng.TestNG.runSuitesSequentially(TestNG.java:1197)
org.testng.TestNG.runSuitesLocally(TestNG.java:1122)
org.testng.TestNG.run(TestNG.java:1030)
org.apache.maven.surefire.testng.TestNGExecutor.run(TestNGExecutor.java:76)
org.apache.maven.surefire.testng.TestNGDirectoryTestSuite.executeMulti(TestNGDirectoryTestSuite.java:161)
org.apache.maven.surefire.testng.TestNGDirectoryTestSuite.execute(TestNGDirectoryTestSuite.java:101)
org.apache.maven.surefire.testng.TestNGProvider.invoke(TestNGProvider.java:115)
sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
java.lang.reflect.Method.invoke(Method.java:601)
org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)
org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)
org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)
org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:103)
org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:74)
========== Test
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.equalTo;
import java.util.Locale;
import org.testng.annotations.Test;
import com.scispike.foundation.i18n.StringToLocaleConverter;
public class LocaleStringConverterTest {
	StringToLocaleConverter converter = new StringToLocaleConverter();
	public void testStringToLocale(Locale l) 
{
		String s = l.toString();

		assertThat(converter.convert(s), equalTo(l));
	}

	@Test
	public void testAllLocales() {
		Locale[] locales = Locale.getAvailableLocales();
		for (Locale l : locales) 
{
			testStringToLocale(l);
		}
	}
}
========== StringToLocaleConverter
import java.util.Locale;
import org.apache.commons.lang3.LocaleUtils;
import org.springframework.core.convert.converter.Converter;
public class StringToLocaleConverter implements Converter&amp;lt;String, Locale&amp;gt; {
	@Override
	public Locale convert(String source) {
		if (source == null) 
{
			return LocaleToStringConverter.DEFAULT;
		}
		return LocaleUtils.toLocale(source);
	}
}</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.LocaleUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.LocaleUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Regression" description="breaks">559</link>
		</links>
	</bug>
	<bug id="920" opendate="2013-10-11 19:35:41" fixdate="2013-10-11 19:39:23" resolution="Fixed">
		<buginformation>
			<summary>Add ArrayUtils#nullToEmpty(Class&lt;?&gt;[])</summary>
			<description>Class is a ubiquitous array component type. This method can be immediately consumed by [lang]&amp;amp;apos;s own reflection code.</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.ArrayUtils.java</file>
			<file type="M">org.apache.commons.lang3.ArrayUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="921" opendate="2013-10-15 17:46:38" fixdate="2013-10-15 18:32:26" resolution="Fixed">
		<buginformation>
			<summary>BooleanUtils.xor(boolean...) produces wrong results</summary>
			<description>BooleanUtils.xor(true, true, false, true) returns false, although 
true ^ true ^ false ^ true is true. This is because the implementation only checks the count of true in the provided array.</description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.BooleanUtils.java</file>
			<file type="M">org.apache.commons.lang3.BooleanUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">922</link>
		</links>
	</bug>
	<bug id="902" opendate="2013-06-21 12:24:56" fixdate="2013-10-16 08:31:09" resolution="Fixed">
		<buginformation>
			<summary>RandomStringUtils.random (count, letters=true, number=true) may not use numerics</summary>
			<description>Either there is a bug in an implementation or misunderstanding in docs.
RandomStringUtils.random (count, letters, numbers) is documented so that:
letters  if true, generated string will include alphabetic characters
numbers  if true, generated string will include numeric characters
But apparently the current implementation supports only that generated string may include either only letters, only numbers or both.
This is current implementation:
 if (letters &amp;amp;&amp;amp; Character.isLetter(ch) || numbers &amp;amp;&amp;amp; Character.isDigit(ch) || !letters &amp;amp;&amp;amp; !numbers)
So there may be situation when generated string is not containing numbers at all which is in contrary with what the docs say. </description>
			<version>3.1</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.RandomStringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="917" opendate="2013-09-17 07:32:52" fixdate="2013-10-24 20:54:48" resolution="Fixed">
		<buginformation>
			<summary>Exception when combining custom and choice format in ExtendedMessageFormat</summary>
			<description>When using a custom format registered and a choice format with an inner format is used in the same message format, an IndexOutOfBoundsException occurs in the custructor of ExtendedMessageFormat:

new ExtendedMessageFormat("Hi {0,test,any}, got {1,choice,0#none|1#one|1&amp;lt;{1,number}}", Collections.singletonMap("test", new TestFormatFactory()));


java.lang.IndexOutOfBoundsException: Index: 2, Size: 2
	at java.util.ArrayList.rangeCheck(ArrayList.java:604)
	at java.util.ArrayList.get(ArrayList.java:382)
	at org.apache.commons.lang.text.ExtendedMessageFormat.insertFormats(ExtendedMessageFormat.java:364)
	at org.apache.commons.lang.text.ExtendedMessageFormat.applyPattern(ExtendedMessageFormat.java:192)
	at org.apache.commons.lang.text.ExtendedMessageFormat.&amp;lt;init&amp;gt;(ExtendedMessageFormat.java:127)


The problem occurs at the start of {1,number}.
As a workaround i registered the TestFormatFactory also for "choice" and then returning new ChoiceFormat(arguments), but that is not the idea.
I also checked the change logs, but there seems no change on this problem. I have not tester, but I think the bug still is present in the current release.</description>
			<version>2.5</version>
			<fixedVersion>3.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.ExtendedMessageFormat.java</file>
			<file type="M">org.apache.commons.lang3.text.ExtendedMessageFormatTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="819" opendate="2012-09-09 18:40:37" fixdate="2014-01-10 15:42:32" resolution="Fixed">
		<buginformation>
			<summary>EnumUtils.generateBitVector needs a "? extends"</summary>
			<description>    public static &amp;lt;E extends Enum&amp;lt;E&amp;gt;&amp;gt; long generateBitVector(Class&amp;lt;E&amp;gt; enumClass, Iterable&amp;lt;E&amp;gt; values) {
Should be Iterable&amp;lt;? extends E&amp;gt;.
This is because although no subclasses of E can exist, the "? extends" is a common idiom for marking the collection as readonly, or not "owned" by the current object.</description>
			<version>3.0.1</version>
			<fixedVersion>3.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.EnumUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="915" opendate="2013-09-10 12:47:28" fixdate="2014-01-11 13:08:03" resolution="Fixed">
		<buginformation>
			<summary>Wrong locale handling in LocaleUtils.toLocale()</summary>
			<description>The static method LocaleUtils.toLocale() fails, at least, to parse 3-char locale strings, which are completelly valid BCP47 locales.</description>
			<version>3.1</version>
			<fixedVersion>3.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.LocaleUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.LocaleUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Incorporates" description="is part of">155</link>
			<link type="Regression" description="breaks">1172</link>
			<link type="Regression" description="breaks">1260</link>
		</links>
	</bug>
	<bug id="613" opendate="2010-03-27 22:49:50" fixdate="2014-01-20 17:20:38" resolution="Fixed">
		<buginformation>
			<summary>ConstructorUtils.getAccessibleConstructor() Does Not Check the Accessibility of Enclosing Classes</summary>
			<description>ConstructorUtils.getAccessibleConstructor() checks if the declaring class is public but not whether it&amp;amp;apos;s a top-level class or an enclosed one.  Consequently, with enclosed declaring classes, the method does not check if the enclosing class is public, or it&amp;amp;apos;s enclosing class, or it&amp;amp;apos;s enclosing class, etc...</description>
			<version>3.0</version>
			<fixedVersion>3.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.reflect.ConstructorUtils.java</file>
			<file type="M">org.apache.commons.lang3.reflect.ConstructorUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="951" opendate="2014-01-14 10:06:55" fixdate="2014-01-20 17:24:06" resolution="Fixed">
		<buginformation>
			<summary>Fragments are wrong by 1 day when using fragment YEAR or MONTH</summary>
			<description>When one trys to get the fragments of a calendar object and uses the fragment YEAR or MONTH, the returned value is wrong by 1 day in the targeted timeunit. The bug resides in the class DateUtils in function 


private static long getFragment(Calendar calendar, int fragment, int unit)


There is an initial recalculation if the fragment is YEAR or MONTH. So if one would like to have the minutes for the fragment YEAR for the date 2000-01-01 00:00:00 this would return 1440 which is actually wrong. The error can be found on lines 1635 - 1643.
Suggested fix:


// Fragments bigger than a day require a breakdown to days
        switch (fragment) {
            case Calendar.YEAR:
                result += ((calendar.get(Calendar.DAY_OF_YEAR)-1) * MILLIS_PER_DAY) / millisPerUnit;
                break;
            case Calendar.MONTH:
                result += ((calendar.get(Calendar.DAY_OF_MONTH)-1) * MILLIS_PER_DAY) / millisPerUnit;
                break;
        }

</description>
			<version>3.1</version>
			<fixedVersion>3.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.DateUtilsFragmentTest.java</file>
			<file type="M">org.apache.commons.lang3.time.DateUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">987</link>
		</links>
	</bug>
	<bug id="943" opendate="2014-01-05 23:24:13" fixdate="2014-01-20 18:45:56" resolution="Fixed">
		<buginformation>
			<summary>Test DurationFormatUtilsTest.testEdgeDuration fails in JDK 1.6, 1.7 and 1.8, BRST time zone</summary>
			<description>While helping testing LANG-942 with JDK1.8 I always got three tests failing, while others had 2. After @britter fixed the issues related to JDK1.8, I continue getting errors with JDK1.8.
I decided to vote for [lang] 3.2.1 and test the tag with JDK 1.8 and a few others. However, I&amp;amp;apos;m getting errors with any JDK, 1.6, 1.7 and 1.8 (build 121). Always the same error:
Failed tests: 
  DurationFormatUtilsTest.testEdgeDurations:467-&amp;gt;assertEqualDuration:562-&amp;gt;assertEqualDuration:575 expected:&amp;lt;7[7]&amp;gt; but was:&amp;lt;7[6]&amp;gt;
I get the same error with JDK 1.6 and the tag 3.1
Since the test is somewhat related to Time Zones (there are some Calendar&amp;amp;apos;s, TimeZone.getDefault(), etc), here&amp;amp;apos;s my locale and time zone:
kinow@chuva:~/java/apache/commons-lang-31$ locale
LANG=en_US.UTF-8
LANGUAGE=en_US
LC_CTYPE="en_US.UTF-8"
LC_NUMERIC="en_US.UTF-8"
LC_TIME="en_US.UTF-8"
LC_COLLATE="en_US.UTF-8"
LC_MONETARY="en_US.UTF-8"
LC_MESSAGES="en_US.UTF-8"
LC_PAPER="en_US.UTF-8"
LC_NAME="en_US.UTF-8"
LC_ADDRESS="en_US.UTF-8"
LC_TELEPHONE="en_US.UTF-8"
LC_MEASUREMENT="en_US.UTF-8"
LC_IDENTIFICATION="en_US.UTF-8"
LC_ALL=
kinow@chuva:~/java/apache/commons-lang-31$ date
Sun Jan  5 21:23:05 BRST 2014</description>
			<version>3.1</version>
			<fixedVersion>3.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.DurationFormatUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="936" opendate="2013-12-15 15:18:21" fixdate="2014-01-22 08:19:55" resolution="Fixed">
		<buginformation>
			<summary>StringUtils.getLevenshteinDistance with too big of a threshold returns wrong result</summary>
			<description>StringUtils.getLevenshteinDistance(CharSequence s, CharSequence t, int threshold) specifies:

Find the Levenshtein distance between two Strings if it&amp;amp;apos;s less than or equal to a given threshold.
When passing a threshold &amp;gt; Integer.MAX_VALUE - max(s.length(), t.length()) the method always returns -1.
The simplest use case is passing Integer.MAX_VALUE (a common practice if one would want to find the min/max LD of a string to several other strings in an iterative fashion.
The code should be fixed to consider the threshold in relation to the source/target lengths, or alternatively the javadoc should be fixed to pronounce the current limit.</description>
			<version>3.1</version>
			<fixedVersion>3.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">684</link>
		</links>
	</bug>
	<bug id="954" opendate="2014-01-19 10:21:56" fixdate="2014-01-24 17:14:01" resolution="Fixed">
		<buginformation>
			<summary>uncaught PatternSyntaxException in FastDateFormat on Android</summary>
			<description>When updating from lang 3.1.0 to 3.2.1 FastDateFormat stopped working on an Android project of mine, throwing uncaught regular expression exceptions for simple formats like "yyyy-MM-dd&amp;amp;apos;T&amp;amp;apos;".


Caused by: java.util.regex.PatternSyntaxException: U_ILLEGAL_ARGUMENT_ERROR
(\p{IsNd}++)\Q-\E(\p{IsNd}++)\Q-\E(\p{IsNd}++)\QT\E
at java.util.regex.Pattern.compileImpl(Native Method)
at java.util.regex.Pattern.compile(Pattern.java:400)
at java.util.regex.Pattern.&amp;lt;init&amp;gt;(Pattern.java:383)
at java.util.regex.Pattern.compile(Pattern.java:374)
at org.apache.commons.lang3.time.FastDateParser.init(FastDateParser.java:148)
at org.apache.commons.lang3.time.FastDateParser.&amp;lt;init&amp;gt;(FastDateParser.java:104)
at org.apache.commons.lang3.time.FastDateFormat.&amp;lt;init&amp;gt;(FastDateFormat.java:370)
at org.apache.commons.lang3.time.FastDateFormat$1.createInstance(FastDateFormat.java:91)
at org.apache.commons.lang3.time.FastDateFormat$1.createInstance(FastDateFormat.java:88)
at org.apache.commons.lang3.time.FormatCache.getInstance(FormatCache.java:82)
at org.apache.commons.lang3.time.FastDateFormat.getInstance(FastDateFormat.java:148)


more stack traces in this Jenkins output: http://ci.cgeo.org/job/c-geo/1686/console</description>
			<version>3.2.1</version>
			<fixedVersion>3.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDateParser.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateFormatTest.java</file>
		</fixedFiles>
		<links>
			<link type="Regression" description="is broken by">462</link>
		</links>
	</bug>
	<bug id="961" opendate="2014-01-30 21:43:29" fixdate="2014-01-30 22:08:45" resolution="Fixed">
		<buginformation>
			<summary>org.apache.commons.lang3.reflect.FieldUtils.removeFinalModifier(Field) does not clean up after itself</summary>
			<description>FieldUtils.removeFinalModifier(Field) calls setAccessible(true) on the Field it is working on but does not reset it to false when done, after the final modifier has been removed. Also the method does not need to call setAccessible(true) if the field is already accessible.

Only call setAccessible when needed
Refactor and add a new method removeFinalModifier(Field field, boolean forceAccess)

</description>
			<version>3.2</version>
			<fixedVersion>3.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.reflect.MemberUtils.java</file>
			<file type="M">org.apache.commons.lang3.reflect.FieldUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.reflect.FieldUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="946" opendate="2014-01-08 18:45:06" fixdate="2014-02-01 10:47:00" resolution="Fixed">
		<buginformation>
			<summary>ConstantInitializerTest fails when building with IBM JDK 7</summary>
			<description>Found by Jrg Schaible during the vote for 3.2.1 RC1 [1]:


========================== %&amp;lt; ====================
Failed tests:
  ConstantInitializerTest.testToString:122 Wrong string:
ConstantInitializer@-669671219 [ object = 42 ]
========================== %&amp;lt; ====================


[1] http://markmail.org/message/7exdutk2cktec2yy</description>
			<version>3.2.1</version>
			<fixedVersion>3.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.concurrent.ConstantInitializerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="969" opendate="2014-02-07 22:02:06" fixdate="2014-02-10 02:06:29" resolution="Fixed">
		<buginformation>
			<summary>StringUtils.toEncodedString(byte[], Charset) needlessly throws UnsupportedEncodingException</summary>
			<description>This new method throws UnsupportedEncodingException when passed in a Charset object. Why?
new String(byte[], Charset) does not throw this exception.</description>
			<version>3.2.1</version>
			<fixedVersion>3.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="972" opendate="2014-02-11 02:31:03" fixdate="2014-02-11 02:39:41" resolution="Fixed">
		<buginformation>
			<summary>NumberUtils#isNumber does not allow for hex 0XABCD</summary>
			<description>isNumber() does not allow for 0XABCD whereas createNumber() allows for both 0xABCD and 0XABCD</description>
			<version>3.2.1</version>
			<fixedVersion>3.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.math.NumberUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">997</link>
		</links>
	</bug>
	<bug id="971" opendate="2014-02-10 08:17:25" fixdate="2014-02-11 02:54:03" resolution="Fixed">
		<buginformation>
			<summary>NumberUtils#isNumber(String) fails to reject invalid Octal numbers</summary>
			<description>When trying to convert "0085" with NumberUtils.createInteger(String) an NumberFormatException is thrown. 
This is because the leading 0 causes the String to be evaluated as an Octal, 8 is not a valid octal.
However NumberUtils#isNumber(String) evaluates to true, even so it cannot be converted.  
</description>
			<version>3.2.1</version>
			<fixedVersion>3.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.math.NumberUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Regression" description="breaks">992</link>
			<link type="Regression" description="breaks">997</link>
		</links>
	</bug>
	<bug id="977" opendate="2014-02-14 19:57:39" fixdate="2014-02-15 10:36:25" resolution="Fixed">
		<buginformation>
			<summary>NumericEntityEscaper incorrectly encodes supplementary characters</summary>
			<description>NumericEntityEscaper will incorrectly encode supplementary unicode characters depending on the char length of the first code point in the string.
To reproduce, run:


String escaped = NumericEntityEscaper.between(0x7f, Integer.MAX_VALUE).translate("a \uD83D\uDC14 \uD83D\uDCA9");


Expected:


escaped == "a &amp;amp;#128020; &amp;amp;#128169;"


Actual:


escaped == "a &amp;amp;#128020;&amp;amp;#56340; &amp;amp;#128169;&amp;amp;#56489;"


The issue lies in CharSequenceTranslator.translate() and the way it checks code points to figure out how many characters it needs to consume.  Specifically, the issue is on line 95:


// contract with translators is that they have to understand codepoints 
// and they just took care of a surrogate pair
for (int pt = 0; pt &amp;lt; consumed; pt++) {
    pos += Character.charCount(Character.codePointAt(input, pt));
}


The point of this code is to check the charCount of the character that was just translated and move ahead by that many characters in the input string.  The bug is that it&amp;amp;apos;s indexing into the string using &amp;amp;apos;pt&amp;amp;apos;, which is always 0 at the beginning of the loop.  It&amp;amp;apos;s effetively checking the charCount of first character in the string every time.
A patch is attached that fixes the issue and includes supporting unit tests.  Fixing this issue in CharSequenceTranslator uncovered an issue in CsvEscaper/CsvUnescaper caused by the fact that it wasn&amp;amp;apos;t respecting the "code point contract" described in CharSequenceTranslator.translate.  The fix there was to have the translate methods return the string&amp;amp;apos;s code point count rather than character count.</description>
			<version>3.2.1</version>
			<fixedVersion>3.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringEscapeUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.StringEscapeUtils.java</file>
			<file type="M">org.apache.commons.lang3.text.translate.CharSequenceTranslator.java</file>
		</fixedFiles>
	</bug>
	<bug id="978" opendate="2014-03-01 09:23:35" fixdate="2014-03-03 21:33:14" resolution="Fixed">
		<buginformation>
			<summary>Failing tests with Java 8 b128</summary>
			<description>Gary Gregory has reported failing tests during the vote for Lang 3.3 RC1, when building with:


java version "1.8.0"
Java(TM) SE Runtime Environment (build 1.8.0-b128)
Java HotSpot(TM) 64-Bit Server VM (build 25.0-b69, mixed mode)

Apache Maven 3.2.1 (ea8b2b07643dbb1b84b6d16e1f08391b666bc1e9;
2014-02-14T12:37:52-05:00)
Maven home: C:\Java\apache-maven-3.2.1\bin\..
Java version: 1.8.0, vendor: Oracle Corporation
Java home: C:\Program Files\Java\jdk1.8.0\jre
Default locale: en_US, platform encoding: Cp1252
OS name: "windows 7", version: "6.1", arch: "amd64", family: "dos"




FastDateFormat_ParserTest&amp;gt;FastDateParserTest.testParses:242-&amp;gt;FastDateParserTest.validateSdfFormatFdpParseEquality:219  Parse FastDateParserTest.testParses:242-&amp;gt;validateSdfFormatFdpParseEquality:219  Parse

Running org.apache.commons.lang3.time.FastDateFormat_ParserTest /1/2/10/5/??/0/0/?/+0000 ja_JP_JP_#u-ca-japanese 1867 G/y/M/d/h/a/m/s/E/Z America/New_York Tests run: 29, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 2.491 sec &amp;lt;&amp;lt;&amp;lt; FAILURE! - in org.apache.commons.lang3.time.FastDateFormat_ParserTest testParses(org.apache.commons.lang3.time.FastDateFormat_ParserTest) Time elapsed: 1.492 sec &amp;lt;&amp;lt;&amp;lt; ERROR! java.text.ParseException: (The ja_JP_JP_#u-ca-japanese locale does not support dates before 1868 AD)


See: http://markmail.org/message/suvorq3xrqmimnui</description>
			<version>3.3</version>
			<fixedVersion>3.3.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.DurationFormatUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="987" opendate="2014-03-13 04:53:05" fixdate="2014-03-13 21:52:39" resolution="Fixed">
		<buginformation>
			<summary>DateUtils.getFragmentInDays(Date, Calendar.MONTH) returns wrong days</summary>
			<description>Commons lang3 screwed up my system after upgraded to 3.3 last night!
We use DateUtils.getFragmentInDays(Date, Calendar.MONTH) to extract days for later use. Basically (in 3.2), &amp;amp;apos;today&amp;amp;apos; (Mar. 13) returns 13, but, it returns 12 in 3.3!
I compared the underlying method org.apache.commons.lang3.time.DateUtils.getFragment(Calendar, int, int) between 3.2 and 3.3:
3.2


        // Fragments bigger than a day require a breakdown to days
        switch (fragment) {
            case Calendar.YEAR:
                result += (calendar.get(Calendar.DAY_OF_YEAR) * MILLIS_PER_DAY) / millisPerUnit;
                break;
            case Calendar.MONTH:
                result += (calendar.get(Calendar.DAY_OF_MONTH) * MILLIS_PER_DAY) / millisPerUnit;
                break;
        }


3.3


        // Fragments bigger than a day require a breakdown to days
        switch (fragment) {
            case Calendar.YEAR:
                result += ((calendar.get(Calendar.DAY_OF_YEAR) -1) * MILLIS_PER_DAY) / millisPerUnit;
                break;
            case Calendar.MONTH:
                result += ((calendar.get(Calendar.DAY_OF_MONTH) -1) * MILLIS_PER_DAY) / millisPerUnit;
                break;
            default:
                break;
        }


Is there ANY ANY reason for adding &amp;amp;apos;-1&amp;amp;apos; in 3.3?! Plus, do you have any unit test for this method?</description>
			<version>3.3</version>
			<fixedVersion>3.3.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.DateUtils.java</file>
			<file type="M">org.apache.commons.lang3.time.DateUtilsFragmentTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">951</link>
		</links>
	</bug>
	<bug id="995" opendate="2014-04-11 13:12:56" fixdate="2014-04-11 13:28:59" resolution="Fixed">
		<buginformation>
			<summary>Fix bug with stripping spaces on last line in WordUtils.wrap() </summary>
			<description>Via github: https://github.com/apache/commons-lang/pull/18</description>
			<version>3.3.2</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.WordUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.text.WordUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">957</link>
		</links>
	</bug>
	<bug id="1001" opendate="2014-04-30 20:15:47" fixdate="2014-04-30 21:50:38" resolution="Fixed">
		<buginformation>
			<summary>ISO 8601 misspelled throughout the Javadocs</summary>
			<description>The Javadocs say: ISO8601 but the correct format is ISO 8601. Note the space.
A patch can be provided.</description>
			<version>3.3.2</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.DurationFormatUtils.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateFormat.java</file>
			<file type="M">org.apache.commons.lang3.time.DurationFormatUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinter.java</file>
			<file type="M">org.apache.commons.lang3.time.StopWatch.java</file>
			<file type="M">org.apache.commons.lang3.time.DateFormatUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="957" opendate="2014-01-24 15:14:30" fixdate="2014-05-03 19:27:35" resolution="Duplicate">
		<buginformation>
			<summary>WordUtils.wrap(String, int) doesn&amp;apos;t behave according to JavaDoc</summary>
			<description>The JavaDoc of WordUtils.wrap(String, int) says that leading white spaces on new lines are stripped from the result. However the following test will fail, since the leading spaces of the second line are not stripped from the resultL


@Test
public void testWordUtils_StringInt_LeadingWhitespaces {
        input = "spaces                               spaces";
        expected = "spaces              " + systemNewLine + "spaces";
        assertEquals(expected, WordUtils.wrap(input, 20));
}

</description>
			<version>3.2.1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.WordUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.text.WordUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">995</link>
		</links>
	</bug>
	<bug id="1003" opendate="2014-04-30 21:02:43" fixdate="2014-05-04 08:49:49" resolution="Fixed">
		<buginformation>
			<summary>DurationFormatUtils are not able to handle negative durations/periods</summary>
			<description>It spits out complete garbage.


System.out.println(DurationFormatUtils.formatDurationHMS(-3454));
System.out.println(DurationFormatUtils.formatPeriodISO(4000, 3000));



0:00:-3.-454
P-1Y11M30DT23H59M59.000S


It should throw an IllegalArgumentException if duration is &amp;lt; 0 or period diff is &amp;lt; 0.</description>
			<version>3.3.2</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.DurationFormatUtils.java</file>
			<file type="M">org.apache.commons.lang3.time.DurationFormatUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1027" opendate="2014-07-13 11:41:53" fixdate="2014-07-20 11:31:58" resolution="Fixed">
		<buginformation>
			<summary>org.apache.commons.lang3.SystemUtils#isJavaVersionAtLeast should return true by default</summary>
			<description>Hi
last [lang] release doesn&amp;amp;apos;t support java 9 (not in JavaVersion enum). However it shouldn&amp;amp;apos;t break the org.apache.commons.lang3.SystemUtils#isJavaVersionAtLeast method which should return true when java version is not known (not known = older)
My proposal is to add UNKNOWN to the enum and override atLeast for this particular value to return true.</description>
			<version>3.3.2</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.JavaVersionTest.java</file>
			<file type="M">org.apache.commons.lang3.JavaVersion.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1068</link>
		</links>
	</bug>
	<bug id="1004" opendate="2014-04-30 21:11:43" fixdate="2014-08-04 12:24:59" resolution="Fixed">
		<buginformation>
			<summary>DurationFormatUtils#formatDurationHMS implementation does not correspond to Javadoc and vice versa</summary>
			<description>This method has several flaws:
1. Javadoc says: "The format used is ISO8601-like: H:m:s.S." but the method call supplies "H:mm:ss.SSS"
2. ISO time never omits leading zeros, so the proper pattern must be "HH:mm:ss.SSS"
3. The method name says: "HMS" but includes the second fraction.
Since the use of fractions is optional, the method should use "HH:mm:ss" and update the Javadoc as well.</description>
			<version>3.3.2</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.DurationFormatUtils.java</file>
			<file type="M">org.apache.commons.lang3.time.DurationFormatUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.time.StopWatchTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1035" opendate="2014-08-07 07:59:31" fixdate="2014-09-10 11:35:45" resolution="Fixed">
		<buginformation>
			<summary>Javadoc for EqualsBuilder.reflectionEquals() is unclear</summary>
			<description>The Javadoc for EqualsBuilder.reflectionEquals() doesn&amp;amp;apos;t explain that .equals() is used to compare non-primitive fields in the class.
Consequently, readers may assume the method recursively builds .equals() for all fields. We should clarify this.
Related: LANG-1034</description>
			<version>3.3.2</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.builder.EqualsBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1000" opendate="2014-04-30 12:55:19" fixdate="2014-09-28 10:12:41" resolution="Fixed">
		<buginformation>
			<summary>ParseException when trying to parse UTC dates with Z as zone designator using DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT</summary>
			<description>I have the String 2013-11-18T12:48:05Z which I want to parse into a Date using DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT. 
According to http://en.wikipedia.org/wiki/ISO_8601#UTC the Z at the end should be a valid abbreviation for UTC+00:00 (or UTC) and so all should be fine.
But when I am trying to do so I get the following exception:


java.text.ParseException: Unparseable date: "2013-11-18T12:48:05Z" does not match

</description>
			<version>3.3.2</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.DateFormatUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinter.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinterTest.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="1041" opendate="2014-10-01 12:20:24" fixdate="2014-10-02 10:13:10" resolution="Fixed">
		<buginformation>
			<summary>Fix MethodUtilsTest so it does not depend on JDK method ordering</summary>
			<description>Placeholder for https://github.com/apache/commons-lang/pull/30.</description>
			<version>3.3.2</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.reflect.MethodUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1068" opendate="2014-11-19 20:39:57" fixdate="2014-11-30 18:40:36" resolution="Duplicate">
		<buginformation>
			<summary>SystemUtils.isJavaVersionAtLeast throws NPE under Java 9 EA</summary>
			<description>Hello,
Testing JMeter under Java 9 EA, it fails with NPE in SystemUtils.isJavaVersionAtLeast  due to handling of Java 9 not yet being supported.
Thanks</description>
			<version>3.3.2</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.JavaVersionTest.java</file>
			<file type="M">org.apache.commons.lang3.JavaVersion.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1027</link>
		</links>
	</bug>
	<bug id="1072" opendate="2014-12-02 23:46:34" fixdate="2014-12-03 01:40:18" resolution="Fixed">
		<buginformation>
			<summary>Duplicated "0x" check in createBigInteger in NumberUtils</summary>
			<description>I think there is typo in below line:
org.apache.commons.lang3.math.NumberUtils.java

 if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) { // hex
            radix = 16;
            pos += 2;
}


The second "0x" should be "0X"
org.apache.commons.lang3.math.NumberUtils.java

 if (str.startsWith("0x", pos) || str.startsWith("0X", pos)) { // hex
            radix = 16;
            pos += 2;
}

</description>
			<version>3.3.2</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.math.NumberUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1073" opendate="2014-12-03 00:01:52" fixdate="2014-12-14 18:27:28" resolution="Fixed">
		<buginformation>
			<summary>Read wrong component type of array in add in ArrayUtils</summary>
			<description>org.apache.commons.lang3.ArrayUtils.java

    public static &amp;lt;T&amp;gt; T[] add(final T[] array, final T element) {
        Class&amp;lt;?&amp;gt; type;
        if (array != null){
            type = array.getClass();
        } else if (element != null) {
            type = element.getClass();
        } else {
            throw new IllegalArgumentException("Arguments cannot both be null");
        }
        .......
    }


I think it should be:
org.apache.commons.lang3.ArrayUtils.java

    public static &amp;lt;T&amp;gt; T[] add(final T[] array, final T element) {
        Class&amp;lt;?&amp;gt; type;
        if (array != null){
            type = array.getClass().getComponentType();
        } else if (element != null) {
            type = element.getClass();
        } else {
            throw new IllegalArgumentException("Arguments cannot both be null");
        }
        .......
    }

</description>
			<version>3.3.2</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.ArrayUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="883" opendate="2013-04-05 11:19:57" fixdate="2014-12-27 16:29:39" resolution="Fixed">
		<buginformation>
			<summary>Add StringUtils.containsAny(CharSequence, CharSequence... ) method</summary>
			<description>Presently there is a: public static boolean containsAny(CharSequence cs, char... searchChars). It would be useful to have the: public static boolean containsAny(CharSequence cs, CharSequence... searchCharSequences) which will return true if any of the searchCharSequences are contained within the cs. If you decide to implement it, it would be nice to have an alias method for collections, e.g., public static boolean containsAny(CharSequence cs, Collection&amp;lt;CharSequence&amp;gt; searchCharSequences)</description>
			<version>3.1</version>
			<fixedVersion>3.4</fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">733</link>
		</links>
	</bug>
	<bug id="733" opendate="2011-07-31 11:55:11" fixdate="2014-12-27 16:31:05" resolution="Duplicate">
		<buginformation>
			<summary>Add containsAny(CharSequence cs, CharSequence... searchChars) to StringUtils</summary>
			<description>This method is missing from StringUtils. The corresponding method: 
public static boolean containsAny(CharSequence cs, char... searchChars) {
does exist, so this was probably just forgotten. 
Also
public static boolean containsIgnoreCase(CharSequence str, CharSequence... searchStr) {
needs to be added as well.</description>
			<version>3.0</version>
			<fixedVersion></fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">883</link>
		</links>
	</bug>
	<bug id="1071" opendate="2014-12-02 17:53:08" fixdate="2014-12-27 16:48:49" resolution="Fixed">
		<buginformation>
			<summary>Fix wrong examples in JavaDoc of StringUtils.replaceEachRepeatedly(...), StringUtils.replaceEach(...)</summary>
			<description>StringUtils.replaceEachRepeatedly(, *, *) has javadoc with examples of invokation of StringUtils.replaceEach(, *, *):
https://svn.apache.org/viewvc/commons/proper/lang/trunk/src/main/java/org/apache/commons/lang3/StringUtils.java?revision=1639624&amp;amp;view=markup#l4588
StringUtils.replaceEach(, *, *, *, *) has javadoc with examples of invokation of StringUtils.StringUtils.replaceEach(, *, *, *). Note different number of arguments.
https://svn.apache.org/viewvc/commons/proper/lang/trunk/src/main/java/org/apache/commons/lang3/StringUtils.java?revision=1639624&amp;amp;view=markup#l4639
Please fix javadoc.</description>
			<version>3.3.2</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1055" opendate="2014-10-22 12:59:09" fixdate="2015-01-23 08:11:43" resolution="Fixed">
		<buginformation>
			<summary>StrSubstitutor.replaceSystemProperties does not work consistently</summary>
			<description>StrSubsitutor caches a references to SystemProperties statically on first class references.  This does not work properly with System.setProperties().  For example the following code:


package test.utilities;

import java.util.Properties;

import org.apache.commons.lang.text.StrSubstitutor;

public class TestStrSubstitutor {

    public static void main(String[] args) {
        System.out.println(StrSubstitutor.replaceSystemProperties("os.name=${os.name}"));
        Properties testProps = new Properties();
        testProps.put("test_key",  "test_value");
        testProps.putAll(System.getProperties());
        System.setProperties(testProps);
        System.out.println(StrSubstitutor.replace("test_key=${test_key}", System.getProperties()));
        System.out.println(StrSubstitutor.replaceSystemProperties("test_key=${test_key}"));
    }

}


produces the following output:


os.name=Windows 7
test_key=test_value
test_key=${test_key}


The code linked here shows the static caching of the System Properties reference: http://commons.apache.org/proper/commons-lang/apidocs/src-html/org/apache/commons/lang3/text/StrLookup.html</description>
			<version>3.3.2</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.StrSubstitutorTest.java</file>
			<file type="M">org.apache.commons.lang3.text.StrLookupTest.java</file>
			<file type="M">org.apache.commons.lang3.text.StrLookup.java</file>
		</fixedFiles>
	</bug>
	<bug id="1081" opendate="2015-01-14 16:11:18" fixdate="2015-01-23 08:28:09" resolution="Fixed">
		<buginformation>
			<summary>DiffBuilder.append(String, Object left, Object right) does not do a left.equals(right) check</summary>
			<description>Only testing == without testing equals() seems wrong.
Should an equals() test be added after determining that the parameters are not arrays?</description>
			<version>3.3.2</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.builder.DiffBuilder.java</file>
			<file type="M">org.apache.commons.lang3.builder.DiffBuilderTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1087" opendate="2015-02-28 19:52:12" fixdate="2015-03-01 16:48:54" resolution="Fixed">
		<buginformation>
			<summary>NumberUtils#createNumber() returns positive BigDecimal when negative Float is expected</summary>
			<description>NumberUtils.createNumber("-0.0") returns BigDecimal with 0 signum.
Caused by the implementation not checking for sign when extracting mantissa from the input string.
Expected is that negative Float is returned.</description>
			<version>3.x</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.math.NumberUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1061" opendate="2014-11-05 16:59:04" fixdate="2015-03-01 18:03:14" resolution="Fixed">
		<buginformation>
			<summary>FastDateParser error - timezones not handled correctly</summary>
			<description>The following code throws an exception:
DateParser dp = FastDateFormat.getInstance("z yyyy", Locale.US);
dp.parse("GMT+00:00 2010");
The format works correctly with SimpleDateFormat.
Stack:
java.text.ParseException: Unparseable date: "GMT+00:00 2010" does not match (GMT[+\-]\d
{0,1}
\d
{2}|[+\-]\d{2}
:?\d
{2}
|\QAcre Time\E|\QACT\E|\QADT\E|\QAfghanistan Time\E|\QAFT\E|\QAKDT\E|\QAKST\E|\QAlaska Daylight Time\E|\QAlaska Standard Time\E|\QAlma-Ata Time\E|\QALMT\E|\QAmazon Summer Time\E|\QAmazon Time\E|\QAMST\E|\QAMT\E|\QAnadyr Time\E|\QANAT\E|\QAqtau Time\E|\QAqtobe Time\E|\QAQTT\E|\QArabia Standard Time\E|\QArgentine Time\E|\QArmenia Time\E|\QART\E|\QAST\E|\QAtlantic Daylight Time\E|\QAtlantic Standard Time\E|\QAzerbaijan Summer Time\E|\QAzerbaijan Time\E|\QAzores Summer Time\E|\QAzores Time\E|\QAZOST\E|\QAZOT\E|\QAZST\E|\QAZT\E|\QBangladesh Time\E|\QBDT\E|\QBhutan Time\E|\QBNT\E|\QBolivia Time\E|\QBOT\E|\QBrasilia Summer Time\E|\QBrasilia Time\E|\QBritish Summer Time\E|\QBRST\E|\QBRT\E|\QBrunei Time\E|\QBST\E|\QBTT\E|\QCape Verde Time\E|\QCAT\E|\QCCT\E|\QCDT\E|\QCentral African Time\E|\QCentral Daylight Time\E|\QCentral European Summer Time\E|\QCentral European Time\E|\QCentral Indonesia Time\E|\QCentral Standard Time\E|\QCentral Standard Time (Northern Territory)\E|\QCentral Standard Time (South Australia)\E|\QCentral Standard Time (South Australia/New South Wales)\E|\QCentral Summer Time (South Australia)\E|\QCentral Summer Time (South Australia/New South Wales)\E|\QCentral Western Standard Time (Australia)\E|\QCEST\E|\QCET\E|\QCHADT\E|\QChamorro Standard Time\E|\QCHAST\E|\QChatham Daylight Time\E|\QChatham Standard Time\E|\QChile Summer Time\E|\QChile Time\E|\QChina Standard Time\E|\QChoibalsan Time\E|\QCHOT\E|\QChristmas Island Time\E|\QChST\E|\QCHUT\E|\QChuuk Time\E|\QCKT\E|\QCLST\E|\QCLT\E|\QCocos Islands Time\E|\QColombia Time\E|\QCook Is. Time\E|\QCoordinated Universal Time\E|\QCOT\E|\QCST\E|\QCuba Daylight Time\E|\QCuba Standard Time\E|\QCVT\E|\QCWST\E|\QCXT\E|\QDavis Time\E|\QDAVT\E|\QDDUT\E|\QDumont-d&amp;amp;apos;Urville Time\E|\QEASST\E|\QEAST\E|\QEast Indonesia Time\E|\QEaster Is. Summer Time\E|\QEaster Is. Time\E|\QEastern African Time\E|\QEastern Daylight Time\E|\QEastern European Summer Time\E|\QEastern European Time\E|\QEastern Greenland Summer Time\E|\QEastern Greenland Time\E|\QEastern Standard Time\E|\QEastern Standard Time (New South Wales)\E|\QEastern Standard Time (Queensland)\E|\QEastern Standard Time (Tasmania)\E|\QEastern Standard Time (Victoria)\E|\QEastern Summer Time (New South Wales)\E|\QEastern Summer Time (Tasmania)\E|\QEastern Summer Time (Victoria)\E|\QEAT\E|\QECT\E|\QEcuador Time\E|\QEDT\E|\QEEST\E|\QEET\E|\QEGST\E|\QEGT\E|\QEST\E|\QFalkland Is. Time\E|\QFernando de Noronha Time\E|\QFET\E|\QFiji Summer Time\E|\QFiji Time\E|\QFJST\E|\QFJT\E|\QFKT\E|\QFNT\E|\QFrench Guiana Time\E|\QFrench Southern &amp;amp; Antarctic Lands Time\E|\QFurther-eastern European Time\E|\QGalapagos Time\E|\QGALT\E|\QGambier Time\E|\QGAMT\E|\QGeorgia Time\E|\QGET\E|\QGFT\E|\QGhana Mean Time\E|\QGilbert Is. Time\E|\QGILT\E|\QGMT\E|\QGreenwich Mean Time\E|\QGST\E|\QGulf Standard Time\E|\QGuyana Time\E|\QGYT\E|\QHADT\E|\QHAST\E|\QHawaii Standard Time\E|\QHawaii-Aleutian Daylight Time\E|\QHawaii-Aleutian Standard Time\E|\QHKT\E|\QHong Kong Time\E|\QHovd Time\E|\QHOVT\E|\QHST\E|\QICT\E|\QIDT\E|\QIndia Standard Time\E|\QIndian Ocean Territory Time\E|\QIndochina Time\E|\QIOT\E|\QIran Daylight Time\E|\QIran Standard Time\E|\QIRDT\E|\QIrish Summer Time\E|\QIRKT\E|\QIrkutsk Time\E|\QIRST\E|\QIsrael Daylight Time\E|\QIsrael Standard Time\E|\QIST\E|\QJapan Standard Time\E|\QJST\E|\QKGT\E|\QKhandyga Time\E|\QKirgizstan Time\E|\QKorea Standard Time\E|\QKosrae Time\E|\QKOST\E|\QKrasnoyarsk Time\E|\QKRAT\E|\QKST\E|\QLHST\E|\QLine Is. Time\E|\QLINT\E|\QLord Howe Standard Time\E|\QLord Howe Summer Time\E|\QMacquarie Island Time\E|\QMagadan Time\E|\QMAGT\E|\QMalaysia Time\E|\QMaldives Time\E|\QMarquesas Time\E|\QMarshall Islands Time\E|\QMART\E|\QMauritius Time\E|\QMawson Time\E|\QMAWT\E|\QMDT\E|\QMeST\E|\QMET\E|\QMetlakatla Standard Time\E|\QMHT\E|\QMiddle Europe Summer Time\E|\QMiddle Europe Time\E|\QMIST\E|\QMMT\E|\QMoscow Standard Time\E|\QMountain Daylight Time\E|\QMountain Standard Time\E|\QMSK\E|\QMST\E|\QMUT\E|\QMVT\E|\QMyanmar Time\E|\QMYT\E|\QNauru Time\E|\QNCT\E|\QNDT\E|\QNepal Time\E|\QNew Caledonia Time\E|\QNew Zealand Daylight Time\E|\QNew Zealand Standard Time\E|\QNewfoundland Daylight Time\E|\QNewfoundland Standard Time\E|\QNFT\E|\QNiue Time\E|\QNorfolk Time\E|\QNovosibirsk Time\E|\QNOVT\E|\QNPT\E|\QNRT\E|\QNST\E|\QNUT\E|\QNZDT\E|\QNZST\E|\QOmsk Time\E|\QOMST\E|\QOral Time\E|\QORAT\E|\QPacific Daylight Time\E|\QPacific Standard Time\E|\QPakistan Time\E|\QPalau Time\E|\QPapua New Guinea Time\E|\QParaguay Summer Time\E|\QParaguay Time\E|\QPDT\E|\QPeru Time\E|\QPET\E|\QPetropavlovsk-Kamchatski Time\E|\QPETT\E|\QPGT\E|\QPhilippines Time\E|\QPhoenix Is. Time\E|\QPHOT\E|\QPHT\E|\QPierre &amp;amp; Miquelon Daylight Time\E|\QPierre &amp;amp; Miquelon Standard Time\E|\QPitcairn Standard Time\E|\QPKT\E|\QPMDT\E|\QPMST\E|\QPohnpei Time\E|\QPONT\E|\QPST\E|\QPWT\E|\QPYST\E|\QPYT\E|\QQYZT\E|\QQyzylorda Time\E|\QRET\E|\QReunion Time\E|\QRothera Time\E|\QROTT\E|\QSakhalin Time\E|\QSAKT\E|\QSamara Time\E|\QSamoa Standard Time\E|\QSAMT\E|\QSAST\E|\QSBT\E|\QSCT\E|\QSeychelles Time\E|\QSGT\E|\QSingapore Time\E|\QSolomon Is. Time\E|\QSouth Africa Standard Time\E|\QSouth Georgia Standard Time\E|\QSRT\E|\QSST\E|\QSuriname Time\E|\QSYOT\E|\QSyowa Time\E|\QTahiti Time\E|\QTAHT\E|\QTajikistan Time\E|\QTFT\E|\QTimor-Leste Time\E|\QTJT\E|\QTKT\E|\QTLT\E|\QTMT\E|\QTokelau Time\E|\QTonga Time\E|\QTOT\E|\QTurkmenistan Time\E|\QTuvalu Time\E|\QTVT\E|\QUlaanbaatar Time\E|\QULAT\E|\QUruguay Summer Time\E|\QUruguay Time\E|\QUst-Nera Time\E|\QUTC\E|\QUYST\E|\QUYT\E|\QUzbekistan Time\E|\QUZT\E|\QVanuatu Time\E|\QVenezuela Time\E|\QVET\E|\QVladivostok Time\E|\QVLAT\E|\QVolgograd Time\E|\QVOLT\E|\QVOST\E|\QVostok Time\E|\QVUT\E|\QWake Time\E|\QWAKT\E|\QWallis &amp;amp; Futuna Time\E|\QWAST\E|\QWAT\E|\QWEST\E|\QWest Indonesia Time\E|\QWest Samoa Daylight Time\E|\QWest Samoa Time\E|\QWestern African Summer Time\E|\QWestern African Time\E|\QWestern European Summer Time\E|\QWestern European Time\E|\QWestern Greenland Summer Time\E|\QWestern Greenland Time\E|\QWestern Standard Time (Australia)\E|\QWET\E|\QWFT\E|\QWGST\E|\QWGT\E|\QWIB\E|\QWIT\E|\QWITA\E|\QWSDT\E|\QWST\E|\QYAKT\E|\QYakutsk Time\E|\QYekaterinburg Time\E|\QYEKT\E)\Q \E(\p
{Nd}
++)
	at org.apache.commons.lang3.time.FastDateParser.parse(FastDateParser.java:289)
	at org.apache.commons.lang3.time.FastDateFormat.parse(FastDateFormat.java:487)
</description>
			<version>3.3.2</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDateParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="1092" opendate="2015-03-10 23:28:15" fixdate="2015-03-13 20:30:56" resolution="Fixed">
		<buginformation>
			<summary>Wrong formating of time zones with daylight saving time in FastDatePrinter</summary>
			<description>At work we&amp;amp;apos;re getting build issues with Lang 3.3.2 (and any since 3.2 when the test code was introduced in LANG-818).  The test org.apache.commons.lang3.time.FastDatePrinterTest.testCalendarTimezoneRespected picks a timezone and runs a test on it. One assumes that timezones usually work, but some are not - so it depends on the order of timezones returned by TimeZone.getAvailableIDs().
This would seem to imply a daylight savings time bug in FastDateFormat. This may be the same issue as LANG-916.
If you adjust the for loop such that the test is within the loop and happens on every timezone, you will hit timezones that fail.  e.g.:


Index: FastDatePrinterTest.java
===================================================================
--- FastDatePrinterTest.java	(revision 1665715)
+++ FastDatePrinterTest.java	(working copy)
@@ -269,8 +269,6 @@
         for (final String zone : availableZones) {
             if (!zone.equals(currentZone.getID())) {
                 anotherZone = TimeZone.getTimeZone(zone);
-            }
-        }
         
         assertNotNull("Cannot find another timezone", anotherZone);
         
@@ -282,6 +280,8 @@
         final String expectedValue = sdf.format(cal.getTime());
         final String actualValue = FastDateFormat.getInstance(pattern).format(cal);
         assertEquals(expectedValue, actualValue);
+            }
+        }
     }
     
     @Test

</description>
			<version>3.3.2</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinter.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinterTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">916</link>
		</links>
	</bug>
	<bug id="948" opendate="2014-01-10 11:07:46" fixdate="2015-03-14 12:48:35" resolution="Fixed">
		<buginformation>
			<summary>Exception while using ExtendedMessageFormat and escaping braces</summary>
			<description>Exception while trying to format a string containing escaped braces


Exception in thread "main" java.lang.IllegalArgumentException: Invalid format argument index at position 7: }
	at org.apache.commons.lang3.text.ExtendedMessageFormat.readArgumentIndex(ExtendedMessageFormat.java:357)
	at org.apache.commons.lang3.text.ExtendedMessageFormat.applyPattern(ExtendedMessageFormat.java:167)
	at org.apache.commons.lang3.text.ExtendedMessageFormat.&amp;lt;init&amp;gt;(ExtendedMessageFormat.java:128)
	at org.apache.commons.lang3.text.ExtendedMessageFormat.&amp;lt;init&amp;gt;(ExtendedMessageFormat.java:113)
	at test.TestExtendedMessageFormat.main(TestExtendedMessageFormat.java:16)


I will attach a source</description>
			<version>3.2</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.ExtendedMessageFormat.java</file>
			<file type="M">org.apache.commons.lang3.text.ExtendedMessageFormatTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1104" opendate="2015-04-01 02:10:12" fixdate="2015-04-01 04:10:23" resolution="Fixed">
		<buginformation>
			<summary>FastDateParserTest.testParses fails in TimeZone America/Sao_Paulo</summary>
			<description>Build works fine with Java 7 and Maven 3.2
Apache Maven 3.2.5 (12a6b3acb947671f09b81f49094c53f426d8cea1; 2014-12-14T15:29:23-02:00)
Maven home: /opt/apache-maven-3.2.5
Java version: 1.7.0_76, vendor: Oracle Corporation
Java home: /usr/lib/jvm/java-7-oracle/jre
Default locale: en_US, platform encoding: UTF-8
OS name: "linux", version: "3.16.0-33-generic", arch: "amd64", family: "unix"
The following test failed though:
org.apache.commons.lang3.time.FastDateFormat_ParserTest:
java.lang.AssertionError: ms_MY Sat Feb 10 01:53:32 BRT 1900 GGGG/yyyy/MMMM/dddd/hhhh/mmmm/ss/aaaa/EEEE/ZZZZ
America/New_York expected:&amp;lt;Sat Feb 10 01:53:32 BRT 1900&amp;gt; but was:&amp;lt;Sat Feb 10 01:53:04
BRT 1900&amp;gt;
Build fails with Java 8 and Maven 3.2. Same test fails.
Failed tests: 
  FastDateFormat_ParserTest&amp;gt;FastDateParserTest.testParses:250-&amp;gt;FastDateParserTest.validateSdfFormatFdpParseEquality:227 
Sat Feb 10 01:53:32 BRT 1900 GGGG/yyyy/MMMM/dddd/hhhh/mmmm/ss/aaaa/EEEE/ZZZZ America/New_York
expected:&amp;lt;Sat Feb 10 01:53:32 BRT 1900&amp;gt; but was:&amp;lt;Sat Feb 10 01:53:04 BRT 1900&amp;gt;
My time zone is set to America/Sao_Paulo, GMT -3,
and I suspect that that failing test is in someway related to my time zone.</description>
			<version>4.0</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDateParserTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="794" opendate="2012-03-16 23:15:36" fixdate="2015-04-03 12:02:36" resolution="Fixed">
		<buginformation>
			<summary>SystemUtils.IS_OS_WINDOWS_2008, VISTA are incorrect</summary>
			<description>On Windows Server 2008 R2 (a Rackspace Cloud Instance), the values of SystemUtils.IS_OS_WINDOWS_2008 and SystemUtils.IS_OS_WINDOWS_VISTA are incorrect: the former is false and the latter is true.
I&amp;amp;apos;m not sure how to fix the VISTA flag (as I don&amp;amp;apos;t have an instance to test against), but the cause of WINDOWS_2008 being set to false is that the match explicitly requires the version to be 6.1, where 6.0 can apparently also be the version number for 2008 R2.</description>
			<version>3.1</version>
			<fixedVersion>3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.SystemUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1069" opendate="2014-11-25 12:36:57" fixdate="2015-04-11 06:09:55" resolution="Fixed">
		<buginformation>
			<summary>CharSet.getInstance documentation does not clearly explain how to include negation character in set</summary>
			<description>As discussed in this Stack Overflow question, the documentation for CharSet.getInstance() don&amp;amp;apos;t explain clearly how to include the negation character (^) as a literal character.
The two solutions suggested in the SO question are:


// Add the &amp;amp;apos;^&amp;amp;apos; on its own
CharSet.getInstance("^", "otherlettershere");

// Add the &amp;amp;apos;^&amp;amp;apos; as the last character
CharSet.getInstance("otherlettershere^")


If those are the best options, we should add a line to the Javadoc to indicate this. If there is a better way, clearly that should be documented instead.</description>
			<version>3.3.2</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.CharSet.java</file>
			<file type="M">org.apache.commons.lang3.CharSetTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1112" opendate="2015-04-09 07:47:19" fixdate="2015-04-18 18:45:26" resolution="Fixed">
		<buginformation>
			<summary>MultilineRecursiveToStringStyle largely unusable due to being package-private</summary>
			<description>The new MultilineRecursiveToStringStyle which was added under LANG-1052 is a package-private scoped class (no specific scope is specified for the class). I&amp;amp;apos;m assuming, like RecursiveToStringStyle, it should be public instead?</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.builder.MultilineRecursiveToStringStyle.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1181</link>
		</links>
	</bug>
	<bug id="1116" opendate="2015-04-17 20:46:09" fixdate="2015-04-30 23:29:12" resolution="Fixed">
		<buginformation>
			<summary>DateUtilsTest.testLang530 fails for some timezones</summary>
			<description>Unit test for testLang530 fails when the isoDateStr comes out with just a Z instead of +00:00.


Tests run: 38, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.014 sec &amp;lt;&amp;lt;&amp;lt; FAILURE! - in org.apache.commons.lang3.time.DateUtilsTest
testLang530(org.apache.commons.lang3.time.DateUtilsTest)  Time elapsed: 0.005 sec  &amp;lt;&amp;lt;&amp;lt; ERROR!
java.text.ParseException: Unable to parse the date: 2015-04-17T18:51:52Z
        at org.apache.commons.lang3.time.DateUtils.parseDateWithLeniency(DateUtils.java:401)
        at org.apache.commons.lang3.time.DateUtils.parseDate(DateUtils.java:301)
        at org.apache.commons.lang3.time.DateUtils.parseDate(DateUtils.java:278)
        at org.apache.commons.lang3.time.DateUtilsTest.testLang530(DateUtilsTest.java:1222)


On a Linux machine where this test passes, isoDateStr is 2015-04-17T19:26:03+00:00.</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.DateUtils.java</file>
			<file type="M">org.apache.commons.lang3.time.DateFormatUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="916" opendate="2013-09-13 01:19:23" fixdate="2015-05-01 02:29:01" resolution="Fixed">
		<buginformation>
			<summary>CLONE - DateFormatUtils.format does not correctly change Calendar TimeZone in certain situations</summary>
			<description>In LANG-538 issue, there is an unit test:

  public void testFormat_CalendarIsoMsZulu() {
    final String dateTime = "2009-10-16T16:42:16.000Z";
    GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT-8"));
    cal.clear();
    cal.set(2009, 9, 16, 8, 42, 16);
    cal.getTime();

    FastDateFormat format = FastDateFormat.getInstance("yyyy-MM-dd&amp;amp;apos;T&amp;amp;apos;HH:mm:ss.SSS&amp;amp;apos;Z&amp;amp;apos;", TimeZone.getTimeZone("GMT"));
    assertEquals("dateTime", dateTime, format.format(cal));
  }


This test passes successfully in lang-2.6 but failed in lang3-3.1:

org.junit.ComparisonFailure: dateTime expected:&amp;lt;2009-10-16T[16]:42:16.000Z&amp;gt; but was:&amp;lt;2009-10-16T[08]:42:16.000Z&amp;gt;


Reproduced whit Sun Java version: 1.6.0_45 and 1.7.0_21 on Fedora 17 (Linux 3.9.10-100.fc17.i686.PAE).
Moreover, I wrote another unit test showing that the timeZone parameter seems to be ignored :

public void test() {
	Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("Europe/Paris"));
	cal.set(2009, 9, 16, 8, 42, 16);

	// System.out.println(DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(cal));

	System.out.println("long");
	System.out.println(DateFormatUtils.format(cal.getTimeInMillis(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getDefault()));
	System.out.println(DateFormatUtils.format(cal.getTimeInMillis(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(),
			TimeZone.getTimeZone("Asia/Kolkata")));
	System.out.println(DateFormatUtils.format(cal.getTimeInMillis(), DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(),
			TimeZone.getTimeZone("Europe/London")));

	System.out.println("calendar");
	System.out.println(DateFormatUtils.format(cal, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getDefault()));
	System.out.println(DateFormatUtils.format(cal, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone("Asia/Kolkata")));
	System.out.println(DateFormatUtils.format(cal, DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern(), TimeZone.getTimeZone("Europe/London")));

	System.out.println("calendar fast");
	System.out.println(FastDateFormat.getInstance("yyyy-MM-dd&amp;amp;apos;T&amp;amp;apos;HH:mm:ss.SSS&amp;amp;apos;Z&amp;amp;apos;", TimeZone.getTimeZone("Europe/Paris")).format(cal));
	System.out.println(FastDateFormat.getInstance("yyyy-MM-dd&amp;amp;apos;T&amp;amp;apos;HH:mm:ss.SSS&amp;amp;apos;Z&amp;amp;apos;", TimeZone.getTimeZone("Asia/Kolkata")).format(cal));
	System.out.println(FastDateFormat.getInstance("yyyy-MM-dd&amp;amp;apos;T&amp;amp;apos;HH:mm:ss.SSS&amp;amp;apos;Z&amp;amp;apos;", TimeZone.getTimeZone("Europe/London")).format(cal));
}


Gives the following console logs:

long
2009-10-16T08:42:16+02:00
2009-10-16T12:12:16+05:30
2009-10-16T07:42:16+01:00
calendar
2009-10-16T08:42:16+02:00
2009-10-16T08:42:16+02:00
2009-10-16T08:42:16+02:00
calendar fast
2009-10-16T08:42:16.975Z
2009-10-16T08:42:16.975Z
2009-10-16T08:42:16.975Z


When DateFormatUtils.format takes a long parameter, the time string is good.
When DateFormatUtils.format takes a Calendar parameter, the time string is wrong, the timezone parameter is IGNORED.</description>
			<version>3.1</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.DateFormatUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinterTest.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinterTimeZonesTest.java</file>
			<file type="M">org.apache.commons.lang3.time.DurationFormatUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.time.DatePrinter.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinter.java</file>
			<file type="M">org.apache.commons.lang3.time.DateFormatUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Cloners" description="is a clone of">538</link>
			<link type="Reference" description="relates to">1092</link>
			<link type="Reference" description="is related to">1127</link>
			<link type="Required" description="requires">1123</link>
		</links>
	</bug>
	<bug id="1132" opendate="2015-05-06 03:32:29" fixdate="2015-05-07 18:46:07" resolution="Fixed">
		<buginformation>
			<summary>ReflectionToStringBuilder doesn&amp;apos;t throw IllegalArgumentException when the constructor&amp;apos;s object param is null</summary>
			<description>Placeholder for https://github.com/apache/commons-lang/pull/85

As described in it&amp;amp;apos;s javadoc, ReflectionToStringBuilder constructor will throw IllegalArgumentException if the Object to build a toStringfor is null, while in fact it won&amp;amp;apos;t.</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.builder.ReflectionToStringBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1133" opendate="2015-05-06 21:34:39" fixdate="2015-05-09 23:48:04" resolution="Fixed">
		<buginformation>
			<summary>FastDateParser_TimeZoneStrategyTest#testTimeZoneStrategyPattern fails on Windows with German Locale</summary>
			<description>FastDateParser_TimeZoneStrategyTest#testTimeZoneStrategyPattern() on current master fails:
java.lang.AssertionError: Franzsisch:Heure d&amp;amp;apos;Europe de l&amp;amp;apos;Est UTC+3
	at org.junit.Assert.fail(Assert.java:88)
	at org.junit.Assert.assertTrue(Assert.java:41)
	at org.apache.commons.lang3.time.FastDateParser_TimeZoneStrategyTest.testTimeZoneStrategyPattern(FastDateParser_TimeZoneStrategyTest.java:39)
I&amp;amp;apos;m unsure why. I guess it has something to do with my German Locale and maybe Windows too.
</description>
			<version>3.5</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDateParser.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateParser_TimeZoneStrategyTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1147" opendate="2015-06-12 08:16:54" fixdate="2015-06-12 23:40:06" resolution="Fixed">
		<buginformation>
			<summary>EnumUtils *BitVector issue with more than 32 values Enum</summary>
			<description>In EnumUtils all BitVector related methods fail in handling Enums with more than 32 values.
This is due to a implicit int -&amp;gt; long conversion in generating the Enum value long mask.
Bad code : here 1 is an int value so the &amp;lt;&amp;lt; operation is done into an int context and then, the result is converted to a long value


long mask = 1 &amp;lt;&amp;lt; 32;    // -&amp;gt; mask = 1 and not 4294967296 (0x100000000)


Good code : here 1L is a long value so the &amp;lt;&amp;lt; operation is done into an long context


long mask = 1L &amp;lt;&amp;lt; 32;    // -&amp;gt; mask = 4294967296 (0x100000000)


See PR#97 : https://github.com/apache/commons-lang/pull/97</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.EnumUtils.java</file>
			<file type="M">org.apache.commons.lang3.EnumUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1141" opendate="2015-06-02 20:13:07" fixdate="2015-06-24 20:26:56" resolution="Fixed">
		<buginformation>
			<summary>StrLookup.systemPropertiesLookup() no longer reacts on changes on system properties</summary>
			<description>In versions of Commons Lang before 3.4 a Lookup object created from the systemPropertiesLookup() method offered a live view of system properties. So if a system property was changed after the creation of the lookup object, the new value was visible. In version 3.4 this is no longer the case.
The change seems to be related to LANG-1055. Here a fix was implemented which initializes a lookup object for system properties with a snapshot copy of the current properties. Changes made later on system properties are no longer reflected. I do not understand the background for this change because this is not really related to the original bug report.
I would propose an implementation which fixes the reported problem in LANG-1055 and allows a live view on system properties. Maybe the snapshot use case could still be supported by an overloaded method.</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.StrLookupTest.java</file>
			<file type="M">org.apache.commons.lang3.text.StrLookup.java</file>
		</fixedFiles>
	</bug>
	<bug id="1152" opendate="2015-07-07 15:11:10" fixdate="2015-07-08 04:16:17" resolution="Fixed">
		<buginformation>
			<summary>FastDateFormat seems to behave differently with very large dates than simple date format</summary>
			<description>Inconsistent behaviour compared to SimpleDateFormat.
StringIndexOutOfBoundsException using one format and no exception when using another format. (both legal).
Different results when using another format.
Testcase:
import org.apache.commons.lang3.time.FastDateFormat;
import org.hamcrest.Matchers;
import org.junit.Assert;
import org.junit.Test;
import java.text.SimpleDateFormat;
import java.util.Date;
public class FastDateFormatBug {
    @Test
    public void testFastFormatWitLongMaxValue()
{
        Date date = new Date(Long.MAX_VALUE);
        String dateAsString = FastDateFormat.getInstance("yyyy-MM-dd").format(date);
        Assert.assertThat(dateAsString, Matchers.equalTo("292278994-08-17"));
    }

    @Test
    public void testWeirdResultWithMaxValue()
{
        Date date = new Date(Long.MAX_VALUE);
        String dateAsString = FastDateFormat.getInstance("dd/MM/yyyy").format(date);
        Assert.assertThat(dateAsString, Matchers.equalTo("292278994-08-17"));
    }

    @Test
    public void testSimpleFormatWithLongMaxValueWithLenientOff()
{
        Date date = new Date(Long.MAX_VALUE);
        SimpleDateFormat fft = new SimpleDateFormat("yyyy-MM-dd");
        fft.setLenient(false);
        String dateAsString = fft.format(date);
        Assert.assertThat(dateAsString, Matchers.equalTo("292278994-08-17"));
    }

    @Test
    public void testSimpleFormatWithLongMaxValueWithLenientOn()
{
        Date date = new Date(Long.MAX_VALUE);
        SimpleDateFormat fft = new SimpleDateFormat("yyyy-MM-dd");
        fft.setLenient(true);
        String dateAsString = fft.format(date);
        Assert.assertThat(dateAsString, Matchers.equalTo("292278994-08-17"));
    }

}</description>
			<version>3.x</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinter.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateFormatTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1002" opendate="2014-04-30 20:45:25" fixdate="2015-07-08 05:51:13" resolution="Fixed">
		<buginformation>
			<summary>Several predefined ISO FastDateFormats in DateFormatUtils are incorrect</summary>
			<description>Formats ISO_TIME_FORMAT, ISO_TIME_TIME_ZONE_FORMAT prepend a T but this is not correct. Sole time is never prepended by defintion. T is used only when date and time are given.
The Javadocs of ISO_TIME_NO_T_FORMAT, ISO_TIME_NO_T_FORMAT are in correct too because they say: "This pattern does not comply with the formal ISO8601 specification as the standard requires the &amp;amp;apos;T&amp;amp;apos; prefix for times."
You might want to read Markus Kuhn&amp;amp;apos;s reference on that.
A solution would be remove the first two and rename the second two by dropping the NO_T in the name.</description>
			<version>3.3.2</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinter.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateFormat.java</file>
			<file type="M">org.apache.commons.lang3.time.DateFormatUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1142" opendate="2015-06-05 17:24:33" fixdate="2015-07-19 08:27:07" resolution="Fixed">
		<buginformation>
			<summary>StringUtils#capitalize: Javadoc says toTitleCase; code uses toUpperCase</summary>
			<description>The capitalize Javadoc says the code uses  Character#toTitleCase, however the code actually uses Character#toUpperCase.
Generally these produce the same result, but some charsets may have different characters for upper and title case - see for example the Javadoc [1] for Character#isTitleCase.
The way I read this, the character that looks like "lj" is lower-case, "LJ" is upper case and "Lj" is title case - i.e. not the same.
The question here is: should the code be corrected to use TitleCase or should the Javadoc be corrected to use UpperCase?
[1] http://docs.oracle.com/javase/7/docs/api/java/lang/Character.html#isTitleCase%28char%29</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">1059</link>
			<link type="Reference" description="is related to">1058</link>
		</links>
	</bug>
	<bug id="1162" opendate="2015-08-10 21:11:38" fixdate="2015-08-11 13:28:00" resolution="Fixed">
		<buginformation>
			<summary>StringUtils#equals fails with Index OOBE on non-Strings with identical leading prefix</summary>
			<description>From the Commons User mailing list:

StringUtils.equals(cs1,cs2) delegates to CharSequence.regionMatches(...) in a way that causes IndexOutOfBounds when either of cs1/cs2 isn&amp;amp;apos;t a String.
Specifically, comparing "foo" and "foobar" for non-String CharSequences bombs due to CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())) because regionMatches doesn&amp;amp;apos;t check for input exhaustion.</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1207</link>
			<link type="Duplicate" description="is duplicated by">1239</link>
			<link type="Reference" description="relates to">1163</link>
		</links>
	</bug>
	<bug id="1163" opendate="2015-08-11 13:26:46" fixdate="2015-08-11 13:30:50" resolution="Fixed">
		<buginformation>
			<summary>There are no tests for CharSequenceUtils.regionMatches</summary>
			<description>There are no tests for CharSequenceUtils.regionMatches.
It ought to behave the same way as the String version.
This includes not failing with Index OOBE if the CharSequences are not long enough.</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.CharSequenceUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.CharSequenceUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">1162</link>
		</links>
	</bug>
	<bug id="1182" opendate="2015-10-31 00:13:27" fixdate="2015-11-16 19:19:34" resolution="Fixed">
		<buginformation>
			<summary>Clarify JavaDoc of StringUtils.containsAny()</summary>
			<description>(1) The javadoc for StringUtils.containsAny(CharSequence cs, CharSequence... searchCharSequences) confusingly says 

StringUtils.containsAny("abcd", "ab", "cd") = false

You can verify this actually returns true by running this:
        if (!StringUtils.containsAny("abcd", "ab", "cd")) 
            throw new AssertionError("Third sample from StringUtils 3.4 javadoc");
(2) The javadoc for containsAny(final CharSequence cs, final CharSequence searchChars) is inadequate, and could easily mislead naive readers to believe this containsAny() looks for a matching sequence (substring) rather than characters in a set:

StringUtils.containsAny("zzabyycdxx", "za") = true
StringUtils.containsAny("zzabyycdxx", "by") = true

In other words, both examples would be equally true for StringUtils.contains().  I suggest adding clarifying examples, like:

StringUtils.containsAny("zzabyycdxx", "\tx") = true
StringUtils.containsAny("zzabyycdxx", "$.#yF") = true

</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1181" opendate="2015-10-29 01:33:19" fixdate="2015-11-19 21:28:08" resolution="Duplicate">
		<buginformation>
			<summary>MultilineRecursiveToStringStyle is not public</summary>
			<description>The public access modifier is missing from the MultilineRecursiveToStringStyle class. </description>
			<version>3.4</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.builder.MultilineRecursiveToStringStyle.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1112</link>
		</links>
	</bug>
	<bug id="1193" opendate="2015-12-11 10:30:14" fixdate="2015-12-11 13:47:20" resolution="Fixed">
		<buginformation>
			<summary>ordinalIndexOf("abc", "ab", 1) gives incorrect answer of -1 (correct answer should be 0)</summary>
			<description>In Apache Commons Lang 3.4, StringUtils.ordinalIndexOf("abc", "ab", 1) gives incorrect answer of -1 (correct answer should be 0)but StringUtils.ordinalIndexOf("abc", "a", 1) gives correct answer of 0.
Based on the above mentioned observation, the bug occurrs if the searchStr is of length &amp;gt; 1, and locates at the index 0 of the str.
In Apache Commons Lang 2.6, this bug is not observed.</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">1077</link>
		</links>
	</bug>
	<bug id="1192" opendate="2015-12-10 08:16:10" fixdate="2015-12-25 20:50:17" resolution="Fixed">
		<buginformation>
			<summary>FastDateFormat does not support the week-year component (uppercase &amp;apos;Y&amp;apos;)</summary>
			<description>The Java SimpleDateFormat supports two year-components, &amp;amp;apos;y&amp;amp;apos; for normal year and &amp;amp;apos;Y&amp;amp;apos; for &amp;amp;apos;Week year&amp;amp;apos;, see http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html
However when we try to use FastDateFormat to parse a format which uses the week-year, it fails with an exception

java.lang.IllegalArgumentException: Illegal pattern component: YYYY
	at org.apache.commons.lang3.time.FastDatePrinter.parsePattern(FastDatePrinter.java:282)
	at org.apache.commons.lang3.time.FastDatePrinter.init(FastDatePrinter.java:149)
	at org.apache.commons.lang3.time.FastDatePrinter.&amp;lt;init&amp;gt;(FastDatePrinter.java:142)
	at org.apache.commons.lang3.time.FastDateFormat.&amp;lt;init&amp;gt;(FastDateFormat.java:384)
	at org.apache.commons.lang3.time.FastDateFormat.&amp;lt;init&amp;gt;(FastDateFormat.java:369)
	at org.apache.commons.lang3.time.FastDateFormat$1.createInstance(FastDateFormat.java:91)
	at org.apache.commons.lang3.time.FastDateFormat$1.createInstance(FastDateFormat.java:88)
	at org.apache.commons.lang3.time.FormatCache.getInstance(FormatCache.java:82)
	at org.apache.commons.lang3.time.FastDateFormat.getInstance(FastDateFormat.java:119)


Simple unit test to reproduce this:


    @Test
    public void testCommonsLang() {
    	Date date = new Date();

    	Format dateFormat = new SimpleDateFormat("YYYY");
		assertNotNull(dateFormat.format(date));

        dateFormat = FastDateFormat.getInstance("YYYY");
		assertNotNull(dateFormat.format(date));
    }

</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDateParser.java</file>
			<file type="M">org.apache.commons.lang3.time.DateParser.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateFormat.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinter.java</file>
			<file type="D">org.apache.commons.lang3.time.WeekYearTest.java</file>
			<file type="D">org.apache.commons.lang3.time.CalendarReflection.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinterTest.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateParserTest.java</file>
		</fixedFiles>
		<links>
			<link type="Blocker" description="is blocked by">1194</link>
			<link type="Duplicate" description="is duplicated by">1209</link>
		</links>
	</bug>
	<bug id="1200" opendate="2016-01-14 22:08:39" fixdate="2016-01-14 22:12:21" resolution="Fixed">
		<buginformation>
			<summary>StringUtils.ordinalIndexOf: Add missing right parenthesis in JavaDoc example</summary>
			<description>https://github.com/apache/commons-lang/pull/120</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1191" opendate="2015-12-08 11:56:20" fixdate="2016-01-26 18:52:03" resolution="Fixed">
		<buginformation>
			<summary>Incorrect Javadoc StringUtils.containsAny(CharSequence, CharSequence...) </summary>
			<description>Javadoc for boolean org.apache.commons.lang3.StringUtils.containsAny(CharSequence cs, CharSequence... searchCharSequences) says:
StringUtils.containsAny("abcd", "ab", "cd") = false
which is not true. It should be:
StringUtils.containsAny("abcd", "ab", "cd") = true</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1207" opendate="2016-02-24 14:23:59" fixdate="2016-02-24 14:45:03" resolution="Duplicate">
		<buginformation>
			<summary>StringUtils.equals with CharSequence - IndexOutOfBoundsException</summary>
			<description>Good day,
This is my first report here, so I&amp;amp;apos;m really sorry if I did not fill in the form right .
I just ran into a bug with the method 
public static boolean equals(final CharSequence cs1, final CharSequence cs2).
If one of the object is not the String object, the method use the CharSequenceUtils to check the equality. 
The problem is that using Math.max(cs1.length(), cs2.length()) give the max length of the 2 objects. Then 1 of the object throw IndexOutOfBoundsException.
I think it will be better to check the size before using CharSequenceUtils as the method equalsIgnoreCase.
Maybe this code could correct the bug :
if (cs1 == cs2) 
{
    return true;
}
 else if (cs1 == null || cs2 == null) 
{
    return false;
} else if (cs1.length() != cs2.length()) {
    return false;
}
 else if (cs1 instanceof String &amp;amp;&amp;amp; cs2 instanceof String) 
{
    return cs1.equals(cs2);
}
 else 
{
    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());
}

Kind regards,</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1162</link>
		</links>
	</bug>
	<bug id="1209" opendate="2016-02-26 20:04:40" fixdate="2016-03-01 06:48:24" resolution="Duplicate">
		<buginformation>
			<summary>FastDateFormat does not support the &amp;apos;u&amp;apos; pattern element</summary>
			<description>java.lang.IllegalArgumentException: Illegal pattern component: u</description>
			<version>2.6</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDateParser.java</file>
			<file type="M">org.apache.commons.lang3.time.DateParser.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateFormat.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinter.java</file>
			<file type="D">org.apache.commons.lang3.time.WeekYearTest.java</file>
			<file type="D">org.apache.commons.lang3.time.CalendarReflection.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinterTest.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateParserTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1192</link>
		</links>
	</bug>
	<bug id="1219" opendate="2016-04-21 14:09:50" fixdate="2016-04-23 20:04:01" resolution="Fixed">
		<buginformation>
			<summary>FastDateFormat doesn&amp;apos;t respect summer daylight in localized strings</summary>
			<description>FastDateFormat can&amp;amp;apos;t properly parse dates with daylight saving in the "z" pattern. It always returns date without daylight saving. Test case:


		SimpleDateFormat format = new SimpleDateFormat("dd.MM.yyyy HH:mm:ss z", Locale.GERMANY);
		Date d1 = format.parse("26.10.2014 02:00:00 MESZ");
		Date d2 = format.parse("26.10.2014 02:00:00 MEZ");
		System.out.println(d1);
		System.out.println(d2);
		FastDateFormat formatt = FastDateFormat.getInstance("dd.MM.yyyy HH:mm:ss z", Locale.GERMANY);
		Date d3 = formatt.parse("26.10.2014 02:00:00 MESZ");
		Date d4 = formatt.parse("26.10.2014 02:00:00 MEZ");
		System.out.println(d3);
		System.out.println(d4);	


returns:
SDF: Sun Oct 26 02:00:00 CEST 2014
SDF: Sun Oct 26 02:00:00 CET 2014
FDF: Sun Oct 26 02:00:00 CET 2014
FDF:  Sun Oct 26 02:00:00 CET 2014
FastDateFormat returns the same date, which is wrong.
Bug is in the FastDateParser.TimeZoneStrategy.setCalendar:


@Override
        void setCalendar(final FastDateParser parser, final Calendar cal, final String value) {
            TimeZone tz;
            if(value.charAt(0)==&amp;amp;apos;+&amp;amp;apos; || value.charAt(0)==&amp;amp;apos;-&amp;amp;apos;) {
                tz= TimeZone.getTimeZone("GMT"+value);
            }
            else if(value.startsWith("GMT")) {
                tz= TimeZone.getTimeZone(value);
            }
            else {
                tz= tzNames.get(value);
                if(tz==null) {
                    throw new IllegalArgumentException(value + " is not a supported timezone name");
                }
            }
            cal.setTimeZone(tz);
        }


It&amp;amp;apos;s not enough to just call: cal.setTimeZone.
If zone names in standard and daylight time are different, you have to check the name in DateFormatSymbols.getInstance(locale).getZoneStrings(); and if it&amp;amp;apos;s &amp;gt;= 3, you have to activate daylight mode.Just like SimpleDateFormat does it:


1491            // (abbreviation) for both standard and daylight time,
1492            // let the time zone in the Calendar decide which one.
1493            if (!useSameName) {
1494                calendar.set(Calendar.ZONE_OFFSET, tz.getRawOffset());
1495                calendar.set(Calendar.DST_OFFSET,
1496                             j &amp;gt;= 3 ? tz.getDSTSavings() : 0);
1497            }

</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDateParser.java</file>
			<file type="M">org.apache.commons.lang3.time.FastDateParser_TimeZoneStrategyTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1205" opendate="2016-02-23 16:40:09" fixdate="2016-04-24 03:37:53" resolution="Fixed">
		<buginformation>
			<summary>NumberUtils.createNumber() behaves inconsistently with NumberUtils.isNumber()</summary>
			<description>The NumberUtils.createNumber() method fails to check for multiple trailing characters, and as a result, it returns a value even though NumberUtils.isNumber() indicates that it should not.  For example:


boolean isNumber = NumberUtils.isNumber("81.5514DD");   // returns false

Number numValue = NumberUtils.createNumber("81.5514DD");  // returns a Double value, 81.5514


I would expect the createNumber() method to throw a NumberFormatException in this case.</description>
			<version>3.1</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.math.NumberUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1232" opendate="2016-05-19 17:39:34" fixdate="2016-05-19 17:54:38" resolution="Fixed">
		<buginformation>
			<summary>DiffBuilder: Add null check on fieldName when appending Object or Object[]</summary>
			<description>The other append methods throw an IllegalArgumentException if fieldName is null. So, append(Object) and append(Object[]) should also do this.
source: https://github.com/apache/commons-lang/pull/121</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.builder.DiffBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1239" opendate="2016-05-27 07:59:56" fixdate="2016-05-27 10:04:19" resolution="Duplicate">
		<buginformation>
			<summary>StringUtils.equals("",new StringBuffer("foo")) throws StringIndexOutOfBoundsException</summary>
			<description></description>
			<version>3.4</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsEqualsIndexOfTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1162</link>
		</links>
	</bug>
	<bug id="901" opendate="2013-06-19 14:53:05" fixdate="2016-05-28 10:50:31" resolution="Fixed">
		<buginformation>
			<summary>endsWithAny is case sensitive - documented as case insensitive</summary>
			<description>endsWithAny was added in response to this task: LANG-614
Documentation says that the method returns "true if the CharSequence starts with any of the the prefixes, case insensitive, or both null" 
StringUtils.endsWithAny("MIME/TYPE", "TYPE") true
StringUtils.endsWithAny("MIME/TYPE", "type") false</description>
			<version>3.1</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsStartsEndsWithTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1120" opendate="2015-04-28 09:55:33" fixdate="2016-05-28 10:57:43" resolution="Fixed">
		<buginformation>
			<summary>StringUtils.stripAccents from "" and ""</summary>
			<description>

import org.apache.commons.lang3.StringUtils;

public class Main {

    public static void main(String[] args) {
        System.out.println(StringUtils.stripAccents(" "));
    }
}

</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsTrimEmptyTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1178" opendate="2015-10-24 13:42:12" fixdate="2016-05-28 11:16:42" resolution="Fixed">
		<buginformation>
			<summary>ArrayUtils.removeAll(Object array, int... indices) should do the clone, not its callers</summary>
			<description>The method ArrayUtils.removeAll(Object array, int... indices) currently sorts the input indices array. Therefore the array needs to be cloned; this is currently done by the callers.
However the sort is an implementation detail of the method, so should be done by the method itself, not by the callers, which is fragile (easy to overlook when creating a new method) and unnecessary.
This would also allow the method to be more easily changed to a different implementation that does not need to sort the array (e.g. using BitSet)</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.ArrayUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1189" opendate="2015-12-03 19:54:28" fixdate="2016-06-02 10:47:14" resolution="Fixed">
		<buginformation>
			<summary>Add getAndIncrement/getAndDecrement/getAndAdd/incrementAndGet/decrementAndGet/addAndGet in Mutable* classes</summary>
			<description>Add below methods to Mutable* classes:
    getAndIncrement
    getAndDecrement
    getAndAdd
    incrementAndGet
    decrementAndGet
    addAndGet</description>
			<version>3.5</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.mutable.MutableShort.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableDouble.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableInt.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableFloat.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableLong.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableByte.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableIntTest.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableDoubleTest.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableShortTest.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableLongTest.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableFloatTest.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableByteTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1235</link>
		</links>
	</bug>
	<bug id="1235" opendate="2016-05-20 19:37:59" fixdate="2016-06-02 10:48:54" resolution="Duplicate">
		<buginformation>
			<summary>Add decrementAndGet/incrementAndGet to MutableInt class</summary>
			<description>Frequently when incrementing or decrementing a number, one needs to compare it to a limit. For example in loops.
At present that requires two calls:
MutableInt.decrement()
MutableInt.getValue()
It would be convenient to have a method that combined the two.
c.f. AtomicInteger.decrementAndGet()
There is less likelihood of needing these methods for other Mutable Number types as they are not often used in loops.</description>
			<version>3.5</version>
			<fixedVersion></fixedVersion>
			<type>New Feature</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.mutable.MutableShort.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableDouble.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableInt.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableFloat.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableLong.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableByte.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableIntTest.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableDoubleTest.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableShortTest.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableLongTest.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableFloatTest.java</file>
			<file type="M">org.apache.commons.lang3.mutable.MutableByteTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1189</link>
			<link type="Reference" description="relates to">1176</link>
		</links>
	</bug>
	<bug id="1242" opendate="2016-05-30 18:59:30" fixdate="2016-06-02 20:16:24" resolution="Fixed">
		<buginformation>
			<summary> "\u2284":"&amp;nsub;" mapping missing from EntityArrays#HTML40_EXTENDED_ESCAPE</summary>
			<description>see: https://github.com/apache/commons-lang/pull/159</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.translate.EntityArrays.java</file>
		</fixedFiles>
	</bug>
	<bug id="1199" opendate="2016-01-13 15:54:32" fixdate="2016-06-05 15:40:28" resolution="Fixed">
		<buginformation>
			<summary>Fix implementation of StringUtils.getJaroWinklerDistance()</summary>
			<description>The current implementation of StringUtils.getJaroWinklerDistance() does not compute the correct result in some cases. See #LANG-944 for the initial code contribution.
StringUtils.getJaroWinklerDistance("Haus Ingeborg", "Ingeborg Esser") == 0.0
This is due to the incorrect computation of common characters, which causes the algorithm to exit prematurely.
In contrast, the implementation in Lucene gives ~0.63, which is about right.
    JaroWinklerDistance d = new JaroWinklerDistance();
    getDistance("Haus Ingeborg", "Ingeborg Esser");
See https://lucene.apache.org/core/3_0_3/api/contrib-spellchecker/org/apache/lucene/search/spell/JaroWinklerDistance.html</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">26</link>
		</links>
	</bug>
	<bug id="1229" opendate="2016-05-15 14:27:36" fixdate="2016-06-08 20:34:48" resolution="Fixed">
		<buginformation>
			<summary>Performance regression due to cyclic hashCode guard</summary>
			<description>We observed a severe performance regression in HashCodeBuilder in 3.5 trunk compared to 3.4 release. We get about 20% of the throughput in 3.5 trunk for common cases compared to 3.4 release. Previously there was no noticeable overhead of using HashCodeBuilder. Investigating we found the performance degradation was caused by the fix for LANG-456. It causes the method to be too large to be inlined and escape analysis to fail (see LANG-1218 for a related discussion).
We currently do not see a way to keep the 3.4 performance and support cyclic graphs. The append methods have not supported cycles for so long we feel it&amp;amp;apos;s de facto part of the contract by now. Since neither the JDK nor the Guava hashCode helper methods support cyclic graphs we don&amp;amp;apos;t believe this is an unreasonable assumption. In addition EqualsBuilder#append(Object,Object) doesn&amp;amp;apos;t support cycles.
If supporting cycles is a requirement we propose the introduction of new #appendRecursive (or named differently) methods to both HashCodeBuilder and EqualsBuilder that add cycle guards. If that is an acceptable compromise we would be willing to provide patches.</description>
			<version>3.5</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.builder.HashCodeBuilder.java</file>
			<file type="M">org.apache.commons.lang3.builder.HashCodeBuilderTest.java</file>
		</fixedFiles>
		<links>
			<link type="Regression" description="is broken by">456</link>
		</links>
	</bug>
	<bug id="1215" opendate="2016-03-31 09:18:11" fixdate="2016-06-12 08:25:20" resolution="Duplicate">
		<buginformation>
			<summary>NumberUtils.createNumber() method lost precision sometimes</summary>
			<description>For example:
    System.out.println(NumberUtils.createNumber("193343.82"));
The result  is   193343.81
The bug because of  code in the class  NumberUtils of the org.apache.commons.lang3.math package
    public static Float createFloat(final String str) {
        if (str == null) 
{
            return null;
        }
        return Float.valueOf(str);
    }</description>
			<version>2.6</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.math.NumberUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1018</link>
		</links>
	</bug>
	<bug id="1187" opendate="2015-11-24 12:06:49" fixdate="2016-06-12 08:27:24" resolution="Duplicate">
		<buginformation>
			<summary>Method createNumber from NumberUtils doesn&amp;apos;t work for floating point numbers other than Float</summary>
			<description>demo:
 Number n = org.apache.commons.lang3.math.NumberUtils.createNumber("6264583.33");
        System.out.println("lang3_createNumber_6264583.33----&amp;gt;" + n);
while n will be 6264583.5. not 6264583.33</description>
			<version>3.4</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.math.NumberUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1018</link>
		</links>
	</bug>
	<bug id="1018" opendate="2014-05-27 10:24:53" fixdate="2016-06-12 11:29:48" resolution="Fixed">
		<buginformation>
			<summary>NumberUtils.createNumber(final String str)  Precision will be lost</summary>
			<description>With commons-lang 3.2.2:
NumberUtils.createNumber("-160952.54");
The result is "-160952.55".
Should not be based on the length of the decimal point number to judge whether the floating point number.
Using the method (createFloat(str)) of dealing with the valid number greater than seven Numbers will cause accuracy loss.
The source code is as follows:


try {
            if(numDecimals &amp;lt;= 7){// If number has 7 or fewer digits past the decimal point then make it a float
                final Float f = createFloat(str);
                if (!(f.isInfinite() || (f.floatValue() == 0.0F &amp;amp;&amp;amp; !allZeros))) {
                    return f;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }
        try {
            if(numDecimals &amp;lt;= 16){// If number has between 8 and 16 digits past the decimal point then make it a double
                final Double d = createDouble(str);
                if (!(d.isInfinite() || (d.doubleValue() == 0.0D &amp;amp;&amp;amp; !allZeros))) {
                    return d;
                }
            }
        } catch (final NumberFormatException nfe) { // NOPMD
            // ignore the bad number
        }

        return createBigDecimal(str);
    }

</description>
			<version>3.3.2</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.math.NumberUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1187</link>
			<link type="Duplicate" description="is duplicated by">1215</link>
		</links>
	</bug>
	<bug id="1245" opendate="2016-06-14 05:15:53" fixdate="2016-06-15 17:40:52" resolution="Fixed">
		<buginformation>
			<summary>signature change of applyRules(java.util.Calendar, java.lang.StringBuffer) is not binary compatible</summary>
			<description>add back method
 java.lang.StringBuffer applyRules(java.util.Calendar, java.lang.StringBuffer)</description>
			<version>3.5</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1248" opendate="2016-07-05 14:54:04" fixdate="2016-07-17 02:33:37" resolution="Fixed">
		<buginformation>
			<summary>FastDatePrinter Memory allocation regression</summary>
			<description>when the code was migrated from StringBuffer to Appendable in LANG-1152.
We&amp;amp;apos;ve lost the ability to modify the buffer (setCharAt) 
The new implementation of appendFullDigits allocate a temporary char array to work around that limitation.
This is a major source of memory allocation which is not present in version 3.4.</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDatePrinter.java</file>
		</fixedFiles>
	</bug>
	<bug id="1202" opendate="2016-01-18 16:34:59" fixdate="2016-07-26 03:18:58" resolution="Fixed">
		<buginformation>
			<summary>parseDateStrictly does&amp;apos;t pass specified locale</summary>
			<description>LANG-799 added support for specifying a locale, but parseDateStrictly() doesn&amp;amp;apos;t pass it to the final parseDateWithLeniency() method.</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.DateUtils.java</file>
			<file type="M">org.apache.commons.lang3.time.DateUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">799</link>
		</links>
	</bug>
	<bug id="1251" opendate="2016-07-27 05:18:01" fixdate="2016-07-31 17:51:29" resolution="Fixed">
		<buginformation>
			<summary>SerializationUtils.ClassLoaderAwareObjectInputStream should use static initializer to initialize primitiveTypes map.</summary>
			<description>SerializationUtils.ClassLoaderAwareObjectInputStream should use static initializer to initialize primitiveTypes map because initializing the map in the constructor of ClassLoaderAwareObjectInputStream would break thread safety. java.util.HashMap is not thread safe.</description>
			<version>3.2</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.SerializationUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1226" opendate="2016-05-08 18:10:16" fixdate="2016-07-31 17:58:59" resolution="Fixed">
		<buginformation>
			<summary>StringUtils#normalizeSpace does not trim the string anymore</summary>
			<description>These work with 3.3.2, but fail with 3.4:


assertEquals("b", StringUtils.normalizeSpace("\u0000b"));
assertEquals("b", StringUtils.normalizeSpace("b\u0000"));


Java doc still says "... Additionally #trim(String)} removes control characters (char &amp;lt;= 32) from both ends of this String."</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Regression" description="is broken by">1020</link>
		</links>
	</bug>
	<bug id="1190" opendate="2015-12-07 19:39:32" fixdate="2016-07-31 18:03:21" resolution="Fixed">
		<buginformation>
			<summary>TypeUtils.isAssignable throws NullPointerException when fromType has type variables and toType generic superclass specifies type variable</summary>
			<description>

import static org.apache.commons.lang3.reflect.TypeUtils.*;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Type;
import java.util.ArrayList;

public class Demonstration {

    public static &amp;lt;U&amp;gt; Iterable&amp;lt;U&amp;gt; someMethod() { return null; }
    
    public static class WorkingClass extends ArrayList { }
    public static class FailingClass extends ArrayList&amp;lt;Object&amp;gt; { }
    
    
    public static void main(String[] args) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        Type fromType = Demonstration.class.getDeclaredMethod("someMethod").getGenericReturnType();
        Type workingToType = wildcardType().withLowerBounds(WorkingClass.class).build();
        Type failingToType = wildcardType().withLowerBounds(FailingClass.class).build();
        
        System.out.println(fromType);
        System.out.println(workingToType);
        System.out.println(failingToType);
        
        System.out.println(isAssignable(fromType, workingToType));
        System.out.println(isAssignable(fromType, failingToType));
    }
}

</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.reflect.TypeUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.reflect.TypeUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1214" opendate="2016-03-29 10:36:34" fixdate="2016-08-21 11:19:10" resolution="Fixed">
		<buginformation>
			<summary>ClassUtils.getClass(ClassLoader, String) fails for "void"</summary>
			<description>ClassUtils.getClass(ClassUtils.class.getClassLoader(), "void") throws "ClassNotFoundException: [V".
Root cause: ClassUtils contains an abbreviationMap for use in dealing with abbreviated primitive types like "[I" and "[J". However, this commit introduces a "void -&amp;gt; V" mapping for "completeness".
This seems wholly erroneous, since the maps are used only for primitive array abbreviations, and "void/V" is not among them.</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.ClassUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.ClassUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1230" opendate="2016-05-16 08:29:17" fixdate="2016-08-21 17:18:40" resolution="Fixed">
		<buginformation>
			<summary>Remove unnecessary synchronization from registry lookup in EqualsBuilder and HashCodeBuilder</summary>
			<description>We&amp;amp;apos;re running into contention issues in registry lookup in EqualsBuilder and HashCodeBuilder. We believe the synchronization for the registry lookup is unnecessary. ThreadLocals are thread safe, each thread gets own value. Therefore no other thread can read or change the value of the current thread. As a consequence access to ThreadLocals does not need to be synchronized.
Since IDKey uses object identity and the identity hashCode it does use neither EqualsBuilder nor HashCodeBuilder. This means that recursive calls to register and unregister are not possible even if the registered objects use EqualsBuilder or HashCodeBuilder. This also makes re-reading redundant.
The issue was likely introduced in 2.5 by LANG-586 but 2.6 is the oldest version we can select.</description>
			<version>2.6</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.builder.EqualsBuilder.java</file>
			<file type="M">org.apache.commons.lang3.builder.HashCodeBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1262" opendate="2016-08-29 19:44:21" fixdate="2016-08-30 19:54:41" resolution="Fixed">
		<buginformation>
			<summary>CompareToBuilder.append(Object,Object,Comparator) method is too big to be inlined</summary>
			<description>Issue is the same as in LANG-1218: CompareToBuilder.append(Object,Object,Comparator) is quite big, due to in-place arrays processing, and thus breaching inlining threshold (325 bytecodes):

....
o.a.c.l.b.CompareToBuilder::append (346 bytes)   hot method too big
....


This prevents CompareToBuilder object itself from being scalarized.
Fix may be the same, as in LANG-1218: extract arrays processing into separate method.</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.builder.CompareToBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1264" opendate="2016-09-11 15:47:30" fixdate="2016-09-11 19:54:58" resolution="Duplicate">
		<buginformation>
			<summary>JavaVersion does not correctly handle Java 9</summary>
			<description>See http://markmail.org/message/bgrhxr6ef2axubcf
JavaVersion assumes that the version String for Java 9 will be "1.9".</description>
			<version>3.4</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.JavaVersionTest.java</file>
			<file type="M">org.apache.commons.lang3.SystemUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.JavaVersion.java</file>
			<file type="M">org.apache.commons.lang3.SystemUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">1197</link>
		</links>
	</bug>
	<bug id="1252" opendate="2016-07-28 11:33:31" fixdate="2016-09-11 20:36:38" resolution="Fixed">
		<buginformation>
			<summary>NumberUtils.isNumber and NumberUtils.createNumber resolve inconsistently</summary>
			<description>In considering the issues LANG-1060, LANG-1040, LANG-1038, and LANG-992, it seems that there are times when NumberUtils.isNumber resolves to false while NumberUtils.createNumber, given the same input, does not throw an exception, returning a valid java.lang.Number. This inconsistency should be resolved either by making isNumber more lenient or createNumber more stringent.</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.NumberUtils.java</file>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.math.package-info.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="relates to">1060</link>
			<link type="Reference" description="relates to">992</link>
			<link type="Reference" description="relates to">1038</link>
			<link type="Reference" description="relates to">1040</link>
			<link type="Reference" description="is related to">992</link>
			<link type="Reference" description="is related to">1038</link>
			<link type="Reference" description="is related to">1040</link>
		</links>
	</bug>
	<bug id="1197" opendate="2016-01-10 17:56:49" fixdate="2016-09-17 14:37:37" resolution="Fixed">
		<buginformation>
			<summary>Prepare Java 9 detection</summary>
			<description>In anticipation of Java 9 and JEP 223, the versioning scheme will change completely. We need to reflect that in SystemUtils, JavaVersion, etc.:

SystemUtils: Deprecate IS_JAVA_1_9 and replace with IS_JAVA_9
JavaVersion: Deprecate JAVA_1_9 in JavaVersion and replace with JAVA_9

and other places in the library.</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Task</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.JavaVersionTest.java</file>
			<file type="M">org.apache.commons.lang3.SystemUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.JavaVersion.java</file>
			<file type="M">org.apache.commons.lang3.SystemUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">1264</link>
		</links>
	</bug>
	<bug id="1261" opendate="2016-08-23 08:33:12" fixdate="2016-09-18 16:02:58" resolution="Fixed">
		<buginformation>
			<summary>ArrayUtils.contains returns false for instances of subtypes</summary>
			<description>ArrayUtils.contains(Object[] array, Object objectToFind) wrongly returns false.
STEPS TO REPRODUCE
=========================================================
-Create a superclass "Parent" and override equals and hashcode based on some member id variable.
-Create a class "Child" extending "Parent". Do not override equals nor hashcode.
-Let "childrens" be an array of type Child[] containing several instances.
Create an instance of Parent "p" with the same id as childrens[0], such that childrens[0].equals(p) returns true and p.equals(childrens[0]) returns true as well.
Because they are equals, ArrayUtils.contains(childrens, p) should return true. However it returns false.
WHERE THE BUG IS LOCATED
=====================================================
-Go to ArrayUtils.class, line 1917. In the "indexOf" method implementation, before going into calling equals for each element of the input array, there is some sort of optimization check to make sure the instance to be found is an instance of the array type:
} else if (array.getClass().getComponentType().isInstance(objectToFind)) {
That line is wrong. In our case, the array contains elements of type "Child", whereas the object to be found is of type "Parent". They are equals according to the equals implementation of "Parent", but obviously Children.class.isInstance(p) is false.
EXPECTED BEHAVIOR
================================================
Since the method signature accepts an array of Object[] and an instance of Object, it should ignore the classes of the arguments. It should be possible to call "ArrayUtils.contains(Child[] children, Parent p)", in fact it should be possible to do this with any combination of classes, not only the ones assignable from the class hierarchy.</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.ArrayUtils.java</file>
			<file type="M">org.apache.commons.lang3.ArrayUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1278" opendate="2016-10-21 15:06:39" fixdate="2016-10-21 19:08:03" resolution="Fixed">
		<buginformation>
			<summary>BooleanUtils javadoc issues</summary>
			<description>1.  Every instance of NOTE: This returns null and will throw a NullPointerException if autoboxed to a boolean. needs to be fixed, for example: https://github.com/apache/commons-lang/blob/LANG_3_5/src/main/java/org/apache/commons/lang3/BooleanUtils.java#L51
autoboxed -&amp;gt; unboxed
reference: https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html
2.  https://github.com/apache/commons-lang/blob/LANG_3_5/src/main/java/org/apache/commons/lang3/BooleanUtils.java#L1025
The examples are duplicated: lines 1029~1031 are identical to lines 1026~1028.</description>
			<version>3.1</version>
			<fixedVersion>3.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.BooleanUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1216" opendate="2016-04-08 08:13:00" fixdate="2016-10-22 12:31:21" resolution="Fixed">
		<buginformation>
			<summary>NumberUtils.isNumber bug</summary>
			<description>I found that when using NumberUtilsorg.apache.commons.lang3.math.NumberUtils.isNumber(version3.4) isNumber method the following phenomenon, 
when the parameter is 1.0 is true, but when the parameter is 0.1 is displayed is false.
When I use 0.1 as the parameter tuning isNumber method, 
view the source code in the method of the method of line 1370 discovered a problem.
When the analytical parameter is ". ", this time the chars [I] value is 46, direct return false.
I think to do so is not very reasonable, please give me your guidance.</description>
			<version>3.4</version>
			<fixedVersion>3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.math.NumberUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="1276" opendate="2016-10-19 10:17:36" fixdate="2016-10-23 15:07:01" resolution="Fixed">
		<buginformation>
			<summary>StrBuilder#replaceAll ArrayIndexOutOfBoundsException</summary>
			<description>There is a bug in replace for StrBuilder, seems the use of nonupdated buffer and character count is off.
new StrBuilder("Dear X, hello X.").replaceAll(StrMatcher.stringMatcher("X"), "012345678901234567");
yields

java.lang.ArrayIndexOutOfBoundsException: 49
	at org.apache.commons.lang3.text.StrMatcher$StringMatcher.isMatch(StrMatcher.java:372)
	at org.apache.commons.lang3.text.StrBuilder.replaceImpl(StrBuilder.java:2115)
	at org.apache.commons.lang3.text.StrBuilder.replace(StrBuilder.java:2088)
	at org.apache.commons.lang3.text.StrBuilder.replaceAll(StrBuilder.java:2049)

</description>
			<version>3.2.1</version>
			<fixedVersion>3.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.text.StrBuilderTest.java</file>
			<file type="M">org.apache.commons.lang3.text.StrBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="1144" opendate="2015-06-10 20:07:28" fixdate="2016-10-23 17:37:32" resolution="Fixed">
		<buginformation>
			<summary>Multiple calls of org.apache.commons.lang3.concurrent.LazyInitializer.initialize() are possible</summary>
			<description>It is possible to create a construct, that allows multiple calls of LazyInitializer.initialize, when calculations (which can be very expensive) return null as result. 
In the Javadoc is described that the initialize method will be called only on the first access


    /**
     * Creates and initializes the object managed by this {@code
     * LazyInitializer}. This method is called by {@link #get()} when the object
     * is accessed for the first time. An implementation can focus on the
     * creation of the object. No synchronization is needed, as this is already
     * handled by {@code get()}.
     *
     * @return the managed data object
     * @throws ConcurrentException if an error occurs during object creation
     */
    protected abstract T initialize() throws ConcurrentException;


The Junit Test can be something like this:
(fix can be appplied from attached patch-file)


package edu.test;

import static org.junit.Assert.assertEquals;

import org.apache.commons.lang3.concurrent.ConcurrentException;
import org.apache.commons.lang3.concurrent.LazyInitializer;
import org.junit.Test;

public class LazyInitializerTest {

  private int lazyinitCounter = 0;

  private LazyInitializer&amp;lt;Object&amp;gt; lazyIinit = new LazyInitializer&amp;lt;Object&amp;gt;() {

    @Override
    protected Object initialize() throws ConcurrentException {
      lazyinitCounter++;
      return doSomeVeryExpensiveOperations();
    }
  };
  
  
  private Object doSomeVeryExpensiveOperations() {
    // do db calls
    // do some complex math calculations
    // the result of them all is null
    return null;
  }
  
  
  @Test
  public void testInitialization() throws Exception {
    lazyIinit.get();
    lazyIinit.get();
    assertEquals("Multiple call of LazyInitializer#initialize", 1, lazyinitCounter);
  }

}



</description>
			<version>3.4</version>
			<fixedVersion>3.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.concurrent.LazyInitializer.java</file>
		</fixedFiles>
	</bug>
	<bug id="1188" opendate="2015-11-26 12:45:17" fixdate="2016-10-23 19:59:46" resolution="Fixed">
		<buginformation>
			<summary>StringUtils#join(T...): warning: [unchecked] Possible heap pollution from parameterized vararg type T</summary>
			<description>commons-lang3-3.4-src/src/main/java/org/apache/commons/lang3/StringUtils.java:3302: warning: [unchecked] Possible heap pollution from parameterized vararg type T
    public static &amp;lt;T&amp;gt; String join(final T... elements) {
                                             ^
usage: String.join(" ", stringarray)</description>
			<version>3.4</version>
			<fixedVersion>3.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1269" opendate="2016-09-21 10:19:27" fixdate="2016-10-28 17:23:52" resolution="Fixed">
		<buginformation>
			<summary>Wrong name or result of StringUtils::getJaroWinklerDistance</summary>
			<description>The name of the method StringUtils::getJaroWinklerDistance is misleading.
Currently for equal strings 1 is returned, for completely different strings 0 is returned. That is a measure of similarity, not of a distance. A distance must be 0 for equal strings. I read on the issues LANG-591 and LANG-944, that it was decided to have a similar name to StringUtils::getLevenshteinDistance, but that requires also the change of the methods result.
Could you please (1) rename the method to StringUtils::getJaroWinklerSimilarity or (2) change the method to return 1 - currentResult?
First option has the disadvantage to lose the similar naming of the similar methods, second option implies the risk to unnoticed introduce bugs in depending code. So I think it is preferable to use the first option.</description>
			<version>3.3</version>
			<fixedVersion>3.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
			<file type="M">org.apache.commons.lang3.StringUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">21</link>
			<link type="Supercedes" description="supercedes">9</link>
		</links>
	</bug>
	<bug id="1281" opendate="2016-11-03 14:57:00" fixdate="2016-11-06 11:20:58" resolution="Fixed">
		<buginformation>
			<summary>Javadoc of StringUtils.ordinalIndexOf is contradictory.</summary>
			<description>Javadoc of StringUtils.ordinalIndexOf states the following:
"The code increments the starting index by one, rather than by the length of the match string, so matches may overlap."
But then gives the following example:
StringUtils.ordinalIndexOf("aabaabaa", "", 2) = 0
which clearly indicates that it does not increment the starting index by one in case of the empty string.
</description>
			<version>3.5</version>
			<fixedVersion>3.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.StringUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="1285" opendate="2016-11-16 06:06:42" fixdate="2016-11-16 20:47:21" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException in FastDateParser$TimeZoneStrategy</summary>
			<description>It seems that after LANG-1186 was fixed, and before 3.5 went out, the bug was re-introduced.
One of my customers is getting the following error (I am actually not able to reproduce it) with 3.5:


java.lang.NullPointerException
        at org.apache.commons.lang3.time.FastDateParser$TimeZoneStrategy.&amp;lt;init&amp;gt;(FastDateParser.java:869)
        at org.apache.commons.lang3.time.FastDateParser.getLocaleSpecificStrategy(FastDateParser.java:637)
        at org.apache.commons.lang3.time.FastDateParser.getStrategy(FastDateParser.java:606)
        at org.apache.commons.lang3.time.FastDateParser.access$100(FastDateParser.java:73)
        at org.apache.commons.lang3.time.FastDateParser$StrategyParser.letterPattern(FastDateParser.java:234)
        at org.apache.commons.lang3.time.FastDateParser$StrategyParser.getNextStrategy(FastDateParser.java:220)
        at org.apache.commons.lang3.time.FastDateParser.init(FastDateParser.java:167)
        at org.apache.commons.lang3.time.FastDateParser.&amp;lt;init&amp;gt;(FastDateParser.java:153)
        at org.apache.commons.lang3.time.FastDateFormat.&amp;lt;init&amp;gt;(FastDateFormat.java:394)
        at org.apache.commons.lang3.time.FastDateFormat.&amp;lt;init&amp;gt;(FastDateFormat.java:378)
        at org.apache.commons.lang3.time.FastDateFormat$1.createInstance(FastDateFormat.java:100)
        at org.apache.commons.lang3.time.FastDateFormat$1.createInstance(FastDateFormat.java:97)
        at org.apache.commons.lang3.time.FormatCache.getInstance(FormatCache.java:81)
        at org.apache.commons.lang3.time.FastDateFormat.getInstance(FastDateFormat.java:128)

</description>
			<version>3.5</version>
			<fixedVersion>3.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.time.FastDateParser.java</file>
		</fixedFiles>
		<links>
			<link type="Reference" description="is related to">1186</link>
		</links>
	</bug>
	<bug id="1287" opendate="2016-11-18 15:41:33" fixdate="2016-11-18 15:53:54" resolution="Fixed">
		<buginformation>
			<summary>RandomStringUtils#random can enter infinite loop if end parameter is to small</summary>
			<description>I faced that the random method can cause an infinite loop. It can be caused if the end parameter is too low for generating either numbers (&amp;lt; 48) or letters (&amp;lt;65). I added some exception tests to make the cases clear. Basically, if we call the random function with for example numbers = true &amp;amp;&amp;amp; end &amp;lt; 48 the validation for Character.isDigit(ch) will fail and we increment count count++.
Ivan Morozov https://github.com/apache/commons-lang/pull/211</description>
			<version>3.5</version>
			<fixedVersion>3.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.apache.commons.lang3.RandomStringUtilsTest.java</file>
			<file type="M">org.apache.commons.lang3.RandomStringUtils.java</file>
		</fixedFiles>
	</bug>
</bugrepository>