<?xml version = "1.0" encoding = "UTF-8" ?>
<bugrepository name="AMQP">
	<bug id="38" opendate="2010-08-02 14:21:06" fixdate="2010-08-02 15:01:05" resolution="Complete">
		<buginformation>
			<summary>NullPointerException in Message.toString() method when BasicProperties are sent as null</summary>
			<description>I send a message using RabbitMQ Java client - com.rabbitmq.client.Channel#basicPublish(String, String, BasicProperties, byte[]) - with null BasicProperties, which seems to be a valid case. I get NPE when I try to print the message within the MessageListener implementation:






java.lang.NullPointerException




	at org.springframework.amqp.core.Message.getBodyContentAsString(Message.java:70)




	at org.springframework.amqp.core.Message.toString(Message.java:56)




	at java.lang.String.valueOf(String.java:2826)




	at java.lang.StringBuilder.append(StringBuilder.java:115)




	at com.ndpar.spring.rabbitmq.MessageHandler.onMessage(MessageHandler.java:14)




	at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:316)




	at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:254)




	at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.doExecuteListener(AbstractMessageListenerContainer.java:230)




	at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.executeListener(AbstractMessageListenerContainer.java:199)




	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.processMessage(SimpleMessageListenerContainer.java:229)




	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$AsyncMessageProcessingConsumer.run(SimpleMessageListenerContainer.java:288)




	at java.lang.Thread.run(Thread.java:637)





</description>
			<version>1.0.0.M1</version>
			<fixedVersion>1.0.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitMessageProperties.java</file>
			<file type="M">org.springframework.amqp.core.Message.java</file>
			<file type="M">org.springframework.amqp.core.MessageTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="73" opendate="2010-11-04 08:20:23" fixdate="2010-11-11 00:56:29" resolution="Complete">
		<buginformation>
			<summary>Message listener container multiple messages per transaction not working</summary>
			<description></description>
			<version>1.0.0.M1</version>
			<fixedVersion>1.0.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.AbstractRabbitListeningContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.RabbitResourceHolder.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplatePerformanceIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.support.RabbitAccessor.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerLifecycleIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.support.RabbitUtils.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.java</file>
			<file type="D">org.springframework.amqp.rabbit.listener.LocallyExposedRabbitResourceHolder.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplate.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="D">org.springframework.amqp.rabbit.test.LogLevelAdjuster.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.java</file>
		</fixedFiles>
	</bug>
	<bug id="65" opendate="2010-10-22 12:11:54" fixdate="2011-02-11 03:15:36" resolution="Complete">
		<buginformation>
			<summary>Make RabbitAdmin.deleteQueue() return boolean result</summary>
			<description>Make RabbitAdmin.deleteQueue() return boolean: currently it fails if the queue didn&amp;amp;apos;t exist, but it would be nicer really to simply ignore the exception and return false.  It would save us having to do this everywhere:






try {




	admin.deleteQueue("test.queue");




} catch (AmqpIOException e) {




	// Ignore (queue didn&amp;amp;apos;t exist)




}





 </description>
			<version>1.0.0.M3</version>
			<fixedVersion>1.0.0.M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.test.BrokerRunning.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplate.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdmin.java</file>
			<file type="M">org.springframework.amqp.core.AmqpAdmin.java</file>
		</fixedFiles>
	</bug>
	<bug id="99" opendate="2011-02-16 08:57:37" fixdate="2011-02-23 09:54:14" resolution="Complete">
		<buginformation>
			<summary>AmqpBrokerAdminIntegrationTests failing with new rabbit server (2.3.1)</summary>
			<description>AmqpBrokerAdminIntegrationTests failing with new rabbit server (2.3.1)</description>
			<version>1.0.0.M2</version>
			<fixedVersion>1.0.0.M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.admin.RabbitBrokerAdminIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.admin.RabbitBrokerAdmin.java</file>
			<file type="M">org.springframework.amqp.rabbit.admin.RabbitControlErlangConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="109" opendate="2011-03-10 10:14:32" fixdate="2011-03-14 04:59:27" resolution="Complete">
		<buginformation>
			<summary>Tomcat shutdown doesn&amp;apos;t wait for consumers in MessageListenerContainer</summary>
			<description>I&amp;amp;apos;m not sure it&amp;amp;apos;s really a problem, but Tomcat should wait for the context to close, so why do I keep seeing ShutdownSignalExceptions?  If you start Tomcat in debug mode from WTP and then shut it down, you can see the exception because the debugger pauses.  Unfortunately it happens quite frequently but not always, so the first task is to get an integration test that mimics this scenario (not sure why the existing *LifecycleIntegrationTests don&amp;amp;apos;t expose it).</description>
			<version>1.0.0.M3</version>
			<fixedVersion>1.0.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="121" opendate="2011-03-15 08:31:54" fixdate="2011-03-15 08:32:12" resolution="Complete">
		<buginformation>
			<summary>&lt;listener-container concurrency="5"/&gt; blows up</summary>
			<description>&amp;lt;listener-container concurrency="5"/&amp;gt; blows up because it uses the wrong property name in SimpleMessageListenerContainer.</description>
			<version>1.0.0.M3</version>
			<fixedVersion>1.0.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.config.ListenerContainerParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="122" opendate="2011-03-21 03:43:37" fixdate="2011-03-22 06:56:14" resolution="Complete">
		<buginformation>
			<summary>RabbitAdmin needs to handle starting up with no broker</summary>
			<description>RabbitAdmin does not appear to handle starting up without the presence of a broker. Starting up with no broker can happen of course and so it would be reasonable to have a warning logged just once until the broker becomes available. The following stack trace is shows the current behaviour:
2011-03-20 07:34:12,983 [main ] ERROR: org.springframework.web.servlet.DispatcherServlet - Context initialization failed
org.springframework.context.ApplicationContextException: Failed to start bean &amp;amp;apos;org.springframework.amqp.rabbit.core.RabbitAdmin#0&amp;amp;apos;; nested exception is org.springframework.amqp.AmqpConnectException: java.net.ConnectException: Connection refused
at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:169)
at org.springframework.context.support.DefaultLifecycleProcessor.access$1(DefaultLifecycleProcessor.java:154)
at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:335)
at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:143)
at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:108)
at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:908)
at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:428)
at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:442)
at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:458)
at org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:339)
at org.springframework.web.servlet.FrameworkServlet.initServletBean(FrameworkServlet.java:306)
at org.springframework.web.servlet.HttpServletBean.init(HttpServletBean.java:127)
at javax.servlet.GenericServlet.init(GenericServlet.java:212)
at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1161)
at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:981)
at org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:4058)
at org.apache.catalina.core.StandardContext.start(StandardContext.java:4364)
at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1045)
at org.apache.catalina.core.StandardHost.start(StandardHost.java:719)
at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1045)
at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:443)
at org.apache.catalina.startup.Embedded.start(Embedded.java:825)
at org.codehaus.mojo.tomcat.AbstractRunMojo.startContainer(AbstractRunMojo.java:385)
at org.codehaus.mojo.tomcat.AbstractRunMojo.execute(AbstractRunMojo.java:144)
at org.apache.maven.plugin.DefaultPluginManager.executeMojo(DefaultPluginManager.java:490)
at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoals(DefaultLifecycleExecutor.java:694)
at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeStandaloneGoal(DefaultLifecycleExecutor.java:569)
at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoal(DefaultLifecycleExecutor.java:539)
at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeGoalAndHandleFailures(DefaultLifecycleExecutor.java:387)
at org.apache.maven.lifecycle.DefaultLifecycleExecutor.executeTaskSegments(DefaultLifecycleExecutor.java:348)
at org.apache.maven.lifecycle.DefaultLifecycleExecutor.execute(DefaultLifecycleExecutor.java:180)
at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:328)
at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:138)
at org.apache.maven.cli.MavenCli.main(MavenCli.java:362)
at org.apache.maven.cli.compat.CompatibleMain.main(CompatibleMain.java:60)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
at java.lang.reflect.Method.invoke(Method.java:597)
at org.codehaus.classworlds.Launcher.launchEnhanced(Launcher.java:315)
at org.codehaus.classworlds.Launcher.launch(Launcher.java:255)
at org.codehaus.classworlds.Launcher.mainWithExitCode(Launcher.java:430)
at org.codehaus.classworlds.Launcher.main(Launcher.java:375)
Caused by: org.springframework.amqp.AmqpConnectException: java.net.ConnectException: Connection refused
at org.springframework.amqp.rabbit.support.RabbitUtils.convertRabbitAccessException(RabbitUtils.java:111)
at org.springframework.amqp.rabbit.connection.SingleConnectionFactory.createBareConnection(SingleConnectionFactory.java:167)
at org.springframework.amqp.rabbit.connection.SingleConnectionFactory.doCreateConnection(SingleConnectionFactory.java:160)
at org.springframework.amqp.rabbit.connection.SingleConnectionFactory.createConnection(SingleConnectionFactory.java:120)
at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils$1.createConnection(ConnectionFactoryUtils.java:94)
at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.doGetTransactionalResourceHolder(ConnectionFactoryUtils.java:141)
at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.getTransactionalResourceHolder(ConnectionFactoryUtils.java:84)
at org.springframework.amqp.rabbit.support.RabbitAccessor.getTransactionalResourceHolder(RabbitAccessor.java:112)
at org.springframework.amqp.rabbit.core.RabbitTemplate.execute(RabbitTemplate.java:291)
at org.springframework.amqp.rabbit.core.RabbitAdmin.start(RabbitAdmin.java:219)
at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:166)
... 42 more
Caused by: java.net.ConnectException: Connection refused
at java.net.PlainSocketImpl.socketConnect(Native Method)
at java.net.PlainSocketImpl.doConnect(PlainSocketImpl.java:333)
at java.net.PlainSocketImpl.connectToAddress(PlainSocketImpl.java:195)
at java.net.PlainSocketImpl.connect(PlainSocketImpl.java:182)
at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:432)
at java.net.Socket.connect(Socket.java:529)
at java.net.Socket.connect(Socket.java:478)
at com.rabbitmq.client.ConnectionFactory.createFrameHandler(ConnectionFactory.java:342)
at com.rabbitmq.client.ConnectionFactory.newConnection(ConnectionFactory.java:380)
at com.rabbitmq.client.ConnectionFactory.newConnection(ConnectionFactory.java:403)
at org.springframework.amqp.rabbit.connection.SingleConnectionFactory.createBareConnection(SingleConnectionFactory.java:165)
... 51 more</description>
			<version>1.0.0.M3</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.amqp.rabbit.admin.TestRabbitConfiguration.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdminTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.AdminParserTests.java</file>
			<file type="D">org.springframework.amqp.rabbit.admin.TestConstants.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.AbstractRabbitConfiguration.java</file>
			<file type="D">org.springframework.amqp.rabbit.admin.PojoHandler.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.ConnectionFactory.java</file>
			<file type="D">org.springframework.amqp.rabbit.admin.RabbitTemplateProducerExample.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.AdminParser.java</file>
			<file type="D">org.springframework.amqp.rabbit.admin.RabbitTemplateConsumerExample.java</file>
			<file type="M">org.springframework.amqp.rabbit.test.BrokerRunning.java</file>
			<file type="D">org.springframework.amqp.rabbit.admin.RabbitProducerConfiguration.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdmin.java</file>
			<file type="D">org.springframework.amqp.rabbit.admin.RabbitConsumerConfiguration.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.SingleConnectionFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="124" opendate="2011-03-22 11:19:26" fixdate="2011-03-22 11:29:49" resolution="Complete">
		<buginformation>
			<summary>Message.toString() ClasscastException</summary>
			<description>Message.toString() ClasscastException when body is Serializable and not a String!</description>
			<version>1.0.0.M1</version>
			<fixedVersion>1.0.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.core.MessageTests.java</file>
			<file type="M">org.springframework.amqp.core.Message.java</file>
		</fixedFiles>
	</bug>
	<bug id="125" opendate="2011-03-23 07:51:21" fixdate="2011-03-23 08:10:07" resolution="Complete">
		<buginformation>
			<summary>Unreliable lock algorithm in SimpleMessageListenerContainer</summary>
			<description>Unreliable lock algorithm in SimpleMessageListenerContainer leads to container not waiting for stop() if some listeners have failed.</description>
			<version>1.0.0.M3</version>
			<fixedVersion>1.0.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitBindingIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerRecoveryCachingConnectionIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerLifecycleIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="148" opendate="2011-04-04 22:54:24" fixdate="2011-04-05 10:23:54" resolution="Complete">
		<buginformation>
			<summary>Default number of consumers is 0 on SimpleMessageListenerContainer if afterPropertiesSet() not called</summary>
			<description>SimpleMessageListenerContainer has a default number of concurrent consumers set to 0, and the validateConfiguration() method, which checks for it and eventually set it to 1, seems to be never called.
This is very annoying, because applications using older versions will stop working with no apparent reason.
Finally, please note that version M2 had a default number set to 1.</description>
			<version>1.0.0.M3</version>
			<fixedVersion>1.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="151" opendate="2011-04-06 00:46:32" fixdate="2011-04-06 01:06:49" resolution="Complete">
		<buginformation>
			<summary>SingleConnectionFactory can close the wrong target connection on close</summary>
			<description>SingleConnectionFactory can close the wrong target connection on close. From zzantozz on the forum:

The targetConnection is created first, and then "connection" is targetConnection wrapped with an adapter. That&amp;amp;apos;s all well and good, but the adapter that the former connection is wrapped with is a SingleConnectionFactory.SharedConnectionProxy. The targetConnection is passed in as a constructor arg and is stored in the instance field SharedConnectionProxy.target. Then in SharedConnectionProxy.createChannel, it has the ability to detect that "target" is closed and to create a new connection. The problem here is that it only updates SharedConnectionProxy.target and not SingleConnectionFactory.targetConnection, so when the factory is shut down, it will try to close a connection that is already known to be bad, and the good connection won&amp;amp;apos;t be closed. Given that SharedConnectionProxy is an inner class of SingleConnectionFactory, the correct behavior could be gotten just by eliminating the target field from the former and directly accessing targetConnection in the latter. </description>
			<version>1.0.0.RC1</version>
			<fixedVersion>1.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.connection.SingleConnectionFactoryTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.SingleConnectionFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="150" opendate="2011-04-05 07:29:00" fixdate="2011-04-06 03:25:04" resolution="Complete">
		<buginformation>
			<summary>RabbitAdmin or CachingConnectionFactory should prevent calls to ConnectionListener when physical connection is not opened</summary>
			<description></description>
			<version>1.0.0.RC1</version>
			<fixedVersion>1.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.connection.SingleConnectionFactoryTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.SingleConnectionFactory.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactoryTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.test.BrokerRunning.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactory.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdminIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="164" opendate="2011-04-27 02:00:51" fixdate="2011-04-27 02:33:13" resolution="Complete">
		<buginformation>
			<summary>Exchange parsers do not handle anonymous queues correctly</summary>
			<description>The problem manifests itself as a test failure in the stocks sample because there is no integration test for the binding parsers in spring-rabbit.  Test set: org.springframework.amqp.rabbit.stocks.web.ServletConfigurationTests






Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 3.521 sec &amp;lt;&amp;lt;&amp;lt; FAILURE!




testContext(org.springframework.amqp.rabbit.stocks.web.ServletConfigurationTests)  Time elapsed: 3.449 sec  &amp;lt;&amp;lt;&amp;lt; ERROR!




org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;org.springframework.amqp.rabbit.core.RabbitAdmin#0&amp;amp;apos;: Invocation of init method failed; nested exception is org.springframework.amqp.AmqpIOException: java.io.IOException




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1420)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:519)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:456)




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:291)




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:288)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:190)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:580)




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:895)




	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:425)




	at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:139)




	at org.springframework.context.support.ClassPathXmlApplicationContext.&amp;lt;init&amp;gt;(ClassPathXmlApplicationContext.java:105)




	at org.springframework.amqp.rabbit.stocks.web.ServletConfigurationTests.testContext(ServletConfigurationTests.java:32)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)




	at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:35)




	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:115)




	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:97)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.apache.maven.surefire.booter.ProviderFactory$ClassLoaderProxy.invoke(ProviderFactory.java:103)




	at $Proxy0.invoke(Unknown Source)




	at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:150)




	at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcess(SurefireStarter.java:91)




	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:69)




Caused by: org.springframework.amqp.AmqpIOException: java.io.IOException




	at org.springframework.amqp.rabbit.connection.RabbitUtils.convertRabbitAccessException(RabbitUtils.java:117)




	at org.springframework.amqp.rabbit.connection.RabbitAccessor.convertRabbitAccessException(RabbitAccessor.java:106)




	at org.springframework.amqp.rabbit.core.RabbitTemplate.execute(RabbitTemplate.java:314)




	at org.springframework.amqp.rabbit.core.RabbitAdmin.initialize(RabbitAdmin.java:298)




	at org.springframework.amqp.rabbit.core.RabbitAdmin$10.onCreate(RabbitAdmin.java:232)




	at org.springframework.amqp.rabbit.connection.SingleConnectionFactory.addConnectionListener(SingleConnectionFactory.java:143)




	at org.springframework.amqp.rabbit.core.RabbitAdmin.afterPropertiesSet(RabbitAdmin.java:215)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1477)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1417)




	... 40 more




Caused by: java.io.IOException




	at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:107)




	at com.rabbitmq.client.impl.AMQChannel.exnWrappingRpc(AMQChannel.java:131)




	at com.rabbitmq.client.impl.ChannelN.exchangeBind(ChannelN.java:577)




	at com.rabbitmq.client.impl.ChannelN.exchangeBind(ChannelN.java:59)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.springframework.amqp.rabbit.connection.CachingConnectionFactory$CachedChannelInvocationHandler.invoke(CachingConnectionFactory.java:239)




	at $Proxy12.exchangeBind(Unknown Source)




	at org.springframework.amqp.rabbit.core.RabbitAdmin.declareBindings(RabbitAdmin.java:347)




	at org.springframework.amqp.rabbit.core.RabbitAdmin.access$200(RabbitAdmin.java:45)




	at org.springframework.amqp.rabbit.core.RabbitAdmin$11.doInRabbit(RabbitAdmin.java:302)




	at org.springframework.amqp.rabbit.core.RabbitTemplate.execute(RabbitTemplate.java:309)




	... 46 more




Caused by: com.rabbitmq.client.ShutdownSignalException: channel error; reason: {#method&amp;lt;channel.close&amp;gt;(reply-code=404,reply-text=NOT_FOUND - no exchange &amp;amp;apos;tradeQueue&amp;amp;apos; in vhost &amp;amp;apos;/&amp;amp;apos;,class-id=40,method-id=30),null,""}




	at com.rabbitmq.utility.ValueOrException.getValue(ValueOrException.java:67)




	at com.rabbitmq.utility.BlockingValueOrException.uninterruptibleGetValue(BlockingValueOrException.java:33)




	at com.rabbitmq.client.impl.AMQChannel$BlockingRpcContinuation.getReply(AMQChannel.java:328)




	at com.rabbitmq.client.impl.AMQChannel.rpc(AMQChannel.java:201)




	at com.rabbitmq.client.impl.AMQChannel.exnWrappingRpc(AMQChannel.java:125)




	... 58 more




Caused by: com.rabbitmq.client.ShutdownSignalException: channel error; reason: {#method&amp;lt;channel.close&amp;gt;(reply-code=404,reply-text=NOT_FOUND - no exchange &amp;amp;apos;tradeQueue&amp;amp;apos; in vhost &amp;amp;apos;/&amp;amp;apos;,class-id=40,method-id=30),null,""}




	at com.rabbitmq.client.impl.ChannelN.asyncShutdown(ChannelN.java:365)




	at com.rabbitmq.client.impl.ChannelN.processAsync(ChannelN.java:235)




	at com.rabbitmq.client.impl.AMQChannel.handleCompleteInboundCommand(AMQChannel.java:151)




	at com.rabbitmq.client.impl.AMQChannel.handleFrame(AMQChannel.java:96)




	at com.rabbitmq.client.impl.AMQConnection$MainLoop.run(AMQConnection.java:446)






</description>
			<version>1.0.0 GA</version>
			<fixedVersion>1.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.config.FanoutExchangeParser.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.HeadersExchangeParser.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.TopicExchangeParser.java</file>
			<file type="M">org.springframework.amqp.core.Binding.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.DirectExchangeParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="165" opendate="2011-04-27 05:23:57" fixdate="2011-04-27 05:42:37" resolution="Complete">
		<buginformation>
			<summary>AmqpAppender does not die cleanly when webapp shuts down</summary>
			<description>Fixed in samples by using Log4jConfigListener (it shuts down the appenders) and also in spring-rabbit by manually closing the connection factory when the appender closes.</description>
			<version>1.0.0.RC1</version>
			<fixedVersion>1.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppender.java</file>
		</fixedFiles>
	</bug>
	<bug id="168" opendate="2011-05-10 05:49:10" fixdate="2011-05-11 05:47:41" resolution="Complete">
		<buginformation>
			<summary>SimpleMessageListenerContainer should only commit every txSize messages</summary>
			<description>SimpleMessageListenerContainer should only commit every txSize messages (it looks like it does it for every message right now).</description>
			<version>1.0.0.RC1</version>
			<fixedVersion>1.0.0.RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.StatefulRetryOperationsInterceptorFactoryBean.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerRetryIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.test.BrokerRunning.java</file>
			<file type="M">org.springframework.amqp.rabbit.test.RepeatProcessor.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerRecoveryCachingConnectionIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="170" opendate="2011-05-25 05:23:19" fixdate="2011-05-27 11:31:19" resolution="Complete">
		<buginformation>
			<summary>Message header value has type com.rabbitmq.client.impl.LongStringHelper.ByteArrayLongString</summary>
			<description>The problem has happened using spring-integration-amqp.
Trying to read a value from the header of a message I get that this value is of com.rabbitmq.client.impl.LongStringHelper.ByteArrayLongString type, when it was supposed to be String.</description>
			<version>1.0.0.RC1</version>
			<fixedVersion>1.0.0.RC2</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.connection.RabbitUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="179" opendate="2011-07-05 13:32:24" fixdate="2011-07-05 13:33:19" resolution="Complete">
		<buginformation>
			<summary>RabbitAdmin anonymous queue declaration javadocs inconsistent with Queue properties</summary>
			<description>RabbitAdmin anonymous queue declaration javadocs inconsistent with Queue properties: it creates a non-durable, non-exclusive, auto-delete queue (as per the defaults in Channel), but javadocs say it is durable and not auto-delete.</description>
			<version>1.0.0.RC2</version>
			<fixedVersion>1.0.0.RC3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdmin.java</file>
		</fixedFiles>
	</bug>
	<bug id="223" opendate="2012-04-06 08:08:36" fixdate="2012-04-09 10:47:10" resolution="Complete">
		<buginformation>
			<summary>Too Many Threads Running in SimpleListenerContainer</summary>
			<description>If doStart() is called twice, we end up with two threads running in each consumer.
This can happen, say, if spring-integration-amqp declares an adapter that uses an externally defined listener container.
The container itself is started, and then started again by the adapter.
This can cause acks to go out asynchronously. Need to protect against running the consumers multiple times.</description>
			<version>1.0.0 GA</version>
			<fixedVersion>1.1.0.GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
		</fixedFiles>
	</bug>
	<bug id="231" opendate="2012-05-12 05:50:39" fixdate="2012-05-14 09:36:06" resolution="Complete">
		<buginformation>
			<summary>Fix Failing Integration Tests</summary>
			<description></description>
			<version>1.1.0.GA</version>
			<fixedVersion>1.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitBindingIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplatePublisherCallbacksIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerLifecycleIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="233" opendate="2012-05-16 06:27:44" fixdate="2012-05-16 08:32:30" resolution="Complete">
		<buginformation>
			<summary>Publisher Returns Cannot be Requested Independently of Publisher Confirms</summary>
			<description>The rabbit-connection-factory publisher-returns attribute is not wired up to the connection factory.
You can only get returns if you also request confirms...
Caused by: java.lang.IllegalStateException: When using publisher confirms, channels must be wrapped in a PublisherCallbackChannelImpl</description>
			<version>1.1.0.GA</version>
			<fixedVersion>1.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplate.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplatePublisherCallbacksIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.ConnectionFactoryParserTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="232" opendate="2012-05-15 17:34:16" fixdate="2012-05-24 07:49:03" resolution="Complete">
		<buginformation>
			<summary>More Failing System Tests</summary>
			<description>Placeholder until we clean these all up.
https://build.springsource.org/browse/AMQP-INTEGRATION-422/</description>
			<version>1.1.0.GA</version>
			<fixedVersion>1.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerRecoveryCachingConnectionIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerLifecycleIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="243" opendate="2012-06-11 02:23:38" fixdate="2012-07-17 12:50:16" resolution="Complete">
		<buginformation>
			<summary>AmqpAppender and log4j synchronization issues resulting in messages loss</summary>
			<description>The Log4j AmqpAppender is subject to synchronization issues because of the Log4j PatternLayout.
Problem is at the following line :
String routingKey = routingKeyLayout.format(logEvent);
We must either use another pattern like the EnhancedPatternLayoutlike suggested by the PatternLayout JavaDoc or add synchronization code.
The consequence is message lost because of the routing key badly generated.</description>
			<version>1.1.1</version>
			<fixedVersion>1.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppender.java</file>
		</fixedFiles>
	</bug>
	<bug id="242" opendate="2012-06-08 13:09:15" fixdate="2012-07-17 12:50:59" resolution="Complete">
		<buginformation>
			<summary>Log4j AmqpAppender does not use the layout</summary>
			<description>The Log4j AmqpAppender does not use the layout.
The JavaDoc mentions the property log4j.appender.amqp.layout but the message is rendered using new StringBuffer(String.format("%s%n", logEvent.getRenderedMessage())).
layout.format(logEvent) should maybe be used.</description>
			<version>1.1.1</version>
			<fixedVersion>1.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppender.java</file>
		</fixedFiles>
	</bug>
	<bug id="190" opendate="2011-09-10 20:24:17" fixdate="2012-07-18 08:51:03" resolution="Complete">
		<buginformation>
			<summary>CachingConnectionFactory leaks channels when synchronized with a TransactionManager</summary>
			<description>It seems that when I use RabbitTemplate, channelTransacted=true, to convertAndSend() a message to an exchange within the context of a synchronized TransactionManager (e.g. an active transaction on the current thread), the channel is never closed, hence new publishes will always get their "own", shiny, new channel (that is never closed or released to the channel pool) until Rabbit can&amp;amp;apos;t handle any more channels.
See Forum Reference for more info.
The problem is not observed on the consumer side (e.g. MessageListenerContainer).  Its observed on the publishing side, (e.g. RabbitTemplate).  It is observed both if I use the RabbitTemplate, natively... or if I use spring-integration and the &amp;lt;int-amqp:outbound-channel-adapter...&amp;gt; tag.
BTW, the observed "channel leak" goes away when I choose channelTransacted=false.
I will look to supply a simple recreate, if I can scrounge the time.</description>
			<version>1.0.0 GA</version>
			<fixedVersion>1.1.2, 1.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.connection.RabbitResourceHolder.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplateTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplatePerformanceIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="250" opendate="2012-07-13 06:03:55" fixdate="2012-07-18 09:09:32" resolution="Complete">
		<buginformation>
			<summary>Anonymous reply-queue Doesn&amp;apos;t Work with Send/Reply Operations</summary>
			<description></description>
			<version>1.1.1</version>
			<fixedVersion>1.1.2, 1.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.config.TemplateParser.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.TemplateParserTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="249" opendate="2012-07-12 11:46:31" fixdate="2012-07-19 11:04:18" resolution="Complete">
		<buginformation>
			<summary>Issues with RabbitTemplate Temporary Reply Queues</summary>
			<description>Temporary Reply Queues are configured autoAck=false, but we don&amp;amp;apos;t ack the reply. If using a cached channel, this causes accounting problems on the Rabbit admin (channel shows unacked count).
Also, since the replyHandoff is a SynchronizedQueue, there is a race condition in the case the timeout is exceeded just as the reply is received; the consumer thread hangs on the put() because there is nobody in take().</description>
			<version>1.1.1</version>
			<fixedVersion>1.1.2, 1.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplate.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplateTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="252" opendate="2012-07-16 06:23:01" fixdate="2012-07-19 15:25:34" resolution="Complete">
		<buginformation>
			<summary>Remove System.out Call In JsonMessageConverter</summary>
			<description>Line #122, when a ClassMapper is provided.</description>
			<version>1.1.1</version>
			<fixedVersion>1.1.2, 1.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.support.converter.JsonMessageConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="260" opendate="2012-07-24 07:50:58" fixdate="2012-08-22 10:18:57" resolution="Complete">
		<buginformation>
			<summary>Hanging thread when using RabbitTransactionManager with a listener container where channelTransacted=true</summary>
			<description>When using the following configuration, the message will never be acknowledged:






&amp;lt;bean id="connectionFactory" class="org.springframework.amqp.rabbit.connection.CachingConnectionFactory"&amp;gt;




	    &amp;lt;constructor-arg value="localhost"/&amp;gt;




	    &amp;lt;property name="username" value="guest"/&amp;gt;




	    &amp;lt;property name="password" value="guest"/&amp;gt;




	&amp;lt;/bean&amp;gt;	




		




	&amp;lt;bean id="rabbitTransactionManager" class="org.springframework.amqp.rabbit.transaction.RabbitTransactionManager"&amp;gt;




		&amp;lt;property name="connectionFactory" ref="connectionFactory" /&amp;gt;




	&amp;lt;/bean&amp;gt;




	




	&amp;lt;bean class="org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer"&amp;gt;




		&amp;lt;property name="connectionFactory" ref="connectionFactory" /&amp;gt;




		&amp;lt;property name="queueNames" value="Queue" /&amp;gt;




		&amp;lt;property name="messageListener"&amp;gt;




			&amp;lt;bean class="org.springframework.amqp.rabbit.listener.adapter.MessageListenerAdapter"&amp;gt;




				&amp;lt;property name="delegate" ref="endpoint" /&amp;gt;




			&amp;lt;/bean&amp;gt;




		&amp;lt;/property&amp;gt;




		&amp;lt;property name="transactionManager" ref="rabbitTransactionManager" /&amp;gt;




		&amp;lt;property name="channelTransacted" value="true" /&amp;gt;




	&amp;lt;/bean&amp;gt;









	&amp;lt;bean id="endpoint" class="amqp.Endpoint" /&amp;gt;




	




	&amp;lt;rabbit:admin connection-factory="connectionFactory" /&amp;gt;




	




	&amp;lt;rabbit:queue name="Queue" /&amp;gt;






Attached is a zip file with a sample demo project that reproduces the issue.
PS: The test was done with both 1.1.1.RELEASE and 1.1.2.BUID-SNAPSHOT.
This may be related to AMQP-190.</description>
			<version>1.1.1</version>
			<fixedVersion>1.1.2, 1.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">309</link>
		</links>
	</bug>
	<bug id="262" opendate="2012-08-06 09:51:41" fixdate="2012-08-22 10:34:57" resolution="Complete">
		<buginformation>
			<summary>ConcurrentModificationException with publish confirms</summary>
			<description>I&amp;amp;apos;m getting random ConcurrentModificationExceptions in the publish confirm code when sending messages from multiple threads, using the same rabbit template. 
Caused by: java.util.ConcurrentModificationException
	at java.util.TreeMap$NavigableSubMap$SubMapIterator.nextEntry(TreeMap.java:1594)
	at java.util.TreeMap$NavigableSubMap$SubMapEntryIterator.next(TreeMap.java:1642)
	at java.util.TreeMap$NavigableSubMap$SubMapEntryIterator.next(TreeMap.java:1636)
	at org.springframework.amqp.rabbit.support.PublisherCallbackChannelImpl.processAck(PublisherCallbackChannelImpl.java:493)
	at org.springframework.amqp.rabbit.support.PublisherCallbackChannelImpl.handleAck(PublisherCallbackChannelImpl.java:474)
	at com.rabbitmq.client.impl.ChannelN.callConfirmListeners(ChannelN.java:435)
	at com.rabbitmq.client.impl.ChannelN.processAsync(ChannelN.java:351)
	at com.rabbitmq.client.impl.AMQChannel.handleCompleteInboundCommand(AMQChannel.java:144)
	at com.rabbitmq.client.impl.AMQChannel.handleFrame(AMQChannel.java:91)
	at com.rabbitmq.client.impl.AMQConnection$MainLoop.run(AMQConnection.java:526)
Looking at the code, it seems that PublisherCallbackChannelImpl.addPendingConfirm() is thread unsafe. It should synchronize the access to this.pendingConfirms, just like processAck() does. I&amp;amp;apos;ve attached a possible fix. 
</description>
			<version>1.1.1</version>
			<fixedVersion>1.1.2, 1.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.support.PublisherCallbackChannelImpl.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplatePublisherCallbacksIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="272" opendate="2012-10-01 11:52:40" fixdate="2012-10-30 08:32:05" resolution="Complete">
		<buginformation>
			<summary>Misspelled accessor for messageKeyGenerator in StatefulRetryOperationsInterceptorFactoryBean</summary>
			<description>In looking at the StatefulRetryOperationsInterceptorFactoryBean from 1.1.2 I noticed that the setter for the MessageKeyGenerator property is misspelled:






public void setMessageKeyGeneretor(MessageKeyGenerator messageKeyGeneretor) { ... }





</description>
			<version>1.1.2</version>
			<fixedVersion>1.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.config.StatefulRetryOperationsInterceptorFactoryBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="275" opendate="2012-10-30 06:18:40" fixdate="2012-11-05 13:56:33" resolution="Complete">
		<buginformation>
			<summary>Race Condition When Stopping Listener Container</summary>
			<description>Race condition where messages can be rejected/requeued during container stop before the consumer was canceled. The message can be redelivered to the blocking queue before the cancel.
1. Cancel the consumer first
2. Drain the queue with reject/requeue</description>
			<version>1.1.2</version>
			<fixedVersion>1.1.3, 1.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.connection.RabbitUtils.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.StopStartIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="274" opendate="2012-10-25 13:00:10" fixdate="2012-11-06 06:56:01" resolution="Complete">
		<buginformation>
			<summary>Listener Container Local Transactions Not Properly Set Up</summary>
			<description>When using local transactions (no external tx manager) and exposeListenerChannel is true (default), the synchronized resource does not have the synchronizedWithTransaction property set to true.
This causes a downstream RabbitTemplate to close() the channel.
</description>
			<version>1.1.2</version>
			<fixedVersion>1.1.3, 1.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.connection.RabbitResourceHolder.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.LocallyTransactedTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.ExternalTxManagerTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="280" opendate="2012-11-06 12:58:17" fixdate="2012-11-06 13:50:03" resolution="Complete">
		<buginformation>
			<summary>Fix Race Condition in Test</summary>
			<description>Container is stopped before testing mocki to ensure close() wasn&amp;amp;apos;t called on the channel.</description>
			<version>1.1.3</version>
			<fixedVersion>1.1.3, 1.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.LocallyTransactedTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="268" opendate="2012-08-30 05:28:24" fixdate="2013-02-27 10:02:36" resolution="Complete">
		<buginformation>
			<summary>MDC properties are not correctly handled in AmqpAppender</summary>
			<description>the code :
// Copy properties in from MDC
					@SuppressWarnings("rawtypes")
					Map props = event.getProperties();
					for (Object key : event.getProperties().entrySet()) 
{
						amqpProps.setHeader(key.toString(), props.get(key));
					}


should be:

// Copy properties in from MDC
					@SuppressWarnings("rawtypes")
					Map props = event.getProperties();
					for (Object key : event.getProperties().keySet()) {						amqpProps.setHeader(key.toString(), props.get(key));					}</description>
			<version>1.1.2</version>
			<fixedVersion>1.1.4, 1.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.log4j.TestListener.java</file>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppender.java</file>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppenderIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="281" opendate="2012-11-13 01:56:26" fixdate="2013-03-03 09:29:29" resolution="Complete">
		<buginformation>
			<summary>AmqpAppender is causing the application not to shut down</summary>
			<description>if the logging is configured to use AmqpAppender the thread remains alive and does not shut down if the application is started from a main method and if it is a web app then the classloader will not unload on hot redeploy and tomcat shows the following message :
The web application [/xxx] appears to have started a thread named [log-event-retry-delay] but has failed to stop it. This is very likely to create a memory leak.</description>
			<version>1.1.3</version>
			<fixedVersion>1.1.4, 1.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppender.java</file>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppenderIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="282" opendate="2012-11-15 06:01:52" fixdate="2013-03-04 15:15:25" resolution="Complete">
		<buginformation>
			<summary>AmqpAppender always logs message body with default encoding</summary>
			<description>When logging the String message &amp;amp;apos;Tourne&amp;amp;apos; with UTF-8 encoding using AmqpAppender and running the java application with -Dfile.encoding=windows-1252, the message retrieved from rabbit queue holds an incorrect character for character &amp;amp;apos;&amp;amp;apos; in &amp;amp;apos;Tourne&amp;amp;apos;.
The following code in AmqpAppender causes the problem:
rabbitTemplate.send(exchangeName, routingKey, new Message(msgBody.toString().getBytes(), amqpProps));
using msgBody.toString().getBytes("UTF-8") fixes the problem.</description>
			<version>1.1.1</version>
			<fixedVersion>1.1.4, 1.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.log4j.TestListener.java</file>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppender.java</file>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppenderIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="304" opendate="2013-03-21 20:42:00" fixdate="2013-03-25 11:20:34" resolution="Complete">
		<buginformation>
			<summary>Tests are not closing Rabbit connections properly</summary>
			<description>The JUnit tests are not closing the RabbitMQ connections correctly. This may lead to a hanging build (depends on the OS but observed on Mac OS):






Building &amp;gt; :spring-rabbit:test &amp;gt; 254 tests completed, 1 skipped






In the RabbitMQ admin you may observe that the Socket descriptors max out (E.g. on my Mac I have 138 available)</description>
			<version>1.1.4</version>
			<fixedVersion>1.2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerTxSizeIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.QueueArgumentsParserTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerRecoveryRepeatIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerErrorHandlerIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerRecoveryCachingConnectionIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.QueueParserIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplateIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.ExchangeParserIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerRetryIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerManualAckIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumerIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.MismatchedQueueDeclarationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.FederatedExchangeParserIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdminTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactoryIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerMultipleQueueIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.admin.RabbitBrokerAdminIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.StopStartIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.transaction.RabbitTransactionManagerIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerBrokerInterruptionIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplatePerformanceIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdminIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitBindingIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplatePublisherCallbacksIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.SimpleConnection.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerLifecycleIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppenderIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="307" opendate="2013-04-19 09:23:09" fixdate="2013-04-24 16:25:29" resolution="Duplicate">
		<buginformation>
			<summary>Multiple RabbitAdmin instances force dubious declarations.</summary>
			<description>As stated in thread, the RabbitAdmin class is indiscriminate about the Queue instances it chooses to declare, regardless of their use by connectionfactories.</description>
			<version>1.1.4</version>
			<fixedVersion></fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.config.BindingFactoryBean.java</file>
			<file type="M">org.springframework.amqp.core.Binding.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdmin.java</file>
			<file type="M">org.springframework.amqp.core.Exchange.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.HeadersExchangeParser.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.AbstractExchangeParser.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.FederatedExchangeParser.java</file>
			<file type="M">org.springframework.amqp.core.Queue.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.FanoutExchangeParser.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.ExchangeParserTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.DirectExchangeParser.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.QueueParser.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.TopicExchangeParser.java</file>
			<file type="M">org.springframework.amqp.core.AbstractExchange.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.QueueParserTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.NamespaceUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">286</link>
		</links>
	</bug>
	<bug id="309" opendate="2013-04-24 10:11:37" fixdate="2013-05-09 15:06:39" resolution="Complete">
		<buginformation>
			<summary>ConsumerChannelRegistry uses a ThreadLocal which prevents receiving and sending on different channels within a transaction</summary>
			<description>The way the Spring AMQP Rabbit implementation works, it is not possible to receive messages from one channel and send messages through a separate channel within the same transaction.  This behavior is requested so that a service may consume messages from a queue on one rabbit node and publish messages to a different rabbit node.  
The ConnectionFactoryUtils will not use a ConnectionFactory to create a new channel if it finds an existing cached RabbitMQ channel in the ConsumerChannelRegistry.  This happens in the ConnectionFactoryUtils.doGetTransactionalResource() method:






ConnectionFactoryUtils.java






    ...




    boolean isExistingCon = (connection != null);




    if (!isExistingCon) {




        connection = resourceFactory.createConnection();




        resourceHolderToUse.addConnection(connection);




    }




    channel = ConsumerChannelRegistry.getConsumerChannel();




    if (channel == null) {




        channel = resourceFactory.createChannel(connection);




    }




    resourceHolderToUse.addChannel(channel, connection);




    ...






The main culprit is the ConsumerChannelRegistry which uses a ThreadLocal variable to store a channel associated with the current transaction.  The registry does not use the ConnectionFactory as a key.  And since the receive channel is already registered in the registry, my messages end up getting sent through the receiving channel.
Essentially what ends up happening is that even though I provide a different ConnectionFactory, the ConnectionFactoryUtils avoid creating a new channel because one already exists in the ConsumerChannelRegistry.</description>
			<version>1.1.3</version>
			<fixedVersion>1.2.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.ExternalTxManagerTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.support.ConsumerChannelRegistry.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">260</link>
		</links>
	</bug>
	<bug id="286" opendate="2012-11-21 02:07:11" fixdate="2013-06-19 08:29:50" resolution="Complete">
		<buginformation>
			<summary>Specify which connection factory to use when creating exchanges and queues</summary>
			<description>Add attributes to &amp;lt;rabbit:queue&amp;gt; and &amp;lt;rabbit:exchange&amp;gt; to specify which connection factory to use or admin to use.
This is required systems which &amp;amp;apos;straddles&amp;amp;apos; two different application environments each of which have their own RabbitMQ brokers. You can&amp;amp;apos;t run both environments on the same broker as there will be name clashing and messages going to the wrong system.
One work around for this is to use the code configuration instead of XML application context configuration.</description>
			<version>1.1.3</version>
			<fixedVersion>1.2.0.RC1</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.config.BindingFactoryBean.java</file>
			<file type="M">org.springframework.amqp.core.Binding.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdmin.java</file>
			<file type="M">org.springframework.amqp.core.Exchange.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.HeadersExchangeParser.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.AbstractExchangeParser.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.FederatedExchangeParser.java</file>
			<file type="M">org.springframework.amqp.core.Queue.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.FanoutExchangeParser.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.ExchangeParserTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.DirectExchangeParser.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.QueueParser.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.TopicExchangeParser.java</file>
			<file type="M">org.springframework.amqp.core.AbstractExchange.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.QueueParserTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.NamespaceUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">307</link>
		</links>
	</bug>
	<bug id="327" opendate="2013-06-28 05:13:51" fixdate="2013-07-10 07:33:18" resolution="Complete">
		<buginformation>
			<summary>AmqpAppender cannot be used as a root logger appender </summary>
			<description>AmqpAppender cannot be used as a root logger appender as it causes an infinite look creating the CachingConnectionFactory. The spring-amqp classes themselves use the same appender; causing this infinite loop during initialization.</description>
			<version>1.1.4</version>
			<fixedVersion>1.2.0.GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppender.java</file>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppenderIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="331" opendate="2013-09-05 18:26:55" fixdate="2013-09-06 08:46:08" resolution="Complete">
		<buginformation>
			<summary>When java.lang.Error(e.g.OutOfMemory) occurs, threads do not abort.</summary>
			<description>When an OutOfMemory occurs, threads do not abort.
But, it is expected that threads will be abort in this situation.</description>
			<version>1.2.0.GA</version>
			<fixedVersion>1.2.1, 1.3.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
		</fixedFiles>
	</bug>
	<bug id="330" opendate="2013-08-30 03:30:01" fixdate="2013-09-20 07:49:24" resolution="Complete">
		<buginformation>
			<summary>String array can not be converted back from message </summary>
			<description>the following code used to work in 1.0.0 but as of 1.1.x upwards it throws an exception:











// Jackson2JsonMessageConverter converter=new Jackson2JsonMessageConverter();




        JsonMessageConverter converter = new JsonMessageConverter();




        Message message = converter.toMessage(new String[] { "test" }, new MessageProperties());




        Object fromMessage = converter.fromMessage(message);





 </description>
			<version>1.2.0.GA</version>
			<fixedVersion>1.2.1, 1.3.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.support.converter.JsonMessageConverterTests.java</file>
			<file type="M">org.springframework.amqp.support.converter.Jackson2JsonMessageConverterTests.java</file>
			<file type="M">org.springframework.amqp.support.converter.DefaultJackson2JavaTypeMapper.java</file>
			<file type="M">org.springframework.amqp.support.converter.DefaultJavaTypeMapper.java</file>
		</fixedFiles>
	</bug>
	<bug id="332" opendate="2013-09-11 06:35:56" fixdate="2013-09-20 09:08:09" resolution="Complete">
		<buginformation>
			<summary>Adding multiple listeners inside a single listener-container element is not working</summary>
			<description>If I am adding multiple listener classes inside a single &amp;lt;listener-container&amp;gt; element, only one of them is working i.e. the listener class which is defined at the last in XML e.g Please refer to the stackoverflow link above</description>
			<version>1.2.0.GA</version>
			<fixedVersion>1.2.1, 1.3.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.config.ListenerContainerParser.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.ListenerContainerPlaceholderParserTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.ListenerContainerParserTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="290" opendate="2013-01-04 02:26:52" fixdate="2013-09-25 12:11:46" resolution="Complete">
		<buginformation>
			<summary>Rabbit namespace little bug, when using reference to queueArgumentsMap</summary>
			<description>I am using some queues like that:






  &amp;lt;rabbit:queue name="${queue.name.routage.lot.reception}" durable="true" queue-arguments="defaultQueueArguments"/&amp;gt;




  &amp;lt;rabbit:queue name="${queue.name.routage.lot.mail.notification}" durable="true" queue-arguments="defaultQueueArguments"/&amp;gt;




  &amp;lt;rabbit:queue name="${queue.name.routage.lot.mobile.notification}" durable="true" queue-arguments="defaultQueueArguments"/&amp;gt;






I wanted to use:






  &amp;lt;util:map id="defaultQueueArgumentsMap"&amp;gt;




    &amp;lt;entry key="x-dead-letter-exchange" value="${exchange.name.dead.letters}"/&amp;gt;




  &amp;lt;/util:map&amp;gt;




  &amp;lt;rabbit:queue-arguments id="defaultQueueArguments" ref="defaultQueueArgumentsMap"/&amp;gt;






But this doesn&amp;amp;apos;t work: my queues are not created with the dead letter.
With a little google search I found:
http://forum.springsource.org/showthread.php?125014-Dead-Lettering
And when using:






  &amp;lt;rabbit:queue-arguments id="defaultQueueArguments"&amp;gt;




    &amp;lt;entry key="x-dead-letter-exchange" value="${exchange.name.dead.letters}" /&amp;gt;




  &amp;lt;/rabbit:queue-arguments&amp;gt;






It works fine (but my Intellij complains: element entry not allowed here)
I think both way should work.
XSD documentation says: ref = The bean name of the Map to pass to the broker when this component is declared.
</description>
			<version>1.1.2</version>
			<fixedVersion>1.2.1, 1.3.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.config.AbstractExchangeParser.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.ExchangeParserTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.QueueParserTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.QueueParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="338" opendate="2013-10-28 11:18:05" fixdate="2013-10-30 03:59:17" resolution="Complete">
		<buginformation>
			<summary>Container Doesn&amp;apos;t Stop Consuming</summary>
			<description>When the container is stopped, it should stop consuming from the queue, while allowing the prefetched messages to be processed (until the shutdown timeout).</description>
			<version>1.2.0.GA</version>
			<fixedVersion>1.2.1, 1.3.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerLifecycleIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="is depended on by">342</link>
		</links>
	</bug>
	<bug id="340" opendate="2013-11-18 09:41:01" fixdate="2013-12-02 12:39:09" resolution="Complete">
		<buginformation>
			<summary>Wrong RabbitMQ credentials are not considered as fatal error by SimpleMessageListenerContainer</summary>
			<description>If I connect an AmqpInboundChannelAdapter to the RabbitMQ (3.1.0) with wrong credentials (wrong password) the SimpleMessageListenerContainer doesn&amp;amp;apos;t detect the real reason and continues to restart the consumer in a seemingly endless loop. As AmqpInboundChannelAdapter user, I don&amp;amp;apos;t notice (except if I turn on debug logging level) any problem, its start() method returns after a pause with no error, but the connection remains not established.
It would be nice to have a notification (exception) about wrong credentials right away (there is a comprehensive rabbit client exception that gets swallowed in SimpleMessageListenerContainer.run())</description>
			<version>1.2.0.GA</version>
			<fixedVersion>1.2.1, 1.3.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerLifecycleIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.support.RabbitExceptionTranslator.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="355" opendate="2014-01-04 06:39:59" fixdate="2014-01-05 07:32:50" resolution="Complete">
		<buginformation>
			<summary>Fix Race Condition in Test Case</summary>
			<description>The ErrorHandler is not called unless the container is active; the container is stopped as soon as the 3rd message is received (on exit from the onMessage method).
So there is a (small) possibility that the container is not active when it&amp;amp;apos;s time to invoke the ErrorHandler and the verify fails because it was only called twice.</description>
			<version>1.2.0.GA</version>
			<fixedVersion>1.3.0.M1</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerErrorHandlerIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="359" opendate="2014-01-14 09:21:35" fixdate="2014-01-14 18:59:45" resolution="Complete">
		<buginformation>
			<summary>AmqpAppenderIntegrationTests should revert to default log4j.properties after its work</summary>
			<description>CI build logs (see Reference URL) show that DEBUG logging level for org.springframework.amqp.rabbit is switched by log4j-amqp.properties and isn&amp;amp;apos;t returned back to INFO.
It causes very slow test results parsing process on Bamboo.</description>
			<version>1.2.1</version>
			<fixedVersion>1.3.0.M2, 1.2.2</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppenderIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="363" opendate="2014-01-22 09:43:10" fixdate="2014-01-24 11:56:17" resolution="Complete">
		<buginformation>
			<summary>AmqpAppender appends throwable information even when layout handles it</summary>
			<description>I use AmqpAppender to log messages to RabbitMQ. I have a custom layout which converts data to JSON. Even though my layout handles ThrowableInformation, AmqpAppender re-appends ThrowableInformation and is messing up the message body. I use org.springframework.amqp spring-rabbit 1.2.0.RELEASE.
Please find log4j.xml and my custom Layout class SimpleJsonLayout attached.
Fix is to add just the first line below in AmqpAppender.EventSender.run()






if (layout.ignoresThrowable())




{









if (null != logEvent.getThrowableInformation()) {




						ThrowableInformation tinfo = logEvent.getThrowableInformation();




						for (String line : tinfo.getThrowableStrRep()) {




							msgBody.append(String.format("%s%n", line));




						}




					}




}






PFA java project with log4j.xml. Please set values for AMQPAppender in Log4j.xml and run Test.class to reproduce error.</description>
			<version>1.2.1</version>
			<fixedVersion>1.3.0.M2, 1.2.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppender.java</file>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppenderIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="365" opendate="2014-01-24 13:38:23" fixdate="2014-01-27 08:42:00" resolution="Complete">
		<buginformation>
			<summary>Fix Race Condition in Consumer Recovery Test Cases</summary>
			<description>Analysis
The test cases send 10 messages. The consumer uses manual ack and does a double ack on the first message causing the channel to be closed. It is a race between the broker closing the channel and the second message being received by the listener.
The listener counts down a latch that the test is waiting on.
If the broker loses the race, the channel is closed AFTER the second message is received by the listener and the message is redelivered after the consumer is recovered.
This results in 11 messages being received and the final test for a null message fails.
Solution
In the listener, only count down the latch if the message is NOT a redelivery (because the latch would have already been counted down for this message). However, we can&amp;amp;apos;t just test the redelivered flag - the message might have been sent by the broker but not actually received by the listener.
Add the message to a Set and only countdown the latch if it&amp;amp;apos;s not already received.</description>
			<version>1.2.1</version>
			<fixedVersion>1.3.0.M2, 1.2.2</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.connection.RabbitUtils.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerLifecycleIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerRecoveryCachingConnectionIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="369" opendate="2014-01-30 08:00:54" fixdate="2014-01-30 13:24:25" resolution="Complete">
		<buginformation>
			<summary>AmqpAdmin &lt;-&gt; Declarable classes tangle</summary>
			<description></description>
			<version>1.3.0.M1</version>
			<fixedVersion>1.3.0.M2</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.config.BindingFactoryBean.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdminDeclarationTests.java</file>
			<file type="M">org.springframework.amqp.core.Declarable.java</file>
			<file type="M">org.springframework.amqp.core.AbstractDeclarable.java</file>
		</fixedFiles>
	</bug>
	<bug id="371" opendate="2014-02-04 05:59:40" fixdate="2014-02-04 06:17:20" resolution="Complete">
		<buginformation>
			<summary>MessageBuilderSupport has wrong visibility</summary>
			<description>The restricted visibility means that method chaining can&amp;amp;apos;t be used, so the code below results in a compilation error:
MessageProperties props  = 
MessagePropertiesBuilder.newInstance()
.setHeader("fruit", fruit.toString())
.setHeader("seeds", fruit.seeds().toString())
.build();</description>
			<version>1.3.0.M2</version>
			<fixedVersion>1.3.0.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.core.MessageBuilderSupport.java</file>
			<file type="D">org.springframework.amqp.core.MessageBuilderTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="383" opendate="2014-03-08 02:23:06" fixdate="2014-03-10 03:21:48" resolution="Complete">
		<buginformation>
			<summary>Bindings are not re-established after re-creating anonymous queues</summary>
			<description>Whilst testing bug report AMQP-373
Stopping and starting a listener container creates the queue
However the bindings are not re-established when the queue is created for the second time hence, no messages can be routed to the queue.
Additionally heading off a potential future bug (before it happens):
Assuming that the listener-container is set to autoStart="false".
There is a discrepancy between the first and second start.
On the first start the binding will already exist, hence there "may" be messages in the queue when the container is manually started.
However on the second start the queue isn&amp;amp;apos;t created until the container is re-started (hence there are never any messages pending).
I can see how people may prefer either the first or second behavior depending on their use-case, however I doubt anyone would want both.</description>
			<version>1.3.0.RC1</version>
			<fixedVersion>1.3.0 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.ListenerContainerParser.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.ListenFromAutoDeleteQueueTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerIntegration2Tests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">373</link>
		</links>
	</bug>
	<bug id="384" opendate="2014-03-13 07:35:28" fixdate="2014-03-13 08:04:11" resolution="Complete">
		<buginformation>
			<summary>Fix NPE in Test Case</summary>
			<description>TestUtils needs to test for null before checking the type of the retrieved field.
Also, when iterating over the consumers, exit if the channel has not yet been assigned.






2014-03-13 05:21:52,613 WARN SimpleAsyncTaskExecutor-2 [org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer] - &amp;lt;Consumer raised exception, processing can restart if the connection factory supports it&amp;gt;




java.lang.NullPointerException




	at org.springframework.amqp.utils.test.TestUtils.getPropertyValue(TestUtils.java:60)




	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerTests$19.answer(SimpleMessageListenerContainerTests.java:536)




	at org.mockito.internal.stubbing.StubbedInvocationMatcher.answer(StubbedInvocationMatcher.java:34)





</description>
			<version>1.3.0.RC1</version>
			<fixedVersion>1.3.0 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerTests.java</file>
			<file type="M">org.springframework.amqp.utils.test.TestUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="385" opendate="2014-03-26 13:12:20" fixdate="2014-03-27 02:50:28" resolution="Complete">
		<buginformation>
			<summary>AmqpRejectAndDontRequeueException kills pub-sub-channel consumer</summary>
			<description>One documented way in spring-amqp to avoid message redelivery on listener failure is to inject an error-handler that throws AmqpRejectAndDontRequeueException. This works fine for SI amqp-backed point-to-point channels, but causes the consumer to attempt to restart for SI amqp-backed pub-sub channels. This attempt to restart fails because 
"there is a problem with the pub-sub channel in that if the consumer fails, it does not redeclare its queue - this has been partially addressed in 4.0.0.M3 (https://jira.spring.io/browse/INT-3278) in that the queue and binding will be redeclared in the event of a connection failure, but it still won&amp;amp;apos;t handle a fatal (but recoverable) consumer exception because it only redeclares when it detects a new connection is created."
See reference URL forum posting for more details from Gary Russell, who understands this stuff way better than I do.
From the forum posting: 
"In order for the AmqpRejectAndDontRequeueException to be non-fatal to the consumer, when thrown from an ErrorHandler, it needs to be wrapped in a ListenerExecutionFailedException (we should probably document that, or even treat ARADREs in the same way as LEFEs; please open up a JIRA issue: https://jira.spring.io/browse/AMQP)."</description>
			<version>1.2.1</version>
			<fixedVersion>1.2.2, 1.3.0 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerErrorHandlerIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="396" opendate="2014-05-26 07:15:39" fixdate="2014-05-29 10:26:00" resolution="Complete">
		<buginformation>
			<summary>Prefetch count = 0 after passive declare failure in BlockingQueueConsumer</summary>
			<description>When using the SimpleMessageListenerContainer and consuming from multiple passively declared queues and one of the queues does not exist.
Prefetch count for the channel remains at 0, which is not correct.</description>
			<version>1.3.3</version>
			<fixedVersion>1.3.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumerTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="398" opendate="2014-06-05 06:41:04" fixdate="2014-06-18 15:09:41" resolution="Complete">
		<buginformation>
			<summary>Direct exchange binding default routing key fails on queue name with dot char</summary>
			<description>If the queue name for rabbit direct-exchange binding contains a dot character, the default routing key evaluation will fail on non-existing bean &amp;lt;string_before_first_dot&amp;gt;, which unfortunately breaks all our direct-exchange bindings with such queue names.
Following configuration fails on unresolvable bean &amp;amp;apos;communication&amp;amp;apos;.






&amp;lt;rabbit:direct-exchange name="communication.mail"&amp;gt;




  &amp;lt;rabbit:bindings&amp;gt;




    &amp;lt;rabbit:binding queue="communication.mail" /&amp;gt;




  &amp;lt;/rabbit:bindings&amp;gt;




&amp;lt;/rabbit:direct-exchange&amp;gt;






What was the reason behind using SPEL expression as default routing key in DirectExchangeParser?
It would be ok if it&amp;amp;apos;s used with explicitly set key to take advantage of spel evaluation to provide flexible routing keys, but as a default, it&amp;amp;apos;s somehow undocumented hidden breaking magic.</description>
			<version>1.3.4</version>
			<fixedVersion>1.3.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.config.ExchangeParserIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.DirectExchangeParser.java</file>
		</fixedFiles>
		<links>
			<link type="Depend" description="depends on">230</link>
		</links>
	</bug>
	<bug id="421" opendate="2014-08-12 04:44:40" fixdate="2014-08-12 07:22:57" resolution="Complete">
		<buginformation>
			<summary>RabbitTemplate Memory Leak with Publisher Confirms/Returns</summary>
			<description>The wrong key is being used for `RabbitTemplate.pendingConfirms`. The rabbit template
stores the pending confirms map under the `ChannelProxy` whereas the
removal uses the actual `PublisherCallbackChannel` so the map
entry is not removed.</description>
			<version>1.3.5</version>
			<fixedVersion>1.4 M1, 1.3.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplate.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplatePublisherCallbacksIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="351" opendate="2013-12-19 11:48:49" fixdate="2014-09-04 04:57:18" resolution="Complete">
		<buginformation>
			<summary>MessageListenerAdaper.invokeListenerMethod - NoSuchMethodException causes endless loop</summary>
			<description>While developing a RabbitMQ simple project I had not implemented a method that I had specified when creating the MessageListenerAdapter.






new MessageListenerAdapter(new AlertsReceiver(), "receiveMessage");






Below is the corresponding stack trace. These logs continue to repeat until the application is killed. My understanding is with something as critical as finding a method that has not been implemented the logic should stop the processing of the message such that there isn&amp;amp;apos;t an endless loop.






2013-12-19 11:21:11.559  WARN 95672 [SimpleAsyncTaskExecutor-1] --- o.s.a.r.l.SimpleMessageListenerContainer : Execution of Rabbit message listener failed, and no ErrorHandler has been set.









org.springframework.amqp.rabbit.listener.ListenerExecutionFailedException: Failed to invoke target method &amp;amp;apos;receiveMessage&amp;amp;apos; with argument type = [class [B], value = [{[B@136c2849}]




	at org.springframework.amqp.rabbit.listener.adapter.MessageListenerAdapter.invokeListenerMethod(MessageListenerAdapter.java:467)




	at org.springframework.amqp.rabbit.listener.adapter.MessageListenerAdapter.onMessage(MessageListenerAdapter.java:358)




	at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:546)




	at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:472)




	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.access$001(SimpleMessageListenerContainer.java:61)




	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$1.invokeListener(SimpleMessageListenerContainer.java:110)




	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.invokeListener(SimpleMessageListenerContainer.java:611)




	at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.executeListener(AbstractMessageListenerContainer.java:454)




	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.doReceiveAndExecute(SimpleMessageListenerContainer.java:474)




	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.receiveAndExecute(SimpleMessageListenerContainer.java:458)




	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.access$300(SimpleMessageListenerContainer.java:61)




	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$AsyncMessageProcessingConsumer.run(SimpleMessageListenerContainer.java:551)




	at java.lang.Thread.run(Thread.java:724)




Caused by: java.lang.NoSuchMethodException: *omitted*.AlertReceiver.receiveMessage([B)




	at java.lang.Class.getMethod(Class.java:1655)




	at org.springframework.util.MethodInvoker.prepare(MethodInvoker.java:178)




	at org.springframework.amqp.rabbit.listener.adapter.MessageListenerAdapter.invokeListenerMethod(MessageListenerAdapter.java:450)




	... 12 common frames omitted





</description>
			<version>1.2.0.GA</version>
			<fixedVersion>1.4 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerIntegration2Tests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.java</file>
		</fixedFiles>
	</bug>
	<bug id="432" opendate="2014-10-10 02:07:28" fixdate="2014-10-20 11:34:37" resolution="Complete">
		<buginformation>
			<summary>Default MessagePropertiesConverter should convert LongString values nested in lists</summary>
			<description>Multi-valued headers are contained as List&amp;lt;Object&amp;gt; in BasicProperties.headers. LongString values contained in these Lists will not be converted.
AMQP header values are converted from LongString to either a String or a DataInputStream depending on their length:






for (Map.Entry&amp;lt;String, Object&amp;gt; entry : headers.entrySet()) {




	Object value = entry.getValue();




	if (value instanceof LongString) {




		value = this.convertLongString((LongString) value, charset);




	}




	target.setHeader(entry.getKey(), value);




}






A possible solution would be:






for (Map.Entry&amp;lt;String, Object&amp;gt; entry : headers.entrySet()) {




	Object value = entry.getValue();




	if (value instanceof LongString) {




		value = this.convertLongString((LongString) value, charset);




	} else if (value instanceof List) {




		List listValue = new ArrayList&amp;lt;Object&amp;gt;();




		for (Object v : (List)value) {




			if (v instanceof LongString) {




				v = this.convertLongString((LongString) v, charset);




			}




			listValue.add(v);




		}




		value = listValue;




	}




	target.setHeader(entry.getKey(), value);




}





</description>
			<version>1.3.6</version>
			<fixedVersion>1.4.RC1, 1.3.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.support.DefaultMessagePropertiesConverter.java</file>
		</fixedFiles>
	</bug>
	<bug id="434" opendate="2014-10-21 05:21:17" fixdate="2014-10-23 01:47:58" resolution="Complete">
		<buginformation>
			<summary>convertAndSend() methods can throw MessageConversionException but that&amp;apos;s not documented</summary>
			<description>This exception should be either added to the throws clause OR caught and wrapped in convertMessageIfNecessary()</description>
			<version>1.3.6</version>
			<fixedVersion>1.4.RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.support.converter.MessageConversionException.java</file>
		</fixedFiles>
	</bug>
	<bug id="438" opendate="2014-10-31 00:44:20" fixdate="2014-10-31 12:59:23" resolution="Complete">
		<buginformation>
			<summary>ConditionalRejectingErrorHandler.DefaultExceptionStrategy catches only org.springframework.amqp.support.converter.MessageConversionException</summary>
			<description>The DefaultExceptionStrategy in ConditionalRejectingErrorHandler only catches org.springframework.amqp.support.converter.MessageConversionException, whereas methods annotated with @RabbitListener now throw the more general org.springframework.messaging.converter.MessageConversionException (both wrapped in a org.springframework.amqp.rabbit.listener.exception.ListenerExecutionFailedException, of course).
Marked trivial because it is easy to fix by inserting your own strategy, but it would be nice if it worked out of the box.</description>
			<version>1.4.RC1</version>
			<fixedVersion>1.4 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.MethodRabbitListenerEndpointTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.annotation.EnableRabbitIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.adapter.MessagingMessageListenerAdapterTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.adapter.MessagingMessageListenerAdapter.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.ConditionalRejectingErrorHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="446" opendate="2014-11-26 08:50:50" fixdate="2014-12-11 10:03:04" resolution="Complete">
		<buginformation>
			<summary>RabbitAdmin warnings for autodeclaring anonymous queue</summary>
			<description>As I see it - these warnings just waste some disk space.

Auto-declaring an exclusive Queue ...
Auto-declaring an auto-delete Queue ...
Auto-declaring a non-durable Queue ...

1. if queue is anonymous then always 3 warnings are logged, makes no sense.
2. it makes no sense logging this in production, only as a hint during development
If these warnings are considered useful, then I would suggest adding a property "boolean enableHints", so I can disable them on production.</description>
			<version>1.4 GA</version>
			<fixedVersion>1.4.1</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdminTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdmin.java</file>
		</fixedFiles>
	</bug>
	<bug id="463" opendate="2015-01-05 09:46:22" fixdate="2015-01-06 03:48:06" resolution="Complete">
		<buginformation>
			<summary>PublisherCallbackChannelImpl Incompatible with JRockit</summary>
			<description>JRockit&amp;amp;apos;s TreeMap doesn&amp;amp;apos;t allow getValue() after remove on an Iterator.






						while (iterator.hasNext()) {




							Entry&amp;lt;Long, PendingConfirm&amp;gt; entry = iterator.next();




							iterator.remove();




							doHandleConfirm(ack, involvedListener, entry.getValue());




						}





</description>
			<version>1.3.7</version>
			<fixedVersion>1.3.8, 1.4.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.support.PublisherCallbackChannelImpl.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplatePublisherCallbacksIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdminDeclarationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">468</link>
		</links>
	</bug>
	<bug id="447" opendate="2014-11-27 19:42:03" fixdate="2015-01-08 11:57:07" resolution="Complete">
		<buginformation>
			<summary>AbstractConnectionFactory.setAddresses(String) should ignore empty string</summary>
			<description>At the moment if an empty string is passed it is parsed to an array with size 1 and empty host in Address (due to use of the String.split() method), which makes java connecting to localhost.
This is completely unexpected.
I&amp;amp;apos;ve raised this question in rabbitmq-java-client https://groups.google.com/forum/#!topic/rabbitmq-users/yIMnrcR9_o4 and throwing an exception is a possible option there.
I would suggest a hasText() check before in spring-amqp code.</description>
			<version>1.4 GA</version>
			<fixedVersion>1.5 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.connection.AbstractConnectionFactory.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactoryTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="468" opendate="2015-01-19 08:55:52" fixdate="2015-01-19 09:54:41" resolution="Duplicate">
		<buginformation>
			<summary>RabbitTemplate.convertAndSend is hanging occasionally</summary>
			<description>We have had an issue with the rabbitTemplate.convertAndSend(String, Object, CorrelationData) hanging occasionally.
On further analysis, we think the root of the problem is in org.springframework.amqp.rabbit.support.PublisherCallbackChannelImpl.processAck(PublisherCallbackChannelImpl)
In a large message volume environment when we throttle back the hardware we see this stack trace in the console.






DefaultExceptionHandler: ConfirmListener.handle{N,A}ck threw an exception for channel AMQChannel(amqp://spectrum@192.168.1.139:5672vhost.spectrum,1):




java.lang.IllegalStateException




        at java.util.TreeMap$Entry.getValue(TreeMap.java:139)




        at org.springframework.amqp.rabbit.support.PublisherCallbackChannelImpl.processAck(PublisherCallbackChannelImpl.java:658)




        at org.springframework.amqp.rabbit.support.PublisherCallbackChannelImpl.handleAck(PublisherCallbackChannelImpl.java:628)




        at com.rabbitmq.client.impl.ChannelN.processAsync(ChannelN.java:372)




        at com.rabbitmq.client.impl.AMQChannel.handleCompleteInboundCommand(AMQChannel.java:144)




        at com.rabbitmq.client.impl.AMQChannel.handleFrame(AMQChannel.java:91)




        at com.rabbitmq.client.impl.AMQConnection$MainLoop.run(AMQConnection.java:551)






I think that when this exception is thrown, the channel goes in to a bad state and does not respond when the rabbitTemplate.convertAndSend() is called.
Note:
We were not able to use the PublisherCallback functionality in production. We devised a different method to ensure message delivery.
We are using:

spring-rabbit-1.3.6.RELEASE.jar
spring-amqp-1.3.2.RELEASE.jar

Please let me know what additional information I can provide.</description>
			<version>1.3.6</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.support.PublisherCallbackChannelImpl.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplatePublisherCallbacksIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdminDeclarationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">463</link>
		</links>
	</bug>
	<bug id="470" opendate="2015-01-27 20:16:35" fixdate="2015-01-28 11:00:53" resolution="Complete">
		<buginformation>
			<summary>Connection Reset on basicQos Should Not Be Fatal</summary>
			<description>SimpleMessageListenerContainer
If a connection reset occurs in the (tiny) timing window between declaring the queue and setting basicQos, the container is stopped due to a fatal error.
This could occur if a network connection is re-broken soon after being re-established.
basicQos calls that fail due to a connection reset should not be considered fatal since it&amp;amp;apos;s likely a transient error.






2015-01-24 22:14:51.104 SimpleMessageListenerContainer [ERROR] Consumer received fatal exception on startup  ,tomcat_thread=SimpleAsyncTaskExecutor-64  




org.springframework.amqp.rabbit.listener.FatalListenerStartupException: Cannot set basicQos.




	at org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.start(BlockingQueueConsumer.java:418)




	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$AsyncMessageProcessingConsumer.run(SimpleMessageListenerContainer.java:963)




	at java.lang.Thread.run(Thread.java:722)




Caused by: java.io.IOException




	at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:106)




	at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:102)




	at com.rabbitmq.client.impl.AMQChannel.exnWrappingRpc(AMQChannel.java:124)




	at com.rabbitmq.client.impl.ChannelN.basicQos(ChannelN.java:599)




	at com.rabbitmq.client.impl.ChannelN.basicQos(ChannelN.java:613)




	at sun.reflect.GeneratedMethodAccessor105.invoke(Unknown Source)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:601)




	at org.springframework.amqp.rabbit.connection.CachingConnectionFactory$CachedChannelInvocationHandler.invoke(CachingConnectionFactory.java:536)




	at $Proxy87.basicQos(Unknown Source)




	at org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.start(BlockingQueueConsumer.java:414)




	... 2 more




Caused by: com.rabbitmq.client.ShutdownSignalException: connection error




	at com.rabbitmq.utility.ValueOrException.getValue(ValueOrException.java:67)




	at com.rabbitmq.utility.BlockingValueOrException.uninterruptibleGetValue(BlockingValueOrException.java:33)




	at com.rabbitmq.client.impl.AMQChannel$BlockingRpcContinuation.getReply(AMQChannel.java:343)




	at com.rabbitmq.client.impl.AMQChannel.privateRpc(AMQChannel.java:216)




	at com.rabbitmq.client.impl.AMQChannel.exnWrappingRpc(AMQChannel.java:118)




	... 10 more




Caused by: java.net.SocketException: Connection reset




	at java.net.SocketInputStream.read(SocketInputStream.java:189)




	at java.net.SocketInputStream.read(SocketInputStream.java:121)




	at java.io.BufferedInputStream.fill(BufferedInputStream.java:235)




	at java.io.BufferedInputStream.read(BufferedInputStream.java:254)




	at java.io.DataInputStream.readUnsignedByte(DataInputStream.java:288)




	at com.rabbitmq.client.impl.Frame.readFrom(Frame.java:95)




	at com.rabbitmq.client.impl.SocketFrameHandler.readFrame(SocketFrameHandler.java:139)




	at com.rabbitmq.client.impl.AMQConnection$MainLoop.run(AMQConnection.java:532)




	... 1 more




2015-01-24 22:14:51.161 SimpleMessageListenerContainer [ERROR] Stopping container from aborted consumer  ,tomcat_thread=SimpleAsyncTaskExecutor-51  





</description>
			<version>1.4.2</version>
			<fixedVersion>1.3.9, 1.4.3, 1.5 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerIntegration2Tests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">472</link>
		</links>
	</bug>
	<bug id="472" opendate="2015-01-29 06:08:34" fixdate="2015-01-30 10:08:55" resolution="Complete">
		<buginformation>
			<summary>Early Exit Queue Declaration on a Connection Reset</summary>
			<description>Related to AMQP-470.
In the SimpleMessageListenerContainer, passive queue declaration is retried after IO errors. It should only do so if the declaration fails due to a missing queue. We should take an early exit for other IO errors (such as connection reset).
Eventually after retries are exhausted, a QueuesNotAvailableException which is a FatalListenerStartupException is thrown.
</description>
			<version>1.3.8</version>
			<fixedVersion>1.3.9, 1.4.3, 1.5 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerIntegration2Tests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.RabbitNamespaceUtils.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.ListenerContainerParserTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.RabbitUtils.java</file>
			<file type="D">org.springframework.amqp.rabbit.listener.MessageListenerRecoverySingleConnectionIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumerTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">470</link>
		</links>
	</bug>
	<bug id="487" opendate="2015-04-02 15:04:10" fixdate="2015-04-03 03:44:24" resolution="Complete">
		<buginformation>
			<summary>NPE encountered when one Rabbit server in HA cluster went down</summary>
			<description>










org.springframework.messaging.MessageHandlingException: error occurred in message handler [org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint#0]; nested exception is java.lang.NullPointerException




	at org.springframework.integration.handler.AbstractMessageHandler.handleMessage(AbstractMessageHandler.java:84) ~[spring-integration-core-4.1.1.RELEASE.jar:na]




	at org.springframework.integration.dispatcher.AbstractDispatcher.tryOptimizedDispatch(AbstractDispatcher.java:116) ~[spring-integration-core-4.1.1.RELEASE.jar:na]




	at org.springframework.integration.dispatcher.UnicastingDispatcher.doDispatch(UnicastingDispatcher.java:101) ~[spring-integration-core-4.1.1.RELEASE.jar:na]




	at org.springframework.integration.dispatcher.UnicastingDispatcher.dispatch(UnicastingDispatcher.java:97) ~[spring-integration-core-4.1.1.RELEASE.jar:na]




	at org.springframework.integration.channel.AbstractSubscribableChannel.doSend(AbstractSubscribableChannel.java:77) ~[spring-integration-core-4.1.1.RELEASE.jar:na]




	at org.springframework.integration.channel.AbstractMessageChannel.send(AbstractMessageChannel.java:277) ~[spring-integration-core-4.1.1.RELEASE.jar:na]




	at org.springframework.integration.channel.AbstractMessageChannel.send(AbstractMessageChannel.java:239) ~[spring-integration-core-4.1.1.RELEASE.jar:na]




	at org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:115) ~[spring-messaging-4.1.4.RELEASE.jar:4.1.4.RELEASE]




	at org.springframework.messaging.core.GenericMessagingTemplate.doSend(GenericMessagingTemplate.java:45) ~[spring-messaging-4.1.4.RELEASE.jar:4.1.4.RELEASE]




	at org.springframework.messaging.core.AbstractMessageSendingTemplate.send(AbstractMessageSendingTemplate.java:95) ~[spring-messaging-4.1.4.RELEASE.jar:4.1.4.RELEASE]




	at org.springframework.messaging.core.AbstractMessageSendingTemplate.convertAndSend(AbstractMessageSendingTemplate.java:133) ~[spring-messaging-4.1.4.RELEASE.jar:4.1.4.RELEASE]




	at org.springframework.messaging.core.AbstractMessageSendingTemplate.convertAndSend(AbstractMessageSendingTemplate.java:125) ~[spring-messaging-4.1.4.RELEASE.jar:4.1.4.RELEASE]




	at org.springframework.integration.gateway.MessagingGatewaySupport.send(MessagingGatewaySupport.java:302) ~[spring-integration-core-4.1.1.RELEASE.jar:na]




	at org.springframework.integration.gateway.GatewayProxyFactoryBean.invokeGatewayMethod(GatewayProxyFactoryBean.java:417) ~[spring-integration-core-4.1.1.RELEASE.jar:na]




	at org.springframework.integration.gateway.GatewayProxyFactoryBean.doInvoke(GatewayProxyFactoryBean.java:374) ~[spring-integration-core-4.1.1.RELEASE.jar:na]




	at org.springframework.integration.gateway.GatewayProxyFactoryBean.invoke(GatewayProxyFactoryBean.java:365) ~[spring-integration-core-4.1.1.RELEASE.jar:na]




	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) [spring-aop-4.1.4.RELEASE.jar:4.1.4.RELEASE]




	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207) [spring-aop-4.1.4.RELEASE.jar:4.1.4.RELEASE]




	at com.sun.proxy.$Proxy150.publishRequested(Unknown Source) [na:na]




	




Caused by: java.lang.NullPointerException: null




	at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.getChannel(CachingConnectionFactory.java:331) ~[spring-rabbit-1.4.2.RELEASE.jar:na]




	at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.access$1100(CachingConnectionFactory.java:75) ~[spring-rabbit-1.4.2.RELEASE.jar:na]




	at org.springframework.amqp.rabbit.connection.CachingConnectionFactory$ChannelCachingConnectionProxy.createChannel(CachingConnectionFactory.java:752) ~[spring-rabbit-1.4.2.RELEASE.jar:na]




	at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils$1.createChannel(ConnectionFactoryUtils.java:85) ~[spring-rabbit-1.4.2.RELEASE.jar:na]




	at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.doGetTransactionalResourceHolder(ConnectionFactoryUtils.java:134) ~[spring-rabbit-1.4.2.RELEASE.jar:na]




	at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.getTransactionalResourceHolder(ConnectionFactoryUtils.java:67) ~[spring-rabbit-1.4.2.RELEASE.jar:na]




	at org.springframework.amqp.rabbit.core.RabbitTemplate.doExecute(RabbitTemplate.java:1036) ~[spring-rabbit-1.4.2.RELEASE.jar:na]




	at org.springframework.amqp.rabbit.core.RabbitTemplate.execute(RabbitTemplate.java:1029) ~[spring-rabbit-1.4.2.RELEASE.jar:na]




	at org.springframework.amqp.rabbit.core.RabbitTemplate.send(RabbitTemplate.java:541) ~[spring-rabbit-1.4.2.RELEASE.jar:na]




	at org.springframework.amqp.rabbit.core.RabbitTemplate.convertAndSend(RabbitTemplate.java:636) ~[spring-rabbit-1.4.2.RELEASE.jar:na]




	at org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint.send(AmqpOutboundEndpoint.java:331) ~[spring-integration-amqp-4.1.1.RELEASE.jar:na]




	at org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint.handleRequestMessage(AmqpOutboundEndpoint.java:323) ~[spring-integration-amqp-4.1.1.RELEASE.jar:na]




	at org.springframework.integration.handler.AbstractReplyProducingMessageHandler.handleMessageInternal(AbstractReplyProducingMessageHandler.java:99) ~[spring-integration-core-4.1.1.RELEASE.jar:na]




	at org.springframework.integration.handler.AbstractMessageHandler.handleMessage(AbstractMessageHandler.java:78) ~[spring-integration-core-4.1.1.RELEASE.jar:na]




	... 111 common frames omitted










</description>
			<version>1.4.2</version>
			<fixedVersion>1.5 M1, 1.4.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactoryTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="490" opendate="2015-04-09 05:00:16" fixdate="2015-04-22 10:53:49" resolution="Complete">
		<buginformation>
			<summary>Normal closes are logged as error</summary>
			<description>The following errors are logged during connection shutdown:






2015-04-09 13:34:47 CachingConnectionFactory       ERROR Channel shutdown: clean connection shutdown; protocol method: #method&amp;lt;connection.close&amp;gt;(reply-code=200, reply-text=OK, class-id=0, method-id=0)






It seems to me that org.springframework.amqp.rabbit.connection.RabbitUtils.isNormalChannelClose() returns false here because the shutdown reason is connection.close, not channel.close.</description>
			<version>1.4.4</version>
			<fixedVersion>1.5 M1, 1.4.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.connection.RabbitUtils.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactoryIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="481" opendate="2015-03-02 05:28:36" fixdate="2015-05-06 09:10:58" resolution="Complete">
		<buginformation>
			<summary>@RabbitListener cannot be a scoped proxy</summary>
			<description>Because of the way the endpoints are detected in a BeanPostProcessor and the message listener container is started in a SmartInitializingBean, the listener is never registered if it is a scoped proxy (e.g. @Scope(proxyMode=TARGET_CLASS) @Lazy). The BeanPostProcessor is not presented with the actual listener until it is instantiated, and the instantiation happens lazily, the container is never created or started (I believe it&amp;amp;apos;s because the call to RabbitListenerEndpointRegistrar.afterPropertiesSet() in RabbitListenerAnnotationBeanPostProcessor.afterSingletonsInstantiated() is never made).
See https://github.com/spring-cloud/spring-cloud-config/issues/96 for original user&amp;amp;apos;s issue.</description>
			<version>1.4.3</version>
			<fixedVersion>1.5 M1, 1.4.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.RabbitListenerEndpointRegistry.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.RabbitListenerEndpointRegistrar.java</file>
			<file type="M">org.springframework.amqp.rabbit.annotation.EnableRabbitTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">12774</link>
		</links>
	</bug>
	<bug id="469" opendate="2015-01-21 02:59:57" fixdate="2015-05-08 03:47:08" resolution="Complete">
		<buginformation>
			<summary>Thread safety of ErlangTemplate</summary>
			<description>ErlangTemplate.executeErlangRpc is not threadsafe when used with SingleConnectionFactory.
The code in ErlangTemplate.executeErlangRpc first calls connection.sendRPC then calls connection.receiveRPC(). When used with the SingleConnectionFactory this means that another thread could also be using the same connection.
The end result of this is that connection.sendRPC and connection.receiveRPC() requests become interleaved.
I believe, but have not checked, that with SimpleConnectionFactory, this would not happen as each thread would have its own connection.
I understand that thread safety is not documented, so should be not assumed, so I am issuing this bug mainly to request documentation on the thread safety of the ErlangTemplate.
If ErlangTemplate is intended to be thread safe, this bug should be raised to "Critical".</description>
			<version>1.4.1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.admin.JInterfaceIntegrationTests.java</file>
			<file type="M">org.springframework.erlang.core.ErlangTemplate.java</file>
			<file type="M">org.springframework.erlang.connection.Connection.java</file>
			<file type="M">org.springframework.erlang.connection.DefaultConnection.java</file>
		</fixedFiles>
	</bug>
	<bug id="498" opendate="2015-05-12 00:50:49" fixdate="2015-05-12 08:16:37" resolution="Complete">
		<buginformation>
			<summary>Dynamic Consumer Adjustment Does Not Work when Channel is Transacted</summary>
			<description></description>
			<version>1.4.5</version>
			<fixedVersion>1.5 RC1, 1.4.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerLongTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="502" opendate="2015-06-19 03:02:33" fixdate="2015-06-19 11:11:55" resolution="Complete">
		<buginformation>
			<summary>Fanout binding is not created due to missing routing key</summary>
			<description>Currently i am using spring-cloud-starter-bus-amqp which in terms references spring-amqp 1.4.3.
when i declare a rabbitlistener like this:






  @RabbitListener(




      bindings = @QueueBinding(




          value = @Queue(




              autoDelete = "true"




          ),




          exchange = @Exchange(




              type = "fanout",




              value = "mytest.broadcast",




              autoDelete = "true"




          ),




          key = "#"




      )




  )




  public void processBroadcast(String data) {




    int i = 0;




  }






I will get an error, that the binding can not be created.
If i try another exchange type, the binding works.
Edit: It also does not work if omit the key.
The following is the debug logout and the stacktrace:






11:53:20.977 DEBUG   org.springframework.amqp.rabbit.core.RabbitAdmin - Initializing declarations 




11:53:20.980  INFO   org.springframework.amqp.rabbit.core.RabbitAdmin - Auto-declaring a non-durable or auto-delete Exchange (mytest.broadcast) durable:false, auto-delete:true. It will be deleted by the broker if it shuts down, and can be redeclared by closing and reopening the connection. 




11:53:20.980  INFO   org.springframework.amqp.rabbit.core.RabbitAdmin - Auto-declaring a non-durable, auto-delete, or exclusive Queue (5df237ec-13d4-4aab-a0ff-772707bd7d03) durable:false, auto-delete:false, exclusive:true. It will be redeclared if the broker stops and is restarted while the connection factory is alive, but all messages will be lost. 




11:53:20.982 DEBUG   o.s.a.rabbit.connection.CachingConnectionFactory - Creating cached Rabbit Channel from AMQChannel(amqp://stinger@10.0.10.34:5672/,1) 




11:53:20.982 DEBUG  o.springframework.amqp.rabbit.core.RabbitTemplate - Executing callback on RabbitMQ Channel: Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1) 




11:53:20.982 DEBUG   org.springframework.amqp.rabbit.core.RabbitAdmin - declaring Exchange &amp;amp;apos;mytest.broadcast&amp;amp;apos; 




11:53:20.984 DEBUG   org.springframework.amqp.rabbit.core.RabbitAdmin - declaring Queue &amp;amp;apos;5df237ec-13d4-4aab-a0ff-772707bd7d03&amp;amp;apos; 




11:53:20.989 DEBUG   org.springframework.amqp.rabbit.core.RabbitAdmin - Binding destination [5df237ec-13d4-4aab-a0ff-772707bd7d03 (QUEUE)] to exchange [mytest.broadcast] with routing key [null] 




11:53:20.991 DEBUG    o.s.a.r.listener.SimpleMessageListenerContainer - Recovering consumer in 5000 ms. 




11:53:20.991 DEBUG    o.s.a.r.listener.SimpleMessageListenerContainer - Starting Rabbit listener container. 




11:53:20.992 DEBUG     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Starting consumer Consumer: tags=[{}], channel=null, acknowledgeMode=AUTO local queue size=0 




11:53:20.998 DEBUG     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Started on queue &amp;amp;apos;5df237ec-13d4-4aab-a0ff-772707bd7d03&amp;amp;apos; with tag amq.ctag-Gai8Uo2Q0SYYJDbSopNtLA: Consumer: tags=[{amq.ctag-Gai8Uo2Q0SYYJDbSopNtLA=5df237ec-13d4-4aab-a0ff-772707bd7d03}], channel=Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1), acknowledgeMode=AUTO local queue size=0 




11:53:20.998 DEBUG     o.s.amqp.rabbit.listener.BlockingQueueConsumer - ConsumeOK : Consumer: tags=[{amq.ctag-Gai8Uo2Q0SYYJDbSopNtLA=5df237ec-13d4-4aab-a0ff-772707bd7d03}], channel=Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1), acknowledgeMode=AUTO local queue size=0 




11:53:20.999 DEBUG     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Retrieving delivery for Consumer: tags=[{amq.ctag-Gai8Uo2Q0SYYJDbSopNtLA=5df237ec-13d4-4aab-a0ff-772707bd7d03}], channel=Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1), acknowledgeMode=AUTO local queue size=0 




11:53:21.093  INFO             mytest.server.Server - Started Server in 16.957 seconds (JVM running for 18.151) 




11:53:22.003 DEBUG     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Retrieving delivery for Consumer: tags=[{amq.ctag-Gai8Uo2Q0SYYJDbSopNtLA=5df237ec-13d4-4aab-a0ff-772707bd7d03}], channel=Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1), acknowledgeMode=AUTO local queue size=0 




11:53:23.004 DEBUG     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Retrieving delivery for Consumer: tags=[{amq.ctag-Gai8Uo2Q0SYYJDbSopNtLA=5df237ec-13d4-4aab-a0ff-772707bd7d03}], channel=Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1), acknowledgeMode=AUTO local queue size=0 




11:53:24.009 DEBUG     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Retrieving delivery for Consumer: tags=[{amq.ctag-Gai8Uo2Q0SYYJDbSopNtLA=5df237ec-13d4-4aab-a0ff-772707bd7d03}], channel=Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1), acknowledgeMode=AUTO local queue size=0 




11:53:25.013 DEBUG     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Retrieving delivery for Consumer: tags=[{amq.ctag-Gai8Uo2Q0SYYJDbSopNtLA=5df237ec-13d4-4aab-a0ff-772707bd7d03}], channel=Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1), acknowledgeMode=AUTO local queue size=0 




11:53:26.017 DEBUG     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Retrieving delivery for Consumer: tags=[{amq.ctag-Gai8Uo2Q0SYYJDbSopNtLA=5df237ec-13d4-4aab-a0ff-772707bd7d03}], channel=Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1), acknowledgeMode=AUTO local queue size=0 




11:53:26.071  WARN    o.s.a.r.listener.SimpleMessageListenerContainer - Consumer raised exception, processing can restart if the connection factory supports it 




org.springframework.amqp.UncategorizedAmqpException: java.lang.IllegalStateException: Invalid configuration: &amp;amp;apos;routingKey&amp;amp;apos; must be non-null.




	at org.springframework.amqp.rabbit.support.RabbitExceptionTranslator.convertRabbitAccessException(RabbitExceptionTranslator.java:66) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.connection.RabbitAccessor.convertRabbitAccessException(RabbitAccessor.java:110) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.core.RabbitTemplate.doExecute(RabbitTemplate.java:1124) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.core.RabbitTemplate.execute(RabbitTemplate.java:1101) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.core.RabbitTemplate.execute(RabbitTemplate.java:1077) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.core.RabbitAdmin.initialize(RabbitAdmin.java:381) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.core.RabbitAdmin$11.onCreate(RabbitAdmin.java:323) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.connection.CompositeConnectionListener.onCreate(CompositeConnectionListener.java:32) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.createConnection(CachingConnectionFactory.java:446) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils$1.createConnection(ConnectionFactoryUtils.java:80) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.doGetTransactionalResourceHolder(ConnectionFactoryUtils.java:130) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.getTransactionalResourceHolder(ConnectionFactoryUtils.java:67) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.start(BlockingQueueConsumer.java:451) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$AsyncMessageProcessingConsumer.run(SimpleMessageListenerContainer.java:1107) ~[spring-rabbit-1.5.0.M1.jar:na]




	at java.lang.Thread.run(Thread.java:745) [na:1.8.0_20-ea]




Caused by: java.lang.IllegalStateException: Invalid configuration: &amp;amp;apos;routingKey&amp;amp;apos; must be non-null.




	at com.rabbitmq.client.impl.AMQImpl$Queue$Bind.&amp;lt;init&amp;gt;(AMQImpl.java:1577) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.AMQP$Queue$Bind$Builder.build(AMQP.java:870) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.ChannelN.queueBind(ChannelN.java:918) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.ChannelN.queueBind(ChannelN.java:61) ~[amqp-client-3.5.1.jar:na]




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_20-ea]




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_20-ea]




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_20-ea]




	at java.lang.reflect.Method.invoke(Method.java:483) ~[na:1.8.0_20-ea]




	at org.springframework.amqp.rabbit.connection.CachingConnectionFactory$CachedChannelInvocationHandler.invoke(CachingConnectionFactory.java:633) ~[spring-rabbit-1.5.0.M1.jar:na]




	at com.sun.proxy.$Proxy0.queueBind(Unknown Source) ~[na:na]




	at org.springframework.amqp.rabbit.core.RabbitAdmin.declareBindings(RabbitAdmin.java:480) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.core.RabbitAdmin.access$300(RabbitAdmin.java:54) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.core.RabbitAdmin$12.doInRabbit(RabbitAdmin.java:386) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.core.RabbitTemplate.doExecute(RabbitTemplate.java:1118) ~[spring-rabbit-1.5.0.M1.jar:na]




	... 12 common frames omitted




11:53:26.071  INFO    o.s.a.r.listener.SimpleMessageListenerContainer - Restarting Consumer: tags=[{}], channel=null, acknowledgeMode=AUTO local queue size=0 




11:53:26.071 DEBUG     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Closing Rabbit Channel: null 




11:53:26.072 DEBUG  o.springframework.amqp.rabbit.core.RabbitTemplate - Executing callback on RabbitMQ Channel: Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1) 




11:53:26.072 DEBUG  o.springframework.amqp.rabbit.core.RabbitTemplate - Publishing message on exchange [errors], routingKey = [org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.WARN] 




11:53:26.072 DEBUG     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Starting consumer Consumer: tags=[{}], channel=null, acknowledgeMode=AUTO local queue size=0 




11:53:26.075 DEBUG   o.s.a.rabbit.connection.CachingConnectionFactory - Creating cached Rabbit Channel from AMQChannel(amqp://stinger@10.0.10.34:5672/,2) 




11:53:26.077 DEBUG   o.s.a.rabbit.connection.CachingConnectionFactory - Channel shutdown: channel error; protocol method: #method&amp;lt;channel.close&amp;gt;(reply-code=404, reply-text=NOT_FOUND - no queue &amp;amp;apos;493eb6d6-8340-44a8-b73f-ab93446407dc&amp;amp;apos; in vhost &amp;amp;apos;/&amp;amp;apos;, class-id=50, method-id=10) 




11:53:26.079 DEBUG   o.s.a.rabbit.connection.CachingConnectionFactory - Detected closed channel on exception.  Re-initializing: null 




11:53:26.080  WARN     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Failed to declare queue:493eb6d6-8340-44a8-b73f-ab93446407dc 




11:53:26.081 DEBUG  o.springframework.amqp.rabbit.core.RabbitTemplate - Executing callback on RabbitMQ Channel: Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1) 




11:53:26.081 DEBUG  o.springframework.amqp.rabbit.core.RabbitTemplate - Publishing message on exchange [errors], routingKey = [org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.WARN] 




11:53:26.081  WARN     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Queue declaration failed; retries left=3 




org.springframework.amqp.rabbit.listener.BlockingQueueConsumer$DeclarationException: Failed to declare queue(s):[493eb6d6-8340-44a8-b73f-ab93446407dc]




	at org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.attemptPassiveDeclarations(BlockingQueueConsumer.java:554) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.start(BlockingQueueConsumer.java:465) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$AsyncMessageProcessingConsumer.run(SimpleMessageListenerContainer.java:1107) [spring-rabbit-1.5.0.M1.jar:na]




	at java.lang.Thread.run(Thread.java:745) [na:1.8.0_20-ea]




Caused by: java.io.IOException: null




	at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:106) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:102) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.AMQChannel.exnWrappingRpc(AMQChannel.java:124) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.ChannelN.queueDeclarePassive(ChannelN.java:873) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.ChannelN.queueDeclarePassive(ChannelN.java:61) ~[amqp-client-3.5.1.jar:na]




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_20-ea]




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_20-ea]




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_20-ea]




	at java.lang.reflect.Method.invoke(Method.java:483) ~[na:1.8.0_20-ea]




	at org.springframework.amqp.rabbit.connection.CachingConnectionFactory$CachedChannelInvocationHandler.invoke(CachingConnectionFactory.java:633) ~[spring-rabbit-1.5.0.M1.jar:na]




	at com.sun.proxy.$Proxy0.queueDeclarePassive(Unknown Source) ~[na:na]




	at org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.attemptPassiveDeclarations(BlockingQueueConsumer.java:544) ~[spring-rabbit-1.5.0.M1.jar:na]




	... 3 common frames omitted




Caused by: com.rabbitmq.client.ShutdownSignalException: channel error; protocol method: #method&amp;lt;channel.close&amp;gt;(reply-code=404, reply-text=NOT_FOUND - no queue &amp;amp;apos;493eb6d6-8340-44a8-b73f-ab93446407dc&amp;amp;apos; in vhost &amp;amp;apos;/&amp;amp;apos;, class-id=50, method-id=10)




	at com.rabbitmq.utility.ValueOrException.getValue(ValueOrException.java:67) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.utility.BlockingValueOrException.uninterruptibleGetValue(BlockingValueOrException.java:33) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.AMQChannel$BlockingRpcContinuation.getReply(AMQChannel.java:348) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.AMQChannel.privateRpc(AMQChannel.java:221) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.AMQChannel.exnWrappingRpc(AMQChannel.java:118) ~[amqp-client-3.5.1.jar:na]




	... 12 common frames omitted




Caused by: com.rabbitmq.client.ShutdownSignalException: channel error; protocol method: #method&amp;lt;channel.close&amp;gt;(reply-code=404, reply-text=NOT_FOUND - no queue &amp;amp;apos;493eb6d6-8340-44a8-b73f-ab93446407dc&amp;amp;apos; in vhost &amp;amp;apos;/&amp;amp;apos;, class-id=50, method-id=10)




	at com.rabbitmq.client.impl.ChannelN.asyncShutdown(ChannelN.java:478) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.ChannelN.processAsync(ChannelN.java:315) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.AMQChannel.handleCompleteInboundCommand(AMQChannel.java:144) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.AMQChannel.handleFrame(AMQChannel.java:91) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.AMQConnection$MainLoop.run(AMQConnection.java:552) ~[amqp-client-3.5.1.jar:na]




	... 1 common frames omitted




11:53:26.081 DEBUG  o.springframework.amqp.rabbit.core.RabbitTemplate - Executing callback on RabbitMQ Channel: Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1) 




11:53:26.081 DEBUG  o.springframework.amqp.rabbit.core.RabbitTemplate - Publishing message on exchange [errors], routingKey = [org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.WARN] 




11:53:27.018 DEBUG     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Retrieving delivery for Consumer: tags=[{amq.ctag-Gai8Uo2Q0SYYJDbSopNtLA=5df237ec-13d4-4aab-a0ff-772707bd7d03}], channel=Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1), acknowledgeMode=AUTO local queue size=0 




11:53:28.022 DEBUG     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Retrieving delivery for Consumer: tags=[{amq.ctag-Gai8Uo2Q0SYYJDbSopNtLA=5df237ec-13d4-4aab-a0ff-772707bd7d03}], channel=Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1), acknowledgeMode=AUTO local queue size=0 




11:53:29.025 DEBUG     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Retrieving delivery for Consumer: tags=[{amq.ctag-Gai8Uo2Q0SYYJDbSopNtLA=5df237ec-13d4-4aab-a0ff-772707bd7d03}], channel=Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1), acknowledgeMode=AUTO local queue size=0 




11:53:30.030 DEBUG     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Retrieving delivery for Consumer: tags=[{amq.ctag-Gai8Uo2Q0SYYJDbSopNtLA=5df237ec-13d4-4aab-a0ff-772707bd7d03}], channel=Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1), acknowledgeMode=AUTO local queue size=0 




11:53:31.034 DEBUG     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Retrieving delivery for Consumer: tags=[{amq.ctag-Gai8Uo2Q0SYYJDbSopNtLA=5df237ec-13d4-4aab-a0ff-772707bd7d03}], channel=Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1), acknowledgeMode=AUTO local queue size=0 




11:53:31.086 DEBUG   o.s.a.rabbit.connection.CachingConnectionFactory - Channel shutdown: channel error; protocol method: #method&amp;lt;channel.close&amp;gt;(reply-code=404, reply-text=NOT_FOUND - no queue &amp;amp;apos;493eb6d6-8340-44a8-b73f-ab93446407dc&amp;amp;apos; in vhost &amp;amp;apos;/&amp;amp;apos;, class-id=50, method-id=10) 




11:53:31.086 DEBUG   o.s.a.rabbit.connection.CachingConnectionFactory - Detected closed channel on exception.  Re-initializing: null 




11:53:31.088  WARN     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Failed to declare queue:493eb6d6-8340-44a8-b73f-ab93446407dc 




11:53:31.089 DEBUG  o.springframework.amqp.rabbit.core.RabbitTemplate - Executing callback on RabbitMQ Channel: Cached Rabbit Channel: AMQChannel(amqp://stinger@10.0.10.34:5672/,1) 




11:53:31.089 DEBUG  o.springframework.amqp.rabbit.core.RabbitTemplate - Publishing message on exchange [errors], routingKey = [org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.WARN] 




11:53:31.089  WARN     o.s.amqp.rabbit.listener.BlockingQueueConsumer - Queue declaration failed; retries left=2 




org.springframework.amqp.rabbit.listener.BlockingQueueConsumer$DeclarationException: Failed to declare queue(s):[493eb6d6-8340-44a8-b73f-ab93446407dc]




	at org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.attemptPassiveDeclarations(BlockingQueueConsumer.java:554) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.start(BlockingQueueConsumer.java:465) ~[spring-rabbit-1.5.0.M1.jar:na]




	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$AsyncMessageProcessingConsumer.run(SimpleMessageListenerContainer.java:1107) [spring-rabbit-1.5.0.M1.jar:na]




	at java.lang.Thread.run(Thread.java:745) [na:1.8.0_20-ea]




Caused by: java.io.IOException: null




	at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:106) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.AMQChannel.wrap(AMQChannel.java:102) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.AMQChannel.exnWrappingRpc(AMQChannel.java:124) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.ChannelN.queueDeclarePassive(ChannelN.java:873) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.ChannelN.queueDeclarePassive(ChannelN.java:61) ~[amqp-client-3.5.1.jar:na]




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_20-ea]




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_20-ea]




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_20-ea]




	at java.lang.reflect.Method.invoke(Method.java:483) ~[na:1.8.0_20-ea]




	at org.springframework.amqp.rabbit.connection.CachingConnectionFactory$CachedChannelInvocationHandler.invoke(CachingConnectionFactory.java:633) ~[spring-rabbit-1.5.0.M1.jar:na]




	at com.sun.proxy.$Proxy0.queueDeclarePassive(Unknown Source) ~[na:na]




	at org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.attemptPassiveDeclarations(BlockingQueueConsumer.java:544) ~[spring-rabbit-1.5.0.M1.jar:na]




	... 3 common frames omitted




Caused by: com.rabbitmq.client.ShutdownSignalException: channel error; protocol method: #method&amp;lt;channel.close&amp;gt;(reply-code=404, reply-text=NOT_FOUND - no queue &amp;amp;apos;493eb6d6-8340-44a8-b73f-ab93446407dc&amp;amp;apos; in vhost &amp;amp;apos;/&amp;amp;apos;, class-id=50, method-id=10)




	at com.rabbitmq.utility.ValueOrException.getValue(ValueOrException.java:67) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.utility.BlockingValueOrException.uninterruptibleGetValue(BlockingValueOrException.java:33) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.AMQChannel$BlockingRpcContinuation.getReply(AMQChannel.java:348) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.AMQChannel.privateRpc(AMQChannel.java:221) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.AMQChannel.exnWrappingRpc(AMQChannel.java:118) ~[amqp-client-3.5.1.jar:na]




	... 12 common frames omitted




Caused by: com.rabbitmq.client.ShutdownSignalException: channel error; protocol method: #method&amp;lt;channel.close&amp;gt;(reply-code=404, reply-text=NOT_FOUND - no queue &amp;amp;apos;493eb6d6-8340-44a8-b73f-ab93446407dc&amp;amp;apos; in vhost &amp;amp;apos;/&amp;amp;apos;, class-id=50, method-id=10)




	at com.rabbitmq.client.impl.ChannelN.asyncShutdown(ChannelN.java:478) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.ChannelN.processAsync(ChannelN.java:315) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.AMQChannel.handleCompleteInboundCommand(AMQChannel.java:144) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.AMQChannel.handleFrame(AMQChannel.java:91) ~[amqp-client-3.5.1.jar:na]




	at com.rabbitmq.client.impl.AMQConnection$MainLoop.run(AMQConnection.java:552) ~[amqp-client-3.5.1.jar:na]




	... 1 common frames omitted





</description>
			<version>1.5 M1</version>
			<fixedVersion>1.5 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.annotation.RabbitListenerAnnotationBeanPostProcessor.java</file>
			<file type="M">org.springframework.amqp.rabbit.annotation.EnableRabbitIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="496" opendate="2015-05-08 08:03:04" fixdate="2015-06-23 06:39:26" resolution="Complete">
		<buginformation>
			<summary>Some threads are not interrupted when Workers did not finish before shutdownTimeout</summary>
			<description>Please see http://stackoverflow.com/questions/30124537/spring-amqp-with-rabbitmq-does-not-shutdown-properly for details</description>
			<version>1.4.5</version>
			<fixedVersion>1.5 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerLifecycleIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactory.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">536</link>
			<link type="Relate" description="relates to">546</link>
			<link type="Relate" description="relates to">526</link>
		</links>
	</bug>
	<bug id="506" opendate="2015-06-26 13:51:22" fixdate="2015-06-29 09:34:58" resolution="Complete">
		<buginformation>
			<summary>ConcurrentModificationException on RabbitTemplate.getUnconfirmed()</summary>
			<description>Although we&amp;amp;apos;re synchronized on pendingConfirms, the values are maps and we fail to synchronize on those while iterating/removing.</description>
			<version>1.4.5</version>
			<fixedVersion>1.3.10, 1.5 RC1, 1.4.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.support.PublisherCallbackChannelImpl.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplate.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplatePublisherCallbacksIntegrationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">532</link>
		</links>
	</bug>
	<bug id="508" opendate="2015-06-28 07:56:30" fixdate="2015-06-29 09:44:34" resolution="Complete">
		<buginformation>
			<summary>Admin Hang After IllegalArgumentException on declareQueue()</summary>
			<description></description>
			<version>1.4.5</version>
			<fixedVersion>1.5 RC1, 1.4.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumerIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdmin.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdminTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="516" opendate="2015-08-06 01:25:34" fixdate="2015-08-07 09:46:00" resolution="Complete">
		<buginformation>
			<summary>Setting autoDelete or exclusive to anything, including "true" in @Queue without a queue name results in them being disabled</summary>
			<description>The following queue declaration will result in a queue being declared with auto delete and exclusive set to false:






@RabbitListener(bindings = @QueueBinding(




    value = @Queue(autoDelete = "true", exclusive = "true"),




    exchange = @Exchange(value = "myFanout", type = ExchangeTypes.FANOUT, durable = "true")




))






due to the following code in RabbitListenerAnnotationBeanProcessor:






if (!StringUtils.hasText(queueName)) {




    queueName = UUID.randomUUID().toString();




    if (!StringUtils.hasText(bindingQueue.exclusive())) {




        exclusive = true;




    }




    if (!StringUtils.hasText(bindingQueue.autoDelete())) {




        autoDelete = true;




    }




}




else {




    exclusive = resolveExpressionAsBoolean(bindingQueue.exclusive());




    autoDelete = resolveExpressionAsBoolean(bindingQueue.autoDelete());




}






Making them exclusive and auto delete by default when using a random name seems like a good idea, but it should probably be changed to something like:






String e = bindingQueue.exclusive();




if (!StringUtils.hasText(e) || resolveExpressionAsBoolean(e)) {




    exclusive = true




}





</description>
			<version>1.5 M1</version>
			<fixedVersion>1.5 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.annotation.RabbitListenerAnnotationBeanPostProcessor.java</file>
			<file type="M">org.springframework.amqp.rabbit.annotation.EnableRabbitIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="532" opendate="2015-09-03 20:40:54" fixdate="2015-09-13 17:31:37" resolution="Complete">
		<buginformation>
			<summary>ConcurrentModificationException in PublisherCallbackChannelImpl</summary>
			<description>While testing continuous publishing to a RabbitMQ node that I blocked network traffic to (simulating a network partition), I got this ConcurrentModificationException in PublisherCallbackChannelImpl, the line number indicates that this happened in the pendingConfirms map. Looking at the source code, the code is guarded by synchronizing on the map, while other places in the code where the map is accessed are synchronized on the PublisherCallbackChannelImpl itself.
Stacktrace below:






Caused by: java.util.ConcurrentModificationException: null




        at java.util.TreeMap$PrivateEntryIterator.nextEntry(TreeMap.java:1207) ~[na:1.8.0_60]




        at java.util.TreeMap$EntryIterator.next(TreeMap.java:1243) ~[na:1.8.0_60]




        at java.util.TreeMap$EntryIterator.next(TreeMap.java:1238) ~[na:1.8.0_60]




        at org.springframework.amqp.rabbit.support.PublisherCallbackChannelImpl.generateNacksForPendingAcks(PublisherCallbackChannelImpl.java:637) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.support.PublisherCallbackChannelImpl.close(PublisherCallbackChannelImpl.java:630) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.getChannel(CachingConnectionFactory.java:333) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.access$1100(CachingConnectionFactory.java:75) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.connection.CachingConnectionFactory$ChannelCachingConnectionProxy.createChannel(CachingConnectionFactory.java:763) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils$1.createChannel(ConnectionFactoryUtils.java:85) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.doGetTransactionalResourceHolder(ConnectionFactoryUtils.java:134) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.getTransactionalResourceHolder(ConnectionFactoryUtils.java:67) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.core.RabbitTemplate.doExecute(RabbitTemplate.java:1035) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.core.RabbitTemplate.execute(RabbitTemplate.java:1028) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.core.RabbitTemplate.execute(RabbitTemplate.java:1004) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.core.RabbitAdmin.initialize(RabbitAdmin.java:381) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.core.RabbitAdmin$11.onCreate(RabbitAdmin.java:323) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.connection.CompositeConnectionListener.onCreate(CompositeConnectionListener.java:32) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.createConnection(CachingConnectionFactory.java:446) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.createBareChannel(CachingConnectionFactory.java:391) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.getCachedChannelProxy(CachingConnectionFactory.java:364) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.getChannel(CachingConnectionFactory.java:357) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.access$1100(CachingConnectionFactory.java:75) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.connection.CachingConnectionFactory$ChannelCachingConnectionProxy.createChannel(CachingConnectionFactory.java:763) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils$1.createChannel(ConnectionFactoryUtils.java:85) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.doGetTransactionalResourceHolder(ConnectionFactoryUtils.java:134) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.getTransactionalResourceHolder(ConnectionFactoryUtils.java:67) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.core.RabbitTemplate.doExecute(RabbitTemplate.java:1035) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.core.RabbitTemplate.execute(RabbitTemplate.java:1028) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.core.RabbitTemplate.send(RabbitTemplate.java:540) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.amqp.rabbit.core.RabbitTemplate.convertAndSend(RabbitTemplate.java:635) ~[spring-rabbit-1.4.5.RELEASE.jar:na]




        at org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint.send(AmqpOutboundEndpoint.java:331) ~[spring-integration-amqp-4.1.5.RELEASE.jar:na]




        at org.springframework.integration.amqp.outbound.AmqpOutboundEndpoint.handleRequestMessage(AmqpOutboundEndpoint.java:323) ~[spring-integration-amqp-4.1.5.RELEASE.jar:na]





</description>
			<version>1.4.5</version>
			<fixedVersion>1.4.6, 1.5.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.support.PublisherCallbackChannelImpl.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplatePublisherCallbacksIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplate.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactory.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">506</link>
			<link type="Relate" description="relates to">535</link>
		</links>
	</bug>
	<bug id="540" opendate="2015-10-09 19:36:49" fixdate="2015-10-09 21:54:50" resolution="Complete">
		<buginformation>
			<summary>RabbitListenerAnnotationBeanPostProcessor cannot find Class-Level @RabbitListener annotations on beans with @Transactional annotations</summary>
			<description>RabbitListenerAnnotationBeanPostProcessor .postProcessAfterInitialization:






Class&amp;lt;?&amp;gt; targetClass = AopUtils.getTargetClass(bean);




final RabbitListener classLevelListener = AnnotationUtils.findAnnotation(bean.getClass(), RabbitListener.class);






bean.getClass() in this case refers to proxy. Why not use AnnotationUtils.findAnnotation(targetClass) ? It&amp;amp;apos;s interesting because 2 lines below targetClass is used to find annotations on methods:
ReflectionUtils.doWithMethods(targetClass, ...)</description>
			<version>1.5.1</version>
			<fixedVersion>1.5.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.annotation.RabbitListenerAnnotationBeanPostProcessor.java</file>
			<file type="M">org.springframework.amqp.rabbit.annotation.EnableRabbitIntegrationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">541</link>
			<link type="Relate" description="is related to">444</link>
		</links>
	</bug>
	<bug id="542" opendate="2015-10-16 02:03:50" fixdate="2015-10-19 17:25:23" resolution="Complete">
		<buginformation>
			<summary>Class-level @RabbitListener causes INFO log message about NullPointerException</summary>
			<description>If you have a class-level @RabbitListener annotation and some @RabbitHandler methods, when you start your application you&amp;amp;apos;ll get a log message like:
2015-10-15 18:50:15.430  INFO o.s.core.annotation.AnnotationUtils: Failed to introspect annotations on [null]: java.lang.NullPointerException
This appears to be completely harmless and the handler methods are all correctly called for incoming messages, but it makes my team nervous to have NullPointerException messages in our logs that we&amp;amp;apos;re supposed to just ignore.
The current version of Spring Boot&amp;amp;apos;s AMQP sample app (spring-boot-sample-amqp) demonstrates the problem with no changes needed; fire up the example and look for the error just after the "Registering beans for JMX exposure on startup" message.</description>
			<version>1.5.1</version>
			<fixedVersion>1.5.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.MultiMethodRabbitListenerEndpoint.java</file>
			<file type="M">org.springframework.amqp.rabbit.annotation.RabbitListener.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MethodRabbitListenerEndpoint.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.adapter.DelegatingInvocableHandler.java</file>
			<file type="M">org.springframework.amqp.rabbit.annotation.RabbitListenerAnnotationBeanPostProcessor.java</file>
			<file type="M">org.springframework.amqp.rabbit.annotation.EnableRabbitIntegrationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">13578</link>
		</links>
	</bug>
	<bug id="541" opendate="2015-10-09 21:33:11" fixdate="2015-11-10 01:21:54" resolution="Complete">
		<buginformation>
			<summary>@Header and @Payload Annotations Not Recognized on Proxy</summary>
			<description>See AMQP-540.
The PR fixes the reported problem but it is incomplete because annotated handler methods are not matched.</description>
			<version>1.5.1</version>
			<fixedVersion>1.5.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.annotation.RabbitListenerAnnotationBeanPostProcessor.java</file>
			<file type="M">org.springframework.amqp.rabbit.annotation.EnableRabbitIntegrationTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">13576</link>
			<link type="Relate" description="relates to">545</link>
			<link type="Relate" description="is related to">540</link>
		</links>
	</bug>
	<bug id="479" opendate="2015-02-19 00:51:04" fixdate="2015-11-13 20:12:33" resolution="Complete">
		<buginformation>
			<summary>Send of message via tx-channel is commited early when external (JTA) transaction is present</summary>
			<description>When an external JTA/EJB transaction calls a transactional spring bean (using JtaTransactionManager), which in turn sends a RabbitMQ-message (using RabbitTemplate), then the message is committed on the channel when the spring transaction bracket ends (not as expected when the outer JTA transaction is committed).
This StackOverflow question describes the same problem:
http://stackoverflow.com/questions/25773000/spring-amqp-rabbitmq-transaction-rollback-in-ejb3-cmt
The reason seems to be, that AbstractPlatformTransactionManager.processCommit() executes onCommit() callbacks immediately (whereas afterCompletion-Callbacks are passed on to a surrounding transaction). As the RabbitTemplate uses onCommit() callbacks (see RabbitResourceSynchronization) this causes the described behavior.
Moving the channel commit to afterCompletion in RabbitResourceSynchronization should fix this problem.</description>
			<version>1.3.8</version>
			<fixedVersion>1.5.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplateIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="546" opendate="2015-11-14 00:54:00" fixdate="2015-11-18 15:57:24" resolution="Complete">
		<buginformation>
			<summary>Closing the CachingConnectionFactory at application context close is too abrupt</summary>
			<description>From version 1.5 and onwards the CachingConnectionFactory will not allow any connections to be created once the application context has been closed. This is implemented by closing the connection factory as soon as closing of the application context is initiated (when the ContextClosedEvent is fired).
This is quite abrupt and causes problems for code that may want to process requests and publish messages while the application context is still in it&amp;amp;apos;s closing stage.
As an example we use spring-integration AMQP components (AmqpInboundChannelAdapter) for consuming inbound messages and these components implement the Spring SmartLifeCycle. This means that message consumers are not stopped until you reach the life-cycle processing stage in the application context closing (which happens after the ContextClosedEvent is fired). This causes problems as you cannot easily prevent incoming messages from arriving but you cannot send any outbound messages (since the connection factory is already closed). 
For us this is major issue since it now limits our possibility to perform a graceful shutdown of our application, which worked well with prior versions.
If closing is really required then I think it could make sense to defer it to a later stage by e.g. implementing Spring SmartLifeCycle and use the stop() method. Combined with a configurable phase that would give us the possibility to co-ordinate the closing with other components that should be stopped before we let the application context start destroying beans.</description>
			<version>1.5 GA</version>
			<fixedVersion>1.5.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactory.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">496</link>
		</links>
	</bug>
	<bug id="551" opendate="2015-11-30 11:21:31" fixdate="2015-12-03 21:55:01" resolution="Complete">
		<buginformation>
			<summary>Intermittent build failure caused by non-thread-safe use of Mockito</summary>
			<description>LocalizedQueueConnectionFactoryTests.testFailOver uses a Mockito mock on multiple threads (it changes the mock&amp;amp;apos;s behaviour while the listener container is running and calling the mock to cause the container to fail over). This leads to intermittent test failures as Mockito does not support such multi-threaded usage. The failure is:






org.mockito.exceptions.misusing.WrongTypeOfReturnValue: org.mockito.exceptions.misusing.WrongTypeOfReturnValue: 




Boolean cannot be returned by toString()




toString() should return String




***




If you&amp;amp;apos;re unsure why you&amp;amp;apos;re getting above error read on.




Due to the nature of the syntax above problem might occur because:




1. This exception *might* occur in wrongly written multi-threaded tests.




   Please refer to Mockito FAQ on limitations of concurrency testing.




2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - 




   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.









org.mockito.exceptions.misusing.WrongTypeOfReturnValue: 




Boolean cannot be returned by toString()




toString() should return String




***




If you&amp;amp;apos;re unsure why you&amp;amp;apos;re getting above error read on.




Due to the nature of the syntax above problem might occur because:




1. This exception *might* occur in wrongly written multi-threaded tests.




   Please refer to Mockito FAQ on limitations of concurrency testing.




2. A spy is stubbed using when(spy.foo()).then() syntax. It is safer to stub spies - 




   - with doReturn|Throw() family of methods. More in javadocs for Mockito.spy() method.









	at org.springframework.amqp.rabbit.connection.LocalizedQueueConnectionFactoryTests.testFailOver(LocalizedQueueConnectionFactoryTests.java:133)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:606)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)




	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)




	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:86)




	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:49)




	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:64)




	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:50)




	at sun.reflect.GeneratedMethodAccessor37.invoke(Unknown Source)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:606)




	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)




	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)




	at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)




	at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)




	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)




	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:106)




	at sun.reflect.GeneratedMethodAccessor36.invoke(Unknown Source)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:606)




	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)




	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)




	at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:360)




	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)




	at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)




	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)




	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)




	at java.lang.Thread.run(Thread.java:745)





</description>
			<version>1.5.2</version>
			<fixedVersion>1.5.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdminTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.AbstractConnectionFactoryTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplateIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerIntegration2Tests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.BatchingRabbitTemplateTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerErrorHandlerIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.LocalizedQueueConnectionFactoryTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="556" opendate="2015-12-18 16:03:10" fixdate="2015-12-18 23:52:17" resolution="Complete">
		<buginformation>
			<summary>NPE in SMLC (Recoverable)</summary>
			<description>consumerActive = this.consumers != null &amp;amp;&amp;amp; this.consumers.get(consumer);
If the container is stopped and times out waiting for the consumers, the consumer is no longer in the map when he next calls isActive().</description>
			<version>1.5.2</version>
			<fixedVersion>1.5.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerIntegration2Tests.java</file>
		</fixedFiles>
	</bug>
	<bug id="561" opendate="2016-01-13 17:23:50" fixdate="2016-01-15 17:34:03" resolution="Complete">
		<buginformation>
			<summary>AmqpAppender causes application error when declareExchange=true and no RabbitMQ connection available</summary>
			<description>When the declareExchange property is set for the AmqpAppender in log4j.properties, a call to org.apache.log4j.Logger.getLogger(..) will cause an application exception if the connection to RabbitMQ is not available. Stack trace below:






	org.springframework.amqp.AmqpConnectException: java.net.ConnectException: Connection timed out: connect




	org.springframework.amqp.rabbit.support.RabbitExceptionTranslator.convertRabbitAccessException(RabbitExceptionTranslator.java:58)




	org.springframework.amqp.rabbit.connection.AbstractConnectionFactory.createBareConnection(AbstractConnectionFactory.java:273)




	org.springframework.amqp.rabbit.connection.CachingConnectionFactory.createConnection(CachingConnectionFactory.java:500)




	org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils$1.createConnection(ConnectionFactoryUtils.java:85)




	org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.doGetTransactionalResourceHolder(ConnectionFactoryUtils.java:135)




	org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.getTransactionalResourceHolder(ConnectionFactoryUtils.java:71)




	org.springframework.amqp.rabbit.core.RabbitTemplate.doExecute(RabbitTemplate.java:1278)




	org.springframework.amqp.rabbit.core.RabbitTemplate.execute(RabbitTemplate.java:1271)




	org.springframework.amqp.rabbit.core.RabbitTemplate.execute(RabbitTemplate.java:1247)




	org.springframework.amqp.rabbit.core.RabbitAdmin.declareExchange(RabbitAdmin.java:126)




	org.springframework.amqp.rabbit.log4j.AmqpAppender.maybeDeclareExchange(AmqpAppender.java:434)




	org.springframework.amqp.rabbit.log4j.AmqpAppender.activateOptions(AmqpAppender.java:407)




	org.apache.log4j.config.PropertySetter.activate(PropertySetter.java:307)




	org.apache.log4j.config.PropertySetter.setProperties(PropertySetter.java:172)




	org.apache.log4j.config.PropertySetter.setProperties(PropertySetter.java:104)




	org.apache.log4j.PropertyConfigurator.parseAppender(PropertyConfigurator.java:842)




	org.apache.log4j.PropertyConfigurator.parseCategory(PropertyConfigurator.java:768)




	org.apache.log4j.PropertyConfigurator.configureRootCategory(PropertyConfigurator.java:648)




	org.apache.log4j.PropertyConfigurator.doConfigure(PropertyConfigurator.java:514)




	org.apache.log4j.PropertyConfigurator.doConfigure(PropertyConfigurator.java:580)




	org.apache.log4j.helpers.OptionConverter.selectAndConfigure(OptionConverter.java:526)




	org.apache.log4j.LogManager.&amp;amp;lt;clinit&amp;amp;gt;(LogManager.java:127)




	org.apache.log4j.Logger.getLogger(Logger.java:117)






A workaround is to set the declareExchange property to false, however a better solution would be to wrap the declareExchange(..) method in a try/catch and follow the log4j error handler pattern when the connection is not available.</description>
			<version>1.5.2</version>
			<fixedVersion>1.5.4, 1.6 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppender.java</file>
			<file type="M">org.springframework.amqp.rabbit.log4j.AmqpAppenderIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.logback.AmqpAppender.java</file>
		</fixedFiles>
	</bug>
	<bug id="562" opendate="2016-01-19 23:29:19" fixdate="2016-01-21 01:49:41" resolution="Complete">
		<buginformation>
			<summary>Add mismatchedQueuesFatal to SimpleMessageLIstenerContainer to Detect Mismatched Queue Arguments</summary>
			<description>If queue declarations fail due to mis-matched arguments, the missingQueuesFatal property should control whether the container starts or not.
Or add mismatchedQueuesFatal - perhaps with false by default.</description>
			<version>1.5.3</version>
			<fixedVersion>1.6 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.connection.RabbitUtils.java</file>
			<file type="M">org.springframework.amqp.rabbit.annotation.EnableRabbitIdleContainerTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerIntegration2Tests.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.RabbitNamespaceUtils.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.config.ListenerContainerParserTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="565" opendate="2016-01-26 21:21:37" fixdate="2016-01-26 22:20:38" resolution="Complete">
		<buginformation>
			<summary>NPE in RabbitAdmin</summary>
			<description>





org.springframework.amqp.UncategorizedAmqpException: java.lang.NullPointerException









	at org.springframework.amqp.rabbit.support.RabbitExceptionTranslator.convertRabbitAccessException(RabbitExceptionTranslator.java:76)




	at org.springframework.amqp.rabbit.connection.RabbitAccessor.convertRabbitAccessException(RabbitAccessor.java:110)




	at org.springframework.amqp.rabbit.core.RabbitTemplate.doExecute(RabbitTemplate.java:1304)




	at org.springframework.amqp.rabbit.core.RabbitTemplate.execute(RabbitTemplate.java:1271)




	at org.springframework.amqp.rabbit.core.RabbitTemplate.execute(RabbitTemplate.java:1247)




	at org.springframework.amqp.rabbit.core.RabbitAdmin.declareQueue(RabbitAdmin.java:166)




	at org.springframework.cloud.stream.binder.rabbit.RabbitMessageChannelBinder.declareQueue(RabbitMessageChannelBinder.java:654)




	at org.springframework.cloud.stream.binder.rabbit.RabbitMessageChannelBinder.buildOutboundEndpoint(RabbitMessageChannelBinder.java:554)




	at org.springframework.cloud.stream.binder.rabbit.RabbitMessageChannelBinder.bindProducer(RabbitMessageChannelBinder.java:580)




	at org.springframework.cloud.stream.binder.rabbit.RabbitMessageChannelBinder.bindProducer(RabbitMessageChannelBinder.java:108)




	at org.springframework.cloud.stream.binder.AbstractTestBinder.bindProducer(AbstractTestBinder.java:57)




	at org.springframework.cloud.stream.binder.rabbit.RabbitTestBinder.bindProducer(RabbitTestBinder.java:82)




	at org.springframework.cloud.stream.binder.rabbit.RabbitTestBinder.bindProducer(RabbitTestBinder.java:41)




	at org.springframework.cloud.stream.binder.rabbit.RabbitBinderTests.testAutoBindDLQPartionedConsumerFirst(RabbitBinderTests.java:362)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:497)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)




	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)




	at org.springframework.cloud.stream.test.junit.AbstractExternalResourceTestSupport$1.evaluate(AbstractExternalResourceTestSupport.java:70)




	at org.junit.rules.RunRules.evaluate(RunRules.java:20)




	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)




	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)




	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)




	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234)




	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:497)




	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)




Caused by: java.lang.NullPointerException




	at org.springframework.amqp.rabbit.core.RabbitAdmin$3.doInRabbit(RabbitAdmin.java:169)




	at org.springframework.amqp.rabbit.core.RabbitAdmin$3.doInRabbit(RabbitAdmin.java:166)




	at org.springframework.amqp.rabbit.core.RabbitTemplate.doExecute(RabbitTemplate.java:1298)




	... 40 more





</description>
			<version>1.5.3</version>
			<fixedVersion>1.5.4, 1.6 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdmin.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdminIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="570" opendate="2016-02-09 01:18:43" fixdate="2016-02-12 15:55:57" resolution="Complete">
		<buginformation>
			<summary>SimpleAmqpHeaderMapper does not handle org.springframework.util.MimeType</summary>
			<description>In my case I&amp;amp;apos;m sending messages using Spring messaging, with a custom converter based on org.springframework.messaging.converter.AbstractMessageConverter. This class (and the other converters I&amp;amp;apos;ve looked at in Spring messaging) seem to all use org.springframework.util.MimeType for encoding the content type, so it seems spring-amqp should handle that case in SimpleAmqpHeaderMapper.extractContentTypeAsString.
Currently it logs a warning and ignores the content type header. However due to a related bug it does pick up the contentType header further down in fromHeaders and treats it as a custom header (as for some reason org.springframework.amqp.support.AmqpHeaders.CONTENT_TYPE doesn&amp;amp;apos;t use the "amqp_" prefix).
It seems to me the correct behaviour would be to

handle in org.springframework.util.MimeType extractContentTypeAsString
exclude contentType from custom header processing

Links: https://jira.spring.io/browse/INT-2713</description>
			<version>1.5.3</version>
			<fixedVersion>1.5.4, 1.6 M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.support.SimpleAmqpHeaderMapper.java</file>
			<file type="M">org.springframework.amqp.support.SimpleAmqpHeaderMapperTests.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">3951</link>
			<link type="Relate" description="relates to">3690</link>
		</links>
	</bug>
	<bug id="594" opendate="2016-03-24 08:32:14" fixdate="2016-03-24 19:17:27" resolution="Complete">
		<buginformation>
			<summary>@RabbitListener creates two listener instances if annotated method is implementing interface method</summary>
			<description>If we have following situation: 
interface:






ConsumerService.java






public interface  ConsumerService&amp;lt;TPayLoad&amp;gt; {




  void consume(TPayLoad message);




}






and also following interface implementation:






TestingQueueConsumerServiceImpl.java






@Component




public class TestingQueueConsumerServiceImpl implements ConsumerService&amp;lt;DemoMessage&amp;gt; {




  private Log log = LogFactory.getLog(getClass());









  @Transactional




  @RabbitListener(queues = "${rabbitmq.queue.demo}", id = "myuniquecustomid")




  public void consume(@Payload TestMessage message) {




    Assert.notNull(message);




    log.info(message.toString());




  }




}






on application start we gets following exception






2016-03-24 09:26:48.971  INFO 58632 --- [           main] o.apache.catalina.core.StandardService   : Stopping service Tomcat




2016-03-24 09:26:48.982 ERROR 58632 --- [           main] o.s.boot.SpringApplication               : Application startup failed









java.lang.IllegalStateException: Another endpoint is already registered with id &amp;amp;apos;myuniquecustomid&amp;amp;apos;




	at org.springframework.util.Assert.state(Assert.java:392) ~[spring-core-4.2.5.RELEASE.jar:4.2.5.RELEASE]




	at org.springframework.amqp.rabbit.listener.RabbitListenerEndpointRegistry.registerListenerContainer(RabbitListenerEndpointRegistry.java:146) ~[spring-rabbit-1.5.4.RELEASE.jar:na]




	at org.springframework.amqp.rabbit.listener.RabbitListenerEndpointRegistry.registerListenerContainer(RabbitListenerEndpointRegistry.java:122) ~[spring-rabbit-1.5.4.RELEASE.jar:na]




	at org.springframework.amqp.rabbit.listener.RabbitListenerEndpointRegistrar.registerAllEndpoints(RabbitListenerEndpointRegistrar.java:134) ~[spring-rabbit-1.5.4.RELEASE.jar:na]




	at org.springframework.amqp.rabbit.listener.RabbitListenerEndpointRegistrar.afterPropertiesSet(RabbitListenerEndpointRegistrar.java:128) ~[spring-rabbit-1.5.4.RELEASE.jar:na]




	at org.springframework.amqp.rabbit.annotation.RabbitListenerAnnotationBeanPostProcessor.afterSingletonsInstantiated(RabbitListenerAnnotationBeanPostProcessor.java:209) ~[spring-rabbit-1.5.4.RELEASE.jar:na]




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:792) ~[spring-beans-4.2.5.RELEASE.jar:4.2.5.RELEASE]




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:839) ~[spring-context-4.2.5.RELEASE.jar:4.2.5.RELEASE]




	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:538) ~[spring-context-4.2.5.RELEASE.jar:4.2.5.RELEASE]




	at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:118) ~[spring-boot-1.3.3.RELEASE.jar:1.3.3.RELEASE]




	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:766) [spring-boot-1.3.3.RELEASE.jar:1.3.3.RELEASE]




	at org.springframework.boot.SpringApplication.createAndRefreshContext(SpringApplication.java:361) [spring-boot-1.3.3.RELEASE.jar:1.3.3.RELEASE]




	at org.springframework.boot.SpringApplication.run(SpringApplication.java:307) [spring-boot-1.3.3.RELEASE.jar:1.3.3.RELEASE]




	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1191) [spring-boot-1.3.3.RELEASE.jar:1.3.3.RELEASE]




	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1180) [spring-boot-1.3.3.RELEASE.jar:1.3.3.RELEASE]






This is happening as @RabbitListener annotation creates two listener instances, one for interface method and one for implementing method.
After  implementation of `ConsumerService&amp;lt;DemoMessage&amp;gt;` is removed then  everything is working as expected.</description>
			<version>1.5.4</version>
			<fixedVersion>1.6 M2, 1.5.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.annotation.RabbitListenerAnnotationBeanPostProcessor.java</file>
		</fixedFiles>
	</bug>
	<bug id="591" opendate="2016-03-18 10:03:37" fixdate="2016-03-29 17:03:25" resolution="Complete">
		<buginformation>
			<summary>CachingConnectionFactory leaks channels when using channelCacheSize &amp; channelCheckoutTimeout settings</summary>
			<description>The channelCacheSize &amp;amp; channelCheckoutTimeout settings can be used to constrain the number of available RabbitMQ channels per connection. If a connection is lost for some reason (network glitch, rabbit restarted etc), the CachingConnectionFactory starts leaking channels, and eventually fails with "no available channels".</description>
			<version>1.5.3</version>
			<fixedVersion>1.6 RC1, 1.5.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactoryTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactory.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactoryIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.CachePropertiesTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.BatchingRabbitTemplateTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="598" opendate="2016-04-15 17:59:37" fixdate="2016-04-15 20:34:30" resolution="Complete">
		<buginformation>
			<summary>RabbitAdmin Exception when there are beans of type Collection declared with @JobScope </summary>
			<description>Configure a bean of type Collection with @JobScope for Spring Batch.






@Bean




@JobScope




public ConcurrentLinkedDeque&amp;lt;SyncMessage&amp;gt; syncDeque() {




  return new ConcurrentLinkedDeque&amp;lt;SyncMessage&amp;gt;();




}






This is where the exception is thrown in RabbitAdmin.java during RabbitMQ initialization.






initialize() {




...




Collection&amp;lt;Collection&amp;gt; collections = 




    this.applicationContext.getBeansOfType(Collection.class).values();




...




}






Stack Trace
org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;scopedTarget.syncDeque&amp;amp;apos;: Scope &amp;amp;apos;job&amp;amp;apos; is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; nested exception is java.lang.IllegalStateException: No context holder available for job scope
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:355)
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)
at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:534)
at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:523)
at org.springframework.context.support.AbstractApplicationContext.getBeansOfType(AbstractApplicationContext.java:1162)
at org.springframework.amqp.rabbit.core.RabbitAdmin.initialize(RabbitAdmin.java:395)
at org.springframework.amqp.rabbit.core.RabbitAdmin$11.onCreate(RabbitAdmin.java:357)
at org.springframework.amqp.rabbit.connection.CompositeConnectionListener.onCreate(CompositeConnectionListener.java:32)
at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.createConnection(CachingConnectionFactory.java:512)
at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils$1.createConnection(ConnectionFactoryUtils.java:85)
at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.doGetTransactionalResourceHolder(ConnectionFactoryUtils.java:135)
at org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.getTransactionalResourceHolder(ConnectionFactoryUtils.java:71)
at org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.start(BlockingQueueConsumer.java:456)
at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$AsyncMessageProcessingConsumer.run(SimpleMessageListenerContainer.java:1171)
at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.IllegalStateException: No context holder available for job scope
at org.springframework.batch.core.scope.JobScope.getContext(JobScope.java:159)
at org.springframework.batch.core.scope.JobScope.get(JobScope.java:92)
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:340)
... 14 more</description>
			<version>1.5.5</version>
			<fixedVersion>1.6 RC1, 1.5.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdminTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitAdmin.java</file>
		</fixedFiles>
	</bug>
	<bug id="572" opendate="2016-02-09 16:04:43" fixdate="2016-05-05 17:29:28" resolution="Complete">
		<buginformation>
			<summary>Send of message via tx-channel is commited early with (JTA) transaction and TransactionTemplate</summary>
			<description>When an external JTA/EJB transaction calls a spring bean using TransactionTemplate with JtaTransactionManager, which in turn sends a RabbitMQ-message (using a transacted RabbitTemplate), then the message is committed on the channel when the spring transaction bracket ends (not as expected when the outer JTA transaction is committed).
This only occurs when TransactionTemplate  is used, but not with AOP transaction proxies (@Transactional). Everything works as expected with AOP proxies.
The reason seems to be, that the ConnectionFactoryUtils use TransactionAspectSupport.currentTransactionStatus().isNewTransaction() (line 177) to check for the presence of a new/nested transaction - unfortunately it seems TransactionAspectSupport can only be used with AOP based transaction handling. When used with TransactionTemplate, TransactionAspectSupport.currentTransactionStatus() throws a NoTransactionException causing the Utils to assume a local transaction.
Workaround for users: Use AOP based transaction handling.
See AMQP-479 for the history (solved the main issue, but left the problem in the special case of TransactionTemplate s being used)</description>
			<version>1.5.3</version>
			<fixedVersion>1.6 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplateIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.ConnectionFactoryUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="621" opendate="2016-07-05 23:05:47" fixdate="2016-07-15 16:31:24" resolution="Complete">
		<buginformation>
			<summary>Spring AMQP Consumer pauses after running for sometime</summary>
			<description>We have a 2 node RabbitMQ cluster with Ha-all policy. We use Spring AMQP in our application to talk to RabbitMQ. Producer part is working fine, but consumer works for some time and pauses. Producer and consumer are running as different applications. More information on Consumer part.

we use SimpleMessageListenerContainer with ChannelAwareMessageListener, use Manual ack mode and default prefetch(1)
In our application we create queue (on-demand) and add it to the listener
When we started with 10 ConcurrentConsumers and 20 MaxConcurrentConsumers, consumption happens for around 15 hours and pauses. This situation happens within 1 hour when we increase the MaxConcurrentConsumers to 75.

On RabbitMQ UI, we see channels with 3/4 unacked messages on the channel tab when this situation occurs, until then it just have 1 unacked message.
Having heartbeat set to 60 did not help improve this situation.
We dynamically add and remove queues to SimpleMessageListenerContainer and we suspect this is causing some problem, because every time we add or remove a queue from the listener, all the BlockingQueueConsumer are removed and created again. 
@GaryRussell, suggested to create Jira ticket. Please let me know if you need more information.
Spring AMQP version: 1.6.0.RELEASE
Thread Dump: pastebin.com/UrBLfn2C 
Stackoverflow  Link: http://stackoverflow.com/questions/38134687/spring-amqp-consumer-pauses-after-running-for-sometime?noredirect=1#comment63848781_38134687</description>
			<version>1.6 GA</version>
			<fixedVersion>1.6.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerIntegration2Tests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.ContainerInitializationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="625" opendate="2016-07-22 13:35:26" fixdate="2016-07-26 13:28:42" resolution="Complete">
		<buginformation>
			<summary>CachingConnectionFactory onClose notification</summary>
			<description>The problem is happening when using CachingConnectionFactory with cache mode CacheMode.CHANNEL. When connection is closed for the first time the connection listener is notified normally, but if the connection is recreated and closed again the listener is not notified.
I created a sample project on Github to show this problem: https://github.com/marcospy/spring-amqp-listener-issue.</description>
			<version>1.5.6</version>
			<fixedVersion>1.5.7, 1.6.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactoryTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="633" opendate="2016-08-18 15:48:45" fixdate="2016-08-23 16:13:16" resolution="Complete">
		<buginformation>
			<summary>Non Transactional RabbitTemplate Uses Container Transactional Channel</summary>
			<description>When running a RabbitTemplate on a transactional container thread, the container channel is used, even if the RabbitTemplate is not marked transactional.
Consider the case where you wish to publish a message when there&amp;amp;apos;s an error, while rejecting the inbound message. If the container is transactional, the published message is rolled back.
If you publish with a template that is not transactional, the publish should occur on a new channel.






RabbitResourceHolder resourceHolder = (RabbitResourceHolder) TransactionSynchronizationManager




		.getResource(connectionFactory);




if (resourceHolder != null) {




	Channel channel = resourceFactory.getChannel(resourceHolder);




	if (channel != null) {




		return resourceHolder;




	}




}






We should never return the resourceHolder if the resourceFactory.isSynchedLocalTransactionAllowed() is false.</description>
			<version>1.6.1</version>
			<fixedVersion>1.6.2, 2.0.M1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitTemplate.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.LocallyTransactedTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="648" opendate="2016-09-28 12:43:57" fixdate="2016-09-28 16:05:29" resolution="Complete">
		<buginformation>
			<summary>Container Fails to Recover</summary>
			<description>Container configured to listen on multiple queues.
Delete a queue, suspend the consumer thread in handleCancel.
Stop/start the broker.
The issue is that we detect there are other queues so we attempt to cancel those consumers (basicCacncel) but we&amp;amp;apos;ll never get a handleCancelOk call because the broker had been restarted.
When we cancel the other consumers, we need to properly deal with failure to cancel.
VESC-715</description>
			<version>1.6.2</version>
			<fixedVersion>2.0.M1, 1.6.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumerTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.BlockingQueueConsumer.java</file>
		</fixedFiles>
	</bug>
	<bug id="653" opendate="2016-10-08 02:53:08" fixdate="2016-10-10 20:58:31" resolution="Complete">
		<buginformation>
			<summary>RabbitMessagingTemplate doesn&amp;apos;t take advantage of RabbitTemplate&amp;apos;s registered converters</summary>
			<description>When using RabbitTemplate in a Spring Boot application, it&amp;amp;apos;s very easy to register a Spring AMQP Message Converter. Just add this to your code:






@Bean




Jackson2JsonMessageConverter jackson2JsonMessageConverter() {




	return new Jackson2JsonMessageConverter();




}






However, if you switch to RabbitMessagingTemplate, that bean no longer works, because RabbitMessagingTemplate doesn&amp;amp;apos;t offer to look up RabbitTemplate&amp;amp;apos;s converters, and instead relies on its own. Looking inside Spring Boot, there doesn&amp;amp;apos;t appear to be any wiring that offers to hook up message converters either.</description>
			<version>1.6.3</version>
			<fixedVersion>2.0.M1, 1.6.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitMessagingTemplateTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitMessagingTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="196" opendate="2011-09-23 11:23:51" fixdate="2016-10-12 20:20:20" resolution="Complete">
		<buginformation>
			<summary>RabbitTemplate/RabbitGatewaySupport incompatible with JDK proxy</summary>
			<description>RabbitGatewaySupport uses class RabbitTemplate rather than interface RabbitOperations for its rabbitTemplate property. If AOP advice creates a proxy for a RabbitTemplate a JDK proxy will be created since RabbitTemplate implements the RabbitOperations interface. If the advised bean is injected into RabbitGatewaySupport, an error will occur because the bean is not an instance of RabbitTemplate. While a CGLIB proxy could be used, this would require making all proxies in the application CGLIB proxies which could have negative consequences.
Suggestion is to change RabbitGatewaySupport to make the type of rabbitTemplate RabbitOperations. Since RabbitGatewaySupport invokes the getConnection method on rabbitTemplate, there would probably be a need to add this method to the RabbitOperations interface as well. Also, there may be other places within Spring AMQP where RabbitTemplate could be injected; if so then these should be changed as well.
Workaround for this issue is to avoid use of RabbitGatewaySupport or create a local copy and modify it accordingly.</description>
			<version>1.0.0 GA</version>
			<fixedVersion>2.0.M1, 1.6.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitGatewaySupport.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitGatewaySupportTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.core.RabbitOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="656" opendate="2016-10-15 00:25:46" fixdate="2016-10-17 16:44:07" resolution="Complete">
		<buginformation>
			<summary>Unable to refer to the default exchange using @Argument within a @RabbitListener</summary>
			<description>It seems you are unable to use @Argument annotations that use empty strings to refer to the default exchange.  For example, you should be able to configure a queue to use the default exchange as part of the dead letter config similar to the following:






@RabbitListener(bindings =




        @QueueBinding(




            value = @Queue(




                value = "app.events.myEvent",




                durable = "true",




                exclusive = "false",




                autoDelete = "false",




                arguments = {




                        @Argument(name="x-dead-letter-exchange", value = ""),




                        @Argument(name="x-dead-letter-routing-key", value="app.dlq")




                }),




            exchange = @Exchange(value="amq.topic", durable = "true", type = "topic"),




            key="event.app.myEvent.v1"




        ))






This fails though as spring seems to not send the empty string.  I tried being creative with using things like SPEL that would evaluate to an empty string, but same result.
If I use bean configs I am able to get the configuration I want using something like the following, the issue is just with the annotation based config.






    @Bean




    public Queue appMyEventQueue() {




        return QueueBuilder.durable("app.events.myEvent")




            .withArgument("x-dead-letter-exchange", "")




            .withArgument("x-dead-letter-routing-key", deadLetterQueue().getName())




            .build();




    }





</description>
			<version>1.6.2</version>
			<fixedVersion>2.0.M1, 1.6.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.annotation.RabbitListenerAnnotationBeanPostProcessor.java</file>
			<file type="M">org.springframework.amqp.rabbit.annotation.EnableRabbitIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="657" opendate="2016-10-17 14:51:53" fixdate="2016-10-17 17:17:36" resolution="Complete">
		<buginformation>
			<summary>SimpleAmqpHeaderMapper doesn&amp;apos;t map properly receivedUserId header</summary>
			<description></description>
			<version>1.6.3</version>
			<fixedVersion>2.0.M1, 1.6.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.support.SimpleAmqpHeaderMapper.java</file>
			<file type="M">org.springframework.amqp.support.SimpleAmqpHeaderMapperTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.annotation.EnableRabbitIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.support.AmqpMessageHeaderAccessorTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="661" opendate="2016-10-19 13:13:25" fixdate="2016-10-19 16:20:59" resolution="Complete">
		<buginformation>
			<summary>NPE with null QueueName in SMLC</summary>
			<description></description>
			<version>1.6.3</version>
			<fixedVersion>2.0.M1, 1.6.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerIntegrationTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.java</file>
		</fixedFiles>
	</bug>
	<bug id="663" opendate="2016-10-20 09:22:20" fixdate="2016-10-20 14:25:01" resolution="Complete">
		<buginformation>
			<summary>SimpleMessageListenerContainerIntegration2Tests testDeleteOneQueue fails intermittently</summary>
			<description>I think I&amp;amp;apos;ve only seen this with 1.5.6. The failure is:






java.util.NoSuchElementException




	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1439)




	at java.util.HashMap$KeyIterator.next(HashMap.java:1461)




	at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerIntegration2Tests.testDeleteOneQueue(SimpleMessageListenerContainerIntegration2Tests.java:176)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:498)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)




	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)




	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)




	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)




	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)




	at org.junit.rules.RunRules.evaluate(RunRules.java:20)




	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)




	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:86)




	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:49)




	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:64)




	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:50)




	at sun.reflect.GeneratedMethodAccessor25.invoke(Unknown Source)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:498)




	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)




	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)




	at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)




	at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)




	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)




	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:106)




	at sun.reflect.GeneratedMethodAccessor24.invoke(Unknown Source)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:498)




	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)




	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)




	at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:360)




	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)




	at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)




	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)




	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)




	at java.lang.Thread.run(Thread.java:745)





</description>
			<version>1.5.6</version>
			<fixedVersion>1.5.7, 2.0.M1, 1.6.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainerIntegration2Tests.java</file>
		</fixedFiles>
	</bug>
	<bug id="660" opendate="2016-10-18 16:54:13" fixdate="2016-10-28 15:27:39" resolution="Complete">
		<buginformation>
			<summary>Invalid GenericMessage requeued indefinitely</summary>
			<description>Spring Integration 4.x moved GenericMessage from org.springframework.integration.message to org.springframework.messaging.support. After we upgraded our version from 3.x to 4.x, we still had a lot of persistent messages in RabbitMQ in the old GenericMessage Java Serialization format. Obviously, these messages are unable to be deserialized but instead of marking these conversion failures as fatal the ConditionalRejectingErrorHandler would repeatedly requeue them to be tried again.






WARN  2016-10-06 19:26:09,477 [SimpleAsyncTaskExecutor-2] ConditionalRejectingErrorHandler: Execution of Rabbit message listener failed.




org.springframework.amqp.rabbit.listener.exception.ListenerExecutionFailedException: Listener threw exception




        at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.wrapToListenerExecutionFailedExceptionIfNeeded(AbstractMessageListenerContainer.java:865)




        at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:803)




        at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.invokeListener(AbstractMessageListenerContainer.java:691)




        at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.access$001(SimpleMessageListenerContainer.java:93)




        at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$1.invokeListener(SimpleMessageListenerContainer.java:183)




        at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.invokeListener(SimpleMessageListenerContainer.java:1358)




        at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.executeListener(AbstractMessageListenerContainer.java:661)




        at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.doReceiveAndExecute(SimpleMessageListenerContainer.java:1102)




        at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.receiveAndExecute(SimpleMessageListenerContainer.java:1086)




        at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer.access$1100(SimpleMessageListenerContainer.java:93)




        at org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer$AsyncMessageProcessingConsumer.run(SimpleMessageListenerContainer.java:1203)




        at java.lang.Thread.run(Thread.java:745)




Caused by: org.springframework.messaging.MessagingException: Failure occured in AMQP listener while attempting to convert and dispatch Message.; nested exception is org.springframework.amqp.support.converter.MessageConversionException: Could not convert message body




        at org.springframework.integration.amqp.channel.AbstractSubscribableAmqpChannel$DispatchingMessageListener.onMessage(AbstractSubscribableAmqpChannel.java:202)




        at org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer.doInvokeListener(AbstractMessageListenerContainer.java:800)




        ... 10 more




Caused by: org.springframework.amqp.support.converter.MessageConversionException: Could not convert message body




        at org.springframework.amqp.support.converter.SerializerMessageConverter.fromMessage(SerializerMessageConverter.java:151)




        at org.springframework.integration.amqp.channel.AbstractSubscribableAmqpChannel$DispatchingMessageListener.onMessage(AbstractSubscribableAmqpChannel.java:177)




        ... 11 more




Caused by: org.springframework.core.NestedIOException: Failed to deserialize object type; nested exception is java.lang.ClassNotFoundException: org.springframework.integration.message.GenericMessage




        at org.springframework.amqp.support.converter.SerializerMessageConverter.deserialize(SerializerMessageConverter.java:178)




        at org.springframework.amqp.support.converter.SerializerMessageConverter.fromMessage(SerializerMessageConverter.java:144)




        ... 12 more




Caused by: java.lang.ClassNotFoundException: org.springframework.integration.message.GenericMessage




        at java.net.URLClassLoader.findClass(URLClassLoader.java:381)




        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)




        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)




        at org.eclipse.jetty.webapp.WebAppClassLoader.loadClass(WebAppClassLoader.java:429)




        at org.eclipse.jetty.webapp.WebAppClassLoader.loadClass(WebAppClassLoader.java:382)




        at java.lang.Class.forName0(Native Method)




        at java.lang.Class.forName(Class.java:348)




        at java.io.ObjectInputStream.resolveClass(ObjectInputStream.java:626)




        at org.springframework.core.ConfigurableObjectInputStream.resolveClass(ConfigurableObjectInputStream.java:78)




        at org.springframework.amqp.support.converter.SerializerMessageConverter$1.resolveClass(SerializerMessageConverter.java:169)




        at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1613)




        at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1518)




        at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1774)




        at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1351)




        at java.io.ObjectInputStream.readObject(ObjectInputStream.java:371)




        at org.springframework.amqp.support.converter.SerializerMessageConverter.deserialize(SerializerMessageConverter.java:175)




        ... 13 more






It looks like the existing DefaultExceptionStrategy is not checking the entire cause chain to determine if any are fatal like the check for causeChainContainsARADRE() does.</description>
			<version>1.6.2</version>
			<fixedVersion>2.0.M1, 1.6.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.support.converter.SimpleMessageConverter.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.DirectReplyToMessageListenerContainerTests.java</file>
			<file type="M">org.springframework.amqp.support.converter.SerializerMessageConverterTests.java</file>
			<file type="M">org.springframework.amqp.support.converter.SimpleMessageConverterTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.ConditionalRejectingErrorHandler.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">4148</link>
		</links>
	</bug>
	<bug id="668" opendate="2016-11-06 12:34:42" fixdate="2016-11-07 13:56:34" resolution="Complete">
		<buginformation>
			<summary>MessageListenerContainerLifecycleIntegrationTests  testNonTransactionalHighLevel fails intermittently</summary>
			<description>





java.lang.AssertionError: Expect to receive all messages after stop




	at org.junit.Assert.fail(Assert.java:88)




	at org.junit.Assert.assertTrue(Assert.java:41)




	at org.springframework.amqp.rabbit.listener.MessageListenerContainerLifecycleIntegrationTests.doTest(MessageListenerContainerLifecycleIntegrationTests.java:274)




	at org.springframework.amqp.rabbit.listener.MessageListenerContainerLifecycleIntegrationTests.doTest(MessageListenerContainerLifecycleIntegrationTests.java:213)




	at org.springframework.amqp.rabbit.listener.MessageListenerContainerLifecycleIntegrationTests.testNonTransactionalHighLevel(MessageListenerContainerLifecycleIntegrationTests.java:179)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:498)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)




	at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)




	at org.springframework.amqp.rabbit.test.Log4jLevelAdjuster$1.evaluate(Log4jLevelAdjuster.java:63)




	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)




	at org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)




	at org.junit.rules.RunRules.evaluate(RunRules.java:20)




	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)




	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:112)




	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:56)




	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:66)




	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)




	at sun.reflect.GeneratedMethodAccessor25.invoke(Unknown Source)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:498)




	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)




	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)




	at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)




	at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)




	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)




	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:109)




	at sun.reflect.GeneratedMethodAccessor24.invoke(Unknown Source)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)




	at java.lang.reflect.Method.invoke(Method.java:498)




	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)




	at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)




	at org.gradle.messaging.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:364)




	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)




	at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)




	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)




	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)




	at java.lang.Thread.run(Thread.java:745)





</description>
			<version>1.6.4</version>
			<fixedVersion>2.0.M1, 1.6.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.MessageListenerContainerLifecycleIntegrationTests.java</file>
		</fixedFiles>
	</bug>
	<bug id="682" opendate="2016-12-03 18:07:03" fixdate="2016-12-09 01:09:01" resolution="Complete">
		<buginformation>
			<summary>Fix Non-Managed DMLC with Spring-Managed Connection Factory</summary>
			<description>When a DirectMessageListenerContainer outside of an application context is using a CachingConnectionFactory from an application context, and the context is destroyed, the container continues to try to recover:






2016-12-03 16:21:45,404 ERROR org.springframework.scheduling.support.TaskUtils$LoggingErrorHandler [null-consumerMonitor-1] : Unexpected error occurred in scheduled task.




org.springframework.amqp.AmqpConnectException: java.lang.IllegalStateException: The ApplicationContext is closed and the ConnectionFactory can no longer create connections.




	at org.springframework.amqp.rabbit.listener.DirectMessageListenerContainer.doConsumeFromQueue(DirectMessageListenerContainer.java:487) ~[main/:?]




	at org.springframework.amqp.rabbit.listener.DirectMessageListenerContainer.lambda$actualStart$4(DirectMessageListenerContainer.java:371) ~[main/:?]




	at org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54) [spring-context-5.0.0.BUILD-SNAPSHOT.jar:5.0.0.BUILD-SNAPSHOT]




	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [?:1.8.0_101]




	at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308) [?:1.8.0_101]




	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180) [?:1.8.0_101]




	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294) [?:1.8.0_101]




	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [?:1.8.0_101]




	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [?:1.8.0_101]




	at java.lang.Thread.run(Thread.java:745) [?:1.8.0_101]




Caused by: java.lang.IllegalStateException: The ApplicationContext is closed and the ConnectionFactory can no longer create connections.




	at org.springframework.util.Assert.state(Assert.java:640) ~[spring-core-5.0.0.BUILD-SNAPSHOT.jar:5.0.0.BUILD-SNAPSHOT]




	at org.springframework.amqp.rabbit.connection.CachingConnectionFactory.createConnection(CachingConnectionFactory.java:546) ~[main/:?]




	at org.springframework.amqp.rabbit.listener.DirectMessageListenerContainer.doConsumeFromQueue(DirectMessageListenerContainer.java:483) ~[main/:?]




	... 9 more






If both are spring-managed, the container will also be stopped/destroyed.
Detect the exception and auto-stop the container when the condition is detected.
Different logic for start Vs. recovery.</description>
			<version>2.0.M1</version>
			<fixedVersion>2.0.M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.amqp.rabbit.listener.DirectMessageListenerContainerTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.ConnectionFactoryLifecycleTests.java</file>
			<file type="M">org.springframework.amqp.rabbit.listener.DirectMessageListenerContainer.java</file>
			<file type="M">org.springframework.amqp.rabbit.connection.CachingConnectionFactory.java</file>
		</fixedFiles>
	</bug>
</bugrepository>