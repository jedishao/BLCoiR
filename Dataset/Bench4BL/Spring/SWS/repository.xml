<?xml version = "1.0" encoding = "UTF-8" ?>
<bugrepository name="SWS">
	<bug id="56" opendate="2006-09-28 17:06:24" fixdate="2006-09-29 20:24:32" resolution="Fixed">
		<buginformation>
			<summary>Digest passwords are never accepted in the SimplePasswordValidationCallbackHandler</summary>
			<description>Digest passwords are never accepted by the SimplePasswordValidationCallbackHandler, because the setValidator is called twice.
protected void handleInternal(Callback callback) throws IOException, UnsupportedCallbackException {
        if (callback instanceof PasswordValidationCallback) {
            PasswordValidationCallback passwordCallback = (PasswordValidationCallback) callback;
            if (passwordCallback.getRequest() instanceof PasswordValidationCallback.PlainTextPasswordRequest) 
{
                passwordCallback.setValidator(new SimplePlainTextPasswordValidator());
            }
            else if (passwordCallback.getRequest() instanceof PasswordValidationCallback.DigestPasswordRequest) 
{
                PasswordValidationCallback.DigestPasswordRequest digestPasswordRequest =
                        (PasswordValidationCallback.DigestPasswordRequest) passwordCallback.getRequest();
                String password = users.getProperty(digestPasswordRequest.getUsername());
                digestPasswordRequest.setPassword(password);
                passwordCallback.setValidator(new PasswordValidationCallback.DigestPasswordValidator());
            }
            passwordCallback.setValidator(new SimplePlainTextPasswordValidator());</description>
			<version>1.0 M2</version>
			<fixedVersion>1.0 M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SimplePasswordValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SimplePasswordValidationCallbackHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="55" opendate="2006-09-25 21:42:29" fixdate="2006-10-01 07:17:18" resolution="Fixed">
		<buginformation>
			<summary>npe thrown when validating with nonce</summary>
			<description>I am having a problem getting an npe as referenced in another thread (which was getting really long).
it looks like it happens in DefaulttimestampValidator.java, at line 41
Date expired = parseDate(utcRequest.getExpired());
while trying to verifyInboundMessage.
This happens when my security policy inbound is:
&amp;lt;xwss:SecurityConfiguration dumpMessages="true" xmlns:xwss="http://java.sun.com/xml/ns/xwss/config"&amp;gt;
&amp;lt;xwss:Timestamp timeout="120"/&amp;gt;
&amp;lt;xwss:RequireUsernameToken passwordDigestRequired="false" nonceRequired="true"/&amp;gt;
&amp;lt;/xwss:SecurityConfiguration&amp;gt;
and outbound is 
&amp;lt;xwss:SecurityConfiguration dumpMessages="true" xmlns:xwss="http://java.sun.com/xml/ns/xwss/config"&amp;gt;
&amp;lt;xwss:Timestamp timeout="120"/&amp;gt;
&amp;lt;xwss:UsernameToken digestPassword="false" useNonce="true"/&amp;gt;
&amp;lt;/xwss:SecurityConfiguration&amp;gt;If I change useNonce to false, it works.
I can see in the console that the timestamp for nonce only has created, not expired
&amp;lt;wsse:UsernameToken xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" wsu:Id="XWSSGID-1159216970175594217203"&amp;gt;
&amp;lt;wsse:Username&amp;gt;Bert&amp;lt;/wsse:Username&amp;gt;
&amp;lt;wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText"&amp;gt;****&amp;lt;/wsse:Password&amp;gt;
&amp;lt;wsse:Nonce EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary"&amp;gt;lNS7NMI3OJWQ8WtjNiB0AuFS&amp;lt;/wsse:Nonce&amp;gt;
&amp;lt;wsu:Created&amp;gt;2006-09-25T20:42:50Z&amp;lt;/wsu:Created&amp;gt;
&amp;lt;/wsse:UsernameToken&amp;gt;
Jira opened as recommended by Arjen. 
Thanks.</description>
			<version>1.0 M2</version>
			<fixedVersion>1.0 M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.oxm.xmlbeans.XmlBeansUnmarshallerTest.java</file>
			<file type="M">org.springframework.oxm.xmlbeans.XmlBeansMarshaller.java</file>
			<file type="M">org.springframework.oxm.AbstractMarshaller.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.DefaultTimestampValidator.java</file>
		</fixedFiles>
	</bug>
	<bug id="59" opendate="2006-10-05 21:32:39" fixdate="2006-10-05 21:36:02" resolution="Fixed">
		<buginformation>
			<summary>CastorMarshaller does not marshal to DOM trees correctly</summary>
			<description>The CastorMarshaller does not create correct DOM trees. While marshalling to DOM nodes, castor uses a SAX2DOMHandler to publish SAX events into the DOM tree. This handler is a SAX 1 DocumentHandler, which has no native namespace support. There is a DocumentHandlerAdapter, which tries to correct this, but obviously that is failing. 
See http://forum.springframework.org/showthread.php?t=27476 and http://forum.springframework.org/showthread.php?t=28419</description>
			<version>1.0 M2</version>
			<fixedVersion>1.0 M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.oxm.AbstractMarshallerTestCase.java</file>
			<file type="M">org.springframework.oxm.castor.CastorMarshaller.java</file>
		</fixedFiles>
	</bug>
	<bug id="68" opendate="2006-12-03 09:15:01" fixdate="2006-12-04 08:22:47" resolution="Fixed">
		<buginformation>
			<summary>No way to propagate exception from an AbstractSaxPayloadEndpoint</summary>
			<description>The invoke method on AbstractSaxPayloadEndpoint declares that it can throw an exception, but there is no way to propagate checked exceptions back to it from createContentHandler and getResponse.  I need to be able to throw an exception from getResponse so an appropriate SOAP fault can be created.  All other Endpoint implementations seem to support this in some way.</description>
			<version>1.0 M2</version>
			<fixedVersion>1.0 M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.endpoint.AbstractSaxPayloadEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="75" opendate="2006-12-24 19:07:51" fixdate="2006-12-25 20:52:17" resolution="Fixed">
		<buginformation>
			<summary>Java 1.5+ Constructor Used for IllegalStateException</summary>
			<description>org.springframework.xml.stream.StaxEventXmlReader uses a constructor for IllegalStateException that is only available in Java 1.5 and later on line 68.  If this is meant to be able to compile with earlier versions of the jdk, then the second parameter should be dropped.</description>
			<version>1.0 M3</version>
			<fixedVersion>1.0 M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.stream.StaxEventXmlReader.java</file>
		</fixedFiles>
	</bug>
	<bug id="70" opendate="2006-12-04 14:10:32" fixdate="2006-12-25 22:15:39" resolution="Fixed">
		<buginformation>
			<summary>AbstractMarshallerTestCase.testMarshalDOMResult() builds a DOM object that does not retain namespace</summary>
			<description>with the combination of xml procesing libraries listed, the creation of the expected result document in testMarshalDOMResult loses the namespace attribute (xmlns:tns...).  For whatever reason, it doesn&amp;amp;apos;t get serialized.  Adding:
Attr namespace = expected.createAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:tns");
        namespace.setNodeValue("http://samples.springframework.org/flight");
        flightsElement.setAttributeNode(namespace);
creates a more valid test case.</description>
			<version>1.0 M3</version>
			<fixedVersion>1.0 M3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.oxm.AbstractMarshallerTestCase.java</file>
		</fixedFiles>
	</bug>
	<bug id="89" opendate="2007-02-01 20:24:18" fixdate="2007-02-01 20:29:39" resolution="Fixed">
		<buginformation>
			<summary>DefaultTimestampValidator uses wrong date format</summary>
			<description>org.springframework.ws.soap.security.xwss.callback.DefaultTimestampValidator uses the wrong date format.
See https://xwss.dev.java.net/issues/show_bug.cgi?id=14</description>
			<version>1.0 M1</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.DefaultTimestampValidator.java</file>
		</fixedFiles>
	</bug>
	<bug id="87" opendate="2007-01-31 13:51:00" fixdate="2007-02-14 01:44:25" resolution="Fixed">
		<buginformation>
			<summary>AbstractSoapMessage.getPayloadSource returns null with Axis SAAJ</summary>
			<description>Hi,
I have some more woes with Axis SAAJ.  This problem doesn&amp;amp;apos;t occur with jdk1.5 and Sun&amp;amp;apos;s SAAJ implementation, so it may well be the result of an axis bug.
The payload logging interceptor isn&amp;amp;apos;t logging responses for me, but requests get logged fine.  It turns out that getPayloadSource() was returning null.
I traced it through to getFirstBodyElement(SOAPBody) in Saaj12Implementation:
public SOAPBodyElement getFirstBodyElement(SOAPBody body) {
        for (Iterator iterator = body.getChildElements(); iterator.hasNext() {
            Object child = iterator.next();
            if (child instanceof SOAPBodyElement) 
{
                return (SOAPBodyElement) child;
            }
        }
        return null;
    }
The child it found was actually an instance of SOAPElement, not SOAPBodyElement.
	 body.getClass()
	 (java.lang.Class&amp;lt;T&amp;gt;) class org.apache.axis.message.SOAPBody
	 child.getClass()
	 (java.lang.Class&amp;lt;T&amp;gt;) class org.apache.axis.message.MessageElement
public class org.apache.axis.message.MessageElement extends org.apache.axis.message.NodeImpl implements javax.xml.soap.SOAPElement, (etc)
The javadoc for SOAPBody certainly implies that it should be a SOAPBodyElement, but it doesn&amp;amp;apos;t look as if SOAPBodyElement adds anything over SOAPElement so perhaps it can check for and return that instead? 
Thanks,
Brad. </description>
			<version>1.0 M3</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.saaj.Saaj13Implementation.java</file>
			<file type="M">org.springframework.ws.soap.saaj.Saaj11Implementation.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajImplementation.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoapMessageFactory.java</file>
			<file type="M">org.springframework.ws.soap.saaj.Saaj12Implementation.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoapMessage.java</file>
		</fixedFiles>
	</bug>
	<bug id="86" opendate="2007-01-31 08:57:06" fixdate="2007-02-17 23:34:39" resolution="Fixed">
		<buginformation>
			<summary>Stream closed before response read with WebServiceTemplate + Axis SAAJ Soap Messages</summary>
			<description>http://forum.springframework.org/showthread.php?t=34306
I&amp;amp;apos;m converting an existing SAAJ client into a Spring-WS client. I got the following error when the template tries to check for the fault:
org.springframework.ws.soap.saaj.SaajSoapEnvelopeE xception: Could not access envelope: org.xml.sax.SAXParseException: Premature end of file.; nested exception is javax.xml.soap.SOAPException: org.xml.sax.SAXParseException: Premature end of file.
It appears that the messages are created lazily from the stream, but the stream is closed before that happens. I was able to work around the problem by forcing the message to be read in the readResponse method (using hasFault() in this case, there may be a better way):
HttpUrlConnectionMessageSender webServiceMessageSender = new HttpUrlConnectionMessageSender() {
protected void readResponse(HttpURLConnection connection, MessageContext messageContext) throws IOException {
if (connection.getResponseCode() == HttpURLConnection.HTTP_NO_CONTENT || connection.getContentLength() == 0) {
return;
}
TransportInputStream tis = null;
try {
tis = new HttpUrlConnectionTransportInputStream(connection);
messageContext.readResponse(tis);
/* workaround problem with lazy read - force message to be read before stream is closed */
messageContext.getResponse().hasFault();
}
finally {
if (tis != null) {
tis.close();
}
}
}
};
I&amp;amp;apos;m using Java 1.4, Spring 1.0 M3, and my SAAJ implementation is Axis 1.4. I suspect the behaviour may not be evident for other SAAJ implementations.
I&amp;amp;apos;ve shown the HttpUrlConnectionMessageSender here but same problem and workaround applies for the commons http client one.</description>
			<version>1.0 M3</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.CommonsHttpMessageSender.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplateTest.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplate.java</file>
			<file type="M">org.springframework.ws.transport.TransportOutputStream.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceMessageCallback.java</file>
			<file type="M">org.springframework.ws.transport.TransportInputStream.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpUrlConnectionMessageSender.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceOperations.java</file>
			<file type="M">org.springframework.ws.transport.http.AbstractHttpWebServiceMessageSenderTestCase.java</file>
			<file type="M">org.springframework.ws.transport.WebServiceMessageSender.java</file>
		</fixedFiles>
	</bug>
	<bug id="101" opendate="2007-04-01 18:36:58" fixdate="2007-04-01 19:04:55" resolution="Fixed">
		<buginformation>
			<summary>XsdBasedSoap11Wsdl4jDefinitionBuilder parsing error</summary>
			<description>Parsing xml schema files with xs:element tags have do not a &amp;amp;apos;name&amp;amp;apos; attribute causes the builder to fail with the following exception when requesting the wsdl:
java.lang.NullPointerException
at org.springframework.ws.wsdl.wsdl11.builder.XsdBase dSoap11Wsdl4jDefinitionBuilder.isRequestMessage(Xs dBasedSoap11Wsdl4jDefinitionBuilder.java:244)
at org.springframework.ws.wsdl.wsdl11.builder.XsdBase dSoap11Wsdl4jDefinitionBuilder.buildMessages(XsdBa sedSoap11Wsdl4jDefinitionBuilder.java:223)
at org.springframework.ws.wsdl.wsdl11.builder.Abstrac tWsdl4jDefinitionBuilder.buildMessages(AbstractWsd l4jDefinitionBuilder.java:115)
I have tested a fix locally, and adding a null check to the element name within the following method resolves this problem:
protected void buildMessages(Definition definition) throws WSDLException {
		NodeList elements = schemaElement.getElementsByTagNameNS(
				SCHEMA_NAMESPACE_URI, "element");
		for (int i = 0; i &amp;lt; elements.getLength(); i++) {
			Element element = (Element) elements.item;
			QName elementName = getSchemaElementName(element);
			if ((elementName != null)
					&amp;amp;&amp;amp; (isRequestMessage(elementName) || isResponseMessage(elementName))) 
{
				Message message = definition.createMessage();
				populateMessage(message, element);
				Part part = definition.createPart();
				populatePart(part, elementName);
				message.addPart(part);
				message.setUndefined(false);
				definition.addMessage(message);
			}
		}
	}</description>
			<version>1.0 M3</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.wsdl.wsdl11.builder.XsdBasedSoap11Wsdl4jDefinitionBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="105" opendate="2007-04-04 09:42:41" fixdate="2007-04-09 22:58:34" resolution="Fixed">
		<buginformation>
			<summary>GZip compression is not enabled</summary>
			<description>The HTTP client does not handle GZip compression. I don&amp;amp;apos;t know if it can internally when handling the contents but the header sent to the server does not tell the server that it can handle GZip so the server never GZip the content.
This is very key as in a Rich-client / Web Service application, it is very possible to have the scenario of a large data set being sent over the wire. GZip compression speeds up the transfer markedly in some circumstances.
The step I did to try is as follow:
1) Activated GZip compression on Tomcat as "force" to be sure.
2) I monitored the network with Ethereal.
3) Connected to the server through my client program.
4) Looked at the headers sent and received.
I saw in JIRA the following entry, marked as FIXED, http://opensource.atlassian.com/projects/spring/browse/SPR-1255
Though, I&amp;amp;apos;m not tracking at all with the comments there.
Also see http://forum.springframework.org/showthread.php?p=111679#post111679
</description>
			<version>1.0 M3</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.CommonsHttpConnection.java</file>
			<file type="M">org.springframework.ws.transport.http.CommonsHttpMessageSender.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpUrlConnection.java</file>
			<file type="D">org.springframework.ws.transport.http.HttpUrlConnectionMessageSenderTest.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpUrlConnectionMessageSender.java</file>
			<file type="D">org.springframework.ws.transport.http.CommonsHttpMessageSenderTest.java</file>
			<file type="D">org.springframework.ws.transport.http.AbstractHttpWebServiceMessageSenderTestCase.java</file>
			<file type="M">org.springframework.ws.transport.http.AbstractHttpWebServiceMessageSender.java</file>
		</fixedFiles>
	</bug>
	<bug id="98" opendate="2007-03-19 06:13:53" fixdate="2007-05-19 21:15:17" resolution="Fixed">
		<buginformation>
			<summary>Changing URL in CommonsHttpMessageSender</summary>
			<description>There is no way of modifying the URL in CommonsHttpMessageSender.  In its current form, it is well suited for a hard coded URL, but does not handle setting the URL at runtime.  If you try to set up CommonsHttpMessageSender in the applicationContext.xml file without providing a URL, it will fail on startup.  If you provide a default URL, and then try to override it using the setUrl method, the new URL will not be used.  I believe that HttpUrlConnectionMessageSender has the same issue.</description>
			<version>1.0 M3</version>
			<fixedVersion>1.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="D">org.springframework.ws.transport.AbstractReceivingWebServiceConnection.java</file>
			<file type="D">org.springframework.ws.transport.AbstractSendingWebServiceConnection.java</file>
			<file type="M">org.springframework.ws.transport.http.AbstractHttpWebServiceMessageSenderIntegrationTestCase.java</file>
			<file type="M">org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.java</file>
			<file type="M">org.springframework.ws.client.core.support.WebServiceGatewaySupport.java</file>
			<file type="M">org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapterTest.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpUrlConnectionMessageSender.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplateIntegrationTest.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpServletConnectionTest.java</file>
			<file type="M">org.springframework.ws.client.support.WebServiceAccessor.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplateTest.java</file>
			<file type="M">org.springframework.ws.client.core.SimpleSaajServlet.java</file>
			<file type="D">org.springframework.ws.client.support.WebServiceAccessorTest.java</file>
			<file type="M">org.springframework.ws.transport.http.AbstractHttpWebServiceMessageSender.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplate.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpUrlConnection.java</file>
			<file type="M">org.springframework.ws.transport.WebServiceConnection.java</file>
			<file type="M">org.springframework.ws.transport.WebServiceMessageSender.java</file>
			<file type="M">org.springframework.ws.transport.http.CommonsHttpConnection.java</file>
			<file type="M">org.springframework.ws.transport.http.CommonsHttpMessageSender.java</file>
			<file type="M">org.springframework.ws.transport.support.WebServiceMessageReceiverObjectSupport.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpServletConnection.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceOperations.java</file>
			<file type="D">org.springframework.ws.transport.http.AbstractHttpSendingWebServiceConnection.java</file>
		</fixedFiles>
	</bug>
	<bug id="128" opendate="2007-05-23 23:36:45" fixdate="2007-05-26 20:23:05" resolution="Fixed">
		<buginformation>
			<summary>A SOAP:Fault does not set the the response code to 500</summary>
			<description>Whenever a SOAP Fault is returned on the server side, the server error code is not set to 500. This does not comply with WS-I.
See http://forum.springframework.org/showthread.php?t=39122</description>
			<version>1.0 RC1</version>
			<fixedVersion>1.0 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.CommonsHttpConnection.java</file>
			<file type="M">org.springframework.ws.transport.AbstractReceiverConnection.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpServletConnection.java</file>
			<file type="M">org.springframework.ws.transport.AbstractWebServiceConnection.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpUrlConnection.java</file>
		</fixedFiles>
	</bug>
	<bug id="133" opendate="2007-05-30 19:29:24" fixdate="2007-05-30 23:20:29" resolution="Fixed">
		<buginformation>
			<summary>CastorMarshaller ignoreExtraAttributes &amp; Elements</summary>
			<description>Spring CastorMarshaller class does not expose the ignoreExtraAttributes and ignoreExtraElements settings from the Castor Unmarshaller class.  This means that when you use Castor Unmarshaller you are forced to map every XML element to an object.  </description>
			<version>1.0 RC1</version>
			<fixedVersion>1.0 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.oxm.castor.CastorMarshaller.java</file>
			<file type="M">org.springframework.oxm.xmlbeans.XmlBeansMarshaller.java</file>
			<file type="M">org.springframework.oxm.AbstractMarshaller.java</file>
		</fixedFiles>
	</bug>
	<bug id="137" opendate="2007-06-07 13:46:02" fixdate="2007-06-08 10:59:09" resolution="Fixed">
		<buginformation>
			<summary>WebServiceTemplate hasFaut skips check for fault in response if the connection implements FaultAwareWebServiceConnection</summary>
			<description>The method should check for a fault in the connection and then in the response as follows:
protected boolean hasFault(WebServiceConnection connection, WebServiceMessage response) throws IOException {
		if (connection instanceof FaultAwareWebServiceConnection) 
{
			if (((FaultAwareWebServiceConnection) connection).hasFault())
				return true;
		}
		return response.hasFault();
	}</description>
			<version>1.0 RC1</version>
			<fixedVersion>1.0 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.CommonsHttpConnection.java</file>
			<file type="M">org.springframework.ws.MockWebServiceMessage.java</file>
			<file type="M">org.springframework.ws.server.MessageDispatcher.java</file>
			<file type="M">org.springframework.ws.client.WebServiceFaultException.java</file>
			<file type="M">org.springframework.ws.soap.saaj.AbstractSaajImplementationTestCase.java</file>
			<file type="M">org.springframework.ws.transport.support.WebServiceMessageReceiverObjectSupport.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplateTest.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpServletConnection.java</file>
			<file type="M">org.springframework.ws.soap.SoapMessage.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplate.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpUrlConnection.java</file>
			<file type="M">org.springframework.ws.AbstractWebServiceMessageTestCase.java</file>
			<file type="M">org.springframework.ws.WebServiceMessage.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplateIntegrationTest.java</file>
			<file type="M">org.springframework.ws.transport.http.MessageDispatcherServlet.java</file>
			<file type="M">org.springframework.ws.client.core.SimpleFaultMessageResolverTest.java</file>
			<file type="M">org.springframework.ws.transport.FaultAwareWebServiceConnection.java</file>
			<file type="M">org.springframework.ws.transport.http.AbstractHttpSenderConnection.java</file>
			<file type="M">org.springframework.ws.client.core.SimpleFaultMessageResolver.java</file>
			<file type="M">org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapterTest.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">330</link>
		</links>
	</bug>
	<bug id="141" opendate="2007-06-19 18:56:24" fixdate="2007-06-22 21:29:04" resolution="Fixed">
		<buginformation>
			<summary>Minor Documentation Bug: org.springframework.xml.transform.ResourceSource</summary>
			<description>In org.springframework.xml.transform.ResourceSource the javadoc says it is an "convenient subclass of &amp;lt;code&amp;gt;StreamSource&amp;lt;/code&amp;gt;" but ResourceSource is really a subclass of SAXSource.</description>
			<version>1.0 RC2</version>
			<fixedVersion>1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.transform.ResourceSource.java</file>
		</fixedFiles>
	</bug>
	<bug id="142" opendate="2007-06-21 00:14:30" fixdate="2007-06-22 22:34:06" resolution="Fixed">
		<buginformation>
			<summary>AxiomSoapFaultDetailElementIterator does not consider whitespace nodes</summary>
			<description>The org.springframework.ws.soap.axiom.AxiomSoapFaultDetail$AxiomFaultDetailElementIterator throws a ClassCastException if the Fault Detail element contains whitespace nodes, e.g. line breaks (\n). This seems to be due to the fact that the next() method casts everything to OMElement and does not consider OMTextImpl nodes (which represent whitespace).</description>
			<version>1.0 RC2</version>
			<fixedVersion>1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapFaultDetailTest.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapFaultDetail.java</file>
		</fixedFiles>
	</bug>
	<bug id="145" opendate="2007-06-24 20:17:42" fixdate="2007-06-24 20:17:51" resolution="Fixed">
		<buginformation>
			<summary>When using JAXB2, all messages become MTOM</summary>
			<description>When using the JAXB2 marshaller, all SaajSoapMessages become MTOM enabled by default. This can be changed by setting the &amp;amp;apos;mtomEnabled&amp;amp;apos; property of the Jaxb2Marshaller to &amp;amp;apos;false&amp;amp;apos;. We really should set the default to false, since it&amp;amp;apos;s currently true.</description>
			<version>1.0 RC2</version>
			<fixedVersion>1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.oxm.jaxb.Jaxb2Marshaller.java</file>
			<file type="M">org.springframework.oxm.jaxb.Jaxb2UnmarshallerTest.java</file>
			<file type="M">org.springframework.oxm.jaxb.Jaxb2MarshallerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="149" opendate="2007-06-27 21:32:09" fixdate="2007-06-27 21:51:44" resolution="Fixed">
		<buginformation>
			<summary>marshallSendAndReceivce bug in WebServiceTemplate</summary>
			<description>The method "marshalSendAndReceive(String uri, final Object requestPayload)" in class "WebServiceTemplate" calls the wrong overloaded method. The parameter "uri" is not used in this call and will be replaced by the "defaultUri" in the called method.
Wrong:
public Object marshalSendAndReceive(String uri, final Object requestPayload) {
    return marshalSendAndReceive(requestPayload, null);
}
Correct:
public Object marshalSendAndReceive(String uri, final Object requestPayload) {
    return marshalSendAndReceive(uri, requestPayload, null);
}</description>
			<version>1.0 RC2</version>
			<fixedVersion>1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="150" opendate="2007-06-28 23:16:16" fixdate="2007-06-29 00:00:51" resolution="Fixed">
		<buginformation>
			<summary>Don&amp;apos;t close the ServletInputStream in AbstractWebServiceConnection.receive</summary>
			<description>Some SAAJ implementations (Axis1 for instance) don&amp;amp;apos;t read the entire message when using MessageFactory.createMessage(mimeHeaders,InputStream). Instead, they lazily instantiate the message. Therefore, closing the stream should be deferred to when the connection is closed. 
See http://forum.springframework.org/showthread.php?t=40413</description>
			<version>1.0 RC2</version>
			<fixedVersion>1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.HttpServletConnection.java</file>
		</fixedFiles>
	</bug>
	<bug id="158" opendate="2007-07-11 04:32:21" fixdate="2007-07-30 23:15:04" resolution="Fixed">
		<buginformation>
			<summary>java.lang.IllegalArgumentException: This is not an attribute, it is a namespace: xmlns:xs</summary>
			<description>java.lang.IllegalArgumentException: This is not an attribute, it is a namespace:xmlns:xs
        at weblogic.xml.xmlnode.XMLNode.addAttribute(XMLNode.java:488)
        at weblogic.webservice.core.soap.SOAPElementImpl.addAttribute(SOAPElementImpl.java:169)
        at org.springframework.ws.soap.saaj.support.SaajContentHandler.startElement(SaajContentHandler.java:86)
        at org.apache.xalan.transformer.TransformerIdentityImpl.startElement(TransformerIdentityImpl.java:1072)
        at org.apache.xml.serializer.TreeWalker.startNode(TreeWalker.java:357)
        at org.apache.xml.serializer.TreeWalker.traverse(TreeWalker.java:143)
        at org.apache.xalan.transformer.TransformerIdentityImpl.transform(TransformerIdentityImpl.java:389)
The exception above occurred when transforming the xml below:
&amp;lt;AttributeValue xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="xs:string"&amp;gt;XYZ&amp;lt;/AttributeValue&amp;gt;
Please see the patch for the fix.</description>
			<version>1.0 M3</version>
			<fixedVersion>1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.saaj.support.SaajContentHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="152" opendate="2007-06-29 08:00:23" fixdate="2007-07-30 23:47:56" resolution="Fixed">
		<buginformation>
			<summary>NoSuchMethodError: SaajUtils.toName()</summary>
			<description>The following exception occurred when attempting to add a header to the response message:
29 Jun 2007 20:38:04,897 DEBUG MessageDispatcherServlet []: Could not complete request
java.lang.NoSuchMethodError: javax.xml.soap.SOAPElement.getVisibleNamespacePrefixes()Ljava/util/Iterator;
        at org.springframework.ws.soap.saaj.support.SaajUtils.toName(SaajUtils.java:122)
        at org.springframework.ws.soap.saaj.Saaj11Implementation.addHeaderElement(Saaj11Implementation.java:109)
        at org.springframework.ws.soap.saaj.SaajSoapHeader.addHeaderElement(SaajSoapHeader.java:54)
        ...
The problem is in SaajUtils.java, line 122:
Iterator prefixes = resolveElement.getVisibleNamespacePrefixes();
However, getVisibleNamespacePrefixes() is not available in SAAJ 1.1. 
I will submit a patch shortly.</description>
			<version>1.0 M3</version>
			<fixedVersion>1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.saaj.support.SaajUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="151" opendate="2007-06-29 06:39:18" fixdate="2007-07-31 00:11:20" resolution="Fixed">
		<buginformation>
			<summary>IllegalStateException in Saaj11Implementation.removeContents()</summary>
			<description>The following stack trace occurred while attempting to use the PayloadTransformingInterceptor.
29 Jun 2007 19:14:10,804 WARN  SoapMessageDispatcher []: Endpoint invocation resulted in exception - responding with SOAP Fault
java.lang.IllegalStateException
        at java.util.AbstractList$Itr.remove(AbstractList.java:432)
        at org.springframework.ws.soap.saaj.Saaj11Implementation.removeContents(Saaj11Implementation.java:279)
        at org.springframework.ws.soap.saaj.SaajSoapBody.getPayloadResult(SaajSoapBody.java:43)
        at org.springframework.ws.soap.AbstractSoapMessage.getPayloadResult(AbstractSoapMessage.java:56)
        at org.springframework.ws.server.endpoint.interceptor.PayloadTransformingInterceptor.handleRequest(PayloadTransformingInterceptor.java:85)
        at org.springframework.ws.server.MessageDispatcher.dispatch(MessageDispatcher.java:197)
        at org.springframework.ws.server.MessageDispatcher.receive(MessageDispatcher.java:166)
        at org.springframework.ws.transport.support.WebServiceMessageReceiverObjectSupport.handle(WebServiceMessageReceiverObjectSupport.java:78)
        at org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.handle(WebServiceMessageReceiverHandlerAdapter.java:60)
        at org.springframework.ws.transport.http.MessageDispatcherServlet.doService(MessageDispatcherServlet.java:125)
        at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:396)
        at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:360)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:760)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:853)
        at weblogic.servlet.internal.ServletStubImpl$ServletInvocationAction.run(ServletStubImpl.java:996)
        at weblogic.servlet.internal.ServletStubImpl.invokeServlet(ServletStubImpl.java:419)
        at weblogic.servlet.internal.ServletStubImpl.invokeServlet(ServletStubImpl.java:315)
        at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run(WebAppServletContext.java:6452)
        at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:321)
        at weblogic.security.service.SecurityManager.runAs(SecurityManager.java:118)
        at weblogic.servlet.internal.WebAppServletContext.invokeServlet(WebAppServletContext.java:3661)
        at weblogic.servlet.internal.ServletRequestImpl.execute(ServletRequestImpl.java:2630)
        at weblogic.kernel.ExecuteThread.execute(ExecuteThread.java:219)
        at weblogic.kernel.ExecuteThread.run(ExecuteThread.java:178)
I believe I have identified the source of the problem and will be attaching a patch shortly.</description>
			<version>1.0 M3</version>
			<fixedVersion>1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.saaj.Saaj11Implementation.java</file>
			<file type="M">org.springframework.ws.soap.saaj.AbstractSaajImplementationTestCase.java</file>
		</fixedFiles>
	</bug>
	<bug id="156" opendate="2007-07-11 03:18:44" fixdate="2007-08-14 09:13:46" resolution="Fixed">
		<buginformation>
			<summary>client-side support for JAXB2 MTOM marshalling is not working well</summary>
			<description>It&amp;amp;apos;s related to this thread:
http://forum.springframework.org/showthread.php?t=38587</description>
			<version>1.0 RC2</version>
			<fixedVersion>1.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.endpoint.AbstractMarshallingPayloadEndpoint.java</file>
			<file type="M">org.springframework.ws.server.endpoint.adapter.MarshallingMethodEndpointAdapter.java</file>
			<file type="D">org.springframework.ws.server.endpoint.support.MarshallingUtils.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="164" opendate="2007-08-08 18:14:42" fixdate="2007-08-25 06:18:47" resolution="Fixed">
		<buginformation>
			<summary>Null pointer while handling empty SOAP Body</summary>
			<description>I get a NullPointer exception when I issue a web service request with an empty input message. This results in an empty soap body which is totally legal (and works with other webservice frameworks)
With Spring-WS I get a NullPointerException. This is caused by the fact that a null object is sent to the transformer. IMO a check should be build in that does no transformation when there is an empty payload.
I know that I can get around this by implementing the MessageEndpoint interface but then I loose the transformation functionality e.d. I guess sending an empty message is normal functionality
Anyway, there is a workaround but it is a bit annoying
</description>
			<version>1.0 RC2</version>
			<fixedVersion>1.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.endpoint.adapter.MarshallingMethodEndpointAdapterTest.java</file>
			<file type="M">org.springframework.ws.support.MarshallingUtilsTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.AbstractStaxEventPayloadEndpoint.java</file>
			<file type="M">org.springframework.ws.MockWebServiceMessage.java</file>
			<file type="M">org.springframework.ws.server.endpoint.AbstractStaxStreamPayloadEndpoint.java</file>
			<file type="M">org.springframework.ws.server.endpoint.MarshallingPayloadEndpointTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.StaxStreamPayloadEndpointTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.AbstractMessageEndpointTestCase.java</file>
			<file type="M">org.springframework.ws.server.endpoint.StaxEventPayloadEndpointTest.java</file>
			<file type="M">org.springframework.ws.support.MarshallingUtils.java</file>
			<file type="M">org.springframework.ws.server.endpoint.AbstractDomPayloadEndpoint.java</file>
			<file type="M">org.springframework.ws.server.endpoint.AbstractXomPayloadEndpoint.java</file>
			<file type="M">org.springframework.ws.server.endpoint.Dom4jPayloadEndpointTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.SaxPayloadEndpointTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.NonReflectiveXomPayloadEndpointTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.AbstractDom4jPayloadEndpoint.java</file>
			<file type="M">org.springframework.ws.server.endpoint.DomPayloadEndpointTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.AbstractPayloadEndpointTestCase.java</file>
			<file type="M">org.springframework.ws.server.endpoint.ReflectiveXomPayloadEndpointTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.AbstractSaxPayloadEndpoint.java</file>
			<file type="M">org.springframework.ws.server.endpoint.PayloadEndpoint.java</file>
			<file type="M">org.springframework.ws.server.endpoint.JDomPayloadEndpointTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.AbstractJDomPayloadEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="171" opendate="2007-08-21 21:44:47" fixdate="2007-09-07 13:01:11" resolution="Fixed">
		<buginformation>
			<summary>Jaxb2Marshaller.supports(Class clazz) is too eager</summary>
			<description>When using multiple Jaxb2Marshallers for multiple endpoints, first encountered Jaxb2Marshaller is always used, because it&amp;amp;apos;s "support" method accepts every Jaxb class. My proposition for improvement is:
	public boolean supports(Class clazz) {
		boolean isJaxbClass = clazz.getAnnotation(XmlRootElement.class) != null


 JAXBElement.class.isAssignableFrom(clazz);
		if (isJaxbClass) {
			if (StringUtils.hasLength(getContextPath())) {
				String pckgName = clazz.getPackage().getName();
				StringTokenizer st = new StringTokenizer(getContextPath(), ":");
				while (st.hasMoreTokens()) 
Unknown macro: {					if (st.nextToken().equals(pckgName)) {
						return true;
					}
				}
			} else if (!ObjectUtils.isEmpty(classesToBeBound)) {
				for (Class clazzToBeBo : classesToBeBound) {
					if (clazzToBeBo.equals(clazz)) {						return true;					}				} 
			} else 
{
				throw new IllegalArgumentException(
						"setting either contextPath or classesToBeBound is required");
			}
		}
		return false;
	}


</description>
			<version>1.0</version>
			<fixedVersion>1.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.oxm.jaxb.Jaxb2Marshaller.java</file>
		</fixedFiles>
	</bug>
	<bug id="191" opendate="2007-09-08 17:05:26" fixdate="2007-09-09 08:01:23" resolution="Fixed">
		<buginformation>
			<summary>Loading default key store overwrites truststore</summary>
			<description>When no keyStore property is set on the KeyStoreCallbackHandler a default key store is loaded. However, in stead of loading the keyStore it loads the trustStore with the data. See line 600 of KeyStoreCallbackHandler. This messes up the situation where you don&amp;amp;apos;t need a keyStore, but do need a trustStore (like XML encryption).</description>
			<version>1.0</version>
			<fixedVersion>1.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="165" opendate="2007-08-10 02:02:05" fixdate="2007-09-09 08:36:02" resolution="Fixed">
		<buginformation>
			<summary>GZIP decompression handling in client</summary>
			<description>When trying to use gzip compression with a spring-ws client, i get this exception:
2007-08-10 16:06:40,375 INFO [org.springframework.ws.soap.saaj.SaajSoapMessageFactory::afterPropertiesSet] - &amp;lt;Creating SAAJ 1.3 MessageFactory with SOAP 1.1 Protocol&amp;gt;
java.io.IOException: Not in GZIP format
	at java.util.zip.GZIPInputStream.readHeader(GZIPInputStream.java:132)
	at java.util.zip.GZIPInputStream.&amp;lt;init&amp;gt;(GZIPInputStream.java:58)
	at java.util.zip.GZIPInputStream.&amp;lt;init&amp;gt;(GZIPInputStream.java:68)
	at org.springframework.ws.transport.http.AbstractHttpSenderConnection.getResponseInputStream(AbstractHttpSenderConnection.java:78)
	at org.springframework.ws.transport.AbstractSenderConnection$ResponseTransportInputStream.createInputStream(AbstractSenderConnection.java:100)
	at org.springframework.ws.transport.TransportInputStream.getInputStream(TransportInputStream.java:42)
	at org.springframework.ws.transport.TransportInputStream.read(TransportInputStream.java:79)
	at com.sun.xml.messaging.saaj.util.ByteOutputStream.write(ByteOutputStream.java:80)
	at com.sun.xml.messaging.saaj.util.JAXMStreamSource.&amp;lt;init&amp;gt;(JAXMStreamSource.java:50)
	at com.sun.xml.messaging.saaj.soap.SOAPPartImpl.setContent(SOAPPartImpl.java:227)
	at com.sun.xml.messaging.saaj.soap.MessageImpl.init(MessageImpl.java:364)
	at com.sun.xml.messaging.saaj.soap.MessageImpl.&amp;lt;init&amp;gt;(MessageImpl.java:273)
	at com.sun.xml.messaging.saaj.soap.ver1_1.Message1_1Impl.&amp;lt;init&amp;gt;(Message1_1Impl.java:68)
	at com.sun.xml.messaging.saaj.soap.ver1_1.SOAPMessageFactory1_1Impl.createMessage(SOAPMessageFactory1_1Impl.java:62)
	at org.springframework.ws.soap.saaj.SaajSoapMessageFactory.createWebServiceMessage(SaajSoapMessageFactory.java:163)
	at org.springframework.ws.transport.AbstractWebServiceConnection.receive(AbstractWebServiceConnection.java:52)
	at org.springframework.ws.client.core.WebServiceTemplate.sendAndReceive(WebServiceTemplate.java:408)
	at org.springframework.ws.client.core.WebServiceTemplate.doSendAndReceive(WebServiceTemplate.java:357)
	at org.springframework.ws.client.core.WebServiceTemplate.sendSourceAndReceiveToResult(WebServiceTemplate.java:305)
	at org.springframework.ws.client.core.WebServiceTemplate.sendSourceAndReceiveToResult(WebServiceTemplate.java:296)
        ....
I tried to debug a little. This is my client code:
        DOMResult responseResult = new DOMResult(documentResponse);
        boolean err = !getWebServiceTemplate().sendSourceAndReceiveToResult(
                new DOMSource(document), new SoapActionCallback("findByIdOperation"),
                responseResult);
        if (err)
            throw new Exception("blah blah blah");
What happens (approximatively) is:

the soap request is sent to the remote server
response comes back with a Content-Encoding http header set to "gzip" and payload is gzipped
in org.springframework.ws.transport.http.AbstractHttpSenderConnection, getResponseInputStream() is called:

    protected final InputStream getResponseInputStream() throws IOException {
        InputStream inputStream;
        if (responseBuffer != null) 
{
            inputStream = new ByteArrayInputStream(responseBuffer);
        }
        else {
            inputStream = getRawResponseInputStream();
        }
        return isGzipResponse() ? new GZIPInputStream(inputStream) : inputStream;
    }

    /** Determine whether the given response is a GZIP response. */
    private boolean isGzipResponse() throws IOException {
        for (Iterator iterator = getResponseHeaders(HttpTransportConstants.HEADER_CONTENT_ENCODING);
             iterator.hasNext() {
            String encodingHeader = (String) iterator.next();
            return encodingHeader.toLowerCase().indexOf(HttpTransportConstants.CONTENT_ENCODING_GZIP) != -1;
        }
        return false;
    }

The first time the function is called, responseBuffer is null, so a raw input stream is created and wrapped into a gzip input stream (since isGzipResponse() return true). Next time function is called, responseBuffer (which holds the now unzipped payload) is wrapped into a bytearray input stream ... but also into a gzip input stream (since isGzipResponse() still returns true). Gzip complains about not finding the magic bytes at the beginning of the stream (which in fact starts by "&amp;lt;?xml version=").

At first glance, getResponseInputStream() should be (but couldn&amp;amp;apos;t test it so don&amp;amp;apos;t know about side effects :-O):

        if (responseBuffer != null) {            inputStream = new ByteArrayInputStream(responseBuffer);        }
        else 
{
            inputStream = getRawResponseInputStream();
            if(isGzipResponse())
                inputStream = new GZIPInputStream(inputStream);
        }
        return inputStream;
Best regards.    </description>
			<version>1.0 RC2</version>
			<fixedVersion>1.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.AbstractHttpWebServiceMessageSenderIntegrationTestCase.java</file>
			<file type="M">org.springframework.ws.transport.http.AbstractHttpSenderConnection.java</file>
		</fixedFiles>
	</bug>
	<bug id="170" opendate="2007-08-21 00:18:39" fixdate="2007-09-14 23:01:09" resolution="Fixed">
		<buginformation>
			<summary>AxiomSoapMessageFactory + PayloadRootAnnotationMethodEndpointMapping allways falls to DOM parsing</summary>
			<description>DOM transformation is used every time in org.springframework.ws.server.endpoint.support.PayloadRootUtils#getPayloadRootQName because the root event type is XMLStreamConstants.START_DOCUMENT
Proposed improvement: (working with Woodstox 3.2.1.jar and sjsxp 1.0.1)
    public static QName getPayloadRootQName(Source source, TransformerFactory transformerFactory)
            throws TransformerException, XMLStreamException {
        if (source instanceof DOMSource) {
            DOMSource domSource = (DOMSource) source;
            Node node = domSource.getNode();
            if (node.getNodeType() == Node.ELEMENT_NODE) 
{
                return QNameUtils.getQNameForNode(node);
            }
            else if (node.getNodeType() == Node.DOCUMENT_NODE) 
{
                Document document = (Document) node;
                return QNameUtils.getQNameForNode(document.getDocumentElement());
            }
        }
        else if (source instanceof StaxSource) {
            StaxSource staxSource = (StaxSource) source;
            if (staxSource.getXMLStreamReader() != null) {
                XMLStreamReader streamReader = staxSource.getXMLStreamReader();
                if (streamReader.getEventType() == XMLStreamConstants.START_ELEMENT ||
                        streamReader.getEventType() == XMLStreamConstants.END_ELEMENT) 
{
                    return streamReader.getName();
                }
 else if(streamReader.getEventType() == XMLStreamConstants.START_DOCUMENT) {
			streamReader.next();
                	if(streamReader.getEventType() == XMLStreamConstants.START_ELEMENT ||
                      streamReader.getEventType() == XMLStreamConstants.END_ELEMENT) 
{
                		return streamReader.getName();
                	}
                }
            }
        }
        // we have no other option than to transform
        Transformer transformer = transformerFactory.newTransformer();
        DOMResult domResult = new DOMResult();
        transformer.transform(source, domResult);
        Document document = (Document) domResult.getNode();
        return QNameUtils.getQNameForNode(document.getDocumentElement());
    }</description>
			<version>1.0</version>
			<fixedVersion>1.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.endpoint.mapping.SimpleMethodEndpointMapping.java</file>
			<file type="M">org.springframework.ws.server.endpoint.support.PayloadRootUtils.java</file>
			<file type="M">org.springframework.ws.server.endpoint.mapping.PayloadRootQNameEndpointMapping.java</file>
			<file type="M">org.springframework.ws.server.endpoint.support.PayloadRootUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="195" opendate="2007-09-20 23:11:31" fixdate="2007-09-20 23:25:44" resolution="Fixed">
		<buginformation>
			<summary>Incorrect javadoc in org.springframework.ws.soap.SoapFault</summary>
			<description>The javadoc for method getFaultDetail() refers to addFaultDetail() and vice versa.</description>
			<version>1.0</version>
			<fixedVersion>1.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.SoapFault.java</file>
		</fixedFiles>
	</bug>
	<bug id="188" opendate="2007-09-05 00:30:38" fixdate="2007-09-24 21:27:55" resolution="Fixed">
		<buginformation>
			<summary>WS-Security exception not being handled</summary>
			<description>The Spring WS framework does not handle WSSE related exceptions such as WssSoapFaultException. Ideally, the framework should catch this exception and map it to an appropriate SOAP Fault rather than requiring the user code to do so. See the following forum entry for a full discussion of this issue.
http://forum.springframework.org/showthread.php?t=42647</description>
			<version>1.0 RC2</version>
			<fixedVersion>1.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.xwss.XwsSecuritySecurementException.java</file>
			<file type="M">org.springframework.ws.soap.security.AbstractWsSecurityInterceptor.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.XwsSecurityValidationException.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.XwsSecurityInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="203" opendate="2007-10-04 17:53:37" fixdate="2007-10-22 02:06:27" resolution="Fixed">
		<buginformation>
			<summary>Namespace declarations may be removed from the wsdl when transformWsdlLocations = true</summary>
			<description>See http://forum.springframework.org/showthread.php?t=44599
When a SimpleWsdl11Definition is used in combination with transformWsdlLocations=true, namespace declarations are removed which leads to an invalid wsdl. 
Resetting transfromWsdlLocations to false resolves the issue (with the penalty that the wsdl locations are no longer transformed).</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.transform.ResourceSource.java</file>
			<file type="M">org.springframework.xml.validation.SchemaLoaderUtils.java</file>
			<file type="M">org.springframework.ws.transport.http.WsdlDefinitionHandlerAdapterTest.java</file>
			<file type="M">org.springframework.ws.wsdl.wsdl11.SimpleWsdl11Definition.java</file>
			<file type="M">org.springframework.ws.server.endpoint.interceptor.PayloadTransformingInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="216" opendate="2007-10-25 17:27:09" fixdate="2007-10-26 21:42:28" resolution="Fixed">
		<buginformation>
			<summary>AbstractValidatingInterceptor.handleResponseValidationErrors&amp;apos;s JavaDoc is wrong</summary>
			<description>AbstractValidatingInterceptor.handleResponseValidationErrors&amp;amp;apos;s JavaDoc states the following:
    /**

Template method that is called when the response message contains validation errors. Default implementation logs
all errors, and returns &amp;lt;code&amp;gt;false&amp;lt;/code&amp;gt;, i.e. do not send the response.
     *
@param messageContext the message context
@param errors         the validation errors @return &amp;lt;code&amp;gt;true&amp;lt;/code&amp;gt; to continue sending the response,
&amp;lt;code&amp;gt;false&amp;lt;/code&amp;gt; (the default) otherwise
     */

However, returning false here doesn&amp;amp;apos;t mean that the response won&amp;amp;apos;t be send. It means that the rest of the Interceptor chain won&amp;amp;apos;t be processed and that the response will be send out immediately (see MessageDispatcher.triggerHandleResponse). The docs should be changed to represent the actual behaviour.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.endpoint.interceptor.AbstractValidatingInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="146" opendate="2007-06-27 02:03:49" fixdate="2007-10-28 10:54:52" resolution="Fixed">
		<buginformation>
			<summary>MessageDispatcherServlet does not search servlet context for a WsdlDefinitionHandlerAdapter instance</summary>
			<description>The servlet should look in it&amp;amp;apos;s application context for an instance of WsdlDefinitionHandlerAdapter to use. I believe this is the standard set by the DispatcherServlet for all pluggable logic modules. I&amp;amp;apos;ll open another issue for the MessageReceiverHandlerAdapter.</description>
			<version>1.0 RC2</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.WsdlDefinitionHandlerAdapter.java</file>
			<file type="M">org.springframework.ws.transport.http.WsdlDefinitionHandlerAdapterTest.java</file>
			<file type="M">org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.java</file>
			<file type="M">org.springframework.ws.transport.http.MessageDispatcherServlet.java</file>
		</fixedFiles>
	</bug>
	<bug id="202" opendate="2007-10-01 01:30:39" fixdate="2007-10-28 11:50:50" resolution="Fixed">
		<buginformation>
			<summary>Endpoint Mapping and Saxon</summary>
			<description>PayloadRootQNameEndpointMapping  gives an error when Saxon is the XSL transformer. It seems that Saxon is expecting a SAX 2 parser, while it receives an instance of SaajXMLReader, which is a SAX 1 parser.
This bug happened while trying to deploy a spring web service in weblogic 9, with Saxon sets as its default XSL transformer (with the JVM flag: -Djavax.xml.transform.TransformerFactory=net.sf.saxon.TransformerFactoryImpl)
The only beans that are defined in spring are the PayloadRootQNameEndpointMapping  and the Endpoints themselves.
Here is the stack trace I get:
2007-09-27 23:36:06,537 WARN org.springframework.ws.soap.server.SoapMessageDisp atcher - Endpoint invocation resulted in exception - responding with SOAP Fault
net.sf.saxon.trans.DynamicError: The SAX2 parser does not support setting the &amp;amp;apos;namespaces&amp;amp;apos; feature to true
at net.sf.saxon.event.Sender.configureParser(Sender.java:357)
at net.sf.saxon.event.Sender.sendSAXSource(Sender.java:241)
at net.sf.saxon.event.Sender.send(Sender.java:142)
at net.sf.saxon.IdentityTransformer.transform(IdentityTransformer.java:29)
at org.springframework.ws.server.endpoint.support.PayloadRootUtils.getPayloadRootQName(PayloadRootUtils .java:79)
at org.springframework.ws.server.endpoint.mapping.PayloadRootQNameEndpointMapping.resolveQName(PayloadR ootQNameEndpointMapping.java:56)
at org.springframework.ws.server.endpoint.mapping.AbstractQNameEndpointMapping.getLookupKeyForMessage(A bstractQNameEndpointMapping.java:33)
at org.springframework.ws.server.endpoint.mapping.AbstractMapBasedEndpointMapping.getEndpointInternal(A bstractMapBasedEndpointMapping.java:106)
at org.springframework.ws.server.endpoint.mapping.AbstractEndpointMapping.getEndpoint(AbstractEndpointM apping.java:83)
at org.springframework.ws.server.MessageDispatcher.getEndpoint(MessageDispatcher.java:238)
at org.springframework.ws.server.MessageDispatcher.dispatch(MessageDispatcher.java:191)
at org.springframework.ws.server.MessageDispatcher.receive(MessageDispatcher.java:158)
at org.springframework.ws.transport.support.WebServiceMessageReceiverObjectSupport.handleConnection(Web ServiceMessageReceiverObjectSupport.java:87)
at org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.handle(WebServiceMessa geReceiverHandlerAdapter.java:57)
at org.springframework.ws.transport.http.MessageDispatcherServlet.doService(MessageDispatcherServlet.ja va:158)
at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:461)
at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:426)
at javax.servlet.http.HttpServlet.service(HttpServlet .java:763)
at javax.servlet.http.HttpServlet.service(HttpServlet .java:856)
at weblogic.servlet.internal.StubSecurityHelper$ServletServiceAction.run(StubSecurityHelper.java:225)
at weblogic.servlet.internal.StubSecurityHelper.invokeServlet(StubSecurityHelper.java:127)
at weblogic.servlet.internal.ServletStubImpl.execute(ServletStubImpl.java:283)
at weblogic.servlet.internal.ServletStubImpl.execute(ServletStubImpl.java:175)
at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run(WebAppServletContext.java :3211)
at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:321)
at weblogic.security.service.SecurityManager.runAs(SecurityManager.java:121)
at weblogic.servlet.internal.WebAppServletContext.securedExecute(WebAppServletContext.java:1983)
at weblogic.servlet.internal.WebAppServletContext.execute(WebAppServletContext.java:1890)
at weblogic.servlet.internal.ServletRequestImpl.run(S ervletRequestImpl.java:1344)
at weblogic.work.ExecuteThread.execute(ExecuteThread. java:209)
at weblogic.work.ExecuteThread.run(ExecuteThread.java :181)
</description>
			<version>1.0</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.sax.AbstractXmlReader.java</file>
			<file type="M">org.springframework.ws.soap.saaj.support.SaajXmlReaderTest.java</file>
			<file type="M">org.springframework.ws.soap.saaj.support.SaajXmlReader.java</file>
		</fixedFiles>
	</bug>
	<bug id="217" opendate="2007-10-28 12:55:41" fixdate="2007-10-29 00:33:27" resolution="Fixed">
		<buginformation>
			<summary>Booking a flight for non-existent flight should result in NoSuchFlightException</summary>
			<description>Submitting an invalid flight number (e.g. KL9999) bubbles up as an EmptyResultDataAccessException instead of NoSuchFlightException. This is because the JpaFlightDao uses query.getSingleResult(), which can throw a NoResultException instead of returning null. Submitting an invalid username has a similar issue. 
I&amp;amp;apos;ve created a fix in the JPA DAO&amp;amp;apos;s to ensure they catch a NoResultException and re-throw it as a business exception. In the case of an invalid username I added a NoSuchUsernameException business exception.
See attached patch for a root-level Eclipse project named &amp;amp;apos;airline&amp;amp;apos; created with &amp;amp;apos;mvn eclipse:eclipse&amp;amp;apos; from the samples directory and connected to the Spring-WS SVN repository.</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.samples.airline.dao.jpa.JpaFrequentFlyerDao.java</file>
			<file type="M">org.springframework.ws.samples.airline.ws.MarshallingAirlineEndpoint.java</file>
			<file type="M">org.springframework.ws.samples.airline.service.impl.AirlineServiceImpl.java</file>
			<file type="M">org.springframework.ws.samples.airline.dao.jpa.JpaFlightDaoTest.java</file>
			<file type="M">org.springframework.ws.samples.airline.ws.XPathAirlineEndpoint.java</file>
			<file type="M">org.springframework.ws.samples.airline.service.AirlineService.java</file>
			<file type="M">org.springframework.ws.samples.airline.security.StubFrequentFlyerSecurityService.java</file>
			<file type="M">org.springframework.ws.samples.airline.security.AcegiFrequentFlyerSecurityService.java</file>
			<file type="M">org.springframework.ws.samples.airline.dao.jpa.JpaFrequentFlyerDaoTest.java</file>
			<file type="M">org.springframework.ws.samples.airline.security.FrequentFlyerSecurityService.java</file>
			<file type="M">org.springframework.ws.samples.airline.dao.jpa.JpaFlightDao.java</file>
		</fixedFiles>
	</bug>
	<bug id="218" opendate="2007-10-28 13:02:47" fixdate="2007-10-29 00:42:23" resolution="Fixed">
		<buginformation>
			<summary>IllegalArgumentException "faultString cannot be empty"</summary>
			<description>If there is a runtime exception on the server-side that doesn&amp;amp;apos;t have a message (e.g. NullPointerException) the client side
gets an IllegalArgumentException "faultString cannot be empty". The exception seems to be coming from SaajSoap11Body.java, line 50. 
Could this be configured so the client always gets SOAP response even if the server had a runtime exception?
Also in the above scenario the server-side doesn&amp;amp;apos;t show the original runtime exception but instead hides it by showing the IllegalArgumentException only.
</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.endpoint.AbstractMarshallingPayloadEndpoint.java</file>
			<file type="M">org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolverTest.java</file>
			<file type="M">org.springframework.ws.soap.server.endpoint.AbstractSoapFaultDefinitionExceptionResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="219" opendate="2007-10-30 12:16:38" fixdate="2007-10-31 01:19:25" resolution="Fixed">
		<buginformation>
			<summary>Spring-ws reads the entier stream when logging set to debug</summary>
			<description>Spring-ws reads the entire message for logging purposes (when logging is set to DEBUG) and Axiom complains that it has nothing else to process:
DEBUG org.springframework.ws.soap.server.SoapMessageDispatcher - MessageDispatcher with name &amp;amp;apos;testing-ws&amp;amp;apos; received request [&amp;lt;?xml version='1.0' encoding='UTF-8'?&amp;gt;&amp;lt;soapenv:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;&amp;lt;soapenv:Body xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;&amp;lt;ns1:echoRequest xmlns:ns1="http://localhost:8080/testing-ws/services/echo"&amp;gt;Hello&amp;lt;/ns1:echoRequest&amp;gt;&amp;lt;/soapenv:Body&amp;gt;&amp;lt;/soapenv:Envelope&amp;gt;]
DEBUG org.springframework.ws.soap.server.SoapMessageDispatcher - Endpoint mapping [org.springframework.ws.soap.server.endpoint.mapping.SoapActionEndpointMapping@11415c8] maps request to endpoint [com.testing.system.infrastructure.ws.EchoEndpoint@1a220e6]
DEBUG org.springframework.ws.soap.server.SoapMessageDispatcher - Testing endpoint adapter [org.springframework.ws.server.endpoint.adapter.MessageEndpointAdapter@11df164]
DEBUG org.springframework.ws.soap.server.SoapMessageDispatcher - Testing endpoint adapter [org.springframework.ws.server.endpoint.adapter.PayloadEndpointAdapter@67c1a6]
DEBUG org.springframework.ws.soap.server.SoapMessageDispatcher - Testing endpoint exception resolver [org.springframework.ws.soap.server.endpoint.SimpleSoapExceptionResolver@6279d]
WARN  org.springframework.ws.soap.server.SoapMessageDispatcher - Endpoint invocation resulted in exception - responding with SOAP Fault
org.springframework.ws.soap.axiom.AxiomSoapBodyException: Could not access envelope: javax.xml.stream.XMLStreamException: ParseError at [row,col]:[1,322]
Message: already reached end document; nested exception is org.apache.axiom.om.OMException: javax.xml.stream.XMLStreamException: ParseError at [row,col]:[1,322]
Message: already reached end document
Caused by: 
org.apache.axiom.om.OMException: javax.xml.stream.XMLStreamException: ParseError at [row,col]:[1,322]
Message: already reached end document
	at org.apache.axiom.om.impl.builder.StAXOMBuilder.next(StAXOMBuilder.java:239)
	at org.apache.axiom.om.impl.llom.OMElementImpl.buildNext(OMElementImpl.java:552)
	at org.apache.axiom.om.impl.llom.OMElementImpl.getFirstOMChild(OMElementImpl.java:563)
	at org.apache.axiom.om.impl.llom.OMElementImpl.getFirstElement(OMElementImpl.java:823)
Setting the log level to INFO solves the problem but the info is quite hard to find and very unpleasant during development/debugging</description>
			<version>1.0.1</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessageFactory.java</file>
			<file type="M">org.springframework.ws.server.MessageDispatcher.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplate.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessage.java</file>
		</fixedFiles>
	</bug>
	<bug id="220" opendate="2007-10-30 14:06:34" fixdate="2007-11-05 08:59:29" resolution="Fixed">
		<buginformation>
			<summary>Jaxb2Marshaller::supports method does not consider multiple marshallers</summary>
			<description>When evaluating multiple MarshallingMethodEndpointAdapters, each with their own Jaxb2MarshallingEndpoint, the first MarshallingMethodEndpointAdapter::supports method is always true.
We are building a modular application; where each endpoint is packaged as it&amp;amp;apos;s own module.
Each of those endpoint modules has it&amp;amp;apos;s own MarshallingMethodEndpointAdapter and it&amp;amp;apos;s own Jaxb2Marshaller.
This means that when the webapp is packaged and running there will be multiple MarshallingMethodEndpointAdapters available to the MessageDispatcher.
The Jaxb2Marshaller::supports method is implemented to return true for any subclass of Jaxb2Element.






    public boolean supports(Class clazz) {




        if (JAXBElement.class.isAssignableFrom(clazz)) {




            return true;




        }




        ...




    }






The Jaxb2Marshaller should not even bother with this check, it should only return true if the JaxbContext is capable of supporting the given class.</description>
			<version>1.0</version>
			<fixedVersion>1.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.oxm.jaxb.Jaxb2Marshaller.java</file>
			<file type="M">org.springframework.oxm.jaxb.Jaxb2MarshallerTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.MethodEndpoint.java</file>
			<file type="M">org.springframework.ws.server.endpoint.adapter.MarshallingMethodEndpointAdapterTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.adapter.MarshallingMethodEndpointAdapter.java</file>
			<file type="M">org.springframework.ws.server.endpoint.adapter.PayloadMethodEndpointAdapterTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="226" opendate="2007-11-08 06:01:49" fixdate="2007-11-14 04:09:14" resolution="Fixed">
		<buginformation>
			<summary>Exception mapping corrupts the &amp;apos;defaultFault&amp;apos; instance</summary>
			<description>In AbstractSoapFaultDefinitionExceptionResolver (v. 1.0.1), have the following code fragment:
    protected final boolean resolveExceptionInternal(MessageContext messageContext, Object endpoint, Exception ex) {
        Assert.isTrue(messageContext.getResponse() instanceof SoapMessage,
                "AbstractSoapFaultDefinitionExceptionResolver requires a SoapMessage");
        SoapFaultDefinition definition = getFaultDefinition(endpoint, ex);
        if (definition == null) 
{
 1.           definition = defaultFault;
        }
        if (definition == null) 
{
            return false;
        }
        if (!StringUtils.hasLength(definition.getFaultStringOrReason())) 
{
2.            definition.setFaultStringOrReason(ex.getMessage());
        }
....
Problem is if (1.) and (2.) are hit on first exception handled by defaultFault, it is effectively calling &amp;amp;apos;defaultFault.setFaultOrReason(...)&amp;amp;apos;.  This in essence sets the defaultFault faultOrReason field (as defnition points to the defaultFault instance), making it non-null.  Problem is that subsequent exceptions that are assigned the defaultFault will now have an already populated faultOrReason code (from the first exception), and thus statement (2.) will never be invoked.  This results in all subsequent defaultFault exceptions having the exception message from the first defaultFault.
Categorizing this as Major as all reported exceptions that map to &amp;amp;apos;defaultFault&amp;amp;apos; will be incorrect, with exception of first mapped defaultFault exception.  Solution is trivial: use &amp;amp;apos;default fault factory&amp;amp;apos; to create new instance of defaultFault for every use, or reset the faultOrReason code to null after the message has been constructed.
====================================================================================
Below test fragments found the behavior (the second test fails, as the returned exception has the message from the first test.  Yet running the second test standalone works fine:
  /**

This will happen on badly formed payload (validation error)
   */
  public void testInvalidXmlCharacter() throws NoSuchAlgorithmException, IOException, ServletException, DocumentException 
{
    // &amp;amp;#1 is illegal xml character
    String payload = buildEchoPayload("foo"+ (char) 0x01);
    MockHttpServletResponse mockResp = invokeWebService(payload, "guitest", "bugBgone",
         HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
    Element resp = getSoapBodyPayload(mockResp);

    assertEquals("Invalid char preventing xml parsing",
        "\n" +
            "&amp;lt;SOAP-ENV:Fault xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"&amp;gt;\n" +
            "  &amp;lt;faultcode&amp;gt;SOAP-ENV:Server&amp;lt;/faultcode&amp;gt;\n" +
            "  &amp;lt;faultstring xml:lang=\"en\"&amp;gt;Could not access envelope: Unable to create envelope from given source: ; nested exception is com.sun.xml.messaging.saaj.SOAPExceptionImpl: Unable to create envelope from given source:&amp;lt;/faultstring&amp;gt;\n" +
            "&amp;lt;/SOAP-ENV:Fault&amp;gt;",
        XmlUtils.toString(resp));
  }

  public void testThrownAppException() throws NoSuchAlgorithmException, IOException, ServletException, DocumentException 
{
    String payload = buildEchoPayload(EchoController.THROW_NULL_POINTER_CMD);
    MockHttpServletResponse mockResp = invokeWebService(payload, "guitest", "bugBgone",
        HttpServletResponse.SC_INTERNAL_SERVER_ERROR);

    Element resp = getSoapBodyPayload(mockResp);
    assertEquals("\n" +
        "&amp;lt;SOAP-ENV:Fault xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\"&amp;gt;\n" +
        "  &amp;lt;faultcode&amp;gt;SOAP-ENV:Server&amp;lt;/faultcode&amp;gt;\n" +
        "  &amp;lt;faultstring xml:lang=\"en\"&amp;gt;Thrown on purpose for testing...&amp;lt;/faultstring&amp;gt;\n" +
        "&amp;lt;/SOAP-ENV:Fault&amp;gt;",
        XmlUtils.toString(resp));
  }
</description>
			<version>1.0.1</version>
			<fixedVersion>1.5 M1, 1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolverTest.java</file>
			<file type="M">org.springframework.ws.soap.server.endpoint.AbstractSoapFaultDefinitionExceptionResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="227" opendate="2007-11-09 00:31:33" fixdate="2007-11-14 04:23:53" resolution="Fixed">
		<buginformation>
			<summary>NPE when "mustUnderstand" attribute is in SOAP header and no Interceptors have been defined </summary>
			<description>When the "mustUnderstand" attribute is set (to either "0" or "1") and no interceptors are defined a "PayloadRootQNameEndpointMapping" the org.springframework.ws.soap.server.SoapMessageDispatcher throw a NullPointerException when iterating over the mapped endpoint s Interceptors. 
Adding a "org.springframework.ws.server.endpoint.interceptor.PayloadLoggingInterceptor" temporarily fixes the problem (as the code just gets "any" EndpointInterceptor before checking via "instanceof" on SoapEndpointInterceptor.class).
Our Server might receive a SOAP Message with the mustUnderstand attribute set (to either "0" or "1") or not, but does not need to handle the attribute.
A nullpointer check would be appropriate here.
thx in advance.</description>
			<version>1.0.1</version>
			<fixedVersion>1.5 M1, 1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.server.SoapMessageDispatcherTest.java</file>
			<file type="M">org.springframework.ws.soap.server.SoapMessageDispatcher.java</file>
		</fixedFiles>
	</bug>
	<bug id="238" opendate="2007-11-20 05:50:51" fixdate="2007-11-20 10:59:55" resolution="Fixed">
		<buginformation>
			<summary>AbstractMethodEndpointMapping does not support JDK Proxies</summary>
			<description>AbstractMethodEndpointMapping has a method, getEndpointClass, which attempts to determine the correct base class for an endpoint.  This method correctly deals with CGLIB-based proxies, but does not handle the more common JDK proxies.
One solution would be to use the AopUtils.getTargetClass method to perform this check.</description>
			<version>1.0.2</version>
			<fixedVersion>1.5 M1, 1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.endpoint.mapping.AbstractMethodEndpointMapping.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">262</link>
		</links>
	</bug>
	<bug id="229" opendate="2007-11-12 18:14:14" fixdate="2007-11-20 11:07:24" resolution="Fixed">
		<buginformation>
			<summary>JibxMarshaller should support marshalling/unmarshalling of all mapped classes</summary>
			<description>The current version of JiBX (1.1.5) supports marshalling and unmarshalling of all classes defined in binding definition file, for single IBindingFactory instance. The class that is passed in to BindingDirectory to get the factory instance is just used to locate the generated class that contains binding information - it is not the only class that this factory can marshall/unmarshall.
The solution: The supports() method of org.springframework.oxm.jibx.JibxMarshaller should be modified to return true for all mapped classes of IBindingFactory.</description>
			<version>1.0.2</version>
			<fixedVersion>1.5 M1, 1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.oxm.jibx.JibxMarshallerTest.java</file>
			<file type="M">org.springframework.oxm.jibx.JibxMarshaller.java</file>
		</fixedFiles>
	</bug>
	<bug id="230" opendate="2007-11-12 20:11:03" fixdate="2007-11-20 11:34:25" resolution="Fixed">
		<buginformation>
			<summary>AxiomSoapMessageFactory throws NPE</summary>
			<description>I used the following configuration for accessing a web service:
    &amp;lt;bean id="webServiceTemplate" class="org.springframework.ws.client.core.WebServi ceTemplate"&amp;gt;
        &amp;lt;property name="defaultUri" value="http://anyURL"/&amp;gt;
        &amp;lt;property name="marshaller" ref="castorMarshaller"/&amp;gt;
        &amp;lt;property name="unmarshaller" ref="castorMarshaller"/&amp;gt;
    &amp;lt;/bean&amp;gt;
Due to the fact that the access occurs inside a JBoss running on JDK 1.5 I run into the problem that SAAJ is not available in the JDK and the JBoss version of the SAAJ-library led to SAAJ-version problems.
So I switched to Axiom using the following:
    &amp;lt;bean id="axiom_MessageFactory" class="org.springframework.ws.soap.axiom.AxiomSoap MessageFactory"&amp;gt;
        &amp;lt;property name="payloadCaching" value="true"/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id="webServiceTemplate" class="org.springframework.ws.client.core.WebServi ceTemplate"&amp;gt;
        &amp;lt;constructor-arg ref="axiom_MessageFactory"/&amp;gt;
        &amp;lt;property name="defaultUri" value="http://anyURI"/&amp;gt;
        &amp;lt;property name="marshaller" ref="castorMarshaller"/&amp;gt;
        &amp;lt;property name="unmarshaller" ref="castorMarshaller"/&amp;gt;
    &amp;lt;/bean&amp;gt;
I have to access the web service three times. The first and second call were successful. The third failed with:
Exception in thread "main" java.lang.NullPointerException
    at org.springframework.xml.stream.AbstractStaxXmlRead er.parse(AbstractStaxXmlReader.java:70)
    at org.springframework.xml.stream.AbstractStaxXmlRead er.parse(AbstractStaxXmlReader.java:50)
    at org.springframework.oxm.castor.CastorMarshaller.un marshalSaxReader(CastorMarshaller.java:286)
    at org.springframework.oxm.castor.CastorMarshaller.un marshalXmlStreamReader(CastorMarshaller.java:297)
    at org.springframework.oxm.AbstractMarshaller.unmarsh alStaxSource(AbstractMarshaller.java:301)
    at org.springframework.oxm.AbstractMarshaller.unmarsh al(AbstractMarshaller.java:125)
    at org.springframework.ws.support.MarshallingUtils.un marshal(MarshallingUtils.java:65)
    at org.springframework.ws.client.core.WebServiceTempl ate$2.extractData(WebServiceTemplate.java:275)
    at org.springframework.ws.client.core.WebServiceTempl ate.sendAndReceive(WebServiceTemplate.java:416)
    at org.springframework.ws.client.core.WebServiceTempl ate.marshalSendAndReceive(WebServiceTemplate.java: 264)
    at org.springframework.ws.client.core.WebServiceTempl ate.marshalSendAndReceive(WebServiceTemplate.java: 252)
    at org.springframework.ws.client.core.WebServiceTempl ate.marshalSendAndReceive(WebServiceTemplate.java: 244)
The NullPointerException does not help very much. But i switched the payloadCaching property to:
    &amp;lt;property name="payloadCaching" value="false"/&amp;gt;
fixed it.</description>
			<version>1.0.2</version>
			<fixedVersion>1.5 M1, 1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.stream.AbstractStaxXmlReader.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">260</link>
			<link type="Related" description="is related to">239</link>
		</links>
	</bug>
	<bug id="241" opendate="2007-11-20 21:36:01" fixdate="2007-11-21 21:32:09" resolution="Fixed">
		<buginformation>
			<summary>NullPointerException during processing message with empty body</summary>
			<description>When I&amp;amp;apos;m sending message with empty body, i receive this exception:
java.lang.NullPointerException
	org.apache.xalan.transformer.TransformerIdentityImpl.transform(TransformerIdentityImpl.java:418)
	org.springframework.ws.server.endpoint.support.PayloadRootUtils.getPayloadRootQName(PayloadRootUtils.java:83)
	org.springframework.ws.server.endpoint.mapping.PayloadRootAnnotationMethodEndpointMapping.getLookupKeyForMessage(PayloadRootAnnotationMethodEndpointMapping.java:57)
	org.springframework.ws.server.endpoint.mapping.AbstractMethodEndpointMapping.getEndpointInternal(AbstractMethodEndpointMapping.java:54)
	org.springframework.ws.server.endpoint.mapping.AbstractEndpointMapping.getEndpoint(AbstractEndpointMapping.java:83)
	org.springframework.ws.server.MessageDispatcher.getEndpoint(MessageDispatcher.java:242)
	org.springframework.ws.server.MessageDispatcher.dispatch(MessageDispatcher.java:195)
	org.springframework.ws.server.MessageDispatcher.receive(MessageDispatcher.java:162)
	org.springframework.ws.transport.support.WebServiceMessageReceiverObjectSupport.handleConnection(WebServiceMessageReceiverObjectSupport.java:87)
	org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.handle(WebServiceMessageReceiverHandlerAdapter.java:57)
	org.springframework.ws.transport.http.MessageDispatcherServlet.doService(MessageDispatcherServlet.java:197)
	org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:476)
	org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:441)
	javax.servlet.http.HttpServlet.service(HttpServlet.java:710)
	javax.servlet.http.HttpServlet.service(HttpServlet.java:803)
	org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:63)
	org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:75)
	org.jboss.web.tomcat.filters.ReplyHeaderFilter.doFilter(ReplyHeaderFilter.java:96)
And message causing this:
&amp;lt;soapenv:Envelope
	xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
	xmlns:q0="http://nevermind"
	xmlns:xsd="http://www.w3.org/2001/XMLSchema"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&amp;gt;
	&amp;lt;soapenv:Header&amp;gt;
		&amp;lt;q0:sessionId&amp;gt;0PPAacL8UUACtCG7kdBp6MfNQ47FwUZd&amp;lt;/q0:sessionId&amp;gt;
	&amp;lt;/soapenv:Header&amp;gt;
	&amp;lt;soapenv:Body&amp;gt;&amp;lt;/soapenv:Body&amp;gt;
&amp;lt;/soapenv:Envelope&amp;gt;</description>
			<version>1.0.2</version>
			<fixedVersion>1.5 M1, 1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.endpoint.support.PayloadRootUtilsTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.support.PayloadRootUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="244" opendate="2007-12-03 04:31:12" fixdate="2007-12-05 23:09:52" resolution="Fixed">
		<buginformation>
			<summary>Soap headers with whitespace cause java.lang.ClassCastException: com.sun.xml.messaging.saaj.soap.impl.TextImpl</summary>
			<description>Soap headers that contain whitespace between xml elements result in ClassCastExceptions when using Sun&amp;amp;apos;s SAAJ 1.2 jar (I&amp;amp;apos;m using Sun&amp;amp;apos;s 1.1 soap message factory "com.sun.xml.messaging.saaj.soap.ver1_1.SOAPMessageFactory1_1Impl").  If you remove the whitespace between the xml elements on the Soap header on the request, the ClassCastException goes away.
The error is caused by the following code that assumes all nodes returned back are SOAPHeaderElement instances but the whitespace nodes are returned back as com.sun.xml.messaging.saaj.soap.impl.TextImpl instances.
org.springframework.ws.soap.saaj.SaajSoap11Header
    public Iterator examineHeaderElementsToProcess(String[] actors) {
        List result = new ArrayList();
        Iterator iterator = getImplementation().examineAllHeaderElements(getSaajHeader());
        while (iterator.hasNext()) {
            SOAPHeaderElement saajHeaderElement = (SOAPHeaderElement) iterator.next();   &amp;lt;- class cast happens here
Here&amp;amp;apos;s the stack trace:
java.lang.ClassCastException: com.sun.xml.messaging.saaj.soap.impl.TextImpl        
        at org.springframework.ws.soap.saaj.SaajSoap11Header.examineHeaderElementsToProcess(SaajSoap11Header.java:46)
        at org.springframework.ws.soap.server.SoapMessageDispatcher.handleHeaders(SoapMessageDispatcher.java:108)
        at org.springframework.ws.soap.server.SoapMessageDispatcher.handleRequest(SoapMessageDispatcher.java:92)
        at org.springframework.ws.server.MessageDispatcher.dispatch(MessageDispatcher.java:199)
        at org.springframework.ws.server.MessageDispatcher.receive(MessageDispatcher.java:162)
        at org.springframework.ws.transport.support.WebServiceMessageReceiverObjectSupport.handleConnection(WebServiceMessageReceiverObjectSupport.java:87)
        at org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.handle(WebServiceMessageReceiverHandlerAdapter.java:57)
        at org.springframework.ws.transport.http.MessageDispatcherServlet.doService(MessageDispatcherServlet.java:197)
        at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:476)
        at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:441)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:763)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:856)
        at weblogic.servlet.internal.StubSecurityHelper$ServletServiceAction.run(StubSecurityHelper.java:227)
        at weblogic.servlet.internal.StubSecurityHelper.invokeServlet(StubSecurityHelper.java:125)
        at weblogic.servlet.internal.ServletStubImpl.execute(ServletStubImpl.java:283)
        at weblogic.servlet.internal.ServletStubImpl.execute(ServletStubImpl.java:175)
        at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run(WebAppServletContext.java:3231)
        at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:321)
        at weblogic.security.service.SecurityManager.runAs(SecurityManager.java:121)
        at weblogic.servlet.internal.WebAppServletContext.securedExecute(WebAppServletContext.java:2002)
        at weblogic.servlet.internal.WebAppServletContext.execute(WebAppServletContext.java:1908)
        at weblogic.servlet.internal.ServletRequestImpl.run(ServletRequestImpl.java:1362)
        at weblogic.work.ExecuteThread.execute(ExecuteThread.java:209)
        at weblogic.work.ExecuteThread.run(ExecuteThread.java:181)</description>
			<version>1.0.2</version>
			<fixedVersion>1.5 M1, 1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoap11Header.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoap12Header.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">274</link>
		</links>
	</bug>
	<bug id="245" opendate="2007-12-03 07:17:27" fixdate="2007-12-06 06:15:24" resolution="Fixed">
		<buginformation>
			<summary>SAXParseException when using HttpURLConnection</summary>
			<description>When using the HttpUrlConnection in combination with the WebServiceTemplate, the following exception occurs:
org.xml.sax.SAXParseException: The root element is required in a well-formed document
This seems to occur in Java 1.4, using SAAJ 1.2. A detailed description of the issue is available at http://forum.springframework.org/showthread.php?t=40413&amp;amp;page=2
</description>
			<version>1.0.2</version>
			<fixedVersion>1.5 M1, 1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.CommonsHttpConnection.java</file>
			<file type="M">org.springframework.ws.transport.AbstractReceiverConnection.java</file>
			<file type="M">org.springframework.ws.transport.jms.JmsSenderConnection.java</file>
			<file type="M">org.springframework.ws.transport.tcp.TcpReceiverConnection.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpServletConnection.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplate.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpUrlConnection.java</file>
			<file type="M">org.springframework.ws.transport.mail.MailSenderConnection.java</file>
			<file type="M">org.springframework.ws.transport.mail.MailReceiverConnection.java</file>
			<file type="M">org.springframework.ws.transport.jms.JmsReceiverConnection.java</file>
			<file type="M">org.springframework.ws.transport.AbstractSenderConnection.java</file>
			<file type="M">org.springframework.ws.transport.tcp.TcpSenderConnection.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">280</link>
			<link type="Duplicate" description="is duplicated by">239</link>
		</links>
	</bug>
	<bug id="239" opendate="2007-11-20 11:28:19" fixdate="2007-12-06 06:17:58" resolution="Fixed">
		<buginformation>
			<summary>Marshalling with Castor and Axiom results in a XMLStreamException</summary>
			<description>Exception in thread "main" org.springframework.oxm.castor.CastorUnmarshalling FailureException: Castor unmarshalling exception: ParseError at [row,col]:[1,8192] 
Message: Unexpected end of stream; nested exception is javax.xml.stream.XMLStreamException: ParseError at [row,col]:[1,8192] 
Message: Unexpected end of stream 
Caused by: javax.xml.stream.XMLStreamException: ParseError at [row,col]:[1,8192] 
Message: Unexpected end of stream 
    at org.springframework.xml.stream.AbstractStaxXmlRead er.parse(AbstractStaxXmlReader.java:70) 
    at org.springframework.xml.stream.AbstractStaxXmlRead er.parse(AbstractStaxXmlReader.java:50) 
    at org.springframework.oxm.castor.CastorMarshaller.un marshalSaxReader(CastorMarshaller.java:286) 
    at org.springframework.oxm.castor.CastorMarshaller.un marshalXmlStreamReader(CastorMarshaller.java:297) 
    at org.springframework.oxm.AbstractMarshaller.unmarsh alStaxSource(AbstractMarshaller.java:301) 
    at org.springframework.oxm.AbstractMarshaller.unmarsh al(AbstractMarshaller.java:125) 
    at org.springframework.ws.support.MarshallingUtils.un marshal(MarshallingUtils.java:65) 
    at org.springframework.ws.client.core.WebServiceTempl ate$2.extractData(WebServiceTemplate.java:275) 
    at org.springframework.ws.client.core.WebServiceTempl ate.sendAndReceive(WebServiceTemplate.java:416) 
    at org.springframework.ws.client.core.WebServiceTempl ate.marshalSendAndReceive(WebServiceTemplate.java: 264) 
    at org.springframework.ws.client.core.WebServiceTempl ate.marshalSendAndReceive(WebServiceTemplate.java: 252) 
    at org.springframework.ws.client.core.WebServiceTempl ate.marshalSendAndReceive(WebServiceTemplate.java: 244) 
In my opinion this is the first bug. Also when payloadCaching is enabled, the same error message has to occur. 
To see where the stream ends I changed the code of org.springframework.ws.soap.axiom.AxiomSoapMessage : 
    public AxiomSoapMessage(SOAPMessage soapMessage, Attachments attachments, String soapAction, boolean payloadCaching) { 
        Assert.notNull(soapMessage, "&amp;amp;apos;soapMessage&amp;amp;apos; must not be null"); 
        Assert.notNull(attachments, "&amp;amp;apos;attachments&amp;amp;apos; must not be null"); 
        System.out.println(soapMessage.getOMDocumentElemen t().toString()); 
        ... 
And wow, it worked correctly. So I think there is a second bug. The SOAP message is not fully parsed. Possibly that is because of the size. The mssage has more than 1 MB, so maybe there is buffering problem or something 
</description>
			<version>1.0.2</version>
			<fixedVersion>1.5 M1, 1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.CommonsHttpConnection.java</file>
			<file type="M">org.springframework.ws.transport.AbstractReceiverConnection.java</file>
			<file type="M">org.springframework.ws.transport.jms.JmsSenderConnection.java</file>
			<file type="M">org.springframework.ws.transport.tcp.TcpReceiverConnection.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpServletConnection.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplate.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpUrlConnection.java</file>
			<file type="M">org.springframework.ws.transport.mail.MailSenderConnection.java</file>
			<file type="M">org.springframework.ws.transport.mail.MailReceiverConnection.java</file>
			<file type="M">org.springframework.ws.transport.jms.JmsReceiverConnection.java</file>
			<file type="M">org.springframework.ws.transport.AbstractSenderConnection.java</file>
			<file type="M">org.springframework.ws.transport.tcp.TcpSenderConnection.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">245</link>
			<link type="Related" description="is related to">230</link>
		</links>
	</bug>
	<bug id="247" opendate="2007-12-05 08:05:56" fixdate="2007-12-07 00:46:41" resolution="Fixed">
		<buginformation>
			<summary>Exception thrown when schemaPrefix is empty in XsdBasedSoap11Wsdl4jDefinitionBuilder</summary>
			<description>When the schemaPrefix is deliberately set to empty in the XsdBasedSoap11Wsdl4jDefinitionBuilder bean, the following exception is thrown:
org.springframework.ws.wsdl.WsdlDefinitionExceptio n: WSDLException: faultCode=PARSER_ERROR: Problem parsing &amp;amp;apos;- WSDL Document -&amp;amp;apos;.: org.xml.sax.SAXParseException: Element or attribute do not match QName production: QName::=(NCName&amp;amp;apos;:&amp;amp;apos;)?NCName.; nested excep
aused by:
avax.wsdl.WSDLException: WSDLException: faultCode=PARSER_ERROR: Problem parsing &amp;amp;apos;- WSDL Document -&amp;amp;apos;.: org.xml.sax.SAXParseException: Element or attribute do not match QName production: QName::=(NCName&amp;amp;apos;:&amp;amp;apos;)?NCName.
at com.ibm.wsdl.xml.WSDLWriterImpl.getDocument(Unknow n Source)
This did not occur in 1.0 and 1.0.1
Alan</description>
			<version>1.0.2</version>
			<fixedVersion>1.5 M1, 1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.wsdl.wsdl11.builder.XsdBasedSoap11Wsdl4jDefinitionBuilderTest.java</file>
			<file type="M">org.springframework.ws.wsdl.wsdl11.builder.XsdBasedSoap11Wsdl4jDefinitionBuilder.java</file>
			<file type="M">org.springframework.ws.wsdl.wsdl11.builder.XsdBasedSoap12Wsdl4jDefinitionBuilder.java</file>
			<file type="M">org.springframework.ws.wsdl.wsdl11.builder.XsdBasedSoap12Wsdl4jDefinitionBuilderTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="248" opendate="2007-12-07 02:04:08" fixdate="2007-12-07 02:26:03" resolution="Fixed">
		<buginformation>
			<summary>DomPoxMessage not clearing DOM on setting the result</summary>
			<description>I am using the POX method to implement a simple XML service. The problem I am having has to do with the XML transformations. The way the PayloadTransformingInterceptor is implemented, it sets the transformation result on the same Document object in DomPoxMessage as the source dom. This is ending up just appending the transformed XML to the original XML.
I wrote my own interceptor and it ended up being the same result. I also tried to add a new method setDocument(Document) to the DomPoxMessage class. I then stored the result of transformation in a new DomResult and then set the resulting dom on the DomPoxMessage. It works fine upto this point, but then somewhere during the internals of Spring-WS it ends up causing a problem and starts throwing null pointer exceptions.
This has been really frustrating and considering that there is barely any documentation on the POX in general, this is really turning out to be a loosing cause.
Reply With Quote
atifmk
  #2  
Old 12-03-2007, 04:56 PM
Arjen Poutsma Arjen Poutsma is offline
Senior Member
Spring Team
Join Date: Jul 2005
Location: Rotterdam, the Netherlands
Posts: 1,166
Default
I think this is something I can fix by simply emptying the document if setPayloadResult() is called (similar to SOAP). If you create a JIRA issue, I will look at it.
I will also try and add some POX documentation in 1.5, or maybe a sample.
__________________
Arjen Poutsma
Spring Web Services Dev Lead
Please read the FAQ</description>
			<version>1.0.2</version>
			<fixedVersion>1.5 M1, 1.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.pox.dom.DomPoxMessageTest.java</file>
			<file type="M">org.springframework.ws.pox.dom.DomPoxMessage.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">249</link>
			<link type="Related" description="is related to">412</link>
		</links>
	</bug>
	<bug id="257" opendate="2007-12-17 19:32:52" fixdate="2007-12-18 10:36:48" resolution="Fixed">
		<buginformation>
			<summary>Infinite loop in XsdBasedSoap11Wsdl4jDefinitionBuilder#buildMessages method</summary>
			<description>When creating a WSDL based on XSD, the method XsdBasedSoap11Wsdl4jDefinitionBuilder#buildMessages goes in infinite loop trying to generate a new prefix for each namespace found in the XSD. It uses a very ugly while(true)/break implementation, forgetting to increment the counter i, so if you have more than one namespace it never reaches the break statement and loop indefinitely.
Very nasty bug with obvious fix.</description>
			<version>1.0.2</version>
			<fixedVersion>1.0.3, 1.5 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.wsdl.wsdl11.builder.XsdBasedSoap11Wsdl4jDefinitionBuilder.java</file>
			<file type="M">org.springframework.ws.wsdl.wsdl11.builder.XsdBasedSoap12Wsdl4jDefinitionBuilder.java</file>
		</fixedFiles>
	</bug>
	<bug id="258" opendate="2007-12-18 05:53:18" fixdate="2008-01-23 00:55:18" resolution="Fixed">
		<buginformation>
			<summary>getting error when trying to use IBM MQ JMS implementation as transport.</summary>
			<description>I already have a working version of Spring 1.0 with JMS/MQ as transport. We extended 1.0 to add that support. Since 1.5 has built-in support, I am trying to use 1.5 M1. I am getting following error when I try to send a message. Including configuration file except and also exception trace.
This framework has been excellent help so far. It is well written. Thanks for developing this.
I will also be doing investigation regarding this issue.
Configuration :
    &amp;lt;bean id="jndiTemplate" class="org.springframework.jndi.JndiTemplate"&amp;gt;
        &amp;lt;property name="environment"&amp;gt;
            &amp;lt;props&amp;gt;
                &amp;lt;prop key="java.naming.factory.initial"&amp;gt;com.ibm.mq.jms.context.WMQInitialContextFactory&amp;lt;/prop&amp;gt;
                &amp;lt;prop key="java.naming.provider.url"&amp;gt;QM_wwhq458m&amp;lt;/prop&amp;gt;
            &amp;lt;/props&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- JMS Queue Connection Factory --&amp;gt;
    &amp;lt;bean id="internalJmsQueueConnectionFactory"
        class="org.springframework.jndi.JndiObjectFactoryBean"&amp;gt;
        &amp;lt;property name="jndiTemplate"&amp;gt;
            &amp;lt;ref bean="jndiTemplate"/&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property name="jndiName"&amp;gt;
            &amp;lt;value&amp;gt;QM_wwhq458m&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- Spring JMS Queue Connection Factory --&amp;gt;
    &amp;lt;bean id="jmsQueueConnectionFactory"
        class="org.springframework.jms.connection.SingleConnectionFactory102"&amp;gt;
        &amp;lt;property name="targetConnectionFactory"&amp;gt;
            &amp;lt;ref bean="internalJmsQueueConnectionFactory"/&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property name="pubSubDomain"&amp;gt;
            &amp;lt;value&amp;gt;false&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- JMS Destination Resolver --&amp;gt;
    &amp;lt;bean id="jmsDestinationResolver"
        class="org.springframework.jms.support.destination.JndiDestinationResolver"&amp;gt;
        &amp;lt;property name="jndiTemplate"&amp;gt;
            &amp;lt;ref bean="jndiTemplate"/&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property name="cache"&amp;gt;
            &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
 &amp;lt;bean id="JMSMQSender" class="org.springframework.ws.transport.jms.JmsMessageSender"&amp;gt;
		      &amp;lt;property name="connectionFactory" ref="jmsQueueConnectionFactory"/&amp;gt;
	 &amp;lt;/bean&amp;gt;
     &amp;lt;bean id="webServiceTemplate" class="org.springframework.ws.client.core.WebServiceTemplate"&amp;gt;
		&amp;lt;property name="messageSenders"&amp;gt;
			&amp;lt;list&amp;gt;
				&amp;lt;ref local="JMSMQSender" /&amp;gt;
				&amp;lt;ref local="HttpUrlConnectionMessageSender" /&amp;gt;
			&amp;lt;/list&amp;gt;
		&amp;lt;/property&amp;gt;
		&amp;lt;property name="defaultUri" value="jms:RequestQueue?deliveryMode=NON_PERSISTENT"/&amp;gt;
		&amp;lt;property name="marshaller"&amp;gt;
			&amp;lt;ref local="RequestPayloadMarshaller" /&amp;gt;
		&amp;lt;/property&amp;gt;
		&amp;lt;property name="unmarshaller"&amp;gt;
			&amp;lt;ref local="ResponsePayloadUnmarshaller" /&amp;gt;
		&amp;lt;/property&amp;gt;
     &amp;lt;/bean&amp;gt;
Exception Trace : 
Caused by: org.springframework.ws.client.WebServiceTransportException: Could not use transport: Could not set property: MQJMS1058: Invalid message property name: Content-Type; nested exception is org.springframework.ws.transport.jms.JmsTransportException: Could not set property: MQJMS1058: Invalid message property name: Content-Type
	at org.springframework.ws.client.core.WebServiceTemplate.sendAndReceive(WebServiceTemplate.java:430)
	at org.springframework.ws.client.core.WebServiceTemplate.doSendAndReceive(WebServiceTemplate.java:360)
	at org.springframework.ws.client.core.WebServiceTemplate.sendSourceAndReceiveToResult(WebServiceTemplate.java:306)
	at com.ual.caribou.transport.JMSTransportNew.invoke(JMSTransportNew.java:70)
	at com.ual.caribou.core.CaribouDispatchImpl.invoke(CaribouDispatchImpl.java:118)
	... 20 more
Caused by: org.springframework.ws.transport.jms.JmsTransportException: Could not set property: MQJMS1058: Invalid message property name: Content-Type
	at org.springframework.ws.transport.jms.JmsSenderConnection.addRequestHeader(JmsSenderConnection.java:152)
	at org.springframework.ws.transport.AbstractSenderConnection$RequestTransportOutputStream.addHeader(AbstractSenderConnection.java:108)
	at org.springframework.ws.soap.saaj.Saaj12Implementation.writeTo(Saaj12Implementation.java:247)
	at org.springframework.ws.soap.saaj.SaajSoapMessage.writeTo(SaajSoapMessage.java:118)
	at org.springframework.ws.transport.AbstractWebServiceConnection.send(AbstractWebServiceConnection.java:36)
	at org.springframework.ws.client.core.WebServiceTemplate.sendRequest(WebServiceTemplate.java:550)
	at org.springframework.ws.client.core.WebServiceTemplate.sendAndReceive(WebServiceTemplate.java:408)
	... 24 more
Caused by: javax.jms.MessageFormatException: MQJMS1058: Invalid message property name: Content-Type
	at com.ibm.jms.JMSMessage.newMessageFormatException(JMSMessage.java:4674)
	at com.ibm.jms.JMSMessage.setStringProperty(JMSMessage.java:5658)
	at org.springframework.ws.transport.jms.JmsSenderConnection.addRequestHeader(JmsSenderConnection.java:149)
	... 30 more</description>
			<version>1.5 M1</version>
			<fixedVersion>1.5 M2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.jms.JmsTransportConstants.java</file>
			<file type="M">org.springframework.ws.transport.jms.JmsSenderConnection.java</file>
			<file type="M">org.springframework.ws.transport.jms.JmsMessageSenderIntegrationTest.java</file>
			<file type="M">org.springframework.ws.transport.jms.JmsReceiverConnection.java</file>
			<file type="M">org.springframework.ws.transport.jms.support.JmsTransportUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="280" opendate="2008-02-04 23:04:06" fixdate="2008-02-05 21:30:26" resolution="Duplicate">
		<buginformation>
			<summary>SAXParseException WebServiceTemplate</summary>
			<description>Using the WebServiceTemplate with XML Beans marshaller gives me following error:
Exception in thread "main" org.springframework.ws.soap.saaj.SaajSoapEnvelopeException: Could not access envelope: org.xml.sax.SAXParseException: Premature end of file.; nested exception is javax.xml.soap.SOAPException: org.xml.sax.SAXParseException: Premature end of file.
Caused by: javax.xml.soap.SOAPException: org.xml.sax.SAXParseException: Premature end of file.
	at org.apache.axis.SOAPPart.getEnvelope(SOAPPart.java:1005)
	at org.springframework.ws.soap.saaj.Saaj12Implementation.getEnvelope(Saaj12Implementation.java:142)
	at org.springframework.ws.soap.saaj.SaajSoapMessage.getEnvelope(SaajSoapMessage.java:86)
	at org.springframework.ws.soap.AbstractSoapMessage.getSoapBody(AbstractSoapMessage.java:36)
	at org.springframework.ws.soap.AbstractSoapMessage.hasFault(AbstractSoapMessage.java:56)
	at org.springframework.ws.client.core.WebServiceTemplate.hasFault(WebServiceTemplate.java:509)
	at org.springframework.ws.client.core.WebServiceTemplate.sendAndReceive(WebServiceTemplate.java:411)
	at org.springframework.ws.client.core.WebServiceTemplate.marshalSendAndReceive(WebServiceTemplate.java:264)
	at org.springframework.ws.client.core.WebServiceTemplate.marshalSendAndReceive(WebServiceTemplate.java:252)
	at org.springframework.ws.client.core.WebServiceTemplate.marshalSendAndReceive(WebServiceTemplate.java:244)
	at be.vlaanderen.dho.client.WebserviceClient.&amp;lt;init&amp;gt;(WebserviceClient.java:76)
	at be.vlaanderen.dho.client.WebserviceClient.main(WebserviceClient.java:81)
Caused by: org.xml.sax.SAXParseException: Premature end of file.
	at org.apache.axis.AxisFault.makeFault(AxisFault.java:101)
	at org.apache.axis.SOAPPart.getAsSOAPEnvelope(SOAPPart.java:701)
	at org.apache.axis.SOAPPart.getEnvelope(SOAPPart.java:1003)
	... 11 more
Caused by: org.xml.sax.SAXParseException: Premature end of file.
	at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.createSAXParseException(ErrorHandlerWrapper.java:236)
	at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.fatalError(ErrorHandlerWrapper.java:215)
	at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:386)
	at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:316)
	at com.sun.org.apache.xerces.internal.impl.XMLVersionDetector.determineDocVersion(XMLVersionDetector.java:230)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:798)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:764)
	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:148)
	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1242)
	at javax.xml.parsers.SAXParser.parse(SAXParser.java:375)
	at org.apache.axis.encoding.DeserializationContext.parse(DeserializationContext.java:227)
	at org.apache.axis.SOAPPart.getAsSOAPEnvelope(SOAPPart.java:696)
	... 12 more
TCPMon log showing the request:
&amp;lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&amp;gt;
&amp;lt;soapenv:Body&amp;gt;
&amp;lt;ann:AnnuleerInschrijvingVoorOpleiding xmlns:ann="http://annuleerinschrijvingvooropleiding.inschrijvingdienst.dho.vlaanderen.be"&amp;gt;
&amp;lt;Verzoek&amp;gt;
&amp;lt;Context&amp;gt;
&amp;lt;Bericht&amp;gt;
&amp;lt;Tijdstip&amp;gt;
&amp;lt;Datum&amp;gt;12-12-2008&amp;lt;/Datum&amp;gt;
&amp;lt;Tijd&amp;gt;00:00:00.000&amp;lt;/Tijd&amp;gt;
&amp;lt;/Tijdstip&amp;gt;
&amp;lt;Afzender&amp;gt;
&amp;lt;Identificatie&amp;gt;34343&amp;lt;/Identificatie&amp;gt;
&amp;lt;Hoedanigheid&amp;gt;hoe&amp;lt;/Hoedanigheid&amp;gt;
&amp;lt;Naam&amp;gt;van de bos&amp;lt;/Naam&amp;gt;
&amp;lt;OrganisatieEenheid&amp;gt;ICT&amp;lt;/OrganisatieEenheid&amp;gt;
&amp;lt;Gebruiker&amp;gt;jos&amp;lt;/Gebruiker&amp;gt;
&amp;lt;Referte&amp;gt;0004444&amp;lt;/Referte&amp;gt;
&amp;lt;/Afzender&amp;gt;
&amp;lt;/Bericht&amp;gt;
&amp;lt;/Context&amp;gt;
&amp;lt;Vragen&amp;gt;
&amp;lt;Vraag&amp;gt;
&amp;lt;VraagInhoud&amp;gt;
&amp;lt;InschrijvingID&amp;gt;007&amp;lt;/InschrijvingID&amp;gt;
&amp;lt;/VraagInhoud&amp;gt;
&amp;lt;/Vraag&amp;gt;
&amp;lt;/Vragen&amp;gt;
&amp;lt;/Verzoek&amp;gt;
&amp;lt;/ann:AnnuleerInschrijvingVoorOpleiding&amp;gt;
&amp;lt;/soapenv:Body&amp;gt;
&amp;lt;/soapenv:Envelope&amp;gt;
</description>
			<version>1.0.2</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.CommonsHttpConnection.java</file>
			<file type="M">org.springframework.ws.transport.AbstractReceiverConnection.java</file>
			<file type="M">org.springframework.ws.transport.jms.JmsSenderConnection.java</file>
			<file type="M">org.springframework.ws.transport.tcp.TcpReceiverConnection.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpServletConnection.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplate.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpUrlConnection.java</file>
			<file type="M">org.springframework.ws.transport.mail.MailSenderConnection.java</file>
			<file type="M">org.springframework.ws.transport.mail.MailReceiverConnection.java</file>
			<file type="M">org.springframework.ws.transport.jms.JmsReceiverConnection.java</file>
			<file type="M">org.springframework.ws.transport.AbstractSenderConnection.java</file>
			<file type="M">org.springframework.ws.transport.tcp.TcpSenderConnection.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">245</link>
		</links>
	</bug>
	<bug id="275" opendate="2008-01-29 03:31:00" fixdate="2008-02-15 03:49:06" resolution="Fixed">
		<buginformation>
			<summary>NAMESPACE_ERR: An attempt is made to create or change an object in a way which is incorrect with regard to namespaces.</summary>
			<description>This error is the result of improper handing of namespaces and their prefixes.  Specifically, when using the default namespace attribute "xmlns".  For example:
&amp;lt;soap:Envelope&amp;gt;
&amp;lt;soap:Body&amp;gt;
&amp;lt;foo xmlns="bar" /&amp;gt;
&amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;
The full stack trace is as follows:
javax.xml.transform.TransformerException: org.w3c.dom.DOMException: NAMESPACE_ERR: An attempt is made to create or change an object in a way which is incorrect with regard to namespaces.
        at org.apache.xalan.transformer.TransformerIdentityImpl.transform(TransformerIdentityImpl.java:501)
        at org.springframework.ws.server.endpoint.support.PayloadRootUtils.getPayloadRootQName(PayloadRootUtils.java:87)
        at org.springframework.ws.server.endpoint.mapping.PayloadRootQNameEndpointMapping.resolveQName(PayloadRootQNameEndpointMapping.java:57)
        at org.springframework.ws.server.endpoint.mapping.AbstractQNameEndpointMapping.getLookupKeyForMessage(AbstractQNameEndpointMapping.java:33)
        at org.springframework.ws.server.endpoint.mapping.AbstractMapBasedEndpointMapping.getEndpointInternal(AbstractMapBasedEndpointMapping.java:106)
        at org.springframework.ws.server.endpoint.mapping.AbstractEndpointMapping.getEndpoint(AbstractEndpointMapping.java:83)
        at org.springframework.ws.server.MessageDispatcher.getEndpoint(MessageDispatcher.java:242)
        at org.springframework.ws.server.MessageDispatcher.dispatch(MessageDispatcher.java:195)
        at org.springframework.ws.server.MessageDispatcher.receive(MessageDispatcher.java:162)
        at org.springframework.ws.transport.support.WebServiceMessageReceiverObjectSupport.handleConnection(WebServiceMessageReceiverObjectSupport.java:87)
        at org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.handle(WebServiceMessageReceiverHandlerAdapter.java:57)
        at org.springframework.ws.transport.http.MessageDispatcherServlet.doService(MessageDispatcherServlet.java:197)
        at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:476)
        at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:441)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:760)
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:853)
        at weblogic.servlet.internal.ServletStubImpl$ServletInvocationAction.run(ServletStubImpl.java:1072)
        at weblogic.servlet.internal.ServletStubImpl.invokeServlet(ServletStubImpl.java:465)
        at weblogic.servlet.internal.ServletStubImpl.invokeServlet(ServletStubImpl.java:348)
        at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run(WebAppServletContext.java:6981)
        at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:321)
        at weblogic.security.service.SecurityManager.runAs(SecurityManager.java:121)
        at weblogic.servlet.internal.WebAppServletContext.invokeServlet(WebAppServletContext.java:3892)
        at weblogic.servlet.internal.ServletRequestImpl.execute(ServletRequestImpl.java:2766)
        at weblogic.kernel.ExecuteThread.execute(ExecuteThread.java:224)
        at weblogic.kernel.ExecuteThread.run(ExecuteThread.java:183)
Caused by: org.w3c.dom.DOMException: NAMESPACE_ERR: An attempt is made to create or change an object in a way which is incorrect with regard to namespaces.
        at org.apache.xml.utils.DOMBuilder.startElement(DOMBuilder.java:374)
        at org.apache.xalan.transformer.TransformerIdentityImpl.startElement(TransformerIdentityImpl.java:1072)
        at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleElement(SaajXmlReader.java:140)
        at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleNode(SaajXmlReader.java:123)
        at org.springframework.ws.soap.saaj.support.SaajXmlReader.parse(SaajXmlReader.java:115)
        at org.springframework.ws.soap.saaj.support.SaajXmlReader.parse(SaajXmlReader.java:96)
        at org.apache.xalan.transformer.TransformerIdentityImpl.transform(TransformerIdentityImpl.java:484)
        ... 25 more
Normally this error is associated with a buggy version of Xalan-J.  In this case, however, it appears to be an error in org.springframework.ws.soap.saaj.support.SaajXmlReader.
I have isolated the problem and will supply a patch.</description>
			<version>1.0.2</version>
			<fixedVersion>1.5 M2, 1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.saaj.support.SaajXmlReader.java</file>
		</fixedFiles>
	</bug>
	<bug id="264" opendate="2008-01-08 08:13:09" fixdate="2008-02-15 04:02:04" resolution="Fixed">
		<buginformation>
			<summary>XPathExpressionFactory should fallback to Jaxen if no JAXP 1.3 XPath implementation is available</summary>
			<description>When running with Java 5 without any JAXP 1.3 XPath implementation available but Jaxen present, XPathExpressionFactory fails to fallback to Jaxen.
The following patch fixes the problem :
 ../spring-ws-1.0.3/modules/xml/src/main/java/org/springframework/xml/xpath/XPathExpressionFactory.java	2007-12-21 16:26:18.000000000 +0100
+++ XPathExpressionFactory.java	2008-01-08 18:12:38.000000000 +0100
@@ -42,10 +42,14 @@
     private static final String JAXEN_CLASS_NAME = "org.jaxen.XPath";
+    private static boolean jaxpAvailable;
     private static boolean jaxenAvailable;
     static {
         // Check whether Jaxen is available
+        jaxpAvailable = (JaxpVersion.getJaxpVersion() &amp;gt;= JaxpVersion.JAXP_13);
+
+        // Check whether Jaxen is available
         try {
             ClassUtils.forName(JAXEN_CLASS_NAME);
             jaxenAvailable = true;
@@ -81,11 +85,27 @@
     public static XPathExpression createXPathExpression(String expression, Map namespaces)
             throws IllegalStateException, XPathParseException {
         Assert.hasLength(expression, "expression is empty");

if (JaxpVersion.getJaxpVersion() &amp;gt;= JaxpVersion.JAXP_13) {
logger.trace("Creating [javax.xml.xpath.XPathExpression]");
return Jaxp13XPathExpressionFactory.createXPathExpression(expression, namespaces);
+        if (jaxpAvailable) {
+            try 
{
+                logger.trace("Creating [javax.xml.xpath.XPathExpression]");
+                return Jaxp13XPathExpressionFactory.createXPathExpression(expression, namespaces);
+            }
+            catch (XPathException e) 
{
+                throw e;
+            }
+            catch (Throwable e) 
Unknown macro: {+                // 'Cause we may get an ExceptionInInitializerError from JAXP+                // XPathFactory+                jaxpAvailable = false;++                if (!jaxenAvailable) {
+                    throw new XPathParseException(
+                        "Could not compile [" + expression + "] to a XPathExpression: " + e.getMessage(), e);
+                }+                // Else} 
         }
else if (jaxenAvailable) {
+        if (jaxenAvailable) 
{
             logger.trace("Creating [org.jaxen.XPath]");
             return JaxenXPathExpressionFactory.createXPathExpression(expression, namespaces);
         }

</description>
			<version>1.0.3</version>
			<fixedVersion>1.5 M2, 1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.JaxpVersion.java</file>
			<file type="M">org.springframework.xml.xpath.XPathExpressionFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="266" opendate="2008-01-08 08:28:03" fixdate="2008-02-15 04:56:08" resolution="Fixed">
		<buginformation>
			<summary>AxiomContentHandler should empty the response body before adding the transformation result</summary>
			<description>AxiomContentHandler append the result of the XSLT transformation without first emptying the response body. The resulting SOAP response ends up with 2 body child elements : the original (untransformed) endpoint response and the transformation result.
The following patch fixes the problem :
 ../spring-ws-1.0.3/modules/core/src/main/java/org/springframework/ws/soap/axiom/AxiomContentHandler.java	2007-12-21 16:26:32.000000000 +0100
+++ AxiomContentHandler.java	2008-01-08 15:14:41.000000000 +0100
@@ -16,6 +16,7 @@
 package org.springframework.ws.soap.axiom;
+import org.apache.axiom.om.OMNode;
 import org.apache.axiom.om.OMElement;
 import org.apache.axiom.om.impl.builder.SAXOMBuilder;
 import org.springframework.util.Assert;
@@ -39,6 +40,15 @@
     public void endDocument() throws SAXException {
         super.endDocument();
+
+        // Remove original (i.e. source) response body.
+        OMNode child = null;
+        while ((child = parentElement.getFirstOMChild()) != null)
+        
{
+            child.detach();
+        }
+
+        // Set result (i.e. transformed) response body.
         parentElement.addChild(super.getRootElement());
     }
 }</description>
			<version>1.0.3</version>
			<fixedVersion>1.5 M2, 1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.support.AxiomUtils.java</file>
			<file type="M">org.springframework.ws.soap.AbstractSoapBodyTestCase.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapBody.java</file>
			<file type="M">org.springframework.ws.WebServiceMessage.java</file>
			<file type="M">org.springframework.ws.soap.SoapBody.java</file>
		</fixedFiles>
	</bug>
	<bug id="274" opendate="2008-01-28 03:00:07" fixdate="2008-02-15 04:59:11" resolution="Fixed">
		<buginformation>
			<summary>Soap headers with whitespace cause java.lang.ClassCastException: com.sun.xml.messaging.saaj.soap.impl.TextImpl - Part II</summary>
			<description>This bug is related to: http://jira.springframework.org/browse/SWS-244.  If white space appears in the header then a class cast exception is thrown.   Sun&amp;amp;apos;s SAAJ impl returns these whitespace nodes as TextImpl.  The class cast happens when the TextImpl&amp;amp;apos;s are cast as SOAPHeaderElement.  I&amp;amp;apos;ve verified that this is a problem with Spring WS 1.0.3 as well even though I&amp;amp;apos;m currently using 1.0.2.
org.springframework.ws.soap.saaj.SaajSoapHeader
        public Object next() 
{
            SOAPHeaderElement saajHeaderElement = (SOAPHeaderElement) iterator.next();   &amp;lt;-- class cast happens here.
            return new SaajSoapHeaderElement(saajHeaderElement);
        }</description>
			<version>1.0.2</version>
			<fixedVersion>1.5 M2, 1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoapHeader.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">244</link>
		</links>
	</bug>
	<bug id="285" opendate="2008-02-14 00:00:54" fixdate="2008-02-16 01:33:05" resolution="Fixed">
		<buginformation>
			<summary>Clear SecurityContext in Acegi Callbacks</summary>
			<description>We must make sure to clear the Acegi SecurityContext when the request has bee processed.</description>
			<version>1.0.3</version>
			<fixedVersion>1.5 RC1, 1.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.acegi.AcegiPlainTextPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.acegi.AcegiDigestPasswordValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jMessageInterceptorAcegiCallbackHandlerTestCase.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.acegi.AcegiPlainTextPasswordValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.acegi.AcegiDigestPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.acegi.AcegiDigestPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.jaas.CertificateLoginModule.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.acegi.AcegiCertificateValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.acegi.AcegiCertificateValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.XwsSecurityInterceptor.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.jaas.JaasCertificateValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.AbstractWsSecurityInterceptor.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.AbstractWsPasswordCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.acegi.AcegiPlainTextPasswordValidationCallbackHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="286" opendate="2008-02-16 03:40:20" fixdate="2008-02-16 03:57:26" resolution="Fixed">
		<buginformation>
			<summary>WSS4J AcegiDigestPasswordValidationCallbackHandler does not set Acegi SecurityContext</summary>
			<description>The AcegiDigestPasswordValidationCallbackHandler does not set any Authentication in the Acegi SecurityContext, which it should.</description>
			<version>1.5 M2</version>
			<fixedVersion>1.5 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.acegi.AcegiDigestPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.AbstractWsPasswordCallbackHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="260" opendate="2007-12-20 18:27:00" fixdate="2008-02-16 12:44:16" resolution="Duplicate">
		<buginformation>
			<summary>NPE when unmarshalling invalid request with Jaxb1Marshaller</summary>
			<description>When unmarshalling an invalid request a NullPointerException occurs in the AbstractStaxXmlReader.
The default exception resolver generates the following WARN debug log:
IWA-UM WARN  21-12-2007 09:19:00,009 [WebContainer : 0] (org.springframework.ws.soap.server.SoapMessageDispatcher) | Endpoint invocation resulted in exception - responding with SOAP Fault
java.lang.NullPointerException
	at org.springframework.xml.stream.AbstractStaxXmlReader.parse(AbstractStaxXmlReader.java:70)
	at org.springframework.xml.stream.AbstractStaxXmlReader.parse(AbstractStaxXmlReader.java:50)
	at org.apache.xerces.jaxp.validation.ValidatorHandlerImpl.validate(Unknown Source)
	at org.apache.xerces.jaxp.validation.ValidatorImpl.validate(Unknown Source)
	at javax.xml.validation.Validator.validate(Validator.java:141)
	at org.springframework.xml.validation.Jaxp13ValidatorFactory$Jaxp13Validator.validate(Jaxp13ValidatorFactory.java:61)
	at org.springframework.ws.server.endpoint.interceptor.AbstractValidatingInterceptor.handleRequest(AbstractValidatingInterceptor.java:143)
	at org.springframework.ws.server.MessageDispatcher.dispatch(MessageDispatcher.java:207)
	at org.springframework.ws.server.MessageDispatcher.receive(MessageDispatcher.java:162)
	at org.springframework.ws.transport.support.WebServiceMessageReceiverObjectSupport.handleConnection(WebServiceMessageReceiverObjectSupport.java:87)
	at org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.handle(WebServiceMessageReceiverHandlerAdapter.java:57)
	at org.springframework.ws.transport.http.MessageDispatcherServlet.doService(MessageDispatcherServlet.java:197)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:476)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:441)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:763)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:856)
	at com.ibm.ws.webcontainer.servlet.ServletWrapper.service(ServletWrapper.java:1572)
	at com.ibm.ws.webcontainer.servlet.ServletWrapper.service(ServletWrapper.java:1521)
	at com.ibm.ws.webcontainer.filter.WebAppFilterChain.doFilter(WebAppFilterChain.java:136)
	at nl.icscards.commons.monitoring.FlowTracerFilter.doFilter(FlowTracerFilter.java:69)
	at com.ibm.ws.webcontainer.filter.FilterInstanceWrapper.doFilter(FilterInstanceWrapper.java:142)
	at com.ibm.ws.webcontainer.filter.WebAppFilterChain.doFilter(WebAppFilterChain.java:121)
	at com.ibm.ws.webcontainer.filter.WebAppFilterChain._doFilter(WebAppFilterChain.java:82)
	at com.ibm.ws.webcontainer.servlet.ServletWrapper.handleRequest(ServletWrapper.java:759)
	at com.ibm.ws.webcontainer.webapp.WebApp.handleRequest(WebApp.java:3177)
	at com.ibm.ws.webcontainer.webapp.WebGroup.handleRequest(WebGroup.java:253)
	at com.ibm.ws.webcontainer.VirtualHost.handleRequest(VirtualHost.java:229)
	at com.ibm.ws.webcontainer.WebContainer.handleRequest(WebContainer.java:1970)
	at com.ibm.ws.webcontainer.channel.WCChannelLink.ready(WCChannelLink.java:114)
	at com.ibm.ws.http.channel.inbound.impl.HttpInboundLink.handleDiscrimination(HttpInboundLink.java:472)
	at com.ibm.ws.http.channel.inbound.impl.HttpInboundLink.handleNewInformation(HttpInboundLink.java:411)
	at com.ibm.ws.http.channel.inbound.impl.HttpInboundLink.ready(HttpInboundLink.java:288)
	at com.ibm.ws.tcp.channel.impl.NewConnectionInitialReadCallback.sendToDiscriminaters(NewConnectionInitialReadCallback.java:207)
	at com.ibm.ws.tcp.channel.impl.NewConnectionInitialReadCallback.complete(NewConnectionInitialReadCallback.java:109)
	at com.ibm.ws.tcp.channel.impl.WorkQueueManager.requestComplete(WorkQueueManager.java:566)
	at com.ibm.ws.tcp.channel.impl.WorkQueueManager.attemptIO(WorkQueueManager.java:619)
	at com.ibm.ws.tcp.channel.impl.WorkQueueManager.workerRun(WorkQueueManager.java:952)
	at com.ibm.ws.tcp.channel.impl.WorkQueueManager$Worker.run(WorkQueueManager.java:1039)
	at com.ibm.ws.util.ThreadPool$Worker.run(ThreadPool.java:1471)</description>
			<version>1.0.2</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.stream.AbstractStaxXmlReader.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">230</link>
		</links>
	</bug>
	<bug id="293" opendate="2008-02-21 02:37:24" fixdate="2008-02-26 22:15:27" resolution="Fixed">
		<buginformation>
			<summary>Response should be cleared in case of exception in WS-Security securement</summary>
			<description>If an exception occurs while securing an outgoing SOAP message with WS-Security the response is not cleared and an incomplete response is sent sent back to the initiator. The response should be cleared in this case.</description>
			<version>1.5 M2</version>
			<fixedVersion>1.5 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.AbstractWsSecurityInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="294" opendate="2008-02-25 01:09:41" fixdate="2008-02-26 22:25:25" resolution="Fixed">
		<buginformation>
			<summary>WSS4J interceptor shouldn&amp;apos;t verify that validationDecryptionCrypto != null</summary>
			<description>WSS4J interceptor verifies now that validationDecryptionCrypto != null when validationActions includes "Encrypt". However, validationDecryptionCrypto is not needed if only embeddable key name encryption style is used.
</description>
			<version>1.5 M2</version>
			<fixedVersion>1.5 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="295" opendate="2008-02-25 07:36:47" fixdate="2008-02-27 00:21:45" resolution="Fixed">
		<buginformation>
			<summary>WSS4J interceptor lacks a property to set WSHandlerConstants.ENC_KEY_NAME option</summary>
			<description>In order to support embedded key name encryption, we need to add a securementEncryptionEmbeddedKeyName property that sets WSHandlerConstants.ENC_KEY_NAME option in the handler. This is necessary to support embedded key name encryption in a declarative fashion. </description>
			<version>1.5 M2</version>
			<fixedVersion>1.5 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="307" opendate="2008-03-10 22:29:53" fixdate="2008-03-12 22:31:30" resolution="Fixed">
		<buginformation>
			<summary>org.springframework.ws.soap.security.wss4j.callback.KeyStoreCallbackHandler uses tiger specific classes</summary>
			<description>The code of KeyStoreCallbackHandler.handleKeyName is tiger specific because of the use of KeyStore.PasswordProtection, KeyStore.SecretKeyEntry and KeyStore.getEntry(String alias, KeyStore.ProtectionParameter protParam).  We should probably use KeyStore.getKey(String alias, char[] password) instead.</description>
			<version>1.5 RC1</version>
			<fixedVersion>1.5 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.KeyStoreCallbackHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="308" opendate="2008-03-10 22:58:24" fixdate="2008-03-17 23:35:51" resolution="Fixed">
		<buginformation>
			<summary>WebServiceTemplate skips handling fault in response with checkConnectionForFault="false" when HTTP status code is not 200 or 500</summary>
			<description>When checkConnectionForFault is set to "false" as stated in documentation  we should rely on the message only for determining if a response envelope is a Fault.
This actually works only if HTTP response code is 500 or 200, but as for a service I call the server send an HTTP 400 response code with a response containing a Fault (it&amp;amp;apos;s clearly not a WS-I Basic Profile compliant web service) the handleError is called instead of handleFault and I get a WebServiceTransportException instead of the Fault related exception.
This breaks WS-I Basic Profile conformance of Spring Web Services as it states:
"... the Profile requires that they examine the envelope. A Fault is an envelope that has a single child element of the soap:Body element, that element being a soap:Fault element.
R1107 A RECEIVER MUST interpret a SOAP message as a Fault when the soap:Body of the message has a single soap:Fault child."</description>
			<version>1.5 RC1</version>
			<fixedVersion>1.5 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplate.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplateIntegrationTest.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">330</link>
		</links>
	</bug>
	<bug id="333" opendate="2008-04-15 08:57:04" fixdate="2008-04-15 09:40:32" resolution="Fixed">
		<buginformation>
			<summary>Transport streams not closed in WebServiceConnection</summary>
			<description> Currently, in the AbstractWebServiceConnection and subclasses, the TransportOutputStream and TransportInputStream are not closed, mainly because Axis1 SAAJ and Axiom lazy-load messages. 
This is not a major issue for most transports, because the streams are closed in the end (during connection.close()), but closing the streams explicitly can&amp;amp;apos;t hurt. </description>
			<version>1.5</version>
			<fixedVersion>1.5.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.AbstractSenderConnection.java</file>
			<file type="M">org.springframework.ws.transport.http.CommonsHttpConnection.java</file>
			<file type="M">org.springframework.ws.transport.AbstractReceiverConnection.java</file>
			<file type="M">org.springframework.ws.transport.AbstractWebServiceConnection.java</file>
		</fixedFiles>
	</bug>
	<bug id="334" opendate="2008-04-15 09:00:00" fixdate="2008-04-15 09:45:27" resolution="Fixed">
		<buginformation>
			<summary>Calls to lifecycleMonitor.notifyAll() in AbstractStandaloneMessageReceiver are superfluous</summary>
			<description>Calls to lifecycleMonitor.notifyAll() in AbstractStandaloneMessageReceiver are superfluous because no threads call wait on that object.</description>
			<version>1.5</version>
			<fixedVersion>1.5.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.support.AbstractStandaloneMessageReceiver.java</file>
		</fixedFiles>
	</bug>
	<bug id="335" opendate="2008-04-17 06:58:45" fixdate="2008-04-27 01:08:45" resolution="Fixed">
		<buginformation>
			<summary> SaajXmlReader NullPointerException / jboss / mac in interceptors</summary>
			<description>run my app in the jboss environment (JBoss 4.2.2GA) I always fail with nullpointer exceptions in one of my payload interceptors (PayloadLoggingInterceptor, PayloadValidatingInterceptor).
When I have validation turned on, I fail in xerces, if it&amp;amp;apos;s off I fail the logger in xalan.
See stacktraces, failure in validator:
Code:
java.lang.NullPointerException
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleText(SaajXmlReader.java:187)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleNode(SaajXmlReader.java:127)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleElement(SaajXmlReader.java:150)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleNode(SaajXmlReader.java:123)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleElement(SaajXmlReader.java:150)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleNode(SaajXmlReader.java:123)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleElement(SaajXmlReader.java:150)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleNode(SaajXmlReader.java:123)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.parse(SaajXmlReader.java:115)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.parse(SaajXmlReader.java:96)
	at org.apache.xerces.jaxp.validation.ValidatorHandlerImpl.validate(Unknown Source)
	at org.apache.xerces.jaxp.validation.ValidatorImpl.validate(Unknown Source)
	at javax.xml.validation.Validator.validate(Unknown Source)
	at org.springframework.xml.validation.Jaxp13ValidatorFactory$Jaxp13Validator.validate(Jaxp13ValidatorFactory.java:61)
	at org.springframework.ws.server.endpoint.interceptor.AbstractValidatingInterceptor.handleResponse(AbstractValidatingInterceptor.java:185)
	at org.springframework.ws.server.MessageDispatcher.triggerHandleResponse(MessageDispatcher.java:341)
	at org.springframework.ws.server.MessageDispatcher.dispatch(MessageDispatcher.java:218)
	at org.springframework.ws.server.MessageDispatcher.receive(MessageDispatcher.java:162)
	at org.springframework.ws.transport.support.WebServiceMessageReceiverObjectSupport.handleConnection(WebServiceMessageReceiverObjectSupport.java:87)
	at org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.handle(WebServiceMessageReceiverHandlerAdapter.java:57)
	at org.springframework.ws.transport.http.MessageDispatcherServlet.doService(MessageDispatcherServlet.java:197)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:476)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:441)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:710)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:803)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.jboss.web.tomcat.filters.ReplyHeaderFilter.doFilter(ReplyHeaderFilter.java:96)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:230)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:175)
	at org.jboss.web.tomcat.security.SecurityAssociationValve.invoke(SecurityAssociationValve.java:179)
	at org.jboss.web.tomcat.security.JaccContextValve.invoke(JaccContextValve.java:84)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:127)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:102)
	at org.jboss.web.tomcat.service.jca.CachedConnectionValve.invoke(CachedConnectionValve.java:157)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:109)
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:262)
	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:844)
	at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.process(Http11Protocol.java:583)
	at org.apache.tomcat.util.net.JIoEndpoint$Worker.run(JIoEndpoint.java:446)
failure in logger:
Code:
14:57:46,159 INFO  [STDOUT] 2008-04-07 14:57:46,158 WARN [org.springframework.ws.soap.server.SoapMessageDispatcher] - Endpoint invocation resulted in exception - responding with SOAP Fault
java.lang.NullPointerException
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleText(SaajXmlReader.java:187)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleNode(SaajXmlReader.java:127)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleElement(SaajXmlReader.java:150)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleNode(SaajXmlReader.java:123)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleElement(SaajXmlReader.java:150)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleNode(SaajXmlReader.java:123)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleElement(SaajXmlReader.java:150)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.handleNode(SaajXmlReader.java:123)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.parse(SaajXmlReader.java:115)
	at org.springframework.ws.soap.saaj.support.SaajXmlReader.parse(SaajXmlReader.java:96)
	at org.apache.xalan.transformer.TransformerIdentityImpl.transform(TransformerIdentityImpl.java:485)
	at org.springframework.ws.server.endpoint.1.logMessageSource(AbstractLoggingInterceptor.java:102)
	at org.springframework.ws.server.endpoint.AbstractLoggingInterceptor.handleResponse(AbstractLoggingInterceptor.java:81)
	at org.springframework.ws.server.MessageDispatcher.triggerHandleResponse(MessageDispatcher.java:341)
	at org.springframework.ws.server.MessageDispatcher.dispatch(MessageDispatcher.java:218)
	at org.springframework.ws.server.MessageDispatcher.receive(MessageDispatcher.java:162)
	at org.springframework.ws.transport.support.WebServiceMessageReceiverObjectSupport.handleConnection(WebServiceMessageReceiverObjectSupport.java:87)
	at org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.handle(WebServiceMessageReceiverHandlerAdapter.java:57)
	at org.springframework.ws.transport.http.MessageDispatcherServlet.doService(MessageDispatcherServlet.java:197)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:476)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:441)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:710)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:803)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:290)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.jboss.web.tomcat.filters.ReplyHeaderFilter.doFilter(ReplyHeaderFilter.java:96)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:235)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:230)
	at ... snip
my bean looks like this,
Code:
     &amp;lt;bean class="org.springframework.ws.server.endpoint.mapping.PayloadRootAnnotationMethodEndpointMapping"&amp;gt;
        &amp;lt;property name="interceptors"&amp;gt;
            &amp;lt;list&amp;gt;
                &amp;lt;bean class="org.springframework.ws.server.endpoint.interceptor.PayloadLoggingInterceptor"/&amp;gt;
                &amp;lt;bean class="org.springframework.ws.soap.server.endpoint.interceptor.PayloadValidatingInterceptor"&amp;gt;
                    &amp;lt;property name="schema" value="/WEB-INF/xsd/codexws.xsd"/&amp;gt;
                    &amp;lt;property name="validateRequest" value="true"/&amp;gt;
                    &amp;lt;property name="validateResponse" value="true"/&amp;gt;
                &amp;lt;/bean&amp;gt;
            &amp;lt;/list&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property name="order" value="1"/&amp;gt;
    &amp;lt;/bean&amp;gt;
I have explicitly defined the message factory:
Code:
    &amp;lt;bean id="messageFactory"
    	class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory"&amp;gt;
    	&amp;lt;description&amp;gt;
				define default message factory to avoid problems with JBoss&amp;amp;apos; 
				built in factory. See http://static.springframework.org/spring-ws/site/faq.html#saaj-jboss
        &amp;lt;/description&amp;gt;
    	&amp;lt;property name="messageFactory"&amp;gt;
    		&amp;lt;bean
    			class="com.sun.xml.messaging.saaj.soap.ver1_1.SOAPMessageFactory1_1Impl"&amp;gt;
    		&amp;lt;/bean&amp;gt;
    	&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
</description>
			<version>1.5</version>
			<fixedVersion>1.5.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.saaj.support.SaajContentHandler.java</file>
			<file type="M">org.springframework.ws.soap.saaj.support.SaajXmlReader.java</file>
		</fixedFiles>
	</bug>
	<bug id="342" opendate="2008-04-26 03:24:02" fixdate="2008-04-27 01:12:17" resolution="Fixed">
		<buginformation>
			<summary>NPE in AbstractAnnotationMethodEndpointMapping  on line 47 during postProcessAfterInitialization</summary>
			<description>The stack trace is as follows:
org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;personMaintenanceSpringWebServiceEndpoint&amp;amp;apos; defined in class path resource [tanzan-web-context.xml]: Cannot resolve reference to bean &amp;amp;apos;personMaintenanceService&amp;amp;apos; while setting bean property &amp;amp;apos;personMaintenanceService&amp;amp;apos;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;personMaintenanceService&amp;amp;apos;: Post-processing of the FactoryBean&amp;amp;apos;s object failed; nested exception is java.lang.NullPointerException
	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:275)
	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:104)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1244)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1008)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:470)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$1.run(AbstractAutowireCapableBeanFactory.java:409)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:380)
	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:264)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:217)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:261)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:254)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:429)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:729)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:381)
	at org.springframework.web.context.ContextLoader.createWebApplicationContext(ContextLoader.java:255)
	at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:199)
	at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:45)
	at weblogic.servlet.internal.EventsManager$FireContextListenerAction.run(EventsManager.java:376)
	at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:321)
	at weblogic.security.service.SecurityManager.runAs(SecurityManager.java:121)
	at weblogic.servlet.internal.EventsManager.notifyContextCreatedEvent(EventsManager.java:82)
	at weblogic.servlet.internal.WebAppServletContext.preloadResources(WebAppServletContext.java:1616)
	at weblogic.servlet.internal.WebAppServletContext.start(WebAppServletContext.java:2761)
	at weblogic.servlet.internal.WebAppModule.startContexts(WebAppModule.java:889)
	at weblogic.servlet.internal.WebAppModule.start(WebAppModule.java:333)
	at weblogic.application.internal.flow.ModuleStateDriver$3.next(ModuleStateDriver.java:204)
	at weblogic.application.utils.StateMachineDriver.nextState(StateMachineDriver.java:26)
	at weblogic.application.internal.flow.ModuleStateDriver.start(ModuleStateDriver.java:60)
	at weblogic.application.internal.flow.ScopedModuleDriver.start(ScopedModuleDriver.java:200)
	at weblogic.application.internal.flow.ModuleListenerInvoker.start(ModuleListenerInvoker.java:117)
	at weblogic.application.internal.flow.ModuleStateDriver$3.next(ModuleStateDriver.java:204)
	at weblogic.application.utils.StateMachineDriver.nextState(StateMachineDriver.java:26)
	at weblogic.application.internal.flow.ModuleStateDriver.start(ModuleStateDriver.java:60)
	at weblogic.application.internal.flow.StartModulesFlow.activate(StartModulesFlow.java:26)
	at weblogic.application.internal.BaseDeployment$2.next(BaseDeployment.java:635)
	at weblogic.application.utils.StateMachineDriver.nextState(StateMachineDriver.java:26)
	at weblogic.application.internal.BaseDeployment.activate(BaseDeployment.java:212)
	at weblogic.application.internal.DeploymentStateChecker.activate(DeploymentStateChecker.java:154)
	at weblogic.deploy.internal.targetserver.AppContainerInvoker.activate(AppContainerInvoker.java:80)
	at weblogic.deploy.internal.targetserver.BasicDeployment.activate(BasicDeployment.java:181)
	at weblogic.deploy.internal.targetserver.BasicDeployment.activateFromServerLifecycle(BasicDeployment.java:358)
	at weblogic.management.deploy.internal.DeploymentAdapter$1.doActivate(DeploymentAdapter.java:52)
	at weblogic.management.deploy.internal.DeploymentAdapter.activate(DeploymentAdapter.java:186)
	at weblogic.management.deploy.internal.AppTransition$2.transitionApp(AppTransition.java:30)
	at weblogic.management.deploy.internal.ConfiguredDeployments.transitionApps(ConfiguredDeployments.java:233)
	at weblogic.management.deploy.internal.ConfiguredDeployments.activate(ConfiguredDeployments.java:169)
	at weblogic.management.deploy.internal.ConfiguredDeployments.deploy(ConfiguredDeployments.java:123)
	at weblogic.management.deploy.internal.DeploymentServerService.resume(DeploymentServerService.java:173)
	at weblogic.management.deploy.internal.DeploymentServerService.start(DeploymentServerService.java:89)
	at weblogic.t3.srvr.SubsystemRequest.run(SubsystemRequest.java:64)
	at weblogic.work.ExecuteThread.execute(ExecuteThread.java:209)
	at weblogic.work.ExecuteThread.run(ExecuteThread.java:181)
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;personMaintenanceService&amp;amp;apos;: Post-processing of the FactoryBean&amp;amp;apos;s object failed; nested exception is java.lang.NullPointerException
	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport$1.run(FactoryBeanRegistrySupport.java:142)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:116)
	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.getObjectFromFactoryBean(FactoryBeanRegistrySupport.java:91)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getObjectForBeanInstance(AbstractBeanFactory.java:1285)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:275)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164)
	at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:269)
	... 56 more
Caused by: java.lang.NullPointerException
	at org.springframework.ws.server.endpoint.mapping.AbstractAnnotationMethodEndpointMapping.postProcessAfterInitialization(AbstractAnnotationMethodEndpointMapping.java:47)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:361)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.postProcessObjectFromFactoryBean(AbstractAutowireCapableBeanFactory.java:1427)
	at org.springframework.beans.factory.support.FactoryBeanRegistrySupport$1.run(FactoryBeanRegistrySupport.java:139)
	... 64 more
The problem occurs when AbstractAnnotationMethodEndpointMapping#postProcessAfterInitialization calls getEndpointClass(bean) which in turn calls AopUtils.getTargetClass(endpoint).
&amp;amp;apos;bean&amp;amp;apos; in getEndpointClass(bean) is actually a local-slsb as shown by its config here:
    &amp;lt;jee:local-slsb id="personMaintenanceService"
                    business-interface="uk.co.serin.tanzan.personmaintenance.facade.PersonMaintenanceService"
                    jndi-name="ejb/uk.co.serin.tanzan.personmaintenance.facade.PersonMaintenanceLocal"
                    resource-ref="true"/&amp;gt;
I can see that SWS-222 was raised to address proxies but it does not appear to work with EJBs.
Unfortunatly I cannot easily override the AbstractAnnotationMethodEndpointMapping#postProcessAfterInitialization method because it is final otherwise I could create a quick work around.
Hopefully the above will assist with diagnosis but if any further information would be of assistance just let me know.
</description>
			<version>1.5</version>
			<fixedVersion>1.5.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.endpoint.mapping.AbstractAnnotationMethodEndpointMapping.java</file>
		</fixedFiles>
	</bug>
	<bug id="330" opendate="2008-04-14 04:45:37" fixdate="2008-04-29 22:37:53" resolution="Fixed">
		<buginformation>
			<summary>WebServiceTemplate hasFaut skips check for fault in response if the connection implements FaultAwareWebServiceConnection</summary>
			<description>Hello,
I use WebserviceTemplate configured 
	&amp;lt;bean id="webServiceTemplate" class="org.springframework.ws.client.core.WebServiceTemplate"&amp;gt;
        &amp;lt;constructor-arg ref="messageFactory"/&amp;gt;
        &amp;lt;property name="checkConnectionForFault" value="true"&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;.
As you can see, my server returns an error 500, but due to the code of hasError:
return !(faultConnection.hasFault() &amp;amp;&amp;amp; request instanceof FaultAwareWebServiceMessage);
hasError returns false.
this code seems strange to me, if a 500 is returned the response might not be XML so unmarshalling will fail and it does:
org.springframework.ws.soap.axiom.AxiomSoapMessageCreationException: Unknown content type &amp;amp;apos;text/html;charset=ISO-8859-1&amp;amp;apos;
	at org.springframework.ws.soap.axiom.AxiomSoapMessageFactory.getSoapEnvelopeNamespace(AxiomSoapMessageFactory.java:262)
	at org.springframework.ws.soap.axiom.AxiomSoapMessageFactory.createAxiomSoapMessage(AxiomSoapMessageFactory.java:224)
	at org.springframework.ws.soap.axiom.AxiomSoapMessageFactory.createWebServiceMessage(AxiomSoapMessageFactory.java:196)
	at org.springframework.ws.transport.AbstractWebServiceConnection.receive(AbstractWebServiceConnection.java:53)
	at org.springframework.ws.client.core.WebServiceTemplate.doSendAndReceive(WebServiceTemplate.java:491)
	at org.springframework.ws.client.core.WebServiceTemplate.sendAndReceive(WebServiceTemplate.java:440)
	at org.springframework.ws.client.core.WebServiceTemplate.doSendAndReceive(WebServiceTemplate.java:395)
	at org.springframework.ws.client.core.WebServiceTemplate.sendSourceAndReceiveToResult(WebServiceTemplate.java:341)
	at org.springframework.ws.client.core.WebServiceTemplate.sendSourceAndReceiveToResult(WebServiceTemplate.java:326)
	at com.kingfisher.product.wsclient.TestSpringWSClient.main(TestSpringWSClient.java:100)
Related to http://jira.springframework.org/browse/SWS-137.
Request:
POST /TutorialWS/services/LocalProduct HTTP/1.1
Accept-Encoding: gzip
Content-Type: text/xml; charset="UTF-8"
SOAPAction: ""
Cache-Control: no-cache
Pragma: no-cache
User-Agent: Java/1.4.2_12
Host: 127.0.0.1:9090
Accept: text/html, image/gif, image/jpeg, ; q=.2, */; q=.2
Connection: keep-alive
Content-Length: 486
&amp;lt;?xml version=&amp;amp;apos;1.0&amp;amp;apos; encoding=&amp;amp;apos;UTF-8&amp;amp;apos;?&amp;gt;&amp;lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;&amp;lt;soapenv:Body&amp;gt;&amp;lt;v1:getLocatedProducts xmlns:v1="http://v1.product.ws.store.kingfisher.com" xmlns:xsd="http://data.v1.product.ws.store.kingfisher.com/xsd"&amp;gt;&amp;lt;v1:param0&amp;gt;&amp;lt;xsd:callType&amp;gt;1&amp;lt;/xsd:callType&amp;gt;&amp;lt;xsd:familyCode&amp;gt;1&amp;lt;/xsd:familyCode&amp;gt;&amp;lt;xsd:moduleCode&amp;gt;1&amp;lt;/xsd:moduleCode&amp;gt;&amp;lt;xsd:subFamilyCode&amp;gt;1&amp;lt;/xsd:subFamilyCode&amp;gt;&amp;lt;/v1:param0&amp;gt;&amp;lt;/v1:getLocatedProducts&amp;gt;&amp;lt;/soapenv:Body&amp;gt;&amp;lt;/soapenv:Envelope&amp;gt;
Response:
HTTP/1.1 500 Erreur Interne de Servlet
Server: Apache-Coyote/1.1
Content-Type: text/html;charset=ISO-8859-1
Content-Language: fr-FR
Transfer-Encoding: chunked
Date: Mon, 14 Apr 2008 17:06:47 GMT
Connection: close
&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Apache Tomcat/4.1.36-LE-jdk14 - Rapport d&amp;amp;apos;erreur&amp;lt;/title&amp;gt;&amp;lt;STYLE&amp;gt;&amp;lt;!--H1
{font-family : sans-serif,Arial,Tahoma;color : white;background-color : #0086b2;}
 H3
{font-family : sans-serif,Arial,Tahoma;color : white;background-color : #0086b2;}
 BODY
{font-family : sans-serif,Arial,Tahoma;color : black;background-color : white;}
 B
{color : white;background-color : #0086b2;}
 HR
{color : #0086b2;}
 --&amp;gt;&amp;lt;/STYLE&amp;gt; &amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Etat HTTP 500 - &amp;lt;/h1&amp;gt;&amp;lt;HR size="1" noshade="noshade"&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;type&amp;lt;/b&amp;gt; Rapport d&amp;amp;apos;exception&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;message&amp;lt;/b&amp;gt; &amp;lt;u&amp;gt;&amp;lt;/u&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;description&amp;lt;/b&amp;gt; &amp;lt;u&amp;gt;Le serveur a rencontr une erreur interne () qui l&amp;amp;apos;a empch de satisfaire la requte.&amp;lt;/u&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;exception&amp;lt;/b&amp;gt; &amp;lt;pre&amp;gt;org.springframework.web.util.NestedServletException: Request processing failed; nested exception is java.lang.NoClassDefFoundError: Test
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:535)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:463)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:717)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:810)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:199)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:145)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:210)
	at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:596)
	at org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:433)
	at org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:955)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:139)
	at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:596)
	at org.apache.catalina.valves.CertificatesValve.invoke(CertificatesValve.java:198)
	at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:594)
	at org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:433)
	at org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:955)
	at org.apache.catalina.core.StandardContext.invoke(StandardContext.java:2460)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:133)
	at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:596)
	at org.apache.catalina.valves.ErrorDispatcherValve.invoke(ErrorDispatcherValve.java:119)
	at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:594)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:117)
	at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:594)
	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:545)
	at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:594)
	at org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:433)
	at org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:955)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:127)
	at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:596)
	at org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:433)
	at org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:955)
	at org.apache.coyote.tomcat4.CoyoteAdapter.service(CoyoteAdapter.java:157)
	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:874)
	at org.apache.coyote.http11.Http11BaseProtocol$Http11ConnectionHandler.processConnection(Http11BaseProtocol.java:665)
	at org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:528)
	at org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt(LeaderFollowerWorkerThread.java:81)
	at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:685)
	at java.lang.Thread.run(Thread.java:534)
Caused by: java.lang.NoClassDefFoundError: Test
	at com.kingfisher.product.ws.ProductWsMarshallingEndpoint.invokeInternal(ProductWsMarshallingEndpoint.java:58)
	at org.springframework.ws.server.endpoint.AbstractMarshallingPayloadEndpoint.invoke(AbstractMarshallingPayloadEndpoint.java:131)
	at org.springframework.ws.server.endpoint.adapter.MessageEndpointAdapter.invoke(MessageEndpointAdapter.java:41)
	at org.springframework.ws.server.MessageDispatcher.dispatch(MessageDispatcher.java:216)
	at org.springframework.ws.server.MessageDispatcher.receive(MessageDispatcher.java:163)
	at org.springframework.ws.transport.support.WebServiceMessageReceiverObjectSupport.handleConnection(WebServiceMessageReceiverObjectSupport.java:88)
	at org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.handle(WebServiceMessageReceiverHandlerAdapter.java:57)
	at org.springframework.ws.transport.http.MessageDispatcherServlet.doService(MessageDispatcherServlet.java:197)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:523)
	... 37 more
&amp;lt;/pre&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;cause mre&amp;lt;/b&amp;gt; &amp;lt;pre&amp;gt;java.lang.NoClassDefFoundError: Test
	at com.kingfisher.product.ws.ProductWsMarshallingEndpoint.invokeInternal(ProductWsMarshallingEndpoint.java:58)
	at org.springframework.ws.server.endpoint.AbstractMarshallingPayloadEndpoint.invoke(AbstractMarshallingPayloadEndpoint.java:131)
	at org.springframework.ws.server.endpoint.adapter.MessageEndpointAdapter.invoke(MessageEndpointAdapter.java:41)
	at org.springframework.ws.server.MessageDispatcher.dispatch(MessageDispatcher.java:216)
	at org.springframework.ws.server.MessageDispatcher.receive(MessageDispatcher.java:163)
	at org.springframework.ws.transport.support.WebServiceMessageReceiverObjectSupport.handleConnection(WebServiceMessageReceiverObjectSupport.java:88)
	at org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.handle(WebServiceMessageReceiverHandlerAdapter.java:57)
	at org.springframework.ws.transport.http.MessageDispatcherServlet.doService(MessageDispatcherServlet.java:197)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:523)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:463)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:717)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:810)
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:199)
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:145)
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:210)
	at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:596)
	at org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:433)
	at org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:955)
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:139)
	at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:596)
	at org.apache.catalina.valves.CertificatesValve.invoke(CertificatesValve.java:198)
	at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:594)
	at org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:433)
	at org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:955)
	at org.apache.catalina.core.StandardContext.invoke(StandardContext.java:2460)
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:133)
	at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:596)
	at org.apache.catalina.valves.ErrorDispatcherValve.invoke(ErrorDispatcherValve.java:119)
	at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:594)
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:117)
	at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:594)
	at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:545)
	at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:594)
	at org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:433)
	at org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:955)
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:127)
	at org.apache.catalina.core.StandardPipeline$StandardPipelineValveContext.invokeNext(StandardPipeline.java:596)
	at org.apache.catalina.core.StandardPipeline.invoke(StandardPipeline.java:433)
	at org.apache.catalina.core.ContainerBase.invoke(ContainerBase.java:955)
	at org.apache.coyote.tomcat4.CoyoteAdapter.service(CoyoteAdapter.java:157)
	at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:874)
	at org.apache.coyote.http11.Http11BaseProtocol$Http11ConnectionHandler.processConnection(Http11BaseProtocol.java:665)
	at org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:528)
	at org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt(LeaderFollowerWorkerThread.java:81)
	at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:685)
	at java.lang.Thread.run(Thread.java:534)
&amp;lt;/pre&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;HR size="1" noshade="noshade"&amp;gt;&amp;lt;h3&amp;gt;Apache Tomcat/4.1.36-LE-jdk14&amp;lt;/h3&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
</description>
			<version>1.5</version>
			<fixedVersion>1.5.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.AbstractHttpWebServiceMessageSenderIntegrationTestCase.java</file>
			<file type="M">org.springframework.ws.client.core.FaultMessageResolver.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplateIntegrationTest.java</file>
			<file type="M">org.springframework.ws.transport.http.AbstractHttpSenderConnection.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplate.java</file>
		</fixedFiles>
		<links>
			<link type="Depends" description="depends on">338</link>
			<link type="Related" description="is related to">137</link>
			<link type="Related" description="is related to">308</link>
		</links>
	</bug>
	<bug id="341" opendate="2008-04-25 01:49:55" fixdate="2008-04-30 22:21:56" resolution="Fixed">
		<buginformation>
			<summary>Wss4jSecurityInterceptor and AcegiDigestPasswordValidationCallbackHandler do not correctly work together to update the Acegi security context.</summary>
			<description>I am trying to hook up digest password handling and acegi authorization. I have managed to do this successfully with the plain text equivalent. I think I&amp;amp;apos;ve managed to get close to the problem. When you configure the plain text acegi handler you wire in a ProviderManager. 
&amp;lt;bean id="acegiHandler"
          class="org.springframework.ws.soap.security.wss4j.callback.acegi.AcegiPlainTextPasswordValidationCallbackHandler"&amp;gt;
        &amp;lt;property name="authenticationManager" ref="authenticationManager"/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id="authenticationManager" class="org.acegisecurity.providers.ProviderManager"&amp;gt;
        &amp;lt;property name="providers"&amp;gt;
            &amp;lt;bean class="org.acegisecurity.providers.dao.DaoAuthenticationProvider"&amp;gt;
                &amp;lt;property name="userDetailsService" ref="inMemoryDaoImpl"/&amp;gt;
            &amp;lt;/bean&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id="wsSecurityInterceptor" class="org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor"&amp;gt;
        &amp;lt;property name="validationActions" value="UsernameToken"/&amp;gt;
        &amp;lt;property name="validationCallbackHandler"&amp;gt;
            &amp;lt;!-&amp;lt;ref local="acegiDigestPasswordHandler"/&amp;gt;-&amp;gt;
            &amp;lt;ref local="acegiHandler"/&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id="inMemoryDaoImpl" class="org.acegisecurity.userdetails.memory.InMemoryDaoImpl"&amp;gt;
        &amp;lt;property name="userMap"&amp;gt;
            &amp;lt;value&amp;gt;
                Ernie=Bert,ROLE_SUPERVISOR
            &amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
It is the AbstractUserDetailsAuthenticationProvider (called by the AuthenticationManager) which, upon successful authentication, that actually sets the setAuthenticated(true) on the UsernamePasswordAuthenticationToken (see UsernamePasswordAuthenticationToken(principal,  authentication.getCredentials(), user.getAuthorities()); ).
protected Authentication createSuccessAuthentication(Object principal, Authentication authentication,
        UserDetails user) 
{
        // Ensure we return the original credentials the user supplied,
        // so subsequent attempts are successful even with encoded passwords.
        // Also ensure we return the original getDetails(), so that future
        // authentication events after cache expiry contain the details

// IB this constructor sets &amp;amp;apos;authenticated&amp;amp;apos; to true
        UsernamePasswordAuthenticationToken result = new UsernamePasswordAuthenticationToken(principal,
                authentication.getCredentials(), user.getAuthorities());
        result.setDetails(authentication.getDetails());

        return result;
    }


In the case of AcegiDigestPasswordValidationCallbackHandler you don&amp;amp;apos;t wire in a AuthenticationManager so even thought the credentials are valid it is never set to authentication in acegi SecurityContext. So the authorization fails even though the Principal has the correct GrantedAuthorities.
&amp;lt;bean id="wsSecurityInterceptor" class="org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor"&amp;gt;
        &amp;lt;property name="validationActions" value="UsernameToken"/&amp;gt;
        &amp;lt;property name="validationCallbackHandler"&amp;gt;
            &amp;lt;ref local="acegiDigestPasswordHandler"/&amp;gt;
            &amp;lt;!-&amp;lt;ref local="acegiHandler"/&amp;gt;-&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id="inMemoryDaoImpl" class="org.acegisecurity.userdetails.memory.InMemoryDaoImpl"&amp;gt;
        &amp;lt;property name="userMap"&amp;gt;
            &amp;lt;value&amp;gt;
                Ernie=Bert,ROLE_SUPERVISOR
            &amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id="acegiDigestPasswordHandler"
          class="org.springframework.ws.soap.security.wss4j.callback.acegi.AcegiDigestPasswordValidationCallbackHandler"&amp;gt;
        &amp;lt;property name="userDetailsService"&amp;gt;
            &amp;lt;ref local="inMemoryDaoImpl"/&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;</description>
			<version>1.5</version>
			<fixedVersion>1.5.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.acegi.AcegiDigestPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.SpringDigestPasswordValidationCallbackHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="339" opendate="2008-04-23 23:14:48" fixdate="2008-05-03 08:08:09" resolution="Fixed">
		<buginformation>
			<summary>XML namespace (http://www.w3.org/XML/1998/namespace) mapped to wrong prefix when building WSDL with inlined schemas</summary>
			<description>When using CommonsXsdSchemaCollection with inline=true, and inlining a schema that use the xml namespace, the WSDL cannot be generated due to the following exception:
org.xml.sax.SAXParseException: The prefix "xml" cannot be bound to any namespace other than its usual namespace; neither can the namespace for "xml" be bound to any prefix other than "xml".
InliningXsdSchemaTypesProvider.addTypes should check for the namespace "http://www.w3.org/XML/1998/namespace" and always map it to the prefix "xml"</description>
			<version>1.5</version>
			<fixedVersion>1.5.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.xsd.commons.CommonsXsdSchemaCollection.java</file>
			<file type="M">org.springframework.xml.xsd.commons.CommonsXsdSchemaCollectionTest.java</file>
			<file type="D">org.springframework.ws.samples.airline.security.AcegiFrequentFlyerSecurityService.java</file>
			<file type="M">org.springframework.xml.xsd.AbstractXsdSchemaTestCase.java</file>
		</fixedFiles>
	</bug>
	<bug id="345" opendate="2008-05-01 10:27:14" fixdate="2008-05-05 03:10:51" resolution="Fixed">
		<buginformation>
			<summary>WSS4J interceptor creates creates invalid digest for SAAJ messages</summary>
			<description>When using SAAJ and WSS4J on for outgoing messages, the digest created is incorrect, which results in signature verification failures. This is due to the fact that  the Document exposed via SOAPMessage.getSOAPPart() is out of sync. Calling SOAPMessage.saveChanges() fixes this.
</description>
			<version>1.5</version>
			<fixedVersion>1.5.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.SaajWss4jMessageInterceptorSignTest.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor.java</file>
			<file type="M">org.springframework.ws.context.DefaultMessageContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="353" opendate="2008-05-08 03:33:08" fixdate="2008-05-08 22:13:14" resolution="Fixed">
		<buginformation>
			<summary>Schema inlining results in duplicate inlining of files referenced from multiple files</summary>
			<description>Suppose you have two files foo-response.xsd and bar-response.xsd referenceing a common domain.xsd the Dynamic WSDL creation will cause the domain.xsd to be inlined twice in the WSDL.
This causes trouble to JAX-WS wsimport utility as elements appera twice in the same namespace.</description>
			<version>1.5.1</version>
			<fixedVersion>1.5.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.xsd.commons.CommonsXsdSchemaCollection.java</file>
		</fixedFiles>
	</bug>
	<bug id="358" opendate="2008-05-20 23:30:11" fixdate="2008-05-20 23:34:36" resolution="Fixed">
		<buginformation>
			<summary>NPE in JmsSenderConnection.onReceiveBeforeRead() when the received Message is null</summary>
			<description>We should test whether the Message returned by messageConsumer.receive is null (case of time out for instance) or else a NPE is thrown:
Message message = receiveTimeout &amp;gt;= 0 ? messageConsumer.receive(receiveTimeout) : messageConsumer.receive();</description>
			<version>1.5.2</version>
			<fixedVersion>1.5.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.jms.JmsSenderConnection.java</file>
			<file type="M">org.springframework.ws.transport.jms.JmsMessageSenderIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="363" opendate="2008-05-27 17:50:29" fixdate="2008-05-28 09:03:57" resolution="Fixed">
		<buginformation>
			<summary>AcegiPlainTextPasswordValidationCallbackHandler doesn&amp;apos;t implement InitializingBean</summary>
			<description>The AcegiPlainTextPasswordValidationCallbackHandler (both in xwss and wss4j packages) does provide an afterPropertiesSet method, but it is never called suring context setup, since it doesn&amp;amp;apos;t implement the InitializingBean interface.
A workaround is to set it as "init-method" in the context.</description>
			<version>1.5.2</version>
			<fixedVersion>1.5.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.acegi.AcegiPlainTextPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringDigestPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringCertificateValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.acegi.AcegiDigestPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.acegi.AcegiDigestPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.SpringPlainTextPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.SpringDigestPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.acegi.AcegiCertificateValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringPlainTextPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.acegi.AcegiPlainTextPasswordValidationCallbackHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="367" opendate="2008-06-02 04:10:59" fixdate="2008-06-05 00:41:39" resolution="Fixed">
		<buginformation>
			<summary>SOAP over JMS (BEA Weblogic 9.2) - empty body in SOAP responses with a jms TextMessage</summary>
			<description>A SOAP request is sent over JMS, the JMSReplyTo is set manually to an internal jms Queue.
Both for normal responses and for soap faults, the produced response (TextMessage) has an empty soap body.
The problem is coming from the following method in org.springframework.ws.transport.jms.JmsReceiverConnection
    protected OutputStream getResponseOutputStream() throws IOException {
        if (responseMessage instanceof BytesMessage) 
{
            return new BytesMessageOutputStream((BytesMessage) responseMessage);
        }
        else if (responseMessage instanceof TextMessage) {
            return new ByteArrayOutputStream() {
                public void close() throws IOException {
                    String text = new String(toByteArray(), textMessageEncoding);
                    try 
{
                        ((TextMessage) responseMessage).setText(text);
                    }
                    catch (JMSException ex) 
{
                        throw new JmsTransportException(ex);
                    }
                }
            };
        }
        else 
{
            throw new IllegalStateException("Unknown request message type [" + responseMessage + "]");
        }
    }
The close() on the private class set the text property of the TextMessage, but  the close() is called AFTER the message has been sent by the JMS message producer :
See this method in the ancestor AbstractWebServiceConnection
    public final void send(WebServiceMessage message) throws IOException {
        onSendBeforeWrite(message);
        tos = createTransportOutputStream();
        if (tos == null) 
{
            return;
        }
        message.writeTo(tos);
        tos.flush();
        onSendAfterWrite(message);
    }
For a TextMessage the line : message.writeTo(tos) did not set yet the text property of the TextMessage, then the onSendAfterWrite(message) is called, which sends the JMS message to the destination ( see in JmsReceiverConnection).  
Finally, a close() is performed in the caller bean ( a message listener) via a TransportUtils.closeConnection(connection) which closes also the private ByteArrayOutputStream, but a bit too late ...
The JMS Specification says : 
3.9 Access to Sent Messages
After sending a message, a client may retain and modify it without affecting
the message that has been sent. The same message object may be sent multiple
times.
I have triggered the &amp;amp;apos;set&amp;amp;apos; of the text property with the flush() method instead of the close(). It solved the problem but it&amp;amp;apos;s not very proper because the flush() may be called multiple times when writing in a OutputStream
</description>
			<version>1.5.2</version>
			<fixedVersion>1.5.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.jms.JmsSenderConnection.java</file>
			<file type="M">org.springframework.ws.transport.jms.JmsReceiverConnection.java</file>
			<file type="M">org.springframework.ws.transport.jms.JmsMessageSenderIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="365" opendate="2008-05-30 03:49:16" fixdate="2008-06-06 02:33:24" resolution="Fixed">
		<buginformation>
			<summary>wss4j-1.5.4.jar not in repository</summary>
			<description>The Spring-WS project:
http://repo1.maven.org/maven2/org/springframework/ws/spring-ws-parent/1.5.2/spring-ws-parent-1.5.2.pom
has a reference to wss4j-1.5.4.jar
This jar doesn&amp;amp;apos;t exist in the maven repo&amp;amp;apos;s. The only way i&amp;amp;apos;ve found to get it is from the manual "all dependencies" download of spring-ws.</description>
			<version>1.5.2</version>
			<fixedVersion>1.5.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="359" opendate="2008-05-21 10:17:08" fixdate="2008-06-06 02:56:09" resolution="Fixed">
		<buginformation>
			<summary>Using Axiom with payload caching off sometimes creates empty soap bodies</summary>
			<description>It appears that if you&amp;amp;apos;re using Castor to marshal your responses, and you&amp;amp;apos;re using Axiom without payload caching, that the SOAP response comes back with an empty Soap Body.  I did not try this with other Marshalling technologies like JAXB, etc, so I&amp;amp;apos;m not sure if it is restricted to Castor only or not.
It looks like NonCachingPayload.DelegatingStreamWriter.writeEndDocument() never gets called at least when marshalling with Castor.  Castor by default does not fire an endDocument SAX event (or close or flush for that matter).  But if you call setMarshalAsDocument(true) on a castor marshaller it does call endDocument().
I just now worked around this with Castor by creating a simple subclass of CastorMarshaller like this below:
    public class MyCastorMarshaller extends CastorMarshaller {
        protected void customizeMarshaller(Marshaller marshaller) 
{
            super.customizeMarshaller(marshaller);
            marshaller.setMarshalAsDocument(true);
        }
    }
See this forum thread for additional details: http://forum.springframework.org/showthread.php?p=181732&amp;amp;posted=1#post181732</description>
			<version>1.5.2</version>
			<fixedVersion>1.5.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.Payload.java</file>
			<file type="M">org.springframework.ws.soap.axiom.NonCachingPayload.java</file>
			<file type="M">org.springframework.ws.soap.axiom.CachingPayload.java</file>
		</fixedFiles>
	</bug>
	<bug id="374" opendate="2008-06-16 00:56:13" fixdate="2008-06-16 03:06:37" resolution="Fixed">
		<buginformation>
			<summary>DefaultURIResolver with witespaces</summary>
			<description>Hi
The following bean definition:
&amp;lt;bean id="schemaCollection" class="org.springframework.xml.xsd.commons.CommonsXsdSchemaCollection" lazy-init="true"&amp;gt;
        &amp;lt;property name="xsds" value="dl-messages.xsd"/&amp;gt;
        &amp;lt;property name="inline" value="true"/&amp;gt;
throws exception in my logs with a stack trace (part of stack trace)
at org.apache.ws.commons.schema.resolver.DefaultURIResolver.resolveEntity(DefaultURIResolver.java:64)
	at org.apache.ws.commons.schema.SchemaBuilder.resolveXmlSchema(SchemaBuilder.java:1872)
	at org.apache.ws.commons.schema.SchemaBuilder.handleImport(SchemaBuilder.java:1620)
	at org.apache.ws.commons.schema.SchemaBuilder.handleXmlSchemaElement(SchemaBuilder.java:175)
	at org.apache.ws.commons.schema.SchemaBuilder.build(SchemaBuilder.java:82)
	at org.apache.ws.commons.schema.XmlSchemaCollection.read(XmlSchemaCollection.java:359)
	at org.apache.ws.commons.schema.XmlSchemaCollection.read(XmlSchemaCollection.java:304)
	at org.apache.ws.commons.schema.XmlSchemaCollection.read(XmlSchemaCollection.java:315)
	at org.springframework.xml.xsd.commons.CommonsXsdSchemaCollection.afterPropertiesSet(CommonsXsdSchemaCollection.java:109)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1367)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1333)
	... 55 more
Caused by: java.net.URISyntaxException: Illegal character in path at index 16: file:/D:/Program Files/IBM/SDP70/runtimes/base_v61/profiles/prof/installedApps/linNode01Cell/ear-dl.ear/web-ws.war/dl-messages.xsd
	at java.net.URI$Parser.fail(URI.java:2821)
	at java.net.URI$Parser.checkChars(URI.java:2994)
	at java.net.URI$Parser.parseHierarchical(URI.java:3078)
	at java.net.URI$Parser.parse(URI.java:3026)
	at java.net.URI.&amp;lt;init&amp;gt;(URI.java:590)
	at org.apache.ws.commons.schema.resolver.DefaultURIResolver.resolveEntity(DefaultURIResolver.java:58)
	... 65 more
After a little investigation I found that the main problem is that URI constructor used in DefaultURIResolver.resolveEntity method can not parse expression:
"file:/D:/Program Files/IBM/SDP70/runtimes/base_v61/profiles/prof/installedApps/linNode01Cell/ear-dl.ear/web-ws.war/dl-messages.xsd"
and it is because of white space in &amp;amp;apos;Program Files&amp;amp;apos; folder.
To make URI constructor happy i would have to provide %20 instead of &amp;amp;apos; &amp;amp;apos; So to have it look like: "file:/D:/Program%20Files/IBM/SDP70/..."
I&amp;amp;apos; ve made some tests and for me it seems like a problem with org.springframework.core.io.Resource.getURL() call on websphere that does not conform to URI specification OR  problem with org.springframework.SaxUtils class that use getURL() instead of getURI.
1) Problem in Resource.getURL()
Calling getURL() on ClassPathResource or ServletContextResource in Websphere returns value that is proper URL but its string value (toString() value) contains whitespaces
A little example:
String sss = appContext.getResource("/WEB-INF/web.xml").getURL().toString();
System.out.println(sss);
String sss2 = appContext.getResource("/WEB-INF/web.xml").getURI().toString();
System.out.println(sss2);
produces:
file:/D:/Program
Files/IBM/SDP70/runtimes/base_v61/profiles/Wb/installedApps/liseksnNode01Cell/TestClassLoader.ear/TestClassLoaderWeb.war/WEB-INF/web.xml
file:/D:/Program%20Files/IBM/SDP70/runtimes/base_v61/profiles/Wb/installedApps/liseksnNode01Cell/TestClassLoader.ear/TestClassLoaderWeb.war/WEB-INF/web.xml
The analogous output you can get with ClassPathResource.
In comment on http://jira.springframework.org/browse/SPR-3900 by Juergen Hoeller
you can read
"Resource URLs always allow conversion to URIs now"
It doesn&amp;amp;apos;t look as it is always true on Websphere...
2) Problem lies in SaxUtils class
Method getSystemId() on org.springframework.xml.sax.SaxUtils returns resource.getURI() instead of getURL().
I took a look at documentation (javadoc) of setSystemId(String systemId) method in org.xml.sax.InputSource class where you can read:
"If the system ID is a URL, it must be fully resolved"
Summary:
i hope that i explained you the source and potential solution for a problem.
I am just not 100 % if the problem lies in Spring webservices or core spring framework.
</description>
			<version>1.5.1</version>
			<fixedVersion>1.5.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.sax.SaxUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="376" opendate="2008-06-16 21:51:26" fixdate="2008-06-16 22:02:01" resolution="Fixed">
		<buginformation>
			<summary>SaajSoapMessage.setSaajMessage() and AxiomSoapMessage.setAxiomMessage() should clear cached fields</summary>
			<description>The cached envelope fields in SaajSoapMessage and AxiomSoapMessage should be set to null when setSaajMessage or setAxiomMessage is called.</description>
			<version>1.5.2</version>
			<fixedVersion>1.5.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessage.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoapMessage.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">378</link>
		</links>
	</bug>
	<bug id="370" opendate="2008-06-07 03:42:38" fixdate="2008-06-29 22:51:42" resolution="Fixed">
		<buginformation>
			<summary>&amp;apos;KeyStoreUtils.loadDefaultKeyStore()&amp;apos; issue</summary>
			<description>In the loadDefaultKeyStore method of org.springframework.ws.soap.security.support.KeyStoreUtils class I found this code:
....
String passwordProperty = System.getProperty("javax.net.ssl.keyStorePassword");
if (StringUtils.hasLength(passwordProperty)) 
{
        password = passwordProperty;
    }
    type = System.getProperty("javax.net.ssl.trustStore");
}
....
In the line, System.getProperty("javax.net.ssl.trustStore"), the String parameter should be "javax.net.ssl.keyStoreType", right?
</description>
			<version>1.5.2</version>
			<fixedVersion>1.5.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.support.KeyStoreUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="385" opendate="2008-06-24 22:54:53" fixdate="2008-07-02 01:23:48" resolution="Fixed">
		<buginformation>
			<summary>Exceptions thrown using WS-Addressing result in Assert failure in Addressing10.addAddressingHeaders</summary>
			<description>When using WS-Addressing if any interceptor or endpoint throws an Exception the implicit interceptor created by AbstractAddressingEndpointMapping will cause an Assertion failure because it has a null faultAction URI.  When this happens no response is sent to the client.
Exposing a faultActionURI to the user in AbstractAddressingEndpointMapping to be used to create the interceptor would fix the problem.  If the user is implementing something that uses WS-BaseFaults this would be required anyhow, and the default behavior could be to use the responseAction if the faultAction is not set.</description>
			<version>1.5.1</version>
			<fixedVersion>1.5.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.addressing.server.AddressingEndpointInterceptor.java</file>
			<file type="M">org.springframework.ws.soap.addressing.server.AbstractActionEndpointMapping.java</file>
			<file type="M">org.springframework.ws.soap.addressing.server.AnnotationActionEndpointMapping.java</file>
			<file type="M">org.springframework.ws.soap.addressing.server.AbstractAddressingEndpointMapping.java</file>
			<file type="M">org.springframework.ws.soap.addressing.server.annotation.Action.java</file>
		</fixedFiles>
	</bug>
	<bug id="357" opendate="2008-05-20 01:53:39" fixdate="2008-07-04 00:22:08" resolution="Fixed">
		<buginformation>
			<summary>Axiom does not support SwA attachments </summary>
			<description>Incoming SOAP messages with attachments are parsed correctly, but outgoing messages with attachments are missing attachment parts and all part boundaries, even though the overall HTTP content-type is "multipart/related" with a boundary value specified.
Given this message sending scenario:






WebServiceMessageCallback requestCallback = new WebServiceMessageCallback() {




  public void doWithMessage(WebServiceMessage message)




      throws IOException, TransformerException {




    




    SoapMessage soapMessage = (SoapMessage) message;




      




    soapMessage.addAttachment(




        generateContentId(), // generates a unique Content-ID String




        new ByteArrayResource(attachmentData),   // Data




        "application/octet-stream");        // Content-Type




  }




}; 









// ...create response extractor ....









serviceTemplate.sendAndReceive(




  "https://foo.bar.com/SendSubmissionReceipts", 




  requestCallback, responseExtractor);






I get an HTTP message like this:






Accept-Encoding: gzip




Content-Type: multipart/related; boundary=MIMEBoundaryurn_uuid_3D927F4433B32F68641210953465313; type="text/xml"; start="0.urn:uuid:3D927F4433B32F68641210953465314@apache.org"; charset="UTF-8"




SOAPAction: "SendSubmissionReceipts"




User-Agent: Jakarta Commons-HttpClient/3.1




Host: foo.bar.com




Cookie: $Version=0; JSESSIONID=0001JGVZICF0ATPGIDRKW5J1LHY:11p9fo6l7; $Path=/




Content-Length: 3978









&amp;lt;?xml version=&amp;amp;apos;1.0&amp;amp;apos; encoding=&amp;amp;apos;UTF-8&amp;amp;apos;?&amp;gt;&amp;lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;&amp;lt;soapenv:Header&amp;gt;[contents intentionally omitted]&amp;lt;/soapenv:Header&amp;gt;&amp;lt;soapenv:Body&amp;gt;[contents intentionally omitted]&amp;lt;/soapenv:Body&amp;gt;&amp;lt;/soapenv:Envelope&amp;gt;






Correct overall content-type and boundary value, but no attachment parts and no boundaries.
The problem may be in CommonsHttpConnection.onSendAfterWrite() where a ByteArrayRequestEntity is always used instead of the MultipartRequestEntity that the Commons HttpClient API says should be used for requests with attachments






protected void onSendAfterWrite(WebServiceMessage message) throws IOException {




  postMethod.setRequestEntity(new ByteArrayRequestEntity(requestBuffer.toByteArray()));




  requestBuffer = null;




  httpClient.executeMethod(postMethod);




}






It would seem to me that onSendAfterWrite() should be checking the WebServiceMessage to see if there are any attachments, and if there are, creating the necessary xml message and attachment Parts and passing them to a MultipartRequestEntity instead of sending the entire request to a ByteArrayRequestEntity.</description>
			<version>1.5.2</version>
			<fixedVersion>1.5.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessage.java</file>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplateIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="389" opendate="2008-07-08 02:07:30" fixdate="2008-07-13 20:20:49" resolution="Fixed">
		<buginformation>
			<summary>problem with DomContentHandler</summary>
			<description>Everytime the function appendChild on a Node is used , the return value should be set to the original node (the one passed as argument). This must be done as Jboss create it&amp;amp;apos;s own element and use it as a wrapper around the one has been passed in the function.
So , for example, the code in the function startElement(..) should be changed from:
        Node parent = getParent();
        Element element = document.createElementNS(uri, qName);
        ...........(more code here)
        parent.appendChild(element);
        elements.add(element);
to
        Node parent = getParent();
        Element element = document.createElementNS(uri, qName);
        ...........(more code here)
        element = parent.appendChild(element);
        elements.add(element);
And so on everywhere appendChild is used.</description>
			<version>1.5.3</version>
			<fixedVersion>1.5.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.dom.DomContentHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="386" opendate="2008-07-06 16:35:10" fixdate="2008-07-13 20:22:00" resolution="Fixed">
		<buginformation>
			<summary>DefaultWsdl11Definition.setFaultSuffix : responseSuffix overwritten</summary>
			<description>There is a bug in DefaultWsdl11Definition.setFaultSuffix
It should be
    /** Sets the suffix used to detect fault elements in the schema. */
    public void setFaultSuffix(String faultSuffix) 
{
        portTypesProvider.setFaultSuffix(faultSuffix);
        //messagesProvider.setResponseSuffix(faultSuffix);
        messagesProvider.setFaultSuffix(faultSuffix);
    }
</description>
			<version>1.5.3</version>
			<fixedVersion>1.5.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.wsdl.wsdl11.DefaultWsdl11Definition.java</file>
		</fixedFiles>
	</bug>
	<bug id="393" opendate="2008-07-10 06:00:06" fixdate="2008-07-15 00:02:58" resolution="Fixed">
		<buginformation>
			<summary>Incoming message with with UTF-8 BOM is failing</summary>
			<description>When submitting a SOAP request that contains a UTF BOM http://unicode.org/faq/utf_bom.html#22, the following fault string is returned: "Could not access envelope: Unable to create envelope from given source:"
After removing the offending BOM, and not manipulating the XML in any other way, the message is is delivered to the defined Endpoint successfully.
Per http://unicode.org/faq/utf_bom.html#29 , Spring-WS should be able to transparently ignore the BOM on UTF-8 files.</description>
			<version>1.5.3</version>
			<fixedVersion>1.5.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoapMessageFactory.java</file>
			<file type="M">org.springframework.ws.soap.soap11.AbstractSoap11MessageFactoryTestCase.java</file>
		</fixedFiles>
	</bug>
	<bug id="396" opendate="2008-07-11 01:49:00" fixdate="2008-07-17 22:49:18" resolution="Fixed">
		<buginformation>
			<summary>@Endpoint with method having any other annotation then @PayloadRoot is not mapped</summary>
			<description>I&amp;amp;apos;ve got @PayloadRoot annotated methods of @Endpoint and some methods also has @RolesAllowed from spring security. Today after upgrading from spring-ws 1.5.2 PayloadRootAnnotationMethodEndpointMapping stopped to processed this endpoint. I&amp;amp;apos;ve also tried another (my custom @Log AOP annotation) annotation with same (bad) result. 
So now after last test, when any @Endpoint method has any other annotation then @PayloadRoot, it is not mapped.</description>
			<version>1.5.3</version>
			<fixedVersion>1.5.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.endpoint.mapping.AbstractAnnotationMethodEndpointMapping.java</file>
			<file type="M">org.springframework.ws.server.endpoint.mapping.AbstractMethodEndpointMapping.java</file>
			<file type="M">org.springframework.ws.server.endpoint.mapping.PayloadRootAnnotationMethodEndpointMappingTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.mapping.PayloadRootEndpoint.java</file>
		</fixedFiles>
	</bug>
	<bug id="392" opendate="2008-07-09 18:28:30" fixdate="2008-07-21 22:04:37" resolution="Fixed">
		<buginformation>
			<summary>AbstractMarshallingPayloadEndpoint and XStreamMarshaller produces malformed response body</summary>
			<description>Marshalling and unmarshalling of objects to XML payloads using AbstractMarshallingPayloadEndpoint and XStreamMarshaller seems to generated malformed SOAP Message when using XStream 1.2.1 or newer (XStream 1.2 works without problems).
The fundamental method of my endpoint looks like this:
Code:
  protected Object invokeInternal(Object object) throws Exception {
    MovieReservation movieReservationRequest = (MovieReservation) object;
    ReservationConfirmation confirmation = new ReservationConfirmation();
    confirmation.setId(new Date().getDate());
    confirmation.setSeatIds(new int[] 
{1, 2, 3, 4}
);
    return confirmation;
  }
The SOAP response, which is malformed, looks as follows:
Code:
&amp;lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="..../"&amp;gt;
  &amp;lt;SOAP-ENV:Header/&amp;gt;
  &amp;lt;SOAP-ENV:Body/&amp;gt;
  &amp;lt;ReservationConfirmation&amp;gt;
    &amp;lt;id&amp;gt;23&amp;lt;/id&amp;gt;
    &amp;lt;seatIds&amp;gt;
      &amp;lt;int&amp;gt;1&amp;lt;/int&amp;gt;
      &amp;lt;int&amp;gt;2&amp;lt;/int&amp;gt;
      &amp;lt;int&amp;gt;3&amp;lt;/int&amp;gt;
      &amp;lt;int&amp;gt;4&amp;lt;/int&amp;gt;
    &amp;lt;/seatIds&amp;gt;
  &amp;lt;/ReservationConfirmation&amp;gt;
&amp;lt;/SOAP-ENV:Envelope&amp;gt;
Notice the empty header and empty body and the ReservationConfirmation element following the body element (which is incorrect, since this element should be within the body).
I suspect the Spring org.s.x.oxm.XStreamWriter and its method marshalDomDone which contains the following lines
Code:
        else if (node instanceof Element) 
{
            streamWriter = new DomWriter((Element) node);
        }

However, sometimes between XStream 1.2 and XStream 1.3 the functionality of DomWriter has changed. This is described on the XStream mailing list in the "DOMWriter uses root element for marshalling instead of specified element" topic [1]
The suggested change is described in that post:"To write into an arbitrary node you have to use the constructor DomWriter(Element, Document, XmlFriendlyReplacer)."
Shouldn&amp;amp;apos;t the XStreamMarshall use the suggested three-param constructor instead of the default?
[1] http://www.nabble.com/DOMWriter-uses-root-element-for-marshalling-instead-of-specified-element-td16088975.html#a16088975</description>
			<version>1.5.2</version>
			<fixedVersion>1.5.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.oxm.xstream.XStreamMarshaller.java</file>
			<file type="M">org.springframework.oxm.xstream.XStreamMarshallerTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="411" opendate="2008-08-06 18:26:54" fixdate="2008-08-28 05:27:50" resolution="Fixed">
		<buginformation>
			<summary>When using permanent replyTo queues, their JNDI names can&amp;apos;t start with jms/ in the defaultUri property of the WebServiceGateway</summary>
			<description>We are using permanent queues defined as JNDI resources in a WAS 6.1. Their JNDI names start with jms/, for instance jms/RESPONSE_QUEUE.
We have a client which is configured like this, along side with a jndiDestinationResolver and a jndiTemplate:
[code]
&amp;lt;bean id="serviceGateway" class="net.croz.client.ServiceGatewayImpl"&amp;gt;
        &amp;lt;property name="defaultUri" value="jms:jms/REQUEST_QUEUE?replyToName=jms/REPLY_QUEUE" /&amp;gt;
        &amp;lt;property name="messageSenders"&amp;gt;
            &amp;lt;bean class="org.springframework.ws.transport.jms.JmsMessageSender"&amp;gt;
                &amp;lt;property name="connectionFactory" ref="mqConnectionFactory" /&amp;gt;
                &amp;lt;property name="pubSubDomain" value="false" /&amp;gt;
                &amp;lt;property name="destinationResolver" ref="jndiDestinationResolver"&amp;gt;&amp;lt;/property&amp;gt;
                &amp;lt;property name="receiveTimeout" value="10000"&amp;gt;&amp;lt;/property&amp;gt;
            &amp;lt;/bean&amp;gt;
        &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id="jndiTemplate"
        class="org.springframework.jndi.JndiTemplate"&amp;gt;
        &amp;lt;property name="environment"&amp;gt;
          &amp;lt;props&amp;gt;
            &amp;lt;prop key="java.naming.factory.initial"&amp;gt;com.ibm.websphere.naming.WsnInitialContextFactory&amp;lt;/prop&amp;gt;
            &amp;lt;prop key="java.naming.provider.url"&amp;gt;iiop://localhost:2810&amp;lt;/prop&amp;gt;
          &amp;lt;/props&amp;gt;
        &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id="jndiDestinationResolver" class="org.springframework.jms.support.destination.JndiDestinationResolver"&amp;gt;
        &amp;lt;property name="jndiTemplate" ref="jndiTemplate"&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
[code/]
When invoking a fully functional web service (under our control), the request ends up in the REQUEST_QUEUE, but when the client tries to find the RESPONSE_QUEUE via its JNDI name (jms/REPLY_QUEUE) it fails with:
[code]
Destination [jms] not found in JNDI; nested exception is org.springframework.jndi.TypeMismatchNamingException: Object of type [class com.ibm.ws.naming.jndicos.CNContextImpl] available at JNDI location [jms] is not assignable to [javax.jms.Destination]
[/code]
Observe the "..available at JNDI location [jms]..." part in particular... This led me to investigate the code responsible for parsing the defaultUri property of the WebServiceGateway. What I&amp;amp;apos;ve found is that the regular expression responsible for the parsing of the replyToName part of the defaultUri:
[code]
public abstract class JmsTransportUtils {
.......    
     private static final Pattern REPLY_TO_NAME_PATTERN = Pattern.compile("replyToName=(w+)");
.......
}
[/code]
strips everything behind the "jms" part of the JNDI name.
To do a quick fix, I&amp;amp;apos;ve externalized the JmsTransportUtils class and changed the REPLY_TO_NAME_PATTERN to be similar to the DESTINATION_NAME_PATTERN:
[code]
public abstract class JmsTransportUtils {
.......    
     private static final Pattern REPLY_TO_NAME_PATTERN = Pattern.compile("replyToName=([^\\?]+)");
.......
}
[/code] </description>
			<version>1.5.3</version>
			<fixedVersion>1.5.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.jms.support.JmsTransportUtils.java</file>
			<file type="M">org.springframework.ws.transport.jms.support.JmsTransportUtilsTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="418" opendate="2008-08-20 23:11:24" fixdate="2008-08-28 09:23:17" resolution="Fixed">
		<buginformation>
			<summary>Castor mappings are added multiple times</summary>
			<description>When using multiple mapping files for castor the CastorMarshaller adds each mapping several times.
i.e.
&amp;lt;bean id="castorMarshaller" class="org.springframework.oxm.castor.CastorMarshaller" &amp;gt;
		&amp;lt;property name="mappingLocations"&amp;gt;
			&amp;lt;list&amp;gt;                               
				&amp;lt;value&amp;gt;classpath:file1.xml&amp;lt;/value&amp;gt;
				&amp;lt;value&amp;gt;classpath:file2.xml&amp;lt;/value&amp;gt;                
				&amp;lt;value&amp;gt;classpath:file3.xml&amp;lt;/value&amp;gt;
			&amp;lt;/list&amp;gt;
		&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
The mappings from file1 are added 3 times because the addMapping() method is called within the loop with the entire mapping.
I think method
    protected XMLContext createXMLContext(Resource[] mappingLocations, Class targetClass)
            throws MappingException, IOException, ResolverException {
        XMLContext context = new XMLContext();
        if (!ObjectUtils.isEmpty(mappingLocations)) {
            Mapping mapping = new Mapping();
            for (int i = 0; i &amp;lt; mappingLocations.length; i++) 
{
                mapping.loadMapping(SaxUtils.createInputSource(mappingLocations[i]));
                context.addMapping(mapping);
            }
        }
        if (targetClass != null) 
{
            context.addClass(targetClass);
        }
        return context;
    }

Should actually look like this

    protected XMLContext createXMLContext(Resource[] mappingLocations, Class targetClass)
            throws MappingException, IOException, ResolverException {
        XMLContext context = new XMLContext();
        if (!ObjectUtils.isEmpty(mappingLocations)) {
            Mapping mapping = new Mapping();
            for (int i = 0; i &amp;lt; mappingLocations.length; i++) {
                mapping.loadMapping(SaxUtils.createInputSource(mappingLocations[i]));
            }
            context.addMapping(mapping);
        }
        if (targetClass != null) {            context.addClass(targetClass);        }
        return context;
    }
BTW: Adding mappings multiple times will result in strange behavior because Castor tries identify objects by their namespace if it finds multiple entries with the same name and fails because of bad namespace support within castor.</description>
			<version>1.5.4</version>
			<fixedVersion>1.5.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.oxm.castor.CastorMarshaller.java</file>
		</fixedFiles>
	</bug>
	<bug id="416" opendate="2008-08-15 04:52:14" fixdate="2008-08-28 09:43:36" resolution="Fixed">
		<buginformation>
			<summary>Wss4jSecurityInterceptor loosing SOAPAction header</summary>
			<description>When the Wss4jSecurityInterceptor replaces the AxiomMessage in the SoapMessage, if the original SoapMessage already had a SoapAction set, the value is lost.
I believe, in the Wss4jSecurityInterceptor.replaceMessage() method, the following workaround should be done:
// replace the Axiom message
String tempSoapAction = soapMessage.getSoapAction();
axiomMessage.setAxiomMessage(newMessage);
soapMessage.setSoapAction(tempSoapAction);</description>
			<version>1.5.3</version>
			<fixedVersion>1.5.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="422" opendate="2008-08-26 22:57:44" fixdate="2008-09-01 21:45:34" resolution="Fixed">
		<buginformation>
			<summary>Class AxiomUtils is not java 1.4 compatible</summary>
			<description>In the class AxiomUtils, the methods toDocument and toEnvelope construct an IllegalArgumentException with a constructor introduced in java 1.5:
public IllegalArgumentException(String message, Throwable cause)</description>
			<version>1.5.1</version>
			<fixedVersion>1.5.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.support.AxiomUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="412" opendate="2008-08-10 20:59:55" fixdate="2008-09-02 02:38:42" resolution="Fixed">
		<buginformation>
			<summary>PayloadTransformingInterceptor does not work with a DomPoxMessage - the transformation clears the document</summary>
			<description>This bug is related to SWS-248
Emptying the Document in the method getPayloadResult() of the DomPoxMessage makes the transformation in the PayloadTransformingInterceptor  impossible.
PayloadTransformingInterceptor  source code 1.5.4
80      public boolean handleRequest(MessageContext messageContext, Object endpoint) throws Exception {
81          if (requestTemplates != null) 
{
82              WebServiceMessage request = messageContext.getRequest();
83              Transformer transformer = requestTemplates.newTransformer();
84              transformer.transform(request.getPayloadSource(), request.getPayloadResult());
85              logger.debug("Request message transformed");
86          }
87          return true;
88      }
Line 84, before the transform() method is called, the 2nd argument evaluation clears the document inside the DomPoxMessage, so the DOMSource created by calling the 1st argument wraps now an empty document, the transformation returns always an empty XML.
See my small test :
	public static void main(String[] args) throws IOException, TransformerFactoryConfigurationError, TransformerException 
{
	
		
		String content = "&amp;lt;element xmlns=\"http://www.springframework.org/spring-ws\" /&amp;gt;";
		byte[] bytes = content.getBytes("UTF-8");
	    InputStream input = new ByteArrayInputStream(bytes);
		
		DomPoxMessageFactory factory = new DomPoxMessageFactory();
		DomPoxMessage domPoxMsg = (DomPoxMessage) factory.createWebServiceMessage(input);
		
		
		Result result = new StreamResult(System.out);
		Transformer t = TransformerFactory.newInstance().newTransformer();
		System.out.println("1. Transformation to System.out :");
		t.transform(domPoxMsg.getPayloadSource(), result);
		
		System.out.println("\n\n");
		System.out.println("2. Transformation to message itself as Result (=interceptor)");
		t.transform(domPoxMsg.getPayloadSource(), domPoxMsg.getPayloadResult());
		
		System.out.println("\n\n");
		System.out.println("3. Transformation to System.out :");
		t.transform(domPoxMsg.getPayloadSource(), result);
		
		
	}

The solution may be to add an intermediate transformation ( a simple StreamResult) but as it is working for other WebServiceMessage implementation ( SOAP ) it could be too heavy ...
Note also that a testPayLoadInterceptor() could be added in DomPoxMessageTest </description>
			<version>1.5.4</version>
			<fixedVersion>1.5.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.endpoint.interceptor.PayloadTransformingInterceptorTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.interceptor.PayloadTransformingInterceptor.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">248</link>
		</links>
	</bug>
	<bug id="427" opendate="2008-09-07 20:18:35" fixdate="2008-09-13 21:03:02" resolution="Fixed">
		<buginformation>
			<summary>AbstractEndpointExceptionResolver.resolveException() does not let subclasses have full access to the MethodEndpoint that raised an exception</summary>
			<description>In resolveException(), the MethodEndpoint gets replaced with it&amp;amp;apos;s bean name. As a consequence, subclasses can no longer inspect the MethodEndpoint.
Discussion in this thread: http://forum.springframework.org/showthread.php?p=200392.
</description>
			<version>1.5.2</version>
			<fixedVersion>1.5.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.endpoint.AbstractEndpointExceptionResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="432" opendate="2008-09-22 08:20:20" fixdate="2008-09-22 20:31:55" resolution="Fixed">
		<buginformation>
			<summary>AxiomSoap12Body.getFault() returns object of type AxiomSoap11Fault</summary>
			<description>AxiomSoap12Body.getFault() returns object of type AxiomSoap11Fault
Cause: AxiomSoap12Body does not implement the method getFault. So the getFault() method of the super class AxiomSoapBody is called which returns an object of type AxiomSoap11Fault.
Proposal to solve the issue: Remove the getFault() method from the super class and implement specific methods in the sub classes AxiomSoap11Body respectively AxiomSoap12Body.</description>
			<version>1.5.4</version>
			<fixedVersion>1.5.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoap11Body.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoap12Body.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapBody.java</file>
		</fixedFiles>
	</bug>
	<bug id="420" opendate="2008-08-24 10:00:22" fixdate="2008-09-26 00:48:15" resolution="Fixed">
		<buginformation>
			<summary>AxiomSoapMessage + SOAP1.2 SoapAction</summary>
			<description>AxiomSoapMessage and SOAP1.2 SoapAction Problem.
I&amp;amp;apos;m not sure, but as far as I read, in SOAP 1.2 the SoapAction parameter now part of Content-Type.
( http://www.w3.org/TR/2003/REC-soap12-part2-20030624/#ietf-action ).
org.springframework.ws.soap.axiom.AxiomSoapMessage.writeTo(OutputStream outputStream) don&amp;amp;apos;t extend the content-type header with the action paramater
in case of an soap1.2 message.
independent from the soap version, an SOAPAction header element is created.</description>
			<version>1.5.4</version>
			<fixedVersion>1.5.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.soap12.AbstractSoap12MessageTestCase.java</file>
			<file type="M">org.springframework.ws.soap.soap11.AbstractSoap11MessageFactoryTestCase.java</file>
			<file type="M">org.springframework.ws.transport.TransportConstants.java</file>
			<file type="M">org.springframework.ws.soap.soap12.AbstractSoap12MessageFactoryTestCase.java</file>
			<file type="M">org.springframework.ws.soap.AbstractSoapMessage.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessage.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessageFactory.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoapMessage.java</file>
		</fixedFiles>
	</bug>
	<bug id="445" opendate="2008-11-10 21:15:33" fixdate="2008-11-12 21:25:05" resolution="Duplicate">
		<buginformation>
			<summary>CLONE -JibxMarshaller - marshalSaxHandlers</summary>
			<description>JiBX does not support SAX natively, so there is written to a buffer first:
ByteArrayOutputStream os = new ByteArrayOutputStream();
marshalOutputStream(graph, os);
ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
the character &amp;lt; results in &amp;amp;&amp;lt;; and not in &amp;lt; as expected.
http://forum.springframework.org/showthread.php?t=55407&amp;amp;highlight=SAXResult</description>
			<version>1.5.4</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.AxiomHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomHandler.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">434</link>
		</links>
	</bug>
	<bug id="448" opendate="2008-11-16 01:59:49" fixdate="2008-11-17 20:02:41" resolution="Fixed">
		<buginformation>
			<summary>Wss4jSecurityInterceptor accept messages when &lt;wsse:header&gt; is empty</summary>
			<description>http://forum.springframework.org/showthread.php?t=63553
The problem is when Wss4jSecurityInterceptor is used in the server side, to validate username token (or signature).
Everything looks fine except when a &amp;lt;wsse:header&amp;gt; empty is sent. The Interceptor lets the messsage goes and don&amp;amp;apos;t
throw any exceptions.
As an attachment, I&amp;amp;apos;m sending a maven project with JUnit tests to prove the case. The project is a very simple web service
based on the tutorial sample. I just configure the wss4j interceptor for validate username token.
The only test thats doesn&amp;amp;apos;t pass is the last &amp;amp;apos;testSendMessageWithEmptyWsseHeader&amp;amp;apos;
Sorry for my english... it isn&amp;amp;apos;t my native language. </description>
			<version>1.5.5</version>
			<fixedVersion>1.5.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jMessageInterceptorHeaderTestCase.java</file>
		</fixedFiles>
	</bug>
	<bug id="434" opendate="2008-10-01 19:48:25" fixdate="2008-12-12 21:59:41" resolution="Fixed">
		<buginformation>
			<summary>JibxMarshaller - marshalSaxHandlers</summary>
			<description>JiBX does not support SAX natively, so there is written to a buffer first:
ByteArrayOutputStream os = new ByteArrayOutputStream();
marshalOutputStream(graph, os);
ByteArrayInputStream is = new ByteArrayInputStream(os.toByteArray());
the character &amp;lt; results in &amp;amp;&amp;lt;; and not in &amp;lt; as expected.
http://forum.springframework.org/showthread.php?t=55407&amp;amp;highlight=SAXResult</description>
			<version>1.5.4</version>
			<fixedVersion>1.5.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.AxiomHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomHandler.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">455</link>
			<link type="Duplicate" description="is duplicated by">445</link>
		</links>
	</bug>
	<bug id="455" opendate="2008-12-01 06:35:46" fixdate="2008-12-12 22:01:03" resolution="Duplicate">
		<buginformation>
			<summary>Mangled predefined xml &amp;apos;special character&amp;apos; entities when using AxiomSoapMessageFactory and extending AbstractStaxStreamPayloadEndpoint</summary>
			<description>Using AxiomSoapMessageFactory and with an endpoint extending AbstractStaxStreamPayloadEndpoint, special character predefined entities like &amp;amp; or &amp;lt; in HTTP response get &amp;amp;apos;mangled&amp;amp;apos;.  For example, when the endpoint writes  &amp;lt;echo:echoRequest&amp;gt; &amp;lt; &amp;lt;/echo:echoRequest&amp;gt; to the XMLStreamWriter (which is correct) what actually gets sent in the resulting AxiomSoapMessage is this: &amp;lt;echo:echoRequest&amp;gt; &amp;amp;&amp;lt;; &amp;lt;/echo:echoRequest&amp;gt; (which is incorrect).  I recreated this bug with the echo sample application in 1.5.5 by changing the endpoint to extend AbstractStaxStreamPayloadEndpoint and specifying the AxiomSoapMessageFactory  in the spring-ws-servlet.xml file (documented in this forum thread: http://forum.springframework.org/showthread.php?p=215668)
I was able to correct this behavior by modifying org.springframework.ws.soap.axiom.AxiomHandler - I simply commented out the statements inside startEntity(..) and endEntity(..) functions making them "unsupported".  While this did not produce any side-effects during the testing I did for my project, I have not run the full spring-ws test suite.  The change is as follows:
class AxiomHandler implements ContentHandler, LexicalHandler {
...
 public void startEntity(String name) throws SAXException 
{
        //make unsupported to fix mangling of special character entities        
        //charactersType = XMLStreamConstants.ENTITY_REFERENCE;
    }

    public void endEntity(String name) throws SAXException 
{
        //make unsupported to fix mangling of special character entities
        //charactersType = XMLStreamConstants.CHARACTERS;
    }

...
}
</description>
			<version>1.5.5</version>
			<fixedVersion>1.5.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.AxiomHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomHandler.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">434</link>
		</links>
	</bug>
	<bug id="464" opendate="2008-12-15 01:52:57" fixdate="2008-12-16 20:15:12" resolution="Fixed">
		<buginformation>
			<summary>The use of WS Addressing results in malformed SOAP messages</summary>
			<description>When WS Addressing is being used the Axiom message factory appears to produce malformed SOAP messages (details to follow)  </description>
			<version>1.5.5</version>
			<fixedVersion>1.5.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.saaj.Saaj13Implementation.java</file>
			<file type="M">org.springframework.ws.soap.AbstractSoapElementTestCase.java</file>
			<file type="M">org.springframework.ws.soap.saaj.Saaj11Implementation.java</file>
			<file type="M">org.springframework.ws.soap.SoapElement.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoapElement.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajImplementation.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapElement.java</file>
			<file type="M">org.springframework.ws.soap.addressing.version.AbstractAddressingVersion.java</file>
			<file type="M">org.springframework.ws.soap.saaj.Saaj12Implementation.java</file>
		</fixedFiles>
	</bug>
	<bug id="442" opendate="2008-10-30 18:17:55" fixdate="2008-12-18 22:26:56" resolution="Fixed">
		<buginformation>
			<summary>Generated WSDL file does not contain xmime attribute "expectedContentTypes" present in xsd files.</summary>
			<description>The attachment contains the following files,
       1)Normal0.xsd-- schema file containing "xmime:expectedContentTypes" attribute.
       2)Normal1.xsd-- schema file.
       3)MyService.wsdl-- WSDL file generated using "org.springframework.ws.wsdl.wsdl11.DefaultWsdl11Definition" class.
       4)spring-ws-servlet.xml-- Servlet config file used for generation of wsdl.
In spring-ws-servlet.xml file, 
    "org.springframework.ws.wsdl.wsdl11.DefaultWsdl11Definition" bean generates the wsdl file from the schemaCollection bean which uses the "org.springframework.xml.xsd.commons.CommonsXsdSchemaCollection" class.
The Normal0.xsd file,
     uses the xmime:expectedContentTypes="application/octet-stream" attribute to specify binary data, but the wsdl generated by "org.springframework.ws.wsdl.wsdl11.DefaultWsdl11Definition" class does not contain the xmime attribute.The generated wsdl file "MyService.wsdl" is attached.
Without xmime attribute in generated wsdl file the client code generation will not have Datahandler class.
It is also observed that when i use "org.springframework.xml.xsd.SimpleXsdSchema" class for specifying xsd file, the xmime attribute is reflected in wsdl file.But this class cannot be used for multiple xsd files.
Kindly let me know if more info is required,
Thanks in advance ,
Navin Bhat 
</description>
			<version>1.5.4</version>
			<fixedVersion>1.5.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.xsd.commons.CommonsXsdSchemaCollection.java</file>
			<file type="M">org.springframework.xml.xsd.AbstractXsdSchemaTestCase.java</file>
			<file type="M">org.springframework.xml.xsd.commons.CommonsXsdSchema.java</file>
		</fixedFiles>
	</bug>
	<bug id="467" opendate="2008-12-19 01:29:36" fixdate="2008-12-19 01:32:54" resolution="Duplicate">
		<buginformation>
			<summary>Issues while generating of WSDL using SpringWS1.5 and spring-core2.0</summary>
			<description>Hi,
We are trying to generate the WSDL from XSD using DynamicWSDL of springws1.5 with Spring2.0. We are getting the following error: 
java.lang.NoSuchMethodError: getURI Caused by: org.springframework.beans.factory.BeanCreationException
defined in ServletContext resource [/WEB-INF/spring-ws-servlet.xml]: Invocation of init method failed; nested exception is java.lang.NoSuchMethodError: getURI Caused by: java.lang.NoSuchMethodError: getURI at org.springframework.xml.sax.SaxUtils.getSystemId(Lorg.springframework.core.io.Resource;)Ljava.lang.String;(SaxUtils.java:52)
at org.springframework.xml.sax.SaxUtils.createInputSource(Lorg.springframework.core.io.Resource;)Lorg.xml.sax.InputSource;(SaxUtils.java:45)
at org.springframework.xml.xsd.SimpleXsdSchema.loadSchema(Ljavax.xml.parsers.DocumentBuilder;)V(SimpleXsdSchema.java:113)
at org.springframework.xml.xsd.SimpleXsdSchema.afterPropertiesSet()V(SimpleXsdSchema.java:109)
It will be great if you let us know a way to generate the WSDL within Spring2.0 and SpringWS1.5?
Thanks and Regards
Amerish
</description>
			<version>1.5.1</version>
			<fixedVersion>1.5.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.sax.SaxUtils.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpUrlConnection.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">459</link>
		</links>
	</bug>
	<bug id="457" opendate="2008-12-08 18:30:33" fixdate="2008-12-21 21:40:54" resolution="Fixed">
		<buginformation>
			<summary>AxiomSoapMessageFactory payloadCaching=false causes org.springframework.ws.soap.axiom.AxiomSoapEnvelope.getBody()  to fail</summary>
			<description>http://forum.springframework.org/showthread.php?t=64350
Hello,
I have problem with AxiomSoapMessageFactory payloadCaching=false.
Spring config is simple as this:






&amp;lt;bean id="messageFactory" class="org.springframework.ws.soap.axiom.AxiomSoapMessageFactory"&amp;gt;




  &amp;lt;property name="payloadCaching" value="false"/&amp;gt;




&amp;lt;/bean&amp;gt;









&amp;lt;bean class="org.springframework.ws.soap.server.endpoint.mapping.SoapActionEndpointMapping"&amp;gt;




  &amp;lt;property name="mappings"&amp;gt;




    &amp;lt;props&amp;gt;




      &amp;lt;prop key="SoapAction1"&amp;gt;endpoint1&amp;lt;/prop&amp;gt;




    &amp;lt;/props&amp;gt;




  &amp;lt;/property&amp;gt;




&amp;lt;/bean&amp;gt;









&amp;lt;bean id="wsdl" class="org.springframework.ws.wsdl.wsdl11.DefaultWsdl11Definition"&amp;gt;




  &amp;lt;property name="schema" ref="schema" /&amp;gt;




  &amp;lt;property name="portTypeName" value="resource1" /&amp;gt;




  &amp;lt;property name="locationUri" value="/service1/" /&amp;gt;




  &amp;lt;property name="targetNamespace" value="my.service" /&amp;gt;




  &amp;lt;property name="soapActions"&amp;gt;




    &amp;lt;props&amp;gt;




      &amp;lt;prop key="UploadAddressMaterial"&amp;gt;SoapAction1&amp;lt;/prop&amp;gt;




    &amp;lt;/props&amp;gt;




  &amp;lt;/property&amp;gt;




&amp;lt;/bean&amp;gt;









&amp;lt;bean id="schema" class="org.springframework.xml.xsd.SimpleXsdSchema "&amp;gt;




  &amp;lt;property name="xsd" value="/WEB-INF/schema.xsd" /&amp;gt;




&amp;lt;/bean&amp;gt;






I&amp;amp;apos;m not using any kind of interceptors.
Actual ws end point extends AbstractStaxStreamPayloadEndpoint but the request doesn&amp;amp;apos;t get that far.
I get exception "com.sun.jdi.InvocationException occurred invoking method." when trying to invoke the web service in method org.springframework.ws.soap.axiom.AxiomSoapEnvelope.getBody().
Line 59 SOAPBody axiomBody = getAxiomEnvelope().getBody(); fails some how and the OMException on line 71 is catched. This leads to:
"Nested in org.springframework.ws.soap.axiom.AxiomSoapMessage Exception: Could not write message to OutputStream: problem accessing the parser. Parser already accessed!; nested exception is javax.xml.stream.XMLStreamException: problem accessing the parser. Parser already accessed!:
java.lang.IllegalStateException: Parser already accessed! "
I am running spring ws v.1.5.5 and spring core 2.5.6.
Everything works fine if payloadCaching is true.
Is this a bug? There is a resolved Jira that looks much the same: id SWS-359 </description>
			<version>1.5.5</version>
			<fixedVersion>1.5.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.NonCachingPayload.java</file>
			<file type="M">org.springframework.ws.server.endpoint.StaxStreamPayloadEndpointTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="459" opendate="2008-12-09 18:46:04" fixdate="2009-01-12 20:57:53" resolution="Fixed">
		<buginformation>
			<summary>Spring 1.5.x should depend on Spring 2.0.x as a minimum requirement</summary>
			<description>Spring 1.5.x should depend on Spring 2.0.x as a minimum requirement and not Spring 2.5.x. 
Log4J trace logging causes problems when using Spring 2.0.x because the toURI() method in org.springframework.util.ResourceUtils is not available in Spring core 2.0.x. 
As a workaround, changing the log level to INFO should resolve the issue. 
We should run the test suite against Spring 2.0.x to see if other problems arise.</description>
			<version>1.5.1</version>
			<fixedVersion>1.5.6</fixedVersion>
			<type>Refactoring</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.sax.SaxUtils.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpUrlConnection.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">467</link>
		</links>
	</bug>
	<bug id="473" opendate="2009-01-07 12:53:28" fixdate="2009-01-12 21:57:02" resolution="Fixed">
		<buginformation>
			<summary>JmsSenderConnection does not commit transaction after send, leading to messages never being sent if sessionTransacted is true</summary>
			<description>When sending a JMS message using a org.springframework.ws.transport.jms.JmsMessageSender with sessionTransacted set to true, the org.springframework.ws.transport.jms.JmsSenderConnection.onSendAfterWrite method doesn&amp;amp;apos;t commit the transaction.  This leads to the transaction being rolled back when the connection is closed so the message is never sent.  JMSUtils.commitIfNecessary should be called before closing the message producer.
An example of how this is done in JmsTemplate:






JmsTemplate.java






protected void doSend(Session session, Destination destination, MessageCreator messageCreator)




			throws JMSException {









		Assert.notNull(messageCreator, "MessageCreator must not be null");




		MessageProducer producer = createProducer(session, destination);




		try {




			Message message = messageCreator.createMessage(session);




			if (logger.isDebugEnabled()) {




				logger.debug("Sending created message: " + message);




			}




			doSend(producer, message);




			// Check commit - avoid commit call within a JTA transaction.




			if (session.getTransacted() &amp;amp;&amp;amp; isSessionLocallyTransacted(session)) {




				// Transacted session created by this template -&amp;gt; commit.




				JmsUtils.commitIfNecessary(session);




			}




		}




		finally {




			JmsUtils.closeMessageProducer(producer);




		}




	}






Similarly, the following should be done in JmsSenderConnection:






JmsSenderConnection.java






protected void onSendAfterWrite(WebServiceMessage message) throws IOException {




        MessageProducer messageProducer = null;




        try {




            messageProducer = session.createProducer(requestDestination);




            messageProducer.setDeliveryMode(deliveryMode);




            messageProducer.setTimeToLive(timeToLive);




            messageProducer.setPriority(priority);




            if (responseDestination == null) {




                responseDestination = session.createTemporaryQueue();




            }




            requestMessage.setJMSReplyTo(responseDestination);




            connection.start();




            messageProducer.send(requestMessage);




            if (session.getTransacted()) {




               JmsUtils.commitIfNecessary(session);




            }




        }




        catch (JMSException ex) {




            throw new JmsTransportException(ex);




        }




        finally {




            JmsUtils.closeMessageProducer(messageProducer);




        }




    }





</description>
			<version>1.5.3</version>
			<fixedVersion>1.5.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.jms.JmsSenderConnection.java</file>
			<file type="M">org.springframework.ws.transport.jms.JmsMessageSender.java</file>
		</fixedFiles>
	</bug>
	<bug id="469" opendate="2008-12-23 21:38:33" fixdate="2009-01-25 20:42:24" resolution="Fixed">
		<buginformation>
			<summary>Content type not set accouring to Http specification, RFC 2616</summary>
			<description>the AxiomSoapMessage and the SaajSoapMessage set the content-type  character-set incorrectly. 
The character set is surrounded by double quotes i.e "ISO-8859-1". the specification however states, $14.17 and $3.7 clearly state that this is not allowed. Although most servers do not complain about it, the one i use does 
Since the implementation is not confirming to specifications, i would say it&amp;amp;apos;s a bug.
Pieter</description>
			<version>1.5.5</version>
			<fixedVersion>1.5.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.AbstractSoapMessageTestCase.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessage.java</file>
		</fixedFiles>
	</bug>
	<bug id="465" opendate="2008-12-18 23:23:35" fixdate="2009-01-25 22:53:46" resolution="Fixed">
		<buginformation>
			<summary>Optional WS-Addressing request headers being treated as mandatory</summary>
			<description>Using SimpleActionEndpointMapping results in wsa:MessageAddressingHeaderRequired errors being returned from a request unless that request specifies
a wsa:To and wsa:MessageID header. According to the WS-Addressing standard, only the wsa:Action header is mandatory.
The problem appears to lie in the  hasRequiredProperties() method of org.springframework.ws.soap.addressing.MessageAddressingProperties. This method insists on
 1. wsa:To being present
 2. wsa:MessageID being present if either ReplyTo or FaultTo have been specified. 
In the case of (2) above I was able to trigger the fault by omitting all of the MessageID, ReplyTo and FaultTo headers in my request, so it may be that the server-side stack has inserted a default "anonymous endpoint" value into one or both of the latter and that is triggering the error.</description>
			<version>1.5.5</version>
			<fixedVersion>1.5.6</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.addressing.server.AddressingInterceptor10Test.java</file>
			<file type="M">org.springframework.ws.soap.addressing.version.AddressingVersion.java</file>
			<file type="M">org.springframework.ws.soap.addressing.server.AbstractAddressingInterceptorTestCase.java</file>
			<file type="M">org.springframework.ws.soap.addressing.version.Addressing200408.java</file>
			<file type="M">org.springframework.ws.soap.addressing.version.Addressing10.java</file>
			<file type="M">org.springframework.ws.soap.addressing.core.MessageAddressingProperties.java</file>
			<file type="M">org.springframework.ws.soap.addressing.server.AddressingEndpointInterceptor.java</file>
			<file type="M">org.springframework.ws.soap.addressing.version.AbstractAddressingVersion.java</file>
		</fixedFiles>
	</bug>
	<bug id="487" opendate="2009-02-17 19:37:14" fixdate="2009-02-17 20:45:06" resolution="Duplicate">
		<buginformation>
			<summary>CLONE -xml:lang="en" attribute in &lt;faultstring&gt; element is not compliant to SOAP/1.1 schema</summary>
			<description>There is xml:lang="en" attribute in &amp;lt;faultstring&amp;gt; element although SOAP/1.1 schema doesn&amp;amp;apos;t provide it.
Yes, it may be suppressed if set faultStringOrReasonLocale property for all affected endpoints to null,
set empty language for each and every exception mapping in SoapFaultMappingExceptionResolver (BTW, it is not
very well documented how to do it), set to null faultStringOrReasonLocale for message dispatcher,
oh did I forget something? 
Probably, it may as well be avoided by subclassing of each of above mentioned classes (and likely some others),
but then each developer need to use them. 
See as well http://www.eviware.com/component/option,com_smf/Itemid,53/topic,1044.0
IMHO, or it should comply with schema by default, or, in the worst case, it should exist some global setting 
"be compliant".
Kind regards,
Oleksandr
</description>
			<version>1.5.1</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoap11BodyTest.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapFaultDetailTest.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jTestCase.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoap11EnvelopeTest.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoapEnvelope.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessageFactory.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapEnvelope.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoapMessageFactory.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoap11BodyTest.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoap11Body.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoap12EnvelopeTest.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoap11Body.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessage.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoapMessage.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">485</link>
		</links>
	</bug>
	<bug id="486" opendate="2009-02-17 19:31:32" fixdate="2009-05-12 21:02:16" resolution="Fixed">
		<buginformation>
			<summary>SaajSoap11Body.getFault() does not conforms to interface specification - if no fault is present IllegalArgumentException is thrown instead of returning null.</summary>
			<description>Hi, 
the call 
  SoapFault bodyFault = body == null ? null : body.getFault();
returns following exception (line numbers are from Spring-WS 1.5.1, but relevant code is the same in 1.5.6 as well).
java.lang.IllegalArgumentException: element must not be null
	at org.springframework.util.Assert.notNull(Assert.java:112)
	at org.springframework.ws.soap.saaj.SaajSoapElement.&amp;lt;init&amp;gt;(SaajSoapElement.java:40)
	at org.springframework.ws.soap.saaj.SaajSoapFault.&amp;lt;init&amp;gt;(SaajSoapFault.java:36)
	at org.springframework.ws.soap.saaj.SaajSoap11Fault.&amp;lt;init&amp;gt;(SaajSoap11Fault.java:34)
	at org.springframework.ws.soap.saaj.SaajSoap11Body.getFault(SaajSoap11Body.java:45)
	at com.navteq.ncs.common.core.utils.aop.EndpointInvokeInterceptor.checkResult(EndpointInvokeInterceptor.java:46)
while SoapBody interface Javadoc states for this method:
Returns:
the SoapFault, or null if none is present
The getFault() method in the class SaajSoap11Body may be modified as follows 
    public SoapFault getFault() 
{
        SOAPFault fault = getImplementation().getFault(getSaajBody());
        return fault==null ? null : new SaajSoap11Fault(fault);
    }</description>
			<version>1.5.1</version>
			<fixedVersion>1.5.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoap12Body.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoap11Body.java</file>
		</fixedFiles>
	</bug>
	<bug id="494" opendate="2009-03-12 23:52:26" fixdate="2009-05-12 22:27:34" resolution="Fixed">
		<buginformation>
			<summary>AbstractHttpSenderConnection  getErrorMessage() </summary>
			<description>I have situation where AbstractHttpSenderConnection.getResponseMessage() returns null which results in NullPointerException at AbstractHttpSenderConnection.getErrorMessage() due to the construcor of StringBuffer  ( when passed String to the StringBuffer it tries to get it&amp;amp;apos;s length ) I can&amp;amp;apos;t imagine why null is not casted to "null" 
StringBuffer buffer = new StringBuffer(getResponseMessage()); </description>
			<version>1.5.6</version>
			<fixedVersion>1.5.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.AbstractHttpSenderConnection.java</file>
		</fixedFiles>
	</bug>
	<bug id="485" opendate="2009-02-12 01:42:21" fixdate="2009-05-13 22:38:15" resolution="Fixed">
		<buginformation>
			<summary>xml:lang="en" attribute in &lt;faultstring&gt; element is not compliant to SOAP/1.1 schema</summary>
			<description>There is xml:lang="en" attribute in &amp;lt;faultstring&amp;gt; element although SOAP/1.1 schema doesn&amp;amp;apos;t provide it.
Yes, it may be suppressed if set faultStringOrReasonLocale property for all affected endpoints to null,
set empty language for each and every exception mapping in SoapFaultMappingExceptionResolver (BTW, it is not
very well documented how to do it), set to null faultStringOrReasonLocale for message dispatcher,
oh did I forget something? 
Probably, it may as well be avoided by subclassing of each of above mentioned classes (and likely some others),
but then each developer need to use them. 
See as well http://www.eviware.com/component/option,com_smf/Itemid,53/topic,1044.0
IMHO, or it should comply with schema by default, or, in the worst case, it should exist some global setting 
"be compliant".
Kind regards,
Oleksandr
</description>
			<version>1.5.1</version>
			<fixedVersion>1.5.7</fixedVersion>
			<type>Improvement</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoap11BodyTest.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapFaultDetailTest.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jTestCase.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoap11EnvelopeTest.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoapEnvelope.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessageFactory.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapEnvelope.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoapMessageFactory.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoap11BodyTest.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoap11Body.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoap12EnvelopeTest.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoap11Body.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessage.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoapMessage.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">487</link>
		</links>
	</bug>
	<bug id="496" opendate="2009-03-24 01:35:41" fixdate="2009-05-17 21:19:21" resolution="Fixed">
		<buginformation>
			<summary>SpringWS client does not send Mtom attachments - it inlines them instead.</summary>
			<description>The actual problem that I have is that I cannot send large attachments with SpringWS-client.
I suspect the cause is that MTOM encoding in Spring does not work, even though mtomEnabled in org.springframework.oxm.jaxb.Jaxb2Marshaller is set to true. Without MTOM encoding the whole attachment is inlined, in memory, and then OutOfMemoryErrors can quickly occur.
With a Tcp monitor you can see that MTOM does in not work, while it does work with Axis. I demonstrate this in an Eclipse project, that I will try to attach to this issue.
Because of this, we are now forced to use Axis in our otherwise Spring-dominated project. This is quite unsatisfying.</description>
			<version>1.5.6</version>
			<fixedVersion>1.5.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.samples.mtom.service.StubImageRepository.java</file>
			<file type="D">org.springframework.ws.samples.mtom.client.sws.MtomClient.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessage.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessageFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="502" opendate="2009-04-23 21:12:32" fixdate="2009-05-18 20:24:44" resolution="Fixed">
		<buginformation>
			<summary>Soap envelope rpc-encoded namespace issue </summary>
			<description>I have an rpc-encoded soap envelope containing the declarations of soapenv (xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/") and xsi (xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance") namespaces. 
The first element of the soap body references soapenv in one of his attributes (soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"). Some xml elements in the soap body reference the xsi namespace (xsi:type="soapenc:string") as well.
When I try to parse the soap body (extracted from the soap envelope) using JDOM or DOM4J I get a SaxParseException because the soapenv and xsi namespaces are not bound:
org.xml.sax.SAXParseException: The prefix "soapenv" for attribute "soapenv:encodingStyle" associated with an element type "ns1:sendMessage" is not bound.
The issue seems to be creating a org.springframework.xml.transform.StaxSource using XMLStreamReader from Axiom payload element and transforming it to a StreamResult.
I have found a workaround transforming the StaxSource in a JDOMResult instead of a StreamResult.
The problem is the same as using javax.xml.transform.stax.StAXSource; some Axiom developers have suggested me to use OMSource from a snapshot version (https://issues.apache.org/jira/browse/WSCOMMONS-459) instead of StAXSource.
The problem is in org.springframework.ws.soap.axiom.Payload#getSource() that uses XMLStreamReader class: namespace declarations is ok if I use OMSource from the snapshot version of axiom (the abstract method getStreamReader() is never used in this solution).</description>
			<version>1.5.6</version>
			<fixedVersion>1.5.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoap11MessageFactoryTest.java</file>
			<file type="M">org.springframework.xml.stream.StaxStreamXmlReader.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">509</link>
		</links>
	</bug>
	<bug id="483" opendate="2009-02-10 04:11:05" fixdate="2009-05-19 22:29:56" resolution="Fixed">
		<buginformation>
			<summary>Wss4j 1.5.5 stripping custom SOAP headers after 1.5.6 upgrade</summary>
			<description>I upgraded an existing spring-ws app from 1.5.5 to 1.5.6, and also upgraded dependencies bundled in the with-dependencies release, specifically upgraded wss4j jar from 1.5.4 to 1.5.5 and xmlsec from 1.4.0 to 1.4.2. Now wss4j 1.5.5 somehow strips out my custom SOAP headers on the client side from the request message. Both client and server use spring-ws, I am using Axiom soap message factory (payloadCaching=true), Wss4j for ws-security, running the application in Tomcat 6 with Sun Java 5 jvm. 
Rolling back wss4j libs to wss4j-1.5.4.jar and xmlsec-1.4.0.jar fixes the problem (keeping the other spring-ws 1.5.6 release jars), therefore I suspect this is a Wss4j-1.5.5 bug, but other causes are possible (see other observations below).  Proposed solution: roll back the bundled Wss4j jars to wss4j 1.5.4 and xmlsec 1.4.0.  
Other observations: 
1. Sending the SOAP request using soapUI instead of the spring-ws client fixes the problem, proving that the headers are stripped by the spring-ws client.
2. Removing Wss4j security interceptor fixes the problem. 
3. Switching to SaajSoapMessageFactory fixes the problem.
4. Spring-ws client trace logger logs the sent SOAP message WITH the custom soap headers intact, so the headers are stripped after the logging code is executed. 
Attached is a sample that reproduces the problem.  The sample is a slightly modified echo spring-ws sample pre-configured as an Eclipse project folder.  The echo sample was modified to use Wss4j security interceptor, Axiom Soap message factory and I added the code to add custom Soap headers.  To reproduce, import the sample into an Eclipse 3.* workspace, deploy spring-ws-echo war to a servlet container, and run org.echo.client.sws.EchoClient as Java applicatio. The logged Soap request on the client contains the "customSoapHeader" header element, but on the server side the same request Soap message is missing this header. </description>
			<version>1.5.6</version>
			<fixedVersion>1.5.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.support.AxiomUtils.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jTestCase.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jMessageInterceptorHeaderTestCase.java</file>
		</fixedFiles>
	</bug>
	<bug id="482" opendate="2009-02-09 20:20:31" fixdate="2009-05-19 22:36:05" resolution="Fixed">
		<buginformation>
			<summary>java.lang.IllegalStateException: Connection factory has been shutdown</summary>
			<description>spring-ws does not seem to correctly reinitialize the httpclient connection manager under certain circumstances






Caused by: java.lang.IllegalStateException: Connection factory has been shutdown.




	at org.apache.commons.httpclient.MultiThreadedHttpConnectionManager.doGetConnection(MultiThreadedHttpConnectionManager.java:456)




	at org.apache.commons.httpclient.MultiThreadedHttpConnectionManager.getConnectionWithTimeout(MultiThreadedHttpConnectionManager.java:394)




	at org.apache.commons.httpclient.HttpMethodDirector.executeMethod(HttpMethodDirector.java:152)




	at org.apache.commons.httpclient.HttpClient.executeMethod(HttpClient.java:396)




	at org.apache.commons.httpclient.HttpClient.executeMethod(HttpClient.java:324)




	at org.springframework.ws.transport.http.CommonsHttpConnection.onSendAfterWrite(CommonsHttpConnection.java:100)




	at org.springframework.ws.transport.AbstractWebServiceConnection.send(AbstractWebServiceConnection.java:44)




	at org.springframework.ws.client.core.WebServiceTemplate.sendRequest(WebServiceTemplate.java:585)




	at org.springframework.ws.client.core.WebServiceTemplate.doSendAndReceive(WebServiceTemplate.java:548)




	at org.springframework.ws.client.core.WebServiceTemplate.sendAndReceive(WebServiceTemplate.java:501)




	at org.springframework.ws.client.core.WebServiceTemplate.doSendAndReceive(WebServiceTemplate.java:456)




	at org.springframework.ws.client.core.WebServiceTemplate.sendSourceAndReceiveToResult(WebServiceTemplate.java:402)




	at org.springframework.ws.client.core.WebServiceTemplate.sendSourceAndReceiveToResult(WebServiceTemplate.java:393)




	at org.springframework.ws.client.core.WebServiceTemplate.sendSourceAndReceiveToResult(WebServiceTemplate






i cannot come up with a reproducible testcase for the moment, but when it happens it is always after we redeploy our application (weblogic 9.2MP2). It is quite an impacting annoyance because we have to restart the server to get things back in line.</description>
			<version>1.5.5</version>
			<fixedVersion>1.5.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.CommonsHttpMessageSender.java</file>
		</fixedFiles>
		<links>
			<link type="Related" description="is related to">564</link>
		</links>
	</bug>
	<bug id="509" opendate="2009-05-13 01:38:11" fixdate="2009-05-19 22:47:20" resolution="Duplicate">
		<buginformation>
			<summary>Namespace prefix in attribute value not resolved correctly</summary>
			<description>I have following SOAP request. 






 




&amp;lt;soapenv:Envelope  xmlns:ns="http://schemas.qqq.com/wsdl/spi/profile/1.0" xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&amp;gt;




   &amp;lt;soapenv:Header/&amp;gt;




   &amp;lt;soapenv:Body&amp;gt;




      &amp;lt;ns:getRights&amp;gt; 




            &amp;lt;ns:customerCredential xsi:type="ns:CustomerCredentialMsisdn"&amp;gt;




               &amp;lt;ns:msisdn&amp;gt;420123456789&amp;lt;/ns:msisdn&amp;gt;




            &amp;lt;/ns:customerCredential&amp;gt;




      &amp;lt;/ns:getRights&amp;gt;




   &amp;lt;/soapenv:Body&amp;gt;




&amp;lt;/soapenv:Envelope&amp;gt;






When umarshalling is called only the payload is passed to the unmarshaller. So DOM equivalent of following is used






 




&amp;lt;ns:getRights&amp;gt; 




            &amp;lt;ns:customerCredential xsi:type="ns:CustomerCredentialMsisdn"&amp;gt;




               &amp;lt;ns:msisdn&amp;gt;420123456789&amp;lt;/ns:msisdn&amp;gt;




            &amp;lt;/ns:customerCredential&amp;gt;




&amp;lt;/ns:getRights&amp;gt;






Please note that namespace prefix ns is not defined. Usually this is not a problem since in DOM namespaces are already resolved. There is one exception - attribute value. When XmlBeans try to unmarshall the element, they are not able to resolve the namespace and do not work correctly. I assume that Spring-WS should somehow take this situation into account. 
If following request is used (the only difference is position of ns prefix declaration) everything works fine






 




&amp;lt;soapenv:Envelope  xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&amp;gt;




   &amp;lt;soapenv:Header/&amp;gt;




   &amp;lt;soapenv:Body&amp;gt;




      &amp;lt;ns:getRights xmlns:ns="http://schemas.qqq.com/wsdl/spi/profile/1.0"&amp;gt; 




            &amp;lt;ns:customerCredential xsi:type="ns:CustomerCredentialMsisdn"&amp;gt;




               &amp;lt;ns:msisdn&amp;gt;420123456789&amp;lt;/ns:msisdn&amp;gt;




            &amp;lt;/ns:customerCredential&amp;gt;




      &amp;lt;/ns:getRights&amp;gt;




   &amp;lt;/soapenv:Body&amp;gt;




&amp;lt;/soapenv:Envelope&amp;gt;





 </description>
			<version>1.5.6</version>
			<fixedVersion>1.5.7</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoap11MessageFactoryTest.java</file>
			<file type="M">org.springframework.xml.stream.StaxStreamXmlReader.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">502</link>
			<link type="Related" description="is related to">523</link>
		</links>
	</bug>
	<bug id="520" opendate="2009-05-25 18:32:28" fixdate="2009-06-02 01:29:13" resolution="Fixed">
		<buginformation>
			<summary>HTTP Accept header field contains invalid type, and omits text/xml</summary>
			<description>The Spring-WS client sends an HTTP Accept  request-header field that is invalid according to the HTTP 1.1 spec.
The header that the Spring-WS client sends is:
   Accept: text/html, image/gif, image/jpeg, ; q=.2, */; q=.2
The fourth media-range in this field does not include the mandatory "/" and subtype.
The definition of the Accept header in the HTTP 1.1 spec (http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html) is:
    Accept         = "Accept" ":"
                        #( media-range [ accept-params ] )
       media-range    = ( "/"


 ( type "/" "*" )


 ( type "/" subtype )
                        ) *( ";" parameter )


I would have also expected the Accept header field to contain "text/xml" explicitly (for SOAP 1.1), and not to Accept "text/html", "image/gif" or "image/jpeg". 
My spring-client-context.xml is:
&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;
&amp;lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd"&amp;gt;
  &amp;lt;bean id="messageFactory" class="org.springframework.ws.soap.axiom.AxiomSoapMessageFactory"&amp;gt;
    &amp;lt;property name="payloadCaching" value="false" /&amp;gt;
  &amp;lt;/bean&amp;gt;
  &amp;lt;bean id="webServiceTemplate" class="org.springframework.ws.client.core.WebServiceTemplate"&amp;gt;
    &amp;lt;property name="marshaller" ref="marshaller" /&amp;gt;
    &amp;lt;property name="unmarshaller" ref="marshaller" /&amp;gt;
    &amp;lt;property name="defaultUri" value="http://localhost:8079/jibx-ws-seismic/soap/quake-service" /&amp;gt;
    &amp;lt;property name="messageFactory" ref="messageFactory"/&amp;gt;
  &amp;lt;/bean&amp;gt;
  &amp;lt;!-- A JiBX-based payload marshaller/unmarshaller.  --&amp;gt;
  &amp;lt;bean id="marshaller" class="org.springframework.oxm.jibx.JibxMarshaller"&amp;gt;
    &amp;lt;property name="targetClass" value="com.sosnoski.seismic.common.Query" /&amp;gt;
  &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;</description>
			<version>1.5.7</version>
			<fixedVersion>1.5.8</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.soap12.AbstractSoap12MessageTestCase.java</file>
			<file type="M">org.springframework.ws.soap.soap11.AbstractSoap11MessageTestCase.java</file>
			<file type="M">org.springframework.ws.transport.TransportConstants.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessage.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoapMessage.java</file>
		</fixedFiles>
	</bug>
	<bug id="545" opendate="2009-07-27 17:11:44" fixdate="2009-08-02 19:05:48" resolution="Fixed">
		<buginformation>
			<summary>IllegalArgumentException on AxiomSoap11Body.addFault</summary>
			<description>I have created a custom ExceptionResolver below:






MyExceptionResolver .java






public class MyExceptionResolver  extends AbstractSoapFaultDefinitionExceptionResolver {




	@Override




protected SoapFaultDefinition getFaultDefinition(Object endpoint,




		Exception ex) {		




	QName messageDeliveryFaultQName = new QName(INVOKER_NS_URI, "MessageDeliveryFault", "invoker");




	QName messageDeliveryFaultQNameNOPREFIX = new QName(INVOKER_NS_URI, "MessageDeliveryFault");









	if (ex instanceof WebServiceTransportException) {




		SoapFaultDefinition soapFaultDefinition = new SoapFaultDefinition();




		soapFaultDefinition.setFaultCode(messageDeliveryFaultQNameNOPREFIX );




			




		soapFaultDefinition.setFaultStringOrReason(ex.getMessage());	




		return soapFaultDefinition;




	}




	return null;




}




}






if I use the messageDeliveryFaultQNameNOPREFIX Qname as the fault code I get:






java.lang.IllegalArgumentException: Could not resolve namespace of code [{urn:www.thiess.com.au:services:eProcurement:QuadremInvoker:v1}MessageDeliveryFault]




	at org.springframework.ws.soap.axiom.AxiomSoap11Body.setValueText(AxiomSoap11Body.java:117)




	at org.springframework.ws.soap.axiom.AxiomSoap11Body.addFault(AxiomSoap11Body.java:92)




	at org.springframework.ws.soap.server.endpoint.AbstractSoapFaultDefinitionExceptionResolver.resolveExceptionInternal(AbstractSoapFaultDefinitionExceptionResolver.java:89)




	at org.springframework.ws.server.endpoint.AbstractEndpointExceptionResolver.resolveException(AbstractEndpointExceptionResolver.java:106)




	at org.springframework.ws.server.MessageDispatcher.processEndpointException(MessageDispatcher.java:311)




	at org.springframework.ws.server.MessageDispatcher.dispatch(MessageDispatcher.java:235)




	at org.springframework.ws.server.MessageDispatcher.receive(MessageDispatcher.java:168)




	at org.springframework.ws.transport.support.WebServiceMessageReceiverObjectSupport.handleConnection(WebServiceMessageReceiverObjectSupport.java:88)




	at org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.handle(WebServiceMessageReceiverHandlerAdapter.java:57)




	at org.springframework.ws.transport.http.MessageDispatcherServlet.doService(MessageDispatcherServlet.java:230)




	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:523)




	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:463)






The other  Qname with a prefix works fine.</description>
			<version>1.5.7</version>
			<fixedVersion>1.5.8</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoap11BodyTest.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoap11Body.java</file>
			<file type="M">org.springframework.ws.soap.soap11.AbstractSoap11BodyTestCase.java</file>
		</fixedFiles>
	</bug>
	<bug id="550" opendate="2009-08-11 06:31:53" fixdate="2009-08-12 22:33:42" resolution="Fixed">
		<buginformation>
			<summary>Jaxb2Marshaller.createJaxbContext() doesn&amp;apos;t respect provided classloader when checking JAXB version</summary>
			<description>Jaxb2Marshaller.createJaxbContext() checks the JAXB version using JaxbUtils
        if (JaxbUtils.getJaxbVersion() &amp;lt; JaxbUtils.JAXB_2) 
{
            throw new IllegalStateException(
                    "Cannot use Jaxb2Marshaller in combination with JAXB 1.0. Use Jaxb1Marshaller instead.");
        }

But this is incorrect because JaxbUtils is checking the version by seeing if it can load javax.xml.bind.Binder using the ClassUtils&amp;amp;apos; getDefaultClassLoader. Instead it should use the supplied classloader set via setBeanClassLoader in Jaxb2Marshaller.</description>
			<version>1.5.7</version>
			<fixedVersion>1.5.8</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.oxm.jaxb.Jaxb2Marshaller.java</file>
			<file type="M">org.springframework.oxm.jaxb.JaxbUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="517" opendate="2009-05-22 10:15:07" fixdate="2009-08-13 21:52:49" resolution="Fixed">
		<buginformation>
			<summary>Soap response validation errors after update to 1.5.7</summary>
			<description>Upgrade from SpringWS 1.5.6 to 1.5.7 and update.  - No code changes. 
After upgrade error "java.lang.ArrayIndexOutOfBoundsException: -1" was thrown during validation. Turning validation off works as a workaround.
my Soap API has 130 calls. Most respones were working fine, not all were tested. I wonder if It might have something to do with the size of the response, all other tested responses were pretty small,  see forum post for bean configurations, errors and response sample.
</description>
			<version>1.5.7</version>
			<fixedVersion>1.5.8</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.namespace.SimpleNamespaceContextTest.java</file>
			<file type="M">org.springframework.xml.namespace.SimpleNamespaceContext.java</file>
			<file type="M">org.springframework.xml.stream.StaxStreamXmlReader.java</file>
			<file type="M">org.springframework.ws.soap.server.endpoint.interceptor.PayloadValidatingInterceptorTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="571" opendate="2009-09-21 02:53:18" fixdate="2009-09-21 21:16:14" resolution="Fixed">
		<buginformation>
			<summary>Illegal SoapAction header: "</summary>
			<description>It seems that spring ws generates an illegal soapaction if no explicit soapaction is provided: an unmatched double quote. 
A quick look at the SoapUtils class shows the problem:






 public static String escapeAction(String soapAction) {




        if (soapAction == null) {




            soapAction = "";




        }




        if (!soapAction.startsWith("\"")) {




            soapAction = "\"" + soapAction;




        }




        if (!soapAction.endsWith("\"")) {




            soapAction = soapAction + "\"";




        }




        return soapAction;




    }






If you pass null as argument, it will return " instead of ""</description>
			<version>1.5.8</version>
			<fixedVersion>1.5.9</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.support.SoapUtilsTest.java</file>
			<file type="M">org.springframework.ws.soap.support.SoapUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="560" opendate="2009-08-27 18:39:39" fixdate="2009-11-09 20:33:03" resolution="Fixed">
		<buginformation>
			<summary>IllegalStateException: Could not find SAAJ on the classpath after upgrading from 1.5.7 to 1.5.8</summary>
			<description>Seems there is something wrong in fix for SWS-525 (r1427 on svn), saaj version doesn&amp;amp;apos;t get resolved well in case where a SOAP message&amp;amp;apos;s envelope has a body with elements that reference a non-declared namespace/prefix like in following:
&amp;lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;
   &amp;lt;soapenv:Header/&amp;gt;
   &amp;lt;soapenv:Body&amp;gt;
      &amp;lt;ndns:DoSomethingRequest/&amp;gt;
   &amp;lt;/soapenv:Body&amp;gt;
&amp;lt;/soapenv:Envelope&amp;gt;
Such messages would previously (with SWS 1.5.7) result in SOAP Fault with Server faultcode and faultstring:
Could not access envelope: Unable to create envelope from given source: ; nested exception is com.sun.xml.internal.messaging.saaj.SOAPExceptionImpl: Unable to create envelope from given source:
while now (with SWS 1.5.8) a HTTP error 500 is returned with following stack trace:
java.lang.IllegalStateException: Could not find SAAJ on the classpath
	at org.springframework.ws.soap.saaj.SaajSoapMessage.getImplementation(SaajSoapMessage.java:261)
	at org.springframework.ws.soap.saaj.SaajSoapMessage.&amp;lt;init&amp;gt;(SaajSoapMessage.java:84)
	at org.springframework.ws.soap.saaj.SaajSoapMessage.&amp;lt;init&amp;gt;(SaajSoapMessage.java:70)
	at org.springframework.ws.soap.saaj.SaajSoapMessageFactory.createWebServiceMessage(SaajSoapMessageFactory.java:168)
	at org.springframework.ws.transport.AbstractWebServiceConnection.receive(AbstractWebServiceConnection.java:86)
	at org.springframework.ws.transport.support.WebServiceMessageReceiverObjectSupport.handleConnection(WebServiceMessageReceiverObjectSupport.java:86)
	at org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.handle(WebServiceMessageReceiverHandlerAdapter.java:57)
	at org.springframework.ws.transport.http.MessageDispatcherServlet.doService(MessageDispatcherServlet.java:230)
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:571)
	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:511)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:727)
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:820)
	at org.mortbay.jetty.servlet.ServletHolder.handle(ServletHolder.java:502)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1157)
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:96)
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76)
	at org.mortbay.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1148)
	at org.mortbay.jetty.servlet.ServletHandler.handle(ServletHandler.java:387)
	at org.mortbay.jetty.security.SecurityHandler.handle(SecurityHandler.java:216)
	at org.mortbay.jetty.servlet.SessionHandler.handle(SessionHandler.java:181)
	at org.mortbay.jetty.handler.ContextHandler.handle(ContextHandler.java:765)
	at org.mortbay.jetty.webapp.WebAppContext.handle(WebAppContext.java:417)
	at org.mortbay.jetty.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:230)
	at org.mortbay.jetty.handler.HandlerCollection.handle(HandlerCollection.java:114)
	at org.mortbay.jetty.handler.HandlerWrapper.handle(HandlerWrapper.java:152)
	at org.mortbay.jetty.Server.handle(Server.java:326)
	at org.mortbay.jetty.HttpConnection.handleRequest(HttpConnection.java:534)
	at org.mortbay.jetty.HttpConnection$RequestHandler.content(HttpConnection.java:879)
	at org.mortbay.jetty.HttpParser.parseNext(HttpParser.java:747)
	at org.mortbay.jetty.HttpParser.parseAvailable(HttpParser.java:218)
	at org.mortbay.jetty.HttpConnection.handle(HttpConnection.java:404)
	at org.mortbay.io.nio.SelectChannelEndPoint.run(SelectChannelEndPoint.java:409)
	at org.mortbay.thread.QueuedThreadPool$PoolThread.run(QueuedThreadPool.java:520)
even though saaj api and impl 1.3 are on the path.</description>
			<version>1.5.8</version>
			<fixedVersion>1.5.9</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.saaj.support.SaajUtils.java</file>
			<file type="M">org.springframework.ws.soap.saaj.support.SaajUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">569</link>
		</links>
	</bug>
	<bug id="566" opendate="2009-09-14 23:38:17" fixdate="2009-11-10 00:50:29" resolution="Fixed">
		<buginformation>
			<summary>DelegatingSoapEndpointMapping produce NPE</summary>
			<description>





    public EndpointInvocationChain getEndpoint(MessageContext messageContext) throws Exception {




        EndpointInvocationChain delegateChain = delegate.getEndpoint(messageContext);




        return new SoapEndpointInvocationChain(delegateChain.getEndpoint(), delegateChain.getInterceptors(),




                actorsOrRoles, isUltimateReceiver);




    }






delegate.getEndpoint() can return null </description>
			<version>1.5.8</version>
			<fixedVersion>1.5.9</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.server.endpoint.mapping.DelegatingSoapEndpointMapping.java</file>
		</fixedFiles>
	</bug>
	<bug id="569" opendate="2009-09-16 04:31:30" fixdate="2009-11-10 00:52:15" resolution="Duplicate">
		<buginformation>
			<summary>Refactored SaajSoapMessage getImplementation() method hides root cause problems</summary>
			<description>Under 1.5.7, I have a problematic web service that causes the following exception to be thrown from WebServiceTemplate (stack trace edited for brevity):
org.springframework.ws.soap.saaj.SaajSoapEnvelopeException: Could not access envelope: Unable to create envelope from given source: ; nested exception is com.sun.xml.messaging.saaj.SOAPExceptionImpl: Unable to create envelope from given source: 
  at org.springframework.ws.soap.saaj.SaajSoapMessage.getEnvelope(SaajSoapMessage.java:107)
Caused by: javax.xml.transform.TransformerException: org.w3c.dom.DOMException: NAMESPACE_ERR: An attempt is made to create or change an object in a way which is incorrect with regard to namespaces.
  at org.apache.xalan.transformer.TransformerIdentityImpl.transform(TransformerIdentityImpl.java:449)
  at com.sun.xml.messaging.saaj.util.transform.EfficientStreamingTransformer.transform(EfficientStreamingTransformer.java:411)
  at com.sun.xml.messaging.saaj.soap.EnvelopeFactory.createEnvelope(EnvelopeFactory.java:113)
  ... 35 more
Caused by: org.w3c.dom.DOMException: NAMESPACE_ERR: An attempt is made to create or change an object in a way which is incorrect with regard to namespaces.
  at org.apache.xml.utils.DOMBuilder.startElement(DOMBuilder.java:322)
  at org.apache.xalan.transformer.TransformerIdentityImpl.startElement(TransformerIdentityImpl.java:1020)
This exception, while annoying, contains enough information to get on with.
Under 1.5.8, however, the changes to SaajSoapMessage mean that all I get is:
java.lang.IllegalStateException: Could not find SAAJ on the classpath
  at org.springframework.ws.soap.saaj.SaajSoapMessage.getImplementation(SaajSoapMessage.java:261)
  at org.springframework.ws.soap.saaj.SaajSoapMessage.&amp;lt;init&amp;gt;(SaajSoapMessage.java:84)
  at org.springframework.ws.soap.saaj.SaajSoapMessage.&amp;lt;init&amp;gt;(SaajSoapMessage.java:70)
  at org.springframework.ws.soap.saaj.SaajSoapMessageFactory.createWebServiceMessage(SaajSoapMessageFactory.java:168)
This is a weird side-effect, since several prior web service calls have been made without a problem. It&amp;amp;apos;s very difficult to reproduce reliably since 1.5.8 is hiding a lot behid the scenes when building this message.</description>
			<version>1.5.8</version>
			<fixedVersion>1.5.9</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.saaj.support.SaajUtils.java</file>
			<file type="M">org.springframework.ws.soap.saaj.support.SaajUtilsTest.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">560</link>
		</links>
	</bug>
	<bug id="579" opendate="2009-10-22 03:35:16" fixdate="2009-11-10 01:07:39" resolution="Fixed">
		<buginformation>
			<summary>AxiomSoapMessageFactory does not parse application/xop+xml Content-Type properly</summary>
			<description>AxiomSoapMessageFactory#getCharSetEncoding(), when given the following HTTP Content-Type header (which I assume is valid),
application/xop+xml;type="text/xml; charset=utf-8"
returns a CharSet of &amp;amp;apos;utf-8"&amp;amp;apos; instead of &amp;amp;apos;utf-8&amp;amp;apos; (i.e. there is an erroneous double quote at the end of the string).</description>
			<version>1.5.8</version>
			<fixedVersion>1.5.9</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoap11MessageFactoryTest.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessageFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="521" opendate="2009-05-27 07:03:09" fixdate="2009-11-10 02:39:59" resolution="Fixed">
		<buginformation>
			<summary>UnsupportedOperationException During Validation After Upgrade From 1.5.6 to 1.5.7</summary>
			<description>After upgrading from 1.5.6 to 1.5.7, a test where I have client-side validation turned on failed with the following stack trace.  Reverting to 1.5.6 made the problem disappear:
java.lang.UnsupportedOperationException
        at java.util.AbstractList.add(AbstractList.java:131)
        at java.util.AbstractList.add(AbstractList.java:91)
        at org.springframework.xml.namespace.SimpleNamespaceContext.bindNamespaceUri(SimpleNamespaceContext.java:108)
        at org.springframework.xml.stream.StaxStreamXmlReader.startPrefixMapping(StaxStreamXmlReader.java:171)
        at org.springframework.xml.stream.StaxStreamXmlReader.handleStartElement(StaxStreamXmlReader.java:145)
        at org.springframework.xml.stream.StaxStreamXmlReader.parseInternal(StaxStreamXmlReader.java:80)
        at org.springframework.xml.stream.AbstractStaxXmlReader.parse(AbstractStaxXmlReader.java:128)
        at org.springframework.xml.stream.AbstractStaxXmlReader.parse(AbstractStaxXmlReader.java:111)
        at org.apache.xerces.jaxp.validation.ValidatorHandlerImpl.validate(Unknown Source)
        at org.apache.xerces.jaxp.validation.ValidatorImpl.validate(Unknown Source)
        at javax.xml.validation.Validator.validate(Validator.java:127)
        at org.springframework.xml.validation.Jaxp13ValidatorFactory$Jaxp13Validator.validate(Jaxp13ValidatorFactory.java:61)
        at org.springframework.ws.client.support.interceptor.AbstractValidatingInterceptor.handleRequest(AbstractValidatingInterceptor.java:171)
        at org.springframework.ws.client.core.WebServiceTemplate.doSendAndReceive(WebServiceTemplate.java:542)
        at org.springframework.ws.client.core.WebServiceTemplate.sendAndReceive(WebServiceTemplate.java:502)
        at org.springframework.ws.client.core.WebServiceTemplate.doSendAndReceive(WebServiceTemplate.java:457)
        at org.springframework.ws.client.core.WebServiceTemplate.sendSourceAndReceiveToResult(WebServiceTemplate.java:403)
        at org.springframework.ws.client.core.WebServiceTemplate.sendSourceAndReceiveToResult(WebServiceTemplate.java:394)
        at org.springframework.ws.client.core.WebServiceTemplate.sendSourceAndReceiveToResult(WebServiceTemplate.java:384)</description>
			<version>1.5.7</version>
			<fixedVersion>1.5.9</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.server.endpoint.interceptor.PayloadValidatingInterceptorTest.java</file>
			<file type="M">org.springframework.xml.namespace.SimpleNamespaceContext.java</file>
			<file type="M">org.springframework.xml.namespace.SimpleNamespaceContextTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="572" opendate="2009-09-23 19:48:07" fixdate="2009-11-10 20:29:55" resolution="Fixed">
		<buginformation>
			<summary>The default encoding is not set to UTF-8 for JibxMarshaller</summary>
			<description>In the class "org.springframework.oxm.jibx.JibxMarshaller" the default encoding is not set to UTF-8 as specified in the Java-Doc of the method &amp;amp;apos;setEncoding()&amp;amp;apos;.
Therefore, when we marshal an object with "org.springframework.oxm.jibx.JibxMarshaller", the output XML does not contain the encoding attribute:
&amp;lt;?xml version="1.0"?&amp;gt;
instead of
&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;</description>
			<version>1.5.8</version>
			<fixedVersion>1.5.9</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.oxm.jibx.JibxMarshaller.java</file>
		</fixedFiles>
	</bug>
	<bug id="576" opendate="2009-10-13 20:40:26" fixdate="2009-11-10 21:02:04" resolution="Fixed">
		<buginformation>
			<summary>sentMessageTracingLogger  skips request message headerer content </summary>
			<description>In org.springframework.ws.server.MessageDispatcher class sentMessageTracingLogger with trace level does not log the same request message as the one being logged by receivedMessageTracingLogger.
I&amp;amp;apos;ve noticed that request message having &amp;lt;SOAP-ENV:Header&amp;gt; with wss4j stuff is properly logged by receivedMessageTracingLogger on trace level:






Received request [&amp;lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;




&amp;lt;SOAP-ENV:Header&amp;gt;




&amp;lt;wsse:Security xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd" SOAP-ENV:mustUnderstand="1"&amp;gt;




&amp;lt;wsse:UsernameToken xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" wsu:Id="UsernameToken-21398464"&amp;gt;




&amp;lt;wsse:Username&amp;gt;876543&amp;lt;/wsse:Username&amp;gt;




&amp;lt;wsse:Password Type="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordText"&amp;gt;a701050a4e03ef54319c319c9a06a895&amp;lt;/wsse:Password&amp;gt;




&amp;lt;/wsse:UsernameToken&amp;gt;




&amp;lt;/wsse:Security&amp;gt;




&amp;lt;/SOAP-ENV:Header&amp;gt;




&amp;lt;SOAP-ENV:Body&amp;gt;....&amp;lt;/SOAP-ENV:Body&amp;gt;&amp;lt;/SOAP-ENV:Envelope&amp;gt;] 






Unfortunately sentMessageTracingLogger strips out content of &amp;lt;SOAP-ENV:Header&amp;gt; when logging request message:






Sent response [------=_Part_18_463346590.1255441172093




Content-Type: application/xop+xml; type="text/xml"; charset=utf-8









&amp;lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;




&amp;lt;SOAP-ENV:Header/&amp;gt;




&amp;lt;SOAP-ENV:Body&amp;gt;...&amp;lt;/SOAP-ENV:Body&amp;gt;&amp;lt;/SOAP-ENV:Envelope&amp;gt;




------=_Part_18_463346590.1255441172093--] for request [&amp;lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;&amp;lt;SOAP-ENV:Header&amp;gt;




&amp;lt;/SOAP-ENV:Header&amp;gt;&amp;lt;SOAP-ENV:Body&amp;gt;...&amp;lt;/SOAP-ENV:Body&amp;gt;&amp;lt;/SOAP-ENV:Envelope&amp;gt;






It seems that wss4j headers are processed by WSS4j Interceptor and then somehow removed from requestMessage. Actually had no time to dig it further and check if custom headres are also stripped out.
Anyway i think that sentMessageTracingLogger  should log original client request message.
I am attaching patch version of MessageDispatcher</description>
			<version>1.5.3</version>
			<fixedVersion>1.5.9</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.MessageDispatcher.java</file>
		</fixedFiles>
	</bug>
	<bug id="575" opendate="2009-10-12 07:53:45" fixdate="2010-01-10 20:12:00" resolution="Fixed">
		<buginformation>
			<summary>CommonsXsdSchemaCollection: Combination of xs:includes and xs:imports in a schema result in incorrect/overcomplete schema in wsdl generated by DefaultWsdl11Definition</summary>
			<description>When using a DefaultWsdl11Definition for wsdl generation I used a CommonsXsdSchemaCollection to combine a set of xsd&amp;amp;apos;s. I found out that when a schema uses a mix of xs:imports and xs:includes, the inline schema in the generated wsdl (inside &amp;lt;wsdl:types&amp;gt;) contains an error. Both xs:imports and xs:includes are &amp;amp;apos;expanded&amp;amp;apos; inline in the generated wsdl, but the xs:include lines are not removed from the inline schema, causing test tools like SOAPUI to fail (included schema&amp;amp;apos;s cannot be retrieved).</description>
			<version>1.5.8</version>
			<fixedVersion>1.5.9</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.xsd.commons.CommonsXsdSchemaCollection.java</file>
			<file type="M">org.springframework.xml.xsd.commons.CommonsXsdSchemaCollectionTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="594" opendate="2010-01-11 20:40:37" fixdate="2010-01-11 20:55:10" resolution="Fixed">
		<buginformation>
			<summary>SchemaCollection issue when XSD files are in the classpath, in different JAR artifacts</summary>
			<description>Problem described in issue SWS-413 has partially been fixed.
Given XSD-A importing XSD-B, both in the classpath, the fix works if XSD-A and XSD-B are in the same classpath location (both in WEB-INF/classes, or in the same JAR file), but it does not work if the XSD files are located in different JAR files, for example.
The provided patch fixes this : if the imported XSD could not be resolved with the same base URI, we must keep searching in the classpath, (last statements should not be in an else block).</description>
			<version>1.5.8</version>
			<fixedVersion>1.5.9</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.xsd.commons.CommonsXsdSchemaCollection.java</file>
		</fixedFiles>
	</bug>
	<bug id="595" opendate="2010-01-13 07:40:21" fixdate="2010-01-13 07:48:12" resolution="Fixed">
		<buginformation>
			<summary>SoapUtils.setActionInContentType incorrectly replaces existing actions</summary>
			<description>If a SOAP action already exists, the new action is set without the leading "action=".</description>
			<version>1.5.8</version>
			<fixedVersion>1.5.9</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.support.SoapUtilsTest.java</file>
			<file type="M">org.springframework.ws.soap.support.SoapUtils.java</file>
		</fixedFiles>
	</bug>
	<bug id="606" opendate="2010-03-08 00:10:08" fixdate="2010-03-08 00:25:01" resolution="Duplicate">
		<buginformation>
			<summary>SpringPlainTextPasswordValidationCallbackHandler should import from Spring 3.0 packages</summary>
			<description>The current trunk version of SpringPlainTextPasswordValidationCallbackHandler looks like this: https://fisheye.springsource.org/browse/spring-ws/trunk/security/src/main/java/org/springframework/ws/soap/security/wss4j/callback/SpringPlainTextPasswordValidationCallbackHandler.java?r2=1570&amp;amp;u=3&amp;amp;r1=1570
Its imports haven&amp;amp;apos;t been updated for Spring 3.0 and still list old, Spring 2.5 packages. Some of those imports:






26	import org.springframework.security.Authentication;




27	import org.springframework.security.AuthenticationException;




28	import org.springframework.security.AuthenticationManager;






They should be org.springframework.security.core.Authentication, org.springframework.security.core.AuthenticationException, org.springframework.security.authentication.AuthenticationManager etc.
In general, most imports in this class need updating.</description>
			<version>2.0 M2</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jMessageInterceptorSpringSecurityCallbackHandlerTestCase.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringDigestPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringUsernamePasswordCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringCertificateValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.SpringPlainTextPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.SpringDigestPasswordValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringPlainTextPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringUsernamePasswordCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.samples.airline.security.FrequentFlyerDetails.java</file>
			<file type="M">org.springframework.ws.samples.airline.security.SpringFrequentFlyerSecurityServiceTest.java</file>
			<file type="M">org.springframework.ws.samples.airline.security.SpringFrequentFlyerSecurityService.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.SpringDigestPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.samples.airline.service.impl.AirlineServiceImpl.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringPlainTextPasswordValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringDigestPasswordValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringCertificateValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.security.support.SpringSecurityUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">559</link>
		</links>
	</bug>
	<bug id="611" opendate="2010-03-19 00:12:04" fixdate="2010-03-19 00:26:40" resolution="Duplicate">
		<buginformation>
			<summary>SpringCertificateValidationCallbackHandler.SpringSecurityCertificateValidator.validate(..) . Use PreAuthenticatedAuthenticationToken</summary>
			<description>X509AuthenticationProvider/X509AuthenticationToken are deprecated</description>
			<version>2.0 M2</version>
			<fixedVersion></fixedVersion>
			<type>Task</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jMessageInterceptorSpringSecurityCallbackHandlerTestCase.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringDigestPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringUsernamePasswordCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringCertificateValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.SpringPlainTextPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.SpringDigestPasswordValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringPlainTextPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringUsernamePasswordCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.samples.airline.security.FrequentFlyerDetails.java</file>
			<file type="M">org.springframework.ws.samples.airline.security.SpringFrequentFlyerSecurityServiceTest.java</file>
			<file type="M">org.springframework.ws.samples.airline.security.SpringFrequentFlyerSecurityService.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.SpringDigestPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.samples.airline.service.impl.AirlineServiceImpl.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringPlainTextPasswordValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringDigestPasswordValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringCertificateValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.security.support.SpringSecurityUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">559</link>
		</links>
	</bug>
	<bug id="613" opendate="2010-03-25 02:31:17" fixdate="2010-05-11 20:10:06" resolution="Fixed">
		<buginformation>
			<summary>Jaxp13XPathTemplate uses thread-unsafe XPathFactory as field</summary>
			<description>The XPathFactory provided by Sun in the JDK mentions it&amp;amp;apos;s not threadsafe, see: http://java.sun.com/javase/6/docs/api/javax/xml/xpath/XPathFactory.html. Though it is not clear from documentation nor code which of the methods is not threadsafe. It can either be:
a) The XPathFactory.newInstance(...) method: In which case Jaxp13XPathTemplate should clearly document that it should only be constructed once for an entire application to prvent concurrency bugs
b) Any of the other instance methods: In which case Jaxp13XPathTemplate should not use XPathFactory as a field if it wants to be threadsafe.
This means that at the moment the Jaxp13XPathTemplate deviates from other Spring templates, such as JdbcTemplate etc, as these are all threadsafe.</description>
			<version>1.5.9</version>
			<fixedVersion>2.0 M2, 1.5.10</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.xpath.Jaxp13XPathTemplate.java</file>
			<file type="M">org.springframework.ws.server.endpoint.adapter.XPathParamAnnotationMethodEndpointAdapter.java</file>
			<file type="M">org.springframework.xml.xpath.Jaxp13XPathExpressionFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="559" opendate="2009-08-27 06:15:26" fixdate="2010-05-19 21:25:36" resolution="Complete">
		<buginformation>
			<summary>Upgrade Spring Security to 3.0.2</summary>
			<description>I&amp;amp;apos;d like to upgrade to spring security 3.0.0.M1, but spring ws security does not have support for it yet.</description>
			<version>2.0 M2</version>
			<fixedVersion>2.0 M2</fixedVersion>
			<type>Task</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jMessageInterceptorSpringSecurityCallbackHandlerTestCase.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringDigestPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringUsernamePasswordCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringCertificateValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.SpringPlainTextPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.SpringDigestPasswordValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringPlainTextPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringUsernamePasswordCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.samples.airline.security.FrequentFlyerDetails.java</file>
			<file type="M">org.springframework.ws.samples.airline.security.SpringFrequentFlyerSecurityServiceTest.java</file>
			<file type="M">org.springframework.ws.samples.airline.security.SpringFrequentFlyerSecurityService.java</file>
			<file type="M">org.springframework.ws.soap.security.wss4j.callback.SpringDigestPasswordValidationCallbackHandler.java</file>
			<file type="M">org.springframework.ws.samples.airline.service.impl.AirlineServiceImpl.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringPlainTextPasswordValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringDigestPasswordValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringCertificateValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.security.support.SpringSecurityUtils.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">606</link>
			<link type="Duplicate" description="is duplicated by">611</link>
		</links>
	</bug>
	<bug id="640" opendate="2010-08-27 15:15:25" fixdate="2010-09-01 05:18:04" resolution="Fixed">
		<buginformation>
			<summary>evaluateAsBoolean returns true for node with text content "false"</summary>
			<description>The method Jaxp13XPathTemplate.evaluateAsBoolean returns true if the element selected by the expression exists, regardless of its contents. The text contents can be empty, "false", or "WTF", and evaluateAsBoolean will return true. 
This does not appear to match its Javadoc, which says: "Evaluates the given expression as a boolean. Returns the boolean evaluation of the expression, or false if it is invalid." The very similar method evaluateAsDouble has nearly identical Javadoc: "Evaluates the given expression as a double. Returns the evaluation of the expression, or Double.NaN if it is invalid." - but evaluateAsDouble returns the actual contents of the text node. If evaluateAsBoolean is really meant to mean, "doesExpressionSelectAnything", it should be renamed.
Below is a unit test that demonstrates the problem. The second assert fails.
The problem also occurs when using a WSDL which defines aFlag as type "xs:boolean". And, it also occurs with JaxenXPathTemplate. However, I have not seen it using sources other than DOMSource.






package com.yodle.misc;









import static org.junit.Assert.*;









import javax.xml.transform.dom.DOMSource;









import org.junit.Test;




import org.springframework.ws.server.endpoint.AbstractDomPayloadEndpoint;




import org.springframework.xml.transform.StringSource;




import org.springframework.xml.xpath.Jaxp13XPathTemplate;




import org.w3c.dom.Document;




import org.w3c.dom.Element;









public class BugDemo {









	final String request =




		"&amp;lt;someRequest&amp;gt; " +		




		"	&amp;lt;aDouble&amp;gt;123&amp;lt;/aDouble&amp;gt; " +




		"	&amp;lt;aFlag&amp;gt;false&amp;lt;/aFlag&amp;gt; " +




		"&amp;lt;/someRequest&amp;gt; ";




	




	private class Endpoint extends AbstractDomPayloadEndpoint {









		@Override




		protected Element invokeInternal(Element requestElement, Document responseDocument) throws Exception {




			Jaxp13XPathTemplate xPathTemplate = new Jaxp13XPathTemplate();




			DOMSource src = new DOMSource(requestElement);




			




			double aDouble = xPathTemplate.evaluateAsDouble("aDouble", src);




			assertEquals(123d, aDouble, 0.01);




			




			boolean aFlag = xPathTemplate.evaluateAsBoolean("aFlag", src);




			assertFalse(aFlag);




			




			return null;




		}




		




	};




	




	@Test




	public void demonstrateEvaluateAsBooleanStrangeBehavior() throws Exception {




		Endpoint endPoint = new Endpoint();




		endPoint.invoke(new StringSource(request));




	}




	




}





</description>
			<version>1.5.8</version>
			<fixedVersion>2.0 RC1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.xpath.XPathOperations.java</file>
			<file type="M">org.springframework.xml.xpath.XPathExpression.java</file>
		</fixedFiles>
	</bug>
	<bug id="656" opendate="2010-11-14 09:34:59" fixdate="2010-12-10 01:45:25" resolution="Fixed">
		<buginformation>
			<summary> ResponseMatcher.payload(Resource payload) should be static</summary>
			<description>ResponseMatchers  public ResponseMatcher payload(Resource payload) should be declared static</description>
			<version>2.0 RC1</version>
			<fixedVersion>2.0 RC2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.test.server.ResponseMatchers.java</file>
		</fixedFiles>
	</bug>
	<bug id="675" opendate="2011-01-03 03:03:34" fixdate="2011-01-05 07:05:02" resolution="Fixed">
		<buginformation>
			<summary>XwssSecurityInterceptor in combination with &lt;sws:interceptors&gt;</summary>
			<description>The following config:











&amp;lt;sws:interceptors&amp;gt;




&amp;lt;bean id="wsSecurityInterceptor" class="org.springframework.ws.soap.security.xwss.X wsSecurityInterceptor"&amp;gt;




&amp;lt;description&amp;gt;




This interceptor validates incoming messages according to the policy defined in




&amp;amp;apos;securityPolicy.xml&amp;amp;apos;.




The policy defines that all incoming requests must have a UsernameToken with a password digest




in it.




The actual authentication is performed by the Spring callback handler.




&amp;lt;/description&amp;gt;




&amp;lt;property name="secureResponse" value="false"/&amp;gt;




&amp;lt;property name="policyConfiguration"




value="/WEB-INF/spring/securityPolicy.xml"/&amp;gt;




&amp;lt;property name="callbackHandlers"&amp;gt;




&amp;lt;list&amp;gt;




&amp;lt;bean class="org.springframework.ws.soap.security.xwss.c allback.SpringDigestPasswordValidationCallbackHand ler"&amp;gt;




&amp;lt;property name="userDetailsService" ref="securityService"/&amp;gt;




&amp;lt;property name="userCache" ref="userCache"/&amp;gt;




&amp;lt;/bean&amp;gt;




&amp;lt;bean class="com.xifin.security.UserValidationCallbackHa ndler"&amp;gt;




&amp;lt;property name="userCache" ref="userCache"/&amp;gt;




&amp;lt;/bean&amp;gt;




&amp;lt;/list&amp;gt;




&amp;lt;/property&amp;gt;




&amp;lt;/bean&amp;gt;









&amp;lt;/sws:interceptors&amp;gt;






results in the following exception:






2010-12-30 16:35:37,699 DEBUG SoapMessageDispatcher[handleHeaders() line 120] - Handling MustUnderstand header {http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}Security




2010-12-30 16:35:37,702 WARN SoapMessageDispatcher[createMustUnderstandFault() line 162] - Could not handle mustUnderstand headers: {http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd}Security. Returning fault




2010-12-30 16:35:37,704 DEBUG sent[receive() line 181] - Sent response [SaajSoapMessage http://schemas.xmlsoap.org/soap/envelope/}Fault] for request [SaajSoapM





</description>
			<version>2.0 RC2</version>
			<fixedVersion>2.0 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.endpoint.interceptor.DelegatingSmartEndpointInterceptor.java</file>
			<file type="D">org.springframework.ws.server.endpoint.interceptor.PayloadRootSmartEndpointInterceptorTest.java</file>
			<file type="M">org.springframework.ws.config.InterceptorsBeanDefinitionParser.java</file>
			<file type="M">org.springframework.ws.soap.server.endpoint.interceptor.SoapActionSmartEndpointInterceptor.java</file>
			<file type="D">org.springframework.ws.server.endpoint.interceptor.PayloadRootSmartEndpointInterceptor.java</file>
			<file type="M">org.springframework.ws.config.InterceptorsBeanDefinitionParserTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="698" opendate="2011-03-15 06:56:33" fixdate="2011-03-22 04:26:09" resolution="Fixed">
		<buginformation>
			<summary>EndpointExceptionResolver is not registered automatically when used together with &lt;sws:annotation-driven/&gt; tag</summary>
			<description>After removing &amp;lt;sws:annotation-driven/&amp;gt; EndpointExceptionResolver starts to work. Whats more - it looks like that &amp;lt;sws:annotation-driven/&amp;gt; tag is not needed as anotation based Endpoints works without it.
Additional details in the Spring forum post.
</description>
			<version>2.0 GA</version>
			<fixedVersion>2.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.config.AnnotationDrivenBeanDefinitionParser.java</file>
			<file type="M">org.springframework.ws.config.AnnotationDrivenBeanDefinitionParserTest.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">682</link>
		</links>
	</bug>
	<bug id="691" opendate="2011-02-08 03:51:02" fixdate="2011-03-22 05:00:58" resolution="Fixed">
		<buginformation>
			<summary>Annotation-driven tag does not support ws-addressing @Action</summary>
			<description>Objects annotated with @Action should be picked up by the sws:annotation-driven tag (triggered with AnnotationActionEndpointMapping), but this fails because the AnnotationDrivenBeanDefinitionParser does not register all possible endpoint mappings in the registerEndpointMappings method.
Ws-addressing support is not working without explicit adding the AnnotationActionEndpointMapping in the Spring context.
Workaround:
Add the following line to the Spring context xml:
&amp;lt;bean class="org.springframework.ws.soap.addressing.server.AnnotationActionEndpointMapping" /&amp;gt;
</description>
			<version>2.0 GA</version>
			<fixedVersion>2.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.addressing.server.AnnotationActionEndpointMapping.java</file>
			<file type="M">org.springframework.ws.soap.addressing.server.AbstractAddressingEndpointMapping.java</file>
			<file type="M">org.springframework.ws.config.AnnotationDrivenBeanDefinitionParser.java</file>
			<file type="M">org.springframework.ws.config.AnnotationDrivenBeanDefinitionParserTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="242" opendate="2007-11-22 23:45:27" fixdate="2011-03-24 03:15:51" resolution="Fixed">
		<buginformation>
			<summary>Allow for custom ErrorHandler in PayloadValidatingInterceptor</summary>
			<description>Validating a SOAP request or response with PayloadValidatingInterceptor or Jaxb2Marshaller fails when using MTOM.
The spring-ws MTOM sample fails when PayloadValidatingInterceptor is added to the endpoint interceptor chain.
Schema:
    &amp;lt;element name="SendRequest" type="tns:SendMessage"/&amp;gt;
    &amp;lt;complexType name="SendMessage"&amp;gt;
       	&amp;lt;sequence&amp;gt;
   		&amp;lt;element name="sender" type="string"/&amp;gt;
   		&amp;lt;element name="recipient" type="string"/&amp;gt;
            	&amp;lt;element name="content" type="base64Binary" xmime:expectedContentTypes="/"/&amp;gt;
       	&amp;lt;/sequence&amp;gt;
   &amp;lt;/complexType&amp;gt;
SOAP request:
&amp;lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:mail="http://www.enovation.nl/ems/mailwebservice"&amp;gt;
   &amp;lt;soapenv:Header/&amp;gt;
   &amp;lt;soapenv:Body&amp;gt;
      &amp;lt;mail:SendRequest&amp;gt;
         &amp;lt;mail:sender&amp;gt;1&amp;lt;/mail:sender&amp;gt;
         &amp;lt;mail:recipient&amp;gt;2&amp;lt;/mail:recipient&amp;gt;
         &amp;lt;mail:content&amp;gt;&amp;lt;inc:Include xmlns:inc="http://www.w3.org/2004/08/xop/include" href="cid:768176637073"/&amp;gt;&amp;lt;/mail:content&amp;gt;
      &amp;lt;/mail:SendRequest&amp;gt;
   &amp;lt;/soapenv:Body&amp;gt;
&amp;lt;/soapenv:Envelope&amp;gt;
SOAP response:
&amp;lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;
   &amp;lt;SOAP-ENV:Header/&amp;gt;
   &amp;lt;SOAP-ENV:Body&amp;gt;
      &amp;lt;SOAP-ENV:Fault&amp;gt;
         &amp;lt;faultcode&amp;gt;SOAP-ENV:Client&amp;lt;/faultcode&amp;gt;
         &amp;lt;faultstring xml:lang="en"&amp;gt;Validation error&amp;lt;/faultstring&amp;gt;
         &amp;lt;detail&amp;gt;
            &amp;lt;spring-ws:ValidationError xmlns:spring-ws="http://springframework.org/spring-ws"&amp;gt;cvc-type.3.1.2: Element &amp;amp;apos;mail:content&amp;amp;apos; is a simple type, so it must have no element information item [children].&amp;lt;/spring-ws:ValidationError&amp;gt;
         &amp;lt;/detail&amp;gt;
      &amp;lt;/SOAP-ENV:Fault&amp;gt;
   &amp;lt;/SOAP-ENV:Body&amp;gt;
&amp;lt;/SOAP-ENV:Envelope&amp;gt;</description>
			<version>1.0.2</version>
			<fixedVersion>2.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.validation.Jaxp10ValidatorFactoryTest.java</file>
			<file type="M">org.springframework.xml.validation.Jaxp10ValidatorFactory.java</file>
			<file type="M">org.springframework.xml.validation.AbstractValidatorFactoryTestCase.java</file>
			<file type="M">org.springframework.ws.server.endpoint.interceptor.AbstractValidatingInterceptor.java</file>
			<file type="M">org.springframework.xml.validation.Jaxp13ValidatorFactory.java</file>
			<file type="M">org.springframework.xml.validation.XmlValidator.java</file>
			<file type="M">org.springframework.ws.soap.server.endpoint.interceptor.PayloadValidatingInterceptorTest.java</file>
			<file type="M">org.springframework.xml.validation.XmlValidatorFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="699" opendate="2011-03-24 05:38:15" fixdate="2011-03-28 02:31:51" resolution="Complete">
		<buginformation>
			<summary>XomPayloadMethodProcessor is not added methodReturnValueHandlers in DefaultMethodEndpointAdapter</summary>
			<description>





      private void initMethodReturnValueHandlers() {




            ...




            if (isPresent(XOM_CLASS_NAME)) {




                methodArgumentResolvers.add(new XomPayloadMethodProcessor());




            }




            ...




      }






as you can see the XomPayloadMethodProcessor is added to the methodArgumentResolvers and not to the methodReturnValueHandlers. 
To fix the problem just replace the methodArgumentResolvers.add(...) with methodReturnValueHandlers.add(...) </description>
			<version>2.0 GA</version>
			<fixedVersion>2.0.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.endpoint.adapter.DefaultMethodEndpointAdapter.java</file>
		</fixedFiles>
	</bug>
	<bug id="708" opendate="2011-05-09 15:44:19" fixdate="2011-05-18 07:24:03" resolution="Fixed">
		<buginformation>
			<summary>PayloadValidatingInterceptor errors not clearing SecurityContextHolder </summary>
			<description>I have Validtion Interecptor first and SecurityInterceptor Later in the sequence. 
When response has validation errors some how SecurityConextHolder has old previous authenticated user Information. 
When there are NO response validation errors SecurityContextHolder is clean.
I am guessing that when PayloadValidatingInterceptor has errors which is causing not to clean up thread local ?
Once the request is complete all thread context should be nulled out and give back to pool. It does that there are no reponse validation errors but doesn&amp;amp;apos;t do that when there are response validation errors. I tried to debug the code , all the way to MessageDispatcherServlet but didn&amp;amp;apos;t find any clue.
Here is my configuration






&amp;lt;sws:interceptors&amp;gt;














        &amp;lt;bean id="wsSecurityInterceptor" class="com.mycompancy.MyXwsSecurityInterceptor"&amp;gt;




            




            &amp;lt;property name="secureResponse" value="false"/&amp;gt;




            &amp;lt;property name="policyConfiguration"




                      value="/WEB-INF/spring/securityPolicy.xml"/&amp;gt;




            &amp;lt;property name="callbackHandlers"&amp;gt;




                &amp;lt;list&amp;gt;




                    &amp;lt;bean class="com.mycompancy.security.MySpringDigestPasswordValidationCallbackHandler"&amp;gt;




                        &amp;lt;property name="userDetailsService" ref="securityService"/&amp;gt;




                        &amp;lt;property name="userCache" ref="userCache"/&amp;gt;




                    &amp;lt;/bean&amp;gt;




                &amp;lt;/list&amp;gt;




            &amp;lt;/property&amp;gt;




        &amp;lt;/bean&amp;gt;














        &amp;lt;bean class="com.mycompancy.util.MyLoggingInterceptor"/&amp;gt;




        &amp;lt;bean class="org.springframework.ws.soap.server.endpoint.interceptor.PayloadValidatingInterceptor"




              p:validateRequest="true" p:validateResponse="true"&amp;gt;




            &amp;lt;property name="schemas"&amp;gt;




                &amp;lt;list&amp;gt;




                    &amp;lt;value&amp;gt;/WEB-INF/schema/customer.xsd&amp;lt;/value&amp;gt;




                    &amp;lt;value&amp;gt;/WEB-INF/schema/users.xsd&amp;lt;/value&amp;gt;




                    &amp;lt;value&amp;gt;/WEB-INF/schema/userDetails.xsd&amp;lt;/value&amp;gt;




                &amp;lt;/list&amp;gt;




            &amp;lt;/property&amp;gt;




        &amp;lt;/bean&amp;gt;




    &amp;lt;/sws:interceptors&amp;gt;





</description>
			<version>2.0 GA</version>
			<fixedVersion>1.5.10, 2.0.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jMessageInterceptorSpringSecurityCallbackHandlerTestCase.java</file>
			<file type="M">org.springframework.ws.server.MessageDispatcher.java</file>
			<file type="M">org.springframework.ws.server.endpoint.interceptor.EndpointInterceptorAdapter.java</file>
			<file type="M">org.springframework.ws.server.endpoint.AbstractLoggingInterceptor.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.callback.SpringDigestPasswordValidationCallbackHandlerTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.interceptor.DelegatingSmartEndpointInterceptor.java</file>
			<file type="M">org.springframework.ws.server.endpoint.interceptor.AbstractValidatingInterceptor.java</file>
			<file type="M">org.springframework.ws.server.MessageDispatcherTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.interceptor.PayloadTransformingInterceptor.java</file>
			<file type="M">org.springframework.ws.soap.security.AbstractWsSecurityInterceptor.java</file>
			<file type="M">org.springframework.ws.soap.security.xwss.XwsSecurityInterceptorTest.java</file>
			<file type="M">org.springframework.ws.server.EndpointInterceptor.java</file>
			<file type="M">org.springframework.ws.soap.addressing.server.AddressingEndpointInterceptor.java</file>
		</fixedFiles>
	</bug>
	<bug id="733" opendate="2011-09-28 02:49:35" fixdate="2011-10-06 03:09:11" resolution="Fixed">
		<buginformation>
			<summary>Typo in marshalSendAndReceive javadoc</summary>
			<description>Javadoc for marshalSendAndReceive (one that uses default URI) was
This will only work with a default specified!
should be
This will only work with a default uri specified!</description>
			<version>2.0.2</version>
			<fixedVersion>2.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.client.core.WebServiceOperations.java</file>
		</fixedFiles>
	</bug>
	<bug id="721" opendate="2011-07-26 09:31:14" fixdate="2011-10-06 03:11:21" resolution="Fixed">
		<buginformation>
			<summary>EndpointExceptionResolver mentions SOAP but this interface is not necessarily SOAP releated</summary>
			<description>Javadoc for EndpointExceptionResolver:






Defines the interface for objects than can resolve exceptions thrown during endpoint execution, resulting in SOAP messages.





.
Not true. Resolvers don&amp;amp;apos;t have to produce SOAP messages, but the ones in the SOAP packages do. Just eliminate the clause at the end.</description>
			<version>2.0 GA</version>
			<fixedVersion>2.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.EndpointExceptionResolver.java</file>
		</fixedFiles>
	</bug>
	<bug id="709" opendate="2011-05-24 08:53:51" fixdate="2011-10-06 03:14:46" resolution="Fixed">
		<buginformation>
			<summary>JavaDoc for WebServiceTemplate#setFaultMessageResolver has wrong default class</summary>
			<description>The JavaDoc for WebServiceTemplate#setFaultMessageResolver claims that SimpleFaultMessageResolver is the default, whereas it&amp;amp;apos;s actually SoapFaultMessageResolver as listed in WebServiceTemplate.properties. </description>
			<version>2.0.2</version>
			<fixedVersion>2.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.client.core.WebServiceTemplate.java</file>
		</fixedFiles>
	</bug>
	<bug id="724" opendate="2011-08-11 09:56:23" fixdate="2011-10-06 03:23:00" resolution="Fixed">
		<buginformation>
			<summary>DefaultConcretePartProvider is not allowing a blank suffix, due to improper assertion</summary>
			<description>The allowance for a blank ("") suffix is esential to be able to maintain compatability w/ legacy or handwritten WSDLs.
should read as:
    /** Sets the suffix to append to the port type name to obtain the binding name. */
    public void setBindingSuffix(String bindingSuffix) 
{
        Assert.notNull(bindingSuffix, "&amp;amp;apos;bindingSuffix&amp;amp;apos; must not be null");
        this.bindingSuffix = bindingSuffix;
    }

currently as:
  public void setBindingSuffix(String bindingSuffix)
  {
    Assert.hasText(bindingSuffix, "&amp;amp;apos;bindingSuffix&amp;amp;apos; must not be null");
    this.bindingSuffix = bindingSuffix;
  }


patch forthcomming....</description>
			<version>2.0.2</version>
			<fixedVersion>2.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.wsdl.wsdl11.provider.DefaultConcretePartProvider.java</file>
		</fixedFiles>
	</bug>
	<bug id="713" opendate="2011-06-30 05:30:57" fixdate="2011-10-06 04:08:22" resolution="Fixed">
		<buginformation>
			<summary>Order of interceptor calls is dependent on the way the interceptors are included</summary>
			<description>The InterceptorsBeanDefinitionParser scans for interceptors in the following order: first "bean", then "ref", and so on. I.e. the order in which the interceptors are called is dependent on the way the interceptors are included.
One would expect that the interceptors are called in the order in which they were specified, so that changing a "bean" to a "ref" does not modify the calling order.</description>
			<version>2.0.2</version>
			<fixedVersion>2.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.config.InterceptorsBeanDefinitionParserTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.interceptor.DelegatingSmartEndpointInterceptor.java</file>
			<file type="M">org.springframework.ws.config.InterceptorsBeanDefinitionParser.java</file>
		</fixedFiles>
	</bug>
	<bug id="737" opendate="2011-10-10 00:15:08" fixdate="2011-10-17 01:10:08" resolution="Fixed">
		<buginformation>
			<summary>EndpointInterceptorAdapter removes "throws Exception" from handleFault() method defined by EndpointInterceptor</summary>
			<description>EndpointInterceptor defines handleFault as follows:
boolean handleFault(MessageContext messageContext, Object endpoint) throws Exception;
EndpointInterceptorAdapter provides a default implementation like this (notice the missing "throws Exception"):
public boolean handleFault(MessageContext messageContext, Object endpoint) {
    return true;
}
As a result subclasses of EndpointInterceptorAdapter can no longer throw exceptions from handleFault()</description>
			<version>2.0.2</version>
			<fixedVersion>2.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.endpoint.interceptor.EndpointInterceptorAdapter.java</file>
		</fixedFiles>
	</bug>
	<bug id="726" opendate="2011-08-24 09:21:08" fixdate="2011-10-17 01:30:17" resolution="Fixed">
		<buginformation>
			<summary>CryptoFactoryBean keystore location can&amp;apos;t resolve ClassPathResource where resource is located in a jar</summary>
			<description>When using a ClassPathResource to set the keyStoreLocation property, if the resource is located in a jar file a FileNotFoundException is thrown.






Caused by: java.io.FileNotFoundException: class path resource [com/foo/security/foo.keystore] cannot be resolved to absolute file path because it does not reside in the file system: jar:file:/C:/views/java/jboss/server/oneforce/deploy/oba.war/WEB-INF/lib/foo-security.jar!/com/foo/security/foo.keystore




	at org.springframework.util.ResourceUtils.getFile(ResourceUtils.java:204)




	at org.springframework.core.io.AbstractFileResolvingResource.getFile(AbstractFileResolvingResource.java:52)




	at org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean.setKeyStoreLocation(CryptoFactoryBean.java:88)






org.apache.ws.security.components.crypto.AbstractCrypto has it&amp;amp;apos;s own mechanism for locating classpath resources. The following patch will fallback to the ClassPathResource path if can&amp;amp;apos;t be resolved to a file.






org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean






public void setKeyStoreLocation(Resource location) throws IOException {




	String resourcePath = null;




	try {




		File keyStoreFile = location.getFile();




		resourcePath = keyStoreFile.getAbsolutePath();




	} catch (IOException ioe) {




		// can&amp;amp;apos;t resolve to file on the file system




		// allow org.apache.ws.security.components.crypto.AbstractCrypt to resolve from resource path




		if(location instanceof ClassPathResource) {




			resourcePath = ((ClassPathResource) location).getPath();




		} else {




			throw ioe;




		}




	}




	




	this.configuration.setProperty("org.apache.ws.security.crypto.merlin.file", resourcePath);	




}





</description>
			<version>2.0.2</version>
			<fixedVersion>2.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.support.CryptoFactoryBean.java</file>
		</fixedFiles>
	</bug>
	<bug id="718" opendate="2011-07-12 08:38:38" fixdate="2011-10-17 03:18:00" resolution="Fixed">
		<buginformation>
			<summary>Reloading the spring context does not refresh the MessageDispatcherServlet</summary>
			<description>Our application uses a special classloader from which it can load beans dynamically. The applicationcontext is reloaded to do this. The normal DispatcherServlet has a mechanism to allow the applicationcontext to be reloaded by overriding the onRefresh method. The MessageDispatcherServlet does not do this and crashes occur when webservices are invoked. 
The class below can be used as a workaround.






public class FixedMessageDispatcherServlet




	extends MessageDispatcherServlet




{









	private boolean initializing = true;









	@Override




	protected void onRefresh(ApplicationContext context)




	{




		try {




			if (this.initializing) {




				this.initializing = false;




			} else {




				this.initFrameworkServlet();




			}




		} catch (Exception e) {




			throw new RuntimeException(e);




		}




	}




}





</description>
			<version>2.0.2</version>
			<fixedVersion>2.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.MessageDispatcherServlet.java</file>
		</fixedFiles>
	</bug>
	<bug id="702" opendate="2011-04-04 05:20:51" fixdate="2011-10-18 04:14:45" resolution="Fixed">
		<buginformation>
			<summary>sws:annotation-driven does not pick up @Endpoint annotations on classes that are JDK proxies</summary>
			<description>We essentially have an app context loaded by the MessageDispatcherServlet that does the following:






&amp;lt;bean id="ws.myWebService" class="foo.bar.MyWebServiceImpl"/&amp;gt;




&amp;lt;aop:aspectj-autoproxy /&amp;gt;




&amp;lt;bean class="foo.bar.MyCustomAspect"/&amp;gt;




&amp;lt;sws:annotation-driven/&amp;gt;






The MyWebServiceImpl looks like this:






@Endpoint




public class MyWebServiceImpl implements MyWebService {









  @PayloadRoot(namespace = "http://my.foo.bar", localPart = "myWebService")




  @MyCustomAnnotation // picked up by MyCustomAspect to proxy this class




  @ResponsePayload




  public MyResponseDocument getFactInfo(@RequestPayload MyRequestDocument request) {




    ...




  }




}






As a result of the @MyCustomAnnotation, the MyWebServiceImpl will be JDK proxied. Because of this the @Endpoint is not picked up. If we remove the custom aspect the @Endpoint is indeed picked up.
For now, I have added the following to the app context as a workaround:






&amp;lt;aop:config proxy-target-class="true"/&amp;gt;






Note that this seems to be similar to SWS-262</description>
			<version>2.0.1</version>
			<fixedVersion>2.0.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.server.endpoint.mapping.SoapActionAnnotationMethodEndpointMapping.java</file>
			<file type="M">org.springframework.ws.server.endpoint.mapping.PayloadRootAnnotationMethodEndpointMapping.java</file>
			<file type="D">org.springframework.ws.server.endpoint.mapping.PayloadRootEndpoint.java</file>
			<file type="M">org.springframework.ws.server.endpoint.mapping.AbstractMethodEndpointMapping.java</file>
			<file type="D">org.springframework.ws.server.endpoint.mapping.OtherBean.java</file>
			<file type="M">org.springframework.ws.server.endpoint.mapping.PayloadRootAnnotationMethodEndpointMappingTest.java</file>
			<file type="M">org.springframework.ws.server.endpoint.mapping.LogAspect.java</file>
		</fixedFiles>
	</bug>
	<bug id="750" opendate="2012-01-20 00:25:47" fixdate="2012-01-24 07:16:16" resolution="Fixed">
		<buginformation>
			<summary>SaajSoapMessageFactory&amp;apos;s checkForUtf8ByteOrderMark is corrupting input stream</summary>
			<description>There appears to be a bug in the implementation of "checkForUtf8ByteOrderMark" in org.springframework.ws.soap.saaj.SaajSoapMessageFactory.
Under certain circumstances, the call to pushbackInputStream.read(bom) will read less than the required 3 bytes into bom. Then, since the byte order mark isn&amp;amp;apos;t found, unread(bom) is called which results in some invalid bytes being added to the stream.
The contract for PushbackInputStream.read(byte[] b, int off, int len) says "Reads up to len bytes of data." In our case, using Tomcat (versions 6 and 7) with recent releases of Chrome and IE, the call to inputstream.available() in BufferedInputStream&amp;amp;apos;s implementation of read returns 0. This is because no more data can be read without blocking. It seems to be just an unfortunate coincidence caused by the size of the header sent by the newest version of chrome and IE. The end result is that our soap envelope is corrupted and our system is unusable.</description>
			<version>1.5.8</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoapMessageFactory.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">845</link>
		</links>
	</bug>
	<bug id="647" opendate="2010-10-25 15:01:34" fixdate="2012-01-25 01:36:20" resolution="Fixed">
		<buginformation>
			<summary>PayloadValidatingInterceptor throws IllegalArgumentException when passed a schema collection</summary>
			<description>When I configure the PayloadValidatingInterceptor to refer to a CommonsXsdSchemaCollection, I get the following error when my web service is invoked:






org.springframework.beans.factory.BeanCreationException: Error creating bean with name &amp;amp;apos;validatingInterceptor&amp;amp;apos; defined in ServletContext resource [/WEB-INF/spring-ws-servlet.xml]: Error setting property values; nested exception is org.springframework.beans.PropertyBatchUpdateException; nested PropertyAccessExceptions (1) are:




PropertyAccessException 1: org.springframework.beans.MethodInvocationException: Property &amp;amp;apos;xsdSchemaCollection&amp;amp;apos; threw exception; nested exception is java.lang.IllegalArgumentException: Path must not be null




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1341)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1067)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:511)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:450)




	at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:290)




	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222)




	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:287)




	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:189)




	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:557)




	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:895)




	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:425)




	at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:402)




	at org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:316)




	at org.springframework.web.servlet.FrameworkServlet.initServletBean(FrameworkServlet.java:282)




	at org.springframework.web.servlet.HttpServletBean.init(HttpServletBean.java:126)




	at javax.servlet.GenericServlet.init(GenericServlet.java:241)




	at weblogic.servlet.internal.StubSecurityHelper$ServletInitAction.run(StubSecurityHelper.java:283)




	at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:321)




	at weblogic.security.service.SecurityManager.runAs(SecurityManager.java:121)




	at weblogic.servlet.internal.StubSecurityHelper.createServlet(StubSecurityHelper.java:64)




	at weblogic.servlet.internal.StubLifecycleHelper.createOneInstance(StubLifecycleHelper.java:58)




	at weblogic.servlet.internal.StubLifecycleHelper.(StubLifecycleHelper.java:48)




	at weblogic.servlet.internal.ServletStubImpl.prepareServlet(ServletStubImpl.java:539)




	at weblogic.servlet.internal.ServletStubImpl.execute(ServletStubImpl.java:243)




	at weblogic.servlet.internal.ServletStubImpl.execute(ServletStubImpl.java:183)




	at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.doIt(WebAppServletContext.java:3686)




	at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run(WebAppServletContext.java:3650)




	at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:321)




	at weblogic.security.service.SecurityManager.runAs(SecurityManager.java:121)




	at weblogic.servlet.internal.WebAppServletContext.securedExecute(WebAppServletContext.java:2268)




	at weblogic.servlet.internal.WebAppServletContext.execute(WebAppServletContext.java:2174)




	at weblogic.servlet.internal.ServletRequestImpl.run(ServletRequestImpl.java:1446)




	at weblogic.work.ExecuteThread.execute(ExecuteThread.java:201)




	at weblogic.work.ExecuteThread.run(ExecuteThread.java:173)




Caused by: org.springframework.beans.PropertyBatchUpdateException; nested PropertyAccessExceptions (1) are:




PropertyAccessException 1: org.springframework.beans.MethodInvocationException: Property &amp;amp;apos;xsdSchemaCollection&amp;amp;apos; threw exception; nested exception is java.lang.IllegalArgumentException: Path must not be null




	at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:102)




	at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:58)




	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1338)




	... 33 more






-------------------------
Here&amp;amp;apos;s my spring bean config:






    &amp;lt;bean id="validatingInterceptor" class="org.springframework.ws.soap.server.endpoint.interceptor.PayloadValidatingInterceptor"&amp;gt;




        &amp;lt;property name="xsdSchemaCollection" ref="schemaCollection" /&amp;gt;




        &amp;lt;property name="validateRequest" value="true" /&amp;gt;




        &amp;lt;property name="validateResponse" value="true" /&amp;gt;




    &amp;lt;/bean&amp;gt;









    &amp;lt;bean id="schemaCollection" class="org.springframework.xml.xsd.commons.CommonsXsdSchemaCollection"&amp;gt;




        &amp;lt;property name="xsds"&amp;gt;




            &amp;lt;list&amp;gt;




                &amp;lt;value&amp;gt;classpath:schemas/CommonTypes.xsd&amp;lt;/value&amp;gt;




                &amp;lt;value&amp;gt;classpath:schemas/TakeService.xsd&amp;lt;/value&amp;gt;




            &amp;lt;/list&amp;gt;




        &amp;lt;/property&amp;gt;




        &amp;lt;property name="inline" value="true" /&amp;gt;




    &amp;lt;/bean&amp;gt;






------------------------
The workaround is to explicit set the "schemas" property, thus duplicating the XSD paths in the config (which is not ideal):






    &amp;lt;bean id="validatingInterceptor" class="org.springframework.ws.soap.server.endpoint.interceptor.PayloadValidatingInterceptor"&amp;gt;




        &amp;lt;property name="schemas"&amp;gt;




            &amp;lt;list&amp;gt;




                &amp;lt;value&amp;gt;classpath:schemas/CommonTypes.xsd&amp;lt;/value&amp;gt;




                &amp;lt;value&amp;gt;classpath:schemas/TakeService.xsd&amp;lt;/value&amp;gt;




            &amp;lt;/list&amp;gt;




        &amp;lt;/property&amp;gt;




        &amp;lt;property name="validateRequest" value="true" /&amp;gt;




        &amp;lt;property name="validateResponse" value="true" /&amp;gt;




    &amp;lt;/bean&amp;gt;






</description>
			<version>1.5.9</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.xsd.commons.CommonsXsdSchema.java</file>
			<file type="M">org.springframework.xml.xsd.commons.CommonsXsdSchemaCollection.java</file>
		</fixedFiles>
	</bug>
	<bug id="742" opendate="2011-12-20 02:45:53" fixdate="2012-01-25 02:58:57" resolution="Fixed">
		<buginformation>
			<summary>JMSCorrelationID together with Oracle AQ</summary>
			<description>In org.springframework.ws.transport.jms.JmsSenderConnection.onReceiveBeforeRead() the following code set the value of messageSelector:






if (responseDestination instanceof TemporaryQueue || responseDestination instanceof TemporaryTopic) {




       messageConsumer = session.createConsumer(responseDestination);




} else {




       String messageId = requestMessage.getJMSMessageID().replaceAll("&amp;amp;apos;", "&amp;amp;apos;&amp;amp;apos;");




       String messageSelector = "JMSCorrelationID = &amp;amp;apos;" + messageId + "&amp;amp;apos;";




       messageConsumer = session.createConsumer(responseDestination, messageSelector);




}






If  I&amp;amp;apos;m using Oracle AQ, expression (responseDestination instanceof TemporaryQueue) always returns true (See Oracle Streams Advanced Queuing Java API Reference http://docs.oracle.com/cd/B19306_01/server.102/b14291/oracle/jms/AQjmsDestination.html). Regarding this it is impossible to use JMSCorrelationID together with Oracle AQ. </description>
			<version>2.0.3</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.jms.JmsSenderConnection.java</file>
			<file type="M">org.springframework.ws.transport.jms.JmsMessageSenderIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="748" opendate="2012-01-14 07:49:02" fixdate="2012-01-25 04:12:00" resolution="Fixed">
		<buginformation>
			<summary>Not well formed xml causes server 500 error</summary>
			<description>In 2.0.3 and likely previous versions, parsing a not well formed xml causes http 500 instead of a client error, e.g bad request.
	com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(Unknown Source)
	com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(Unknown Source)
	com.sun.xml.internal.messaging.saaj.util.transform.EfficientStreamingTransformer.transform(Unknown Source)
	com.sun.xml.internal.messaging.saaj.soap.EnvelopeFactory.createEnvelope(Unknown Source)
	com.sun.xml.internal.messaging.saaj.soap.ver1_1.SOAPPart1_1Impl.createEnvelopeFromSource(Unknown Source)
	com.sun.xml.internal.messaging.saaj.soap.SOAPPartImpl.getEnvelope(Unknown Source)
	org.springframework.ws.soap.saaj.support.SaajUtils.getSaajVersion(SaajUtils.java:155)
	org.springframework.ws.soap.saaj.SaajSoapMessage.getSaajVersion(SaajSoapMessage.java:257)
	org.springframework.ws.soap.saaj.SaajSoapMessage.getImplementation(SaajSoapMessage.java:342)
	org.springframework.ws.soap.saaj.SaajSoapMessage.&amp;lt;init&amp;gt;(SaajSoapMessage.java:117)
	org.springframework.ws.soap.saaj.SaajSoapMessageFactory.createWebServiceMessage(SaajSoapMessageFactory.java:184)
	org.springframework.ws.soap.saaj.SaajSoapMessageFactory.createWebServiceMessage(SaajSoapMessageFactory.java:58)
	org.springframework.ws.transport.AbstractWebServiceConnection.receive(AbstractWebServiceConnection.java:90)
	org.springframework.ws.transport.support.WebServiceMessageReceiverObjectSupport.handleConnection(WebServiceMessageReceiverObjectSupport.java:86)
	org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.handle(WebServiceMessageReceiverHandlerAdapter.java:57)
</description>
			<version>2.0.3</version>
			<fixedVersion>2.0.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoap12MessageFactoryTest.java</file>
			<file type="M">org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapterTest.java</file>
			<file type="M">org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.java</file>
			<file type="M">org.springframework.ws.soap.saaj.SaajSoapMessageFactory.java</file>
			<file type="M">org.springframework.ws.soap.AbstractSoapMessageFactoryTestCase.java</file>
			<file type="M">org.springframework.ws.WebServiceMessageFactory.java</file>
			<file type="M">org.springframework.ws.soap.soap11.AbstractSoap11MessageFactoryTestCase.java</file>
			<file type="M">org.springframework.ws.soap.soap12.AbstractSoap12MessageFactoryTestCase.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoap11MessageFactoryTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="763" opendate="2012-04-13 01:11:24" fixdate="2012-05-01 07:44:42" resolution="Complete">
		<buginformation>
			<summary>Namespace problems after upgrading to Axiom 1.2.13</summary>
			<description>After upgrading to Axiom 1.2.13 which changes (restricts) some namespace issues there are several problems with Spring-WS + Axiom Message Factory:
1. UnsupportedOperationException in org.springframework.ws.soap.axiom.AxiomSoapMessage constructor:






java.lang.UnsupportedOperationException: This is not allowed. Use set SOAPEnvelope instead




	at org.apache.axiom.soap.impl.llom.SOAPMessageImpl.setOMDocumentElement(SOAPMessageImpl.java:59)




	at org.apache.axiom.om.impl.llom.OMDocumentImpl.&amp;lt;init&amp;gt;(OMDocumentImpl.java:101)




	at org.apache.axiom.soap.impl.llom.SOAPMessageImpl.&amp;lt;init&amp;gt;(SOAPMessageImpl.java:42)




	at org.apache.axiom.soap.impl.llom.soap11.SOAP11Factory.createSOAPMessage(SOAP11Factory.java:329)




	at org.springframework.ws.soap.axiom.AxiomSoapMessage.&amp;lt;init&amp;gt;(AxiomSoapMessage.java:100)




	at org.springframework.ws.soap.axiom.AxiomSoapMessage.&amp;lt;init&amp;gt;(AxiomSoapMessage.java:89)




	at org.springframework.ws.soap.axiom.AxiomSoap11MessageTest.createSoapMessage(AxiomSoap11MessageTest.java:29)




	at org.springframework.ws.soap.AbstractSoapMessageTestCase.createMimeMessage(AbstractSoapMessageTestCase.java:51)




	at org.springframework.ws.mime.AbstractMimeMessageTestCase.createWebServiceMessage(AbstractMimeMessageTestCase.java:44)




	at org.springframework.ws.AbstractWebServiceMessageTestCase.setUp(AbstractWebServiceMessageTestCase.java:79)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)




	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:27)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)




	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)




	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)






2. org.apache.axiom.attachments.Attachments.getAttachmentSpecType() throws OMException, not NullPointerException now:






org.springframework.ws.soap.axiom.AxiomSoapMessageException: Could not write message to OutputStream: Unable to determine the attachment spec type because the Attachments object doesn&amp;amp;apos;t have a known content type; nested exception is org.apache.axiom.om.OMException: Unable to determine the attachment spec type because the Attachments object doesn&amp;amp;apos;t have a known content type




	at org.springframework.ws.soap.axiom.AxiomSoapMessage.writeTo(AxiomSoapMessage.java:295)




	at org.springframework.ws.soap.soap11.AbstractSoap11MessageTestCase.testWriteToTransportOutputStream(AbstractSoap11MessageTestCase.java:65)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)




	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)




	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)




	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)




Caused by: org.apache.axiom.om.OMException: Unable to determine the attachment spec type because the Attachments object doesn&amp;amp;apos;t have a known content type




	at org.apache.axiom.attachments.Attachments.getAttachmentSpecType(Attachments.java:164)




	at org.springframework.ws.soap.axiom.AxiomSoapMessage.isXopPackage(AxiomSoapMessage.java:220)




	at org.springframework.ws.soap.axiom.AxiomSoapMessage.getOutputFormat(AxiomSoapMessage.java:309)




	at org.springframework.ws.soap.axiom.AxiomSoapMessage.writeTo(AxiomSoapMessage.java:258)




	... 24 more






3. Conflicting namespace declarations in org.springframework.ws.soap.axiom.AxiomHandler.startElement():






javax.xml.transform.TransformerException: org.apache.axiom.om.OMException: Attempt to add a namespace declaration that conflicts with the namespace information of the element




	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:716)




	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:313)




	at org.springframework.ws.soap.soap11.AbstractSoap11MessageTestCase.testWriteToTransportOutputStream(AbstractSoap11MessageTestCase.java:59)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)




	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)




	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)




	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)




Caused by: org.apache.axiom.om.OMException: Attempt to add a namespace declaration that conflicts with the namespace information of the element




	at org.apache.axiom.om.impl.llom.OMElementImpl.declareDefaultNamespace(OMElementImpl.java:401)




	at org.springframework.ws.soap.axiom.AxiomHandler.startElement(AxiomHandler.java:93)




	at com.sun.org.apache.xml.internal.serializer.ToXMLSAXHandler.closeStartTag(ToXMLSAXHandler.java:204)




	at com.sun.org.apache.xml.internal.serializer.ToSAXHandler.flushPending(ToSAXHandler.java:277)




	at com.sun.org.apache.xml.internal.serializer.ToXMLSAXHandler.endElement(ToXMLSAXHandler.java:243)




	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.endElement(AbstractSAXParser.java:601)




	at com.sun.org.apache.xerces.internal.parsers.AbstractXMLDocumentParser.emptyElement(AbstractXMLDocumentParser.java:180)




	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.scanStartElement(XMLNSDocumentScannerImpl.java:377)




	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl$NSContentDriver.scanRootElementHook(XMLNSDocumentScannerImpl.java:626)




	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:3104)




	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl$PrologDriver.next(XMLDocumentScannerImpl.java:922)




	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:648)




	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.next(XMLNSDocumentScannerImpl.java:140)




	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:511)




	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:808)




	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737)




	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119)




	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205)




	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transformIdentity(TransformerImpl.java:609)




	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:707)




	... 25 more




---------




org.apache.axiom.om.OMException: Attempt to add a namespace declaration that conflicts with the namespace information of the element




	at org.apache.axiom.om.impl.llom.OMElementImpl.declareDefaultNamespace(OMElementImpl.java:401)




	at org.springframework.ws.soap.axiom.AxiomHandler.startElement(AxiomHandler.java:93)




	at com.sun.org.apache.xml.internal.serializer.ToXMLSAXHandler.closeStartTag(ToXMLSAXHandler.java:204)




	at com.sun.org.apache.xml.internal.serializer.ToSAXHandler.flushPending(ToSAXHandler.java:277)




	at com.sun.org.apache.xml.internal.serializer.ToXMLSAXHandler.endElement(ToXMLSAXHandler.java:243)




	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.endElement(AbstractSAXParser.java:601)




	at com.sun.org.apache.xerces.internal.parsers.AbstractXMLDocumentParser.emptyElement(AbstractXMLDocumentParser.java:180)




	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.scanStartElement(XMLNSDocumentScannerImpl.java:377)




	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl$NSContentDriver.scanRootElementHook(XMLNSDocumentScannerImpl.java:626)




	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:3104)




	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl$PrologDriver.next(XMLDocumentScannerImpl.java:922)




	at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:648)




	at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.next(XMLNSDocumentScannerImpl.java:140)




	at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:511)




	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:808)




	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737)




	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119)




	at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1205)




	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transformIdentity(TransformerImpl.java:609)




	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:707)




	at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:313)




	at org.springframework.ws.soap.soap11.AbstractSoap11MessageTestCase.testWriteToTransportOutputStream(AbstractSoap11MessageTestCase.java:59)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)




	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)




	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)




	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)






4. Violation of Iterator contract in org.springframework.ws.soap.axiom.support.AxiomUtils.removeContents(OMContainer):






java.util.ConcurrentModificationException: The current node has been removed using a method other than Iterator#remove()




	at org.apache.axiom.om.impl.traverse.OMAbstractIterator.hasNext(OMAbstractIterator.java:67)




	at org.springframework.ws.soap.axiom.support.AxiomUtils.removeContents(AxiomUtils.java:107)




	at org.springframework.ws.soap.axiom.AbstractPayload.getResult(AbstractPayload.java:72)




	at org.springframework.ws.soap.axiom.AxiomSoapBody.getPayloadResult(AxiomSoapBody.java:57)




	at org.springframework.ws.soap.AbstractSoapBodyTestCase.testGetPayloadResultTwice(AbstractSoapBodyTestCase.java:56)




	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)




	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)




	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)




	at java.lang.reflect.Method.invoke(Method.java:597)




	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)




	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)




	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)




	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)




	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:28)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:76)




	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)




	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)




	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)




	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)




	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)




	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)




	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)




	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)




	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:467)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390)




	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)






Please find attached a patch (with tests) allowing Spring-WS to be used with Axiom 1.2.13. All tests pass also with Axiom 1.2.9.
regards
Grzegorz Grzybek</description>
			<version>2.0.4</version>
			<fixedVersion>2.0.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.support.AxiomUtils.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessage.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomHandlerTest.java</file>
			<file type="M">org.springframework.ws.soap.axiom.AxiomHandler.java</file>
		</fixedFiles>
	</bug>
	<bug id="754" opendate="2012-02-20 04:07:34" fixdate="2012-05-02 07:10:00" resolution="Fixed">
		<buginformation>
			<summary>EndpointInterceptor.afterCompletion is not always invoked</summary>
			<description>afterCompletion&amp;amp;apos;s javadoc states that it will be called on any outcome of endpoint invocation, allowing for proper resource cleanup. There is however a case where handleRequest() successfully completes, but afterCompletion() is never invoked. This happens whenever an exception occurs and no EndpointExceptionResolver is able to resolve the exception.






MessageDispatcher.java






// within dispatch()&amp;amp;apos;s last catch block




catch (Exception ex) {




  Object endpoint = mappedEndpoint != null ? mappedEndpoint.getEndpoint() : null;




  processEndpointException(messageContext, endpoint, ex); // exception is rethrown here..




  triggerHandleResponse(mappedEndpoint, interceptorIndex, messageContext);




  triggerAfterCompletion(mappedEndpoint, interceptorIndex, messageContext, ex); // .. and afterCompletion() is never invoked




}






</description>
			<version>2.0.4</version>
			<fixedVersion>2.0.5</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.MessageDispatcherTest.java</file>
			<file type="M">org.springframework.ws.server.MessageDispatcher.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">824</link>
		</links>
	</bug>
	<bug id="777" opendate="2012-05-22 19:37:20" fixdate="2012-05-29 04:03:33" resolution="Fixed">
		<buginformation>
			<summary>SoapFaultMappingExceptionResolver not handling exception</summary>
			<description>Given the following configuration:






    &amp;lt;bean class="org.springframework.ws.soap.server.endpoint.SoapFaultMappingExceptionResolver"&amp;gt;




        &amp;lt;property name="exceptionMappings"&amp;gt;




            &amp;lt;value&amp;gt;




                org.springframework.dao.EmptyResultDataAccessException=CLIENT,Entity not found




            &amp;lt;/value&amp;gt;




        &amp;lt;/property&amp;gt;




        &amp;lt;property name="defaultFault" value="SERVER"/&amp;gt;




    &amp;lt;/bean&amp;gt;






The result in 2.0.5 is correct:






&amp;lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;




        &amp;lt;SOAP-ENV:Header/&amp;gt;




        &amp;lt;SOAP-ENV:Body&amp;gt;




            &amp;lt;SOAP-ENV:Fault&amp;gt;




                &amp;lt;faultcode&amp;gt;SOAP-ENV:Client&amp;lt;/faultcode&amp;gt;




                &amp;lt;faultstring xml:lang="en"&amp;gt;Entity not found&amp;lt;/faultstring&amp;gt;




            &amp;lt;/SOAP-ENV:Fault&amp;gt;




        &amp;lt;/SOAP-ENV:Body&amp;gt;




    &amp;lt;/SOAP-ENV:Envelope&amp;gt;






The result in 2.1.0.RC1 is INCORRECT:






&amp;lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"&amp;gt;




    &amp;lt;SOAP-ENV:Header/&amp;gt;




    &amp;lt;SOAP-ENV:Body&amp;gt;




        &amp;lt;SOAP-ENV:Fault&amp;gt;




            &amp;lt;faultcode&amp;gt;SOAP-ENV:Server&amp;lt;/faultcode&amp;gt;




            &amp;lt;faultstring xml:lang="en"&amp;gt;Incorrect result size: expected 1, actual 0&amp;lt;/faultstring&amp;gt;




        &amp;lt;/SOAP-ENV:Fault&amp;gt;




    &amp;lt;/SOAP-ENV:Body&amp;gt;




&amp;lt;/SOAP-ENV:Envelope&amp;gt;





</description>
			<version>2.1 RC1</version>
			<fixedVersion>2.1 GA</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.config.AnnotationDrivenBeanDefinitionParser.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="is duplicated by">793</link>
			<link type="Relate" description="relates to">772</link>
		</links>
	</bug>
	<bug id="787" opendate="2012-07-23 05:24:02" fixdate="2012-08-07 02:52:34" resolution="Fixed">
		<buginformation>
			<summary>MethodEndpoint.getBean is inconsistent with its API</summary>
			<description>The API description of MethodEndpoint.getBean says "Returns the object bean for this method endpoint." But if the constructor with a BeanFactory argument is used, it actually returns the bean name (String) instead of the actual bean! 
You might correct the documentation, but I&amp;amp;apos;d much prefer if you fix the implementation to do as the documentation says, since currently you need to get hold of the BeanFactory as well to get to the endpoint object, and the MethodEndpoint does not provide it.</description>
			<version>2.0.4</version>
			<fixedVersion>2.1.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.server.endpoint.MethodEndpoint.java</file>
			<file type="M">org.springframework.ws.server.endpoint.MethodEndpointTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="793" opendate="2012-08-23 19:50:49" fixdate="2012-08-28 03:03:34" resolution="Duplicate">
		<buginformation>
			<summary>Extending SoapFaultAnnotationExceptionResolver results in competing annotation resolvers with backwards order</summary>
			<description>I extended SoapFaultAnnotationExceptionResolver to create a custom exception resolver.  While testing I realized that the default SoapFaultAnnotationExceptionResolver was handling the annotated exception being thrown.  From the logs I could see that both resolvers were being created, and the custom one was never called.
I reverted back to version 2.0.1_RELEASE and the problem went away.  It also appeared like the default SoapFaultAnnotationExceptionResolver was not created.
One workaround for this is to set the order of the custom resolver to highest priority, therefore delegating the exceptions to that resolver first, but this is not consistent with the documentation and samples.  </description>
			<version>2.1 GA</version>
			<fixedVersion></fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.config.AnnotationDrivenBeanDefinitionParser.java</file>
		</fixedFiles>
		<links>
			<link type="Duplicate" description="duplicates">777</link>
			<link type="Relate" description="relates to">772</link>
		</links>
	</bug>
	<bug id="797" opendate="2012-09-24 13:19:21" fixdate="2012-09-25 06:30:28" resolution="Fixed">
		<buginformation>
			<summary>XsdSchemaHandlerAdapter does not transform schema locations</summary>
			<description>This is on an existing issue that was marked resolved.
The issue number is SWS-791.
I have modified the issue but didn&amp;amp;apos;t know how to reopen it so I am opening this new one referring to SWS-791.
Sorry for that.
Thanks,</description>
			<version>2.1 GA</version>
			<fixedVersion>2.1.2</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.MessageDispatcherServlet.java</file>
			<file type="M">org.springframework.ws.transport.http.WsdlDefinitionHandlerAdapter.java</file>
			<file type="M">org.springframework.ws.transport.http.XsdSchemaHandlerAdapter.java</file>
			<file type="M">org.springframework.ws.transport.http.XsdSchemaHandlerAdapterTest.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="is related to">791</link>
		</links>
	</bug>
	<bug id="804" opendate="2012-10-15 22:28:33" fixdate="2012-11-30 03:49:30" resolution="Fixed">
		<buginformation>
			<summary>WebServiceMessageReceiverHandlerAdapter not easily overridable to produce SOAP faults</summary>
			<description>WebServiceMessageReceiverHandlerAdapter has been changed recently to catch InvalidXmlException and return a HTTP 400 status code. We would like to instead return a SOAP fault with a detailed message of the parse error (I&amp;amp;apos;m not certain but returning 400 is probably against the SOAP spec). This is impossible with the new implementation of WebServiceMessageReceiverHandlerAdapter without re-implementing the handle(...) method. 
Could the handling of this exception (and probably the non-POST transport method) be done by a separate protected method such that it can be overridden?</description>
			<version>2.1 GA</version>
			<fixedVersion>2.1.2</fixedVersion>
			<type>Defect</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.WebServiceMessageReceiverHandlerAdapter.java</file>
		</fixedFiles>
	</bug>
	<bug id="815" opendate="2012-12-04 12:44:11" fixdate="2012-12-05 01:39:32" resolution="Fixed">
		<buginformation>
			<summary>Error loading SAML properties file</summary>
			<description>Wss4j is unable to load the properties file when it is given an absolute path. Wss4j is using the ClassLoader to load the properties file. See http://grepcode.com/file/repository.springsource.com/org.apache.ws/com.springsource.org.apache.ws.security/1.6.5/org/apache/ws/security/saml/SAMLIssuerFactory.java#SAMLIssuerFactory.getProperties%28java.lang.String%29 for how the saml properties file gets loaded by Wss4j.</description>
			<version>2.1.2</version>
			<fixedVersion>2.1.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.security.wss4j.Wss4jSecurityInterceptor.java</file>
		</fixedFiles>
		<links>
			<link type="Relate" description="relates to">796</link>
		</links>
	</bug>
	<bug id="819" opendate="2012-12-06 10:21:53" fixdate="2012-12-07 02:39:30" resolution="Fixed">
		<buginformation>
			<summary>SimpleNamespaceContext.removeBinding() does not clean up all references</summary>
			<description>In SimpleNamespaceContext.removeBinding() the first line should be changed to 
String namespaceUri = prefixToNamespaceUri.remove(prefix);
Otherwise the internal map prefixToNamespaceUri still contains the prefix, and hasBinding(String prefix) behaves incorrectly.
This is error is critical, as under certain circumstances XML schema validation fails. If necessary I can provide an example. </description>
			<version>1.5.9</version>
			<fixedVersion>2.1.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.xml.namespace.SimpleNamespaceContext.java</file>
		</fixedFiles>
	</bug>
	<bug id="888" opendate="2015-01-22 06:26:22" fixdate="2015-03-18 12:40:41" resolution="Complete">
		<buginformation>
			<summary>HttpComponentsMessageSender does not set correctly the maximum connections per host for https connection</summary>
			<description>The following piece of code is used to set the maximum number of connection by route in the method "setMaxConnectionsPerHost":
HttpHost host = new HttpHost(uri.getHost(), uri.getPort(), uri.getScheme());
HttpRoute route = new HttpRoute(host);
This works well for http host but it does not work for https because the route will not be set as "secure".  The following patch seems to work to correct this issue:
if (uri.getScheme().equals("https")) {
     httpRoute = new HttpRoute(httpHost, null, true); 
} else {
    httpRoute = new HttpRoute(httpHost);
}
</description>
			<version>2.1.2</version>
			<fixedVersion>2.2.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.HttpComponentsMessageSender.java</file>
			<file type="M">org.springframework.ws.transport.http.HttpComponentsMessageSenderIntegrationTest.java</file>
		</fixedFiles>
	</bug>
	<bug id="924" opendate="2015-11-01 16:10:34" fixdate="2015-11-02 20:22:02" resolution="Complete">
		<buginformation>
			<summary>Mime header : Multiple keys with same value</summary>
			<description>Hi,
I have an HTTP Response with in the header multiple values for the same key:

cookie : value1
cookie : value2

When I called the function to have the MimeHeaders, I have this:

cookie : value2
cookie : value2

About the code:
SaajSoapMessageFactory use parseMimeHeaders to get header from HTTP Response. Behind this you called http://docs.oracle.com/javase/7/docs/api/java/net/URLConnection.html#getHeaderField(java.lang.String) , this function returned only the last value.
Thanks,
</description>
			<version>2.2.1</version>
			<fixedVersion>2.2.3</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.HttpUrlConnection.java</file>
		</fixedFiles>
	</bug>
	<bug id="929" opendate="2015-12-15 16:19:12" fixdate="2015-12-15 16:37:23" resolution="Complete">
		<buginformation>
			<summary>Fix namespace prefix handling with StreamingPayload</summary>
			<description>The getName() method in JaxbStreamingPayload doesn&amp;amp;apos;t report the actual
namespace prefix that is later generated by the writeTo method. With
Axiom 1.2.13 that didn&amp;amp;apos;t cause problems, but 1.2.14 is less lenient,
causing an error as described in AXIOM-463.
This change:

Updates the StreamingPayload documentation to specify that the
namespace prefix in the QName returned by getName() has no significance
(which is effectively how things are currently).
Updates AxiomSoapBody so that it Axiom is aware that the namespace
prefix of the created OMSourcedElement is unknown.
Modifies the unit test for setStreamingPayload so that it uses a
StreamingPayload with a prefix mismatch.

</description>
			<version>2.2.3</version>
			<fixedVersion>2.2.4</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapBody.java</file>
			<file type="M">org.springframework.ws.stream.StreamingPayload.java</file>
			<file type="M">org.springframework.ws.soap.AbstractSoapMessageTestCase.java</file>
		</fixedFiles>
	</bug>
	<bug id="932" opendate="2016-01-08 12:22:28" fixdate="2016-02-09 17:26:34" resolution="Complete">
		<buginformation>
			<summary>Not enough namespace context during XSD validation when using AxiomSoapMessageFactory</summary>
			<description>XSD request validation using AxiomSoapMessageFactory and PayloadValidatingInterceptor fails with an UndeclaredPrefix validation error, because Axiom does not have full access to the namespace declarations made on the SOAP Envelope level.
As suggested in http://stackoverflow.com/questions/34633662/xsd-validation-fails-with-undeclaredprefix-when-using-axiomsoapmessagefactory-in, a possible fix is to use OMContainer#getXMLStreamReader(boolean, OMXMLStreamReaderConfiguration) and set the preserveNamespaceContext property to true in the OMXMLStreamReaderConfiguration object (in CachingPayload#getStreamReader(OMElement)).
I tested this, and it fixes the problem. Patch is attached, as well as a small sample project exposing the erroneous behaviour.
Request that fails:






&amp;lt;soapenv:Envelope xmlns:sch="http://example.com/springws/extension/schema" xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" &amp;gt;




   &amp;lt;soapenv:Header/&amp;gt;




   &amp;lt;soapenv:Body&amp;gt;




      &amp;lt;sch:formatRequest &amp;gt;




         &amp;lt;sch:value xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="sch:dateType"&amp;gt;




           &amp;lt;sch:day&amp;gt;1&amp;lt;/sch:day&amp;gt;




           &amp;lt;sch:month&amp;gt;1&amp;lt;/sch:month&amp;gt;




           &amp;lt;sch:year&amp;gt;2000&amp;lt;/sch:year&amp;gt;




         &amp;lt;/sch:value&amp;gt;




      &amp;lt;/sch:formatRequest&amp;gt;




   &amp;lt;/soapenv:Body&amp;gt;




&amp;lt;/soapenv:Envelope&amp;gt;






Response is  a SOAP fault with detail






&amp;lt;detail&amp;gt;




    &amp;lt;spring-ws:ValidationError xmlns:spring-ws="http://springframework.org/spring-ws"&amp;gt;UndeclaredPrefix: Cannot resolve &amp;amp;apos;sch:dateType&amp;amp;apos; as a QName: the prefix &amp;amp;apos;sch&amp;amp;apos; is not declared.&amp;lt;/spring-ws:ValidationError&amp;gt;




    &amp;lt;spring-ws:ValidationError xmlns:spring-ws="http://springframework.org/spring-ws"&amp;gt;cvc-elt.4.1: The value &amp;amp;apos;sch:dateType&amp;amp;apos; of attribute &amp;amp;apos;http://www.w3.org/2001/XMLSchema-instance,type&amp;amp;apos; of element &amp;amp;apos;sch:value&amp;amp;apos; is not a valid QName.&amp;lt;/spring-ws:ValidationError&amp;gt;




    &amp;lt;spring-ws:ValidationError xmlns:spring-ws="http://springframework.org/spring-ws"&amp;gt;cvc-type.2: The type definition cannot be abstract for element sch:value.&amp;lt;/spring-ws:ValidationError&amp;gt;




    &amp;lt;spring-ws:ValidationError xmlns:spring-ws="http://springframework.org/spring-ws"&amp;gt;UndeclaredPrefix: Cannot resolve &amp;amp;apos;sch:dateType&amp;amp;apos; as a QName: the prefix &amp;amp;apos;sch&amp;amp;apos; is not declared.&amp;lt;/spring-ws:ValidationError&amp;gt;




    &amp;lt;spring-ws:ValidationError xmlns:spring-ws="http://springframework.org/spring-ws"&amp;gt;cvc-attribute.3: The value &amp;amp;apos;sch:dateType&amp;amp;apos; of attribute &amp;amp;apos;xsi:type&amp;amp;apos; on element &amp;amp;apos;sch:value&amp;amp;apos; is not valid with respect to its type, &amp;amp;apos;QName&amp;amp;apos;.&amp;lt;/spring-ws:ValidationError&amp;gt;




    &amp;lt;spring-ws:ValidationError xmlns:spring-ws="http://springframework.org/spring-ws"&amp;gt;cvc-complex-type.2.1: Element &amp;amp;apos;sch:value&amp;amp;apos; must have no character or element information item [children], because the type&amp;amp;apos;s content type is empty.&amp;lt;/spring-ws:ValidationError&amp;gt;




&amp;lt;/detail&amp;gt;






Request that works, with namespace decl in payload:
localhost:8084/format/format.wsdl






&amp;lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" &amp;gt;




   &amp;lt;soapenv:Header/&amp;gt;




   &amp;lt;soapenv:Body&amp;gt;




      &amp;lt;sch:formatRequest xmlns:sch="http://example.com/springws/extension/schema" &amp;gt;




         &amp;lt;sch:value xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="sch:dateType"&amp;gt;




           &amp;lt;sch:day&amp;gt;1&amp;lt;/sch:day&amp;gt;




           &amp;lt;sch:month&amp;gt;1&amp;lt;/sch:month&amp;gt;




           &amp;lt;sch:year&amp;gt;2000&amp;lt;/sch:year&amp;gt;




         &amp;lt;/sch:value&amp;gt;




      &amp;lt;/sch:formatRequest&amp;gt;




   &amp;lt;/soapenv:Body&amp;gt;




&amp;lt;/soapenv:Envelope&amp;gt;





</description>
			<version>2.2.4</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.CachingPayload.java</file>
		</fixedFiles>
	</bug>
	<bug id="950" opendate="2016-03-14 09:17:00" fixdate="2016-04-05 02:30:36" resolution="Complete">
		<buginformation>
			<summary>getResponseHeaders() is case sensitive</summary>
			<description>In org.springframework.ws.transport.http.HttpUrlConnection we find the following code:






@Override




	public Iterator&amp;lt;String&amp;gt; getResponseHeaders(String name) throws IOException {




		Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; mapHeader = connection.getHeaderFields();




		List&amp;lt;String&amp;gt; listHeaderValues = mapHeader.get(name);




		if (listHeaderValues == null) {




		    return Collections.&amp;lt;String&amp;gt;emptyList().iterator();




		} else {




		    return listHeaderValues.iterator();




		}




	}






This code returns an Iterator containing the HTTP-Header(s) that matches the parameter "name" . The problem is that this is case sensitive. According to the RFC HTTP-Headers are case-insensitive</description>
			<version>2.2.3</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.transport.http.HttpUrlConnection.java</file>
			<file type="M">org.springframework.ws.transport.http.AbstractHttpWebServiceMessageSenderIntegrationTestCase.java</file>
		</fixedFiles>
	</bug>
	<bug id="930" opendate="2015-12-18 16:13:03" fixdate="2016-04-11 16:28:43" resolution="Complete">
		<buginformation>
			<summary>NoSuchMethodError when using Axiom 1.2.14</summary>
			<description>The changes made for SWS-922 have resulted in Spring Web Services no longer working with Axiom 1.2.14. Specifically the move to using getSOAPMessage in place of the, deprecated in 1.2.15, getSoapMessage. IMO, it would be preferable to continue to use getSoapMessage and suppress the deprecation warning. This approach will make things compatible with Axiom 1.2.14 and 1.2.15.</description>
			<version>2.2.4</version>
			<fixedVersion>2.3.0</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.soap.axiom.AxiomSoapMessageFactory.java</file>
		</fixedFiles>
	</bug>
	<bug id="947" opendate="2016-02-11 15:20:09" fixdate="2016-08-23 16:28:54" resolution="Complete">
		<buginformation>
			<summary>race-condition breaks dynamic WSDL </summary>
			<description>We have developed a couple of Spring Webservices deployed on Tomcat in a (stateless) Docker container that from time to time somehow fail to start correctly and return a stacktrace instead of the WSDL. Restarting the container will almost always fix it at the first attempt.
The same issue was reported here by someone else: http://forum.spring.io/forum/spring-projects/web-services/122858-thread-safety-issue-with-requests-to-wsdl 
It looks like it is similar to bugs like these:

https://issues.apache.org/jira/browse/XERCESJ-211
https://netbeans.org/bugzilla/show_bug.cgi?id=111862#c15

Below the complete stacktrace:
08:14:35.378 [http-nio-8080-exec-1] DEBUG o.s.w.t.h.MessageDispatcherServlet - Could not complete request
javax.xml.transform.TransformerException: java.lang.NullPointerException
        at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:752) ~[na:1.8.0_40-internal]
        at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:357) ~[na:1.8.0_40-internal]
        at org.springframework.ws.transport.http.WsdlDefinitionHandlerAdapter.handle(WsdlDefinitionHandlerAdapter.java:144) ~[spring-ws-core-2.2.0.RELEASE.jar:2.2.0.RELEASE]
        at org.springframework.ws.transport.http.MessageDispatcherServlet.doService(MessageDispatcherServlet.java:285) ~[spring-ws-core-2.2.0.RELEASE.jar:2.2.0.RELEASE]
        at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:961) [spring-webmvc-4.0.5.RELEASE.jar:4.0.5.RELEASE]
        at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:852) [spring-webmvc-4.0.5.RELEASE.jar:4.0.5.RELEASE]
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:618) [servlet-api.jar:na]
        at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:837) [spring-webmvc-4.0.5.RELEASE.jar:4.0.5.RELEASE]
        at javax.servlet.http.HttpServlet.service(HttpServlet.java:725) [servlet-api.jar:na]
        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:291) [catalina.jar:8.0.20]
        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) [catalina.jar:8.0.20]
        at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) [tomcat-websocket.jar:8.0.20]
        at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:239) [catalina.jar:8.0.20]
        at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:206) [catalina.jar:8.0.20]
        at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:219) [catalina.jar:8.0.20]
        at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:106) [catalina.jar:8.0.20]
        at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:501) [catalina.jar:8.0.20]
        at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:142) [catalina.jar:8.0.20]
        at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79) [catalina.jar:8.0.20]
        at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:610) [catalina.jar:8.0.20]
        at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88) [catalina.jar:8.0.20]
        at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:516) [catalina.jar:8.0.20]
        at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1086) [tomcat-coyote.jar:8.0.20]
        at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:659) [tomcat-coyote.jar:8.0.20]
        at org.apache.coyote.http11.Http11NioProtocol$Http11ConnectionHandler.process(Http11NioProtocol.java:223) [tomcat-coyote.jar:8.0.20]
        at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1558) [tomcat-coyote.jar:8.0.20]
        at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.run(NioEndpoint.java:1515) [tomcat-coyote.jar:8.0.20]
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_40-internal]
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_40-internal]
        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-util.jar:8.0.20]
        at java.lang.Thread.run(Thread.java:745) [na:1.8.0_40-internal]
Caused by: java.lang.NullPointerException: null
        at com.sun.org.apache.xerces.internal.dom.DeferredElementNSImpl.synchronizeData(DeferredElementNSImpl.java:108) ~[na:1.8.0_40-internal]
        at com.sun.org.apache.xerces.internal.dom.ElementImpl.getNodeName(ElementImpl.java:122) ~[na:1.8.0_40-internal]
        at com.sun.org.apache.xalan.internal.xsltc.trax.DOM2TO.parse(DOM2TO.java:152) ~[na:1.8.0_40-internal]
        at com.sun.org.apache.xalan.internal.xsltc.trax.DOM2TO.parse(DOM2TO.java:230) ~[na:1.8.0_40-internal]
        at com.sun.org.apache.xalan.internal.xsltc.trax.DOM2TO.parse(DOM2TO.java:230) ~[na:1.8.0_40-internal]
        at com.sun.org.apache.xalan.internal.xsltc.trax.DOM2TO.parse(DOM2TO.java:230) ~[na:1.8.0_40-internal]
        at com.sun.org.apache.xalan.internal.xsltc.trax.DOM2TO.parse(DOM2TO.java:230) ~[na:1.8.0_40-internal]
        at com.sun.org.apache.xalan.internal.xsltc.trax.DOM2TO.parse(DOM2TO.java:230) ~[na:1.8.0_40-internal]
        at com.sun.org.apache.xalan.internal.xsltc.trax.DOM2TO.parse(DOM2TO.java:136) ~[na:1.8.0_40-internal]
        at com.sun.org.apache.xalan.internal.xsltc.trax.DOM2TO.parse(DOM2TO.java:98) ~[na:1.8.0_40-internal]
        at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transformIdentity(TransformerImpl.java:699) ~[na:1.8.0_40-internal]
        at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.transform(TransformerImpl.java:743) ~[na:1.8.0_40-internal]
        ... 30 common frames omitted</description>
			<version>2.2.0.RELEASE</version>
			<fixedVersion>2.3.1</fixedVersion>
			<type>Bug</type>
		</buginformation>
		<fixedFiles>
			<file type="M">org.springframework.ws.wsdl.wsdl11.Wsdl4jDefinition.java</file>
		</fixedFiles>
	</bug>
</bugrepository>