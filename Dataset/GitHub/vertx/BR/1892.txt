Race condition in Future setHandler/completion between threads
In one of our projects we have encountered a problem with CompositeFuture.all() when running "outside"
of a verticle (in junit tests). Here is a sample program:
import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.Vertx;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class CompositeFutureTest {
    private static final int NUMBER_OF_LOOPS = 10_000;
    private static final Vertx vertx = Vertx.vertx();

    private static boolean testCompositeFuture() throws InterruptedException, ExecutionException {
        CountDownLatch finished = new CountDownLatch(1);
        AtomicInteger atomicCounter = new AtomicInteger(0);

        for (int i = 0; i < NUMBER_OF_LOOPS; i++) {
            Future<Void> future1 = Future.future();
            Future<Void> future2 = Future.future();

            vertx.runOnContext(future1::complete);
            vertx.runOnContext(future2::complete);

            CompositeFuture.all(future1, future2).setHandler(ar -> {
                if (ar.succeeded()) {
                    if (atomicCounter.incrementAndGet() == NUMBER_OF_LOOPS) {
                        finished.countDown();
                    }
                }
            });
        }

        boolean result = finished.await(10, TimeUnit.SECONDS);

        System.out.println(String.format("%s: %s == %s", result ? "OK": "ERROR", atomicCounter, NUMBER_OF_LOOPS));

        return result;
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        while (testCompositeFuture());
        vertx.close();
    }
}
After a while it prints something like
ERROR: 9985 == 10000

Inside implementation of CompositeFutureImpl.all() the setHandler() function is called upon each future in the composition (in our case two). The problem here is that the completion of futures runs in a different thread than setting the handler. Neither of the functions (setHandler() nor complete()) are atomic and it may result in
a situation when the handler is never called. The problem seems to be more fundamental. The future
implementation (FutureImpl) is not thread safe and using it from different threads may cause difficulties.
When running inside a verticle it's ok because asynchronous callbacks are serialized within the event loop
and should not run concurrently.
I don't know if this is an expected behaviour and Futures (and their compositions) should be used only
within verticles. Our understanding based on looking into the implementation of CompositeFutureImpl is that
the intention was to make it thread safe.
