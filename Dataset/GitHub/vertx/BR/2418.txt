Possible deadlock when trying to get multiple locks
Here is the code, which illustrates the problem.
The Consumer verticle acuires lock1 and gets stuck.
I have reproduced the same problem using HazelcastClusterManager and IgniteClusterManager.
    Vertx.clusteredVertx(
        new VertxOptions().setClusterManager(new HazelcastClusterManager()),
        result -> {
          final Vertx vertx = result.result();

          final int messagesToSend = 10;

          final Consumer consumer = new Consumer();
          vertx.deployVerticle(
              consumer,
              new DeploymentOptions(),
              event -> {
                if (event.succeeded()) {
                  vertx.deployVerticle(
                      new Supplier(messagesToSend),
                      new DeploymentOptions()
                  );
                }
              }
          );

          vertx.setTimer(
              messagesToSend * DEFAULT_LOCK_TIMEOUT,
              timer -> {
                final long failsNumber = messagesToSend - consumer.counter.sum();
                if (failsNumber != 0) {
                  System.err.println("Failed to get " + failsNumber + " locks");
                }
                vertx.close();
              }
          );
        }
    );
  class Supplier extends AbstractVerticle {
    private final long messagesToSend;

    public Supplier(long messagesToSend) {
      this.messagesToSend = messagesToSend;
    }

    @Override
    public void start() {
      final LongAdder sent = new LongAdder();
      vertx.setPeriodic(1, timer -> {
        vertx.eventBus().send(TEST_ADDRESS, "message");
        sent.increment();
        System.out.println(sent.sum() + " messages sent");
        if (sent.sum() >= messagesToSend) {
          vertx.cancelTimer(timer);
        }
      });
    }
  }
class Consumer extends AbstractVerticle {
    private final LongAdder counter = new LongAdder();

    @Override
    public void start(Future<Void> startFuture) {
      vertx.eventBus().consumer(
          TEST_ADDRESS,
          event -> {
            vertx.sharedData().getLock("lock1", lock1 -> {
              if (lock1.failed()) {
                System.out.println("Failed to get lock1: " + lock1.cause());
              } else {
                System.out.println("Succeeded to get lock1");
                vertx.sharedData().getLock("lock2", lock2 -> {
                  if (lock2.failed()) {
                    System.out.println("Failed to get lock2: " + lock2.cause());
                  } else {
                    System.out.println("Succeeded to get lock2");
                    counter.increment();
                    System.out.println(counter.sum() + " messages consumed");
                    lock2.result().release();
                  }
                  lock1.result().release();
                });
              }
            });
          }
      ).completionHandler(startFuture);
    }
  }
