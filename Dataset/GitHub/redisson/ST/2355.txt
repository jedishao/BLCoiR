RedissonLock.unlock() hangs infinitely waiting for RedissonPromise
Expected behavior
Calls to RedissonLock.unlock() are expected to finish after the lock has been deleted from Redis.

Actual behavior
We have experienced several threads locked forever waiting inside calls to RedissonLock.unlock() in our production system within a few hours after upgrading to Redisson 3.11.4 from Redisson 3.8.0.

Steps to reproduce or test case
Unfortunately I am unable to reproduce the problem on my own computer. We have however experienced it on several of our production servers within just a few hours after starting our newer version of the application with updated Redisson version. We upgraded from 3.8.0 in order to receive fixes for bug #1966 - Deadlock after Redis timeout, which we also experienced a couple of times. However right after start we have found some (29) exceptions in our logs coming from internal redisson threads:

[redisson-netty-5-24] WARN  io.netty.util.concurrent.DefaultPromise - An exception was thrown by org.redisson.misc.RedissonPromise$$Lambda$50/265319658.operationComplete()
java.lang.NullPointerException: null
	at org.redisson.RedissonLock.cancelExpirationRenewal(RedissonLock.java:330) ~[redisson-3.11.4.jar:3.11.4]
	at org.redisson.RedissonLock.lambda$unlockAsync$3(RedissonLock.java:583) ~[redisson-3.11.4.jar:3.11.4]
	at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187) ~[redisson-3.11.4.jar:3.11.4]
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577) ~[netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570) ~[netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549) ~[netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490) ~[netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615) ~[netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:604) ~[netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104) ~[netty-common-4.1.41.Final.jar:4.1.41.Final]
	at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82) ~[redisson-3.11.4.jar:3.11.4]
	at org.redisson.command.RedisExecutor.handleReference(RedisExecutor.java:505) ~[redisson-3.11.4.jar:3.11.4]
	at org.redisson.command.RedisExecutor.handleSuccess(RedisExecutor.java:498) ~[redisson-3.11.4.jar:3.11.4]
	at org.redisson.command.RedisExecutor.handleResult(RedisExecutor.java:483) ~[redisson-3.11.4.jar:3.11.4]
	at org.redisson.command.RedisExecutor.checkAttemptPromise(RedisExecutor.java:469) ~[redisson-3.11.4.jar:3.11.4]
	at org.redisson.command.RedisExecutor.lambda$execute$3(RedisExecutor.java:187) ~[redisson-3.11.4.jar:3.11.4]
	at org.redisson.misc.RedissonPromise.lambda$onComplete$0(RedissonPromise.java:187) ~[redisson-3.11.4.jar:3.11.4]
	at io.netty.util.concurrent.DefaultPromise.notifyListener0(DefaultPromise.java:577) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners0(DefaultPromise.java:570) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListenersNow(DefaultPromise.java:549) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.notifyListeners(DefaultPromise.java:490) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.setValue0(DefaultPromise.java:615) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.setSuccess0(DefaultPromise.java:604) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.DefaultPromise.trySuccess(DefaultPromise.java:104) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at org.redisson.misc.RedissonPromise.trySuccess(RedissonPromise.java:82) [redisson-3.11.4.jar:3.11.4]
	at org.redisson.client.handler.CommandDecoder.completeResponse(CommandDecoder.java:454) [redisson-3.11.4.jar:3.11.4]
	at org.redisson.client.handler.CommandDecoder.handleResult(CommandDecoder.java:449) [redisson-3.11.4.jar:3.11.4]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:372) [redisson-3.11.4.jar:3.11.4]
	at org.redisson.client.handler.CommandDecoder.decodeCommand(CommandDecoder.java:209) [redisson-3.11.4.jar:3.11.4]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:147) [redisson-3.11.4.jar:3.11.4]
	at org.redisson.client.handler.CommandDecoder.decode(CommandDecoder.java:117) [redisson-3.11.4.jar:3.11.4]
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:505) [netty-codec-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.handler.codec.ReplayingDecoder.callDecode(ReplayingDecoder.java:366) [netty-codec-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:283) [netty-codec-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) [netty-transport-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) [netty-transport-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:352) [netty-transport-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1422) [netty-transport-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:374) [netty-transport-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:360) [netty-transport-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:931) [netty-transport-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163) [netty-transport-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:700) [netty-transport-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:635) [netty-transport-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:552) [netty-transport-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:514) [netty-transport-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.SingleThreadEventExecutor$6.run(SingleThreadEventExecutor.java:1044) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) [netty-common-4.1.41.Final.jar:4.1.41.Final]
	at java.lang.Thread.run(Thread.java:748) [?:1.8.0_151]
After that we were investigating issues with blocked threads by analyzing thread dumps. All stuck threads had exactly the same stack trace as below:

 rabbitmq-thread-1awaiting notification on [ 0x00000005e298c400 ] , holding [ 0x00000005cad3ebd0 ]
at java.lang.Object.wait(Native Method)
at java.lang.Object.wait(Object.java:502)
at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:252)
at org.redisson.misc.RedissonPromise.await(RedissonPromise.java:110)
at org.redisson.misc.RedissonPromise.await(RedissonPromise.java:35)
at org.redisson.command.CommandAsyncService.get(CommandAsyncService.java:132)
at org.redisson.RedissonObject.get(RedissonObject.java:90)
at org.redisson.RedissonLock.unlock(RedissonLock.java:453)
at ... (our code goes below)
After examining the source code of RedissonLock.java we have found that the NullPointerException occurs probably due to missing timeout object inside task:

329:        if (threadId == null || task.hasNoThreads()) {
330:            task.getTimeout().cancel();
331:            EXPIRATION_RENEWAL_MAP.remove(getEntryName());
332:        }
I'm not sure if it would solve the root cause why task.getTimeout() returns null, but calls to cancelExpirationRenewal method should not fail with an exception, otherwise, e.g. in RedissonLock.unlockAsync method the future will never receive a result (or a failure):

    @Override
    public RFuture<Void> unlockAsync(long threadId) {
        RPromise<Void> result = new RedissonPromise<Void>();
        RFuture<Boolean> future = unlockInnerAsync(threadId);

        future.onComplete((opStatus, e) -> {
            if (e != null) {
                cancelExpirationRenewal(threadId);
                result.tryFailure(e);
                return;
            }

            if (opStatus == null) {
                IllegalMonitorStateException cause = new IllegalMonitorStateException("attempt to unlock lock, not locked by current thread by node id: "
                        + id + " thread-id: " + threadId);
                result.tryFailure(cause);
                return;
            }
            
            cancelExpirationRenewal(threadId);
            result.trySuccess(null);
        });

        return result;
    }
Please add null check for timeout inside the ExpirationEntry object.

We had to return to 3.8.0 version because of this problem. I think it is quire severe.

Redis version
4.0.2

Redisson version
3.11.4

Redisson configuration
Default configuration with sentinel servers.