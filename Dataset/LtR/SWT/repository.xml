<bugrepository name="SWT">
    <bug id="183830" opendate="2007-04-24 13:21:28" fixdate="2005-01-27 10:24:22" resolution="Fixed">
        <buginformation>
            <summary>"Xlib: unexpected async reply" and deadlock in GLX.glXMakeCurrent(int, int, int).
            </summary>
            <description>Every so often our OpenGL program just locks up under Linux.
                "Xlib: unexpected async reply" is printed to stderr, and if we pause the program in the debugger we find
                that the main thread is deadlocked in GLCanvas.setCurrent()->GLX.glXMakeCurrent(int, int, int).
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.swt.internal.opengl.glx.GLX.java</file>
        </fixedFiles>
    </bug>
    <bug id="188320" opendate="2007-05-22 10:17:23" fixdate="2009-09-02 07:58:53" resolution="Fixed">
        <buginformation>
            <summary>Possible Deadlock in JFace ModalContextBuild ID: M20070212-1330.
            </summary>
            <description>The inner class ModalContextThread is not threadsafe and sometimes leads to a deadlock, at
                least under Linux + GTK.

                The problem is, that the block() method not always returns, when the run() method is finished.

                Have a look at these two methods:
                The block() method is called in the SWT thread and does basically this:

                while(continueEventDispatching)
                if (!display.readAndDispatch())
                display.sleep();

                The run method is called in an own thread and does (after the execution of the task) basically this:

                display.syncExec(new Runnable(){});
                continueEventDispatching = false;
                display.asyncExec(null);

                The asyncExec(null) should wake up the SWT thread from display.sleep().
                Unfortunately, this does not work, when the asyncExec() is executed exactly between the
                display.readAndDispatch() and the display.sleep(). This can happen, because there is no synchronisation.
                In this case the display.sleep() does not return immediately, but waits for the next event, which may
                come never.

                You can see the same problem in the following code snippet:

                public static void main(String[] args) throws InterruptedException {
                final Shell shell = new Shell();
                while(true){
                if (! shell.getDisplay().readAndDispatch()){
                Thread async = new Thread(){
                public void run() {
                shell.getDisplay().asyncExec(null);
                }
                };
                async.start();
                async.join();
                System.out.println("sleep");
                shell.getDisplay().sleep();
                System.out.println("wakeup");
                }
                }
                }


                A fix for this problem would be to call
                display.asyncExec(new Runnable(){
                public void run(){
                }
                });
                In contrast to using the null argument, this Runnable generates a real event instead of just waking up
                the SWT thread. So the SWT thread does not really begin to sleep.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.swt.widgets.Synchronizer.java</file>
        </fixedFiles>
    </bug>
    <bug id="176792" opendate="2007-03-09 03:25:55" fixdate="2007-04-03 15:38:31" resolution="Fixed">
        <buginformation>
            <summary>org.eclipse.swt.internal.ole.win32.ComObject misbehavior in multithreaded application.
            </summary>
            <description>org.eclipse.swt.internal.ole.win32.ComObject constructor accesses to Callbacks and ObjectMap
                static fields.
                In multithreaded applications this sometimes leads to org.eclipse.swt.SWTError exceptions with message
                "No more callbacks".

                Solution
                Enclose constructor code in synchronized block

                public COMObject(int[] argCounts) {
                int[] callbackAddresses = new int[argCounts.length];
                synchronized (Callbacks) { //!!! added line
                for (int i = 0, length = argCounts.length; i length; i++){
                if ((Callbacks[i][argCounts[i]]) == null) {
                Callbacks[i][argCounts[i]] = new Callback(this.getClass(), "callback"+i, argCounts[i] + 1, true,
                COM.E_FAIL); //$NON-NLS-1$
                if (Callbacks[i][argCounts[i]].getAddress() == 0) SWT.error(SWT.ERROR_NO_MORE_CALLBACKS);
                }
                callbackAddresses[i] = Callbacks[i][argCounts[i]].getAddress();
                }

                int pVtable = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, 4 * argCounts.length);
                COM.MoveMemory(pVtable, callbackAddresses, 4 * argCounts.length);
                ppVtable = OS.GlobalAlloc(COM.GMEM_FIXED | COM.GMEM_ZEROINIT, 4);
                COM.MoveMemory(ppVtable, new int[] {pVtable}, 4);
                ObjectMap.put(new Integer(ppVtable), this);
                } //!!! added line
                }
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.swt.internal.ole.win32.COMObject.java</file>
        </fixedFiles>
    </bug>
    <bug id="338965" opendate="2011-03-04 13:29:18" fixdate="2011-12-15 15:36:54" resolution="Fixed">
        <buginformation>
            <summary>Deadlock/Hang on UI Thread.</summary>
            <description></description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.swt.widgets.MessageBox.java</file>
        </fixedFiles>
    </bug>
    <bug id="264399" opendate="2009-02-10 13:22:56" fixdate="2009-02-23 10:32:21" resolution="Fixed">
        <buginformation>
            <summary>A deadlock occurs during automated testing of a SWT application on Linux/GTK/x86_64.</summary>
            <description></description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.eclipse.swt.widgets.Control.java</file>
        </fixedFiles>
    </bug>
</bugrepository>