<bugrepository name="AspectJ">
    <bug id="318878" opendate="2010-07-05 07:23:40" fixdate="2013-02-25 18:27:08" resolution="Fixed">
        <buginformation>
            <summary>Pertarget aspect instantiation is not thread-safe.
            </summary>
            <description>The way in which pertarget aspects compiled with ajc check if a given target already has an
                aspect is not thread safe.
                When two different threads trigger an advice on a target object for the first time at the same time,
                sometimes the aspect for that target gets created twice.

                The following code demonstrates the problem:

                The following pertarget aspect will add itself to a (synchronized) set in another class in it's
                constructor.

                aspect Pertarget pertarget(execution(void foo())) {
                public Pertarget() {
                Main.aspects.add(this); // Add this instance to the set in Main
                }
                before(): execution(void foo()) {} // Empty advice to trigger creation
                }

                This class creates 10000 target objects and has two separate threads call a method (that causes the
                aspect to be instantiated) on each object. The aspects add themselves to the "aspects" set and this
                set's size is printed when all threads have finished.

                import java.util.Collections;
                import java.util.IdentityHashMap;
                import java.util.Set;

                public class Main {
                public static Set aspects = Collections.synchronizedSet(
                Collections.newSetFromMap(new IdentityHashMap()));
                public static void main(String[] args) throws InterruptedException {
                for (int i = 0; i
                10000; ++i) {
                final Main m = new Main(); // Create a new target for the aspect
                Runnable r = new Runnable() {
                public void run() { m.foo(); } // This will trigger the advice
                };
                Thread t1 = new Thread(r);
                Thread t2 = new Thread(r);
                t1.start();
                t2.start();
                t1.join();
                t2.join();
                }
                System.out.println(aspects.size()); // Should be 10000
                }
                private void foo() {}
                }

                When compiled with ajc and run, the main method prints values over 10000 (something like 10030-10060
                typically), which means that some target objects get multiple aspect instances.

                In my own application I sometimes also saw some threads accessing partially built aspect instances. This
                was quite rare however and I wasn't able to make a test case for it.

                The ajc version (the current stable) used was:
                AspectJ Compiler 1.6.8 (1.6.8 - Built: Friday Jan 8, 2010 at 21:53:37 GMT) - Eclipse Compiler
                0.785_R33x, 3.3

                The sun vm version was:
                Java(TM) SE Runtime Environment (build 1.6.0_20-b02)
                Java HotSpot(TM) 64-Bit Server VM (build 16.3-b01, mixed mode)

                I investigated the source of this problem: the ajc compiler generates the following (decompiled) method
                into the aspect class:

                public static void ajc$perObjectBind(Object obj)
                {
                if((obj instanceof ajcMightHaveAspect)  ((ajcMightHaveAspect)obj).perObjectGet() == null)
                ((ajcMightHaveAspect)obj).perObjectSet(new Pertarget());
                }

                , which obviously is not thread safe.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.aspectj.weaver.AjcMemberMaker.java</file>
        </fixedFiles>
    </bug>
    <bug id="340806" opendate="2011-03-23 16:35:10" fixdate="2012-10-31 18:00:52" resolution="Fixed">
        <buginformation>
            <summary>Race condition in JavaLangTypeToResolvedTypeConverter (potentially exposed through Spring AOP).
            </summary>
            <description></description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.aspectj.weaver.reflect.JavaLangTypeToResolvedTypeConverter.java</file>
        </fixedFiles>
    </bug>
    <bug id="59909" opendate="2004-04-26 05:40:05" fixdate="2012-04-03 15:52:45" resolution="Fixed">
        <buginformation>
            <summary>CFlowStack removesThreads to lateProblem.
            </summary>
            <description>The current implementation of CFlowStack (Version 1.1-till 1.2 rc1) stores all threads in a
                hashtable.
                These Threads are removes after several calls to the methods getThreadStack(). (In our cases >70 calls.)
                In our project, this cycle is much to long.
                We have soveral long running threads, which grap quite a lot of lot of memory.
                This memory can only be freed after the threads have been removed from the CFlowStack.
                In our production code we sum up to more than 300 Threads stored in different CFlowStack Varaibles.
                Often this results in out of memory Errors.
                Added patch provides an improved freeing scheme.
                It checks if the size of the table has grown, if it has, it checks if it can remove some threads.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.aspectj.runtime.internal.CFlowStack.java</file>
            <file type="M">org.aspectj.runtime.internal.cflowstack.ThreadStack.java</file>
            <file type="M">org.aspectj.runtime.internal.cflowstack.ThreadStackFactory.java</file>
            <file type="M">org.aspectj.runtime.internal.cflowstack.ThreadStackFactoryImpl.java</file>
            <file type="M">org.aspectj.runtime.internal.cflowstack.ThreadStackFactoryImpl11.java</file>
            <file type="M">org.aspectj.runtime.internal.cflowstack.ThreadStackImpl11.java</file>
        </fixedFiles>
    </bug>
    <bug id="408721" opendate="2013-05-22 12:10:52" fixdate="2013-06-26 18:08:38" resolution="Fixed">
        <buginformation>
            <summary>java.util.ConcurrentModificationException when multiple threads enter the weaver.
            </summary>
            <description>I am using AspectJ 1.7.1.
                Occasionally I see the following exception, which I believe is related to multiple threads initializing
                some internal state.

                java.util.ConcurrentModificationException: null
                at java.util.ArrayList$Itr.checkForComodification(Unknown Source) ~[na:1.7.0_11]
                at java.util.ArrayList$Itr.next(Unknown Source) ~[na:1.7.0_11]
                at org.aspectj.weaver.ReferenceType.findDerivativeType(ReferenceType.java:1122)
                ~[aspectjweaver.jar:1.7.1]
                at org.aspectj.weaver.TypeFactory.createParameterizedType(TypeFactory.java:44)
                ~[aspectjweaver.jar:1.7.1]
                at org.aspectj.weaver.ResolvedType.parameterize(ResolvedType.java:2479) ~[aspectjweaver.jar:1.7.1]
                at org.aspectj.weaver.ReferenceType.getDeclaredInterfaces(ReferenceType.java:673)
                ~[aspectjweaver.jar:1.7.1]
                at org.aspectj.weaver.ResolvedType.getDirectSupertypes(ResolvedType.java:82) ~[aspectjweaver.jar:1.7.1]
                at org.aspectj.weaver.patterns.TypePattern.matchesSubtypes(TypePattern.java:178)
                ~[aspectjweaver.jar:1.7.1]
                at org.aspectj.weaver.patterns.ExactTypePattern.matchesSubtypes(ExactTypePattern.java:74)
                ~[aspectjweaver.jar:1.7.1]
                at org.aspectj.weaver.patterns.TypePattern.matchesStatically(TypePattern.java:130)
                ~[aspectjweaver.jar:1.7.1]
                at org.aspectj.weaver.patterns.KindedPointcut.fastMatch(KindedPointcut.java:130)
                ~[aspectjweaver.jar:1.7.1]
                at
                org.aspectj.weaver.internal.tools.PointcutExpressionImpl.couldMatchJoinPointsInType(PointcutExpressionImpl.java:84)
                ~[aspectjweaver.jar:1.7.1]
                at org.springframework.aop.aspectj.AspectJExpressionPointcut.matches(AspectJExpressionPointcut.java:250)
                ~[spring-aop.jar:3.2.1.RELEASE]
                at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:208) ~[spring-aop.jar:3.2.1.RELEASE]
                at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:262) ~[spring-aop.jar:3.2.1.RELEASE]
                at org.springframework.aop.support.AopUtils.findAdvisorsThatCanApply(AopUtils.java:294)
                ~[spring-aop.jar:3.2.1.RELEASE]
                at
                org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply(AbstractAdvisorAutoProxyCreator.java:118)
                ~[spring-aop.jar:3.2.1.RELEASE]
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.aspectj.weaver.ReferenceType.java</file>
        </fixedFiles>
    </bug>
    <bug id="155148" opendate="2006-08-24 20:59:00" fixdate="2012-04-03 15:28:08" resolution="Fixed">
        <buginformation>
            <summary>jdk14 trace deadlock in oc4j.
            </summary>
            <description>I turned on tracing for the Aj class inside of Oracle's OC4J server.
                In one test (not always) it deadlocked.
                It looks like the threads are each trying to lock each other's loader.
                Notice that one of the threads is in the toString method of the Oracle ClassLoader (perhaps another
                reason to prefer tracing argument class names and system identity hashcodes).

                Here's a thread dump from Ctrl+BREAK:

                Found one Java-level deadlock:
                =============================
                "WorkExecutorWorkerThread-1":
                waiting to lock monitor 0x003384ec (object 0x05239e48, a oracle.classloader.Po licyClassLoader),
                which is held by "OC4J Launcher"
                "OC4J Launcher":
                waiting to lock monitor 0x0033848c (object 0x0554f0e8, a oracle.classloader.Po licyClassLoader),
                which is held by "WorkExecutorWorkerThread-1"
                Java stack information for the threads listed above:
                ===================================================
                "WorkExecutorWorkerThread-1":
                at oracle.classloader.SearchPolicy.loadClass(SearchPolicy.java:641)
                - waiting to lock#0x05239e48> (a oracle.classloader.PolicyClassLoader)
                at oracle.classloader.PolicyClassLoader.askParentForClass(PolicyClassLoa der.java:1284)
                at oracle.classloader.SearchPolicy$AskParent.getClass(SearchPolicy.java:69)
                at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119)
                at oracle.classloader.SearchPolicy.loadClass(SearchPolicy.java:642)
                - locked#0x0554f0e8> (a oracle.classloader.PolicyClassLoader)
                at oracle.classloader.PolicyClassLoader.askParentForClass(PolicyClassLoader.java:1284)
                at oracle.classloader.SearchPolicy$AskParent.getClass(SearchPolicy.java:69)
                at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119)
                at oracle.classloader.PolicyClassLoader.internalLoadClass(PolicyClassLoader.java:1660)
                - locked#0x056a9ed0> (a oracle.classloader.PolicyClassLoader)
                at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java:1621)
                at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java:1606)
                at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
                - locked#0x056a9ed0> (a oracle.classloader.PolicyClassLoader)
                at oracle.j2ee.ra.jms.generic.WorkConsumer.doReceive(WorkConsumer.java:987)
                at oracle.j2ee.ra.jms.generic.WorkConsumer.run(WorkConsumer.java:215)
                - locked#0x05de2718> (a oracle.j2ee.ra.jms.generic.WorkConsumer)
                at oracle.j2ee.connector.work.WorkWrapper.runTargetWork(WorkWrapper.java:242)
                at oracle.j2ee.connector.work.WorkWrapper.doWork(WorkWrapper.java:215)
                at oracle.j2ee.connector.work.WorkWrapper.run(WorkWrapper.java:190)
                at EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(PooledExecutor.java:814)
                at java.lang.Thread.run(Thread.java:595)
                "OC4J Launcher":
                at oracle.classloader.PolicyClassLoader.toString(PolicyClassLoader.java:1846)
                - waiting to lock#0x0554f0e8> (a oracle.classloader.PolicyClassLoader)
                at java.text.MessageFormat.subformat(MessageFormat.java:1237)
                at java.text.MessageFormat.format(MessageFormat.java:828)
                at java.text.Format.format(Format.java:133)
                at java.text.MessageFormat.format(MessageFormat.java:804)
                at java.util.logging.Formatter.formatMessage(Formatter.java:130)
                - locked#0x0514e920> (a java.util.logging.SimpleFormatter)
                at java.util.logging.SimpleFormatter.format(SimpleFormatter.java:63)
                - locked#0x0514e920> (a java.util.logging.SimpleFormatter)
                at java.util.logging.StreamHandler.publish(StreamHandler.java:179)
                - locked#0x0514a0a8> (a java.util.logging.FileHandler)
                at java.util.logging.FileHandler.publish(FileHandler.java:555)
                - locked#0x0514a0a8> (a java.util.logging.FileHandler)
                at java.util.logging.Logger.log(Logger.java:428)
                at java.util.logging.Logger.doLog(Logger.java:450)
                at java.util.logging.Logger.logp(Logger.java:619)
                at java.util.logging.Logger.entering(Logger.java:870)
                at org.aspectj.weaver.tools.Jdk14Trace.enter(Jdk14Trace.java:32)
                at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:67)
                at
                org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55)
                at sun.instrument.TransformerManager.transform(TransformerManager.java:122)
                at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155)
                at java.lang.ClassLoader.defineClass1(Native Method)
                at java.lang.ClassLoader.defineClass(ClassLoader.java:620)
                at oracle.classloader.PolicyClassLoader.defineClass(PolicyClassLoader.java:2224)
                at oracle.classloader.PolicyClassLoader.findLocalClass(PolicyClassLoader.java:1457)
                at oracle.classloader.SearchPolicy$FindLocal.getClass(SearchPolicy.java:167)
                at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119)
                at oracle.classloader.PolicyClassLoader.internalLoadClass(PolicyClassLoader.java:1660)
                - locked#0x05239e48> (a oracle.classloader.PolicyClassLoader)
                at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java:1621)
                at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java:1606)
                at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319)
                - locked#0x05239e48> (a oracle.classloader.PolicyClassLoader)
                at com.evermind.server.http.HttpRequestHandler.#init#(HttpRequestHandler.java:97)
                at
                com.evermind.server.http.HttpConnectionListener$HttpNIOAcceptHandler.getReadHandler(HttpConnectionListener.java:116)
                at oracle.oc4j.network.ReadHandlerPool.getContextFromBackend(ReadHandlerPool.java:63)
                at com.evermind.util.BBPool.startPool(BBPool.java:42)
                at oracle.oc4j.network.ReadHandlerPool.register(ReadHandlerPool.java:25)

                - locked#0x05ec9290> (a java.util.ArrayList)
                at oracle.oc4j.network.ServerSocketAcceptHandler.setPoolOptions(ServerSocketAcceptHandler.java:140)
                at
                com.evermind.server.http.HttpConnectionListener.setRequestHandlerPool(HttpConnectionListener.java:232)
                at com.evermind.server.http.HttpConnectionListener.initHandlers(HttpConnectionListener.java:226)
                at com.evermind.server.http.HttpConnectionListener.#init#(HttpConnectionListener.java:174)
                at com.evermind.server.http.HttpServer.getListener(HttpServer.java:481)
                - locked#0x05ec4f88> (a com.evermind.server.http.HttpServer)
                at com.evermind.server.http.HttpServer.setSites(HttpServer.java:267)
                - locked#0x05ec4f88> (a com.evermind.server.http.HttpServer)
                at com.evermind.server.http.HttpServer.setConfig(HttpServer.java:180)
                at com.evermind.server.ApplicationServer.initializeHttp(ApplicationServer.java:2296)
                at com.evermind.server.ApplicationServer.setConfig(ApplicationServer.java:944)
                at com.evermind.server.ApplicationServerLauncher.run(ApplicationServerLauncher.java:113)
                - locked#0x0530eb20> (a java.lang.Object)
                at java.lang.Thread.run(Thread.java:595)
                Found 1 deadlock.
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.aspectj.weaver.loadtime.DefaultWeavingContext.java</file>
            <file type="M">org.aspectj.weaver.tools.AbstractTrace.java</file>
            <file type="M">org.aspectj.weaver.AbstractTraceTest.java</file>
            <file type="M">org.aspectj.weaver.tools.Jdk14Trace.java</file>
        </fixedFiles>
    </bug>
    <bug id="320468" opendate="2010-07-21 04:22:43" fixdate="2010-08-26 11:21:18" resolution="Fixed">
        <buginformation>
            <summary>ModifiersPattern.getModifierFlag() is not thread safe.
            </summary>
            <description>Build Identifier: org.aspectj.weaver_1.6.0.20080423100000.jar
                ModifiersPattern.getModifierFlag() is a non-synchronized static method using the static Map
                modifierFlags.
                This can lead to a ConcurrentModificationException when this code is executed in a multi-threaded
                environment.
                A stack trace showing the erroneous behavior is appended at the end of this bug report.
                In our case multithreading is introduced by using Spring DM.
                This leads to many application contexts being initialized in parallel.
                Each of them can contain pointcut expression, which are processed in independent threads.
                Spring AOP enters the "AspectJ world" calling PointcutParser.parsePointcutExpression().

                Since there is no guarantee that a ConcurrentModificationException is thrown it is also possible that
                concurrent read/write accesses to the modifierFlags map are not recognized and incorrect values are
                used.


                org.springframework.beans.factory.BeanCreationException: Error creating bean with name
                'sessionFactoryProxy': Post-processing of the FactoryBean's object failed; nested exception is
                java.util.ConcurrentModificationException: concurrent access to HashMap attempted by
                Thread[SpringOsgiExtenderThread-43,5,spring-osgi-extender[6dee6dee]-threads]
                at
                org.springframework.beans.factory.support.FactoryBeanRegistrySupport$1.run(FactoryBeanRegistrySupport.java:142)
                at java.security.AccessController.doPrivileged(AccessController.java:219)
                at
                org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:116)
                at
                org.springframework.beans.factory.support.FactoryBeanRegistrySupport.getObjectFromFactoryBean(FactoryBeanRegistrySupport.java:91)
                at
                org.springframework.beans.factory.support.AbstractBeanFactory.getObjectForBeanInstance(AbstractBeanFactory.java:1288)
                at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:217)
                at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:185)
                at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:164)
                at
                org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:425)
                at
                org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:728)
                at
                org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.access$1600(AbstractDelegatedExecutionApplicationContext.java:69)
                at
                org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext$4.run(AbstractDelegatedExecutionApplicationContext.java:355)
                at org.springframework.osgi.util.internal.PrivilegedUtils.executeWithCustomTCCL(PrivilegedUtils.java:85)
                at
                org.springframework.osgi.context.support.AbstractDelegatedExecutionApplicationContext.completeRefresh(AbstractDelegatedExecutionApplicationContext.java:320)
                at
                org.springframework.osgi.extender.internal.dependencies.startup.DependencyWaiterApplicationContextExecutor$CompleteRefreshTask.run(DependencyWaiterApplicationContextExecutor.java:136)
                at java.lang.Thread.run(Thread.java:811)
                Caused by: java.util.ConcurrentModificationException: concurrent access to HashMap attempted by
                Thread[SpringOsgiExtenderThread-43,5,spring-osgi-extender[6dee6dee]-threads]
                at java.util.HashMap.onEntry(HashMap.java:214)
                at java.util.HashMap.transfer(HashMap.java:686)
                at java.util.HashMap.resize(HashMap.java:676)
                at java.util.HashMap.addEntry(HashMap.java:1049)
                at java.util.HashMap.put(HashMap.java:561)
                at org.aspectj.weaver.patterns.ModifiersPattern.getModifierFlag(ModifiersPattern.java:87)
                at org.aspectj.weaver.patterns.PatternParser.parseModifiersPattern(PatternParser.java:1169)
                at
                org.aspectj.weaver.patterns.PatternParser.parseMethodOrConstructorSignaturePattern(PatternParser.java:1248)
                at org.aspectj.weaver.patterns.PatternParser.parseKindedPointcut(PatternParser.java:603)
                at org.aspectj.weaver.patterns.PatternParser.parseSinglePointcut(PatternParser.java:317)
                at org.aspectj.weaver.patterns.PatternParser.parseAtomicPointcut(PatternParser.java:295)
                at org.aspectj.weaver.patterns.PatternParser.parsePointcut(PatternParser.java:256)
                at org.aspectj.weaver.tools.PointcutParser.resolvePointcutExpression(PointcutParser.java:328)
                at org.aspectj.weaver.tools.PointcutParser.parsePointcutExpression(PointcutParser.java:309)
                at
                org.springframework.aop.aspectj.AspectJExpressionPointcut.buildPointcutExpression(AspectJExpressionPointcut.java:206)
                at
                org.springframework.aop.aspectj.AspectJExpressionPointcut.checkReadyToMatch(AspectJExpressionPointcut.java:193)
                at
                org.springframework.aop.aspectj.AspectJExpressionPointcut.getClassFilter(AspectJExpressionPointcut.java:174)
                at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:195)
                at org.springframework.aop.support.AopUtils.canApply(AopUtils.java:250)
                at org.springframework.aop.support.AopUtils.findAdvisorsThatCanApply(AopUtils.java:284)
                at
                org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply(AbstractAdvisorAutoProxyCreator.java:113)
                at
                org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.findEligibleAdvisors(AbstractAdvisorAutoProxyCreator.java:85)
                at
                org.springframework.aop.framework.autoproxy.AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean(AbstractAdvisorAutoProxyCreator.java:66)
                at
                org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:362)
                at
                org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:325)
                at
                org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:361)
                at
                org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.postProcessObjectFromFactoryBean(AbstractAutowireCapableBeanFactory.java:1429)
                at
                org.springframework.beans.factory.support.FactoryBeanRegistrySupport$1.run(FactoryBeanRegistrySupport.java:139)
                ... 15 more

                Reproducible: Sometimes
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.aspectj.weaver.patterns.ModifiersPattern.java</file>
        </fixedFiles>
    </bug>
    <bug id="59599" opendate="2004-04-22 06:03:23" fixdate="2004-10-21 04:31:19" resolution="Fixed">
        <buginformation>
            <summary>Race condition in test suite for incremental.
            </summary>
            <description>On faster machines (my linux desktop, andy's home pc) several of the tests in ajcTests.xml are
                failing (suite attached).
                This appears to be due to a race condition between checking directory contents and waiting for the
                compilation to complete.
                I have an environment in which I can test candidate fixes if you can give me a pointer for what to
                tweak...
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.aspectj.testing.harness.bridge.DirChanges.java</file>
        </fixedFiles>
    </bug>
    <bug id="269867" opendate="2009-03-24 14:16:04" fixdate="2016-06-30 10:03:06" resolution="Fixed">
        <buginformation>
            <summary>Non synchronized access to WeakHashMap causes infinite loop.
            </summary>
            <description>The non synchronized access from AjTypeSystem.getAjType(clazz) to a static instance of
                WeakHashMap may cause an infinite loop at start up in a multi threaded system.
                The thread dump shows that 32 of 33 threads of the application stuck in WeakHashMap.get(Object) line
                355:

                "BundleStarterThreadQcCtrl24" prio=3 tid=0x00957c00 nid=0x39 runnable [0xd42fb000..0xd42ffa70]
                java.lang.Thread.State: RUNNABLE
                at java.util.WeakHashMap.get(WeakHashMap.java:355)
                at org.aspectj.lang.reflect.AjTypeSystem.getAjType(AjTypeSystem.java:37)
                at
                org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate.initialize(Java15ReflectionBasedReferenceTypeDelegate.java:66)
                at
                org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.create15Delegate(ReflectionBasedReferenceTypeDelegateFactory.java:56)
                at
                org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createDelegate(ReflectionBasedReferenceTypeDelegateFactory.java:42)
                at org.aspectj.weaver.reflect.ReflectionWorld.resolveDelegate(ReflectionWorld.java:111)
                at org.aspectj.weaver.World.resolveToReferenceType(World.java:388)
                at org.aspectj.weaver.World.resolve(World.java:279)
                at org.aspectj.weaver.World.resolve(World.java:199)
                at org.aspectj.weaver.World.resolve(World.java:348)
                at org.aspectj.weaver.reflect.ReflectionWorld.resolve(ReflectionWorld.java:103)
                at org.aspectj.weaver.reflect.ReflectionWorld.resolve(ReflectionWorld.java:93)
                at
                org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.toResolvedTypeArray(ReflectionBasedReferenceTypeDelegateFactory.java:214)
                at
                org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createResolvedMethod(ReflectionBasedReferenceTypeDelegateFactory.java:107)
                at
                org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(ReflectionBasedReferenceTypeDelegateFactory.java:98)
                at org.aspectj.weaver.reflect.ReflectionShadow.makeExecutionShadow(ReflectionShadow.java:53)
                at
                org.aspectj.weaver.internal.tools.PointcutExpressionImpl.matchesExecution(PointcutExpressionImpl.java:100)
                at
                org.aspectj.weaver.internal.tools.PointcutExpressionImpl.matchesMethodExecution(PointcutExpressionImpl.java:92)
                at
                org.springframework.aop.aspectj.AspectJExpressionPointcut.getShadowMatch(AspectJExpressionPointcut.java:370)
            </description>
            <version>1.1.0</version>
            <fixedVersion>1.1.0</fixedVersion>
            <fixedVersion>1.1.0</fixedVersion>
            <type>Bug</type>
        </buginformation>
        <fixedFiles>
            <file type="M">org.aspectj.lang.reflect.AjTypeSystem.java</file>
        </fixedFiles>
    </bug>
</bugrepository>