1247	Deadlock if the connection is still being used while HttpClient is closing  This happens in Vert x 3 2  In thread 5717  we hold the lock on HttpClientImpl close  lock  1  and then we try to acquire a lock on ClientConnection close  lock  2   In thread 7035  we hold a lock  2 in ClientConnection handleClosed and try to hold a lock  1 at HttpClientImpl checkClosed  And boom  we get a deadlock  I don t have a good repro now since it s quite hard to reproduce consistently  But I can demonstrate from the stack trace  Thread 5717   state   BLOCKED    io vertx core http impl ClientConnection close    bci 0  line 352  Interpreted frame    io vertx core http impl HttpClientImpl close    bci 46  line 642  Interpreted frame   Thread 7035   state   BLOCKED    io vertx core http impl HttpClientImpl checkClosed    bci 0  line 791  Interpreted frame    io vertx core http impl HttpClientImpl doRequest io vertx core http HttpMethod  java lang String  int  java lang String  io vertx core MultiMap   bci 23  line 782  Interpreted frame    io vertx core http impl HttpClientImpl request io vertx core http HttpMethod  int  java lang String  java lang String   bci 7  line 338  Interpreted frame    io vertx core http impl HttpClientImpl get int  java lang String  java lang String   bci 7  line 348  Interpreted frame          io vertx core http impl HttpClientRequestImpl lambda exceptionHandler 78 io vertx core Handler  java lang Throwable   bci 6  line 262  Interpreted frame    io vertx core http impl HttpClientRequestImpl  Lambda 21 handle java lang Object   bci 12  Interpreted frame    io vertx core http impl HttpClientRequestImpl handleException java lang Throwable   bci 21  line 384  Interpreted frame    io vertx core http impl ClientConnection handleClosed    bci 59  line 307  Interpreted frame    io vertx core net impl VertxHandler  Lambda 43 run    bci 4  Interpreted frame    io vertx core impl ContextImpl lambda wrapTask 16 boolean  io vertx core impl ContextTask  io vertx core Handler   bci 167  line 333  Compiled frame    io vertx core impl ContextImpl  Lambda 15 run    bci 16  Compiled frame    io vertx core impl ContextImpl executeFromIO io vertx core impl ContextTask   bci 17  line 225  Compiled frame    io vertx core net impl VertxHandler channelInactive io netty channel ChannelHandlerContext   bci 37  line 99  Interpreted frame    io netty channel AbstractChannelHandlerContext invokeChannelInactive    bci 8  line 218  Interpreted frame    io netty channel AbstractChannelHandlerContext fireChannelInactive    bci 20  line 204  Interpreted frame    io netty channel ChannelInboundHandlerAdapter channelInactive io netty channel ChannelHandlerContext   bci 1  line 75  Interpreted frame    io netty handler timeout IdleStateHandler channelInactive io netty channel ChannelHandlerContext   bci 6  line 257  Interpreted frame    io netty channel AbstractChannelHandlerContext invokeChannelInactive    bci 8  line 218  Interpreted frame    io netty channel AbstractChannelHandlerContext fireChannelInactive    bci 20  line 204  Interpreted frame    io netty handler codec ByteToMessageDecoder channelInactive io netty channel ChannelHandlerContext   bci 86  line 332  Interpreted frame    io netty handler codec http HttpClientCodec Decoder channelInactive io netty channel ChannelHandlerContext   bci 2  line 212  Interpreted frame    io netty channel CombinedChannelDuplexHandler channelInactive io netty channel ChannelHandlerContext   bci 5  line 132  Interpreted frame    io netty channel AbstractChannelHandlerContext invokeChannelInactive    bci 8  line 218  Interpreted frame    io netty channel AbstractChannelHandlerContext fireChannelInactive    bci 20  line 204  Interpreted frame    io netty channel DefaultChannelPipeline fireChannelInactive    bci 4  line 828  Interpreted frame    io netty channel AbstractChannel AbstractUnsafe 7 run    bci 10  line 625  Interpreted frame    io netty util concurrent SingleThreadEventExecutor runAllTasks long   bci 26  line 358  Compiled frame    io netty channel nio NioEventLoop run    bci 106  line 357  Compiled frame    io netty util concurrent SingleThreadEventExecutor 2 run    bci 13  line 112  Compiled frame    java lang Thread run    bci 11  line 745  Compiled frame
1302	EventLoop thread blocked on Vertx clusteredVertx    Vertx 3 2 1  Sometimes EventLoop thread blocked on Vertx clusteredVertx    Method Vertx clusteredVertx   called on the main java thread on application startup  Stacktrace  19 30 48 633  vertx blocked thread checker  WARN  i v core impl BlockedThreadChecker   Thread Thread vert x eventloop thread 0 5 main  has been blocked for 5660 ms  time limit is 2000 io vertx core VertxException  Thread blocked at java lang Object wait Native Method  ~ na 1 8 0  at com hazelcast spi impl operationservice impl InvocationFuture pollResponse InvocationFuture java 299  ~ hazelcast 3 5 2 jar 3 5 2  at com hazelcast spi impl operationservice impl InvocationFuture waitForResponse InvocationFuture java 247  ~ hazelcast 3 5 2 jar 3 5 2  at com hazelcast spi impl operationservice impl InvocationFuture get InvocationFuture java 224  ~ hazelcast 3 5 2 jar 3 5 2  at com hazelcast spi impl operationservice impl InvocationFuture get InvocationFuture java 204  ~ hazelcast 3 5 2 jar 3 5 2  at com hazelcast map impl proxy MapProxySupport invokeOperation MapProxySupport java 456  ~ hazelcast 3 5 2 jar 3 5 2  at com hazelcast map impl proxy MapProxySupport putInternal MapProxySupport java 417  ~ hazelcast 3 5 2 jar 3 5 2  at com hazelcast map impl proxy MapProxyImpl put MapProxyImpl java 97  ~ hazelcast 3 5 2 jar 3 5 2  at com hazelcast map impl proxy MapProxyImpl put MapProxyImpl java 87  ~ hazelcast 3 5 2 jar 3 5 2  at io vertx core impl HAManager  init  HAManager java 145  ~ vertx core 3 2 1 jar na  at io vertx core impl VertxImpl lambda new 270 VertxImpl java 152  ~ vertx core 3 2 1 jar na  at io vertx core impl VertxImpl  Lambda 3 852445367 handle Unknown Source  ~ na na  at io vertx core impl FutureImpl checkCallHandler FutureImpl java 158  ~ vertx core 3 2 1 jar na  at io vertx core impl FutureImpl setHandler FutureImpl java 100  ~ vertx core 3 2 1 jar na  at io vertx core impl ContextImpl lambda null 16 ContextImpl java 305  ~ vertx core 3 2 1 jar na  at io vertx core impl ContextImpl  Lambda 7 299713639 handle Unknown Source  ~ na na  at io vertx core impl ContextImpl lambda wrapTask 18 ContextImpl java 335  ~ vertx core 3 2 1 jar na  at io vertx core impl ContextImpl  Lambda 8 977225900 run Unknown Source  ~ na na  at io netty util concurrent SingleThreadEventExecutor runAllTasks SingleThreadEventExecutor java 358  ~ netty common 4 0 33 Final jar 4 0 33 Final  at io netty channel nio NioEventLoop run NioEventLoop java 357  ~ netty transport 4 0 33 Final jar 4 0 33 Final  at io netty util concurrent SingleThreadEventExecutor 2 run SingleThreadEventExecutor java 112  ~ netty common 4 0 33 Final jar 4 0 33 Final  at java lang Thread run Thread java 744  ~ na 1 8 0
1355	Deadlock between ClientConnection and HttpClientRequestImpl Hi  After a week attached to our load balancer which does a simple poll to one of our rest end points  we have no other traffic right now  all 4 machines  4 instances  end up in deadlock and had to be  kill  9 ed   which  in theory brought down our whole DC  Since we are in testing stages this was not a big problem but I imagine to most it would be a bit hair raising  From my simple analysis it seems that the Exception handling and the request response seem to be locking on the HttpClientRequestImpl  handleException  getlock     this   and HttpClientRequestImpl  connect this   lamda   this  Also looking at the traffic it seems our load balancer  a cisco content switch with ACE module  sends a request gets the response then resets the connection  I believe this behaviour is causing the deadlock  since this is important for us to go live I will try create a test to replicate this behaviour  This was running 3 2 0 code  Ive seen no fixes in 3 2 1  and using JVM 1 8_74 on RHEL 6 5 Here is the jstack information   Debugger attached successfully  Server compiler detected  JVM version is 25 74 b02 Deadlock Detection  Found one Java level deadlock   vert x eventloop thread 0   waiting to lock Monitor 0x0000000081060ac8  Object 0x0000000081060ac8  a io vertx core http impl ClientConnection   which is held by  vert x eventloop thread 7   vert x eventloop thread 7   waiting to lock Monitor 0x00007f6dac2a5e98  Object 0x0000000081060bf0  a io vertx core http impl HttpClientRequestImpl   which is held by the vert x eventloop thread 0  Found a total of 1 deadlock  Thread 19522   state   BLOCKED   io vertx core net impl ConnectionBase writeToChannel java lang Object   bci 0  line 113  Compiled frame  io vertx core http impl HttpClientRequestImpl writeHeadWithContent io netty buffer ByteBuf  boolean   bci 24  line 678  Compiled frame  io vertx core http impl HttpClientRequestImpl connected io vertx core http impl ClientConnection   bci 82  line 629  Compiled frame  io vertx core http impl HttpClientRequestImpl lambda connect 82 io vertx core http impl ClientConnection   bci 27  line 593  Compiled frame  io vertx core http impl HttpClientRequestImpl  Lambda 190 handle java lang Object   bci 8  Compiled frame  io vertx core http impl ConnectionManager ConnQueue lambda responseEnded 66 io vertx core http impl ConnectionManager Waiter  io vertx core http impl ClientConnection  java lang Void   bci 5  line 129  Compiled frame  io vertx core http impl ConnectionManager ConnQueue  Lambda 233 handle java lang Object   bci 12  Compiled frame  io vertx core impl ContextImpl lambda wrapTask 16 boolean  io vertx core impl ContextTask  io vertx core Handler   bci 177  line 335  Compiled frame  io vertx core impl ContextImpl  Lambda 24 run    bci 16  Compiled frame  io netty util concurrent SingleThreadEventExecutor runAllTasks long   bci 26  line 358  Compiled frame  io netty channel nio NioEventLoop run    bci 106  line 357  Compiled frame  io netty util concurrent SingleThreadEventExecutor 2 run    bci 13  line 112  Interpreted frame  java lang Thread run    bci 11  line 745  Interpreted frame   Thread 19465   state   BLOCKED   io vertx core http impl HttpClientRequestImpl getLock    bci 15  line 426  Compiled frame  io vertx core http impl HttpClientRequestImpl handleException java lang Throwable   bci 1  line 381  Compiled frame  io vertx core http impl ClientConnection handleException java lang Throwable   bci 17  line 324  Compiled frame  io vertx core net impl VertxHandler lambda exceptionCaught 17 io netty channel Channel  io vertx core net impl ConnectionBase  java lang Throwable   bci 22  line 86  Compiled frame  io vertx core net impl VertxHandler  Lambda 225 run    bci 12  Compiled frame  io vertx core impl ContextImpl lambda wrapTask 16 boolean  io vertx core impl ContextTask  io vertx core Handler   bci 167  line 333  Compiled frame  io vertx core impl ContextImpl  Lambda 24 run    bci 16  Compiled frame  io vertx core impl ContextImpl executeFromIO io vertx core impl ContextTask   bci 17  line 225  Compiled frame  io vertx core net impl VertxHandler exceptionCaught io netty channel ChannelHandlerContext  java lang Throwable   bci 38  line 79  Compiled frame  io netty channel AbstractChannelHandlerContext invokeExceptionCaught java lang Throwable   bci 6  line 256  Compiled frame  io netty channel AbstractChannelHandlerContext fireExceptionCaught java lang Throwable   bci 35  line 234  Compiled frame  io netty channel ChannelInboundHandlerAdapter exceptionCaught io netty channel ChannelHandlerContext  java lang Throwable   bci 2  line 131  Compiled frame  io netty channel AbstractChannelHandlerContext invokeExceptionCaught java lang Throwable   bci 6  line 256  Compiled frame  io netty channel AbstractChannelHandlerContext fireExceptionCaught java lang Throwable   bci 35  line 234  Compiled frame  io netty channel ChannelInboundHandlerAdapter exceptionCaught io netty channel ChannelHandlerContext  java lang Throwable   bci 2  line 131  Compiled frame  io netty channel CombinedChannelDuplexHandler exceptionCaught io netty channel ChannelHandlerContext  java lang Throwable   bci 6  line 137  Compiled frame  io netty channel AbstractChannelHandlerContext invokeExceptionCaught java lang Throwable   bci 6  line 256  Compiled frame  io netty channel AbstractChannelHandlerContext fireExceptionCaught java lang Throwable   bci 35  line 234  Compiled frame  io netty handler ssl SslHandler exceptionCaught io netty channel ChannelHandlerContext  java lang Throwable   bci 62  line 729  Compiled frame  io netty channel AbstractChannelHandlerContext invokeExceptionCaught java lang Throwable   bci 6  line 256  Compiled frame  io netty channel AbstractChannelHandlerContext fireExceptionCaught java lang Throwable   bci 35  line 234  Compiled frame  io netty channel DefaultChannelPipeline fireExceptionCaught java lang Throwable   bci 5  line 834  Compiled frame  io netty channel nio AbstractNioByteChannel NioByteUnsafe handleReadException io netty channel ChannelPipeline  io netty buffer ByteBuf  java lang Throwable  boolean   bci 44  line 87  Compiled frame  io netty channel nio AbstractNioByteChannel NioByteUnsafe read    bci 305  line 162  Compiled frame  io netty channel nio NioEventLoop processSelectedKey java nio channels SelectionKey  io netty channel nio AbstractNioChannel   bci 42  line 511  Compiled frame  io netty channel nio NioEventLoop processSelectedKeysOptimized java nio channels SelectionKey     bci 37  line 468  Compiled frame  io netty channel nio NioEventLoop processSelectedKeys    bci 15  line 382  Compiled frame  io netty channel nio NioEventLoop run    bci 84  line 354  Compiled frame  io netty util concurrent SingleThreadEventExecutor 2 run    bci 13  line 112  Interpreted frame  java lang Thread run    bci 11  line 745  Interpreted frame
1466	Deadlock in ServerConnection   HttpClientRequestImpl We use an HttpClient per thread  and this just happened  Found one Java level deadlock                                 vert x eventloop thread 0   waiting to lock monitor 0x00007f553c037b48  object 0x000000070d5fda10  a io vertx core http impl ServerConnection   which is held by  vert x eventloop thread 3   vert x eventloop thread 3   waiting to lock monitor 0x00007f55d9772a28  object 0x0000000653c73ab0  a io vertx core http impl HttpClientRequestImpl   which is held by  vert x eventloop thread 0  â€‹ Java stack information for the threads listed above                                                       vert x eventloop thread 0     waiting to lock  0x000000070d5fda10   a io vertx core http impl ServerConnection          locked  0x0000000653c73ab0   a io vertx core http impl HttpClientRequestImpl   vert x eventloop thread 3     waiting to lock  0x0000000653c73ab0   a io vertx core http impl HttpClientRequestImpl          locked  0x000000070d5fda10   a io vertx core http impl ServerConnection    locked  0x000000070d5fda10   a io vertx core http impl ServerConnection   There is a chance that it s just a glitch  we had some weird behaviour  two instances launched instead of one or something    Also  this code looks a bit dangerous  io vertx core http impl HttpClientRequestImpl getLock      After connecting we should synchronize on the client connection instance to prevent deadlock conditions    but there is a catch   the client connection is null before connecting so we synchronized on this before that    point private Object getLock        We do the initial check outside the synchronized block to prevent the hit of synchronized once the conn has    been set if  conn !  null    return conn    else   synchronized  this    if  conn !  null    return conn    else   return this           related  df69aa3  1355  1247
1469	HttpClientMetrics createEndpoint may be called multiple times for the same endpoint The implementation of io vertx core http impl ConnectionManager QueueManager getConnQueue can lead to HttpClientMetrics createEndpoint being called multiple times for the same endpoint if different threads try to use a fresh HTTP client  ConnQueue connQueue   queueMap get address   if  connQueue    null    connQueue   new ConnQueue version  this  address   ConnQueue prev   queueMap putIfAbsent address  connQueue   if  prev !  null    connQueue   prev      return connQueue  HttpClientMetrics createEndpoint is called from the ConnQueue constructor so a single instance of ConnQueue must be created if none is in the map  Otherwise SPI implementations my leak resources acquired in  createEndpoint as  closeEndpoint would never be called for the corresponding queue instance
1573	Blocked thread warning when opening or closing an AsyncFile Users have reported blocked thread warning when opening or closing an AsyncFile  Here are example stack traces  io vertx core VertxException  Thread blocked  and io vertx core VertxException  Thread blocked  One user provided more details and reported he was using a mapped Windows shared drive  I have been able to reproduce the opening issue by a slow network filesystem  with twickle and nbd
1598	Asynchronous read write done on wrong thread The open close issue has been addressed here  1573   Async read write still is blocking  2016 08 30 18 16 25 382 aaa  WARN  vertx blocked thread checker   io vertx core impl BlockedThreadChecker    Thread Thread vert x eventloop thread 1 5 main  has been blocked for 9988 ms  time limit is 2000 io vertx core VertxException  Thread blocked
1633	Context executeBlocking does not log blocked threads No description provided
1742	File caching implementation not thread safe The FileResolver implementation of caching is not thread safe  The problem occurs when the same file  that is about to be cached  is concurrently being read from multiple verticles  This issue can be reproduced with FileSystem readFileBlocking  however  I believe that async implementation will yield similar results  The problem here is the following  Consider a use case  when a file is read in multiple verticles in parallel  This file does not reside in a local filesystem  and as such Vert x will try to cache the file by moving it to the  vertx directory   First verticle that hits FileResolver resolveFile will trigger the copying action of the resource to the designated  vertx cache directory  Only after this copy action is finished  the file will be read   thus this verticle will read complete data  Every other instance that hits FileResolver resolveFile will find the cached file during resolution   as the file is currently being copied over there   however  it might happen that it will read the cached file before it is copied completely   thus this verticle will read only partial data   The problem can be reproduced by running supplied verticle in multiple instances  The verticle only reads 10 files from attached jar  all are 1MB in size  and outputs the size of read payload  vertx fileread bug zip vertx run  cp data jar   instances 3 FileLengthVerticle java Sample output      file data5  1024000bytes file data5  1024000bytes file data6  1024000bytes file data6  1024000bytes file data6  1024000bytes file data7  1024000bytes file data7  1024000bytes file data7  1024000bytes file data8  65516bytes file data8  73703bytes file data8  1024000bytes file data9  646968bytes file data9  1024000bytes file data9  1024000bytes
1834	Don t call HttpServer request ws close handler holding locks Motivation  currently the ServerWebSocket and HttpServerRequest close handlers are called under synchronized lock of the connection  This can create deadlocks in SockJSSocket because a SockJSSocket may uses different request websocket  reconnects  and event loops  Change  when processing a Netty close event  call the close handlers in the next tick  i e scheduled to run on context
1892	Race condition in Future setHandler completion between threads In one of our projects we have encountered a problem with CompositeFuture all   when running  outside  of a verticle  in junit tests   Here is a sample program  import io vertx core CompositeFuture  import io vertx core Future  import io vertx core Vertx   import java util concurrent CountDownLatch  import java util concurrent ExecutionException  import java util concurrent TimeUnit  import java util concurrent atomic AtomicInteger   public class CompositeFutureTest   private static final int NUMBER_OF_LOOPS   10_000  private static final Vertx vertx   Vertx vertx     private static boolean testCompositeFuture   throws InterruptedException  ExecutionException   CountDownLatch finished   new CountDownLatch 1   AtomicInteger atomicCounter   new AtomicInteger 0    for  int i   0  i   NUMBER_OF_LOOPS  i      Future Void  future1   Future future    Future Void  future2   Future future     vertx runOnContext future1  complete   vertx runOnContext future2  complete    CompositeFuture all future1  future2  setHandler ar      if  ar succeeded      if  atomicCounter incrementAndGet      NUMBER_OF_LOOPS    finished countDown               boolean result   finished await 10  TimeUnit SECONDS    System out println String format   s   s     s   result    OK    ERROR   atomicCounter  NUMBER_OF_LOOPS     return result     public static void main String   args  throws InterruptedException  ExecutionException   while  testCompositeFuture     vertx close        After a while it prints something like ERROR  9985    10000  Inside implementation of CompositeFutureImpl all   the setHandler   function is called upon each future in the composition  in our case two   The problem here is that the completion of futures runs in a different thread than setting the handler  Neither of the functions  setHandler   nor complete    are atomic and it may result in a situation when the handler is never called  The problem seems to be more fundamental  The future implementation  FutureImpl  is not thread safe and using it from different threads may cause difficulties  When running inside a verticle it s ok because asynchronous callbacks are serialized within the event loop and should not run concurrently  I don t know if this is an expected behaviour and Futures  and their compositions  should be used only within verticles  Our understanding based on looking into the implementation of CompositeFutureImpl is that the intention was to make it thread safe
2012	Race condition in AsyncFileImpl writesOutstanding  If an AsyncFileImpl is written to from a thread different to the context that created then the long counter writesOutstanding can get into an invalid state  This is because the counter is updated from both the caller s thread and also on the context when a write is complete   Fix is to use an AtomicLong for writesOutstanding   https   gist github com purplefox 723fa69a1330fb4f4f74d4a5dd5e6658
2370	HttpClient pool gets inconsistent on a synchronous connection failure  The HttpClient pool assumes that the underlying ConnectionProvider will make an asynchronous callback  which is the case with the asynchronous DNS resolver but not with the JVM synchronous resolver when the host cannot be resolved
2418	Possible deadlock when trying to get multiple locks Here is the code  which illustrates the problem  The Consumer verticle acuires lock1 and gets stuck  I have reproduced the same problem using HazelcastClusterManager and IgniteClusterManager  Vertx clusteredVertx  new VertxOptions   setClusterManager new HazelcastClusterManager     result      final Vertx vertx   result result     final int messagesToSend   10   final Consumer consumer   new Consumer    vertx deployVerticle  consumer  new DeploymentOptions    event      if  event succeeded      vertx deployVerticle  new Supplier messagesToSend   new DeploymentOptions              vertx setTimer  messagesToSend   DEFAULT_LOCK_TIMEOUT  timer      final long failsNumber   messagesToSend   consumer counter sum    if  failsNumber !  0    System err println  Failed to get     failsNumber     locks      vertx close              class Supplier extends AbstractVerticle   private final long messagesToSend   public Supplier long messagesToSend    this messagesToSend   messagesToSend      Override public void start     final LongAdder sent   new LongAdder    vertx setPeriodic 1  timer      vertx eventBus   send TEST_ADDRESS   message    sent increment    System out println sent sum       messages sent    if  sent sum      messagesToSend    vertx cancelTimer timer             class Consumer extends AbstractVerticle   private final LongAdder counter   new LongAdder      Override public void start Future Void  startFuture    vertx eventBus   consumer  TEST_ADDRESS  event      vertx sharedData   getLock  lock1   lock1      if  lock1 failed      System out println  Failed to get lock1      lock1 cause       else   System out println  Succeeded to get lock1    vertx sharedData   getLock  lock2   lock2      if  lock2 failed      System out println  Failed to get lock2      lock2 cause       else   System out println  Succeeded to get lock2    counter increment    System out println counter sum       messages consumed    lock2 result   release      lock1 result   release                  completionHandler startFuture
2670	Client connections on GlobalEventExecutor thread that are not propagated to the application  Sometimes the Netty s bootstrap may notify client connections on the GlobalEventExecutor thread when it happens early in the boostrap when an event loop has not been yet determined  Vertx expects notifications to happen on the event loop thread and this results in a Uh oh! Event loop context executing with wrong thread! failure
2684	executeBlocking callback run on the wrong thread for asynchronous future resolution Currently the executeBlocking Handler Future T    Handler AsyncResult T    might execute the callback on the wrong thread when the runOnContext      execution loses the race against the thread that completes the future  This never happens when the worker thread completes the future  but it can happen when the worker thread hands off the future to another thread that completes it   This happen in the Mongo client and fails with a stack trace like
2773	HttpClient race condition when getting a connection from the pool being closed  Currently there is a race condition with the HttpClient between a client request and a connection close  The pool delivers the client request in the next tick and the connection might be removed from the pool between this the schedule and the delivery  At this moment the client does not know the connection was closed and is never aware of the connection close  We should avoid a next tick in this situation  i e when the client request is fulfilled with a valid connection  it should be called immediately to avoid the race   Currently the fact that the connection pool can hold connections with multiples context does not allow to run the pool requests on the pool and thus the situation is hard to avoid without a re check before the connection is delivered  A better solution might be to attach a vertx context on the pool and consider all connections will use the same context  this would allow to eliminate the race easily
2916	HTTP event handler should not be called when holding a lock We still have event handlers that are called while holding a lock which can lead to deadlocks  We should remove them
2982	HTTP Client   Deadlock Sometimes  it appears that some eventloops are blocked while doing some http client relative stuff  Vert x 3 7 0  Here is a threaddump   vert x eventloop thread 0   10 prio 5 os_prio 0 tid 0x00007f55410b0000 nid 0x855f waiting for monitor entry  0x00007f54fb771000  java lang Thread State  BLOCKED  on object monitor    waiting to lock  0x00000000c5b865e0   a io vertx core http impl HttpClientRequestImpl    locked  0x00000000c541b4b8   a io vertx core http impl Http1xClientConnection    locked  0x00000000c541b4b8   a io vertx core http impl Http1xClientConnection    vert x eventloop thread 3   13 prio 5 os_prio 0 tid 0x00007f55410b6800 nid 0x8562 waiting for monitor entry  0x00007f54fb46d000  java lang Thread State  BLOCKED  on object monitor    waiting to lock  0x00000000c541b4b8   a io vertx core http impl Http1xClientConnection    locked  0x00000000c5b865e0   a io vertx core http impl HttpClientRequestImpl   I m trying to provide a simple reproducer but it seems that the deadlock is pretty hard to reproduce
3064	HttpServerResponse operation should not fail synchronously when the stream is is closed We already have made some improvements here and for we should have the same behaviour for other related responses methods   when the stream is ended  by the user  then it should fail synchronously because it is a programming mistake when the stream is closed then it should not fail synchronously but should fail asynchronously  In Vert x 4 the synchronous operation return a Future result that be failed in this case
3140	Do not lock the handler calls in AsyncFile Currently the AsyncFile implementation calls the file handlers in a synchronized block  This synchronization is only useful for reading the handler and should not be used when calling them
3142	Deadlock when deploying several instances of a verticle a starting net server This is a regression on 3 8 2 due to  3117
3232	Vertx close Future will not callback the handler The Future returned by vertx close   never completes because the thread pool has been shut down  The first of these works  the second doesn t   Test public void testPromise   throws Throwable   Vertx vertx   Vertx vertx    logger debug  Shutting down with promise    Promise Void  promise   Promise  Void promise    vertx close promise   Sync await promise future     logger debug  Shut down with promise        Test public void testFuture   throws Throwable    Vertx vertx   Vertx vertx     logger debug  Shutting down with future    Sync await vertx close     logger debug  Shut down with future       Sync await is just a blocking method that waits for a future to complete using setHandler  The output from that is  14 11 43 941  main  DEBUG c g shared minimal vertx VertxTest 28   Shutting down with promise 14 11 43 980  main  DEBUG c g shared minimal vertx VertxTest 32   Shut down with promise 14 11 44 001  main  DEBUG c g shared minimal vertx VertxTest 40   Shutting down with future Exception in thread  vert x eventloop thread 24  java util concurrent RejectedExecutionException  event executor terminated  and it never completes
3335	FileSystemImpl existsInternal can block event loop thread Version 3 8 5 Context Invoking vertx filesystem   exists   can block the event loop thread  This is because resolveFile   runs in the event loop thread instead of in the worker thread  See https   github com eclipse vertx vert x blob master src main java io vertx core file impl FileSystemImpl java L1113  private BlockingAction Boolean  existsInternal String path    Objects requireNonNull path   return new BlockingAction Boolean      File file   vertx resolveFile path   public Boolean perform     return file exists            resolveFile should instead be called in the perform   method  private BlockingAction Boolean  existsInternal String path    Objects requireNonNull path   return new BlockingAction Boolean      public Boolean perform     File file   vertx resolveFile path   return file exists            Do you have a reproducer  You can mock calls to resolveFile   to sleep for any amount of time or set a breakpoint on the resolveFile call as a test runs  Wait up to the blocked thread checker interval and unpause execution  BlockedThreadChecker will report that the thread has been blocked  Steps to reproduce See above
3468	Thread blocked in io vertx core net impl clientconnection ConnectionManager getConnection While upgrading https   github com folio org okapi from Vert x 4 0 0 milestone 4 to milestone 5  we noticed a serious issue with HttpClient connections being thread blocked   It seems to appear when connection can not be made to a remote host  Using same client and issuing another request that also fails results in a thread blocked warning and a halt of the event loop   openjdk version  1 8 0_252  OpenJDK Runtime Environment  build 1 8 0_252 8u252 b09 1ubuntu1 b09  OpenJDK 64 Bit Server VM  build 25 252 b09  mixed mode  and openjdk version  14 0 1  2020 04 14 OpenJDK Runtime Environment  build 14 0 1 7 Ubuntu 1ubuntu1  OpenJDK 64 Bit Server VM  build 14 0 1 7 Ubuntu 1ubuntu1  mixed mode  sharing  Host  Ubuntu 20 04 amd64 Log    INFO  Running org folio okapi common HttpClientDoubleFail 10 54 37 WARN                       Thread Thread vert x eventloop thread 1 5 main  has been blocked for 2883 ms  time limit is 2000 ms 10 54 38 WARN                       Thread Thread vert x eventloop thread 1 5 main  has been blocked for 3883 ms  time limit is 2000 ms 10 54 39 WARN                       Thread Thread vert x eventloop thread 1 5 main  has been blocked for 4883 ms  time limit is 2000 ms 10 54 40 WARN                       Thread Thread vert x eventloop thread 1 5 main  has been blocked for 5883 ms  time limit is 2000 ms io vertx core VertxException  Thread blocked at io vertx core net impl clientconnection ConnectionManager getConnection ConnectionManager java 46  ~ vertx core 4 0 0 milestone5 jar 4 0 0 milestone5  at io vertx core http impl HttpClientImpl getConnectionForRequest HttpClientImpl java 1288  ~ vertx core 4 0 0 milestone5 jar 4 0 0 milestone5  at io vertx core http impl HttpClientRequestImpl connect HttpClientRequestImpl java 422  ~ vertx core 4 0 0 milestone5 jar 4 0 0 milestone5  at io vertx core http impl HttpClientRequestImpl write HttpClientRequestImpl java 614  ~ vertx core 4 0 0 milestone5 jar 4 0 0 milestone5  at io vertx core http impl HttpClientRequestImpl end HttpClientRequestImpl java 527  ~ vertx core 4 0 0 milestone5 jar 4 0 0 milestone5  at io vertx core http impl HttpClientRequestImpl end HttpClientRequestImpl java 521  ~ vertx core 4 0 0 milestone5 jar 4 0 0 milestone5  at org folio okapi common HttpClientDoubleFail lambda test 2 HttpClientDoubleFail java 45  ~ test classes     at org folio okapi common HttpClientDoubleFail  Lambda 34 1409160703 handle Unknown Source
3469	HTTP client retry on same host can self deadlock The HTTP client retrying the same host on a failure can self deadlock because it will close the pool after it performs the callback  It should close the pool before so when it retries and fail it does not retry indefinitely
3658	Race condition throws an unhandled exception in CompositeFuture all  Version Which version s  did you encounter this bug   3 9 2  but this is likely in newer versions as well   Context When at least two futures executing on different threads are passed to CompositeFuture all    there is a race condition throwing an unhandled and unexpected exception if the futures both fail at virtually the same time   The gap between this synchronized block in all method reached when a future fails    else   synchronized composite    if  composite isComplete      return       composite fail ar cause       and the synchronized block in doComplete method  private boolean doComplete Object result    synchronized this    if  this result !  null    return false     this result   result     this promise handle this   return true    can create a situation where a subsequent future thread sees that composite isComplete   is false  yet making it to doComplete method  returning false after seeing result is not null   After returning from tryFail method  this then throws the unhandled and unexpected exception in fail method  public void fail Throwable cause    if  !this tryFail cause     throw new IllegalStateException  Result is already complete       this result    this    succeeded     failed         Steps to reproduce Here is a simple test with  RunWith VertxUnitRunner class  treating unhandled exceptions as unit test failures    RunWith VertxUnitRunner class  public class CompositeFutureRaceConditionTest    private static final int NUM_ITERATIONS   5000  private static final int NUM_THREADS   4    Test public void testRaceConditionRepeatedly TestContext context  throws Exception   for  int i   0  i   NUM_ITERATIONS    i    raceCondition context        private void raceCondition TestContext context  throws Exception   List Promise  promises   IntStream range 0  NUM_THREADS   mapToObj i    Promise promise    collect Collectors toList     List Future  futures   promises stream   map Promise  future  collect Collectors toList     CompositeFuture compositeFuture   CompositeFuture all futures    ExecutorService executorService   Executors newFixedThreadPool NUM_THREADS   CountDownLatch countDownLatch   new CountDownLatch NUM_THREADS    for  int i   0  i   NUM_THREADS    i    final int x   i  executorService submit         countDownLatch countDown    try   countDownLatch await    System out println  Start fail      x       Thread      Thread currentThread   getName     promises get x  fail  Fail     x   System out println  End fail      x       Thread      Thread currentThread   getName       catch  Throwable t    t printStackTrace    context fail t getMessage              compositeFuture onComplete x      System out println  CompositeFuture onComplete called      x        executorService shutdown    boolean terminatedSuccessfully   executorService awaitTermination 30  TimeUnit SECONDS   context assertTrue terminatedSuccessfully       which should throw at least one exception  depending on the number of executions   java lang IllegalStateException  Result is already complete  failed Extra Mac OS 10 15 7 openjdk version  11 0 6  2020 01 14 OpenJDK Runtime Environment AdoptOpenJDK  build 11 0 6 10  OpenJDK 64 Bit Server VM AdoptOpenJDK  build 11 0 6 10  mixed mode
4024	Concurrency issue in listener of TCPServerBase listen Version 4 1 1 Context I stumbled upon a concurrency issue while debugging TCPServerBase in context of  3994  There is a race between what s happening in that listener that is registered via bindFuture addListener      and the code that is running directly in that listen method after doBind   is done   Important  bindFuture addListener   says  The specified listener is notified when this future is done   That listener is setting the  outer  field id with the actual port but that field is also pre set before that listener with port 0  So dependening who is faster  the listener or the outer method code   the final sharedNetServers put id  this   will either pick up the id with the actual port or the one with 0  This is even less predictable due to id not having volatile or synchronized  The effect while debugging was that if I waited before sharedNetServers put id  this    I was getting another random port for each verticle  correct term   while without debugging all got the same random port
4069	Deadlock when closing Vertx and WorkerExecutor concurrently I met a deadlock issue recently on Vertx version 4 1 1 and after investigated and looked into the VertxImpl  CloseFuture  WorkerExecutorImpl  it looks like the deadlock happened in Vertx  please take a look   In my case  the deadlock issue is hit when the vertx close and workerExecutor close happened to be called at same time  one from main thread and another from eventloop thread   the workerExecutor is created by the vertx createSharedWorkerExecutor   Backtrace printed by jstack   Found one Java level deadlock                                 main   waiting to lock monitor 0x00007fa958116580  object 0x00000000b3329eb8  a io vertx core impl WorkerExecutorImpl   which is held by  vert x eventloop thread 0   vert x eventloop thread 0   waiting to lock monitor 0x00007fa89c01ae80  object 0x00000000b3329f58  a io vertx core impl VertxImpl   which is held by  main   Java stack information for the threads listed above                                                       main     waiting to lock  0x00000000b3329eb8   a io vertx core impl WorkerExecutorImpl    locked  0x00000000b3329f58   a io vertx core impl VertxImpl       vert x eventloop thread 0     waiting to lock  0x00000000b3329f58   a io vertx core impl VertxImpl    locked  0x00000000b3329eb8   a io vertx core impl WorkerExecutorImpl       Found 1 deadlock  Checked vertx 4 1 1 code and find  When closing WorkerExecutor  it will do   Lock self  WorkerExecutorImpl  Remove self from CloseFuture Close SharedWorkerPool  which require lock Vertx When closing Vertx  it will do   Lock self  VertxImpl  Close CloseFuture  which synchronized copy the list of callbacks and invoke them outside of the synchronized block  one of the callback is to close the same WorkerExecutorImpl instance as above So  when the copy of callbacks in CloseFuture happened before removing the WorkerExecutorImpl from CloseFuture  it will still be called and cause deadlock  Time	Main thread	Eventloop thread T1	Start close Vertx  locked VertxImpl instance T2	 	Start close WorkerExecutor  locked WorkerExecutorImpl instance T3	In CloseFuture  the list of callbacks are copied T4	 	Remove WorkerExecutorImpl instance from CloseFuture  But since the callback is already copied in T3  this doesn t prevent the callback from being called T5	The callback of close WorkerExecutorImpl instance is called  This require lock on the WorkerExecutorImpl instance  which was acquired by eventloop thread at T2  So it is waiting for the lock to be released by eventloop thread T6	 	Close SharedWorkerPool  and this require lock on the VertxImpl instance  which was acquired by main thread at T1  So it is waiting for the lock to be released by main thread Deadlock	Deadlock The issue seems still exist in 4 1 2
4104	WorkerExecutor executeBlocking sometimes holds a lock on the WorkerExecutor after the blocking call has completed  Version 4 1 0 Beta1  Context I ran into a Java deadlock in a large application  and based on the stack trace of the blocked threads  it seems to be caused by each thread running WorkerExecutor executeBlocking on the same two WorkerExecutor instances  but in a different order  One thread looked like this    vert x eventloop thread 0     waiting to lock  0x00000000d60dd340   a io vertx core impl WorkerExecutorImpl        locked  0x00000000d8e22a10   a io vertx core impl WorkerExecutorImpl  And the other like this    vert x eventloop thread 2     waiting to lock  0x00000000d8e22a10   a io vertx core impl WorkerExecutorImpl    locked  0x00000000d9a520b8   a io vertx reactivex ContextScheduler ContextWorker TimedAction        locked  0x00000000d60dd340   a io vertx core impl WorkerExecutorImpl  WorkerExecutorImpl executeBlocking looks like this   public synchronized  T  void executeBlocking Handler Promise T   blockingCodeHandler  boolean ordered  Handler AsyncResult T   asyncResultHandler    Future T  fut   executeBlocking blockingCodeHandler  ordered   if  asyncResultHandler !  null    fut onComplete asyncResultHandler       If that fut onComplete call runs after the blockingCodeHandler has finished  the asyncResultHandler will be executed right away on the current thread  This means that we stay inside of the synchronized block as we continue on  If one thread does we1 executeBlocking      followed by we2 executeBlocking       and another thread does it in the reverse order  and the first call each thread makes ends up running asyncResultHandler right away  you deadlock   Do you have a reproducer  Here is a simple JUnit test that reproduces it   public static class TestV extends AbstractVerticle   private final CyclicBarrier b  private final WorkerExecutor we1  private final WorkerExecutor we2   public TestV WorkerExecutor we1  WorkerExecutor we2  CyclicBarrier b    this we1   we1  this we2   we2  this b   b      Override public void start Promise Void  p  throws BrokenBarrierException  InterruptedException   b await    we1 executeBlocking a    a complete  a    false  ign    we2 executeBlocking a    a complete  a    false  ign2    p complete             Test public void test TestContext context    var async   context strictAsync 2   CyclicBarrier b   new CyclicBarrier 2   var we1   vertx createSharedWorkerExecutor  test1    var we2   vertx createSharedWorkerExecutor  test2    vertx deployVerticle new TestV we1  we2  b   ign    async countDown     vertx deployVerticle new TestV we2  we1  b   ign    async countDown       Note that you also need to add a breakpoint on this line in WorkerExecuteImpl executeBlocking  to ensure that the blockingCodeHandler always finishes before fut onComplete runs   if  asyncResultHandler !  null    I used the Intellij  Evaluate and log  breakpoint option to insert a 200ms sleep on this line  which lead to consistent reproductions when executing the above test   Steps to reproduce I suspect this is hard to reliably reproduce outside of a carefully constructed test  because the timing requirements are so specific
4221	Pool can deliver lease with null connection  A race can happen in the pool when it delivers a lease  Leases are created as pool post actions and sometimes can read a connection from a slot that became null in the meantime the post action is executed   This leads in an NPE in the HttpClient that instead should not get non null closed connection  instead of a null connection   reported here  4220  comment
4275	ConnectionBase exception handler should not be called within the synchronized block
4278	ArrayList concurrency error when deploying the verticles Hi We have an intermitent problem with the startup of our applications  in a few attempts I can reproduce so it it quite often to occur  vert x version  3 9 9 Java version  openjdk version  11 0 10  2021 01 19 LTS This is the error  java util ConcurrentModificationException  null This is the piece of code that is triggering the concurrency error     Sort list in ascending order facts sort  fact1  fact2     fact1 order     fact2 order     class  DeploymentManager method  registerVerticleFactory The exception is thrown by ArrayList sort  here is the code public void sort Comparator   super E  c    final int expectedModCount   modCount  Arrays sort  E    elementData  0  size  c   if  modCount !  expectedModCount  throw new ConcurrentModificationException    modCount      So from my analysis the ArrayList is being modified while it is being sorted  We have 20 verticles in this application  so we iterate over the collection of class names and invoke the method below from vertex rx java2 3 9 9 rxDeployVerticle String name  DeploymentOptions options  Please let me know if any additional information is required  Thanks