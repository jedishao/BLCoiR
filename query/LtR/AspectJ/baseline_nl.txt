59599	Race condition in test suite for incremental  On faster machines  my linux desktop  andy s home pc  several of the tests in ajcTests xml are failing  suite attached   This appears to be due to a race condition between checking directory contents and waiting for the compilation to complete  I have an environment in which I can test candidate fixes if you can give me a pointer for what to tweak
59909	CFlowStack removesThreads to lateProblem  The current implementation of CFlowStack  Version 1 1 till 1 2 rc1  stores all threads in a hashtable  These Threads are removes after several calls to the methods getThreadStack     In our cases  70 calls   In our project  this cycle is much to long  We have soveral long running threads  which grap quite a lot of lot of memory  This memory can only be freed after the threads have been removed from the CFlowStack  In our production code we sum up to more than 300 Threads stored in different CFlowStack Varaibles  Often this results in out of memory Errors  Added patch provides an improved freeing scheme  It checks if the size of the table has grown  if it has  it checks if it can remove some threads
155148	jdk14 trace deadlock in oc4j  I turned on tracing for the Aj class inside of Oracle s OC4J server  In one test  not always  it deadlocked  It looks like the threads are each trying to lock each other s loader  Notice that one of the threads is in the toString method of the Oracle ClassLoader  perhaps another reason to prefer tracing argument class names and system identity hashcodes    Here s a thread dump from Ctrl BREAK   Found one Java level deadlock                                 WorkExecutorWorkerThread 1   waiting to lock monitor 0x003384ec  object 0x05239e48  a oracle classloader Po licyClassLoader   which is held by  OC4J Launcher   OC4J Launcher   waiting to lock monitor 0x0033848c  object 0x0554f0e8  a oracle classloader Po licyClassLoader   which is held by  WorkExecutorWorkerThread 1  Java stack information for the threads listed above                                                       WorkExecutorWorkerThread 1     waiting to lock  0x05239e48   a oracle classloader PolicyClassLoader    locked  0x0554f0e8   a oracle classloader PolicyClassLoader    locked  0x056a9ed0   a oracle classloader PolicyClassLoader    locked  0x056a9ed0   a oracle classloader PolicyClassLoader    locked  0x05de2718   a oracle j2ee ra jms generic WorkConsumer   OC4J Launcher     waiting to lock  0x0554f0e8   a oracle classloader PolicyClassLoader    locked  0x0514e920   a java util logging SimpleFormatter    locked  0x0514e920   a java util logging SimpleFormatter    locked  0x0514a0a8   a java util logging FileHandler    locked  0x0514a0a8   a java util logging FileHandler    locked  0x05239e48   a oracle classloader PolicyClassLoader    locked  0x05239e48   a oracle classloader PolicyClassLoader     locked  0x05ec9290   a java util ArrayList    locked  0x05ec4f88   a com evermind server http HttpServer    locked  0x05ec4f88   a com evermind server http HttpServer    locked  0x0530eb20   a java lang Object  Found 1 deadlock
269867	Non synchronized access to WeakHashMap causes infinite loop  The non synchronized access from AjTypeSystem getAjType clazz  to a static instance of WeakHashMap may cause an infinite loop at start up in a multi threaded system  The thread dump shows that 32 of 33 threads of the application stuck in WeakHashMap get Object  line 355    BundleStarterThreadQcCtrl24  prio 3 tid 0x00957c00 nid 0x39 runnable  0xd42fb000  0xd42ffa70  java lang Thread State  RUNNABLE
318878	Pertarget aspect instantiation is not thread safe  The way in which pertarget aspects compiled with ajc check if a given target already has an aspect is not thread safe  When two different threads trigger an advice on a target object for the first time at the same time  sometimes the aspect for that target gets created twice   The following code demonstrates the problem   The following pertarget aspect will add itself to a  synchronized  set in another class in it s constructor   aspect Pertarget pertarget execution void foo       public Pertarget     Main aspects add this      Add this instance to the set in Main   before    execution void foo          Empty advice to trigger creation    This class creates 10000 target objects and has two separate threads call a method  that causes the aspect to be instantiated  on each object  The aspects add themselves to the  aspects  set and this set s size is printed when all threads have finished   import java util Collections  import java util IdentityHashMap  import java util Set   public class Main   public static Set aspects   Collections synchronizedSet  Collections newSetFromMap new IdentityHashMap      public static void main String   args  throws InterruptedException   for  int i   0  i   10000    i    final Main m   new Main       Create a new target for the aspect Runnable r   new Runnable     public void run     m foo         This will trigger the advice    Thread t1   new Thread r   Thread t2   new Thread r   t1 start    t2 start    t1 join    t2 join      System out println aspects size        Should be 10000   private void foo         When compiled with ajc and run  the main method prints values over 10000  something like 10030 10060 typically   which means that some target objects get multiple aspect instances   In my own application I sometimes also saw some threads accessing partially built aspect instances  This was quite rare however and I wasn t able to make a test case for it   The ajc version  the current stable  used was  AspectJ Compiler 1 6 8  1 6 8   Built  Friday Jan 8  2010 at 21 53 37 GMT    Eclipse Compiler 0 785_R33x  3 3  The sun vm version was  Java TM  SE Runtime Environment  build 1 6 0_20 b02  Java HotSpot TM  64 Bit Server VM  build 16 3 b01  mixed mode   I investigated the source of this problem  the ajc compiler generates the following  decompiled  method into the aspect class   public static void ajc perObjectBind Object obj    if  obj instanceof ajcMightHaveAspect  &&   ajcMightHaveAspect obj  perObjectGet      null    ajcMightHaveAspect obj  perObjectSet new Pertarget          which obviously is not thread safe
320468	ModifiersPattern getModifierFlag   is not thread safe  Build Identifier  org aspectj weaver_1 6 0 20080423100000 jar ModifiersPattern getModifierFlag   is a non synchronized static method using the static Map modifierFlags  This can lead to a ConcurrentModificationException when this code is executed in a multi threaded environment  A stack trace showing the erroneous behavior is appended at the end of this bug report  In our case multithreading is introduced by using Spring DM  This leads to many application contexts being initialized in parallel  Each of them can contain pointcut expression  which are processed in independent threads  Spring AOP enters the  AspectJ world  calling PointcutParser parsePointcutExpression     Since there is no guarantee that a ConcurrentModificationException is thrown it is also possible that concurrent read write accesses to the modifierFlags map are not recognized and incorrect values are used    org springframework beans factory BeanCreationException  Error creating bean with name  sessionFactoryProxy   Post processing of the FactoryBean s object failed  nested exception is java util ConcurrentModificationException  concurrent access to HashMap attempted by Thread SpringOsgiExtenderThread 43 5 spring osgi extender 6dee6dee  threads  Caused by  java util ConcurrentModificationException  concurrent access to HashMap attempted by Thread SpringOsgiExtenderThread 43 5 spring osgi extender 6dee6dee  threads      15 more  Reproducible  Sometimes
340806	Race condition in JavaLangTypeToResolvedTypeConverter  potentially exposed through Spring AOP
408721	java util ConcurrentModificationException when multiple threads enter the weaver  I am using AspectJ 1 7 1  Occasionally I see the following exception  which I believe is related to multiple threads initializing some internal state   java util ConcurrentModificationException  null at java util ArrayList Itr checkForComodification Unknown Source  ~ na 1 7 0_11  at java util ArrayList Itr next Unknown Source  ~ na 1 7 0_11  at org aspectj weaver ReferenceType findDerivativeType ReferenceType java 1122  ~ aspectjweaver jar 1 7 1  at org aspectj weaver TypeFactory createParameterizedType TypeFactory java 44  ~ aspectjweaver jar 1 7 1  at org aspectj weaver ResolvedType parameterize ResolvedType java 2479  ~ aspectjweaver jar 1 7 1  at org aspectj weaver ReferenceType getDeclaredInterfaces ReferenceType java 673  ~ aspectjweaver jar 1 7 1  at org aspectj weaver ResolvedType getDirectSupertypes ResolvedType java 82  ~ aspectjweaver jar 1 7 1  at org aspectj weaver patterns TypePattern matchesSubtypes TypePattern java 178  ~ aspectjweaver jar 1 7 1  at org aspectj weaver patterns ExactTypePattern matchesSubtypes ExactTypePattern java 74  ~ aspectjweaver jar 1 7 1  at org aspectj weaver patterns TypePattern matchesStatically TypePattern java 130  ~ aspectjweaver jar 1 7 1  at org aspectj weaver patterns KindedPointcut fastMatch KindedPointcut java 130  ~ aspectjweaver jar 1 7 1  at org aspectj weaver internal tools PointcutExpressionImpl couldMatchJoinPointsInType PointcutExpressionImpl java 84  ~ aspectjweaver jar 1 7 1  at org springframework aop aspectj AspectJExpressionPointcut matches AspectJExpressionPointcut java 250  ~ spring aop jar 3 2 1 RELEASE  at org springframework aop support AopUtils canApply AopUtils java 208  ~ spring aop jar 3 2 1 RELEASE  at org springframework aop support AopUtils canApply AopUtils java 262  ~ spring aop jar 3 2 1 RELEASE  at org springframework aop support AopUtils findAdvisorsThatCanApply AopUtils java 294  ~ spring aop jar 3 2 1 RELEASE  at org springframework aop framework autoproxy AbstractAdvisorAutoProxyCreator findAdvisorsThatCanApply AbstractAdvisorAutoProxyCreator java 118  ~ spring aop jar 3 2 1 RELEASE