176792	org eclipse swt internal ole win32 ComObject misbehavior in multithreaded application  org eclipse swt internal ole win32 ComObject constructor accesses to Callbacks and ObjectMap static fields  In multithreaded applications this sometimes leads to org eclipse swt SWTError exceptions with message  No more callbacks    Solution Enclose constructor code in synchronized block  public COMObject int   argCounts    int   callbackAddresses   new int argCounts length   synchronized  Callbacks       added line for  int i   0  length   argCounts length  i   length  i     if   Callbacks i  argCounts i       null    Callbacks i  argCounts i     new Callback this getClass     callback  i  argCounts i    1  true  COM E_FAIL      NON NLS 1  if  Callbacks i  argCounts i   getAddress      0  SWT error SWT ERROR_NO_MORE_CALLBACKS     callbackAddresses i    Callbacks i  argCounts i   getAddress       int pVtable   OS GlobalAlloc COM GMEM_FIXED   COM GMEM_ZEROINIT  4   argCounts length   COM MoveMemory pVtable  callbackAddresses  4   argCounts length   ppVtable   OS GlobalAlloc COM GMEM_FIXED   COM GMEM_ZEROINIT  4   COM MoveMemory ppVtable  new int    pVtable   4   ObjectMap put new Integer ppVtable   this        added line
183830	Xlib  unexpected async reply  and deadlock in GLX glXMakeCurrent int  int  int   Every so often our OpenGL program just locks up under Linux   Xlib  unexpected async reply  is printed to stderr  and if we pause the program in the debugger we find that the main thread is deadlocked in GLCanvas setCurrent    GLX glXMakeCurrent int  int  int
188320	Possible Deadlock in JFace ModalContextBuild ID  M20070212 1330  The inner class ModalContextThread is not threadsafe and sometimes leads to a deadlock  at least under Linux   GTK   The problem is  that the block   method not always returns  when the run   method is finished   Have a look at these two methods  The block   method is called in the SWT thread and does basically this   while continueEventDispatching  if  display readAndDispatch    display sleep     The run method is called in an own thread and does  after the execution of the task  basically this   display syncExec new Runnable       continueEventDispatching   false  display asyncExec null    The asyncExec null  should wake up the SWT thread from display sleep    Unfortunately  this does not work  when the asyncExec   is executed exactly between the display readAndDispatch   and the display sleep    This can happen  because there is no synchronisation  In this case the display sleep   does not return immediately  but waits for the next event  which may come never   You can see the same problem in the following code snippet   public static void main String   args  throws InterruptedException   final Shell shell   new Shell    while true   if   shell getDisplay   readAndDispatch     Thread async   new Thread    public void run     shell getDisplay   asyncExec null        async start    async join    System out println  sleep    shell getDisplay   sleep    System out println  wakeup            A fix for this problem would be to call display asyncExec new Runnable    public void run          In contrast to using the null argument  this Runnable generates a real event instead of just waking up the SWT thread  So the SWT thread does not really begin to sleep
264399	A deadlock occurs during automated testing of a SWT application on Linux GTK x86_64
338965	Deadlock Hang on UI Thread