132	BoundedQueueThreadPoolWriteAttributeHandler does not deal with undefined core threads correctly  BoundedQueueThreadPoolWriteAttributeHandler doesn t deal with undefined values for core threads correctly  It assumes the attribute will be defined  and that s not required  The attribute doesn t have a fixed default value  Instead  the behavior in add is to set the runtime value to match max threads of core threads is undefined  BoundedQueueThreadPoolWriteAttributeHandler should do the same
196	Hang in HostController shutdown when CTRL C is usedIt is fairly easy to produce a hang in domain mode shutdown by launching domain sh and then soft killing the process with CTRL C  If this hang happens  a thread dump will show this        Host Controller   Remoting  localhost MANAGEMENT  task 16  prio 5 tid 0x00007fa07423b800 nid 0x3b0b waiting for monitor entry  0x000000010bce6000       Host Controller     java lang Thread State  BLOCKED  on object monitor           Host Controller  	  waiting to lock &lt 0x00000007f7946a30&gt   a org jboss as host controller ManagedServer                                                                     Host Controller   Host Controller Service Threads   13  prio 5 tid 0x00007fa072cbc800 nid 0xa903 waiting on condition  0x000000010d93a000       Host Controller     java lang Thread State  WAITING  parking           Host Controller  	  parking to wait for  &lt 0x00000007f61e5480&gt   a java util concurrent locks AbstractQueuedSynchronizer ConditionObject                                       Host Controller  	  locked &lt 0x00000007f7946a30&gt   a org jboss as host controller ManagedServer                                    The 2nd thread is blocking waiting for a prepared response from one of the servers  The first thread is trying to send a notification that the channel connecting to the server has been closed  The first thread will never unblock because the 2nd thread can t proceed and deliver the information that the channel is closed  This happens because all the processes  PC  HC  servers  respond to the CTRL C  So the server is shutting down in parallel and has closed the channel  In theory this could happen for other reasons too  though  Anything that results in closing the channel while the ManagedServer lock is held
202	Deadlock when shutdown Wildfly server during CLI client connectionCreating upstream issue as the same deadlock can be found in WFLY  Descirption as comment 5 in BZ1142538    The following deadlock still exists    Steps to Reproduce      1  Prepare a running EAP instance with secured management port   optionally in VM     2  Execute export JAVA_OPTS   agentlib jdwp transport dt_socket address 8787 server y suspend y      3  In the same terminal  execute  bin jboss cli sh   connect   controller  EAP_IP   user admin   password password &amp apos  read resource&amp apos       4  From yet another terminal  execute  jdb  attach localhost 8787      5  In JDB      5 a  Create breakpoint   stop in org xnio channels FramedMessageChannel receive java nio ByteBuffer       5 b  Resume all threads   resume      5 c   Execute five times  Wait until breakpoint is hit and execute  resume   Either set timeout or be fast so that timeout does not occur first     6  Execute  kill  9  EAP_PID    optionally in VM     7  In JDB      8 a  Remove breakpoint   clear org xnio channels FramedMessageChannel receive java nio ByteBuffer       8 b  Resume all threads   resume      9  Now dump the stack trace of jboss cli sh   kill  3  JBOSS_CLI_PID                          Found one Java level deadlock                                         Remoting  cli client  read 1       waiting to lock monitor 0x00007ff9c829b558  object 0x0000000783433408  a java lang String       which is held by  main       main       waiting to lock monitor 0x00007ff9c8333c48  object 0x00000007851ae6e0  a java util ArrayDeque       which is held by  Remoting  cli client  read 1           Java stack information for the threads listed above                                                               Remoting  cli client  read 1             waiting to lock &lt 0x0000000783433408&gt   a java lang String                                        locked &lt 0x00000007851ae6e0&gt   a java util ArrayDeque                locked &lt 0x00000007851ae6e0&gt   a java util ArrayDeque                                                   main             waiting to lock &lt 0x00000007851ae6e0&gt   a java util ArrayDeque                locked &lt 0x0000000784978a00&gt   a org jboss as protocol ProtocolConnectionManager                locked &lt 0x0000000783433408&gt   a java lang String                                                                                    It can be easily reproduce with Eclipse as        1 start Wildfly     2 uncomment  JAVA_OPTS   JAVA_OPTS  agentlib jdwp transport dt_socket address 8787 server y suspend y  in jboss cli sh and connect to server     3 add two break points at     CLIModelControllerClient ChannelCloseHandler  line  285    handleClose Channel  IOException      RemoteConnectionChannel  line  360    receiveMessage Receiver      4 connect to 8787 from eclipse debug     5 shutdown Wildfly          A deadlock between  main  and  cli client  is in Eclipse debug stack
553	ModelControllerClientOperationHandler doesn t manage the clientRequestExecutor properly ModelControllerClientOperationHandler s constructor creates a ThreadPoolExecutor for handling client requests and then the class doesn t clean it up  In addition  an instance of ModelControllerClientOperationHandler is created per channel  not one per ModelControllerClientOperationHandlerFactoryService  I know I at least thought of the thread pool as being per remote management interface  not per channel  Making it be per ModelControllerClientOperationHandlerFactoryService and cleaning it up in that service s stop would be the easiest fix  but the pool settings may not be appropriate if we do that  so tread carefully
997	Security realm using ldaps hangs forever during SSL handshake  when ldap server is killedDuring failover testing we hit the problem of stuck thread  When ldap server is killed in particular time of ssl handshake EAP hangs and waits forever on response  which will never come  Causing thread to block forever  Same problem can be seen in LdapLoginModule using ldaps without specifying com sun jndi ldap connect timeout value  Possible solution is to add option to declare com sun jndi ldap connect timeout for security realm and provide some default non empty value  e g  15 seconds
1002	TransactionalProtocolOperationHandler AbortOperationHandler must initialize the ExecuteRequestContext before responding  If in a race a COMPLETE_TX_REQUEST cancelling an op is processed by a server slave HC before the original EXECUTE_TX_REQUEST is processed  when the EXECUTE_TX_REQUEST comes in the AbortOperationHandler attempts to respond with a  outcome  &gt  cancelled  response  This will fail because the ExecutionRequestContext will not be initialized  In this situation the AbortOperationHandler should initialize the ERC  With assertions enabled  this appears in the log     20 58 47 947 ERROR  stderr   Remoting  slave main three MANAGEMENT  task 6  Exception in thread  Remoting  slave main three MANAGEMENT  task 6  java lang AssertionError                                                                                                Without assertions  a few lines later a call to sendResponse will result in an NPE
1025	ManagementRequestContext executeAsync hides RejectedExecutionExceptionThe impl of ManagementRequestContext executeAsync catches RejectedExecutionException and doesn t notify the calling thread  The handling itself seems ok  call failed on the result handler and send a failure response to the client   but not notifying the caller is problematic  There are a number of cases where the caller thread waits for a latch to be tripped  with the async task tripping  If the latch never trips  the caller thread will block forever  The testsuite hang at http   brontes lab eng brq redhat com viewLog html buildId 71233&amp buildTypeId WildFlyCore_MasterLinux&amp tab buildLog _focus 13620 looks to be a case of this  with a server not stopping due to this              Remoting  master main one MANAGEMENT  task 13   55 prio 5 os_prio 0 tid 0xc6c3bc00 nid 0x19d9 waiting on condition  0xc215c000      java lang Thread State  WAITING  parking            parking to wait for  &lt 0xddbb4aa0&gt   a java util concurrent CountDownLatch Sync                                    locked &lt 0xddbb2300&gt   a org jboss as controller remote TransactionalProtocolOperationHandler ExecuteRequestContext                                                                                    The RejectedExecutionException indicates a thread pool has been shutdown before the response has gone out  Ideally we would prevent that  for which I&amp apos ve recently filed a JIRA  but in any case we should make this more robust  I think having executeAsync return a boolean should suffice