170	Concurrent modification of StepExecution when running an asynchrounous step operationUse of a hibernateJobDao eventually results in a StaleObjectStateException when running an asynchrounous step operation  &lt bean id  myStepExecutor  class  org springframework batch execution step simple SimpleStepExecutor  scope  prototype &gt  &lt property name  transactionManager  ref  txManager   &gt  &lt property name  repository  ref  simpleJobRepository   &gt  &lt property name  stepOperations &gt  &lt bean class  org springframework batch repeat support TaskExecutorRepeatTemplate &gt  &lt property name  taskExecutor  ref  threadPoolTaskExecutor  &gt  &lt  bean&gt  &lt  property&gt  &lt  bean&gt  See  http   forum springframework org showthread php t 44884
449	skip synchronization between reader and writer  ItemSkipPolicyItemHandler always calls skip on both reader and writer  If reader threw the exception it is one item ahead of the writer  so calling skip makes reader skip the item that caused the error  but writer will skip the previous item
603	JobExecution fields could be modified in another Thread and are not volatile  JobExecution fields could be modified in another Thread and are not volatile
782	Synchronization issue in ItemOrientedStep if exception is throw in chunk processing  I have read source code of 1 0 x and 1 1 x and both share similar problem  In ItemOrientedStep  Code  protected ExitStatus doExecute final StepExecution stepExecution  throws Exception      blablabla return stepOperations iterate new RepeatCallback     public ExitStatus doInIteration RepeatContext context  throws Exception      balblabla try      Process chunk       1  try   synchronizer lock stepExecution     catch  InterruptedException e    stepExecution setStatus BatchStatus STOPPED   Thread currentThread   interrupt         step execution persistence   catch  Error e    processRollback stepExecution  contribution  fatalException  transaction   throw e    catch  Exception e                   processRollback stepExecution  contribution  fatalException  transaction                  throw e               finally   synchronizer release stepExecution       blblabla return exitStatus          In case of any exception occured in  1  or during synchronizer lock    the internal semaphore in synchronizer is NOT acquired  However  the outer final block releases synchronizer  and hence  releasing the semaphore  From JDK API of 1 5  it stated that Semaphore can be released by another thread which is not the original acquirer of semaphore  So  in case of parallel processing  I may goes into some case  Thread 1 acquired the semaphore and doing those step execution persistence stuff  Thread 2 have exception in processChunk  and hence releasing the semaphore  Thread 3  originally waiting for semaphore  is now acquired the semaphore because Thread 2 releases it  and hence  it goes to the peresistence block of code  In such case  Thread 1 and 3 goes into the should be protected block of code for step execution persistence  In my environment  I throwed an exception in my writer  and it caused this exception   ERROR  SimpleAsyncTaskExecutor 1  step AbstractStep  Encountered an error executing the step org springframework batch core step AbstractStep FatalException  Fatal error detected during save of step execution context    stack trace deleted Caused by  org springframework dao OptimisticLockingFailureException  Attempt to update step execution id 609 with wrong version  5   where current version is 4    stack trace deleted It is caused by concurrent access and persistence of step execution because of the above mentioned issue  Upon happening  in DB  the step execution will be updated with UNKNOWN status  and hence  preventing it from re run  A quick fix is to set a flag after synchronizer lock  and only release if flag is set  However it does not cater for interruption exception during synchronizer locking
912	Thread safety issue in JobRegistryBackgroundJobRunner  I noticed that the errors variable in JobRegistryBackgroundJobRunner is modified by one thread and accessed by another without synchronization  As the ArrayList isn t thread safe  I think this might cause visibility issues in the code that checks if errors has occurred during initialization of the application context  As with all visibility issues it is hard to prove this  but I believe that at least in theory this may be a problem  A way to fix this would be by replacing private static List Exception errors   new ArrayList&lt Exception&gt     with private static List&lt Exception&gt  errors   Collections synchronizedCollection new ArrayList&lt Exception&gt      Not sure if making the list volatile will work   as I m not all that confident on what the implications are of making a collection variable volatile  Don t think there will much of a performance hit this particular case anyway
1272	Write skips do not work in a multi threaded step  Write skips do not work in a multi threaded step  This is strange  and hard to explain  but apparently the FaultTolerantChunkProcessor is not fault tolerant if run in multiple threads at once
1278	RepeatTemplate aborts early if multiple threads throw ignorable exceptionsRepeatTemplate aborts early if multiple threads throw ignorable exceptions  This is the underlying cause for BATCH 1272
1362	Threads spinning doing nothing at end of multi threaded StepThreads spinning doing nothing at end of multi threaded Step   When a multi threaded step is waiting for its last chunk to process it needs to wait on threads that are FINISHED  rather than spinning round asking them over and over if they want to do more work   The visible effect is often a large disparity between commit count and read count at the end of a step   One user even reported an apparently infinite loop  probably it was just the JVM scheduler not giving priority to the real worker thread
1526	Memory leak in web deployments because ThreadLocal is not nulled out in ChunkMonitorThe Tomcat leak detection in 6 0 24 caught this one  it s a tiny leak but the thread local in ChunkMonitor is not nulled out so re deployment of a web application can result in a memory leak  Tomcat fixes it  from 6 0 24  so it&amp apos s probably not a big deal for existing users
1542	Thread safety in JobExecution and StepExecution collectionsThe collections inside JobExecution and StepExecution should have copy on write concurrency protection  The only place we are likely to see the effect is in really fast step and job executions using the MapJobRepository  which is only thread safe since BATCH 1541 anyway
1572	Step not failing on org springframework transaction UnexpectedRollbackExceptionThe transaction is timing out for a read by the reader in a step due to a lock  The transaction manager marks the out come of the transaction to be rollback only  Once the lock is released and the reader returns  a org springframework transaction UnexpectedRollbackException is thrown while updating the chunk to database  Batch is considering this exception to be a non fatal exception and is continuing with the next chunk just by logging the exception at a debug level  Instead ity should fail the step I guess  Problem   I am loosing all the records in that chunk  I changed the org springframework batch core step item SimpleRetryExceptionHandler java s constructor like  public SimpleRetryExceptionHandler RetryPolicy retryPolicy  ExceptionHandler exceptionHandler  Collection&lt Class&lt   extends Throwable&gt &gt  fatalExceptionClasses    this retryPolicy   retryPolicy  this exceptionHandler   exceptionHandler  fatalExceptionClasses add org springframework transaction UnexpectedRollbackException class   this fatalExceptionClassifier   new BinaryExceptionClassifier fatalExceptionClasses      and tested  Now it is failing the step
1709	BeanWrapperFieldSetMapper race condition in cache  BeanWrapperFieldSetMapper occasionally fails in a concurrent setting with strange messages about duplicate properties and the distance limit  even if the column names are exact  Must be a concurrency bug in the caching
1724	Multithreaded step re processing chunk without skip or retry limitI sort of understand this  and it s quite an amusing little bug  if rather irritating   I doubt if it critical at all  since the outcome of the step is still failure  In a multi threaded step we can only check for the failure one thread at a time  and by the time we have checked it  the failed chunk can have gone back in the queue for processing  Oddly  though  even with a single background thread it still fails the same way  so maybe we can actually fix this at least for some special cases
1725	SubclassClassifier should use ConcurrentHashMapSubclassClassifier should use ConcurrentHashMap  otherwise there can be concurrent modification exceptions when it is used concurrently
2126	DefaultJobParametersConverter is not thread safe and the SimpleJobOperator either DefaultJobParametersConverter is not thread safe due to usage of instance variable for numberFormat  dateFormat and longNumberFormat  Then as the SimpleJobOperator use a JobParametersConverter as a instance variable it is not thread safe either  Thus means that we cannot use it with a SimpleAsyncTaskExecutor or any asynchronous TaskExecutor  Can you fix it or can you explain which setup as be evaluated to make it work properly with an asynchronous TaskExecutor
2153	StepSynchronizationManager uses static HashMap   NullPointerException with multiple Threadsorg springframework batch core scope context StepSynchronizationManager produces NullPointerException  because it uses static java util HashMap to increment and decrement variables for the current Thread  which is not threadsafe  Solution  Replacing java util HashMap with java util Hashtable  threadsafe  works for me  Also see this build error https   build springsource org browse BATCH TRUNK JOB1 6375 test case 62852213 jsessionid 59A64053379861A4C2328C879E4525EA with the same exception  Find attached a minimal maven project  start TestStepSynchronizationManagerMain to reproduce the NullPointerException  and a possible fix
2156	ConcurrencyFailureException when multithreaded tasklet updates  PREFIX STEP_EXECUTION_CONTEXT tableNeed to synchronize the stepExecution in org springframework batch core repository dao JdbcExecutionContextDao in the method updateExecutionContext final StepExecution stepExecution   in order to prevent concurrency failures if two threads are trying to update the same step execution context record  It appears this is already done in JdbcStepExecutionDao updateStepExecution at line 162     Attempt to prevent concurrent modification errors by blocking here if    someone is already trying to do it  synchronized  stepExecution    The error we are getting when our multithreaded tasklet is processing is   org springframework batch core step FatalStepExecutionException  JobRepository failure forcing exit with unknown status at org springframework batch core step tasklet TaskletStep ChunkTransactionCallback doInTransaction TaskletStep java 441  at org springframework transaction support TransactionTemplate execute TransactionTemplate java 131  at org springframework batch core step tasklet TaskletStep 2 doInChunkContext TaskletStep java 264  at org springframework batch core scope context StepContextRepeatCallback doInIteration StepContextRepeatCallback java 76  at org springframework batch repeat support TaskExecutorRepeatTemplate ExecutingRunnable run TaskExecutorRepeatTemplate java 258  at java lang Thread run Thread java 679  Caused by  org springframework dao ConcurrencyFailureException  PreparedStatementCallback  SQL  UPDATE BATCH_STEP_EXECUTION_CONTEXT SET SHORT_CONTEXT      SERIALIZED_CONTEXT     WHERE STEP_EXECUTION_ID        Teradata Database   TeraJDBC 14 00 00 37   Error 2631   SQLState 40001  Transaction ABORTed due to deadlock   nested exception is com teradata jdbc jdbc_4 util JDBCException   Teradata Database   TeraJDBC 14 00 00 37   Error 2631   SQLState 40001  Transaction ABORTed due to deadlock  at org springframework jdbc support SQLStateSQLExceptionTranslator doTranslate SQLStateSQLExceptionTranslator java 110  at org springframework jdbc support AbstractFallbackSQLExceptionTranslator translate AbstractFallbackSQLExceptionTranslator java 72  at org springframework jdbc support AbstractFallbackSQLExceptionTranslator translate AbstractFallbackSQLExceptionTranslator java 80  at org springframework jdbc support AbstractFallbackSQLExceptionTranslator translate AbstractFallbackSQLExceptionTranslator java 80  at org springframework jdbc core JdbcTemplate execute JdbcTemplate java 605  at org springframework jdbc core JdbcTemplate update JdbcTemplate java 818  at org springframework jdbc core JdbcTemplate update JdbcTemplate java 874  at org springframework batch core repository dao JdbcExecutionContextDao persistSerializedContext JdbcExecutionContextDao java 193  at org springframework batch core repository dao JdbcExecutionContextDao updateExecutionContext JdbcExecutionContextDao java 136  at org springframework batch core repository support SimpleJobRepository updateExecutionContext SimpleJobRepository java 184  at sun reflect GeneratedMethodAccessor381 invoke Unknown Source  at sun reflect DelegatingMethodAccesso
2313	Possible race condition leading to NullPointerException in SynchronizationManagerSupport  We recently migrated to Spring Batch 3 x a system that has been running fine in production for a number of years on older Spring Batch 2 x releases  While this has been running fine in production for a couple of months now  yesterday a batch failed with what appears to be some kind of race condition multithreading bug  Re running the batch completely  which would operate on exactly the same data in a re run  worked fine so this is not easily reproducible  The error was  08 25 21 432   main  AbstractJob ERROR &lt execute&gt    Encountered fatal error executing job     org springframework batch core JobExecutionException  Flow execution ended unexpectedly     at org springframework batch core job flow FlowJob doExecute FlowJob java 140      at org springframework batch core job AbstractJob execute AbstractJob java 304      at org springframework batch core launch support SimpleJobLauncher 1 run SimpleJobLauncher java 135      at org springframework core task SyncTaskExecutor execute SyncTaskExecutor java 50      at org springframework batch core launch support SimpleJobLauncher run SimpleJobLauncher java 128      at org springframework batch core launch support CommandLineJobRunner start CommandLineJobRunner java 362      at org springframework batch core launch support CommandLineJobRunner main CommandLineJobRunner java 590      at com ml elt automarking util AutomarkBatchCommandLineRunner main AutomarkBatchCommandLineRunner java 14      Caused by  org springframework batch core job flow FlowExecutionException  Ended flow ECIJob at state ECIJob loadXMLMaster with exception     at org springframework batch core job flow support SimpleFlow resume SimpleFlow java 171      at org springframework batch core job flow support SimpleFlow start SimpleFlow java 141      at org springframework batch core job flow FlowJob doExecute FlowJob java 134          7 more     Caused by  java lang NullPointerException     at org springframework batch core scope context SynchronizationManagerSupport decrement SynchronizationManagerSupport java 149      at org springframework batch core scope context SynchronizationManagerSupport close SynchronizationManagerSupport java 143      at org springframework batch core scope context SynchronizationManagerSupport release SynchronizationManagerSupport java 193      at org springframework batch core scope context StepSynchronizationManager release StepSynchronizationManager java 112      at org springframework batch core step AbstractStep doExecutionRelease AbstractStep java 284      at org springframework batch core step AbstractStep execute AbstractStep java 274      at org springframework batch core job SimpleStepHandler handleStep SimpleStepHandler java 148      at org springframework batch core job flow JobFlowExecutor executeStep JobFlowExecutor java 64      at org springframework batch core job flow support state StepState handle StepState java 67      at org springframework batch core job flow support SimpleFlow resume SimpleFlow java 162          9 more       In the step that failed  the batch has been split into partitions with gridSize 2 running across 5 threads  it looks like the failure happened at the end of the step  Having a look inside the code the NPE line is below  Could this be due to inconsistent synchronization or possibly an assumption that the count hasn&amp apos t already been removed that is not true  Without being highly familiar with the code it looks a bit odd to me to synchronize on one field  counts  during increment  but another  contexts  during decrement        private void decrement         E current   getCurrent   pop        if  current !  null        int remaining   counts get current  decrementAndGet       &lt     PROBLEMATIC LINE     if  remaining &lt   0        synchronized  contexts        contexts remove current       counts remove current                                    public void increment         E current   getCurrent   peek        if  current !  null        AtomicInteger count      synchronized  counts        count   counts get current       if  count    null        count   new AtomicInteger        counts put current  count                   count incrementAndGet