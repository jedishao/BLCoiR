268	LockModePopulatingMethodInterceptor leak causes OutOfMemoryError  PermGen spaceIn cases where locking is not externally set  like when invoking it form a non  Transactional call stack  org springframework data jpa repository support LockModeRepositoryPostProcessor LockModePopulatingMethodIntercceptor invoke MethodInvocation  is registering the locking mode itself  with the target method as key  using org springframework transaction support TransactionSynchronizationManager bindResource Object  Object   but is not calling org springframework transaction support TransactionSynchronizationManager unbindResource Object  afterwards  In environments where the classloaders are discarded but the threads are reused  like in any application or web server with a service thread pool and hot redeployments  the VM ends up running out of PermGen space since   link java lang Thread threadLocals  will keep a strong reference to the bound method keeping alive the otherwise unused class loader and all its  classes and objects graph  Sorry about the test case  it was written in a rush  Heap dump can be found here  18Mb   https   dl dropbox com u 1249691 LockModeRepositoryPostProcessor_LockModePopulatingMethodIntercceptorMemoryLeakTest zip
359	Lock annotation doesn t work on  at least  findOne methodIf I have a repository defined thus    public interface DataObjectRepository extends PagingAndSortingRepository&lt DataObject  Integer&gt              Override      Lock LockModeType PESSIMISTIC_WRITE      DataObject findOne Integer id             Query  from DataObject o where o id    1        Lock LockModeType PESSIMISTIC_WRITE      DataObject findOneAndLock Integer id               and I run both findOne   and findOneAndLock   then only my more specific method acquires a lock   the  Lock annotation applied to the CRUD method has no effect on its operation  Interestingly  applying the annotation to the findAll method  as noted in the docs  does work !  The documentation suggests that the  Lock annotation should also apply to the other CRUD methods  I ve created a sample Maven Eclipse project to demonstrate the issue  this example uses Derby as its DB  but the issue is also present on at least MySQL where I discovered it first  The output of running the test Application class ends with some Hibernate logging of the Derby   Hibernate      select     dataobject0_ id as id1_0_0_      dataobject0_ name as name2_0_0_     from     data dataobject0_     where     dataobject0_ id       Hibernate      select     dataobject0_ id as id1_0_      dataobject0_ name as name2_0_     from     data dataobject0_ for update     with rs     Hibernate      select     dataobject0_ id as id1_0_      dataobject0_ name as name2_0_     from     data dataobject0_     where     dataobject0_ id   for update     with rs     and I had expected that the first query  using the  Lock&amp apos ed findOne  should also have acquired the lock with the  for update  suffix
620	Infinite loop in unsynchronized HashMap in CrudMethodMetadataPostProcessor  The method org springframework data jpa repository support CrudMethodMetadataPostProcessor CrudMethodMetadataPopulatingMethodIntercceptor invoke is not thread safe  although it is called concurrently when Spring Data JPA Queries are executed concurrently  More concretely  since the method uses the non thread safe java util HashMap  concurrent calls to this method may result in an infinite loop when executing the Hashmap Lookup &amp apos metadataCache get method &amp apos   line 101 in version 1 7 0 RELEASE   and I have actually encountered this behavior in an application   Infinite loops in concurrently used hashmaps appear to be a known problem  see  e g   https   jira spring io browse DATACMNS 518 or http   mailinator blogspot dk 2009 06 beautiful race condition html   I therefore believe that this method should be made thread safe  e g   by using a java util concurrent ConcurrentHashMap