188	SecurityContextHolder JavaDoc errorFrom acegisecurity developer  Javadoc for org acegisecurity context SecurityContextHolder   Associates a given SecurityContext with the current execution thread and any new threads the current execution thread may spawn   It can confuse users  as I know InheritableThreadLocal no longer used in SecurityContextHolder  so SecurityContext will not be associated with new threads which current execution thread may spawn
192	Concurrent login checking fails with CAS  The CAS authentication provider should call setDetails on the newly created CASAuthenticationToken  Alternatively  this could be done somewhere like AbstractAuthenticationProvider authenticate  since it is probably common to all providers  Something like  public final Authentication authenticate Authentication authentication  throws AuthenticationException   try   Authentication result   doAuthentication authentication   if result getDetails      null    result setDetails authenitication getDetails         catch  AuthenticationException e    e setAuthentication authentication   throw e
197	ConcurrentSessionController should count non expired Sessions only  With ConcurrentSession support enabled  its very common for a user to close their browser without logging out  thereby locking themselves out of the app until their session expires  I have added a function to my admin to  logout  an active user  bascially calling SessionInformation expireNow   for each session beloging to him  But  after doing this the user still can t logon because ConcurrentSessionController just counts how many SessionInformation objects are returned from getAllSessions  Until the HttpSession expires or the logged out user hits the site again  triggering a HttpSession invalidation  the user cannot login again  If the ConcurrentSessionController checkAuthenticationAllowed method counted non expired sessions instead of all sessions  this would allow the user to log back in  even though he has an abondonded HttpSession  and continue to use the system
328	AbstractUserDetailsAuthenticationProvider makes two hits when no cache is used  If you look at AbstractUserDetailsAuthenticationProvider authenticate  you ll notice that in case of failure  Acegi suppose that it is due to a cache synchronization problem and make a second retrieveUser  But if you use no cache  your information were already up to date and retrieveUser is still called    I think that this snippet  l  148 151      There was a problem  so try again after checking we re using latest data cacheWasUsed   false  user   retrieveUser username   UsernamePasswordAuthenticationToken  authentication   additionalAuthenticationChecks user   UsernamePasswordAuthenticationToken  authentication   has to be changed to that   if cacheWasUsed       There was a problem  so try again after checking we&amp apos re using latest data cacheWasUsed   false  user   retrieveUser username   UsernamePasswordAuthenticationToken  authentication   additionalAuthenticationChecks user   UsernamePasswordAuthenticationToken  authentication     else   throw exception   It ll avoid an useless double check
356	Changes to Authentication leak into synchronous requests when using HttpSessionContextIntegrationFilter  HttpSessionContextIntegrationFilter will read an existing SecurityContext object from the session and attach it to the Http request thread by calling  SecurityContextHolder setContext  This means that simultaneous requests get the same SecurityContext object  If one of those threads changes the authentication attached to the context  for example  to enable some  Run As  functionality such as in org acegisecurity intercept AbstractSecurityInterceptor  that authentication will be seen to change in all the request threads and may enable those threads to be able to gain access that they shouldn t have
398	HttpSessionContextIntegrationFilter AuthenticationProcessingFilter thread concurrency issue  On a successful authentication I occassionally get redirected back to the login page rather than the requested protected resource  This is due to a thread concurrency issue  C  GET  protected resource S  302 Redirect to  login C  GET  login S  200 OK C  POST  j_acegi_security_check     THREAD 1  successful login  S  302 Redirect to  protected resource    THREAD 1 THREAD 1 not finished yet  not reached HttpSessionContextIntegrationFilter post doFilter   block  which means SecurityContext has not been updated with successfull authentication   C  GET  protected resource    THREAD 2 S  302 Redirect to  login    THREAD 2     THREAD 1 completes request and SecurityContext is updated  Solution  Delay the redirects using a response wrapper until after the HttpSessionContextIntegrationFilter has updated the SecurityContext
423	CLONE  SEC 356 Introduces New Bug  Changes to Authentication leak into synchronous requests when using HttpSessionContextIntegrationFilter  HttpSessionContextIntegrationFilter will read an existing SecurityContext object from the session and attach it to the Http request thread by calling  SecurityContextHolder setContext  This means that simultaneous requests get the same SecurityContext object  If one of those threads changes the authentication attached to the context  for example  to enable some  Run As  functionality such as in org acegisecurity intercept AbstractSecurityInterceptor  that authentication will be seen to change in all the request threads and may enable those threads to be able to gain access that they shouldn t have
444	Race condition inside ConcurrentSessionControllerImpl  I was getting SessionAlreadyUsedException on rapid usage  by single user   The strack trace of the exception is below  The problem seems to be the unsynchronized sequence of commands Inside ConcurrentSessionControllerImpl registerSuccessfulAuthentication    sessionRegistry removeSessionInformation sessionId   sessionRegistry registerNewSession sessionId  principal   The registerNewSession   will fail if an other thread registers the same session between these two commands  The strack trace  2007 03 02 16 53 46 204 DEBUG  org acegisecurity ui ExceptionTranslationFilter   http 0 0 0 0 8080 1 Authentication exception occurred  redirecting to authentication entry point org acegisecurity concurrent SessionAlreadyUsedException  Session 1E1B65235B4D42FF17C5F76E7287228D is already is use at org acegisecurity concurrent SessionRegistryImpl registerNewSession SessionRegistryImpl java 121  at org acegisecurity concurrent ConcurrentSessionControllerImpl registerSuccessfulAuthentication ConcurrentSessionControllerImpl java 142  at org acegisecurity providers ProviderManager doAuthentication ProviderManager java 191
618	Authentication details object should be copied to successful Authentication before ConcurrentSessionController checkAuthenticationAllowed is called  If concurrent session control is used with an authentication provider which doesn t copy the authentication details object to the successful authentication  e g  CasAuthenticationProvider  then the check with the concurrent session controller on whether access is allowed takes place before the copyDetails method of AbstractAuthenticationManager is called  This isn t a problem with classes which extend AbstractUserDetailsAuthenticationProvider  as it copies the authentication details object itself  The copyDetails method should probably be pulled down into ProviderManager and called before checkAuthenticationAllowed   is called  This will ensure that the details object is available even if  the provider doesn t set it  It s also not clear that we really need an AbstractAuthenticationManager at all  given how little there is in there
670	Deleting from ACL_OBJECT_IDENTITY can cause deadlocks under  load test While performing load testing  we found concurrent deletes from the ACL_OBJECT_IDENTITY table by the JdbcMutableAclService would cause deadlocks in the database  This is potentially only a problem when using MS SQL server 2000  I haven t tested any other RDBs  The deadlocks were found when simulating only 3 concurrent users  so was relatively easy to reproduce  The deadlocks are caused for several reasons  I ll start with the most serious  deleteAcl ObjectIdentity objectIdentity  boolean deleteChildren  does the following  1 find all children of the ACL 2 optionally delete these recursively     not tested  but would cause deadlocks i think call deleteEntries     performs a select to find Objectidentity pkey deletes from ACL_Entry call deleteObjectIdentityAndOptionallyClass     performs a select to find Objectidentity pkey deletes from ACL_OBJECT_IDENTITY selects from ACL_OBJECT_IDENTITY to see if the entry deleted was the last from a particular class deletes from ACL_CLASS  dependent on outcome of previous select   In MS SQL server the best practise is to perform all selects first  then do deletes  interleaving selects and deletes is a recipe for deadlocks  After some reorganisation of the above operations  we also found another deadlock caused by the database this time internally  where 2 concurrent deletes on the ACL_OBJECT_IDENTITY table when the DB was checking the foreign key to  parent object   which we had to solve with a synchronized  I ve pasted our fixed code below  not that it no longer deletes from the ACL_CLASS table if the ACL_OBJECT_IDENTITY row is that last one that referenced it  as I find this a waste of time  you may not agree    it this may cause issues with a coinciding insert into ACL_OBJECT_IDENTITY  untested and not fully thought through   Also if deleteChildren was passed as true  I m sure the deadlocks would still occur        Deletes the the ACL for the specified   link ObjectIdentity   &lt br&gt    NOTE  Passing deleteChildren as &lt code&gt true&lt  code&gt  can cause deadlocks at   the database  as this uses recursion on this method resulting in   select  delete  select    sequences of JDBC calls which is a recipe for   deadlocks  at least on MS SQL server  under heavy load       param objectIdentity    param deleteChildren    throws ChildrenExistException    public void deleteAcl ObjectIdentity objectIdentity  boolean deleteChildren  throws ChildrenExistException   Assert notNull objectIdentity   Object Identity required    Assert notNull objectIdentity getIdentifier     Object Identity doesn&amp apos t provide an identifier     if  deleteChildren       deadlock territory ObjectIdentity   children   findChildren objectIdentity   for  int i   0  i &lt  children length  i      deleteAcl children i   true           we could have placed the find children outside the if and used it to    check for children  but this has been found to cause the occasional    deadlock in MS SQL server  so we&amp apos ll just let the FK do the checking for    us   After all that&amp apos s what it&amp apos s for  Long oidPkey   retrieveObjectIdentityPrimaryKey objectIdentity       Delete this ACL&amp apos s ACEs in the acl_entry table deleteEntries oidPkey       Delete this ACL&amp apos s acl_object_identity row deleteObjectIdentity oidPkey       Clear the cache aclCache evictFromCache objectIdentity            Deletes all ACEs defined in the acl_entry table belonging to the presented   ObjectIdentity      param oid              the rows in acl_entry to delete    protected void deleteEntries ObjectIdentity oid    this deleteEntries retrieveObjectIdentityPrimaryKey oid       private void deleteEntries Long oidPKey    jdbcTemplate update deleteEntryByObjectIdentityForeignKey  new Object     oidPKey              Deletes a single row from acl_object_identity that is associated with the   presented ObjectIdentity  &lt br&gt    Does not delete the from the ACL_CLASS table if   the   link ObjectIdentity  deleted is the last of that class  as this would require a select after a delete  which can cause deadlocks on some RDB s  and potentially another thread creating an ACL may have checked that ACL_CLASS row exist and is waiting to insert would experience problems  Also note that this method is synchronised  this is yet another deadlock avoidance manoeuvre  here s why  The ACL_OBJECT_IDENTITY table has a foreign key back to itself  to support hierarchical ACLs   and this can cause the following situation  Thread 1  T1  is attempting to delete row X  so obtains an exclusive page lock on row X  and some of it close buddies   Thread 1  T2  is attempting to delete row Y  so obtains an exclusive page lock on row Y  and some of it close buddies   T2 now performs a table scan to ensure the FK from PARENT_OBJECT back to ID  same table remember  is not violated by removal of row Y  but has to wait for the exclusive lock held by T1 to be released  T1 now performs a table scan to ensure the FK from PARENT_OBJECT back to ID  same table remember  is not violated by removal of row X  but has to wait for the exclusive lock held by T2 to be released  This has been observed using MS SQL Server  under load testing     param oidPKey The primary key of the object identity to delete that class name if appropriate     protected synchronized void deleteObjectIdentity Long oidPKey  Unknown macro          Delete the acl_object_identity row    jdbcTemplate update deleteObjectIdentityByPrimaryKey                         new Object     oidPKey              Retrieves the primary key from the acl_object_identity table for the passed ObjectIdentity  Unlike some other methods in this implementation  this method will NOT create a row  use   link    createObjectIdentity ObjectIdentity  Sid   instead     param oid to find   return the object identity or null if not found    protected Long retrieveObjectIdentityPrimaryKey ObjectIdentity oid    try Unknown macro         return new Long jdbcTemplate           queryForLong selectObjectIdentityPrimaryKey  new Object     oid getJavaType   getName    oid getIdentifier             catch  DataAccessException notFound    return null
809	Concurrent Session Control and OpenID Incompatibility  Hi  The openid sample worked fine for me  I tried to use the Concurrent Session Control but it doesn t work  The following post has the same bug   http   forum springframework org showthread php p 177626  Solution proposed is to update the OpenIDAuthenticationProcessingFilter and to populate details before call to the authenticationManager  this way   token setDetails authenticationDetailsSource buildDetails req    Not sure what uNcode suggests is the good  way to fix it  Could be related to http   jira springframework org browse SEC 618 Here is my SS configuration  really basic  based on the sample openid                                          &lt http&gt  &lt intercept url pattern       access  ROLE_USER   &gt  &lt logout  &gt  &lt openid login login page   openidlogin jsp   &gt  &lt concurrent session control max sessions  1  exception if maximum exceeded  true  &gt  &lt  http&gt  &lt authentication manager alias  authenticationManager   &gt  &lt user service id  userService &gt  &lt user name  http   MYACCOUNT myopenid com   password  notused  authorities  ROLE_SUPERVISOR ROLE_USER   &gt  &lt  user service&gt  Here is my stack trace                                    java lang IllegalArgumentException  Authentication getDetails   required at org springframework util Assert notNull Assert java 112  at org springframework security concurrent SessionRegistryUtils obtainSessionIdFromAuthentication SessionRegistryUtils java 52  at org springframework security concurrent ConcurrentSessionControllerImpl checkAuthenticationAllowed ConcurrentSessionControllerImpl java 92  at org springframework security providers ProviderManager doAuthentication ProviderManager java 199  at org springframework security AbstractAuthenticationManager authenticate AbstractAuthenticationManager java 46  at org springframework security ui openid OpenIDAuthenticationProcessingFilter attemptAuthentication OpenIDAuthenticationProcessingFilter java 82  at org springframework security ui AbstractProcessingFilter doFilterHttp AbstractProcessingFilter java 249  at org springframework security ui SpringSecurityFilter doFilter SpringSecurityFilter java 53  at org springframework security util FilterChainProxy VirtualFilterChain doFilter FilterChainProxy java 371  at org springframework security ui logout LogoutFilter doFilterHttp LogoutFilter java 87  at org springframework security ui SpringSecurityFilter doFilter SpringSecurityFilter java 53  at org springframework security util FilterChainProxy VirtualFilterChain doFilter FilterChainProxy java 371  at org springframework security ui SessionFixationProtectionFilter doFilterHttp SessionFixationProtectionFilter java 68  at org springframework security ui SpringSecurityFilter doFilter SpringSecurityFilter java 53  at org springframework security util FilterChainProxy VirtualFilterChain doFilter FilterChainProxy java 371  at org springframework security context HttpSessionContextIntegrationFilter doFilterHttp HttpSessionContextIntegrationFilter java 229  at org springframework security ui SpringSecurityFilter doFilter SpringSecurityFilter java 53  at org springframework security util FilterChainProxy VirtualFilterChain doFilter FilterChainProxy java 371  at org springframework security concurrent ConcurrentSessionFilter doFilterHttp ConcurrentSessionFilter java 97  at org springframework security ui SpringSecurityFilter doFilter SpringSecurityFilter java 53  at org springframework security util FilterChainProxy VirtualFilterChain doFilter FilterChainProxy java 371  at org springframework security securechannel ChannelProcessingFilter doFilterHttp ChannelProcessingFilter java 116  at org springframework security ui SpringSecurityFilter doFilter SpringSecurityFilter java 53  at org springframework security util FilterChainProxy VirtualFilterChain doFilter FilterChainProxy java 371  at org springframework security util FilterChainProxy doFilter FilterChainProxy java 174  at org springframework web filter DelegatingFilterProxy invokeDelegate DelegatingFilterProxy java 183  at org springframework web filter DelegatingFilterProxy doFilter DelegatingFilterProxy java 138
1396	Race condition between HttpSessionContextIntegrationFilter and SessionFixationProtectionFilter  There seems to be a race condition between processing in the HttpSessionContextIntegrationFilter and the SessionFixationProtectionFilter  Here is our problem  We have a web application with a fairly heavy home page that can be served quite slowly depending on the size of certain attributes associated with the user   We are currently using Jetty 6 1 21 which supports HTTP 1 1 chunked responses  If a user opens their browser and goes directly to the home page URL using a RememberMe token  this initial web request executes down through the filter stack and into the Spring MVC framework   Steps 1a   1d describe the processing of this initial request  1a  The HttpSessionContextIntegration filter creates a new HttpSession and puts a default SecurityContext into the ThreadLocal handler  1b  The RememberMeProcessingFilter authenticates the token and sets the user s Authentication object into the ThreadLocal handler  1c  The SessionFixationProtectionFilter detects a new authentication  invalidates the existing HttpSession  and creates a new HttpSession  migrating the attributes    It does not set the user s Authentication into the HttpSession  this is supposed to be done by the HttpSessionContextIntegration after all request processing is complete  1d  The request goes into the Spring MVC framework  causing a response to start to be sent to the client using HTTP chunking   This response includes the session id of the newly created session  created by the SessionFixationProtectionFilter   The client begins receiving the markup  which includes various  script  elements to script files served by the web app   Steps 2a   2c describe the processing of this second request   This processing takes place while the initial request is still being processed   This second request sends over the session id created by the SessionFixationProtectionFilter for the first request  2a  The HttpSessionContextIntegration puts a default SecurityContext into the ThreadLocal handler  since one has not yet been set into the HttpSession   2b  The RememberMeProcessingFilter authenticates the token and sets the user s Authentication object into the ThreadLocal handler  2c  The SessionFixationProtectionFilter detects another new authentication  invalidates the existing HttpSession  and creates a new HttpSession  migrating the attributes   Processing of the initial web request is continuing through the Spring MVC framework   We happen to use JSP for our view technology  1e  Continued processing of a JSP page  or import  for the initial request causes an attempt to deference a variable  causing a IllegalStateException in Jetty&amp apos s AbstractSessionManager Session class  I can  fix  this by extending the SessionFixationProtectionFilter and overriding protected void startNewSessionIfRequired  HttpServletRequest request  HttpServletResponse response    super startNewSessionIfRequired request  response   request getSession   setAttribute  HttpSessionContextIntegrationFilter SPRING_SECURITY_CONTEXT_KEY  SecurityContextHolder getContext   getAuthentication       so that the user s Authentication object is stored into the HttpSession before processing enters the Spring MVC framework  causing the execution of filters on the second request to not be considered a new authentication  thus preserving the validity of the session created during the initial request  Is this the right way to do this   It seems to keep session fixation protection working the way it is supposed to  but I m a little worried about what will happen with the OnRedirectUpdateSessionResponseWrapper created by the HttpSessionContextIntegrationFilter if the request processing results in a sendError   or sendRedirect    My casual reading of HttpSessionContextIntegrationFilter seems to indicate it would still work correctly  Any thoughts or advice would be appreciated
2067	Security context incorrectly removed from session when asynchronous servlet used  Take the following sample servlet         Override     protected void doGet final HttpServletRequest req  final HttpServletResponse resp  throws ServletException  IOException       req startAsync        new Thread  AsyncThread          Override     public void run         try       TimeUnit SECONDS sleep 1       resp getOutputStream   flush          catch  Exception e        e printStackTrace                      start                As you can see it does nothing except flushing after one second in a separate thread  However this servlet is secured by Spring Security so the resp getOutputStream   stream is actually an instance of org springframework security web context SaveContextOnUpdateOrErrorResponseWrapper SaveContextServletOutputStream  This class calls org springframework security web context HttpSessionSecurityContextRepository SaveToSessionResponseWrapper saveContext   on flush    That&amp apos s where the bug is  This method under certain conditions removes security context from session        httpSession removeAttribute springSecurityContextKey        This method was heavily rewritten lately  see  See SEC 776  SEC 1587 and SEC 1735  so I can t tell where the actually bug lies  All I see is that since it can t find security context in thread local holder  we are flushing from a different thread   it removes the context from the session as well  Basically asynchronous servlet logs me out from the application  I extracted the error and prepared sample  simplistic application exposing that bug  attached   I actually run into it when using Atmosphere Comet library together with Spring Security  but this application shows exact same error  Extract and call mvn tomcat7 run  Only one Java class  browse to localhost 8080  login using admin admin and follow instructions to reproduce
3108	DigestAuthenticationFilter should use SecurityContextHolder createEmptyContext    When using Digest authentication and there are concurrent requests from the same session  it is possible that the Authentication object returned by SessionContextHolder getContext   getAuthentication   does not have its authorities set  Then  e g  HttpServletRequest isUserInRole   returns sometimes incorrectly false even if the user actually has that role  This happens because with Digest authentication  constructing the Authentication object is done in two steps  but the incomplete Authentication object is made visible to another threads after first step  Consider the following scenario   User logs in to the system  a session is created  JSESSIONID is set  and user uses the system for some time  User makes request 1 to the server  This request has a header  Authorization  Digest      DigestAuthenticationFilter starts the authentication process and places an incomplete Authentication object  without authorities  into SecurityContext  Simultaneously with request 1  the same user makes request 2 to the server  This request does not have  Authorization  Digest      header  so no re authentication is done  While processing request 2  request isUserInRole   returns now false  because the Authentication object in SecurityContext does not have any authorities  User gets incorrectly a 403 Forbidden response  Request 1 continues the authentication process  and in AbstractSecurityInterceptor  a fully populated Authentication object is created and put into SecurityContext   I could set createAuthenticatedToken   true in DigestAuthenticationFilter  but the comment on the set method says that user flags like isEnabled   or isAccountNonExpired   are not checked in that case  so this is not a solution
3109	Concurrent ThreadPoolTaskScheduler don t work with DelegatingSecurityContextExecutorWe have a setup with Spring Boot with scheduling  To use method security with background jobs we want to use the DelegatingSecurityContextScheduledExecutorService like described here  http   www petrikainulainen net programming spring framework spring from the trenches invoking a secured method from a scheduled job   see  Spring Security 3 2  It Is Almost Like Magic!    I suspect this stopped working with SEC 3031  because now DelegatingSecurityContextRunnable Callable doesn t set clear the security context if run on the same thread as they were created  As Concurrent TheadPoolTaskScheduler uses a ReschedulingRunnable for the trigger mechanic  we use cron triggers   so the rescheduling is done on the pool thread  So random subsequent calls executed on the same pool thread might fail  because the SecurityContext is not set  Getting DelegatingSecurityContextExecutor to set the enableOnOriginalThread property on DelegatingSecurityContextRunnable to true would fix that issue